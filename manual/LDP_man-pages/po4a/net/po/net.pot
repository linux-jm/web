# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-03-12 14:01+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man7/arp.7:12
#, no-wrap
msgid "ARP"
msgstr ""

#. type: TH
#: build/C/man7/arp.7:12 build/C/man7/netdevice.7:17 build/C/man7/raw.7:12 build/C/man5/resolv.conf.5:23
#, no-wrap
msgid "2020-08-13"
msgstr ""

#. type: TH
#: build/C/man7/arp.7:12 build/C/man3/bswap.3:25 build/C/man3/cmsg.3:11 build/C/man7/ddp.7:12 build/C/man5/gai.conf.5:19 build/C/man1/getent.1:25 build/C/man3/getipnodebyname.3:26 build/C/man2/getpeername.2:42 build/C/man5/host.conf.5:26 build/C/man7/hostname.7:39 build/C/man5/hosts.5:27 build/C/man5/hosts.equiv.5:6 build/C/man7/icmp.7:12 build/C/man3/inet_net_pton.3:25 build/C/man3/inet_ntop.3:26 build/C/man3/inet_pton.3:27 build/C/man7/ip.7:42 build/C/man7/ipv6.7:86 build/C/man7/netdevice.7:17 build/C/man5/nss.5:19 build/C/man5/nsswitch.conf.5:25 build/C/man7/packet.7:12 build/C/man5/protocols.5:29 build/C/man7/raw.7:12 build/C/man3/rcmd.3:43 build/C/man3/rexec.3:41 build/C/man5/services.5:34 build/C/man2/shutdown.2:40 build/C/man7/tcp.7:96 build/C/man7/udp.7:12 build/C/man7/udplite.7:27 build/C/man7/unix.7:20 build/C/man7/x25.7:12
#, no-wrap
msgid "Linux"
msgstr ""

#. type: TH
#: build/C/man7/arp.7:12 build/C/man3/bswap.3:25 build/C/man3/byteorder.3:32 build/C/man3/cmsg.3:11 build/C/man7/ddp.7:12 build/C/man3/endian.3:28 build/C/man3/ether_aton.3:31 build/C/man5/gai.conf.5:19 build/C/man3/getaddrinfo.3:44 build/C/man3/getaddrinfo_a.3:30 build/C/man3/gethostbyname.3:38 build/C/man3/getipnodebyname.3:26 build/C/man3/getnameinfo.3:10 build/C/man3/getnetent.3:30 build/C/man3/getnetent_r.3:26 build/C/man2/getpeername.2:42 build/C/man3/getprotoent.3:30 build/C/man3/getprotoent_r.3:26 build/C/man3/getservent.3:34 build/C/man3/getservent_r.3:26 build/C/man7/hostname.7:39 build/C/man5/hosts.5:27 build/C/man5/hosts.equiv.5:6 build/C/man7/icmp.7:12 build/C/man3/inet.3:42 build/C/man3/inet_net_pton.3:25 build/C/man3/inet_ntop.3:26 build/C/man3/inet_pton.3:27 build/C/man7/ip.7:42 build/C/man7/ipv6.7:86 build/C/man7/netdevice.7:17 build/C/man8/nscd.8:23 build/C/man5/nscd.conf.5:20 build/C/man5/nss.5:19 build/C/man5/nsswitch.conf.5:25 build/C/man7/packet.7:12 build/C/man5/protocols.5:29 build/C/man7/raw.7:12 build/C/man3/rcmd.3:43 build/C/man5/resolv.conf.5:23 build/C/man3/resolver.3:33 build/C/man3/rexec.3:41 build/C/man5/services.5:34 build/C/man3/setnetgrent.3:10 build/C/man2/shutdown.2:40 build/C/man7/tcp.7:96 build/C/man7/udp.7:12 build/C/man7/udplite.7:27 build/C/man7/unix.7:20 build/C/man7/x25.7:12
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr ""

#. type: SH
#: build/C/man7/arp.7:13 build/C/man3/bswap.3:26 build/C/man3/byteorder.3:33 build/C/man3/cmsg.3:12 build/C/man7/ddp.7:13 build/C/man3/endian.3:29 build/C/man3/ether_aton.3:32 build/C/man5/gai.conf.5:20 build/C/man3/getaddrinfo.3:45 build/C/man3/getaddrinfo_a.3:31 build/C/man1/getent.1:26 build/C/man3/gethostbyname.3:39 build/C/man3/getipnodebyname.3:27 build/C/man3/getnameinfo.3:11 build/C/man3/getnetent.3:31 build/C/man3/getnetent_r.3:27 build/C/man2/getpeername.2:43 build/C/man3/getprotoent.3:31 build/C/man3/getprotoent_r.3:27 build/C/man3/getservent.3:35 build/C/man3/getservent_r.3:27 build/C/man5/host.conf.5:27 build/C/man7/hostname.7:40 build/C/man5/hosts.5:28 build/C/man5/hosts.equiv.5:7 build/C/man7/icmp.7:13 build/C/man3/inet.3:43 build/C/man3/inet_net_pton.3:26 build/C/man3/inet_ntop.3:27 build/C/man3/inet_pton.3:28 build/C/man7/ip.7:43 build/C/man7/ipv6.7:87 build/C/man7/netdevice.7:18 build/C/man5/networks.5:27 build/C/man8/nscd.8:24 build/C/man5/nscd.conf.5:21 build/C/man5/nss.5:20 build/C/man5/nsswitch.conf.5:26 build/C/man7/packet.7:13 build/C/man5/protocols.5:30 build/C/man7/raw.7:13 build/C/man3/rcmd.3:44 build/C/man5/resolv.conf.5:25 build/C/man3/resolver.3:34 build/C/man3/rexec.3:42 build/C/man5/services.5:35 build/C/man3/setnetgrent.3:11 build/C/man2/shutdown.2:41 build/C/man7/tcp.7:97 build/C/man7/udp.7:13 build/C/man7/udplite.7:28 build/C/man7/unix.7:21 build/C/man7/x25.7:13
#, no-wrap
msgid "NAME"
msgstr ""

#. type: Plain text
#: build/C/man7/arp.7:15
msgid "arp - Linux ARP kernel module."
msgstr ""

#. type: SH
#: build/C/man7/arp.7:15 build/C/man3/bswap.3:36 build/C/man3/byteorder.3:48 build/C/man3/cmsg.3:25 build/C/man7/ddp.7:23 build/C/man3/endian.3:76 build/C/man3/ether_aton.3:57 build/C/man5/gai.conf.5:22 build/C/man3/getaddrinfo.3:75 build/C/man3/getaddrinfo_a.3:51 build/C/man1/getent.1:30 build/C/man3/gethostbyname.3:141 build/C/man3/getipnodebyname.3:44 build/C/man3/getnameinfo.3:33 build/C/man3/getnetent.3:48 build/C/man3/getnetent_r.3:63 build/C/man2/getpeername.2:50 build/C/man3/getprotoent.3:48 build/C/man3/getprotoent_r.3:60 build/C/man3/getservent.3:52 build/C/man3/getservent_r.3:60 build/C/man5/host.conf.5:29 build/C/man7/hostname.7:42 build/C/man5/hosts.5:32 build/C/man5/hosts.equiv.5:11 build/C/man7/icmp.7:15 build/C/man3/inet.3:80 build/C/man3/inet_net_pton.3:60 build/C/man3/inet_ntop.3:36 build/C/man3/inet_pton.3:36 build/C/man7/ip.7:59 build/C/man7/ipv6.7:99 build/C/man7/netdevice.7:24 build/C/man5/networks.5:29 build/C/man8/nscd.8:26 build/C/man5/nscd.conf.5:23 build/C/man5/nss.5:22 build/C/man5/nsswitch.conf.5:28 build/C/man7/packet.7:23 build/C/man5/protocols.5:32 build/C/man7/raw.7:21 build/C/man3/rcmd.3:95 build/C/man5/resolv.conf.5:29 build/C/man3/resolver.3:110 build/C/man3/rexec.3:64 build/C/man5/services.5:37 build/C/man3/setnetgrent.3:47 build/C/man2/shutdown.2:47 build/C/man7/tcp.7:107 build/C/man7/udp.7:23 build/C/man7/udplite.7:38 build/C/man7/unix.7:31 build/C/man7/x25.7:21
#, no-wrap
msgid "DESCRIPTION"
msgstr ""

#. type: Plain text
#: build/C/man7/arp.7:23
msgid ""
"This kernel protocol module implements the Address Resolution Protocol "
"defined in RFC\\ 826.  It is used to convert between Layer2 hardware "
"addresses and IPv4 protocol addresses on directly connected networks.  The "
"user normally doesn't interact directly with this module except to configure "
"it; instead it provides a service for other protocols in the kernel."
msgstr ""

#. type: Plain text
#: build/C/man7/arp.7:36
msgid ""
"A user process can receive ARP packets by using B<packet>(7)  sockets.  "
"There is also a mechanism for managing the ARP cache in user-space by using "
"B<netlink>(7)  sockets.  The ARP table can also be controlled via "
"B<ioctl>(2)  on any B<AF_INET> socket."
msgstr ""

#. type: Plain text
#: build/C/man7/arp.7:48
msgid ""
"The ARP module maintains a cache of mappings between hardware addresses and "
"protocol addresses.  The cache has a limited size so old and less frequently "
"used entries are garbage-collected.  Entries which are marked as permanent "
"are never deleted by the garbage-collector.  The cache can be directly "
"manipulated by the use of ioctls and its behavior can be tuned by the "
"I</proc> interfaces described below."
msgstr ""

#. type: Plain text
#: build/C/man7/arp.7:71
msgid ""
"When there is no positive feedback for an existing mapping after some time "
"(see the I</proc> interfaces below), a neighbor cache entry is considered "
"stale.  Positive feedback can be gotten from a higher layer; for example "
"from a successful TCP ACK.  Other protocols can signal forward progress "
"using the B<MSG_CONFIRM> flag to B<sendmsg>(2).  When there is no forward "
"progress, ARP tries to reprobe.  It first tries to ask a local arp daemon "
"B<app_solicit> times for an updated MAC address.  If that fails and an old "
"MAC address is known, a unicast probe is sent B<ucast_solicit> times.  If "
"that fails too, it will broadcast a new ARP request to the network.  "
"Requests are sent only when there is data queued for sending."
msgstr ""

#. type: Plain text
#: build/C/man7/arp.7:76
msgid ""
"Linux will automatically add a nonpermanent proxy arp entry when it receives "
"a request for an address it forwards to and proxy arp is enabled on the "
"receiving interface.  When there is a reject route for the target, no proxy "
"arp entry is added."
msgstr ""

#. type: SS
#: build/C/man7/arp.7:76 build/C/man7/ddp.7:144 build/C/man7/ip.7:1222 build/C/man7/netdevice.7:63 build/C/man7/packet.7:495 build/C/man7/tcp.7:1241 build/C/man7/udp.7:207 build/C/man7/unix.7:636
#, no-wrap
msgid "Ioctls"
msgstr ""

#. type: Plain text
#: build/C/man7/arp.7:83
msgid ""
"Three ioctls are available on all B<AF_INET> sockets.  They take a pointer "
"to a I<struct arpreq> as their argument."
msgstr ""

#. type: Plain text
#: build/C/man7/arp.7:93
#, no-wrap
msgid ""
"struct arpreq {\n"
"    struct sockaddr arp_pa;      /* protocol address */\n"
"    struct sockaddr arp_ha;      /* hardware address */\n"
"    int             arp_flags;   /* flags */\n"
"    struct sockaddr arp_netmask; /* netmask of protocol address */\n"
"    char            arp_dev[16];\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/arp.7:102
msgid ""
"B<SIOCSARP>, B<SIOCDARP> and B<SIOCGARP> respectively set, delete and get an "
"ARP mapping.  Setting and deleting ARP maps are privileged operations and "
"may be performed only by a process with the B<CAP_NET_ADMIN> capability or "
"an effective UID of 0."
msgstr ""

#. type: Plain text
#: build/C/man7/arp.7:112
msgid ""
"I<arp_pa> must be an B<AF_INET> address and I<arp_ha> must have the same "
"type as the device which is specified in I<arp_dev>.  I<arp_dev> is a "
"zero-terminated string which names a device."
msgstr ""

#. type: tbl table
#: build/C/man7/arp.7:117
#, no-wrap
msgid "I<arp_flags>"
msgstr ""

#. type: tbl table
#: build/C/man7/arp.7:118
#, no-wrap
msgid "flag"
msgstr ""

#. type: tbl table
#: build/C/man7/arp.7:118
#, no-wrap
msgid "meaning"
msgstr ""

#. type: tbl table
#: build/C/man7/arp.7:119
#, no-wrap
msgid "ATF_COM"
msgstr ""

#. type: tbl table
#: build/C/man7/arp.7:119
#, no-wrap
msgid "Lookup complete"
msgstr ""

#. type: tbl table
#: build/C/man7/arp.7:120
#, no-wrap
msgid "ATF_PERM"
msgstr ""

#. type: tbl table
#: build/C/man7/arp.7:120
#, no-wrap
msgid "Permanent entry"
msgstr ""

#. type: tbl table
#: build/C/man7/arp.7:121
#, no-wrap
msgid "ATF_PUBL"
msgstr ""

#. type: tbl table
#: build/C/man7/arp.7:121
#, no-wrap
msgid "Publish entry"
msgstr ""

#. type: tbl table
#: build/C/man7/arp.7:122
#, no-wrap
msgid "ATF_USETRAILERS"
msgstr ""

#. type: tbl table
#: build/C/man7/arp.7:122
#, no-wrap
msgid "Trailers requested"
msgstr ""

#. type: tbl table
#: build/C/man7/arp.7:123
#, no-wrap
msgid "ATF_NETMASK"
msgstr ""

#. type: tbl table
#: build/C/man7/arp.7:123
#, no-wrap
msgid "Use a netmask"
msgstr ""

#. type: tbl table
#: build/C/man7/arp.7:124
#, no-wrap
msgid "ATF_DONTPUB"
msgstr ""

#. type: tbl table
#: build/C/man7/arp.7:124
#, no-wrap
msgid "Don't answer"
msgstr ""

#. type: Plain text
#: build/C/man7/arp.7:137
msgid ""
"If the B<ATF_NETMASK> flag is set, then I<arp_netmask> should be valid.  "
"Linux 2.2 does not support proxy network ARP entries, so this should be set "
"to 0xffffffff, or 0 to remove an existing proxy arp entry.  "
"B<ATF_USETRAILERS> is obsolete and should not be used."
msgstr ""

#. type: SS
#: build/C/man7/arp.7:137 build/C/man7/ddp.7:122 build/C/man7/icmp.7:41 build/C/man7/ip.7:1073 build/C/man7/tcp.7:247 build/C/man7/udp.7:137
#, no-wrap
msgid "/proc interfaces"
msgstr ""

#. type: Plain text
#: build/C/man7/arp.7:150
msgid ""
"ARP supports a range of I</proc> interfaces to configure parameters on a "
"global or per-interface basis.  The interfaces can be accessed by reading or "
"writing the I</proc/sys/net/ipv4/neigh/*/*> files.  Each interface in the "
"system has its own directory in I</proc/sys/net/ipv4/neigh/>.  The setting "
"in the \"default\" directory is used for all newly created devices.  Unless "
"otherwise specified, time-related interfaces are specified in seconds."
msgstr ""

#. type: TP
#: build/C/man7/arp.7:150
#, no-wrap
msgid "I<anycast_delay> (since Linux 2.2)"
msgstr ""

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:157
msgid ""
"The maximum number of jiffies to delay before replying to a IPv6 neighbor "
"solicitation message.  Anycast support is not yet implemented.  Defaults to "
"1 second."
msgstr ""

#. type: TP
#: build/C/man7/arp.7:157
#, no-wrap
msgid "I<app_solicit> (since Linux 2.2)"
msgstr ""

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:164
msgid ""
"The maximum number of probes to send to the user space ARP daemon via "
"netlink before dropping back to multicast probes (see I<mcast_solicit>).  "
"Defaults to 0."
msgstr ""

#. type: TP
#: build/C/man7/arp.7:164
#, no-wrap
msgid "I<base_reachable_time> (since Linux 2.2)"
msgstr ""

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:175
msgid ""
"Once a neighbor has been found, the entry is considered to be valid for at "
"least a random value between I<base_reachable_time>/2 and "
"3*I<base_reachable_time>/2.  An entry's validity will be extended if it "
"receives positive feedback from higher level protocols.  Defaults to 30 "
"seconds.  This file is now obsolete in favor of I<base_reachable_time_ms>."
msgstr ""

#. type: TP
#: build/C/man7/arp.7:175
#, no-wrap
msgid "I<base_reachable_time_ms> (since Linux 2.6.12)"
msgstr ""

#. type: Plain text
#: build/C/man7/arp.7:181
msgid ""
"As for I<base_reachable_time>, but measures time in milliseconds.  Defaults "
"to 30000 milliseconds."
msgstr ""

#. type: TP
#: build/C/man7/arp.7:181
#, no-wrap
msgid "I<delay_first_probe_time> (since Linux 2.2)"
msgstr ""

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:187
msgid ""
"Delay before first probe after it has been decided that a neighbor is "
"stale.  Defaults to 5 seconds."
msgstr ""

#. type: TP
#: build/C/man7/arp.7:187
#, no-wrap
msgid "I<gc_interval> (since Linux 2.2)"
msgstr ""

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:193
msgid ""
"How frequently the garbage collector for neighbor entries should attempt to "
"run.  Defaults to 30 seconds."
msgstr ""

#. type: TP
#: build/C/man7/arp.7:193
#, no-wrap
msgid "I<gc_stale_time> (since Linux 2.2)"
msgstr ""

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:200
msgid ""
"Determines how often to check for stale neighbor entries.  When a neighbor "
"entry is considered stale, it is resolved again before sending data to it.  "
"Defaults to 60 seconds."
msgstr ""

#. type: TP
#: build/C/man7/arp.7:200
#, no-wrap
msgid "I<gc_thresh1> (since Linux 2.2)"
msgstr ""

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:207
msgid ""
"The minimum number of entries to keep in the ARP cache.  The garbage "
"collector will not run if there are fewer than this number of entries in the "
"cache.  Defaults to 128."
msgstr ""

#. type: TP
#: build/C/man7/arp.7:207
#, no-wrap
msgid "I<gc_thresh2> (since Linux 2.2)"
msgstr ""

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:214
msgid ""
"The soft maximum number of entries to keep in the ARP cache.  The garbage "
"collector will allow the number of entries to exceed this for 5 seconds "
"before collection will be performed.  Defaults to 512."
msgstr ""

#. type: TP
#: build/C/man7/arp.7:214
#, no-wrap
msgid "I<gc_thresh3> (since Linux 2.2)"
msgstr ""

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:221
msgid ""
"The hard maximum number of entries to keep in the ARP cache.  The garbage "
"collector will always run if there are more than this number of entries in "
"the cache.  Defaults to 1024."
msgstr ""

#. type: TP
#: build/C/man7/arp.7:221
#, no-wrap
msgid "I<locktime> (since Linux 2.2)"
msgstr ""

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:228
msgid ""
"The minimum number of jiffies to keep an ARP entry in the cache.  This "
"prevents ARP cache thrashing if there is more than one potential mapping "
"(generally due to network misconfiguration).  Defaults to 1 second."
msgstr ""

#. type: TP
#: build/C/man7/arp.7:228
#, no-wrap
msgid "I<mcast_solicit> (since Linux 2.2)"
msgstr ""

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:234
msgid ""
"The maximum number of attempts to resolve an address by multicast/broadcast "
"before marking the entry as unreachable.  Defaults to 3."
msgstr ""

#. type: TP
#: build/C/man7/arp.7:234
#, no-wrap
msgid "I<proxy_delay> (since Linux 2.2)"
msgstr ""

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:242
msgid ""
"When an ARP request for a known proxy-ARP address is received, delay up to "
"I<proxy_delay> jiffies before replying.  This is used to prevent network "
"flooding in some cases.  Defaults to 0.8 seconds."
msgstr ""

#. type: TP
#: build/C/man7/arp.7:242
#, no-wrap
msgid "I<proxy_qlen> (since Linux 2.2)"
msgstr ""

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:247
msgid ""
"The maximum number of packets which may be queued to proxy-ARP addresses.  "
"Defaults to 64."
msgstr ""

#. type: TP
#: build/C/man7/arp.7:247
#, no-wrap
msgid "I<retrans_time> (since Linux 2.2)"
msgstr ""

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:254
msgid ""
"The number of jiffies to delay before retransmitting a request.  Defaults to "
"1 second.  This file is now obsolete in favor of I<retrans_time_ms>."
msgstr ""

#. type: TP
#: build/C/man7/arp.7:254
#, no-wrap
msgid "I<retrans_time_ms> (since Linux 2.6.12)"
msgstr ""

#. type: Plain text
#: build/C/man7/arp.7:258
msgid ""
"The number of milliseconds to delay before retransmitting a request.  "
"Defaults to 1000 milliseconds."
msgstr ""

#. type: TP
#: build/C/man7/arp.7:258
#, no-wrap
msgid "I<ucast_solicit> (since Linux 2.2)"
msgstr ""

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:265
msgid ""
"The maximum number of attempts to send unicast probes before asking the ARP "
"daemon (see I<app_solicit>).  Defaults to 3."
msgstr ""

#. type: TP
#: build/C/man7/arp.7:265
#, no-wrap
msgid "I<unres_qlen> (since Linux 2.2)"
msgstr ""

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:271
msgid ""
"The maximum number of packets which may be queued for each unresolved "
"address by other network layers.  Defaults to 3."
msgstr ""

#. type: SH
#: build/C/man7/arp.7:271 build/C/man7/ddp.7:218 build/C/man3/endian.3:97 build/C/man5/gai.conf.5:74 build/C/man3/getnameinfo.3:204 build/C/man7/icmp.7:166 build/C/man7/ipv6.7:362 build/C/man7/packet.7:548 build/C/man7/raw.7:180 build/C/man3/rcmd.3:264 build/C/man3/rexec.3:146 build/C/man7/tcp.7:1358 build/C/man7/udp.7:256 build/C/man7/udplite.7:133 build/C/man7/unix.7:804 build/C/man7/x25.7:100
#, no-wrap
msgid "VERSIONS"
msgstr ""

#. type: Plain text
#: build/C/man7/arp.7:278
msgid ""
"The I<struct arpreq> changed in Linux 2.0 to include the I<arp_dev> member "
"and the ioctl numbers changed at the same time.  Support for the old ioctls "
"was dropped in Linux 2.2."
msgstr ""

#. type: Plain text
#: build/C/man7/arp.7:284
msgid ""
"Support for proxy arp entries for networks (netmask not equal 0xffffffff)  "
"was dropped in Linux 2.2.  It is replaced by automatic proxy arp setup by "
"the kernel for all reachable hosts on other interfaces (when forwarding and "
"proxy arp is enabled for the interface)."
msgstr ""

#. type: Plain text
#: build/C/man7/arp.7:288
msgid "The I<neigh/*> interfaces did not exist before Linux 2.2."
msgstr ""

#. type: SH
#: build/C/man7/arp.7:288 build/C/man7/ddp.7:241 build/C/man3/ether_aton.3:151 build/C/man3/gethostbyname.3:531 build/C/man3/inet_ntop.3:125 build/C/man3/inet_pton.3:164 build/C/man7/ip.7:1392 build/C/man7/ipv6.7:406 build/C/man7/netdevice.7:357 build/C/man7/packet.7:619 build/C/man7/raw.7:257 build/C/man3/rcmd.3:305 build/C/man3/rexec.3:172 build/C/man2/shutdown.2:105 build/C/man7/tcp.7:1365 build/C/man7/udplite.7:135 build/C/man7/unix.7:830 build/C/man7/x25.7:102
#, no-wrap
msgid "BUGS"
msgstr ""

#. type: Plain text
#: build/C/man7/arp.7:292
msgid ""
"Some timer settings are specified in jiffies, which is architecture- and "
"kernel version-dependent; see B<time>(7)."
msgstr ""

#. type: Plain text
#: build/C/man7/arp.7:298
msgid ""
"There is no way to signal positive feedback from user space.  This means "
"connection-oriented protocols implemented in user space will generate "
"excessive ARP traffic, because ndisc will regularly reprobe the MAC "
"address.  The same problem applies for some kernel protocols (e.g., NFS over "
"UDP)."
msgstr ""

#. type: Plain text
#: build/C/man7/arp.7:301
msgid ""
"This man page mashes together functionality that is IPv4-specific with "
"functionality that is shared between IPv4 and IPv6."
msgstr ""

#. type: SH
#: build/C/man7/arp.7:301 build/C/man3/bswap.3:81 build/C/man3/byteorder.3:98 build/C/man3/cmsg.3:248 build/C/man7/ddp.7:246 build/C/man3/endian.3:174 build/C/man3/ether_aton.3:157 build/C/man5/gai.conf.5:100 build/C/man3/getaddrinfo.3:844 build/C/man3/getaddrinfo_a.3:617 build/C/man1/getent.1:398 build/C/man3/gethostbyname.3:536 build/C/man3/getipnodebyname.3:266 build/C/man3/getnameinfo.3:299 build/C/man3/getnetent.3:205 build/C/man3/getnetent_r.3:162 build/C/man2/getpeername.2:137 build/C/man3/getprotoent.3:193 build/C/man3/getprotoent_r.3:254 build/C/man3/getservent.3:210 build/C/man3/getservent_r.3:257 build/C/man5/host.conf.5:212 build/C/man7/hostname.7:108 build/C/man5/hosts.5:127 build/C/man5/hosts.equiv.5:170 build/C/man7/icmp.7:196 build/C/man3/inet.3:331 build/C/man3/inet_net_pton.3:389 build/C/man3/inet_ntop.3:131 build/C/man3/inet_pton.3:229 build/C/man7/ip.7:1419 build/C/man7/ipv6.7:417 build/C/man7/netdevice.7:371 build/C/man5/networks.5:74 build/C/man8/nscd.8:93 build/C/man5/nscd.conf.5:239 build/C/man5/nss.5:113 build/C/man5/nsswitch.conf.5:432 build/C/man7/packet.7:635 build/C/man5/protocols.5:81 build/C/man7/raw.7:274 build/C/man3/rcmd.3:312 build/C/man5/resolv.conf.5:372 build/C/man3/resolver.3:512 build/C/man3/rexec.3:181 build/C/man5/services.5:208 build/C/man3/setnetgrent.3:154 build/C/man2/shutdown.2:116 build/C/man7/tcp.7:1377 build/C/man7/udp.7:261 build/C/man7/udplite.7:147 build/C/man7/unix.7:1187 build/C/man7/x25.7:118
#, no-wrap
msgid "SEE ALSO"
msgstr ""

#. type: Plain text
#: build/C/man7/arp.7:305
msgid "B<capabilities>(7), B<ip>(7), B<arpd>(8)"
msgstr ""

#. type: Plain text
#: build/C/man7/arp.7:310
msgid ""
"RFC\\ 826 for a description of ARP.  RFC\\ 2461 for a description of IPv6 "
"neighbor discovery and the base algorithms used.  Linux 2.2+ IPv4 ARP uses "
"the IPv6 algorithms when applicable."
msgstr ""

#. type: SH
#: build/C/man7/arp.7:310 build/C/man3/bswap.3:84 build/C/man3/byteorder.3:103 build/C/man3/cmsg.3:253 build/C/man7/ddp.7:251 build/C/man3/endian.3:177 build/C/man3/ether_aton.3:159 build/C/man5/gai.conf.5:103 build/C/man3/getaddrinfo.3:854 build/C/man3/getaddrinfo_a.3:624 build/C/man1/getent.1:400 build/C/man3/gethostbyname.3:550 build/C/man3/getipnodebyname.3:271 build/C/man3/getnameinfo.3:332 build/C/man3/getnetent.3:212 build/C/man3/getnetent_r.3:165 build/C/man2/getpeername.2:144 build/C/man3/getprotoent.3:198 build/C/man3/getprotoent_r.3:257 build/C/man3/getservent.3:215 build/C/man3/getservent_r.3:260 build/C/man5/host.conf.5:219 build/C/man7/hostname.7:126 build/C/man5/hosts.5:140 build/C/man5/hosts.equiv.5:174 build/C/man7/icmp.7:201 build/C/man3/inet.3:342 build/C/man3/inet_net_pton.3:392 build/C/man3/inet_ntop.3:135 build/C/man3/inet_pton.3:233 build/C/man7/ip.7:1440 build/C/man7/ipv6.7:424 build/C/man7/netdevice.7:376 build/C/man5/networks.5:80 build/C/man8/nscd.8:99 build/C/man5/nscd.conf.5:244 build/C/man5/nss.5:115 build/C/man5/nsswitch.conf.5:435 build/C/man7/packet.7:658 build/C/man5/protocols.5:86 build/C/man7/raw.7:287 build/C/man3/rcmd.3:319 build/C/man5/resolv.conf.5:382 build/C/man3/resolver.3:521 build/C/man3/rexec.3:184 build/C/man5/services.5:220 build/C/man3/setnetgrent.3:158 build/C/man2/shutdown.2:121 build/C/man7/tcp.7:1406 build/C/man7/udp.7:275 build/C/man7/udplite.7:157 build/C/man7/unix.7:1197 build/C/man7/x25.7:127
#, no-wrap
msgid "COLOPHON"
msgstr ""

#. type: Plain text
#: build/C/man7/arp.7:318 build/C/man3/bswap.3:92 build/C/man3/byteorder.3:111 build/C/man3/cmsg.3:261 build/C/man7/ddp.7:259 build/C/man3/endian.3:185 build/C/man3/ether_aton.3:167 build/C/man5/gai.conf.5:111 build/C/man3/getaddrinfo.3:862 build/C/man3/getaddrinfo_a.3:632 build/C/man1/getent.1:408 build/C/man3/gethostbyname.3:558 build/C/man3/getipnodebyname.3:279 build/C/man3/getnameinfo.3:340 build/C/man3/getnetent.3:220 build/C/man3/getnetent_r.3:173 build/C/man2/getpeername.2:152 build/C/man3/getprotoent.3:206 build/C/man3/getprotoent_r.3:265 build/C/man3/getservent.3:223 build/C/man3/getservent_r.3:268 build/C/man5/host.conf.5:227 build/C/man7/hostname.7:134 build/C/man5/hosts.5:148 build/C/man5/hosts.equiv.5:182 build/C/man7/icmp.7:209 build/C/man3/inet.3:350 build/C/man3/inet_net_pton.3:400 build/C/man3/inet_ntop.3:143 build/C/man3/inet_pton.3:241 build/C/man7/ip.7:1448 build/C/man7/ipv6.7:432 build/C/man7/netdevice.7:384 build/C/man5/networks.5:88 build/C/man8/nscd.8:107 build/C/man5/nscd.conf.5:252 build/C/man5/nss.5:123 build/C/man5/nsswitch.conf.5:443 build/C/man7/packet.7:666 build/C/man5/protocols.5:94 build/C/man7/raw.7:295 build/C/man3/rcmd.3:327 build/C/man5/resolv.conf.5:390 build/C/man3/resolver.3:529 build/C/man3/rexec.3:192 build/C/man5/services.5:228 build/C/man3/setnetgrent.3:166 build/C/man2/shutdown.2:129 build/C/man7/tcp.7:1414 build/C/man7/udp.7:283 build/C/man7/udplite.7:165 build/C/man7/unix.7:1205 build/C/man7/x25.7:135
msgid ""
"This page is part of release 5.10 of the Linux I<man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at "
"\\%https://www.kernel.org/doc/man-pages/."
msgstr ""

#. type: TH
#: build/C/man3/bswap.3:25
#, no-wrap
msgid "BSWAP"
msgstr ""

#. type: TH
#: build/C/man3/bswap.3:25 build/C/man3/cmsg.3:11 build/C/man3/endian.3:28 build/C/man3/getaddrinfo.3:44 build/C/man3/getaddrinfo_a.3:30 build/C/man3/getprotoent_r.3:26 build/C/man3/getservent_r.3:26 build/C/man7/ip.7:42 build/C/man7/unix.7:20
#, no-wrap
msgid "2020-11-01"
msgstr ""

#. type: Plain text
#: build/C/man3/bswap.3:28
msgid "bswap_16, bswap_32, bswap_64 - reverse order of bytes"
msgstr ""

#. type: SH
#: build/C/man3/bswap.3:28 build/C/man3/byteorder.3:36 build/C/man3/cmsg.3:14 build/C/man7/ddp.7:15 build/C/man3/endian.3:33 build/C/man3/ether_aton.3:35 build/C/man3/getaddrinfo.3:48 build/C/man3/getaddrinfo_a.3:34 build/C/man1/getent.1:28 build/C/man3/gethostbyname.3:46 build/C/man3/getipnodebyname.3:30 build/C/man3/getnameinfo.3:13 build/C/man3/getnetent.3:34 build/C/man3/getnetent_r.3:30 build/C/man2/getpeername.2:45 build/C/man3/getprotoent.3:34 build/C/man3/getprotoent_r.3:30 build/C/man3/getservent.3:38 build/C/man3/getservent_r.3:30 build/C/man5/hosts.5:30 build/C/man3/inet.3:46 build/C/man3/inet_net_pton.3:28 build/C/man3/inet_ntop.3:29 build/C/man3/inet_pton.3:30 build/C/man7/ip.7:45 build/C/man7/ipv6.7:89 build/C/man7/netdevice.7:20 build/C/man7/packet.7:15 build/C/man7/raw.7:15 build/C/man3/rcmd.3:48 build/C/man5/resolv.conf.5:27 build/C/man3/resolver.3:38 build/C/man3/rexec.3:44 build/C/man3/setnetgrent.3:14 build/C/man2/shutdown.2:43 build/C/man7/tcp.7:99 build/C/man7/udp.7:15 build/C/man7/udplite.7:30 build/C/man7/unix.7:23 build/C/man7/x25.7:15
#, no-wrap
msgid "SYNOPSIS"
msgstr ""

#. type: Plain text
#: build/C/man3/bswap.3:31
#, no-wrap
msgid "B<#include E<lt>byteswap.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/bswap.3:35
#, no-wrap
msgid ""
"B<bswap_16(>I<x>B<);>\n"
"B<bswap_32(>I<x>B<);>\n"
"B<bswap_64(>I<x>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/bswap.3:39
msgid ""
"These macros return a value in which the order of the bytes in their 2-, 4-, "
"or 8-byte arguments is reversed."
msgstr ""

#. type: SH
#: build/C/man3/bswap.3:39 build/C/man3/getaddrinfo.3:484 build/C/man3/getaddrinfo_a.3:243 build/C/man3/gethostbyname.3:296 build/C/man3/getipnodebyname.3:186 build/C/man3/getnameinfo.3:139 build/C/man3/getnetent.3:130 build/C/man3/getnetent_r.3:119 build/C/man2/getpeername.2:68 build/C/man3/getprotoent.3:123 build/C/man3/getprotoent_r.3:109 build/C/man3/getservent.3:142 build/C/man3/getservent_r.3:108 build/C/man3/inet_net_pton.3:129 build/C/man3/inet_ntop.3:83 build/C/man3/inet_pton.3:118 build/C/man3/rcmd.3:241 build/C/man3/resolver.3:435 build/C/man3/setnetgrent.3:89 build/C/man2/shutdown.2:69
#, no-wrap
msgid "RETURN VALUE"
msgstr ""

#. type: Plain text
#: build/C/man3/bswap.3:41
msgid "These macros return the value of their argument with the bytes reversed."
msgstr ""

#. type: SH
#: build/C/man3/bswap.3:41 build/C/man7/ddp.7:149 build/C/man3/gethostbyname.3:308 build/C/man3/getnetent_r.3:130 build/C/man2/getpeername.2:73 build/C/man3/getprotoent_r.3:120 build/C/man3/getservent_r.3:119 build/C/man3/inet_net_pton.3:144 build/C/man3/inet_ntop.3:91 build/C/man7/ip.7:1231 build/C/man7/ipv6.7:351 build/C/man7/packet.7:512 build/C/man7/raw.7:149 build/C/man2/shutdown.2:74 build/C/man7/tcp.7:1340 build/C/man7/udp.7:246 build/C/man7/udplite.7:121 build/C/man7/unix.7:683
#, no-wrap
msgid "ERRORS"
msgstr ""

#. type: Plain text
#: build/C/man3/bswap.3:43
msgid "These macros always succeed."
msgstr ""

#. type: SH
#: build/C/man3/bswap.3:43 build/C/man3/byteorder.3:91 build/C/man3/cmsg.3:159 build/C/man3/endian.3:99 build/C/man3/ether_aton.3:149 build/C/man3/getaddrinfo.3:610 build/C/man3/getaddrinfo_a.3:322 build/C/man3/gethostbyname.3:410 build/C/man3/getipnodebyname.3:258 build/C/man3/getnameinfo.3:220 build/C/man3/getnetent.3:196 build/C/man3/getnetent_r.3:158 build/C/man2/getpeername.2:101 build/C/man3/getprotoent.3:191 build/C/man3/getprotoent_r.3:149 build/C/man3/getservent.3:208 build/C/man3/getservent_r.3:147 build/C/man3/inet.3:245 build/C/man3/inet_net_pton.3:158 build/C/man3/inet_ntop.3:113 build/C/man3/inet_pton.3:143 build/C/man3/rcmd.3:297 build/C/man3/resolver.3:510 build/C/man3/rexec.3:163 build/C/man3/setnetgrent.3:139 build/C/man2/shutdown.2:92
#, no-wrap
msgid "CONFORMING TO"
msgstr ""

#. type: Plain text
#: build/C/man3/bswap.3:45
msgid "These macros are GNU extensions."
msgstr ""

#. type: SH
#: build/C/man3/bswap.3:45 build/C/man3/cmsg.3:189 build/C/man3/endian.3:130 build/C/man5/gai.conf.5:79 build/C/man3/getaddrinfo.3:639 build/C/man3/getaddrinfo_a.3:331 build/C/man3/getnameinfo.3:260 build/C/man3/getprotoent_r.3:153 build/C/man3/getservent_r.3:151 build/C/man5/hosts.5:110 build/C/man5/hosts.equiv.5:84 build/C/man3/inet.3:288 build/C/man3/inet_net_pton.3:246 build/C/man3/inet_ntop.3:128 build/C/man3/inet_pton.3:170 build/C/man5/nss.5:100 build/C/man7/unix.7:917
#, no-wrap
msgid "EXAMPLES"
msgstr ""

#. type: Plain text
#: build/C/man3/bswap.3:49
msgid ""
"The program below swaps the bytes of the 8-byte integer supplied as its "
"command-line argument.  The following shell session demonstrates the use of "
"the program:"
msgstr ""

#. type: Plain text
#: build/C/man3/bswap.3:54
#, no-wrap
msgid ""
"$ B<./a.out 0x0123456789abcdef>\n"
"0x123456789abcdef ==E<gt> 0xefcdab8967452301\n"
msgstr ""

#. type: SS
#: build/C/man3/bswap.3:56 build/C/man3/endian.3:146 build/C/man3/getprotoent_r.3:180 build/C/man3/getservent_r.3:177 build/C/man3/inet.3:304 build/C/man3/inet_net_pton.3:330 build/C/man3/inet_pton.3:187 build/C/man7/unix.7:948
#, no-wrap
msgid "Program source"
msgstr ""

#. type: Plain text
#: build/C/man3/bswap.3:64
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>inttypes.hE<gt>\n"
"#include E<lt>byteswap.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/bswap.3:69
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    uint64_t x;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/bswap.3:74
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>numE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/bswap.3:77
#, no-wrap
msgid ""
"    x = strtoull(argv[1], NULL, 0);\n"
"    printf(\"%#\" PRIx64 \" ==E<gt> %#\" PRIx64 \"\\en\", x, bswap_64(x));\n"
msgstr ""

#. type: Plain text
#: build/C/man3/bswap.3:80 build/C/man3/endian.3:173 build/C/man3/getaddrinfo.3:843 build/C/man3/getprotoent_r.3:253 build/C/man3/getservent_r.3:256 build/C/man3/inet_net_pton.3:388 build/C/man3/inet_pton.3:228 build/C/man7/unix.7:1092 build/C/man7/unix.7:1181
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/bswap.3:84
msgid "B<byteorder>(3), B<endian>(3)"
msgstr ""

#. type: TH
#: build/C/man3/byteorder.3:32
#, no-wrap
msgid "BYTEORDER"
msgstr ""

#. type: TH
#: build/C/man3/byteorder.3:32 build/C/man7/ddp.7:12 build/C/man3/ether_aton.3:31 build/C/man3/getipnodebyname.3:26 build/C/man3/getnetent_r.3:26 build/C/man2/getpeername.2:42 build/C/man3/rexec.3:41 build/C/man3/setnetgrent.3:10 build/C/man7/udplite.7:27 build/C/man7/x25.7:12
#, no-wrap
msgid "2017-09-15"
msgstr ""

#. type: TH
#: build/C/man3/byteorder.3:32 build/C/man3/endian.3:28 build/C/man3/ether_aton.3:31 build/C/man3/getaddrinfo.3:44 build/C/man3/getaddrinfo_a.3:30 build/C/man3/getnameinfo.3:10 build/C/man3/getnetent.3:30 build/C/man3/getnetent_r.3:26 build/C/man3/getprotoent.3:30 build/C/man3/getprotoent_r.3:26 build/C/man3/getservent.3:34 build/C/man3/getservent_r.3:26 build/C/man3/inet.3:42 build/C/man8/nscd.8:23 build/C/man5/nscd.conf.5:20 build/C/man3/resolver.3:33 build/C/man3/setnetgrent.3:10
#, no-wrap
msgid "GNU"
msgstr ""

#. type: Plain text
#: build/C/man3/byteorder.3:36
msgid ""
"htonl, htons, ntohl, ntohs - convert values between host and network byte "
"order"
msgstr ""

#. type: Plain text
#: build/C/man3/byteorder.3:39 build/C/man3/inet_net_pton.3:31 build/C/man3/inet_ntop.3:32 build/C/man3/inet_pton.3:33
#, no-wrap
msgid "B<#include E<lt>arpa/inet.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/byteorder.3:41
#, no-wrap
msgid "B<uint32_t htonl(uint32_t >I<hostlong>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/byteorder.3:43
#, no-wrap
msgid "B<uint16_t htons(uint16_t >I<hostshort>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/byteorder.3:45
#, no-wrap
msgid "B<uint32_t ntohl(uint32_t >I<netlong>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/byteorder.3:47
#, no-wrap
msgid "B<uint16_t ntohs(uint16_t >I<netshort>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/byteorder.3:54
msgid ""
"The B<htonl>()  function converts the unsigned integer I<hostlong> from host "
"byte order to network byte order."
msgstr ""

#. type: Plain text
#: build/C/man3/byteorder.3:60
msgid ""
"The B<htons>()  function converts the unsigned short integer I<hostshort> "
"from host byte order to network byte order."
msgstr ""

#. type: Plain text
#: build/C/man3/byteorder.3:66
msgid ""
"The B<ntohl>()  function converts the unsigned integer I<netlong> from "
"network byte order to host byte order."
msgstr ""

#. type: Plain text
#: build/C/man3/byteorder.3:72
msgid ""
"The B<ntohs>()  function converts the unsigned short integer I<netshort> "
"from network byte order to host byte order."
msgstr ""

#. type: Plain text
#: build/C/man3/byteorder.3:76
msgid ""
"On the i386 the host byte order is Least Significant Byte first, whereas the "
"network byte order, as used on the Internet, is Most Significant Byte first."
msgstr ""

#. type: SH
#: build/C/man3/byteorder.3:76 build/C/man3/ether_aton.3:127 build/C/man3/getaddrinfo.3:593 build/C/man3/getaddrinfo_a.3:306 build/C/man3/gethostbyname.3:339 build/C/man3/getnameinfo.3:207 build/C/man3/getnetent.3:145 build/C/man3/getnetent_r.3:142 build/C/man3/getprotoent.3:140 build/C/man3/getprotoent_r.3:132 build/C/man3/getservent.3:157 build/C/man3/getservent_r.3:131 build/C/man3/inet.3:223 build/C/man3/inet_ntop.3:100 build/C/man3/inet_pton.3:131 build/C/man3/rcmd.3:272 build/C/man3/resolver.3:485 build/C/man3/rexec.3:150 build/C/man3/setnetgrent.3:95
#, no-wrap
msgid "ATTRIBUTES"
msgstr ""

#. type: Plain text
#: build/C/man3/byteorder.3:79 build/C/man3/ether_aton.3:130 build/C/man3/getaddrinfo.3:596 build/C/man3/getaddrinfo_a.3:309 build/C/man3/gethostbyname.3:342 build/C/man3/getnameinfo.3:210 build/C/man3/getnetent.3:148 build/C/man3/getnetent_r.3:145 build/C/man3/getprotoent.3:143 build/C/man3/getprotoent_r.3:135 build/C/man3/getservent.3:160 build/C/man3/getservent_r.3:134 build/C/man3/inet.3:226 build/C/man3/inet_ntop.3:103 build/C/man3/inet_pton.3:134 build/C/man3/rcmd.3:275 build/C/man3/resolver.3:488 build/C/man3/rexec.3:153 build/C/man3/setnetgrent.3:98
msgid "For an explanation of the terms used in this section, see B<attributes>(7)."
msgstr ""

#. type: tbl table
#: build/C/man3/byteorder.3:83 build/C/man3/ether_aton.3:135 build/C/man3/getaddrinfo.3:600 build/C/man3/getaddrinfo_a.3:313 build/C/man3/gethostbyname.3:346 build/C/man3/getnameinfo.3:214 build/C/man3/getnetent.3:152 build/C/man3/getnetent_r.3:150 build/C/man3/getprotoent.3:147 build/C/man3/getprotoent_r.3:139 build/C/man3/getservent.3:164 build/C/man3/getservent_r.3:139 build/C/man3/inet.3:230 build/C/man3/inet_ntop.3:107 build/C/man3/inet_pton.3:138 build/C/man3/rcmd.3:279 build/C/man3/resolver.3:492 build/C/man3/rexec.3:157 build/C/man3/setnetgrent.3:102
#, no-wrap
msgid "Interface"
msgstr ""

#. type: tbl table
#: build/C/man3/byteorder.3:83 build/C/man3/ether_aton.3:135 build/C/man3/getaddrinfo.3:600 build/C/man3/getaddrinfo_a.3:313 build/C/man3/gethostbyname.3:346 build/C/man3/getnameinfo.3:214 build/C/man3/getnetent.3:152 build/C/man3/getnetent_r.3:150 build/C/man3/getprotoent.3:147 build/C/man3/getprotoent_r.3:139 build/C/man3/getservent.3:164 build/C/man3/getservent_r.3:139 build/C/man3/inet.3:230 build/C/man3/inet_ntop.3:107 build/C/man3/inet_pton.3:138 build/C/man3/rcmd.3:279 build/C/man3/resolver.3:492 build/C/man3/rexec.3:157 build/C/man3/setnetgrent.3:102
#, no-wrap
msgid "Attribute"
msgstr ""

#. type: tbl table
#: build/C/man3/byteorder.3:83 build/C/man3/ether_aton.3:135 build/C/man3/getaddrinfo.3:600 build/C/man3/getaddrinfo_a.3:313 build/C/man3/gethostbyname.3:346 build/C/man3/getnameinfo.3:214 build/C/man3/getnetent.3:152 build/C/man3/getnetent_r.3:150 build/C/man3/getprotoent.3:147 build/C/man3/getprotoent_r.3:139 build/C/man3/getservent.3:164 build/C/man3/getservent_r.3:139 build/C/man3/inet.3:230 build/C/man3/inet_ntop.3:107 build/C/man3/inet_pton.3:138 build/C/man3/rcmd.3:279 build/C/man3/resolver.3:492 build/C/man3/rexec.3:157 build/C/man3/setnetgrent.3:102
#, no-wrap
msgid "Value"
msgstr ""

#. type: tbl table
#: build/C/man3/byteorder.3:89
#, no-wrap
msgid ""
"B<htonl>(),\n"
"B<htons>(),\n"
"B<ntohl>(),\n"
"B<ntohs>()"
msgstr ""

#. type: tbl table
#: build/C/man3/byteorder.3:89 build/C/man3/ether_aton.3:139 build/C/man3/ether_aton.3:146 build/C/man3/getaddrinfo.3:603 build/C/man3/getaddrinfo.3:607 build/C/man3/getaddrinfo_a.3:319 build/C/man3/gethostbyname.3:349 build/C/man3/gethostbyname.3:356 build/C/man3/gethostbyname.3:367 build/C/man3/gethostbyname.3:376 build/C/man3/gethostbyname.3:379 build/C/man3/gethostbyname.3:386 build/C/man3/gethostbyname.3:395 build/C/man3/getnameinfo.3:217 build/C/man3/getnetent.3:155 build/C/man3/getnetent.3:162 build/C/man3/getnetent.3:169 build/C/man3/getnetent.3:178 build/C/man3/getnetent_r.3:155 build/C/man3/getprotoent.3:150 build/C/man3/getprotoent.3:157 build/C/man3/getprotoent.3:164 build/C/man3/getprotoent.3:173 build/C/man3/getprotoent_r.3:146 build/C/man3/getservent.3:167 build/C/man3/getservent.3:174 build/C/man3/getservent.3:181 build/C/man3/getservent.3:190 build/C/man3/getservent_r.3:144 build/C/man3/inet.3:237 build/C/man3/inet.3:243 build/C/man3/inet_ntop.3:110 build/C/man3/inet_pton.3:141 build/C/man3/rcmd.3:283 build/C/man3/rcmd.3:287 build/C/man3/rcmd.3:294 build/C/man3/resolver.3:501 build/C/man3/resolver.3:507 build/C/man3/rexec.3:161 build/C/man3/setnetgrent.3:109 build/C/man3/setnetgrent.3:116 build/C/man3/setnetgrent.3:119
#, no-wrap
msgid "Thread safety"
msgstr ""

#. type: tbl table
#: build/C/man3/byteorder.3:89 build/C/man3/ether_aton.3:146 build/C/man3/getaddrinfo.3:607 build/C/man3/getaddrinfo_a.3:319 build/C/man3/gethostbyname.3:376 build/C/man3/inet.3:243 build/C/man3/rcmd.3:287 build/C/man3/resolver.3:507
#, no-wrap
msgid "MT-Safe"
msgstr ""

#. type: Plain text
#: build/C/man3/byteorder.3:93 build/C/man3/inet_pton.3:145
msgid "POSIX.1-2001, POSIX.1-2008."
msgstr ""

#. type: Plain text
#: build/C/man3/byteorder.3:98
msgid ""
"Some systems require the inclusion of I<E<lt>netinet/in.hE<gt>> instead of "
"I<E<lt>arpa/inet.hE<gt>>."
msgstr ""

#. type: Plain text
#: build/C/man3/byteorder.3:103
msgid "B<bswap>(3), B<endian>(3), B<gethostbyname>(3), B<getservent>(3)"
msgstr ""

#. type: TH
#: build/C/man3/cmsg.3:11
#, no-wrap
msgid "CMSG"
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:14
msgid "CMSG_ALIGN, CMSG_SPACE, CMSG_NXTHDR, CMSG_FIRSTHDR - access ancillary data"
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:24
#, no-wrap
msgid ""
"B<#include E<lt>sys/socket.hE<gt>>\n"
"B<struct cmsghdr *CMSG_FIRSTHDR(struct msghdr *>I<msgh>B<);>\n"
"B<struct cmsghdr *CMSG_NXTHDR(struct msghdr *>I<msgh>B<,>\n"
"B<                            struct cmsghdr *>cmsgB<);>\n"
"B<size_t CMSG_ALIGN(size_t >I<length>B<);>\n"
"B<size_t CMSG_SPACE(size_t >I<length>B<);>\n"
"B<size_t CMSG_LEN(size_t >I<length>B<);>\n"
"B<unsigned char *CMSG_DATA(struct cmsghdr *>I<cmsg>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:39
msgid ""
"These macros are used to create and access control messages (also called "
"ancillary data) that are not a part of the socket payload.  This control "
"information may include the interface the packet was received on, various "
"rarely used header fields, an extended error description, a set of file "
"descriptors, or UNIX credentials.  For instance, control messages can be "
"used to send additional header fields such as IP options.  Ancillary data is "
"sent by calling B<sendmsg>(2)  and received by calling B<recvmsg>(2).  See "
"their manual pages for more information."
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:48
msgid ""
"Ancillary data is a sequence of I<cmsghdr> structures with appended data.  "
"See the specific protocol man pages for the available control message "
"types.  The maximum ancillary buffer size allowed per socket can be set "
"using I</proc/sys/net/core/optmem_max>; see B<socket>(7)."
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:52
msgid "The I<cmsghdr> structure is defined as follows:"
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:63
#, no-wrap
msgid ""
"struct cmsghdr {\n"
"    size_t cmsg_len;    /* Data byte count, including header\n"
"                           (type is socklen_t in POSIX) */\n"
"    int    cmsg_level;  /* Originating protocol */\n"
"    int    cmsg_type;   /* Protocol-specific type */\n"
"/* followed by\n"
"   unsigned char cmsg_data[]; */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:70
msgid ""
"The sequence of I<cmsghdr> structures should never be accessed directly.  "
"Instead, use only the following macros:"
msgstr ""

#. type: IP
#: build/C/man3/cmsg.3:70 build/C/man3/cmsg.3:80 build/C/man3/cmsg.3:95 build/C/man3/cmsg.3:100 build/C/man3/cmsg.3:105 build/C/man3/cmsg.3:115 build/C/man3/getaddrinfo.3:346 build/C/man3/getaddrinfo.3:369 build/C/man3/getaddrinfo_a.3:192 build/C/man3/getaddrinfo_a.3:196 build/C/man3/getaddrinfo_a.3:198 build/C/man3/inet_net_pton.3:206 build/C/man3/inet_net_pton.3:212 build/C/man3/inet_net_pton.3:219 build/C/man3/inet_net_pton.3:226 build/C/man3/inet_net_pton.3:233 build/C/man7/ip.7:1148 build/C/man7/ip.7:1151 build/C/man7/ip.7:1154 build/C/man7/ip.7:1157 build/C/man5/nsswitch.conf.5:134 build/C/man5/nsswitch.conf.5:138 build/C/man7/packet.7:131 build/C/man7/packet.7:138 build/C/man7/packet.7:148 build/C/man7/packet.7:165 build/C/man7/packet.7:292 build/C/man7/packet.7:300 build/C/man7/packet.7:304 build/C/man7/packet.7:307 build/C/man7/packet.7:311 build/C/man7/packet.7:314 build/C/man7/unix.7:99 build/C/man7/unix.7:124 build/C/man7/unix.7:140 build/C/man7/unix.7:165 build/C/man7/unix.7:169 build/C/man7/unix.7:173
#, no-wrap
msgid "*"
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:80
msgid ""
"B<CMSG_FIRSTHDR>()  returns a pointer to the first I<cmsghdr> in the "
"ancillary data buffer associated with the passed I<msghdr>.  It returns NULL "
"if there isn't enough space for a I<cmsghdr> in the buffer."
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:87
msgid ""
"B<CMSG_NXTHDR>()  returns the next valid I<cmsghdr> after the passed "
"I<cmsghdr>.  It returns NULL when there isn't enough space left in the "
"buffer."
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:95
msgid ""
"When initializing a buffer that will contain a series of I<cmsghdr> "
"structures (e.g., to be sent with B<sendmsg>(2)), that buffer should first "
"be zero-initialized to ensure the correct operation of B<CMSG_NXTHDR>()."
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:100
msgid ""
"B<CMSG_ALIGN>(), given a length, returns it including the required "
"alignment.  This is a constant expression."
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:105
msgid ""
"B<CMSG_SPACE>()  returns the number of bytes an ancillary element with "
"payload of the passed data length occupies.  This is a constant expression."
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:115
msgid ""
"B<CMSG_DATA>()  returns a pointer to the data portion of a I<cmsghdr>.  The "
"pointer returned cannot be assumed to be suitably aligned for accessing "
"arbitrary payload data types.  Applications should not cast it to a pointer "
"type matching the payload, but should instead use B<memcpy>(3)  to copy data "
"to or from a suitably declared object."
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:126
msgid ""
"B<CMSG_LEN>()  returns the value to store in the I<cmsg_len> member of the "
"I<cmsghdr> structure, taking into account any necessary alignment.  It takes "
"the data length as an argument.  This is a constant expression."
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:159
msgid ""
"To create ancillary data, first initialize the I<msg_controllen> member of "
"the I<msghdr> with the length of the control message buffer.  Use "
"B<CMSG_FIRSTHDR>()  on the I<msghdr> to get the first control message and "
"B<CMSG_NXTHDR>()  to get all subsequent ones.  In each control message, "
"initialize I<cmsg_len> (with B<CMSG_LEN>()), the other I<cmsghdr> header "
"fields, and the data portion using B<CMSG_DATA>().  Finally, the "
"I<msg_controllen> field of the I<msghdr> should be set to the sum of the "
"B<CMSG_SPACE>()  of the length of all control messages in the buffer.  For "
"more information on the I<msghdr>, see B<recvmsg>(2)."
msgstr ""

#.  https://www.austingroupbugs.net/view.php?id=978#c3242
#. type: Plain text
#: build/C/man3/cmsg.3:172
msgid ""
"This ancillary data model conforms to the POSIX.1g draft, 4.4BSD-Lite, the "
"IPv6 advanced API described in RFC\\ 2292 and SUSv2.  B<CMSG_FIRSTHDR>(), "
"B<CMSG_NXTHDR>(), and B<CMSG_DATA>()  are specified in POSIX.1-2008.  "
"B<CMSG_SPACE>()  and B<CMSG_LEN>()  will be included in the next POSIX "
"release (Issue 8)."
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:175
msgid "B<CMSG_ALIGN>()  is a Linux extension."
msgstr ""

#. type: SH
#: build/C/man3/cmsg.3:175 build/C/man7/ddp.7:223 build/C/man3/endian.3:114 build/C/man3/getaddrinfo.3:615 build/C/man3/getaddrinfo_a.3:325 build/C/man3/gethostbyname.3:434 build/C/man3/getipnodebyname.3:261 build/C/man3/getnameinfo.3:222 build/C/man3/getnetent.3:198 build/C/man2/getpeername.2:105 build/C/man5/host.conf.5:126 build/C/man5/hosts.5:91 build/C/man5/hosts.equiv.5:71 build/C/man7/icmp.7:174 build/C/man3/inet.3:252 build/C/man3/inet_net_pton.3:164 build/C/man3/inet_pton.3:145 build/C/man7/ip.7:1322 build/C/man7/ipv6.7:386 build/C/man7/netdevice.7:340 build/C/man8/nscd.8:64 build/C/man5/nscd.conf.5:232 build/C/man5/nsswitch.conf.5:413 build/C/man7/packet.7:554 build/C/man7/raw.7:192 build/C/man3/setnetgrent.3:150 build/C/man2/shutdown.2:96 build/C/man7/unix.7:810
#, no-wrap
msgid "NOTES"
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:180
msgid ""
"For portability, ancillary data should be accessed using only the macros "
"described here.  B<CMSG_ALIGN>()  is a Linux extension and should not be "
"used in portable programs."
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:189
msgid ""
"In Linux, B<CMSG_LEN>(), B<CMSG_DATA>(), and B<CMSG_ALIGN>()  are constant "
"expressions (assuming their argument is constant), meaning that these values "
"can be used to declare the size of global variables.  This may not be "
"portable, however."
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:193
msgid "This code looks for the B<IP_TTL> option in a received ancillary buffer:"
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:199
#, no-wrap
msgid ""
"struct msghdr msgh;\n"
"struct cmsghdr *cmsg;\n"
"int received_ttl;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:201
#, no-wrap
msgid "/* Receive auxiliary data in msgh */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:210
#, no-wrap
msgid ""
"for (cmsg = CMSG_FIRSTHDR(&msgh); cmsg != NULL;\n"
"        cmsg = CMSG_NXTHDR(&msgh, cmsg)) {\n"
"    if (cmsg-E<gt>cmsg_level == IPPROTO_IP\n"
"            && cmsg-E<gt>cmsg_type == IP_TTL) {\n"
"        memcpy(&receive_ttl, CMSG_DATA(cmsg), sizeof(received_ttl));\n"
"        break;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:214
#, no-wrap
msgid ""
"if (cmsg == NULL) {\n"
"    /* Error: IP_TTL not enabled or small buffer or I/O error */\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:220
msgid ""
"The code below passes an array of file descriptors over a UNIX domain socket "
"using B<SCM_RIGHTS>:"
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:236
#, no-wrap
msgid ""
"struct msghdr msg = { 0 };\n"
"struct cmsghdr *cmsg;\n"
"int myfds[NUM_FD];  /* Contains the file descriptors to pass */\n"
"char iobuf[1];\n"
"struct iovec io = {\n"
"    .iov_base = iobuf,\n"
"    .iov_len = sizeof(iobuf)\n"
"};\n"
"union {         /* Ancillary data buffer, wrapped in a union\n"
"                   in order to ensure it is suitably aligned */\n"
"    char buf[CMSG_SPACE(sizeof(myfds))];\n"
"    struct cmsghdr align;\n"
"} u;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:246
#, no-wrap
msgid ""
"msg.msg_iov = &io;\n"
"msg.msg_iovlen = 1;\n"
"msg.msg_control = u.buf;\n"
"msg.msg_controllen = sizeof(u.buf);\n"
"cmsg = CMSG_FIRSTHDR(&msg);\n"
"cmsg-E<gt>cmsg_level = SOL_SOCKET;\n"
"cmsg-E<gt>cmsg_type = SCM_RIGHTS;\n"
"cmsg-E<gt>cmsg_len = CMSG_LEN(sizeof(myfds));\n"
"memcpy(CMSG_DATA(cmsg), myfds, sizeof(myfds));\n"
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:251
msgid "B<recvmsg>(2), B<sendmsg>(2)"
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:253
msgid "RFC\\ 2292"
msgstr ""

#. type: TH
#: build/C/man7/ddp.7:12
#, no-wrap
msgid "DDP"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:15
msgid "ddp - Linux AppleTalk protocol implementation"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:17 build/C/man2/getpeername.2:47 build/C/man7/ip.7:47 build/C/man7/ipv6.7:91 build/C/man7/raw.7:17 build/C/man2/shutdown.2:45 build/C/man7/tcp.7:101 build/C/man7/udp.7:17 build/C/man7/udplite.7:32 build/C/man7/unix.7:25 build/C/man7/x25.7:17
msgid "B<#include E<lt>sys/socket.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:19
msgid "B<#include E<lt>netatalk/at.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:21
msgid "I<ddp_socket>B< = socket(AF_APPLETALK, SOCK_DGRAM, 0);>"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:23
msgid "I<raw_socket>B< = socket(AF_APPLETALK, SOCK_RAW, >I<protocol>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:34
msgid ""
"Linux implements the AppleTalk protocols described in I<Inside AppleTalk>.  "
"Only the DDP layer and AARP are present in the kernel.  They are designed to "
"be used via the B<netatalk> protocol libraries.  This page documents the "
"interface for those who wish or need to use the DDP layer directly."
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:39
msgid ""
"The communication between AppleTalk and the user program works using a "
"BSD-compatible socket interface.  For more information on sockets, see "
"B<socket>(7)."
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:60
msgid ""
"An AppleTalk socket is created by calling the B<socket>(2)  function with a "
"B<AF_APPLETALK> socket family argument.  Valid socket types are "
"B<SOCK_DGRAM> to open a B<ddp> socket or B<SOCK_RAW> to open a B<raw> "
"socket.  I<protocol> is the AppleTalk protocol to be received or sent.  For "
"B<SOCK_RAW> you must specify B<ATPROTO_DDP>."
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:65
msgid ""
"Raw sockets may be opened only by a process with effective user ID 0 or when "
"the process has the B<CAP_NET_RAW> capability."
msgstr ""

#. type: SS
#: build/C/man7/ddp.7:65 build/C/man7/ip.7:145 build/C/man7/ipv6.7:142 build/C/man7/raw.7:96 build/C/man7/udp.7:98 build/C/man7/udplite.7:58 build/C/man7/unix.7:58
#, no-wrap
msgid "Address format"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:68
msgid ""
"An AppleTalk socket address is defined as a combination of a network number, "
"a node number, and a port number."
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:75
#, no-wrap
msgid ""
"struct at_addr {\n"
"    unsigned short s_net;\n"
"    unsigned char  s_node;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:81
#, no-wrap
msgid ""
"struct sockaddr_atalk {\n"
"    sa_family_t    sat_family;    /* address family */\n"
"    unsigned char  sat_port;      /* port */\n"
"    struct at_addr sat_addr;      /* net/node */\n"
"};\n"
msgstr ""

#.  FIXME . this doesn't make sense [johnl]
#. type: Plain text
#: build/C/man7/ddp.7:120
msgid ""
"I<sat_family> is always set to B<AF_APPLETALK>.  I<sat_port> contains the "
"port.  The port numbers below 129 are known as I<reserved ports>.  Only "
"processes with the effective user ID 0 or the B<CAP_NET_BIND_SERVICE> "
"capability may B<bind>(2)  to these sockets.  I<sat_addr> is the host "
"address.  The I<net> member of I<struct at_addr> contains the host network "
"in network byte order.  The value of B<AT_ANYNET> is a wildcard and also "
"implies \\(lqthis network.\\(rq The I<node> member of I<struct at_addr> "
"contains the host node number.  The value of B<AT_ANYNODE> is a wildcard and "
"also implies \\(lqthis node.\\(rq The value of B<ATADDR_BCAST> is a link "
"local broadcast address."
msgstr ""

#. type: SS
#: build/C/man7/ddp.7:120 build/C/man7/ip.7:250 build/C/man7/ipv6.7:192 build/C/man7/packet.7:184 build/C/man7/raw.7:114 build/C/man7/tcp.7:998 build/C/man7/udp.7:178 build/C/man7/udplite.7:67 build/C/man7/unix.7:268 build/C/man7/x25.7:72
#, no-wrap
msgid "Socket options"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:122
msgid "No protocol-specific socket options are supported."
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:128
msgid ""
"IP supports a set of I</proc> interfaces to configure some global AppleTalk "
"parameters.  The parameters can be accessed by reading or writing files in "
"the directory I</proc/sys/net/atalk/>."
msgstr ""

#. type: TP
#: build/C/man7/ddp.7:128
#, no-wrap
msgid "I<aarp-expiry-time>"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:131
msgid "The time interval (in seconds) before an AARP cache entry expires."
msgstr ""

#. type: TP
#: build/C/man7/ddp.7:131
#, no-wrap
msgid "I<aarp-resolve-time>"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:134
msgid "The time interval (in seconds) before an AARP cache entry is resolved."
msgstr ""

#. type: TP
#: build/C/man7/ddp.7:134
#, no-wrap
msgid "I<aarp-retransmit-limit>"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:138
msgid ""
"The number of retransmissions of an AARP query before the node is declared "
"dead."
msgstr ""

#. type: TP
#: build/C/man7/ddp.7:138
#, no-wrap
msgid "I<aarp-tick-time>"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:141
msgid "The timer rate (in seconds) for the timer driving AARP."
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:144
msgid ""
"The default values match the specification and should never need to be "
"changed."
msgstr ""

#.  FIXME . Add a section about multicasting
#. type: Plain text
#: build/C/man7/ddp.7:149
msgid "All ioctls described in B<socket>(7)  apply to DDP."
msgstr ""

#. type: TP
#: build/C/man7/ddp.7:150 build/C/man7/ip.7:1235 build/C/man7/raw.7:150
#, no-wrap
msgid "B<EACCES>"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:157
msgid ""
"The user tried to execute an operation without the necessary permissions.  "
"These include sending to a broadcast address without having the broadcast "
"flag set, and trying to bind to a reserved port without effective user ID 0 "
"or B<CAP_NET_BIND_SERVICE>."
msgstr ""

#. type: TP
#: build/C/man7/ddp.7:157 build/C/man7/ip.7:1251 build/C/man7/unix.7:684
#, no-wrap
msgid "B<EADDRINUSE>"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:160 build/C/man7/ip.7:1254
msgid "Tried to bind to an address already in use."
msgstr ""

#. type: TP
#: build/C/man7/ddp.7:160 build/C/man7/ip.7:1254 build/C/man7/packet.7:513
#, no-wrap
msgid "B<EADDRNOTAVAIL>"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:164 build/C/man7/ip.7:1258
msgid ""
"A nonexistent interface was requested or the requested source address was "
"not local."
msgstr ""

#. type: TP
#: build/C/man7/ddp.7:164 build/C/man7/ip.7:1258
#, no-wrap
msgid "B<EAGAIN>"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:167 build/C/man7/ip.7:1261
msgid "Operation on a nonblocking socket would block."
msgstr ""

#. type: TP
#: build/C/man7/ddp.7:167 build/C/man7/ip.7:1261
#, no-wrap
msgid "B<EALREADY>"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:170 build/C/man7/ip.7:1264
msgid "A connection operation on a nonblocking socket is already in progress."
msgstr ""

#. type: TP
#: build/C/man7/ddp.7:170 build/C/man7/ip.7:1264
#, no-wrap
msgid "B<ECONNABORTED>"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:174 build/C/man7/ip.7:1268
msgid "A connection was closed during an B<accept>(2)."
msgstr ""

#. type: TP
#: build/C/man7/ddp.7:174 build/C/man7/ip.7:1268
#, no-wrap
msgid "B<EHOSTUNREACH>"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:177
msgid "No routing table entry matches the destination address."
msgstr ""

#. type: TP
#: build/C/man7/ddp.7:177 build/C/man2/getpeername.2:85 build/C/man7/ip.7:1273 build/C/man7/packet.7:519 build/C/man7/raw.7:157 build/C/man2/shutdown.2:79 build/C/man7/unix.7:709
#, no-wrap
msgid "B<EINVAL>"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:180
msgid "Invalid argument passed."
msgstr ""

#. type: TP
#: build/C/man7/ddp.7:180 build/C/man7/ip.7:1279 build/C/man7/unix.7:718
#, no-wrap
msgid "B<EISCONN>"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:184 build/C/man7/ip.7:1283
msgid "B<connect>(2)  was called on an already connected socket."
msgstr ""

#. type: TP
#: build/C/man7/ddp.7:184 build/C/man3/inet_net_pton.3:150 build/C/man7/ip.7:1283 build/C/man7/packet.7:522 build/C/man7/raw.7:160
#, no-wrap
msgid "B<EMSGSIZE>"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:187
msgid "Datagram is bigger than the DDP MTU."
msgstr ""

#. type: TP
#: build/C/man7/ddp.7:187 build/C/man7/ipv6.7:352 build/C/man7/packet.7:531
#, no-wrap
msgid "B<ENODEV>"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:190
msgid "Network device not available or not capable of sending IP."
msgstr ""

#. type: TP
#: build/C/man7/ddp.7:190 build/C/man3/getnetent_r.3:131 build/C/man3/getprotoent_r.3:121 build/C/man3/getservent_r.3:120 build/C/man3/inet_net_pton.3:153 build/C/man7/ip.7:1291 build/C/man7/packet.7:534 build/C/man7/unix.7:723
#, no-wrap
msgid "B<ENOENT>"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:194 build/C/man7/ip.7:1295
msgid "B<SIOCGSTAMP> was called on a socket where no packet arrived."
msgstr ""

#. type: TP
#: build/C/man7/ddp.7:194
#, no-wrap
msgid "B<ENOMEM> and B<ENOBUFS>"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:197
msgid "Not enough memory available."
msgstr ""

#. type: TP
#: build/C/man7/ddp.7:197 build/C/man7/ip.7:1295
#, no-wrap
msgid "B<ENOPKG>"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:200 build/C/man7/ip.7:1298
msgid "A kernel subsystem was not configured."
msgstr ""

#. type: TP
#: build/C/man7/ddp.7:200 build/C/man7/ip.7:1298
#, no-wrap
msgid "B<ENOPROTOOPT> and B<EOPNOTSUPP>"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:203 build/C/man7/ip.7:1301
msgid "Invalid socket option passed."
msgstr ""

#. type: TP
#: build/C/man7/ddp.7:203 build/C/man2/getpeername.2:93 build/C/man7/ip.7:1301 build/C/man7/packet.7:537 build/C/man2/shutdown.2:84 build/C/man7/unix.7:731
#, no-wrap
msgid "B<ENOTCONN>"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:207 build/C/man7/ip.7:1305
msgid ""
"The operation is defined only on a connected socket, but the socket wasn't "
"connected."
msgstr ""

#. type: TP
#: build/C/man7/ddp.7:207 build/C/man7/ip.7:1305 build/C/man7/packet.7:543 build/C/man7/raw.7:171 build/C/man7/unix.7:738
#, no-wrap
msgid "B<EPERM>"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:212
msgid ""
"User doesn't have permission to set high priority, make a configuration "
"change, or send signals to the requested process or group."
msgstr ""

#. type: TP
#: build/C/man7/ddp.7:212 build/C/man7/ip.7:1309 build/C/man7/tcp.7:1347 build/C/man7/unix.7:742
#, no-wrap
msgid "B<EPIPE>"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:215 build/C/man7/ip.7:1312
msgid "The connection was unexpectedly closed or shut down by the other end."
msgstr ""

#. type: TP
#: build/C/man7/ddp.7:215 build/C/man7/ip.7:1312 build/C/man7/unix.7:764
#, no-wrap
msgid "B<ESOCKTNOSUPPORT>"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:218
msgid "The socket was unconfigured, or an unknown socket type was requested."
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:223
msgid ""
"AppleTalk is supported by Linux 2.0 or higher.  The I</proc> interfaces "
"exist since Linux 2.2."
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:229
msgid ""
"Be very careful with the B<SO_BROADCAST> option; it is not privileged in "
"Linux.  It is easy to overload the network with careless sending to "
"broadcast addresses."
msgstr ""

#. type: SS
#: build/C/man7/ddp.7:229 build/C/man7/ip.7:1379 build/C/man7/packet.7:585
#, no-wrap
msgid "Compatibility"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:236
msgid ""
"The basic AppleTalk socket interface is compatible with B<netatalk> on "
"BSD-derived systems.  Many BSD systems fail to check B<SO_BROADCAST> when "
"sending broadcast frames; this can lead to compatibility problems."
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:241
msgid ""
"The raw socket mode is unique to Linux and exists to support the alternative "
"CAP package and AppleTalk monitoring tools more easily."
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:243 build/C/man7/ip.7:1394
msgid "There are too many inconsistent error values."
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:246
msgid ""
"The ioctls used to configure routing tables, devices, AARP tables, and other "
"devices are not yet described."
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:251
msgid "B<recvmsg>(2), B<sendmsg>(2), B<capabilities>(7), B<socket>(7)"
msgstr ""

#. type: TH
#: build/C/man3/endian.3:28
#, no-wrap
msgid "ENDIAN"
msgstr ""

#. type: Plain text
#: build/C/man3/endian.3:33
msgid ""
"htobe16, htole16, be16toh, le16toh, htobe32, htole32, be32toh, le32toh, "
"htobe64, htole64, be64toh, le64toh - convert values between host and "
"big-/little-endian byte order"
msgstr ""

#. type: Plain text
#: build/C/man3/endian.3:36
#, no-wrap
msgid "B<#include E<lt>endian.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/endian.3:41
#, no-wrap
msgid ""
"B<uint16_t htobe16(uint16_t >I<host_16bits>B<);>\n"
"B<uint16_t htole16(uint16_t >I<host_16bits>B<);>\n"
"B<uint16_t be16toh(uint16_t >I<big_endian_16bits>B<);>\n"
"B<uint16_t le16toh(uint16_t >I<little_endian_16bits>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/endian.3:46
#, no-wrap
msgid ""
"B<uint32_t htobe32(uint32_t >I<host_32bits>B<);>\n"
"B<uint32_t htole32(uint32_t >I<host_32bits>B<);>\n"
"B<uint32_t be32toh(uint32_t >I<big_endian_32bits>B<);>\n"
"B<uint32_t le32toh(uint32_t >I<little_endian_32bits>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/endian.3:51
#, no-wrap
msgid ""
"B<uint64_t htobe64(uint64_t >I<host_64bits>B<);>\n"
"B<uint64_t htole64(uint64_t >I<host_64bits>B<);>\n"
"B<uint64_t be64toh(uint64_t >I<big_endian_64bits>B<);>\n"
"B<uint64_t le64toh(uint64_t >I<little_endian_64bits>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/endian.3:56 build/C/man3/getaddrinfo.3:66 build/C/man3/gethostbyname.3:91 build/C/man3/getnameinfo.3:26 build/C/man3/getnetent_r.3:52 build/C/man3/getprotoent_r.3:49 build/C/man3/getservent_r.3:49 build/C/man3/inet.3:70 build/C/man3/inet_net_pton.3:44 build/C/man3/rcmd.3:81 build/C/man3/setnetgrent.3:34
msgid "Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr ""

#. type: Plain text
#: build/C/man3/endian.3:70
msgid ""
"B<htobe16>(), B<htole16>(), B<be16toh>(), B<le16toh>(), B<htobe32>(), "
"B<htole32>(), B<be32toh>(), B<le32toh>(), B<htobe64>(), B<htole64>(), "
"B<be64toh>(), B<le64toh>():"
msgstr ""

#. type: Plain text
#: build/C/man3/endian.3:75 build/C/man3/rexec.3:63
#, no-wrap
msgid ""
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    In glibc up to and including 2.19:\n"
"        _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man3/endian.3:80
msgid ""
"These functions convert the byte encoding of integer values from the byte "
"order that the current CPU (the \"host\") uses, to and from little-endian "
"and big-endian byte order."
msgstr ""

#. type: Plain text
#: build/C/man3/endian.3:85
msgid ""
"The number, I<nn>, in the name of each function indicates the size of "
"integer handled by the function, either 16, 32, or 64 bits."
msgstr ""

#. type: Plain text
#: build/C/man3/endian.3:88
msgid ""
"The functions with names of the form \"htobeI<nn>\" convert from host byte "
"order to big-endian order."
msgstr ""

#. type: Plain text
#: build/C/man3/endian.3:91
msgid ""
"The functions with names of the form \"htoleI<nn>\" convert from host byte "
"order to little-endian order."
msgstr ""

#. type: Plain text
#: build/C/man3/endian.3:94
msgid ""
"The functions with names of the form \"beI<nn>toh\" convert from big-endian "
"order to host byte order."
msgstr ""

#. type: Plain text
#: build/C/man3/endian.3:97
msgid ""
"The functions with names of the form \"leI<nn>toh\" convert from "
"little-endian order to host byte order."
msgstr ""

#. type: Plain text
#: build/C/man3/endian.3:99
msgid "These functions were added to glibc in version 2.9."
msgstr ""

#. type: Plain text
#: build/C/man3/endian.3:114
msgid ""
"These functions are nonstandard.  Similar functions are present on the BSDs, "
"where the required header file is I<E<lt>sys/endian.hE<gt>> instead of "
"I<E<lt>endian.hE<gt>>.  Unfortunately, NetBSD, FreeBSD, and glibc haven't "
"followed the original OpenBSD naming convention for these functions, whereby "
"the I<nn> component always appears at the end of the function name (thus, "
"for example, in NetBSD, FreeBSD, and glibc, the equivalent of OpenBSDs "
"\"betoh32\" is \"be32toh\")."
msgstr ""

#. type: Plain text
#: build/C/man3/endian.3:122
msgid ""
"These functions are similar to the older B<byteorder>(3)  family of "
"functions.  For example, B<be32toh>()  is identical to B<ntohl>()."
msgstr ""

#. type: Plain text
#: build/C/man3/endian.3:130
msgid ""
"The advantage of the B<byteorder>(3)  functions is that they are standard "
"functions available on all UNIX systems.  On the other hand, the fact that "
"they were designed for use in the context of TCP/IP means that they lack the "
"64-bit and little-endian variants described in this page."
msgstr ""

#. type: Plain text
#: build/C/man3/endian.3:137
msgid ""
"The program below display the results of converting an integer from host "
"byte order to both little-endian and big-endian byte order.  Since host byte "
"order is either little-endian or big-endian, only one of these conversions "
"will have an effect.  When we run this program on a little-endian system "
"such as x86-32, we see the following:"
msgstr ""

#. type: Plain text
#: build/C/man3/endian.3:144
#, no-wrap
msgid ""
"$ B<./a.out>\n"
"x.u32 = 0x44332211\n"
"htole32(x.u32) = 0x44332211\n"
"htobe32(x.u32) = 0x11223344\n"
msgstr ""

#. type: Plain text
#: build/C/man3/endian.3:153
#, no-wrap
msgid ""
"#include E<lt>endian.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/endian.3:161
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    union {\n"
"        uint32_t u32;\n"
"        uint8_t arr[4];\n"
"    } x;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/endian.3:166
#, no-wrap
msgid ""
"    x.arr[0] = 0x11;\t/* Lowest-address byte */\n"
"    x.arr[1] = 0x22;\n"
"    x.arr[2] = 0x33;\n"
"    x.arr[3] = 0x44;\t/* Highest-address byte */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/endian.3:170
#, no-wrap
msgid ""
"    printf(\"x.u32 = %#x\\en\", x.u32);\n"
"    printf(\"htole32(x.u32) = %#x\\en\", htole32(x.u32));\n"
"    printf(\"htobe32(x.u32) = %#x\\en\", htobe32(x.u32));\n"
msgstr ""

#. type: Plain text
#: build/C/man3/endian.3:177
msgid "B<bswap>(3), B<byteorder>(3)"
msgstr ""

#. type: TH
#: build/C/man3/ether_aton.3:31
#, no-wrap
msgid "ETHER_ATON"
msgstr ""

#. type: Plain text
#: build/C/man3/ether_aton.3:35
msgid ""
"ether_aton, ether_ntoa, ether_ntohost, ether_hostton, ether_line, "
"ether_ntoa_r, ether_aton_r - Ethernet address manipulation routines"
msgstr ""

#. type: Plain text
#: build/C/man3/ether_aton.3:38
#, no-wrap
msgid "B<#include E<lt>netinet/ether.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/ether_aton.3:40
#, no-wrap
msgid "B<char *ether_ntoa(const struct ether_addr *>I<addr>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/ether_aton.3:42
#, no-wrap
msgid "B<struct ether_addr *ether_aton(const char *>I<asc>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/ether_aton.3:44
#, no-wrap
msgid ""
"B<int ether_ntohost(char *>I<hostname>B<, const struct ether_addr "
"*>I<addr>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/ether_aton.3:46
#, no-wrap
msgid ""
"B<int ether_hostton(const char *>I<hostname>B<, struct ether_addr "
"*>I<addr>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/ether_aton.3:49
#, no-wrap
msgid ""
"B<int ether_line(const char *>I<line>B<, struct ether_addr *>I<addr>B<,>\n"
"B<               char *>I<hostname>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/ether_aton.3:51
#, no-wrap
msgid "/* GNU extensions */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/ether_aton.3:53
#, no-wrap
msgid ""
"B<char *ether_ntoa_r(const struct ether_addr *>I<addr>B<, char "
"*>I<buf>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/ether_aton.3:56
#, no-wrap
msgid ""
"B<struct ether_addr *ether_aton_r(const char *>I<asc>B<,>\n"
"B<                                struct ether_addr *>I<addr>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/ether_aton.3:67
msgid ""
"B<ether_aton>()  converts the 48-bit Ethernet host address I<asc> from the "
"standard hex-digits-and-colons notation into binary data in network byte "
"order and returns a pointer to it in a statically allocated buffer, which "
"subsequent calls will overwrite.  B<ether_aton>()  returns NULL if the "
"address is invalid."
msgstr ""

#. type: Plain text
#: build/C/man3/ether_aton.3:76
msgid ""
"The B<ether_ntoa>()  function converts the Ethernet host address I<addr> "
"given in network byte order to a string in standard hex-digits-and-colons "
"notation, omitting leading zeros.  The string is returned in a statically "
"allocated buffer, which subsequent calls will overwrite."
msgstr ""

#. type: Plain text
#: build/C/man3/ether_aton.3:83
msgid ""
"The B<ether_ntohost>()  function maps an Ethernet address to the "
"corresponding hostname in I</etc/ethers> and returns nonzero if it cannot be "
"found."
msgstr ""

#. type: Plain text
#: build/C/man3/ether_aton.3:90
msgid ""
"The B<ether_hostton>()  function maps a hostname to the corresponding "
"Ethernet address in I</etc/ethers> and returns nonzero if it cannot be "
"found."
msgstr ""

#. type: Plain text
#: build/C/man3/ether_aton.3:102
msgid ""
"The B<ether_line>()  function parses a line in I</etc/ethers> format "
"(ethernet address followed by whitespace followed by hostname; \\(aq#\\(aq "
"introduces a comment) and returns an address and hostname pair, or nonzero "
"if it cannot be parsed.  The buffer pointed to by I<hostname> must be "
"sufficiently long, for example, have the same length as I<line>."
msgstr ""

#. type: Plain text
#: build/C/man3/ether_aton.3:113
msgid ""
"The functions B<ether_ntoa_r>()  and B<ether_aton_r>()  are reentrant "
"thread-safe versions of B<ether_ntoa>()  and B<ether_aton>()  respectively, "
"and do not use static buffers."
msgstr ""

#. type: Plain text
#: build/C/man3/ether_aton.3:119
msgid "The structure I<ether_addr> is defined in I<E<lt>net/ethernet.hE<gt>> as:"
msgstr ""

#. type: Plain text
#: build/C/man3/ether_aton.3:125
#, no-wrap
msgid ""
"struct ether_addr {\n"
"    uint8_t ether_addr_octet[6];\n"
"}\n"
msgstr ""

#. type: tbl table
#: build/C/man3/ether_aton.3:139
#, no-wrap
msgid ""
"B<ether_aton>(),\n"
"B<ether_ntoa>()"
msgstr ""

#. type: tbl table
#: build/C/man3/ether_aton.3:139 build/C/man3/rcmd.3:283 build/C/man3/rexec.3:161
#, no-wrap
msgid "MT-Unsafe"
msgstr ""

#. type: tbl table
#: build/C/man3/ether_aton.3:146
#, no-wrap
msgid ""
"B<ether_ntohost>(),\n"
"B<ether_hostton>(),\n"
"B<ether_line>(),\n"
"B<ether_ntoa_r>(),\n"
"B<ether_aton_r>()"
msgstr ""

#. type: Plain text
#: build/C/man3/ether_aton.3:151
msgid "4.3BSD, SunOS."
msgstr ""

#.  The fix was presumably commit c0a0f9a32c8baa6ab93d00eb42d92c02e9e146d7
#.  which was in glibc 2.3
#. type: Plain text
#: build/C/man3/ether_aton.3:157
msgid ""
"In glibc 2.2.5 and earlier, the implementation of B<ether_line>()  is "
"broken."
msgstr ""

#. type: Plain text
#: build/C/man3/ether_aton.3:159
msgid "B<ethers>(5)"
msgstr ""

#. type: TH
#: build/C/man5/gai.conf.5:19
#, no-wrap
msgid "GAI.CONF"
msgstr ""

#. type: TH
#: build/C/man5/gai.conf.5:19 build/C/man3/getnameinfo.3:10 build/C/man5/hosts.5:27 build/C/man5/hosts.equiv.5:6 build/C/man3/inet_net_pton.3:25 build/C/man3/inet_ntop.3:26 build/C/man3/inet_pton.3:27 build/C/man5/nss.5:19
#, no-wrap
msgid "2020-06-09"
msgstr ""

#. type: Plain text
#: build/C/man5/gai.conf.5:22
msgid "gai.conf - getaddrinfo(3) configuration file"
msgstr ""

#. type: Plain text
#: build/C/man5/gai.conf.5:36
msgid ""
"A call to B<getaddrinfo>(3)  might return multiple answers.  According to "
"RFC\\ 3484 these answers must be sorted so that the answer with the highest "
"success rate is first in the list.  The RFC provides an algorithm for the "
"sorting.  The static rules are not always adequate, though.  For this "
"reason, the RFC also requires that system administrators should have the "
"possibility to dynamically change the sorting.  For the glibc "
"implementation, this can be achieved with the I</etc/gai.conf> file."
msgstr ""

#. type: Plain text
#: build/C/man5/gai.conf.5:40
msgid ""
"Each line in the configuration file consists of a keyword and its "
"parameters.  White spaces in any place are ignored.  Lines starting with "
"\\(aq#\\(aq are comments and are ignored."
msgstr ""

#. type: Plain text
#: build/C/man5/gai.conf.5:42
msgid "The keywords currently recognized are:"
msgstr ""

#. type: TP
#: build/C/man5/gai.conf.5:42
#, no-wrap
msgid "B<label> I<netmask> I<precedence>"
msgstr ""

#. type: Plain text
#: build/C/man5/gai.conf.5:51
msgid ""
"The value is added to the label table used in the RFC\\ 3484 sorting.  If "
"any B<label> definition is present in the configuration file, the default "
"table is not used.  All the label definitions of the default table which are "
"to be maintained have to be duplicated.  Following the keyword, the line has "
"to contain a network mask and a precedence value."
msgstr ""

#. type: TP
#: build/C/man5/gai.conf.5:51
#, no-wrap
msgid "B<precedence> I<netmask> I<precedence>"
msgstr ""

#. type: Plain text
#: build/C/man5/gai.conf.5:58
msgid ""
"This keyword is similar to B<label>, but instead the value is added to the "
"precedence table as specified in RFC\\ 3484.  Once again, the presence of a "
"single B<precedence> line in the configuration file causes the default table "
"to not be used."
msgstr ""

#. type: TP
#: build/C/man5/gai.conf.5:58
#, no-wrap
msgid "B<reload> E<lt>B<yes>|B<no>E<gt>"
msgstr ""

#. type: Plain text
#: build/C/man5/gai.conf.5:67
msgid ""
"This keyword controls whether a process checks whether the configuration "
"file has been changed since the last time it was read.  If the value is "
"\"B<yes>\", the file is reread.  This might cause problems in multithreaded "
"applications and is generally a bad idea.  The default is \"B<no>\"."
msgstr ""

#. type: TP
#: build/C/man5/gai.conf.5:67
#, no-wrap
msgid "B<scopev4> I<mask> I<value>"
msgstr ""

#. type: Plain text
#: build/C/man5/gai.conf.5:72
msgid ""
"Add another rule to the RFC\\ 3484 scope table for IPv4 address.  By "
"default, the scope IDs described in section 3.2 in RFC\\ 3438 are used.  "
"Changing these defaults should hardly ever be necessary."
msgstr ""

#. type: SH
#: build/C/man5/gai.conf.5:72 build/C/man3/getaddrinfo.3:591 build/C/man3/gethostbyname.3:329 build/C/man3/getnameinfo.3:198 build/C/man3/getnetent.3:141 build/C/man3/getprotoent.3:134 build/C/man3/getservent.3:153 build/C/man5/host.conf.5:116 build/C/man5/hosts.5:89 build/C/man5/hosts.equiv.5:69 build/C/man5/networks.5:70 build/C/man5/nss.5:98 build/C/man5/nsswitch.conf.5:332 build/C/man5/protocols.5:77 build/C/man5/resolv.conf.5:369 build/C/man3/resolver.3:478 build/C/man5/services.5:183 build/C/man3/setnetgrent.3:91 build/C/man7/udplite.7:126
#, no-wrap
msgid "FILES"
msgstr ""

#. type: Plain text
#: build/C/man5/gai.conf.5:74 build/C/man3/getaddrinfo.3:593
msgid "I</etc/gai.conf>"
msgstr ""

#.  Added in 2006
#. type: Plain text
#: build/C/man5/gai.conf.5:79
msgid "The I<gai.conf> file is supported by glibc since version 2.5."
msgstr ""

#. type: Plain text
#: build/C/man5/gai.conf.5:82
msgid ""
"The default table according to RFC\\ 3484 would be specified with the "
"following configuration file:"
msgstr ""

#. type: Plain text
#: build/C/man5/gai.conf.5:95
#, no-wrap
msgid ""
"label  ::1/128       0\n"
"label  ::/0          1\n"
"label  2002::/16     2\n"
"label ::/96          3\n"
"label ::ffff:0:0/96  4\n"
"precedence  ::1/128       50\n"
"precedence  ::/0          40\n"
"precedence  2002::/16     30\n"
"precedence ::/96          20\n"
"precedence ::ffff:0:0/96  10\n"
msgstr ""

#. type: Plain text
#: build/C/man5/gai.conf.5:103
msgid "B<getaddrinfo>(3), RFC\\ 3484"
msgstr ""

#. type: TH
#: build/C/man3/getaddrinfo.3:44
#, no-wrap
msgid "GETADDRINFO"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:48
msgid ""
"getaddrinfo, freeaddrinfo, gai_strerror - network address and service "
"translation"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:53 build/C/man3/getipnodebyname.3:35
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"
"B<#include E<lt>netdb.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:57
#, no-wrap
msgid ""
"B<int getaddrinfo(const char *>I<node>B<, const char *>I<service>B<,>\n"
"B<                const struct addrinfo *>I<hints>B<,>\n"
"B<                struct addrinfo **>I<res>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:59
#, no-wrap
msgid "B<void freeaddrinfo(struct addrinfo *>I<res>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:61
#, no-wrap
msgid "B<const char *gai_strerror(int >I<errcode>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:74
#, no-wrap
msgid ""
"B<getaddrinfo>(),\n"
"B<freeaddrinfo>(),\n"
"B<gai_strerror>():\n"
"    Since glibc 2.22: _POSIX_C_SOURCE E<gt>= 200112L\n"
"    Glibc 2.21 and earlier: _POSIX_C_SOURCE\n"
msgstr ""

#.  .BR getipnodebyname (3),
#.  .BR getipnodebyaddr (3),
#. type: Plain text
#: build/C/man3/getaddrinfo.3:100
msgid ""
"Given I<node> and I<service>, which identify an Internet host and a service, "
"B<getaddrinfo>()  returns one or more I<addrinfo> structures, each of which "
"contains an Internet address that can be specified in a call to B<bind>(2)  "
"or B<connect>(2).  The B<getaddrinfo>()  function combines the functionality "
"provided by the B<gethostbyname>(3)  and B<getservbyname>(3)  functions into "
"a single interface, but unlike the latter functions, B<getaddrinfo>()  is "
"reentrant and allows programs to eliminate IPv4-versus-IPv6 dependencies."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:106
msgid ""
"The I<addrinfo> structure used by B<getaddrinfo>()  contains the following "
"fields:"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:119
#, no-wrap
msgid ""
"struct addrinfo {\n"
"    int              ai_flags;\n"
"    int              ai_family;\n"
"    int              ai_socktype;\n"
"    int              ai_protocol;\n"
"    socklen_t        ai_addrlen;\n"
"    struct sockaddr *ai_addr;\n"
"    char            *ai_canonname;\n"
"    struct addrinfo *ai_next;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:141
msgid ""
"The I<hints> argument points to an I<addrinfo> structure that specifies "
"criteria for selecting the socket address structures returned in the list "
"pointed to by I<res>.  If I<hints> is not NULL it points to an I<addrinfo> "
"structure whose I<ai_family>, I<ai_socktype>, and I<ai_protocol> specify "
"criteria that limit the set of socket addresses returned by "
"B<getaddrinfo>(), as follows:"
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo.3:141
#, no-wrap
msgid "I<ai_family>"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:157
msgid ""
"This field specifies the desired address family for the returned addresses.  "
"Valid values for this field include B<AF_INET> and B<AF_INET6>.  The value "
"B<AF_UNSPEC> indicates that B<getaddrinfo>()  should return socket addresses "
"for any address family (either IPv4 or IPv6, for example) that can be used "
"with I<node> and I<service>."
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo.3:157
#, no-wrap
msgid "I<ai_socktype>"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:166
msgid ""
"This field specifies the preferred socket type, for example B<SOCK_STREAM> "
"or B<SOCK_DGRAM>.  Specifying 0 in this field indicates that socket "
"addresses of any type can be returned by B<getaddrinfo>()."
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo.3:166
#, no-wrap
msgid "I<ai_protocol>"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:172
msgid ""
"This field specifies the protocol for the returned socket addresses.  "
"Specifying 0 in this field indicates that socket addresses with any protocol "
"can be returned by B<getaddrinfo>()."
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo.3:172
#, no-wrap
msgid "I<ai_flags>"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:176
msgid ""
"This field specifies additional options, described below.  Multiple flags "
"are specified by bitwise OR-ing them together."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:180
msgid ""
"All the other fields in the structure pointed to by I<hints> must contain "
"either 0 or a null pointer, as appropriate."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:215
msgid ""
"Specifying I<hints> as NULL is equivalent to setting I<ai_socktype> and "
"I<ai_protocol> to 0; I<ai_family> to B<AF_UNSPEC>; and I<ai_flags> to "
"B<(AI_V4MAPPED\\ |\\ AI_ADDRCONFIG)>.  (POSIX specifies different defaults "
"for I<ai_flags>; see NOTES.)  I<node> specifies either a numerical network "
"address (for IPv4, numbers-and-dots notation as supported by "
"B<inet_aton>(3); for IPv6, hexadecimal string format as supported by "
"B<inet_pton>(3)), or a network hostname, whose network addresses are looked "
"up and resolved.  If I<hints.ai_flags> contains the B<AI_NUMERICHOST> flag, "
"then I<node> must be a numerical network address.  The B<AI_NUMERICHOST> "
"flag suppresses any potentially lengthy network host address lookups."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:240
msgid ""
"If the B<AI_PASSIVE> flag is specified in I<hints.ai_flags>, and I<node> is "
"NULL, then the returned socket addresses will be suitable for B<bind>(2)ing "
"a socket that will B<accept>(2)  connections.  The returned socket address "
"will contain the \"wildcard address\" (B<INADDR_ANY> for IPv4 addresses, "
"B<IN6ADDR_ANY_INIT> for IPv6 address).  The wildcard address is used by "
"applications (typically servers)  that intend to accept connections on any "
"of the host's network addresses.  If I<node> is not NULL, then the "
"B<AI_PASSIVE> flag is ignored."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:260
msgid ""
"If the B<AI_PASSIVE> flag is not set in I<hints.ai_flags>, then the returned "
"socket addresses will be suitable for use with B<connect>(2), B<sendto>(2), "
"or B<sendmsg>(2).  If I<node> is NULL, then the network address will be set "
"to the loopback interface address (B<INADDR_LOOPBACK> for IPv4 addresses, "
"B<IN6ADDR_LOOPBACK_INIT> for IPv6 address); this is used by applications "
"that intend to communicate with peers running on the same host."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:283
msgid ""
"I<service> sets the port in each returned address structure.  If this "
"argument is a service name (see B<services>(5)), it is translated to the "
"corresponding port number.  This argument can also be specified as a decimal "
"number, which is simply converted to binary.  If I<service> is NULL, then "
"the port number of the returned socket addresses will be left "
"uninitialized.  If B<AI_NUMERICSERV> is specified in I<hints.ai_flags> and "
"I<service> is not NULL, then I<service> must point to a string containing a "
"numeric port number.  This flag is used to inhibit the invocation of a name "
"resolution service in cases where it is known not to be required."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:289
msgid "Either I<node> or I<service>, but not both, may be NULL."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:305
msgid ""
"The B<getaddrinfo>()  function allocates and initializes a linked list of "
"I<addrinfo> structures, one for each network address that matches I<node> "
"and I<service>, subject to any restrictions imposed by I<hints>, and returns "
"a pointer to the start of the list in I<res>.  The items in the linked list "
"are linked by the I<ai_next> field."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:327
msgid ""
"There are several reasons why the linked list may have more than one "
"I<addrinfo> structure, including: the network host is multihomed, accessible "
"over multiple protocols (e.g., both B<AF_INET> and B<AF_INET6>); or the same "
"service is available from multiple socket types (one B<SOCK_STREAM> address "
"and another B<SOCK_DGRAM> address, for example).  Normally, the application "
"should try using the addresses in the order in which they are returned.  The "
"sorting function used within B<getaddrinfo>()  is defined in RFC\\ 3484; the "
"order can be tweaked for a particular system by editing I</etc/gai.conf> "
"(available since glibc 2.5)."
msgstr ""

#.  In glibc prior to 2.3.4, the ai_canonname of each addrinfo
#.  structure was set pointing to the canonical name; that was
#.  more than POSIX.1-2001 specified, or other implementations provided.
#.  MTK, Aug 05
#. type: Plain text
#: build/C/man3/getaddrinfo.3:342
msgid ""
"If I<hints.ai_flags> includes the B<AI_CANONNAME> flag, then the "
"I<ai_canonname> field of the first of the I<addrinfo> structures in the "
"returned list is set to point to the official name of the host."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:346
msgid ""
"The remaining fields of each returned I<addrinfo> structure are initialized "
"as follows:"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:369
msgid ""
"The I<ai_family>, I<ai_socktype>, and I<ai_protocol> fields return the "
"socket creation parameters (i.e., these fields have the same meaning as the "
"corresponding arguments of B<socket>(2)).  For example, I<ai_family> might "
"return B<AF_INET> or B<AF_INET6>; I<ai_socktype> might return B<SOCK_DGRAM> "
"or B<SOCK_STREAM>; and I<ai_protocol> returns the protocol for the socket."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:376
msgid ""
"A pointer to the socket address is placed in the I<ai_addr> field, and the "
"length of the socket address, in bytes, is placed in the I<ai_addrlen> "
"field."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:395
msgid ""
"If I<hints.ai_flags> includes the B<AI_ADDRCONFIG> flag, then IPv4 addresses "
"are returned in the list pointed to by I<res> only if the local system has "
"at least one IPv4 address configured, and IPv6 addresses are returned only "
"if the local system has at least one IPv6 address configured.  The loopback "
"address is not considered for this case as valid as a configured address.  "
"This flag is useful on, for example, IPv4-only systems, to ensure that "
"B<getaddrinfo>()  does not return IPv6 socket addresses that would always "
"fail in B<connect>(2)  or B<bind>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:420
msgid ""
"If I<hints.ai_flags> specifies the B<AI_V4MAPPED> flag, and "
"I<hints.ai_family> was specified as B<AF_INET6>, and no matching IPv6 "
"addresses could be found, then return IPv4-mapped IPv6 addresses in the list "
"pointed to by I<res>.  If both B<AI_V4MAPPED> and B<AI_ALL> are specified in "
"I<hints.ai_flags>, then return both IPv6 and IPv4-mapped IPv6 addresses in "
"the list pointed to by I<res>.  B<AI_ALL> is ignored if B<AI_V4MAPPED> is "
"not also specified."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:426
msgid ""
"The B<freeaddrinfo>()  function frees the memory that was allocated for the "
"dynamically allocated linked list I<res>."
msgstr ""

#. type: SS
#: build/C/man3/getaddrinfo.3:426
#, no-wrap
msgid "Extensions to getaddrinfo() for Internationalized Domain Names"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:434
msgid ""
"Starting with glibc 2.3.4, B<getaddrinfo>()  has been extended to "
"selectively allow the incoming and outgoing hostnames to be transparently "
"converted to and from the Internationalized Domain Name (IDN) format (see "
"RFC 3490, I<Internationalizing Domain Names in Applications (IDNA)>).  Four "
"new flags are defined:"
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo.3:434
#, no-wrap
msgid "B<AI_IDN>"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:440
msgid ""
"If this flag is specified, then the node name given in I<node> is converted "
"to IDN format if necessary.  The source encoding is that of the current "
"locale."
msgstr ""

#.  Implementation Detail:
#.  To minimize effects on system performance the implementation might
#.  want to check whether the input string contains any non-ASCII
#.  characters.  If there are none the IDN step can be skipped completely.
#.  On systems which allow not-ASCII safe encodings for a locale this
#.  might be a problem.
#. type: Plain text
#: build/C/man3/getaddrinfo.3:452
msgid ""
"If the input name contains non-ASCII characters, then the IDN encoding is "
"used.  Those parts of the node name (delimited by dots) that contain "
"non-ASCII characters are encoded using ASCII Compatible Encoding (ACE)  "
"before being passed to the name resolution functions."
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo.3:452
#, no-wrap
msgid "B<AI_CANONIDN>"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:464
msgid ""
"After a successful name lookup, and if the B<AI_CANONNAME> flag was "
"specified, B<getaddrinfo>()  will return the canonical name of the node "
"corresponding to the I<addrinfo> structure value passed back.  The return "
"value is an exact copy of the value returned by the name resolution "
"function."
msgstr ""

#
#. Implementation Detail:
#. If no component of the returned name starts with xn\-\- the IDN
#. step can be skipped, therefore avoiding unnecessary slowdowns.
#. type: Plain text
#: build/C/man3/getaddrinfo.3:477
msgid ""
"If the name is encoded using ACE, then it will contain the I<xn--> prefix "
"for one or more components of the name.  To convert these components into a "
"readable form the B<AI_CANONIDN> flag can be passed in addition to "
"B<AI_CANONNAME>.  The resulting string is encoded using the current locale's "
"encoding."
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo.3:477
#, no-wrap
msgid "B<AI_IDN_ALLOW_UNASSIGNED>, B<AI_IDN_USE_STD3_ASCII_RULES>"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:484 build/C/man3/getnameinfo.3:139
msgid ""
"Setting these flags will enable the IDNA_ALLOW_UNASSIGNED (allow unassigned "
"Unicode code points) and IDNA_USE_STD3_ASCII_RULES (check output to make "
"sure it is a STD3 conforming hostname)  flags respectively to be used in the "
"IDNA handling."
msgstr ""

#.  FIXME glibc defines the following additional errors, some which
#.  can probably be returned by getaddrinfo(); they need to
#.  be documented.
#.     #ifdef __USE_GNU
#.     #define EAI_INPROGRESS  -100  /* Processing request in progress.  */
#.     #define EAI_CANCELED    -101  /* Request canceled.  */
#.     #define EAI_NOTCANCELED -102  /* Request not canceled.  */
#.     #define EAI_ALLDONE     -103  /* All requests done.  */
#.     #define EAI_INTR        -104  /* Interrupted by a signal.  */
#.     #define EAI_IDN_ENCODE  -105  /* IDN encoding failed.  */
#.     #endif
#. type: Plain text
#: build/C/man3/getaddrinfo.3:498
msgid ""
"B<getaddrinfo>()  returns 0 if it succeeds, or one of the following nonzero "
"error codes:"
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo.3:498
#, no-wrap
msgid "B<EAI_ADDRFAMILY>"
msgstr ""

#.  Not in SUSv3
#. type: Plain text
#: build/C/man3/getaddrinfo.3:503
msgid ""
"The specified network host does not have any network addresses in the "
"requested address family."
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo.3:503 build/C/man3/getaddrinfo_a.3:248 build/C/man3/getaddrinfo_a.3:265 build/C/man3/getnameinfo.3:156
#, no-wrap
msgid "B<EAI_AGAIN>"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:507
msgid "The name server returned a temporary failure indication.  Try again later."
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo.3:507 build/C/man3/getnameinfo.3:160
#, no-wrap
msgid "B<EAI_BADFLAGS>"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:517
msgid ""
"I<hints.ai_flags> contains invalid flags; or, I<hints.ai_flags> included "
"B<AI_CANONNAME> and I<name> was NULL."
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo.3:517 build/C/man3/getnameinfo.3:165
#, no-wrap
msgid "B<EAI_FAIL>"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:520
msgid "The name server returned a permanent failure indication."
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo.3:520 build/C/man3/getnameinfo.3:168
#, no-wrap
msgid "B<EAI_FAMILY>"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:523
msgid "The requested address family is not supported."
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo.3:523 build/C/man3/getaddrinfo_a.3:253 build/C/man3/getnameinfo.3:172
#, no-wrap
msgid "B<EAI_MEMORY>"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:526 build/C/man3/getaddrinfo_a.3:256 build/C/man3/getnameinfo.3:175 build/C/man7/unix.7:731
msgid "Out of memory."
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo.3:526
#, no-wrap
msgid "B<EAI_NODATA>"
msgstr ""

#.  Not in SUSv3
#. type: Plain text
#: build/C/man3/getaddrinfo.3:531
msgid ""
"The specified network host exists, but does not have any network addresses "
"defined."
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo.3:531 build/C/man3/getnameinfo.3:175
#, no-wrap
msgid "B<EAI_NONAME>"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:548
msgid ""
"The I<node> or I<service> is not known; or both I<node> and I<service> are "
"NULL; or B<AI_NUMERICSERV> was specified in I<hints.ai_flags> and I<service> "
"was not a numeric port-number string."
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo.3:548
#, no-wrap
msgid "B<EAI_SERVICE>"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:569
msgid ""
"The requested service is not available for the requested socket type.  It "
"may be available through another socket type.  For example, this error could "
"occur if I<service> was \"shell\" (a service available only on stream "
"sockets), and either I<hints.ai_protocol> was B<IPPROTO_UDP>, or "
"I<hints.ai_socktype> was B<SOCK_DGRAM>; or the error could occur if "
"I<service> was not NULL, and I<hints.ai_socktype> was B<SOCK_RAW> (a socket "
"type that does not support the concept of services)."
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo.3:569
#, no-wrap
msgid "B<EAI_SOCKTYPE>"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:581
msgid ""
"The requested socket type is not supported.  This could occur, for example, "
"if I<hints.ai_socktype> and I<hints.ai_protocol> are inconsistent (e.g., "
"B<SOCK_DGRAM> and B<IPPROTO_TCP>, respectively)."
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo.3:581 build/C/man3/getaddrinfo_a.3:256 build/C/man3/getnameinfo.3:188
#, no-wrap
msgid "B<EAI_SYSTEM>"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:586
msgid "Other system error, check I<errno> for details."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:591
msgid ""
"The B<gai_strerror>()  function translates these error codes to a human "
"readable string, suitable for error reporting."
msgstr ""

#. type: tbl table
#: build/C/man3/getaddrinfo.3:603
#, no-wrap
msgid "B<getaddrinfo>()"
msgstr ""

#. type: tbl table
#: build/C/man3/getaddrinfo.3:603 build/C/man3/gethostbyname.3:395 build/C/man3/getnameinfo.3:217
#, no-wrap
msgid "MT-Safe env locale"
msgstr ""

#. type: tbl table
#: build/C/man3/getaddrinfo.3:607
#, no-wrap
msgid ""
"B<freeaddrinfo>(),\n"
"B<gai_strerror>()"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:615
msgid ""
"POSIX.1-2001, POSIX.1-2008.  The B<getaddrinfo>()  function is documented in "
"RFC\\ 2553."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:620
msgid ""
"B<getaddrinfo>()  supports the I<address>B<%>I<scope-id> notation for "
"specifying the IPv6 scope-ID."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:628
msgid ""
"B<AI_ADDRCONFIG>, B<AI_ALL>, and B<AI_V4MAPPED> are available since glibc "
"2.3.3.  B<AI_NUMERICSERV> is available since glibc 2.3.4."
msgstr ""

#.  POSIX.1-2001, POSIX.1-2008
#. type: Plain text
#: build/C/man3/getaddrinfo.3:639
msgid ""
"According to POSIX.1, specifying I<hints> as NULL should cause I<ai_flags> "
"to be assumed as 0.  The GNU C library instead assumes a value of "
"B<(AI_V4MAPPED\\ |\\ AI_ADDRCONFIG)> for this case, since this value is "
"considered an improvement on the specification."
msgstr ""

#.  getnameinfo.3 refers to this example
#.  socket.2 refers to this example
#.  bind.2 refers to this example
#.  connect.2 refers to this example
#.  recvfrom.2 refers to this example
#.  sendto.2 refers to this example
#. type: Plain text
#: build/C/man3/getaddrinfo.3:653
msgid ""
"The following programs demonstrate the use of B<getaddrinfo>(), "
"B<gai_strerror>(), B<freeaddrinfo>(), and B<getnameinfo>(3).  The programs "
"are an echo server and client for UDP datagrams."
msgstr ""

#. type: SS
#: build/C/man3/getaddrinfo.3:653
#, no-wrap
msgid "Server program"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:663
#, no-wrap
msgid ""
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>netdb.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:665 build/C/man3/getaddrinfo.3:760
#, no-wrap
msgid "#define BUF_SIZE 500\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:676
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct addrinfo hints;\n"
"    struct addrinfo *result, *rp;\n"
"    int sfd, s;\n"
"    struct sockaddr_storage peer_addr;\n"
"    socklen_t peer_addr_len;\n"
"    ssize_t nread;\n"
"    char buf[BUF_SIZE];\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:681
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s port\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:690
#, no-wrap
msgid ""
"    memset(&hints, 0, sizeof(hints));\n"
"    hints.ai_family = AF_UNSPEC;    /* Allow IPv4 or IPv6 */\n"
"    hints.ai_socktype = SOCK_DGRAM; /* Datagram socket */\n"
"    hints.ai_flags = AI_PASSIVE;    /* For wildcard IP address */\n"
"    hints.ai_protocol = 0;          /* Any protocol */\n"
"    hints.ai_canonname = NULL;\n"
"    hints.ai_addr = NULL;\n"
"    hints.ai_next = NULL;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:696
#, no-wrap
msgid ""
"    s = getaddrinfo(NULL, argv[1], &hints, &result);\n"
"    if (s != 0) {\n"
"        fprintf(stderr, \"getaddrinfo: %s\\en\", gai_strerror(s));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:701
#, no-wrap
msgid ""
"    /* getaddrinfo() returns a list of address structures.\n"
"       Try each address until we successfully bind(2).\n"
"       If socket(2) (or bind(2)) fails, we (close the socket\n"
"       and) try the next address. */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:707
#, no-wrap
msgid ""
"    for (rp = result; rp != NULL; rp = rp-E<gt>ai_next) {\n"
"        sfd = socket(rp-E<gt>ai_family, rp-E<gt>ai_socktype,\n"
"                rp-E<gt>ai_protocol);\n"
"        if (sfd == -1)\n"
"            continue;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:710
#, no-wrap
msgid ""
"        if (bind(sfd, rp-E<gt>ai_addr, rp-E<gt>ai_addrlen) == 0)\n"
"            break;                  /* Success */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:713 build/C/man3/getaddrinfo.3:806
#, no-wrap
msgid ""
"        close(sfd);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:715 build/C/man3/getaddrinfo.3:808
#, no-wrap
msgid "    freeaddrinfo(result);           /* No longer needed */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:720
#, no-wrap
msgid ""
"    if (rp == NULL) {               /* No address succeeded */\n"
"        fprintf(stderr, \"Could not bind\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:722
#, no-wrap
msgid "    /* Read datagrams and echo them back to sender */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:729
#, no-wrap
msgid ""
"    for (;;) {\n"
"        peer_addr_len = sizeof(peer_addr);\n"
"        nread = recvfrom(sfd, buf, BUF_SIZE, 0,\n"
"                (struct sockaddr *) &peer_addr, &peer_addr_len);\n"
"        if (nread == -1)\n"
"            continue;               /* Ignore failed request */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:731
#, no-wrap
msgid "        char host[NI_MAXHOST], service[NI_MAXSERV];\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:740
#, no-wrap
msgid ""
"        s = getnameinfo((struct sockaddr *) &peer_addr,\n"
"                        peer_addr_len, host, NI_MAXHOST,\n"
"                        service, NI_MAXSERV, NI_NUMERICSERV);\n"
"        if (s == 0)\n"
"            printf(\"Received %zd bytes from %s:%s\\en\",\n"
"                    nread, host, service);\n"
"        else\n"
"            fprintf(stderr, \"getnameinfo: %s\\en\", gai_strerror(s));\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:747
#, no-wrap
msgid ""
"        if (sendto(sfd, buf, nread, 0,\n"
"                    (struct sockaddr *) &peer_addr,\n"
"                    peer_addr_len) != nread)\n"
"            fprintf(stderr, \"Error sending response\\en\");\n"
"    }\n"
"}\n"
msgstr ""

#. type: SS
#: build/C/man3/getaddrinfo.3:748
#, no-wrap
msgid "Client program"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:758
#, no-wrap
msgid ""
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>netdb.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:770
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct addrinfo hints;\n"
"    struct addrinfo *result, *rp;\n"
"    int sfd, s;\n"
"    size_t len;\n"
"    ssize_t nread;\n"
"    char buf[BUF_SIZE];\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:775
#, no-wrap
msgid ""
"    if (argc E<lt> 3) {\n"
"        fprintf(stderr, \"Usage: %s host port msg...\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:777
#, no-wrap
msgid "    /* Obtain address(es) matching host/port */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:783
#, no-wrap
msgid ""
"    memset(&hints, 0, sizeof(hints));\n"
"    hints.ai_family = AF_UNSPEC;    /* Allow IPv4 or IPv6 */\n"
"    hints.ai_socktype = SOCK_DGRAM; /* Datagram socket */\n"
"    hints.ai_flags = 0;\n"
"    hints.ai_protocol = 0;          /* Any protocol */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:789
#, no-wrap
msgid ""
"    s = getaddrinfo(argv[1], argv[2], &hints, &result);\n"
"    if (s != 0) {\n"
"        fprintf(stderr, \"getaddrinfo: %s\\en\", gai_strerror(s));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:794
#, no-wrap
msgid ""
"    /* getaddrinfo() returns a list of address structures.\n"
"       Try each address until we successfully connect(2).\n"
"       If socket(2) (or connect(2)) fails, we (close the socket\n"
"       and) try the next address. */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:800
#, no-wrap
msgid ""
"    for (rp = result; rp != NULL; rp = rp-E<gt>ai_next) {\n"
"        sfd = socket(rp-E<gt>ai_family, rp-E<gt>ai_socktype,\n"
"                     rp-E<gt>ai_protocol);\n"
"        if (sfd == -1)\n"
"            continue;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:803
#, no-wrap
msgid ""
"        if (connect(sfd, rp-E<gt>ai_addr, rp-E<gt>ai_addrlen) != -1)\n"
"            break;                  /* Success */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:813
#, no-wrap
msgid ""
"    if (rp == NULL) {               /* No address succeeded */\n"
"        fprintf(stderr, \"Could not connect\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:816
#, no-wrap
msgid ""
"    /* Send remaining command-line arguments as separate\n"
"       datagrams, and read responses from server */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:820
#, no-wrap
msgid ""
"    for (int j = 3; j E<lt> argc; j++) {\n"
"        len = strlen(argv[j]) + 1;\n"
"                /* +1 for terminating null byte */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:826
#, no-wrap
msgid ""
"        if (len E<gt> BUF_SIZE) {\n"
"            fprintf(stderr,\n"
"                    \"Ignoring long message in argument %d\\en\", j);\n"
"            continue;\n"
"        }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:831
#, no-wrap
msgid ""
"        if (write(sfd, argv[j], len) != len) {\n"
"            fprintf(stderr, \"partial/failed write\\en\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:837
#, no-wrap
msgid ""
"        nread = read(sfd, buf, BUF_SIZE);\n"
"        if (nread == -1) {\n"
"            perror(\"read\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:840
#, no-wrap
msgid ""
"        printf(\"Received %zd bytes: %s\\en\", nread, buf);\n"
"    }\n"
msgstr ""

#.  .BR getipnodebyaddr (3),
#.  .BR getipnodebyname (3),
#. type: Plain text
#: build/C/man3/getaddrinfo.3:854
msgid ""
"B<getaddrinfo_a>(3), B<gethostbyname>(3), B<getnameinfo>(3), B<inet>(3), "
"B<gai.conf>(5), B<hostname>(7), B<ip>(7)"
msgstr ""

#. type: TH
#: build/C/man3/getaddrinfo_a.3:30
#, no-wrap
msgid "GETADDRINFO_A"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:34
msgid ""
"getaddrinfo_a, gai_suspend, gai_error, gai_cancel - asynchronous network "
"address and service translation"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:38
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>netdb.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:41
#, no-wrap
msgid ""
"B<int getaddrinfo_a(int >I<mode>B<, struct gaicb *>I<list[]>B<,>\n"
"B<                int >I<nitems>B<, struct sigevent *>I<sevp>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:44
#, no-wrap
msgid ""
"B<int gai_suspend(const struct gaicb * const >I<list[]>B<, int "
">I<nitems>B<,>\n"
"B<                const struct timespec *>I<timeout>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:46
#, no-wrap
msgid "B<int gai_error(struct gaicb *>I<req>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:48
#, no-wrap
msgid "B<int gai_cancel(struct gaicb *>I<req>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:50
#, no-wrap
msgid "Link with I<-lanl>.\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:58
msgid ""
"The B<getaddrinfo_a>()  function performs the same task as "
"B<getaddrinfo>(3), but allows multiple name look-ups to be performed "
"asynchronously, with optional notification on completion of look-up "
"operations."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:62
msgid "The I<mode> argument has one of the following values:"
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo_a.3:62
#, no-wrap
msgid "B<GAI_WAIT>"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:66
msgid ""
"Perform the look-ups synchronously.  The call blocks until the look-ups have "
"completed."
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo_a.3:66
#, no-wrap
msgid "B<GAI_NOWAIT>"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:74
msgid ""
"Perform the look-ups asynchronously.  The call returns immediately, and the "
"requests are resolved in the background.  See the discussion of the I<sevp> "
"argument below."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:89
msgid ""
"The array I<list> specifies the look-up requests to process.  The I<nitems> "
"argument specifies the number of elements in I<list>.  The requested look-up "
"operations are started in parallel.  NULL elements in I<list> are ignored.  "
"Each request is described by a I<gaicb> structure, defined as follows:"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:98
#, no-wrap
msgid ""
"struct gaicb {\n"
"    const char            *ar_name;\n"
"    const char            *ar_service;\n"
"    const struct addrinfo *ar_request;\n"
"    struct addrinfo       *ar_result;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:129
msgid ""
"The elements of this structure correspond to the arguments of "
"B<getaddrinfo>(3).  Thus, I<ar_name> corresponds to the I<node> argument and "
"I<ar_service> to the I<service> argument, identifying an Internet host and a "
"service.  The I<ar_request> element corresponds to the I<hints> argument, "
"specifying the criteria for selecting the returned socket address "
"structures.  Finally, I<ar_result> corresponds to the I<res> argument; you "
"do not need to initialize this element, it will be automatically set when "
"the request is resolved.  The I<addrinfo> structure referenced by the last "
"two elements is described in B<getaddrinfo>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:145
msgid ""
"When I<mode> is specified as B<GAI_NOWAIT>, notifications about resolved "
"requests can be obtained by employing the I<sigevent> structure pointed to "
"by the I<sevp> argument.  For the definition and general details of this "
"structure, see B<sigevent>(7).  The I<sevp-E<gt>sigev_notify> field can have "
"the following values:"
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo_a.3:145
#, no-wrap
msgid "B<SIGEV_NONE>"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:148
msgid "Don't provide any notification."
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo_a.3:148
#, no-wrap
msgid "B<SIGEV_SIGNAL>"
msgstr ""

#.  si_pid and si_uid are also set, to the values of the calling process,
#.  which doesn't provide useful information, so we'll skip mentioning it.
#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:164
msgid ""
"When a look-up completes, generate the signal I<sigev_signo> for the "
"process.  See B<sigevent>(7)  for general details.  The I<si_code> field of "
"the I<siginfo_t> structure will be set to B<SI_ASYNCNL>."
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo_a.3:164
#, no-wrap
msgid "B<SIGEV_THREAD>"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:172
msgid ""
"When a look-up completes, invoke I<sigev_notify_function> as if it were the "
"start function of a new thread.  See B<sigevent>(7)  for details."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:181
msgid ""
"For B<SIGEV_SIGNAL> and B<SIGEV_THREAD>, it may be useful to point "
"I<sevp-E<gt>sigev_value.sival_ptr> to I<list>."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:192
msgid ""
"The B<gai_suspend>()  function suspends execution of the calling thread, "
"waiting for the completion of one or more requests in the array I<list>.  "
"The I<nitems> argument specifies the size of the array I<list>.  The call "
"blocks until one of the following occurs:"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:196
msgid "One or more of the operations in I<list> completes."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:198
msgid "The call is interrupted by a signal that is caught."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:211
msgid ""
"The time interval specified in I<timeout> elapses.  This argument specifies "
"a timeout in seconds plus nanoseconds (see B<nanosleep>(2)  for details of "
"the I<timespec> structure).  If I<timeout> is NULL, then the call blocks "
"indefinitely (until one of the events above occurs)."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:216
msgid ""
"No explicit indication of which request was completed is given; you must "
"determine which request(s) have completed by iterating with B<gai_error>()  "
"over the list of requests."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:226
msgid ""
"The B<gai_error>()  function returns the status of the request I<req>: "
"either B<EAI_INPROGRESS> if the request was not completed yet, 0 if it was "
"handled successfully, or an error code if the request could not be resolved."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:243
msgid ""
"The B<gai_cancel>()  function cancels the request I<req>.  If the request "
"has been canceled successfully, the error status of the request will be set "
"to B<EAI_CANCELED> and normal asynchronous notification will be performed.  "
"The request cannot be canceled if it is currently being processed; in that "
"case, it will be handled as if B<gai_cancel>()  has never been called.  If "
"I<req> is NULL, an attempt is made to cancel all outstanding requests that "
"the process has made."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:248
msgid ""
"The B<getaddrinfo_a>()  function returns 0 if all of the requests have been "
"enqueued successfully, or one of the following nonzero error codes:"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:253
msgid ""
"The resources necessary to enqueue the look-up requests were not available.  "
"The application may check the error status of each request to determine "
"which ones failed."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:260
msgid "I<mode> is invalid."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:265
msgid ""
"The B<gai_suspend>()  function returns 0 if at least one of the listed "
"requests has been completed.  Otherwise, it returns one of the following "
"nonzero error codes:"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:268
msgid "The given timeout expired before any of the requests could be completed."
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo_a.3:268 build/C/man3/getaddrinfo_a.3:298
#, no-wrap
msgid "B<EAI_ALLDONE>"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:271
msgid "There were no actual requests given to the function."
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo_a.3:271
#, no-wrap
msgid "B<EAI_INTR>"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:276
msgid ""
"A signal has interrupted the function.  Note that this interruption might "
"have been caused by signal notification of some completed look-up request."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:288
msgid ""
"The B<gai_error>()  function can return B<EAI_INPROGRESS> for an unfinished "
"look-up request, 0 for a successfully completed look-up (as described "
"above), one of the error codes that could be returned by B<getaddrinfo>(3), "
"or the error code B<EAI_CANCELED> if the request has been canceled "
"explicitly before it could be finished."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:292
msgid "The B<gai_cancel>()  function can return one of these values:"
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo_a.3:292
#, no-wrap
msgid "B<EAI_CANCELED>"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:295
msgid "The request has been canceled successfully."
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo_a.3:295
#, no-wrap
msgid "B<EAI_NOTCANCELED>"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:298
msgid "The request has not been canceled."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:301
msgid "The request has already completed."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:306 build/C/man3/getnameinfo.3:198
msgid ""
"The B<gai_strerror>(3)  function translates these error codes to a human "
"readable string, suitable for error reporting."
msgstr ""

#. type: tbl table
#: build/C/man3/getaddrinfo_a.3:319
#, no-wrap
msgid ""
"B<getaddrinfo_a>(),\n"
"B<gai_suspend>(),\n"
"B<gai_error>(),\n"
"B<gai_cancel>()"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:325
msgid ""
"These functions are GNU extensions; they first appeared in glibc in version "
"2.2.3."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:331
msgid ""
"The interface of B<getaddrinfo_a>()  was modeled after the B<lio_listio>(3)  "
"interface."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:335
msgid ""
"Two examples are provided: a simple example that resolves several requests "
"in parallel synchronously, and a complex example showing some of the "
"asynchronous capabilities."
msgstr ""

#. type: SS
#: build/C/man3/getaddrinfo_a.3:335
#, no-wrap
msgid "Synchronous example"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:340
msgid ""
"The program below simply resolves several hostnames in parallel, giving a "
"speed-up compared to resolving the hostnames sequentially using "
"B<getaddrinfo>(3).  The program might be used like this:"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:347
#, no-wrap
msgid ""
"$ B<./a.out ftp.us.kernel.org enoent.linuxfoundation.org gnu.cz>\n"
"ftp.us.kernel.org: 128.30.2.36\n"
"enoent.linuxfoundation.org: Name or service not known\n"
"gnu.cz: 87.236.197.13\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:351
msgid "Here is the program source code"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:358 build/C/man3/getaddrinfo_a.3:447
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>netdb.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:366
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int ret;\n"
"    struct gaicb *reqs[argc - 1];\n"
"    char host[NI_MAXHOST];\n"
"    struct addrinfo *res;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:371
#, no-wrap
msgid ""
"    if (argc E<lt> 2) {\n"
"        fprintf(stderr, \"Usage: %s HOST...\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:381
#, no-wrap
msgid ""
"    for (int i = 0; i E<lt> argc - 1; i++) {\n"
"        reqs[i] = malloc(sizeof(*reqs[0]));\n"
"        if (reqs[i] == NULL) {\n"
"            perror(\"malloc\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"        memset(reqs[i], 0, sizeof(*reqs[0]));\n"
"        reqs[i]-E<gt>ar_name = argv[i + 1];\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:388
#, no-wrap
msgid ""
"    ret = getaddrinfo_a(GAI_WAIT, reqs, argc - 1, NULL);\n"
"    if (ret != 0) {\n"
"        fprintf(stderr, \"getaddrinfo_a() failed: %s\\en\",\n"
"                gai_strerror(ret));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:394
#, no-wrap
msgid ""
"    for (int i = 0; i E<lt> argc - 1; i++) {\n"
"        printf(\"%s: \", reqs[i]-E<gt>ar_name);\n"
"        ret = gai_error(reqs[i]);\n"
"        if (ret == 0) {\n"
"            res = reqs[i]-E<gt>ar_result;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:404
#, no-wrap
msgid ""
"            ret = getnameinfo(res-E<gt>ai_addr, res-E<gt>ai_addrlen,\n"
"                    host, sizeof(host),\n"
"                    NULL, 0, NI_NUMERICHOST);\n"
"            if (ret != 0) {\n"
"                fprintf(stderr, \"getnameinfo() failed: %s\\en\",\n"
"                        gai_strerror(ret));\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
"            puts(host);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:411
#, no-wrap
msgid ""
"        } else {\n"
"            puts(gai_strerror(ret));\n"
"        }\n"
"    }\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: SS
#: build/C/man3/getaddrinfo_a.3:412
#, no-wrap
msgid "Asynchronous example"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:417
msgid ""
"This example shows a simple interactive B<getaddrinfo_a>()  front-end.  The "
"notification facility is not demonstrated."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:419
msgid "An example session might look like this:"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:436
#, no-wrap
msgid ""
"$ B<./a.out>\n"
"E<gt> a ftp.us.kernel.org enoent.linuxfoundation.org gnu.cz\n"
"E<gt> c 2\n"
"[2] gnu.cz: Request not canceled\n"
"E<gt> w 0 1\n"
"[00] ftp.us.kernel.org: Finished\n"
"E<gt> l\n"
"[00] ftp.us.kernel.org: 216.165.129.139\n"
"[01] enoent.linuxfoundation.org: Processing request in progress\n"
"[02] gnu.cz: 87.236.197.13\n"
"E<gt> l\n"
"[00] ftp.us.kernel.org: 216.165.129.139\n"
"[01] enoent.linuxfoundation.org: Name or service not known\n"
"[02] gnu.cz: 87.236.197.13\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:440
msgid "The program source is as follows:"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:450
#, no-wrap
msgid ""
"static struct gaicb **reqs = NULL;\n"
"static int nreqs = 0;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:455
#, no-wrap
msgid ""
"static char *\n"
"getcmd(void)\n"
"{\n"
"    static char buf[256];\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:459
#, no-wrap
msgid ""
"    fputs(\"E<gt> \", stdout); fflush(stdout);\n"
"    if (fgets(buf, sizeof(buf), stdin) == NULL)\n"
"        return NULL;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:462
#, no-wrap
msgid ""
"    if (buf[strlen(buf) - 1] == \\(aq\\en\\(aq)\n"
"        buf[strlen(buf) - 1] = 0;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:465
#, no-wrap
msgid ""
"    return buf;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:473
#, no-wrap
msgid ""
"/* Add requests for specified hostnames */\n"
"static void\n"
"add_requests(void)\n"
"{\n"
"    int nreqs_base = nreqs;\n"
"    char *host;\n"
"    int ret;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:477
#, no-wrap
msgid ""
"    while ((host = strtok(NULL, \" \"))) {\n"
"        nreqs++;\n"
"        reqs = realloc(reqs, sizeof(reqs[0]) * nreqs);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:481
#, no-wrap
msgid ""
"        reqs[nreqs - 1] = calloc(1, sizeof(*reqs[0]));\n"
"        reqs[nreqs - 1]-E<gt>ar_name = strdup(host);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:483
#, no-wrap
msgid "    /* Queue nreqs_base..nreqs requests. */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:492
#, no-wrap
msgid ""
"    ret = getaddrinfo_a(GAI_NOWAIT, &reqs[nreqs_base],\n"
"                        nreqs - nreqs_base, NULL);\n"
"    if (ret) {\n"
"        fprintf(stderr, \"getaddrinfo_a() failed: %s\\en\",\n"
"                gai_strerror(ret));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:501
#, no-wrap
msgid ""
"/* Wait until at least one of specified requests completes */\n"
"static void\n"
"wait_requests(void)\n"
"{\n"
"    char *id;\n"
"    int ret, n;\n"
"    struct gaicb const **wait_reqs = calloc(nreqs, sizeof(*wait_reqs));\n"
"                /* NULL elements are ignored by gai_suspend(). */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:504 build/C/man3/getaddrinfo_a.3:541
#, no-wrap
msgid ""
"    while ((id = strtok(NULL, \" \")) != NULL) {\n"
"        n = atoi(id);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:509 build/C/man3/getaddrinfo_a.3:546
#, no-wrap
msgid ""
"        if (n E<gt>= nreqs) {\n"
"            printf(\"Bad request number: %s\\en\", id);\n"
"            return;\n"
"        }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:512
#, no-wrap
msgid ""
"        wait_reqs[n] = reqs[n];\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:518
#, no-wrap
msgid ""
"    ret = gai_suspend(wait_reqs, nreqs, NULL);\n"
"    if (ret) {\n"
"        printf(\"gai_suspend(): %s\\en\", gai_strerror(ret));\n"
"        return;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:522
#, no-wrap
msgid ""
"    for (int i = 0; i E<lt> nreqs; i++) {\n"
"        if (wait_reqs[i] == NULL)\n"
"            continue;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:526
#, no-wrap
msgid ""
"        ret = gai_error(reqs[i]);\n"
"        if (ret == EAI_INPROGRESS)\n"
"            continue;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:531
#, no-wrap
msgid ""
"        printf(\"[%02d] %s: %s\\en\", i, reqs[i]-E<gt>ar_name,\n"
"               ret == 0 ? \"Finished\" : gai_strerror(ret));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:538
#, no-wrap
msgid ""
"/* Cancel specified requests */\n"
"static void\n"
"cancel_requests(void)\n"
"{\n"
"    char *id;\n"
"    int ret, n;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:552
#, no-wrap
msgid ""
"        ret = gai_cancel(reqs[n]);\n"
"        printf(\"[%s] %s: %s\\en\", id, reqs[atoi(id)]-E<gt>ar_name,\n"
"               gai_strerror(ret));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:560
#, no-wrap
msgid ""
"/* List all requests */\n"
"static void\n"
"list_requests(void)\n"
"{\n"
"    int ret;\n"
"    char host[NI_MAXHOST];\n"
"    struct addrinfo *res;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:564
#, no-wrap
msgid ""
"    for (int i = 0; i E<lt> nreqs; i++) {\n"
"        printf(\"[%02d] %s: \", i, reqs[i]-E<gt>ar_name);\n"
"        ret = gai_error(reqs[i]);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:567
#, no-wrap
msgid ""
"        if (!ret) {\n"
"            res = reqs[i]-E<gt>ar_result;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:582
#, no-wrap
msgid ""
"            ret = getnameinfo(res-E<gt>ai_addr, res-E<gt>ai_addrlen,\n"
"                              host, sizeof(host),\n"
"                              NULL, 0, NI_NUMERICHOST);\n"
"            if (ret) {\n"
"                fprintf(stderr, \"getnameinfo() failed: %s\\en\",\n"
"                        gai_strerror(ret));\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
"            puts(host);\n"
"        } else {\n"
"            puts(gai_strerror(ret));\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:588
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *cmdline;\n"
"    char *cmd;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:591
#, no-wrap
msgid ""
"    while ((cmdline = getcmd()) != NULL) {\n"
"        cmd = strtok(cmdline, \" \");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:616
#, no-wrap
msgid ""
"        if (cmd == NULL) {\n"
"            list_requests();\n"
"        } else {\n"
"            switch (cmd[0]) {\n"
"            case \\(aqa\\(aq:\n"
"                add_requests();\n"
"                break;\n"
"            case \\(aqw\\(aq:\n"
"                wait_requests();\n"
"                break;\n"
"            case \\(aqc\\(aq:\n"
"                cancel_requests();\n"
"                break;\n"
"            case \\(aql\\(aq:\n"
"                list_requests();\n"
"                break;\n"
"            default:\n"
"                fprintf(stderr, \"Bad command: %c\\en\", cmd[0]);\n"
"                break;\n"
"            }\n"
"        }\n"
"    }\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:624
msgid ""
"B<getaddrinfo>(3), B<inet>(3), B<lio_listio>(3), B<hostname>(7), B<ip>(7), "
"B<sigevent>(7)"
msgstr ""

#. type: TH
#: build/C/man1/getent.1:25
#, no-wrap
msgid "GETENT"
msgstr ""

#. type: TH
#: build/C/man1/getent.1:25 build/C/man3/gethostbyname.3:38 build/C/man3/getnetent.3:30 build/C/man3/getprotoent.3:30 build/C/man3/getservent.3:34 build/C/man3/inet.3:42 build/C/man7/ipv6.7:86 build/C/man5/nscd.conf.5:20 build/C/man7/packet.7:12 build/C/man3/rcmd.3:43 build/C/man3/resolver.3:33 build/C/man7/tcp.7:96
#, no-wrap
msgid "2020-12-21"
msgstr ""

#. type: TH
#: build/C/man1/getent.1:25
#, no-wrap
msgid "User Commands"
msgstr ""

#. type: Plain text
#: build/C/man1/getent.1:28
msgid "getent - get entries from Name Service Switch libraries"
msgstr ""

#. type: Plain text
#: build/C/man1/getent.1:30
msgid "B<getent\\ [>I<option>B<]...\\ >I<database>B<\\ >I<key>B<...>"
msgstr ""

#. type: Plain text
#: build/C/man1/getent.1:45
msgid ""
"The B<getent> command displays entries from databases supported by the Name "
"Service Switch libraries, which are configured in I</etc/nsswitch.conf>.  If "
"one or more I<key> arguments are provided, then only the entries that match "
"the supplied keys will be displayed.  Otherwise, if no I<key> is provided, "
"all entries will be displayed (unless the database does not support "
"enumeration)."
msgstr ""

#. type: Plain text
#: build/C/man1/getent.1:49
msgid ""
"The I<database> may be any of those supported by the GNU C Library, listed "
"below:"
msgstr ""

#. type: TP
#: build/C/man1/getent.1:50
#, no-wrap
msgid "B<ahosts>"
msgstr ""

#. type: Plain text
#: build/C/man1/getent.1:71
msgid ""
"When no I<key> is provided, use B<sethostent>(3), B<gethostent>(3), and "
"B<endhostent>(3)  to enumerate the hosts database.  This is identical to "
"using B<hosts>.  When one or more I<key> arguments are provided, pass each "
"I<key> in succession to B<getaddrinfo>(3)  with the address family "
"B<AF_UNSPEC>, enumerating each socket address structure returned."
msgstr ""

#. type: TP
#: build/C/man1/getent.1:71
#, no-wrap
msgid "B<ahostsv4>"
msgstr ""

#. type: Plain text
#: build/C/man1/getent.1:77
msgid "Same as B<ahosts>, but use the address family B<AF_INET>."
msgstr ""

#. type: TP
#: build/C/man1/getent.1:77
#, no-wrap
msgid "B<ahostsv6>"
msgstr ""

#. type: Plain text
#: build/C/man1/getent.1:88
msgid ""
"Same as B<ahosts>, but use the address family B<AF_INET6>.  The call to "
"B<getaddrinfo>(3)  in this case includes the B<AI_V4MAPPED> flag."
msgstr ""

#. type: TP
#: build/C/man1/getent.1:88 build/C/man5/nsswitch.conf.5:44 build/C/man5/nsswitch.conf.5:371
#, no-wrap
msgid "B<aliases>"
msgstr ""

#. type: Plain text
#: build/C/man1/getent.1:105
msgid ""
"When no I<key> is provided, use B<setaliasent>(3), B<getaliasent>(3), and "
"B<endaliasent>(3)  to enumerate the aliases database.  When one or more "
"I<key> arguments are provided, pass each I<key> in succession to "
"B<getaliasbyname>(3)  and display the result."
msgstr ""

#. type: TP
#: build/C/man1/getent.1:105 build/C/man5/nsswitch.conf.5:49 build/C/man5/nsswitch.conf.5:375
#, no-wrap
msgid "B<ethers>"
msgstr ""

#. type: Plain text
#: build/C/man1/getent.1:121
msgid ""
"When one or more I<key> arguments are provided, pass each I<key> in "
"succession to B<ether_aton>(3)  and B<ether_hostton>(3)  until a result is "
"obtained, and display the result.  Enumeration is not supported on "
"B<ethers>, so a I<key> must be provided."
msgstr ""

#. type: TP
#: build/C/man1/getent.1:121 build/C/man5/nsswitch.conf.5:52 build/C/man5/nsswitch.conf.5:378
#, no-wrap
msgid "B<group>"
msgstr ""

#. type: Plain text
#: build/C/man1/getent.1:142
msgid ""
"When no I<key> is provided, use B<setgrent>(3), B<getgrent>(3), and "
"B<endgrent>(3)  to enumerate the group database.  When one or more I<key> "
"arguments are provided, pass each numeric I<key> to B<getgrgid>(3)  and each "
"nonnumeric I<key> to B<getgrnam>(3)  and display the result."
msgstr ""

#. type: TP
#: build/C/man1/getent.1:142
#, no-wrap
msgid "B<gshadow>"
msgstr ""

#. type: Plain text
#: build/C/man1/getent.1:159
msgid ""
"When no I<key> is provided, use B<setsgent>(3), B<getsgent>(3), and "
"B<endsgent>(3)  to enumerate the gshadow database.  When one or more I<key> "
"arguments are provided, pass each I<key> in succession to B<getsgnam>(3)  "
"and display the result."
msgstr ""

#. type: TP
#: build/C/man1/getent.1:159 build/C/man5/nsswitch.conf.5:57 build/C/man5/nsswitch.conf.5:381
#, no-wrap
msgid "B<hosts>"
msgstr ""

#. type: Plain text
#: build/C/man1/getent.1:182
msgid ""
"When no I<key> is provided, use B<sethostent>(3), B<gethostent>(3), and "
"B<endhostent>(3)  to enumerate the hosts database.  When one or more I<key> "
"arguments are provided, pass each I<key> to B<gethostbyaddr>(3)  or "
"B<gethostbyname2>(3), depending on whether a call to B<inet_pton>(3)  "
"indicates that the I<key> is an IPv6 or IPv4 address or not, and display the "
"result."
msgstr ""

#. type: TP
#: build/C/man1/getent.1:182 build/C/man5/nsswitch.conf.5:62 build/C/man5/nsswitch.conf.5:384
#, no-wrap
msgid "B<initgroups>"
msgstr ""

#. type: Plain text
#: build/C/man1/getent.1:196
msgid ""
"When one or more I<key> arguments are provided, pass each I<key> in "
"succession to B<getgrouplist>(3)  and display the result.  Enumeration is "
"not supported on B<initgroups>, so a I<key> must be provided."
msgstr ""

#. type: TP
#: build/C/man1/getent.1:196 build/C/man5/nsswitch.conf.5:67 build/C/man5/nsswitch.conf.5:387
#, no-wrap
msgid "B<netgroup>"
msgstr ""

#. type: Plain text
#: build/C/man1/getent.1:222
msgid ""
"When one I<key> is provided, pass the I<key> to B<setnetgrent>(3)  and, "
"using B<getnetgrent>(3)  display the resulting string triple (I<hostname>, "
"I<username>, I<domainname>).  Alternatively, three I<keys> may be provided, "
"which are interpreted as the I<hostname>, I<username>, and I<domainname> to "
"match to a netgroup name via B<innetgr>(3).  Enumeration is not supported on "
"B<netgroup>, so either one or three I<keys> must be provided."
msgstr ""

#. type: TP
#: build/C/man1/getent.1:222 build/C/man5/nsswitch.conf.5:71 build/C/man5/nsswitch.conf.5:390
#, no-wrap
msgid "B<networks>"
msgstr ""

#. type: Plain text
#: build/C/man1/getent.1:243
msgid ""
"When no I<key> is provided, use B<setnetent>(3), B<getnetent>(3), and "
"B<endnetent>(3)  to enumerate the networks database.  When one or more "
"I<key> arguments are provided, pass each numeric I<key> to "
"B<getnetbyaddr>(3)  and each nonnumeric I<key> to B<getnetbyname>(3)  and "
"display the result."
msgstr ""

#. type: TP
#: build/C/man1/getent.1:243 build/C/man5/nsswitch.conf.5:76 build/C/man5/nsswitch.conf.5:393
#, no-wrap
msgid "B<passwd>"
msgstr ""

#. type: Plain text
#: build/C/man1/getent.1:264
msgid ""
"When no I<key> is provided, use B<setpwent>(3), B<getpwent>(3), and "
"B<endpwent>(3)  to enumerate the passwd database.  When one or more I<key> "
"arguments are provided, pass each numeric I<key> to B<getpwuid>(3)  and each "
"nonnumeric I<key> to B<getpwnam>(3)  and display the result."
msgstr ""

#. type: TP
#: build/C/man1/getent.1:264 build/C/man5/nsswitch.conf.5:81 build/C/man5/nsswitch.conf.5:396
#, no-wrap
msgid "B<protocols>"
msgstr ""

#. type: Plain text
#: build/C/man1/getent.1:285
msgid ""
"When no I<key> is provided, use B<setprotoent>(3), B<getprotoent>(3), and "
"B<endprotoent>(3)  to enumerate the protocols database.  When one or more "
"I<key> arguments are provided, pass each numeric I<key> to "
"B<getprotobynumber>(3)  and each nonnumeric I<key> to B<getprotobyname>(3)  "
"and display the result."
msgstr ""

#. type: TP
#: build/C/man1/getent.1:285 build/C/man5/nsswitch.conf.5:89 build/C/man5/nsswitch.conf.5:402
#, no-wrap
msgid "B<rpc>"
msgstr ""

#. type: Plain text
#: build/C/man1/getent.1:306
msgid ""
"When no I<key> is provided, use B<setrpcent>(3), B<getrpcent>(3), and "
"B<endrpcent>(3)  to enumerate the rpc database.  When one or more I<key> "
"arguments are provided, pass each numeric I<key> to B<getrpcbynumber>(3)  "
"and each nonnumeric I<key> to B<getrpcbyname>(3)  and display the result."
msgstr ""

#. type: TP
#: build/C/man1/getent.1:306 build/C/man5/nsswitch.conf.5:94 build/C/man5/nsswitch.conf.5:405
#, no-wrap
msgid "B<services>"
msgstr ""

#. type: Plain text
#: build/C/man1/getent.1:327
msgid ""
"When no I<key> is provided, use B<setservent>(3), B<getservent>(3), and "
"B<endservent>(3)  to enumerate the services database.  When one or more "
"I<key> arguments are provided, pass each numeric I<key> to "
"B<getservbynumber>(3)  and each nonnumeric I<key> to B<getservbyname>(3)  "
"and display the result."
msgstr ""

#. type: TP
#: build/C/man1/getent.1:327 build/C/man5/nsswitch.conf.5:99 build/C/man5/nsswitch.conf.5:408
#, no-wrap
msgid "B<shadow>"
msgstr ""

#. type: Plain text
#: build/C/man1/getent.1:344
msgid ""
"When no I<key> is provided, use B<setspent>(3), B<getspent>(3), and "
"B<endspent>(3)  to enumerate the shadow database.  When one or more I<key> "
"arguments are provided, pass each I<key> in succession to B<getspnam>(3)  "
"and display the result."
msgstr ""

#. type: SH
#: build/C/man1/getent.1:345 build/C/man8/nscd.8:60
#, no-wrap
msgid "OPTIONS"
msgstr ""

#. type: TP
#: build/C/man1/getent.1:346
#, no-wrap
msgid "B<-s\\ >I<service>, B<--service\\ >I<service>"
msgstr ""

#.  commit 9d0881aa76b399e6a025c5cf44bebe2ae0efa8af (glibc)
#. type: Plain text
#: build/C/man1/getent.1:351
msgid "Override all databases with the specified service.  (Since glibc 2.2.5.)"
msgstr ""

#. type: TP
#: build/C/man1/getent.1:351
#, no-wrap
msgid "B<-s\\ >I<database>B<:>I<service>, B<--service\\ >I<database>B<:>I<service>"
msgstr ""

#.  commit b4f6f4be85d32b9c03361c38376e36f08100e3e8 (glibc)
#. type: Plain text
#: build/C/man1/getent.1:359
msgid ""
"Override only specified databases with the specified service.  The option "
"may be used multiple times, but only the last service for each database will "
"be used.  (Since glibc 2.4.)"
msgstr ""

#. type: TP
#: build/C/man1/getent.1:359
#, no-wrap
msgid "B<-i>, B<--no-idn>"
msgstr ""

#.  commit a160f8d808cf8020b13bd0ef4a9eaf3c11f964ad (glibc)
#. type: Plain text
#: build/C/man1/getent.1:365
msgid ""
"Disables IDN encoding in lookups for B<ahosts>/B<getaddrinfo>(3)  (Since "
"glibc-2.13.)"
msgstr ""

#. type: TP
#: build/C/man1/getent.1:365
#, no-wrap
msgid "B<-?>, B<--help>"
msgstr ""

#. type: Plain text
#: build/C/man1/getent.1:368
msgid "Print a usage summary and exit."
msgstr ""

#. type: TP
#: build/C/man1/getent.1:368
#, no-wrap
msgid "B<--usage>"
msgstr ""

#. type: Plain text
#: build/C/man1/getent.1:371
msgid "Print a short usage summary and exit."
msgstr ""

#. type: TP
#: build/C/man1/getent.1:371
#, no-wrap
msgid "B<-V>, B<--version>"
msgstr ""

#. type: Plain text
#: build/C/man1/getent.1:375
msgid "Print the version number, license, and disclaimer of warranty for B<getent>."
msgstr ""

#. type: SH
#: build/C/man1/getent.1:375
#, no-wrap
msgid "EXIT STATUS"
msgstr ""

#. type: Plain text
#: build/C/man1/getent.1:378
msgid "One of the following exit values can be returned by B<getent>:"
msgstr ""

#. type: TP
#: build/C/man1/getent.1:379
#, no-wrap
msgid "B<0>"
msgstr ""

#. type: Plain text
#: build/C/man1/getent.1:382
msgid "Command completed successfully."
msgstr ""

#. type: TP
#: build/C/man1/getent.1:382
#, no-wrap
msgid "B<1>"
msgstr ""

#. type: Plain text
#: build/C/man1/getent.1:387
msgid "Missing arguments, or I<database> unknown."
msgstr ""

#. type: TP
#: build/C/man1/getent.1:387
#, no-wrap
msgid "B<2>"
msgstr ""

#. type: Plain text
#: build/C/man1/getent.1:393
msgid "One or more supplied I<key> could not be found in the I<database>."
msgstr ""

#. type: TP
#: build/C/man1/getent.1:393
#, no-wrap
msgid "B<3>"
msgstr ""

#. type: Plain text
#: build/C/man1/getent.1:397
msgid "Enumeration not supported on this I<database>."
msgstr ""

#. type: Plain text
#: build/C/man1/getent.1:400
msgid "B<nsswitch.conf>(5)"
msgstr ""

#. type: TH
#: build/C/man3/gethostbyname.3:38
#, no-wrap
msgid "GETHOSTBYNAME"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:46
msgid ""
"gethostbyname, gethostbyaddr, sethostent, gethostent, endhostent, h_errno, "
"herror, hstrerror, gethostbyaddr_r, gethostbyname2, gethostbyname2_r, "
"gethostbyname_r, gethostent_r - get network host entry"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:50
#, no-wrap
msgid ""
"B<#include E<lt>netdb.hE<gt>>\n"
"B<extern int h_errno;>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:52
#, no-wrap
msgid "B<struct hostent *gethostbyname(const char *>I<name>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:56
#, no-wrap
msgid ""
"B<#include E<lt>sys/socket.hE<gt>>       /* for AF_INET */\n"
"B<struct hostent *gethostbyaddr(const void *>I<addr>B<,>\n"
"B<                              socklen_t >I<len>B<, int >I<type>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:58
#, no-wrap
msgid "B<void sethostent(int >I<stayopen>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:60
#, no-wrap
msgid "B<void endhostent(void);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:62
#, no-wrap
msgid "B<void herror(const char *>I<s>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:64
#, no-wrap
msgid "B<const char *hstrerror(int >I<err>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:67
#, no-wrap
msgid ""
"/* System V/POSIX extension */\n"
"B<struct hostent *gethostent(void);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:70
#, no-wrap
msgid ""
"/* GNU extensions */\n"
"B<struct hostent *gethostbyname2(const char *>I<name>B<, int >I<af>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:74
#, no-wrap
msgid ""
"B<int gethostent_r(>\n"
"B<        struct hostent *>I<ret>B<, char *>I<buf>B<, size_t "
">I<buflen>B<,>\n"
"B<        struct hostent **>I<result>B<, int *>I<h_errnop>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:78
#, no-wrap
msgid ""
"B<int gethostbyaddr_r(const void *>I<addr>B<, socklen_t >I<len>B<, int "
">I<type>B<,>\n"
"B<        struct hostent *>I<ret>B<, char *>I<buf>B<, size_t "
">I<buflen>B<,>\n"
"B<        struct hostent **>I<result>B<, int *>I<h_errnop>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:82
#, no-wrap
msgid ""
"B<int gethostbyname_r(const char *>I<name>B<,>\n"
"B<        struct hostent *>I<ret>B<, char *>I<buf>B<, size_t "
">I<buflen>B<,>\n"
"B<        struct hostent **>I<result>B<, int *>I<h_errnop>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:86
#, no-wrap
msgid ""
"B<int gethostbyname2_r(const char *>I<name>B<, int >I<af,>\n"
"B<        struct hostent *>I<ret>B<, char *>I<buf>B<, size_t "
">I<buflen>B<,>\n"
"B<        struct hostent **>I<result>B<, int *>I<h_errnop>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:100
msgid ""
"B<gethostbyname2>(), B<gethostent_r>(), B<gethostbyaddr_r>(), "
"B<gethostbyname_r>(), B<gethostbyname2_r>():"
msgstr ""

#. type: TP
#: build/C/man3/gethostbyname.3:101 build/C/man3/gethostbyname.3:114
#, no-wrap
msgid "Since glibc 2.19:"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:104 build/C/man3/gethostbyname.3:117 build/C/man3/inet_net_pton.3:54
msgid "_DEFAULT_SOURCE"
msgstr ""

#. type: TP
#: build/C/man3/gethostbyname.3:104
#, no-wrap
msgid "Glibc versions up to and including 2.19:"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:107 build/C/man3/gethostbyname.3:120 build/C/man3/inet_net_pton.3:57
msgid "_BSD_SOURCE || _SVID_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:113
msgid "B<herror>(), B<hstrerror>():"
msgstr ""

#. type: TP
#: build/C/man3/gethostbyname.3:117
#, no-wrap
msgid "Glibc 2.8 to 2.19:"
msgstr ""

#. type: TP
#: build/C/man3/gethostbyname.3:120
#, no-wrap
msgid "Before glibc 2.8:"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:123 build/C/man3/gethostbyname.3:138
msgid "none"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:128
msgid "B<h_errno>:"
msgstr ""

#. type: TP
#: build/C/man3/gethostbyname.3:129
#, no-wrap
msgid "Since glibc 2.19"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:132
msgid "_DEFAULT_SOURCE || _POSIX_C_SOURCE E<lt> 200809L"
msgstr ""

#. type: TP
#: build/C/man3/gethostbyname.3:132
#, no-wrap
msgid "Glibc 2.12 to 2.19:"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:135
msgid "_BSD_SOURCE || _SVID_SOURCE || _POSIX_C_SOURCE E<lt> 200809L"
msgstr ""

#. type: TP
#: build/C/man3/gethostbyname.3:135
#, no-wrap
msgid "Before glibc 2.12:"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:155
msgid ""
"The B<gethostbyname*>(), B<gethostbyaddr*>(), B<herror>(), and "
"B<hstrerror>()  functions are obsolete.  Applications should use "
"B<getaddrinfo>(3), B<getnameinfo>(3), and B<gai_strerror>(3)  instead."
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:194
msgid ""
"The B<gethostbyname>()  function returns a structure of type I<hostent> for "
"the given host I<name>.  Here I<name> is either a hostname or an IPv4 "
"address in standard dot notation (as for B<inet_addr>(3)).  If I<name> is an "
"IPv4 address, no lookup is performed and B<gethostbyname>()  simply copies "
"I<name> into the I<h_name> field and its I<struct in_addr> equivalent into "
"the I<h_addr_list[0]> field of the returned I<hostent> structure.  If "
"I<name> doesn't end in a dot and the environment variable B<HOSTALIASES> is "
"set, the alias file pointed to by B<HOSTALIASES> will first be searched for "
"I<name> (see B<hostname>(7)  for the file format).  The current domain and "
"its parents are searched unless I<name> ends in a dot."
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:210
msgid ""
"The B<gethostbyaddr>()  function returns a structure of type I<hostent> for "
"the given host address I<addr> of length I<len> and address type I<type>.  "
"Valid address types are B<AF_INET> and B<AF_INET6>.  The host address "
"argument is a pointer to a struct of a type depending on the address type, "
"for example a I<struct in_addr *> (probably obtained via a call to "
"B<inet_addr>(3))  for address type B<AF_INET>."
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:217
msgid ""
"The B<sethostent>()  function specifies, if I<stayopen> is true (1), that a "
"connected TCP socket should be used for the name server queries and that the "
"connection should remain open during successive queries.  Otherwise, name "
"server queries will use UDP datagrams."
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:222
msgid ""
"The B<endhostent>()  function ends the use of a TCP connection for name "
"server queries."
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:227
msgid ""
"The (obsolete)  B<herror>()  function prints the error message associated "
"with the current value of I<h_errno> on I<stderr>."
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:232
msgid ""
"The (obsolete)  B<hstrerror>()  function takes an error number (typically "
"I<h_errno>) and returns the corresponding message string."
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:246
msgid ""
"The domain name queries carried out by B<gethostbyname>()  and "
"B<gethostbyaddr>()  rely on the Name Service Switch (B<nsswitch.conf>(5))  "
"configured sources or a local name server (B<named>(8)).  The default action "
"is to query the Name Service Switch (B<nsswitch.conf>(5))  configured "
"sources, failing that, a local name server (B<named>(8))."
msgstr ""

#. type: SS
#: build/C/man3/gethostbyname.3:246 build/C/man5/host.conf.5:135
#, no-wrap
msgid "Historical"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:250 build/C/man5/host.conf.5:139
msgid ""
"The B<nsswitch.conf>(5)  file is the modern way of controlling the order of "
"host lookups."
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:256
msgid ""
"In glibc 2.4 and earlier, the I<order> keyword was used to control the order "
"of host lookups as defined in I</etc/host.conf> (B<host.conf>(5))."
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:258
msgid "The I<hostent> structure is defined in I<E<lt>netdb.hE<gt>> as follows:"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:269
#, no-wrap
msgid ""
"struct hostent {\n"
"    char  *h_name;            /* official name of host */\n"
"    char **h_aliases;         /* alias list */\n"
"    int    h_addrtype;        /* host address type */\n"
"    int    h_length;          /* length of address */\n"
"    char **h_addr_list;       /* list of addresses */\n"
"}\n"
"#define h_addr h_addr_list[0] /* for backward compatibility */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:273
msgid "The members of the I<hostent> structure are:"
msgstr ""

#. type: TP
#: build/C/man3/gethostbyname.3:273 build/C/man3/getipnodebyname.3:210
#, no-wrap
msgid "I<h_name>"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:276
msgid "The official name of the host."
msgstr ""

#. type: TP
#: build/C/man3/gethostbyname.3:276 build/C/man3/getipnodebyname.3:213
#, no-wrap
msgid "I<h_aliases>"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:279
msgid "An array of alternative names for the host, terminated by a null pointer."
msgstr ""

#. type: TP
#: build/C/man3/gethostbyname.3:279 build/C/man3/getipnodebyname.3:217
#, no-wrap
msgid "I<h_addrtype>"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:286
msgid "The type of address; always B<AF_INET> or B<AF_INET6> at present."
msgstr ""

#. type: TP
#: build/C/man3/gethostbyname.3:286 build/C/man3/getipnodebyname.3:239
#, no-wrap
msgid "I<h_length>"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:289
msgid "The length of the address in bytes."
msgstr ""

#. type: TP
#: build/C/man3/gethostbyname.3:289 build/C/man3/getipnodebyname.3:253
#, no-wrap
msgid "I<h_addr_list>"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:293
msgid ""
"An array of pointers to network addresses for the host (in network byte "
"order), terminated by a null pointer."
msgstr ""

#. type: TP
#: build/C/man3/gethostbyname.3:293
#, no-wrap
msgid "I<h_addr>"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:296
msgid "The first address in I<h_addr_list> for backward compatibility."
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:308
msgid ""
"The B<gethostbyname>()  and B<gethostbyaddr>()  functions return the "
"I<hostent> structure or a null pointer if an error occurs.  On error, the "
"I<h_errno> variable holds an error number.  When non-NULL, the return value "
"may point at static data, see the notes below."
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:310
msgid "The variable I<h_errno> can have the following values:"
msgstr ""

#. type: TP
#: build/C/man3/gethostbyname.3:310 build/C/man3/getipnodebyname.3:190
#, no-wrap
msgid "B<HOST_NOT_FOUND>"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:313
msgid "The specified host is unknown."
msgstr ""

#. type: TP
#: build/C/man3/gethostbyname.3:313
#, no-wrap
msgid "B<NO_DATA>"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:322
msgid ""
"The requested name is valid but does not have an IP address.  Another type "
"of request to the name server for this domain may return an answer.  The "
"constant B<NO_ADDRESS> is a synonym for B<NO_DATA>."
msgstr ""

#. type: TP
#: build/C/man3/gethostbyname.3:322 build/C/man3/getipnodebyname.3:199
#, no-wrap
msgid "B<NO_RECOVERY>"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:325
msgid "A nonrecoverable name server error occurred."
msgstr ""

#. type: TP
#: build/C/man3/gethostbyname.3:325 build/C/man3/getipnodebyname.3:202
#, no-wrap
msgid "B<TRY_AGAIN>"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:329
msgid ""
"A temporary error occurred on an authoritative name server.  Try again "
"later."
msgstr ""

#. type: TP
#: build/C/man3/gethostbyname.3:330 build/C/man5/host.conf.5:117 build/C/man3/resolver.3:482
#, no-wrap
msgid "I</etc/host.conf>"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:333 build/C/man3/resolver.3:482 build/C/man3/resolver.3:485
msgid "resolver configuration file"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:333 build/C/man3/getnameinfo.3:200 build/C/man5/host.conf.5:123 build/C/man5/hosts.5:91 build/C/man5/nsswitch.conf.5:384
#, no-wrap
msgid "I</etc/hosts>"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:336
msgid "host database file"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:336 build/C/man3/getnameinfo.3:202 build/C/man5/nsswitch.conf.5:340 build/C/man3/setnetgrent.3:95
#, no-wrap
msgid "I</etc/nsswitch.conf>"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:339
msgid "name service switch configuration"
msgstr ""

#. type: tbl table
#: build/C/man3/gethostbyname.3:349
#, no-wrap
msgid "B<gethostbyname>()"
msgstr ""

#. type: tbl table
#: build/C/man3/gethostbyname.3:351
#, no-wrap
msgid "MT-Unsafe race:hostbyname env\n"
msgstr ""

#. type: tbl table
#: build/C/man3/gethostbyname.3:351 build/C/man3/gethostbyname.3:358 build/C/man3/gethostbyname.3:363 build/C/man3/gethostbyname.3:365 build/C/man3/gethostbyname.3:369 build/C/man3/gethostbyname.3:374 build/C/man3/gethostbyname.3:381 build/C/man3/gethostbyname.3:388 build/C/man3/getnetent.3:157 build/C/man3/getnetent.3:164 build/C/man3/getnetent.3:171 build/C/man3/getnetent.3:176 build/C/man3/getnetent.3:180 build/C/man3/getprotoent.3:152 build/C/man3/getprotoent.3:159 build/C/man3/getprotoent.3:166 build/C/man3/getprotoent.3:171 build/C/man3/getprotoent.3:175 build/C/man3/getprotoent_r.3:142 build/C/man3/getprotoent_r.3:144 build/C/man3/getservent.3:169 build/C/man3/getservent.3:176 build/C/man3/getservent.3:183 build/C/man3/getservent.3:188 build/C/man3/getservent.3:192 build/C/man3/inet.3:234 build/C/man3/inet.3:241 build/C/man3/rcmd.3:291 build/C/man3/resolver.3:497 build/C/man3/resolver.3:505 build/C/man3/setnetgrent.3:105 build/C/man3/setnetgrent.3:107 build/C/man3/setnetgrent.3:111 build/C/man3/setnetgrent.3:121
#, no-wrap
msgid ".br\n"
msgstr ""

#. type: tbl table
#: build/C/man3/gethostbyname.3:353 build/C/man3/gethostbyname.3:360 build/C/man3/gethostbyname.3:371 build/C/man3/getnetent.3:173 build/C/man3/getnetent.3:182 build/C/man3/getprotoent.3:161 build/C/man3/getprotoent.3:168 build/C/man3/getprotoent.3:177 build/C/man3/getservent.3:178 build/C/man3/getservent.3:185 build/C/man3/getservent.3:194 build/C/man3/setnetgrent.3:113
#, no-wrap
msgid "locale"
msgstr ""

#. type: tbl table
#: build/C/man3/gethostbyname.3:356
#, no-wrap
msgid "B<gethostbyaddr>()"
msgstr ""

#. type: tbl table
#: build/C/man3/gethostbyname.3:358
#, no-wrap
msgid "MT-Unsafe race:hostbyaddr env\n"
msgstr ""

#. type: tbl table
#: build/C/man3/gethostbyname.3:363
#, no-wrap
msgid "B<sethostent>(),\n"
msgstr ""

#. type: tbl table
#: build/C/man3/gethostbyname.3:365
#, no-wrap
msgid "B<endhostent>(),\n"
msgstr ""

#. type: tbl table
#: build/C/man3/gethostbyname.3:367
#, no-wrap
msgid "B<gethostent_r>()"
msgstr ""

#. type: tbl table
#: build/C/man3/gethostbyname.3:369
#, no-wrap
msgid "MT-Unsafe race:hostent env\n"
msgstr ""

#. type: tbl table
#: build/C/man3/gethostbyname.3:374
#, no-wrap
msgid "B<herror>(),\n"
msgstr ""

#. type: tbl table
#: build/C/man3/gethostbyname.3:376
#, no-wrap
msgid "B<hstrerror>()"
msgstr ""

#. type: tbl table
#: build/C/man3/gethostbyname.3:379
#, no-wrap
msgid "B<gethostent>()"
msgstr ""

#. type: tbl table
#: build/C/man3/gethostbyname.3:381
#, no-wrap
msgid "MT-Unsafe race:hostent\n"
msgstr ""

#. type: tbl table
#: build/C/man3/gethostbyname.3:383
#, no-wrap
msgid "race:hostentbuf env locale"
msgstr ""

#. type: tbl table
#: build/C/man3/gethostbyname.3:386
#, no-wrap
msgid "B<gethostbyname2>()"
msgstr ""

#. type: tbl table
#: build/C/man3/gethostbyname.3:388
#, no-wrap
msgid "MT-Unsafe race:hostbyname2\n"
msgstr ""

#. type: tbl table
#: build/C/man3/gethostbyname.3:390 build/C/man3/getnetent.3:166
#, no-wrap
msgid "env locale"
msgstr ""

#. type: tbl table
#: build/C/man3/gethostbyname.3:395
#, no-wrap
msgid ""
"B<gethostbyaddr_r>(),\n"
"B<gethostbyname_r>(),\n"
"B<gethostbyname2_r>()"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:410
msgid ""
"In the above table, I<hostent> in I<race:hostent> signifies that if any of "
"the functions B<sethostent>(), B<gethostent>(), B<gethostent_r>(), or "
"B<endhostent>()  are used in parallel in different threads of a program, "
"then data races could occur."
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:434
msgid ""
"POSIX.1-2001 specifies B<gethostbyname>(), B<gethostbyaddr>(), "
"B<sethostent>(), B<endhostent>(), B<gethostent>(), and I<h_errno>; "
"B<gethostbyname>(), B<gethostbyaddr>(), and I<h_errno> are marked "
"obsolescent in that standard.  POSIX.1-2008 removes the specifications of "
"B<gethostbyname>(), B<gethostbyaddr>(), and I<h_errno>, recommending the use "
"of B<getaddrinfo>(3)  and B<getnameinfo>(3)  instead."
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:444
msgid ""
"The functions B<gethostbyname>()  and B<gethostbyaddr>()  may return "
"pointers to static data, which may be overwritten by later calls.  Copying "
"the I<struct hostent> does not suffice, since it contains pointers; a deep "
"copy is required."
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:468
msgid ""
"In the original BSD implementation the I<len> argument of B<gethostbyname>()  "
"was an I<int>.  The SUSv2 standard is buggy and declares the I<len> argument "
"of B<gethostbyaddr>()  to be of type I<size_t>.  (That is wrong, because it "
"has to be I<int>, and I<size_t> is not.  POSIX.1-2001 makes it I<socklen_t>, "
"which is OK.)  See also B<accept>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:474
msgid ""
"The BSD prototype for B<gethostbyaddr>()  uses I<const char\\ *> for the "
"first argument."
msgstr ""

#. type: SS
#: build/C/man3/gethostbyname.3:474
#, no-wrap
msgid "System V/POSIX extension"
msgstr ""

#.  e.g., Linux, FreeBSD, UnixWare, HP-UX
#.  e.g., FreeBSD, AIX
#. type: Plain text
#: build/C/man3/gethostbyname.3:491
msgid ""
"POSIX requires the B<gethostent>()  call, which should return the next entry "
"in the host data base.  When using DNS/BIND this does not make much sense, "
"but it may be reasonable if the host data base is a file that can be read "
"line by line.  On many systems, a routine of this name reads from the file "
"I</etc/hosts>.  It may be available only when the library was built without "
"DNS support.  The glibc version will ignore ipv6 entries.  This function is "
"not reentrant, and glibc adds a reentrant version B<gethostent_r>()."
msgstr ""

#. type: SS
#: build/C/man3/gethostbyname.3:491
#, no-wrap
msgid "GNU extensions"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:497
msgid ""
"Glibc2 also has a B<gethostbyname2>()  that works like B<gethostbyname>(), "
"but permits to specify the address family to which the address must belong."
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:531
msgid ""
"Glibc2 also has reentrant versions B<gethostent_r>(), B<gethostbyaddr_r>(), "
"B<gethostbyname_r>(), and B<gethostbyname2_r>().  The caller supplies a "
"I<hostent> structure I<ret> which will be filled in on success, and a "
"temporary work buffer I<buf> of size I<buflen>.  After the call, I<result> "
"will point to the result on success.  In case of an error or if no entry is "
"found I<result> will be NULL.  The functions return 0 on success and a "
"nonzero error number on failure.  In addition to the errors returned by the "
"nonreentrant versions of these functions, if I<buf> is too small, the "
"functions will return B<ERANGE>, and the call should be retried with a "
"larger buffer.  The global variable I<h_errno> is not modified, but the "
"address of a variable in which to store error numbers is passed in "
"I<h_errnop>."
msgstr ""

#.  http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=482973
#. type: Plain text
#: build/C/man3/gethostbyname.3:536
msgid ""
"B<gethostbyname>()  does not recognize components of a dotted IPv4 address "
"string that are expressed in hexadecimal."
msgstr ""

#.  .BR getipnodebyaddr (3),
#.  .BR getipnodebyname (3),
#.  .BR resolv+ (8)
#. type: Plain text
#: build/C/man3/gethostbyname.3:550
msgid ""
"B<getaddrinfo>(3), B<getnameinfo>(3), B<inet>(3), B<inet_ntop>(3), "
"B<inet_pton>(3), B<resolver>(3), B<hosts>(5), B<nsswitch.conf>(5), "
"B<hostname>(7), B<named>(8)"
msgstr ""

#. type: TH
#: build/C/man3/getipnodebyname.3:26
#, no-wrap
msgid "GETIPNODEBYNAME"
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:30
msgid ""
"getipnodebyname, getipnodebyaddr, freehostent - get network hostnames and "
"addresses"
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:38
#, no-wrap
msgid ""
"B<struct hostent *getipnodebyname(const char *>I<name>B<, int >I<af>B<,>\n"
"B<                                int >I<flags>B<, int *>I<error_num>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:41
#, no-wrap
msgid ""
"B<struct hostent *getipnodebyaddr(const void *>I<addr>B<, size_t "
">I<len>B<,>\n"
"B<                                int >I<af>B<, int *>I<error_num>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:43
#, no-wrap
msgid "B<void freehostent(struct hostent *>I<ip>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:51
msgid ""
"These functions are deprecated (and unavailable in glibc).  Use "
"B<getaddrinfo>(3)  and B<getnameinfo>(3)  instead."
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:59
msgid ""
"The B<getipnodebyname>()  and B<getipnodebyaddr>()  functions return the "
"names and addresses of a network host.  These functions return a pointer to "
"the following structure:"
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:69
#, no-wrap
msgid ""
"struct hostent {\n"
"    char  *h_name;\n"
"    char **h_aliases;\n"
"    int    h_addrtype;\n"
"    int    h_length;\n"
"    char **h_addr_list;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:82
msgid ""
"These functions replace the B<gethostbyname>(3)  and B<gethostbyaddr>(3)  "
"functions, which could access only the IPv4 network address family.  The "
"B<getipnodebyname>()  and B<getipnodebyaddr>()  functions can access "
"multiple network address families."
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:93
msgid ""
"Unlike the B<gethostby> functions, these functions return pointers to "
"dynamically allocated memory.  The B<freehostent>()  function is used to "
"release the dynamically allocated memory after the caller no longer needs "
"the I<hostent> structure."
msgstr ""

#. type: SS
#: build/C/man3/getipnodebyname.3:93
#, no-wrap
msgid "getipnodebyname() arguments"
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:104
msgid ""
"The B<getipnodebyname>()  function looks up network addresses for the host "
"specified by the I<name> argument.  The I<af> argument specifies one of the "
"following values:"
msgstr ""

#. type: TP
#: build/C/man3/getipnodebyname.3:104 build/C/man3/getipnodebyname.3:166 build/C/man3/inet_ntop.3:57 build/C/man3/inet_pton.3:55
#, no-wrap
msgid "B<AF_INET>"
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:110
msgid ""
"The I<name> argument points to a dotted-quad IPv4 address or a name of an "
"IPv4 network host."
msgstr ""

#. type: TP
#: build/C/man3/getipnodebyname.3:110 build/C/man3/getipnodebyname.3:176 build/C/man3/inet_ntop.3:70 build/C/man3/inet_pton.3:69
#, no-wrap
msgid "B<AF_INET6>"
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:116
msgid ""
"The I<name> argument points to a hexadecimal IPv6 address or a name of an "
"IPv6 network host."
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:125
msgid ""
"The I<flags> argument specifies additional options.  More than one option "
"can be specified by bitwise OR-ing them together.  I<flags> should be set to "
"0 if no options are desired."
msgstr ""

#. type: TP
#: build/C/man3/getipnodebyname.3:125
#, no-wrap
msgid "B<AI_V4MAPPED>"
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:132
msgid ""
"This flag is used with B<AF_INET6> to request a query for IPv4 addresses "
"instead of IPv6 addresses; the IPv4 addresses will be mapped to IPv6 "
"addresses."
msgstr ""

#. type: TP
#: build/C/man3/getipnodebyname.3:132
#, no-wrap
msgid "B<AI_ALL>"
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:138
msgid ""
"This flag is used with B<AI_V4MAPPED> to request a query for both IPv4 and "
"IPv6 addresses.  Any IPv4 address found will be mapped to an IPv6 address."
msgstr ""

#. type: TP
#: build/C/man3/getipnodebyname.3:138
#, no-wrap
msgid "B<AI_ADDRCONFIG>"
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:150
msgid ""
"This flag is used with B<AF_INET6> to further request that queries for IPv6 "
"addresses should not be made unless the system has at least one IPv6 address "
"assigned to a network interface, and that queries for IPv4 addresses should "
"not be made unless the system has at least one IPv4 address assigned to a "
"network interface.  This flag may be used by itself or with the "
"B<AI_V4MAPPED> flag."
msgstr ""

#. type: TP
#: build/C/man3/getipnodebyname.3:150
#, no-wrap
msgid "B<AI_DEFAULT>"
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:154
msgid "This flag is equivalent to B<(AI_ADDRCONFIG | AI_V4MAPPED)>."
msgstr ""

#. type: SS
#: build/C/man3/getipnodebyname.3:154
#, no-wrap
msgid "getipnodebyaddr() arguments"
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:166
msgid ""
"The B<getipnodebyaddr>()  function looks up the name of the host whose "
"network address is specified by the I<addr> argument.  The I<af> argument "
"specifies one of the following values:"
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:176
msgid ""
"The I<addr> argument points to a I<struct in_addr> and I<len> must be set to "
"I<sizeof(struct in_addr)>."
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:186
msgid ""
"The I<addr> argument points to a I<struct in6_addr> and I<len> must be set "
"to I<sizeof(struct in6_addr)>."
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:190
msgid ""
"NULL is returned if an error occurred, and I<error_num> will contain an "
"error code from the following list:"
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:193
msgid "The hostname or network address was not found."
msgstr ""

#. type: TP
#: build/C/man3/getipnodebyname.3:193
#, no-wrap
msgid "B<NO_ADDRESS>"
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:199
msgid ""
"The domain name server recognized the network address or name, but no answer "
"was returned.  This can happen if the network host has only IPv4 addresses "
"and a request has been made for IPv6 information only, or vice versa."
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:202
msgid "The domain name server returned a permanent failure response."
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:206
msgid ""
"The domain name server returned a temporary failure response.  You might "
"have better luck next time."
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:210
msgid ""
"A successful query returns a pointer to a I<hostent> structure that contains "
"the following fields:"
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:213
msgid "This is the official name of this network host."
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:217
msgid ""
"This is an array of pointers to unofficial aliases for the same host.  The "
"array is terminated by a null pointer."
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:239
msgid ""
"This is a copy of the I<af> argument to B<getipnodebyname>()  or "
"B<getipnodebyaddr>().  I<h_addrtype> will always be B<AF_INET> if the I<af> "
"argument was B<AF_INET>.  I<h_addrtype> will always be B<AF_INET6> if the "
"I<af> argument was B<AF_INET6>."
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:253
msgid ""
"This field will be set to I<sizeof(struct in_addr)> if I<h_addrtype> is "
"B<AF_INET>, and to I<sizeof(struct in6_addr)> if I<h_addrtype> is "
"B<AF_INET6>."
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:258
msgid ""
"This is an array of one or more pointers to network address structures for "
"the network host.  The array is terminated by a null pointer."
msgstr ""

#.  Not in POSIX.1-2001.
#. type: Plain text
#: build/C/man3/getipnodebyname.3:261
msgid "RFC\\ 2553."
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:266
msgid ""
"These functions were present in glibc 2.1.91-95, but were removed again.  "
"Several UNIX-like systems support them, but all call them deprecated."
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:271
msgid "B<getaddrinfo>(3), B<getnameinfo>(3), B<inet_ntop>(3), B<inet_pton>(3)"
msgstr ""

#. type: TH
#: build/C/man3/getnameinfo.3:10
#, no-wrap
msgid "GETNAMEINFO"
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:13
msgid "getnameinfo - address-to-name translation in protocol-independent manner"
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:17
#, no-wrap
msgid ""
"B<#include E<lt>sys/socket.hE<gt>>\n"
"B<#include E<lt>netdb.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:21
#, no-wrap
msgid ""
"B<int getnameinfo(const struct sockaddr *>I<addr>B<, socklen_t "
">I<addrlen>B<,>\n"
"B<                char *>I<host>B<, socklen_t >I<hostlen>B<,>\n"
"B<                char *>I<serv>B<, socklen_t >I<servlen>B<, int "
">I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:32
#, no-wrap
msgid ""
"B<getnameinfo>():\n"
"    Since glibc 2.22: _POSIX_C_SOURCE E<gt>= 200112L\n"
"    Glibc 2.21 and earlier: _POSIX_C_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:48
msgid ""
"The B<getnameinfo>()  function is the inverse of B<getaddrinfo>(3): it "
"converts a socket address to a corresponding host and service, in a "
"protocol-independent manner.  It combines the functionality of "
"B<gethostbyaddr>(3)  and B<getservbyport>(3), but unlike those functions, "
"B<getnameinfo>()  is reentrant and allows programs to eliminate "
"IPv4-versus-IPv6 dependencies."
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:71
msgid ""
"The I<addr> argument is a pointer to a generic socket address structure (of "
"type I<sockaddr_in> or I<sockaddr_in6>)  of size I<addrlen> that holds the "
"input IP address and port number.  The arguments I<host> and I<serv> are "
"pointers to caller-allocated buffers (of size I<hostlen> and I<servlen> "
"respectively) into which B<getnameinfo>()  places null-terminated strings "
"containing the host and service names respectively."
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:84
msgid ""
"The caller can specify that no hostname (or no service name)  is required by "
"providing a NULL I<host> (or I<serv>)  argument or a zero I<hostlen> (or "
"I<servlen>)  argument.  However, at least one of hostname or service name "
"must be requested."
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:90
msgid "The I<flags> argument modifies the behavior of B<getnameinfo>()  as follows:"
msgstr ""

#. type: TP
#: build/C/man3/getnameinfo.3:90
#, no-wrap
msgid "B<NI_NAMEREQD>"
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:93
msgid "If set, then an error is returned if the hostname cannot be determined."
msgstr ""

#. type: TP
#: build/C/man3/getnameinfo.3:93
#, no-wrap
msgid "B<NI_DGRAM>"
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:99
msgid ""
"If set, then the service is datagram (UDP) based rather than stream (TCP) "
"based.  This is required for the few ports (512\\(en514)  that have "
"different services for UDP and TCP."
msgstr ""

#. type: TP
#: build/C/man3/getnameinfo.3:99
#, no-wrap
msgid "B<NI_NOFQDN>"
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:103
msgid ""
"If set, return only the hostname part of the fully qualified domain name for "
"local hosts."
msgstr ""

#. type: TP
#: build/C/man3/getnameinfo.3:103
#, no-wrap
msgid "B<NI_NUMERICHOST>"
msgstr ""

#.  For example, by calling
#.  .BR inet_ntop ()
#.  instead of
#.  .BR gethostbyaddr ().
#.  POSIX.1-2001 TC1 has NI_NUMERICSCOPE, but glibc doesn't have it.
#. type: Plain text
#: build/C/man3/getnameinfo.3:113
msgid ""
"If set, then the numeric form of the hostname is returned.  (When not set, "
"this will still happen in case the node's name cannot be determined.)"
msgstr ""

#. type: TP
#: build/C/man3/getnameinfo.3:113
#, no-wrap
msgid "B<NI_NUMERICSERV>"
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:118
msgid ""
"If set, then the numeric form of the service address is returned.  (When not "
"set, this will still happen in case the service's name cannot be "
"determined.)"
msgstr ""

#. type: SS
#: build/C/man3/getnameinfo.3:118
#, no-wrap
msgid "Extensions to getnameinfo() for Internationalized Domain Names"
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:126
msgid ""
"Starting with glibc 2.3.4, B<getnameinfo>()  has been extended to "
"selectively allow hostnames to be transparently converted to and from the "
"Internationalized Domain Name (IDN) format (see RFC 3490, "
"I<Internationalizing Domain Names in Applications (IDNA)>).  Three new flags "
"are defined:"
msgstr ""

#. type: TP
#: build/C/man3/getnameinfo.3:126
#, no-wrap
msgid "B<NI_IDN>"
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:132
msgid ""
"If this flag is used, then the name found in the lookup process is converted "
"from IDN format to the locale's encoding if necessary.  ASCII-only names are "
"not affected by the conversion, which makes this flag usable in existing "
"programs and environments."
msgstr ""

#. type: TP
#: build/C/man3/getnameinfo.3:132
#, no-wrap
msgid "B<NI_IDN_ALLOW_UNASSIGNED>, B<NI_IDN_USE_STD3_ASCII_RULES>"
msgstr ""

#.  FIXME glibc defines the following additional errors, some which
#.  can probably be returned by getnameinfo(); they need to
#.  be documented.
#
#.      #ifdef __USE_GNU
#.      #define EAI_INPROGRESS  -100  /* Processing request in progress.  */
#.      #define EAI_CANCELED    -101  /* Request canceled.  */
#.      #define EAI_NOTCANCELED -102  /* Request not canceled.  */
#.      #define EAI_ALLDONE     -103  /* All requests done.  */
#.      #define EAI_INTR        -104  /* Interrupted by a signal.  */
#.      #define EAI_IDN_ENCODE  -105  /* IDN encoding failed.  */
#.      #endif
#. type: Plain text
#: build/C/man3/getnameinfo.3:156
msgid ""
"On success, 0 is returned, and node and service names, if requested, are "
"filled with null-terminated strings, possibly truncated to fit the specified "
"buffer lengths.  On error, one of the following nonzero error codes is "
"returned:"
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:160
msgid "The name could not be resolved at this time.  Try again later."
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:165
msgid "The I<flags> argument has an invalid value."
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:168
msgid "A nonrecoverable error occurred."
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:172
msgid ""
"The address family was not recognized, or the address length was invalid for "
"the specified family."
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:181
msgid ""
"The name does not resolve for the supplied arguments.  B<NI_NAMEREQD> is set "
"and the host's name cannot be located, or neither hostname nor service name "
"were requested."
msgstr ""

#. type: TP
#: build/C/man3/getnameinfo.3:181
#, no-wrap
msgid "B<EAI_OVERFLOW>"
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:188
msgid "The buffer pointed to by I<host> or I<serv> was too small."
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:193
msgid "A system error occurred.  The error code can be found in I<errno>."
msgstr ""

#. type: TP
#: build/C/man3/getnameinfo.3:204 build/C/man5/host.conf.5:120 build/C/man3/resolver.3:479
#, no-wrap
msgid "I</etc/resolv.conf>"
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:207
msgid "B<getnameinfo>()  is provided in glibc since version 2.1."
msgstr ""

#. type: tbl table
#: build/C/man3/getnameinfo.3:217
#, no-wrap
msgid "B<getnameinfo>()"
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:222
msgid "POSIX.1-2001, POSIX.1-2008, RFC\\ 2553."
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:227
msgid ""
"In order to assist the programmer in choosing reasonable sizes for the "
"supplied buffers, I<E<lt>netdb.hE<gt>> defines the constants"
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:232
#, no-wrap
msgid ""
"#define NI_MAXHOST      1025\n"
"#define NI_MAXSERV      32\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:245
msgid ""
"Since glibc 2.8, these definitions are exposed only if suitable feature test "
"macros are defined, namely: B<_GNU_SOURCE>, B<_DEFAULT_SOURCE> (since glibc "
"2.19), or (in glibc versions up to and including 2.19)  B<_BSD_SOURCE> or "
"B<_SVID_SOURCE>."
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:253
msgid ""
"The former is the constant B<MAXDNAME> in recent versions of BIND's "
"I<E<lt>arpa/nameser.hE<gt>> header file.  The latter is a guess based on the "
"services listed in the current Assigned Numbers RFC."
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:260
msgid ""
"Before glibc version 2.2, the I<hostlen> and I<servlen> arguments were typed "
"as I<size_t>."
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:265
msgid ""
"The following code tries to get the numeric hostname and service name, for a "
"given socket address.  Note that there is no hardcoded reference to a "
"particular address family."
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:271
#, no-wrap
msgid ""
"struct sockaddr *addr;     /* input */\n"
"socklen_t addrlen;         /* input */\n"
"char hbuf[NI_MAXHOST], sbuf[NI_MAXSERV];\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:275
#, no-wrap
msgid ""
"if (getnameinfo(addr, addrlen, hbuf, sizeof(hbuf), sbuf,\n"
"            sizeof(sbuf), NI_NUMERICHOST | NI_NUMERICSERV) == 0)\n"
"    printf(\"host=%s, serv=%s\\en\", hbuf, sbuf);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:280
msgid ""
"The following version checks if the socket address has a reverse address "
"mapping."
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:286
#, no-wrap
msgid ""
"struct sockaddr *addr;     /* input */\n"
"socklen_t addrlen;         /* input */\n"
"char hbuf[NI_MAXHOST];\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:292
#, no-wrap
msgid ""
"if (getnameinfo(addr, addrlen, hbuf, sizeof(hbuf),\n"
"            NULL, 0, NI_NAMEREQD))\n"
"    printf(\"could not resolve hostname\");\n"
"else\n"
"    printf(\"host=%s\\en\", hbuf);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:299
msgid ""
"An example program using B<getnameinfo>()  can be found in "
"B<getaddrinfo>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:314
msgid ""
"B<accept>(2), B<getpeername>(2), B<getsockname>(2), B<recvfrom>(2), "
"B<socket>(2), B<getaddrinfo>(3), B<gethostbyaddr>(3), B<getservbyname>(3), "
"B<getservbyport>(3), B<inet_ntop>(3), B<hosts>(5), B<services>(5), "
"B<hostname>(7), B<named>(8)"
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:318
msgid ""
"R.\\& Gilligan, S.\\& Thomson, J.\\& Bound and W.\\& Stevens, I<Basic Socket "
"Interface Extensions for IPv6>, RFC\\ 2553, March 1999."
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:324
msgid ""
"Tatsuya Jinmei and Atsushi Onoe, I<An Extension of Format for IPv6 Scoped "
"Addresses>, internet draft, work in progress E<.UR "
"ftp://ftp.ietf.org\\:/internet-drafts\\:/draft-ietf-ipngwg-scopedaddr-format-02.txt> "
"E<.UE .>"
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:329
msgid ""
"Craig Metz, I<Protocol Independence Using the Sockets API>, Proceedings of "
"the freenix track: 2000 USENIX annual technical conference, June 2000"
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:332
msgid ""
"E<.UR "
"http://www.usenix.org\\:/publications\\:/library\\:/proceedings\\:/usenix2000\\:/freenix\\:/metzprotocol.html> "
"E<.UE .>"
msgstr ""

#. type: TH
#: build/C/man3/getnetent.3:30
#, no-wrap
msgid "GETNETENT"
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent.3:34
msgid ""
"getnetent, getnetbyname, getnetbyaddr, setnetent, endnetent - get network "
"entry"
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent.3:37 build/C/man3/getnetent_r.3:33 build/C/man3/getprotoent.3:37 build/C/man3/getprotoent_r.3:33 build/C/man3/getservent.3:41 build/C/man3/getservent_r.3:33 build/C/man3/rexec.3:47 build/C/man3/setnetgrent.3:17
#, no-wrap
msgid "B<#include E<lt>netdb.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent.3:39
#, no-wrap
msgid "B<struct netent *getnetent(void);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent.3:41
#, no-wrap
msgid "B<struct netent *getnetbyname(const char *>I<name>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent.3:43
#, no-wrap
msgid "B<struct netent *getnetbyaddr(uint32_t >I<net>B<, int >I<type>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent.3:45
#, no-wrap
msgid "B<void setnetent(int >I<stayopen>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent.3:47
#, no-wrap
msgid "B<void endnetent(void);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent.3:57
msgid ""
"The B<getnetent>()  function reads the next entry from the networks database "
"and returns a I<netent> structure containing the broken-out fields from the "
"entry.  A connection is opened to the database if necessary."
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent.3:66
msgid ""
"The B<getnetbyname>()  function returns a I<netent> structure for the entry "
"from the database that matches the network I<name>."
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent.3:80
msgid ""
"The B<getnetbyaddr>()  function returns a I<netent> structure for the entry "
"from the database that matches the network number I<net> of type I<type>.  "
"The I<net> argument must be in host byte order."
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent.3:92
msgid ""
"The B<setnetent>()  function opens a connection to the database, and sets "
"the next entry to the first entry.  If I<stayopen> is nonzero, then the "
"connection to the database will not be closed between calls to one of the "
"B<getnet*>()  functions."
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent.3:96
msgid "The B<endnetent>()  function closes the connection to the database."
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent.3:102
msgid "The I<netent> structure is defined in I<E<lt>netdb.hE<gt>> as follows:"
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent.3:111
#, no-wrap
msgid ""
"struct netent {\n"
"    char      *n_name;     /* official network name */\n"
"    char     **n_aliases;  /* alias list */\n"
"    int        n_addrtype; /* net address type */\n"
"    uint32_t   n_net;      /* network number */\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent.3:117
msgid "The members of the I<netent> structure are:"
msgstr ""

#. type: TP
#: build/C/man3/getnetent.3:117
#, no-wrap
msgid "I<n_name>"
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent.3:120
msgid "The official name of the network."
msgstr ""

#. type: TP
#: build/C/man3/getnetent.3:120
#, no-wrap
msgid "I<n_aliases>"
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent.3:123
msgid "A NULL-terminated list of alternative names for the network."
msgstr ""

#. type: TP
#: build/C/man3/getnetent.3:123
#, no-wrap
msgid "I<n_addrtype>"
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent.3:127
msgid "The type of the network number; always B<AF_INET>."
msgstr ""

#. type: TP
#: build/C/man3/getnetent.3:127
#, no-wrap
msgid "I<n_net>"
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent.3:130
msgid "The network number in host byte order."
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent.3:141
msgid ""
"The B<getnetent>(), B<getnetbyname>(), and B<getnetbyaddr>()  functions "
"return a pointer to a statically allocated I<netent> structure, or a null "
"pointer if an error occurs or the end of the file is reached."
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent.3:142 build/C/man5/networks.5:71 build/C/man5/nsswitch.conf.5:393
#, no-wrap
msgid "I</etc/networks>"
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent.3:145
msgid "networks database file"
msgstr ""

#. type: tbl table
#: build/C/man3/getnetent.3:155
#, no-wrap
msgid "B<getnetent>()"
msgstr ""

#. type: tbl table
#: build/C/man3/getnetent.3:157
#, no-wrap
msgid "MT-Unsafe race:netent\n"
msgstr ""

#. type: tbl table
#: build/C/man3/getnetent.3:159
#, no-wrap
msgid "race:netentbuf env locale"
msgstr ""

#. type: tbl table
#: build/C/man3/getnetent.3:162
#, no-wrap
msgid "B<getnetbyname>()"
msgstr ""

#. type: tbl table
#: build/C/man3/getnetent.3:164
#, no-wrap
msgid "MT-Unsafe race:netbyname\n"
msgstr ""

#. type: tbl table
#: build/C/man3/getnetent.3:169
#, no-wrap
msgid "B<getnetbyaddr>()"
msgstr ""

#. type: tbl table
#: build/C/man3/getnetent.3:171
#, no-wrap
msgid "MT-Unsafe race:netbyaddr\n"
msgstr ""

#. type: tbl table
#: build/C/man3/getnetent.3:176
#, no-wrap
msgid "B<setnetent>(),\n"
msgstr ""

#. type: tbl table
#: build/C/man3/getnetent.3:178
#, no-wrap
msgid "B<endnetent>()"
msgstr ""

#. type: tbl table
#: build/C/man3/getnetent.3:180
#, no-wrap
msgid "MT-Unsafe race:netent env\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent.3:196
msgid ""
"In the above table, I<netent> in I<race:netent> signifies that if any of the "
"functions B<setnetent>(), B<getnetent>(), or B<endnetent>()  are used in "
"parallel in different threads of a program, then data races could occur."
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent.3:198 build/C/man3/getprotoent.3:193 build/C/man3/getservent.3:210
msgid "POSIX.1-2001, POSIX.1-2008, 4.3BSD."
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent.3:205
msgid ""
"In glibc versions before 2.2, the I<net> argument of B<getnetbyaddr>()  was "
"of type I<long>."
msgstr ""

#.  .BR networks (5)
#. type: Plain text
#: build/C/man3/getnetent.3:210
msgid "B<getnetent_r>(3), B<getprotoent>(3), B<getservent>(3)"
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent.3:212
msgid "RFC\\ 1101"
msgstr ""

#. type: TH
#: build/C/man3/getnetent_r.3:26
#, no-wrap
msgid "GETNETENT_R"
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent_r.3:30
msgid "getnetent_r, getnetbyname_r, getnetbyaddr_r - get network entry (reentrant)"
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent_r.3:37
#, no-wrap
msgid ""
"B<int getnetent_r(struct netent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct netent **>I<result>B<,>\n"
"B<                int *>I<h_errnop>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent_r.3:42
#, no-wrap
msgid ""
"B<int getnetbyname_r(const char *>I<name>B<,>\n"
"B<                struct netent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct netent **>I<result>B<,>\n"
"B<                int *>I<h_errnop>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent_r.3:47
#, no-wrap
msgid ""
"B<int getnetbyaddr_r(uint32_t >I<net>B<, int >I<type>B<,>\n"
"B<                struct netent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct netent **>I<result>B<,>\n"
"B<                int *>I<h_errnop>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent_r.3:62
#, no-wrap
msgid ""
"B<getnetent_r>(),\n"
"B<getnetbyname_r>(),\n"
"B<getnetbyaddr_r>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent_r.3:80
msgid ""
"The B<getnetent_r>(), B<getnetbyname_r>(), and B<getnetbyaddr_r>()  "
"functions are the reentrant equivalents of, respectively, B<getnetent>(3), "
"B<getnetbyname>(3), and B<getnetbynumber>(3).  They differ in the way that "
"the I<netent> structure is returned, and in the function calling signature "
"and return value.  This manual page describes just the differences from the "
"nonreentrant functions."
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent_r.3:86
msgid ""
"Instead of returning a pointer to a statically allocated I<netent> structure "
"as the function result, these functions copy the structure into the location "
"pointed to by I<result_buf>."
msgstr ""

#.  I can find no information on the required/recommended buffer size;
#.  the nonreentrant functions use a 1024 byte buffer -- mtk.
#. type: Plain text
#: build/C/man3/getnetent_r.3:103
msgid ""
"The I<buf> array is used to store the string fields pointed to by the "
"returned I<netent> structure.  (The nonreentrant functions allocate these "
"strings in static storage.)  The size of this array is specified in "
"I<buflen>.  If I<buf> is too small, the call fails with the error B<ERANGE>, "
"and the caller must try again with a larger buffer.  (A buffer of length "
"1024 bytes should be sufficient for most applications.)"
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent_r.3:111
msgid ""
"If the function call successfully obtains a network record, then I<*result> "
"is set pointing to I<result_buf>; otherwise, I<*result> is set to NULL."
msgstr ""

#.  getnetent.3 doesn't document any use of h_errno, but nevertheless
#.  the nonreentrant functions no seem to set h_errno.
#. type: Plain text
#: build/C/man3/getnetent_r.3:119
msgid ""
"The buffer pointed to by I<h_errnop> is used to return the value that would "
"be stored in the global variable I<h_errno> by the nonreentrant versions of "
"these functions."
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent_r.3:122 build/C/man3/getprotoent_r.3:112
msgid ""
"On success, these functions return 0.  On error, they return one of the "
"positive error numbers listed in ERRORS."
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent_r.3:130
msgid ""
"On error, record not found (B<getnetbyname_r>(), B<getnetbyaddr_r>()), or "
"end of input (B<getnetent_r>())  I<result> is set to NULL."
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent_r.3:135
msgid "(B<getnetent_r>())  No more records in database."
msgstr ""

#. type: TP
#: build/C/man3/getnetent_r.3:135 build/C/man3/getprotoent_r.3:125 build/C/man3/getservent_r.3:124
#, no-wrap
msgid "B<ERANGE>"
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent_r.3:142 build/C/man3/getprotoent_r.3:132 build/C/man3/getservent_r.3:131
msgid ""
"I<buf> is too small.  Try again with a larger buffer (and increased "
"I<buflen>)."
msgstr ""

#. type: tbl table
#: build/C/man3/getnetent_r.3:155
#, no-wrap
msgid ""
"B<getnetent_r>(),\n"
"B<getnetbyname_r>(),\n"
"B<getnetbyaddr_r>()"
msgstr ""

#. type: tbl table
#: build/C/man3/getnetent_r.3:155 build/C/man3/getprotoent_r.3:146 build/C/man3/getservent_r.3:144 build/C/man3/inet.3:237 build/C/man3/inet_ntop.3:110 build/C/man3/inet_pton.3:141 build/C/man3/rcmd.3:294 build/C/man3/resolver.3:501
#, no-wrap
msgid "MT-Safe locale"
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent_r.3:162 build/C/man3/getprotoent_r.3:153 build/C/man3/getservent_r.3:151
msgid ""
"These functions are GNU extensions.  Functions with similar names exist on "
"some other systems, though typically with different calling signatures."
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent_r.3:165
msgid "B<getnetent>(3), B<networks>(5)"
msgstr ""

#. type: TH
#: build/C/man2/getpeername.2:42
#, no-wrap
msgid "GETPEERNAME"
msgstr ""

#. type: Plain text
#: build/C/man2/getpeername.2:45
msgid "getpeername - get name of connected peer socket"
msgstr ""

#. type: Plain text
#: build/C/man2/getpeername.2:50
msgid ""
"B<int getpeername(int >I<sockfd>B<, struct sockaddr *>I<addr>B<, socklen_t "
"*>I<addrlen>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/getpeername.2:63
msgid ""
"B<getpeername>()  returns the address of the peer connected to the socket "
"I<sockfd>, in the buffer pointed to by I<addr>.  The I<addrlen> argument "
"should be initialized to indicate the amount of space pointed to by "
"I<addr>.  On return it contains the actual size of the name returned (in "
"bytes).  The name is truncated if the buffer provided is too small."
msgstr ""

#. type: Plain text
#: build/C/man2/getpeername.2:68
msgid ""
"The returned address is truncated if the buffer provided is too small; in "
"this case, I<addrlen> will return a value greater than was supplied to the "
"call."
msgstr ""

#. type: Plain text
#: build/C/man2/getpeername.2:73 build/C/man2/shutdown.2:74
msgid ""
"On success, zero is returned.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""

#. type: TP
#: build/C/man2/getpeername.2:74 build/C/man2/shutdown.2:75 build/C/man7/unix.7:688
#, no-wrap
msgid "B<EBADF>"
msgstr ""

#. type: Plain text
#: build/C/man2/getpeername.2:79
msgid "The argument I<sockfd> is not a valid file descriptor."
msgstr ""

#. type: TP
#: build/C/man2/getpeername.2:79 build/C/man7/packet.7:516 build/C/man7/raw.7:154 build/C/man7/unix.7:706
#, no-wrap
msgid "B<EFAULT>"
msgstr ""

#. type: Plain text
#: build/C/man2/getpeername.2:85
msgid ""
"The I<addr> argument points to memory not in a valid part of the process "
"address space."
msgstr ""

#. type: Plain text
#: build/C/man2/getpeername.2:89
msgid "I<addrlen> is invalid (e.g., is negative)."
msgstr ""

#. type: TP
#: build/C/man2/getpeername.2:89 build/C/man7/packet.7:528
#, no-wrap
msgid "B<ENOBUFS>"
msgstr ""

#. type: Plain text
#: build/C/man2/getpeername.2:93
msgid ""
"Insufficient resources were available in the system to perform the "
"operation."
msgstr ""

#. type: Plain text
#: build/C/man2/getpeername.2:96
msgid "The socket is not connected."
msgstr ""

#. type: TP
#: build/C/man2/getpeername.2:96 build/C/man2/shutdown.2:87
#, no-wrap
msgid "B<ENOTSOCK>"
msgstr ""

#. type: Plain text
#: build/C/man2/getpeername.2:101 build/C/man2/shutdown.2:92
msgid "The file descriptor I<sockfd> does not refer to a socket."
msgstr ""

#. type: Plain text
#: build/C/man2/getpeername.2:105
msgid ""
"POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD (B<getpeername>()  first appeared "
"in 4.2BSD)."
msgstr ""

#. type: Plain text
#: build/C/man2/getpeername.2:110
msgid "For background on the I<socklen_t> type, see B<accept>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/getpeername.2:137
msgid ""
"For stream sockets, once a B<connect>(2)  has been performed, either socket "
"can call B<getpeername>()  to obtain the address of the peer socket.  On the "
"other hand, datagram sockets are connectionless.  Calling B<connect>(2)  on "
"a datagram socket merely sets the peer address for outgoing datagrams sent "
"with B<write>(2)  or B<recv>(2).  The caller of B<connect>(2)  can use "
"B<getpeername>()  to obtain the peer address that it earlier set for the "
"socket.  However, the peer socket is unaware of this information, and "
"calling B<getpeername>()  on the peer socket will return no useful "
"information (unless a B<connect>(2)  call was also executed on the peer).  "
"Note also that the receiver of a datagram can obtain the address of the "
"sender when using B<recvfrom>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/getpeername.2:144
msgid ""
"B<accept>(2), B<bind>(2), B<getsockname>(2), B<ip>(7), B<socket>(7), "
"B<unix>(7)"
msgstr ""

#. type: TH
#: build/C/man3/getprotoent.3:30
#, no-wrap
msgid "GETPROTOENT"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent.3:34
msgid ""
"getprotoent, getprotobyname, getprotobynumber, setprotoent, endprotoent - "
"get protocol entry"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent.3:39
#, no-wrap
msgid "B<struct protoent *getprotoent(void);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent.3:41
#, no-wrap
msgid "B<struct protoent *getprotobyname(const char *>I<name>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent.3:43
#, no-wrap
msgid "B<struct protoent *getprotobynumber(int >I<proto>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent.3:45
#, no-wrap
msgid "B<void setprotoent(int >I<stayopen>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent.3:47
#, no-wrap
msgid "B<void endprotoent(void);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent.3:58
msgid ""
"The B<getprotoent>()  function reads the next entry from the protocols "
"database (see B<protocols>(5))  and returns a I<protoent> structure "
"containing the broken-out fields from the entry.  A connection is opened to "
"the database if necessary."
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent.3:68
msgid ""
"The B<getprotobyname>()  function returns a I<protoent> structure for the "
"entry from the database that matches the protocol name I<name>.  A "
"connection is opened to the database if necessary."
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent.3:78
msgid ""
"The B<getprotobynumber>()  function returns a I<protoent> structure for the "
"entry from the database that matches the protocol number I<number>.  A "
"connection is opened to the database if necessary."
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent.3:90
msgid ""
"The B<setprotoent>()  function opens a connection to the database, and sets "
"the next entry to the first entry.  If I<stayopen> is nonzero, then the "
"connection to the database will not be closed between calls to one of the "
"B<getproto*>()  functions."
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent.3:94
msgid "The B<endprotoent>()  function closes the connection to the database."
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent.3:100
msgid "The I<protoent> structure is defined in I<E<lt>netdb.hE<gt>> as follows:"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent.3:108
#, no-wrap
msgid ""
"struct protoent {\n"
"    char  *p_name;       /* official protocol name */\n"
"    char **p_aliases;    /* alias list */\n"
"    int    p_proto;      /* protocol number */\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent.3:114
msgid "The members of the I<protoent> structure are:"
msgstr ""

#. type: TP
#: build/C/man3/getprotoent.3:114
#, no-wrap
msgid "I<p_name>"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent.3:117
msgid "The official name of the protocol."
msgstr ""

#. type: TP
#: build/C/man3/getprotoent.3:117
#, no-wrap
msgid "I<p_aliases>"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent.3:120
msgid "A NULL-terminated list of alternative names for the protocol."
msgstr ""

#. type: TP
#: build/C/man3/getprotoent.3:120
#, no-wrap
msgid "I<p_proto>"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent.3:123
msgid "The protocol number."
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent.3:134
msgid ""
"The B<getprotoent>(), B<getprotobyname>(), and B<getprotobynumber>()  "
"functions return a pointer to a statically allocated I<protoent> structure, "
"or a null pointer if an error occurs or the end of the file is reached."
msgstr ""

#. type: TP
#: build/C/man3/getprotoent.3:136 build/C/man5/nsswitch.conf.5:399 build/C/man5/protocols.5:78
#, no-wrap
msgid "I</etc/protocols>"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent.3:139
msgid "protocol database file"
msgstr ""

#. type: tbl table
#: build/C/man3/getprotoent.3:150
#, no-wrap
msgid "B<getprotoent>()"
msgstr ""

#. type: tbl table
#: build/C/man3/getprotoent.3:152 build/C/man3/getprotoent.3:175
#, no-wrap
msgid "MT-Unsafe race:protoent\n"
msgstr ""

#. type: tbl table
#: build/C/man3/getprotoent.3:154
#, no-wrap
msgid "race:protoentbuf locale"
msgstr ""

#. type: tbl table
#: build/C/man3/getprotoent.3:157
#, no-wrap
msgid "B<getprotobyname>()"
msgstr ""

#. type: tbl table
#: build/C/man3/getprotoent.3:159
#, no-wrap
msgid "MT-Unsafe race:protobyname\n"
msgstr ""

#. type: tbl table
#: build/C/man3/getprotoent.3:164
#, no-wrap
msgid "B<getprotobynumber>()"
msgstr ""

#. type: tbl table
#: build/C/man3/getprotoent.3:166
#, no-wrap
msgid "MT-Unsafe race:protobynumber\n"
msgstr ""

#. type: tbl table
#: build/C/man3/getprotoent.3:171
#, no-wrap
msgid "B<setprotoent>(),\n"
msgstr ""

#. type: tbl table
#: build/C/man3/getprotoent.3:173
#, no-wrap
msgid "B<endprotoent>()"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent.3:191
msgid ""
"In the above table, I<protoent> in I<race:protoent> signifies that if any of "
"the functions B<setprotoent>(), B<getprotoent>(), or B<endprotoent>()  are "
"used in parallel in different threads of a program, then data races could "
"occur."
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent.3:198
msgid "B<getnetent>(3), B<getprotoent_r>(3), B<getservent>(3), B<protocols>(5)"
msgstr ""

#. type: TH
#: build/C/man3/getprotoent_r.3:26
#, no-wrap
msgid "GETPROTOENT_R"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent_r.3:30
msgid ""
"getprotoent_r, getprotobyname_r, getprotobynumber_r - get protocol entry "
"(reentrant)"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent_r.3:36
#, no-wrap
msgid ""
"B<int getprotoent_r(struct protoent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct protoent **>I<result>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent_r.3:40
#, no-wrap
msgid ""
"B<int getprotobyname_r(const char *>I<name>B<,>\n"
"B<                struct protoent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct protoent **>I<result>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent_r.3:44
#, no-wrap
msgid ""
"B<int getprotobynumber_r(int >I<proto>B<,>\n"
"B<                struct protoent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct protoent **>I<result>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent_r.3:59
#, no-wrap
msgid ""
"B<getprotoent_r>(),\n"
"B<getprotobyname_r>(),\n"
"B<getprotobynumber_r>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent_r.3:77
msgid ""
"The B<getprotoent_r>(), B<getprotobyname_r>(), and B<getprotobynumber_r>()  "
"functions are the reentrant equivalents of, respectively, B<getprotoent>(3), "
"B<getprotobyname>(3), and B<getprotobynumber>(3).  They differ in the way "
"that the I<protoent> structure is returned, and in the function calling "
"signature and return value.  This manual page describes just the differences "
"from the nonreentrant functions."
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent_r.3:83
msgid ""
"Instead of returning a pointer to a statically allocated I<protoent> "
"structure as the function result, these functions copy the structure into "
"the location pointed to by I<result_buf>."
msgstr ""

#.  I can find no information on the required/recommended buffer size;
#.  the nonreentrant functions use a 1024 byte buffer.
#.  The 1024 byte value is also what the Solaris man page suggests. -- mtk
#. type: Plain text
#: build/C/man3/getprotoent_r.3:101
msgid ""
"The I<buf> array is used to store the string fields pointed to by the "
"returned I<protoent> structure.  (The nonreentrant functions allocate these "
"strings in static storage.)  The size of this array is specified in "
"I<buflen>.  If I<buf> is too small, the call fails with the error B<ERANGE>, "
"and the caller must try again with a larger buffer.  (A buffer of length "
"1024 bytes should be sufficient for most applications.)"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent_r.3:109
msgid ""
"If the function call successfully obtains a protocol record, then I<*result> "
"is set pointing to I<result_buf>; otherwise, I<*result> is set to NULL."
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent_r.3:120
msgid ""
"On error, record not found (B<getprotobyname_r>(), B<getprotobynumber_r>()), "
"or end of input (B<getprotoent_r>())  I<result> is set to NULL."
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent_r.3:125
msgid "(B<getprotoent_r>())  No more records in database."
msgstr ""

#. type: tbl table
#: build/C/man3/getprotoent_r.3:142
#, no-wrap
msgid "B<getprotoent_r>(),\n"
msgstr ""

#. type: tbl table
#: build/C/man3/getprotoent_r.3:144
#, no-wrap
msgid "B<getprotobyname_r>(),\n"
msgstr ""

#. type: tbl table
#: build/C/man3/getprotoent_r.3:146
#, no-wrap
msgid "B<getprotobynumber_r>()"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent_r.3:167
msgid ""
"The program below uses B<getprotobyname_r>()  to retrieve the protocol "
"record for the protocol named in its first command-line argument.  If a "
"second (integer) command-line argument is supplied, it is used as the "
"initial value for I<buflen>; if B<getprotobyname_r>()  fails with the error "
"B<ERANGE>, the program retries with larger buffer sizes.  The following "
"shell session shows a couple of sample runs:"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent_r.3:178
#, no-wrap
msgid ""
"$B< ./a.out tcp 1>\n"
"ERANGE! Retrying with larger buffer\n"
"getprotobyname_r() returned: 0 (success)  (buflen=78)\n"
"p_name=tcp; p_proto=6; aliases=TCP\n"
"$B< ./a.out xxx 1>\n"
"ERANGE! Retrying with larger buffer\n"
"getprotobyname_r() returned: 0 (success)  (buflen=100)\n"
"Call failed/record not found\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent_r.3:190 build/C/man3/getservent_r.3:187
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>ctype.hE<gt>\n"
"#include E<lt>netdb.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent_r.3:192 build/C/man3/getservent_r.3:189
#, no-wrap
msgid "#define MAX_BUF 10000\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent_r.3:200
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int buflen, erange_cnt, s;\n"
"    struct protoent result_buf;\n"
"    struct protoent *result;\n"
"    char buf[MAX_BUF];\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent_r.3:205
#, no-wrap
msgid ""
"    if (argc E<lt> 2) {\n"
"        printf(\"Usage: %s proto-name [buflen]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent_r.3:209
#, no-wrap
msgid ""
"    buflen = 1024;\n"
"    if (argc E<gt> 2)\n"
"        buflen = atoi(argv[2]);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent_r.3:214 build/C/man3/getservent_r.3:216
#, no-wrap
msgid ""
"    if (buflen E<gt> MAX_BUF) {\n"
"        printf(\"Exceeded buffer limit (%d)\\en\", MAX_BUF);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent_r.3:223
#, no-wrap
msgid ""
"    erange_cnt = 0;\n"
"    do {\n"
"        s = getprotobyname_r(argv[1], &result_buf,\n"
"                     buf, buflen, &result);\n"
"        if (s == ERANGE) {\n"
"            if (erange_cnt == 0)\n"
"                printf(\"ERANGE! Retrying with larger buffer\\en\");\n"
"            erange_cnt++;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent_r.3:226 build/C/man3/getservent_r.3:228
#, no-wrap
msgid ""
"            /* Increment a byte at a time so we can see exactly\n"
"               what size buffer was required */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent_r.3:228 build/C/man3/getservent_r.3:230
#, no-wrap
msgid "            buflen++;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent_r.3:235 build/C/man3/getservent_r.3:237
#, no-wrap
msgid ""
"            if (buflen E<gt> MAX_BUF) {\n"
"                printf(\"Exceeded buffer limit (%d)\\en\", MAX_BUF);\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
"        }\n"
"    } while (s == ERANGE);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent_r.3:239
#, no-wrap
msgid ""
"    printf(\"getprotobyname_r() returned: %s  (buflen=%d)\\en\",\n"
"            (s == 0) ? \"0 (success)\" : (s == ENOENT) ? \"ENOENT\" :\n"
"            strerror(s), buflen);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent_r.3:244 build/C/man3/getservent_r.3:246
#, no-wrap
msgid ""
"    if (s != 0 || result == NULL) {\n"
"        printf(\"Call failed/record not found\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent_r.3:250
#, no-wrap
msgid ""
"    printf(\"p_name=%s; p_proto=%d; aliases=\",\n"
"                result_buf.p_name, result_buf.p_proto);\n"
"    for (char **p = result_buf.p_aliases; *p != NULL; p++)\n"
"        printf(\"%s \", *p);\n"
"    printf(\"\\en\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent_r.3:257
msgid "B<getprotoent>(3), B<protocols>(5)"
msgstr ""

#. type: TH
#: build/C/man3/getservent.3:34
#, no-wrap
msgid "GETSERVENT"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent.3:38
msgid ""
"getservent, getservbyname, getservbyport, setservent, endservent - get "
"service entry"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent.3:43
#, no-wrap
msgid "B<struct servent *getservent(void);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent.3:45
#, no-wrap
msgid ""
"B<struct servent *getservbyname(const char *>I<name>B<, const char "
"*>I<proto>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent.3:47
#, no-wrap
msgid "B<struct servent *getservbyport(int >I<port>B<, const char *>I<proto>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent.3:49
#, no-wrap
msgid "B<void setservent(int >I<stayopen>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent.3:51
#, no-wrap
msgid "B<void endservent(void);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent.3:62
msgid ""
"The B<getservent>()  function reads the next entry from the services "
"database (see B<services>(5))  and returns a I<servent> structure containing "
"the broken-out fields from the entry.  A connection is opened to the "
"database if necessary."
msgstr ""

#. type: Plain text
#: build/C/man3/getservent.3:77
msgid ""
"The B<getservbyname>()  function returns a I<servent> structure for the "
"entry from the database that matches the service I<name> using protocol "
"I<proto>.  If I<proto> is NULL, any protocol will be matched.  A connection "
"is opened to the database if necessary."
msgstr ""

#. type: Plain text
#: build/C/man3/getservent.3:93
msgid ""
"The B<getservbyport>()  function returns a I<servent> structure for the "
"entry from the database that matches the port I<port> (given in network byte "
"order)  using protocol I<proto>.  If I<proto> is NULL, any protocol will be "
"matched.  A connection is opened to the database if necessary."
msgstr ""

#. type: Plain text
#: build/C/man3/getservent.3:105
msgid ""
"The B<setservent>()  function opens a connection to the database, and sets "
"the next entry to the first entry.  If I<stayopen> is nonzero, then the "
"connection to the database will not be closed between calls to one of the "
"B<getserv*>()  functions."
msgstr ""

#. type: Plain text
#: build/C/man3/getservent.3:109
msgid "The B<endservent>()  function closes the connection to the database."
msgstr ""

#. type: Plain text
#: build/C/man3/getservent.3:115
msgid "The I<servent> structure is defined in I<E<lt>netdb.hE<gt>> as follows:"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent.3:124
#, no-wrap
msgid ""
"struct servent {\n"
"    char  *s_name;       /* official service name */\n"
"    char **s_aliases;    /* alias list */\n"
"    int    s_port;       /* port number */\n"
"    char  *s_proto;      /* protocol to use */\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent.3:130
msgid "The members of the I<servent> structure are:"
msgstr ""

#. type: TP
#: build/C/man3/getservent.3:130
#, no-wrap
msgid "I<s_name>"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent.3:133
msgid "The official name of the service."
msgstr ""

#. type: TP
#: build/C/man3/getservent.3:133
#, no-wrap
msgid "I<s_aliases>"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent.3:136
msgid "A NULL-terminated list of alternative names for the service."
msgstr ""

#. type: TP
#: build/C/man3/getservent.3:136
#, no-wrap
msgid "I<s_port>"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent.3:139
msgid "The port number for the service given in network byte order."
msgstr ""

#. type: TP
#: build/C/man3/getservent.3:139
#, no-wrap
msgid "I<s_proto>"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent.3:142
msgid "The name of the protocol to use with this service."
msgstr ""

#. type: Plain text
#: build/C/man3/getservent.3:153
msgid ""
"The B<getservent>(), B<getservbyname>(), and B<getservbyport>()  functions "
"return a pointer to a statically allocated I<servent> structure, or NULL if "
"an error occurs or the end of the file is reached."
msgstr ""

#. type: TP
#: build/C/man3/getservent.3:154 build/C/man5/nsswitch.conf.5:408 build/C/man5/services.5:184
#, no-wrap
msgid "I</etc/services>"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent.3:157
msgid "services database file"
msgstr ""

#. type: tbl table
#: build/C/man3/getservent.3:167
#, no-wrap
msgid "B<getservent>()"
msgstr ""

#. type: tbl table
#: build/C/man3/getservent.3:169 build/C/man3/getservent.3:192
#, no-wrap
msgid "MT-Unsafe race:servent\n"
msgstr ""

#. type: tbl table
#: build/C/man3/getservent.3:171
#, no-wrap
msgid "race:serventbuf locale"
msgstr ""

#. type: tbl table
#: build/C/man3/getservent.3:174
#, no-wrap
msgid "B<getservbyname>()"
msgstr ""

#. type: tbl table
#: build/C/man3/getservent.3:176
#, no-wrap
msgid "MT-Unsafe race:servbyname\n"
msgstr ""

#. type: tbl table
#: build/C/man3/getservent.3:181
#, no-wrap
msgid "B<getservbyport>()"
msgstr ""

#. type: tbl table
#: build/C/man3/getservent.3:183
#, no-wrap
msgid "MT-Unsafe race:servbyport\n"
msgstr ""

#. type: tbl table
#: build/C/man3/getservent.3:188
#, no-wrap
msgid "B<setservent>(),\n"
msgstr ""

#. type: tbl table
#: build/C/man3/getservent.3:190
#, no-wrap
msgid "B<endservent>()"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent.3:208
msgid ""
"In the above table, I<servent> in I<race:servent> signifies that if any of "
"the functions B<setservent>(), B<getservent>(), or B<endservent>()  are used "
"in parallel in different threads of a program, then data races could occur."
msgstr ""

#. type: Plain text
#: build/C/man3/getservent.3:215
msgid "B<getnetent>(3), B<getprotoent>(3), B<getservent_r>(3), B<services>(5)"
msgstr ""

#. type: TH
#: build/C/man3/getservent_r.3:26
#, no-wrap
msgid "GETSERVENT_R"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent_r.3:30
msgid ""
"getservent_r, getservbyname_r, getservbyport_r - get service entry "
"(reentrant)"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent_r.3:36
#, no-wrap
msgid ""
"B<int getservent_r(struct servent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct servent **>I<result>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent_r.3:40
#, no-wrap
msgid ""
"B<int getservbyname_r(const char *>I<name>B<, const char *>I<proto>B<,>\n"
"B<                struct servent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct servent **>I<result>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent_r.3:44
#, no-wrap
msgid ""
"B<int getservbyport_r(int >I<port>B<, const char *>I<proto>B<,>\n"
"B<                struct servent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct servent **>I<result>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent_r.3:59
#, no-wrap
msgid ""
"B<getservent_r>(),\n"
"B<getservbyname_r>(),\n"
"B<getservbyport_r>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent_r.3:77
msgid ""
"The B<getservent_r>(), B<getservbyname_r>(), and B<getservbyport_r>()  "
"functions are the reentrant equivalents of, respectively, B<getservent>(3), "
"B<getservbyname>(3), and B<getservbyport>(3).  They differ in the way that "
"the I<servent> structure is returned, and in the function calling signature "
"and return value.  This manual page describes just the differences from the "
"nonreentrant functions."
msgstr ""

#. type: Plain text
#: build/C/man3/getservent_r.3:83
msgid ""
"Instead of returning a pointer to a statically allocated I<servent> "
"structure as the function result, these functions copy the structure into "
"the location pointed to by I<result_buf>."
msgstr ""

#.  I can find no information on the required/recommended buffer size;
#.  the nonreentrant functions use a 1024 byte buffer -- mtk.
#. type: Plain text
#: build/C/man3/getservent_r.3:100
msgid ""
"The I<buf> array is used to store the string fields pointed to by the "
"returned I<servent> structure.  (The nonreentrant functions allocate these "
"strings in static storage.)  The size of this array is specified in "
"I<buflen>.  If I<buf> is too small, the call fails with the error B<ERANGE>, "
"and the caller must try again with a larger buffer.  (A buffer of length "
"1024 bytes should be sufficient for most applications.)"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent_r.3:108
msgid ""
"If the function call successfully obtains a service record, then I<*result> "
"is set pointing to I<result_buf>; otherwise, I<*result> is set to NULL."
msgstr ""

#. type: Plain text
#: build/C/man3/getservent_r.3:111
msgid ""
"On success, these functions return 0.  On error, they return one of the "
"positive error numbers listed in errors."
msgstr ""

#. type: Plain text
#: build/C/man3/getservent_r.3:119
msgid ""
"On error, record not found (B<getservbyname_r>(), B<getservbyport_r>()), or "
"end of input (B<getservent_r>())  I<result> is set to NULL."
msgstr ""

#. type: Plain text
#: build/C/man3/getservent_r.3:124
msgid "(B<getservent_r>())  No more records in database."
msgstr ""

#. type: tbl table
#: build/C/man3/getservent_r.3:144
#, no-wrap
msgid ""
"B<getservent_r>(),\n"
"B<getservbyname_r>(),\n"
"B<getservbyport_r>()"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent_r.3:165
msgid ""
"The program below uses B<getservbyport_r>()  to retrieve the service record "
"for the port and protocol named in its first command-line argument.  If a "
"third (integer) command-line argument is supplied, it is used as the initial "
"value for I<buflen>; if B<getservbyport_r>()  fails with the error "
"B<ERANGE>, the program retries with larger buffer sizes.  The following "
"shell session shows a couple of sample runs:"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent_r.3:175
#, no-wrap
msgid ""
"$B< ./a.out 7 tcp 1>\n"
"ERANGE! Retrying with larger buffer\n"
"getservbyport_r() returned: 0 (success)  (buflen=87)\n"
"s_name=echo; s_proto=tcp; s_port=7; aliases=\n"
"$B< ./a.out 77777 tcp>\n"
"getservbyport_r() returned: 0 (success)  (buflen=1024)\n"
"Call failed/record not found\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent_r.3:198
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int buflen, erange_cnt, port, s;\n"
"    struct servent result_buf;\n"
"    struct servent *result;\n"
"    char buf[MAX_BUF];\n"
"    char *protop;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent_r.3:203
#, no-wrap
msgid ""
"    if (argc E<lt> 3) {\n"
"        printf(\"Usage: %s port-num proto-name [buflen]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent_r.3:207
#, no-wrap
msgid ""
"    port = htons(atoi(argv[1]));\n"
"    protop = (strcmp(argv[2], \"null\") == 0 ||\n"
"              strcmp(argv[2], \"NULL\") == 0) ?  NULL : argv[2];\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent_r.3:211
#, no-wrap
msgid ""
"    buflen = 1024;\n"
"    if (argc E<gt> 3)\n"
"        buflen = atoi(argv[3]);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent_r.3:225
#, no-wrap
msgid ""
"    erange_cnt = 0;\n"
"    do {\n"
"        s = getservbyport_r(port, protop, &result_buf,\n"
"                     buf, buflen, &result);\n"
"        if (s == ERANGE) {\n"
"            if (erange_cnt == 0)\n"
"                printf(\"ERANGE! Retrying with larger buffer\\en\");\n"
"            erange_cnt++;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent_r.3:241
#, no-wrap
msgid ""
"    printf(\"getservbyport_r() returned: %s  (buflen=%d)\\en\",\n"
"            (s == 0) ? \"0 (success)\" : (s == ENOENT) ? \"ENOENT\" :\n"
"            strerror(s), buflen);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent_r.3:253
#, no-wrap
msgid ""
"    printf(\"s_name=%s; s_proto=%s; s_port=%d; aliases=\",\n"
"                result_buf.s_name, result_buf.s_proto,\n"
"                ntohs(result_buf.s_port));\n"
"    for (char **p = result_buf.s_aliases; *p != NULL; p++)\n"
"        printf(\"%s \", *p);\n"
"    printf(\"\\en\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent_r.3:260
msgid "B<getservent>(3), B<services>(5)"
msgstr ""

#. type: TH
#: build/C/man5/host.conf.5:26
#, no-wrap
msgid "HOST.CONF"
msgstr ""

#. type: TH
#: build/C/man5/host.conf.5:26
#, no-wrap
msgid "2019-03-06"
msgstr ""

#. type: TH
#: build/C/man5/host.conf.5:26 build/C/man5/networks.5:26
#, no-wrap
msgid "Linux System Administration"
msgstr ""

#. type: Plain text
#: build/C/man5/host.conf.5:29
msgid "host.conf - resolver configuration file"
msgstr ""

#. type: Plain text
#: build/C/man5/host.conf.5:36
msgid ""
"The file I</etc/host.conf> contains configuration information specific to "
"the resolver library.  It should contain one configuration keyword per line, "
"followed by appropriate configuration information.  The following keywords "
"are recognized:"
msgstr ""

#. type: TP
#: build/C/man5/host.conf.5:36
#, no-wrap
msgid "I<trim>"
msgstr ""

#. type: Plain text
#: build/C/man5/host.conf.5:56
msgid ""
"This keyword may be listed more than once.  Each time it should be followed "
"by a list of domains, separated by colons (\\(aq:\\(aq), semicolons "
"(\\(aq;\\(aq) or commas (\\(aq,\\(aq), with the leading dot.  When set, the "
"resolver library will automatically trim the given domain name from the end "
"of any hostname resolved via DNS.  This is intended for use with local hosts "
"and domains.  (Related note: I<trim> will not affect hostnames gathered via "
"NIS or the B<hosts>(5)  file.  Care should be taken to ensure that the first "
"hostname for each entry in the hosts file is fully qualified or unqualified, "
"as appropriate for the local installation.)"
msgstr ""

#. type: TP
#: build/C/man5/host.conf.5:56
#, no-wrap
msgid "I<multi>"
msgstr ""

#. type: Plain text
#: build/C/man5/host.conf.5:71
msgid ""
"Valid values are I<on> and I<off>.  If set to I<on>, the resolver library "
"will return all valid addresses for a host that appears in the I</etc/hosts> "
"file, instead of only the first.  This is I<off> by default, as it may cause "
"a substantial performance loss at sites with large hosts files."
msgstr ""

#. type: TP
#: build/C/man5/host.conf.5:71
#, no-wrap
msgid "I<reorder>"
msgstr ""

#. type: Plain text
#: build/C/man5/host.conf.5:85
msgid ""
"Valid values are I<on> and I<off>.  If set to I<on>, the resolver library "
"will attempt to reorder host addresses so that local addresses (i.e., on the "
"same subnet) are listed first when a B<gethostbyname>(3)  is performed.  "
"Reordering is done for all lookup methods.  The default value is I<off>."
msgstr ""

#. type: SH
#: build/C/man5/host.conf.5:85
#, no-wrap
msgid "ENVIRONMENT"
msgstr ""

#. type: Plain text
#: build/C/man5/host.conf.5:89
msgid ""
"The following environment variables can be used to allow users to override "
"the behavior which is configured in I</etc/host.conf>:"
msgstr ""

#. type: TP
#: build/C/man5/host.conf.5:89
#, no-wrap
msgid "B<RESOLV_HOST_CONF>"
msgstr ""

#. type: Plain text
#: build/C/man5/host.conf.5:93
msgid ""
"If set, this variable points to a file that should be read instead of "
"I</etc/host.conf>."
msgstr ""

#. type: TP
#: build/C/man5/host.conf.5:93
#, no-wrap
msgid "B<RESOLV_MULTI>"
msgstr ""

#. type: Plain text
#: build/C/man5/host.conf.5:98
msgid "Overrides the I<multi> command."
msgstr ""

#. type: TP
#: build/C/man5/host.conf.5:98
#, no-wrap
msgid "B<RESOLV_REORDER>"
msgstr ""

#. type: Plain text
#: build/C/man5/host.conf.5:103
msgid "Overrides the I<reorder> command."
msgstr ""

#. type: TP
#: build/C/man5/host.conf.5:103
#, no-wrap
msgid "B<RESOLV_ADD_TRIM_DOMAINS>"
msgstr ""

#. type: Plain text
#: build/C/man5/host.conf.5:108
msgid ""
"A list of domains, separated by colons (\\(aq:\\(aq), semicolons "
"(\\(aq;\\(aq) or commas (\\(aq,\\(aq), with the leading dot, which will be "
"added to the list of domains that should be trimmed."
msgstr ""

#. type: TP
#: build/C/man5/host.conf.5:108
#, no-wrap
msgid "B<RESOLV_OVERRIDE_TRIM_DOMAINS>"
msgstr ""

#. type: Plain text
#: build/C/man5/host.conf.5:116
msgid ""
"A list of domains, separated by colons (\\(aq:\\(aq), semicolons "
"(\\(aq;\\(aq) or commas (\\(aq,\\(aq), with the leading dot, which will "
"replace the list of domains that should be trimmed.  Overrides the I<trim> "
"command."
msgstr ""

#. type: Plain text
#: build/C/man5/host.conf.5:120 build/C/man5/host.conf.5:123
msgid "Resolver configuration file"
msgstr ""

#. type: Plain text
#: build/C/man5/host.conf.5:126
msgid "Local hosts database"
msgstr ""

#. type: Plain text
#: build/C/man5/host.conf.5:135
msgid ""
"The following differences exist compared to the original implementation.  A "
"new command I<spoof> and a new environment variable B<RESOLV_SPOOF_CHECK> "
"can take arguments like I<off>, I<nowarn>, and I<warn>.  Line comments can "
"appear anywhere and not only at the beginning of a line."
msgstr ""

#. type: Plain text
#: build/C/man5/host.conf.5:141
msgid "In glibc 2.4 and earlier, the following keyword is recognized:"
msgstr ""

#. type: TP
#: build/C/man5/host.conf.5:141
#, no-wrap
msgid "I<order>"
msgstr ""

#. type: Plain text
#: build/C/man5/host.conf.5:147
msgid ""
"This keyword specifies how host lookups are to be performed.  It should be "
"followed by one or more lookup methods, separated by commas.  Valid methods "
"are I<bind>, I<hosts>, and I<nis>."
msgstr ""

#. type: TP
#: build/C/man5/host.conf.5:147
#, no-wrap
msgid "B<RESOLV_SERV_ORDER>"
msgstr ""

#. type: Plain text
#: build/C/man5/host.conf.5:152
msgid "Overrides the I<order> command."
msgstr ""

#.  commit 7d68cdaa4f748e87ee921f587ee2d483db624b3d
#. type: Plain text
#: build/C/man5/host.conf.5:156
msgid ""
"Since glibc 2.0.7, and up through glibc 2.24, the following keywords and "
"environment variable have been recognized but never implemented:"
msgstr ""

#. type: TP
#: build/C/man5/host.conf.5:156
#, no-wrap
msgid "I<nospoof>"
msgstr ""

#. type: Plain text
#: build/C/man5/host.conf.5:171
msgid ""
"Valid values are I<on> and I<off>.  If set to I<on>, the resolver library "
"will attempt to prevent hostname spoofing to enhance the security of "
"B<rlogin> and B<rsh>.  It works as follows: after performing a host address "
"lookup, the resolver library will perform a hostname lookup for that "
"address.  If the two hostnames do not match, the query fails.  The default "
"value is I<off>."
msgstr ""

#. type: TP
#: build/C/man5/host.conf.5:171
#, no-wrap
msgid "I<spoofalert>"
msgstr ""

#. type: Plain text
#: build/C/man5/host.conf.5:184
msgid ""
"Valid values are I<on> and I<off>.  If this option is set to I<on> and the "
"I<nospoof> option is also set, the resolver library will log a warning of "
"the error via the syslog facility.  The default value is I<off>."
msgstr ""

#. type: TP
#: build/C/man5/host.conf.5:184
#, no-wrap
msgid "I<spoof>"
msgstr ""

#. type: Plain text
#: build/C/man5/host.conf.5:203
msgid ""
"Valid values are I<off>, I<nowarn>, and I<warn>.  If this option is set to "
"I<off>, spoofed addresses are permitted and no warnings will be emitted via "
"the syslog facility.  If this option is set to I<warn>, the resolver library "
"will attempt to prevent hostname spoofing to enhance the security and log a "
"warning of the error via the syslog facility.  If this option is set to "
"I<nowarn>, the resolver library will attempt to prevent hostname spoofing to "
"enhance the security but not emit warnings via the syslog facility.  Setting "
"this option to anything else is equal to setting it to I<nowarn>."
msgstr ""

#. type: TP
#: build/C/man5/host.conf.5:203
#, no-wrap
msgid "B<RESOLV_SPOOF_CHECK>"
msgstr ""

#. type: Plain text
#: build/C/man5/host.conf.5:212
msgid ""
"Overrides the I<nospoof>, I<spoofalert>, and I<spoof> commands in the same "
"way as the I<spoof> command is parsed.  Valid values are I<off>, I<nowarn>, "
"and I<warn>."
msgstr ""

#. type: Plain text
#: build/C/man5/host.conf.5:219
msgid ""
"B<gethostbyname>(3), B<hosts>(5), B<nsswitch.conf>(5), B<resolv.conf>(5), "
"B<hostname>(7), B<named>(8)"
msgstr ""

#. type: TH
#: build/C/man7/hostname.7:39
#, no-wrap
msgid "HOSTNAME"
msgstr ""

#. type: TH
#: build/C/man7/hostname.7:39
#, no-wrap
msgid "2019-05-09"
msgstr ""

#. type: Plain text
#: build/C/man7/hostname.7:42
msgid "hostname - hostname resolution description"
msgstr ""

#. type: Plain text
#: build/C/man7/hostname.7:46
msgid ""
"Hostnames are domains, where a domain is a hierarchical, dot-separated list "
"of subdomains; for example, the machine \"monet\", in the \"example\" "
"subdomain of the \"com\" domain would be represented as "
"\"monet.example.com\"."
msgstr ""

#. type: Plain text
#: build/C/man7/hostname.7:61
msgid ""
"Each element of the hostname must be from 1 to 63 characters long and the "
"entire hostname, including the dots, can be at most 253 characters long.  "
"Valid characters for hostnames are B<ASCII>(7)  letters from I<a> to I<z>, "
"the digits from I<0> to I<9>, and the hyphen (-).  A hostname may not start "
"with a hyphen."
msgstr ""

#. type: Plain text
#: build/C/man7/hostname.7:68
msgid ""
"Hostnames are often used with network client and server programs, which must "
"generally translate the name to an address for use.  (This task is generally "
"performed by either B<getaddrinfo>(3)  or the obsolete B<gethostbyname>(3).)"
msgstr ""

#. type: Plain text
#: build/C/man7/hostname.7:78
msgid ""
"Hostnames are resolved by the NSS framework in glibc according to the "
"B<hosts> configuration in B<nsswitch.conf>.  The DNS-based name resolver (in "
"the B<dns> NSS service module) resolves them in the following fashion."
msgstr ""

#. type: Plain text
#: build/C/man7/hostname.7:91
msgid ""
"If the name consists of a single component, that is, contains no dot, and if "
"the environment variable B<HOSTALIASES> is set to the name of a file, that "
"file is searched for any string matching the input hostname.  The file "
"should consist of lines made up of two white-space separated strings, the "
"first of which is the hostname alias, and the second of which is the "
"complete hostname to be substituted for that alias.  If a case-insensitive "
"match is found between the hostname to be resolved and the first field of a "
"line in the file, the substituted name is looked up with no further "
"processing."
msgstr ""

#. type: Plain text
#: build/C/man7/hostname.7:95
msgid ""
"If the input name ends with a trailing dot, the trailing dot is removed, and "
"the remaining name is looked up with no further processing."
msgstr ""

#. type: Plain text
#: build/C/man7/hostname.7:108
msgid ""
"If the input name does not end with a trailing dot, it is looked up by "
"searching through a list of domains until a match is found.  The default "
"search list includes first the local domain, then its parent domains with at "
"least 2 name components (longest first).  For example, in the domain "
"cs.example.com, the name lithium.cchem will be checked first as "
"lithium.cchem.cs.example and then as lithium.cchem.example.com.  "
"lithium.cchem.com will not be tried, as there is only one component "
"remaining from the local domain.  The search path can be changed from the "
"default by a system-wide configuration file (see B<resolver>(5))."
msgstr ""

#. type: Plain text
#: build/C/man7/hostname.7:115
msgid ""
"B<getaddrinfo>(3), B<gethostbyname>(3), B<nsswitch.conf>(5), B<resolver>(5), "
"B<mailaddr>(7), B<named>(8)"
msgstr ""

#. type: Plain text
#: build/C/man7/hostname.7:119
msgid "E<.UR http://www.ietf.org\\:/rfc\\:/rfc1123.txt> IETF RFC\\ 1123 E<.UE>"
msgstr ""

#.  .SH HISTORY
#.  Hostname appeared in
#.  4.2BSD.
#. type: Plain text
#: build/C/man7/hostname.7:126
msgid "E<.UR http://www.ietf.org\\:/rfc\\:/rfc1178.txt> IETF RFC\\ 1178 E<.UE>"
msgstr ""

#. type: TH
#: build/C/man5/hosts.5:27
#, no-wrap
msgid "HOSTS"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.5:30
msgid "hosts - static table lookup for hostnames"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.5:32
msgid "B</etc/hosts>"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.5:40
msgid ""
"This manual page describes the format of the I</etc/hosts> file.  This file "
"is a simple text file that associates IP addresses with hostnames, one line "
"per IP address.  For each host a single line should be present with the "
"following information:"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.5:43
msgid "IP_address canonical_hostname [aliases...]"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.5:59
msgid ""
"The IP address can conform to either IPv4 or IPv6.  Fields of the entry are "
"separated by any number of blanks and/or tab characters.  Text from a \"#\" "
"character until the end of the line is a comment, and is ignored.  Host "
"names may contain only alphanumeric characters, minus signs (\"-\"), and "
"periods (\".\").  They must begin with an alphabetic character and end with "
"an alphanumeric character.  Optional aliases provide for name changes, "
"alternate spellings, shorter hostnames, or generic hostnames (for example, "
"I<localhost>).  If required, a host may have two separate entries in this "
"file; one for each version of the Internet Protocol (IPv4 and IPv6)."
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.5:67
msgid ""
"The Berkeley Internet Name Domain (BIND) Server implements the Internet name "
"server for UNIX systems.  It augments or replaces the I</etc/hosts> file or "
"hostname lookup, and frees a host from relying on I</etc/hosts> being up to "
"date and complete."
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.5:70
msgid ""
"In modern systems, even though the host table has been superseded by DNS, it "
"is still widely used for:"
msgstr ""

#. type: TP
#: build/C/man5/hosts.5:70
#, no-wrap
msgid "B<bootstrapping>"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.5:76
msgid ""
"Most systems have a small host table containing the name and address "
"information for important hosts on the local network.  This is useful when "
"DNS is not running, for example during system bootup."
msgstr ""

#. type: TP
#: build/C/man5/hosts.5:76
#, no-wrap
msgid "B<NIS>"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.5:82
msgid ""
"Sites that use NIS use the host table as input to the NIS host database.  "
"Even though NIS can be used with DNS, most NIS sites still use the host "
"table with an entry for all local hosts as a backup."
msgstr ""

#. type: TP
#: build/C/man5/hosts.5:82
#, no-wrap
msgid "B<isolated nodes>"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.5:89
msgid ""
"Very small sites that are isolated from the network use the host table "
"instead of DNS.  If the local information rarely changes, and the network is "
"not connected to the Internet, DNS offers little advantage."
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.5:94
msgid ""
"Modifications to this file normally take effect immediately, except in cases "
"where the file is cached by applications."
msgstr ""

#. type: SS
#: build/C/man5/hosts.5:94
#, no-wrap
msgid "Historical notes"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.5:97
msgid ""
"RFC\\ 952 gave the original format for the host table, though it has since "
"changed."
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.5:110
msgid ""
"Before the advent of DNS, the host table was the only way of resolving "
"hostnames on the fledgling Internet.  Indeed, this file could be created "
"from the official host data base maintained at the Network Information "
"Control Center (NIC), though local changes were often required to bring it "
"up to date regarding unofficial aliases and/or unknown hosts.  The NIC no "
"longer maintains the hosts.txt files, though looking around at the time of "
"writing (circa 2000), there are historical hosts.txt files on the WWW.  I "
"just found three, from 92, 94, and 95."
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.5:114
#, no-wrap
msgid ""
"# The following lines are desirable for IPv4 capable hosts\n"
"127.0.0.1       localhost\n"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.5:121
#, no-wrap
msgid ""
"# 127.0.1.1 is often used for the FQDN of the machine\n"
"127.0.1.1       thishost.mydomain.org  thishost\n"
"192.168.1.10    foo.mydomain.org       foo\n"
"192.168.1.13    bar.mydomain.org       bar\n"
"146.82.138.7    master.debian.org      master\n"
"209.237.226.90  www.opensource.org\n"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.5:126
#, no-wrap
msgid ""
"# The following lines are desirable for IPv6 capable hosts\n"
"::1             localhost ip6-localhost ip6-loopback\n"
"ff02::1         ip6-allnodes\n"
"ff02::2         ip6-allrouters\n"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.5:135
msgid ""
"B<hostname>(1), B<resolver>(3), B<host.conf>(5), B<resolv.conf>(5), "
"B<resolver>(5), B<hostname>(7), B<named>(8)"
msgstr ""

#.  .SH AUTHOR
#.  This manual page was written by Manoj Srivastava <srivasta@debian.org>,
#.  for the Debian GNU/Linux system.
#. type: Plain text
#: build/C/man5/hosts.5:140
msgid "Internet RFC\\ 952"
msgstr ""

#. type: TH
#: build/C/man5/hosts.equiv.5:6
#, no-wrap
msgid "HOSTS.EQUIV"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.equiv.5:11
msgid ""
"hosts.equiv - list of hosts and users that are granted \"trusted\" B<r> "
"command access to your system"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.equiv.5:22
msgid ""
"The file I</etc/hosts.equiv> allows or denies hosts and users to use the "
"B<r>-commands (e.g., B<rlogin>, B<rsh>, or B<rcp>)  without supplying a "
"password."
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.equiv.5:24
msgid "The file uses the following format:"
msgstr ""

#. type: TP
#: build/C/man5/hosts.equiv.5:24
#, no-wrap
msgid ""
"I<+|[-]hostname|+@netgroup|-@netgroup> "
"I<[+|[-]username|+@netgroup|-@netgroup]>"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.equiv.5:43
msgid ""
"The I<hostname> is the name of a host which is logically equivalent to the "
"local host.  Users logged into that host are allowed to access like-named "
"user accounts on the local host without supplying a password.  The "
"I<hostname> may be (optionally) preceded by a plus (+) sign.  If the plus "
"sign is used alone, it allows any host to access your system.  You can "
"explicitly deny access to a host by preceding the I<hostname> by a minus (-) "
"sign.  Users from that host must always supply additional credentials, "
"including possibly a password. For security reasons you should always use "
"the FQDN of the hostname and not the short hostname."
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.equiv.5:61
msgid ""
"The I<username> entry grants a specific user access to all user accounts "
"(except root) without supplying a password.  That means the user is NOT "
"restricted to like-named accounts.  The I<username> may be (optionally) "
"preceded by a plus (+) sign.  You can also explicitly deny access to a "
"specific user by preceding the I<username> with a minus (-) sign.  This says "
"that the user is not trusted no matter what other entries for that host "
"exist."
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.equiv.5:63
msgid "Netgroups can be specified by preceding the netgroup by an @ sign."
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.equiv.5:69
msgid ""
"Be extremely careful when using the plus (+) sign.  A simple typographical "
"error could result in a standalone plus sign.  A standalone plus sign is a "
"wildcard character that means \"any host\"!"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.equiv.5:71
msgid "I</etc/hosts.equiv>"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.equiv.5:76
msgid ""
"Some systems will honor the contents of this file only when it has owner "
"root and no write permission for anybody else.  Some exceptionally paranoid "
"systems even require that there be no other hard links to the file."
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.equiv.5:84
msgid ""
"Modern systems use the Pluggable Authentication Modules library (PAM).  With "
"PAM a standalone plus sign is considered a wildcard character which means "
"\"any host\" only when the word I<promiscuous> is added to the auth "
"component line in your PAM file for the particular service (e.g., "
"B<rlogin>)."
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.equiv.5:90
msgid "Below are some example I</etc/host.equiv> or I<\\(ti/.rhosts> files."
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.equiv.5:92
msgid "Allow any user to log in from any host:"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.equiv.5:94
#, no-wrap
msgid "    +\n"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.equiv.5:98
msgid "Allow any user from I<host> with a matching local account to log in:"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.equiv.5:100
#, no-wrap
msgid "    host\n"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.equiv.5:105
msgid ""
"Note: the use of I<+host> is never a valid syntax, including attempting to "
"specify that any user from the host is allowed."
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.equiv.5:109
msgid "Allow any user from I<host> to log in:"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.equiv.5:111
#, no-wrap
msgid "    host +\n"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.equiv.5:114
msgid ""
"Note: this is distinct from the previous example since it does not require a "
"matching local account."
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.equiv.5:120
msgid "Allow I<user> from I<host> to log in as any non-root user:"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.equiv.5:122
#, no-wrap
msgid "    host user\n"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.equiv.5:127
msgid ""
"Allow all users with matching local accounts from I<host> to log in except "
"for I<baduser>:"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.equiv.5:130
#, no-wrap
msgid ""
"    host -baduser\n"
"    host\n"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.equiv.5:133
msgid "Deny all users from I<host>:"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.equiv.5:135
#, no-wrap
msgid "    -host\n"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.equiv.5:141
msgid ""
"Note: the use of I<-host\\ -user> is never a valid syntax, including "
"attempting to specify that a particular user from the host is not trusted."
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.equiv.5:144
msgid "Allow all users with matching local accounts on all hosts in a I<netgroup>:"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.equiv.5:146
#, no-wrap
msgid "    +@netgroup\n"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.equiv.5:149
msgid "Disallow all users on all hosts in a I<netgroup>:"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.equiv.5:151
#, no-wrap
msgid "    -@netgroup\n"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.equiv.5:157
msgid ""
"Allow all users in a I<netgroup> to log in from I<host> as any non-root "
"user:"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.equiv.5:159
#, no-wrap
msgid "    host +@netgroup\n"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.equiv.5:164
msgid ""
"Allow all users with matching local accounts on all hosts in a I<netgroup> "
"except I<baduser>:"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.equiv.5:167
#, no-wrap
msgid ""
"    +@netgroup -baduser\n"
"    +@netgroup\n"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.equiv.5:170
msgid ""
"Note: the deny statements must always precede the allow statements because "
"the file is processed sequentially until the first matching rule is found."
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.equiv.5:174
msgid "B<rhosts>(5), B<rlogind>(8), B<rshd>(8)"
msgstr ""

#. type: TH
#: build/C/man7/icmp.7:12
#, no-wrap
msgid "ICMP"
msgstr ""

#. type: TH
#: build/C/man7/icmp.7:12
#, no-wrap
msgid "2017-11-26"
msgstr ""

#. type: Plain text
#: build/C/man7/icmp.7:15
msgid "icmp - Linux IPv4 ICMP kernel module."
msgstr ""

#. type: Plain text
#: build/C/man7/icmp.7:23
msgid ""
"This kernel protocol module implements the Internet Control Message Protocol "
"defined in RFC\\ 792.  It is used to signal error conditions and for "
"diagnosis.  The user doesn't interact directly with this module; instead it "
"communicates with the other protocols in the kernel and these pass the ICMP "
"errors to the application layers.  The kernel ICMP module also answers ICMP "
"requests."
msgstr ""

#. type: Plain text
#: build/C/man7/icmp.7:35
msgid ""
"A user protocol may receive ICMP packets for all local sockets by opening a "
"raw socket with the protocol B<IPPROTO_ICMP>.  See B<raw>(7)  for more "
"information.  The types of ICMP packets passed to the socket can be filtered "
"using the B<ICMP_FILTER> socket option.  ICMP packets are always processed "
"by the kernel too, even when passed to a user socket."
msgstr ""

#. type: Plain text
#: build/C/man7/icmp.7:41
msgid ""
"Linux limits the rate of ICMP error packets to each destination.  "
"B<ICMP_REDIRECT> and B<ICMP_DEST_UNREACH> are also limited by the "
"destination route of the incoming packets."
msgstr ""

#.  FIXME . better description needed
#. type: Plain text
#: build/C/man7/icmp.7:54
msgid ""
"ICMP supports a set of I</proc> interfaces to configure some global IP "
"parameters.  The parameters can be accessed by reading or writing files in "
"the directory I</proc/sys/net/ipv4/>.  Most of these parameters are rate "
"limitations for specific ICMP types.  Linux 2.2 uses a token bucket filter "
"to limit ICMPs.  The value is the timeout in jiffies until the token bucket "
"filter is cleared after a burst.  A jiffy is a system dependent unit, "
"usually 10ms on i386 and about 1ms on alpha and ia64."
msgstr ""

#. type: TP
#: build/C/man7/icmp.7:54
#, no-wrap
msgid "I<icmp_destunreach_rate> (Linux 2.2 to 2.4.9)"
msgstr ""

#.  Precisely: from 2.1.102
#. type: Plain text
#: build/C/man7/icmp.7:63
msgid ""
"Maximum rate to send ICMP Destination Unreachable packets.  This limits the "
"rate at which packets are sent to any individual route or destination.  The "
"limit does not affect sending of B<ICMP_FRAG_NEEDED> packets needed for path "
"MTU discovery."
msgstr ""

#. type: TP
#: build/C/man7/icmp.7:63
#, no-wrap
msgid "I<icmp_echo_ignore_all> (since Linux 2.2)"
msgstr ""

#.  Precisely: 2.1.68
#. type: Plain text
#: build/C/man7/icmp.7:69
msgid "If this value is nonzero, Linux will ignore all B<ICMP_ECHO> requests."
msgstr ""

#. type: TP
#: build/C/man7/icmp.7:69
#, no-wrap
msgid "I<icmp_echo_ignore_broadcasts> (since Linux 2.2)"
msgstr ""

#.  Precisely: from 2.1.68
#. type: Plain text
#: build/C/man7/icmp.7:75
msgid ""
"If this value is nonzero, Linux will ignore all B<ICMP_ECHO> packets sent to "
"broadcast addresses."
msgstr ""

#. type: TP
#: build/C/man7/icmp.7:75
#, no-wrap
msgid "I<icmp_echoreply_rate> (Linux 2.2 to 2.4.9)"
msgstr ""

#.  Precisely: from 2.1.102
#. type: Plain text
#: build/C/man7/icmp.7:83
msgid ""
"Maximum rate for sending B<ICMP_ECHOREPLY> packets in response to "
"B<ICMP_ECHOREQUEST> packets."
msgstr ""

#. type: TP
#: build/C/man7/icmp.7:83
#, no-wrap
msgid ""
"I<icmp_errors_use_inbound_ifaddr> (Boolean; default: disabled; since Linux "
"2.6.12)"
msgstr ""

#.  The following taken from 2.6.28-rc4 Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/icmp.7:88
msgid ""
"If disabled, ICMP error messages are sent with the primary address of the "
"exiting interface."
msgstr ""

#. type: Plain text
#: build/C/man7/icmp.7:94
msgid ""
"If enabled, the message will be sent with the primary address of the "
"interface that received the packet that caused the ICMP error.  This is the "
"behavior that many network administrators will expect from a router.  And it "
"can make debugging complicated network layouts much easier."
msgstr ""

#. type: Plain text
#: build/C/man7/icmp.7:98
msgid ""
"Note that if no primary address exists for the interface selected, then the "
"primary address of the first non-loopback interface that has one will be "
"used regardless of this setting."
msgstr ""

#. type: TP
#: build/C/man7/icmp.7:98
#, no-wrap
msgid ""
"I<icmp_ignore_bogus_error_responses> (Boolean; default: disabled; since "
"Linux 2.2)"
msgstr ""

#.  precisely: since 2.1.32
#.  The following taken from 2.6.28-rc4 Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/icmp.7:106
msgid ""
"Some routers violate RFC1122 by sending bogus responses to broadcast "
"frames.  Such violations are normally logged via a kernel warning.  If this "
"parameter is enabled, the kernel will not give such warnings, which will "
"avoid log file clutter."
msgstr ""

#. type: TP
#: build/C/man7/icmp.7:106
#, no-wrap
msgid "I<icmp_paramprob_rate> (Linux 2.2 to 2.4.9)"
msgstr ""

#.  Precisely: from 2.1.102
#. type: Plain text
#: build/C/man7/icmp.7:113
msgid ""
"Maximum rate for sending B<ICMP_PARAMETERPROB> packets.  These packets are "
"sent when a packet arrives with an invalid IP header."
msgstr ""

#. type: TP
#: build/C/man7/icmp.7:113
#, no-wrap
msgid "I<icmp_ratelimit> (integer; default: 1000; since Linux 2.4.10)"
msgstr ""

#.  The following taken from 2.6.28-rc4 Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/icmp.7:121
msgid ""
"Limit the maximum rates for sending ICMP packets whose type matches "
"I<icmp_ratemask> (see below) to specific targets.  0 to disable any "
"limiting, otherwise the minimum space between responses in milliseconds."
msgstr ""

#. type: TP
#: build/C/man7/icmp.7:121
#, no-wrap
msgid "I<icmp_ratemask> (integer; default: see below; since Linux 2.4.10)"
msgstr ""

#.  The following taken from 2.6.28-rc4 Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/icmp.7:125
msgid "Mask made of ICMP types for which rates are being limited."
msgstr ""

#. type: Plain text
#: build/C/man7/icmp.7:127
msgid "Significant bits: IHGFEDCBA9876543210"
msgstr ""

#. type: Plain text
#: build/C/man7/icmp.7:129
msgid "Default mask: 0000001100000011000 (0x1818)"
msgstr ""

#. type: Plain text
#: build/C/man7/icmp.7:132
msgid "Bit definitions (see the Linux kernel source file I<include/linux/icmp.h>):"
msgstr ""

#. type: tbl table
#: build/C/man7/icmp.7:135
#, no-wrap
msgid "0 Echo Reply"
msgstr ""

#. type: tbl table
#: build/C/man7/icmp.7:136
#, no-wrap
msgid "3 Destination Unreachable *"
msgstr ""

#. type: tbl table
#: build/C/man7/icmp.7:137
#, no-wrap
msgid "4 Source Quench *"
msgstr ""

#. type: tbl table
#: build/C/man7/icmp.7:138
#, no-wrap
msgid "5 Redirect"
msgstr ""

#. type: tbl table
#: build/C/man7/icmp.7:139
#, no-wrap
msgid "8 Echo Request"
msgstr ""

#. type: tbl table
#: build/C/man7/icmp.7:140
#, no-wrap
msgid "B Time Exceeded *"
msgstr ""

#. type: tbl table
#: build/C/man7/icmp.7:141
#, no-wrap
msgid "C Parameter Problem *"
msgstr ""

#. type: tbl table
#: build/C/man7/icmp.7:142
#, no-wrap
msgid "D Timestamp Request"
msgstr ""

#. type: tbl table
#: build/C/man7/icmp.7:143
#, no-wrap
msgid "E Timestamp Reply"
msgstr ""

#. type: tbl table
#: build/C/man7/icmp.7:144
#, no-wrap
msgid "F Info Request"
msgstr ""

#. type: tbl table
#: build/C/man7/icmp.7:145
#, no-wrap
msgid "G Info Reply"
msgstr ""

#. type: tbl table
#: build/C/man7/icmp.7:146
#, no-wrap
msgid "H Address Mask Request"
msgstr ""

#. type: tbl table
#: build/C/man7/icmp.7:147
#, no-wrap
msgid "I Address Mask Reply"
msgstr ""

#. type: Plain text
#: build/C/man7/icmp.7:153
msgid ""
"The bits marked with an asterisk are rate limited by default (see the "
"default mask above)."
msgstr ""

#. type: TP
#: build/C/man7/icmp.7:153
#, no-wrap
msgid "I<icmp_timeexceed_rate> (Linux 2.2 to 2.4.9)"
msgstr ""

#. type: Plain text
#: build/C/man7/icmp.7:160
msgid ""
"Maximum rate for sending B<ICMP_TIME_EXCEEDED> packets.  These packets are "
"sent to prevent loops when a packet has crossed too many hops."
msgstr ""

#. type: TP
#: build/C/man7/icmp.7:160
#, no-wrap
msgid "I<ping_group_range> (two integers; default: see below; since Linux 2.6.39)"
msgstr ""

#. type: Plain text
#: build/C/man7/icmp.7:166
msgid ""
"Range of the group IDs (minimum and maximum group IDs, inclusive)  that are "
"allowed to create ICMP Echo sockets.  The default is \"1 0\", which means no "
"group is allowed to create ICMP Echo sockets."
msgstr ""

#. type: Plain text
#: build/C/man7/icmp.7:170
msgid "Support for the B<ICMP_ADDRESS> request was removed in 2.2."
msgstr ""

#. type: Plain text
#: build/C/man7/icmp.7:174
msgid "Support for B<ICMP_SOURCE_QUENCH> was removed in Linux 2.2."
msgstr ""

#.  not really true ATM
#.  .PP
#.  Linux ICMP should be compliant to RFC 1122.
#. type: Plain text
#: build/C/man7/icmp.7:182
msgid ""
"As many other implementations don't support B<IPPROTO_ICMP> raw sockets, "
"this feature should not be relied on in portable programs."
msgstr ""

#. type: Plain text
#: build/C/man7/icmp.7:187
msgid ""
"B<ICMP_REDIRECT> packets are not sent when Linux is not acting as a router.  "
"They are also accepted only from the old gateway defined in the routing "
"table and the redirect routes are expired after some time."
msgstr ""

#. type: Plain text
#: build/C/man7/icmp.7:191
msgid ""
"The 64-bit timestamp returned by B<ICMP_TIMESTAMP> is in milliseconds since "
"the Epoch, 1970-01-01 00:00:00 +0000 (UTC)."
msgstr ""

#. type: Plain text
#: build/C/man7/icmp.7:196
msgid ""
"Linux ICMP internally uses a raw socket to send ICMPs.  This raw socket may "
"appear in B<netstat>(8)  output with a zero inode."
msgstr ""

#. type: Plain text
#: build/C/man7/icmp.7:199
msgid "B<ip>(7), B<rdisc>(8)"
msgstr ""

#. type: Plain text
#: build/C/man7/icmp.7:201
msgid "RFC\\ 792 for a description of the ICMP protocol."
msgstr ""

#. type: TH
#: build/C/man3/inet.3:42
#, no-wrap
msgid "INET"
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:46
msgid ""
"inet_aton, inet_addr, inet_network, inet_ntoa, inet_makeaddr, inet_lnaof, "
"inet_netof - Internet address manipulation routines"
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:51
#, no-wrap
msgid ""
"B<#include E<lt>sys/socket.hE<gt>>\n"
"B<#include E<lt>netinet/in.hE<gt>>\n"
"B<#include E<lt>arpa/inet.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:53
#, no-wrap
msgid "B<int inet_aton(const char *>I<cp>B<, struct in_addr *>I<inp>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:55
#, no-wrap
msgid "B<in_addr_t inet_addr(const char *>I<cp>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:57
#, no-wrap
msgid "B<in_addr_t inet_network(const char *>I<cp>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:59
#, no-wrap
msgid "B<char *inet_ntoa(struct in_addr >I<in>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:61
#, no-wrap
msgid ""
"B<struct in_addr inet_makeaddr(in_addr_t >I<net>B<, in_addr_t "
">I<host>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:63
#, no-wrap
msgid "B<in_addr_t inet_lnaof(struct in_addr >I<in>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:65
#, no-wrap
msgid "B<in_addr_t inet_netof(struct in_addr >I<in>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:74
msgid "B<inet_aton>(), B<inet_ntoa>():"
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:79
#, no-wrap
msgid ""
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    In glibc up to and including 2.19:\n"
"        _BSD_SOURCE || _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:90
msgid ""
"B<inet_aton>()  converts the Internet host address I<cp> from the IPv4 "
"numbers-and-dots notation into binary form (in network byte order)  and "
"stores it in the structure that I<inp> points to.  B<inet_aton>()  returns "
"nonzero if the address is valid, zero if not.  The address supplied in I<cp> "
"can have one of the following forms:"
msgstr ""

#. type: TP
#: build/C/man3/inet.3:90
#, no-wrap
msgid "I<a.b.c.d>"
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:94
msgid ""
"Each of the four numeric parts specifies a byte of the address; the bytes "
"are assigned in left-to-right order to produce the binary address."
msgstr ""

#. type: TP
#: build/C/man3/inet.3:94
#, no-wrap
msgid "I<a.b.c>"
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:107
msgid ""
"Parts I<a> and I<b> specify the first two bytes of the binary address.  Part "
"I<c> is interpreted as a 16-bit value that defines the rightmost two bytes "
"of the binary address.  This notation is suitable for specifying (outmoded) "
"Class B network addresses."
msgstr ""

#. type: TP
#: build/C/man3/inet.3:107
#, no-wrap
msgid "I<a.b>"
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:118
msgid ""
"Part I<a> specifies the first byte of the binary address.  Part I<b> is "
"interpreted as a 24-bit value that defines the rightmost three bytes of the "
"binary address.  This notation is suitable for specifying (outmoded) Class A "
"network addresses."
msgstr ""

#. type: TP
#: build/C/man3/inet.3:118
#, no-wrap
msgid "I<a>"
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:124
msgid ""
"The value I<a> is interpreted as a 32-bit value that is stored directly into "
"the binary address without any byte rearrangement."
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:137
msgid ""
"In all of the above forms, components of the dotted address can be specified "
"in decimal, octal (with a leading I<0>), or hexadecimal, with a leading "
"I<0X>).  Addresses in any of these forms are collectively termed I<IPV4 "
"numbers-and-dots notation>.  The form that uses exactly four decimal numbers "
"is referred to as I<IPv4 dotted-decimal notation> (or sometimes: I<IPv4 "
"dotted-quad notation>)."
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:145
msgid ""
"B<inet_aton>()  returns 1 if the supplied string was successfully "
"interpreted, or 0 if the string is invalid (B<errno> is I<not> set on "
"error)."
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:162
msgid ""
"The B<inet_addr>()  function converts the Internet host address I<cp> from "
"IPv4 numbers-and-dots notation into binary data in network byte order.  If "
"the input is invalid, B<INADDR_NONE> (usually -1) is returned.  Use of this "
"function is problematic because -1 is a valid address (255.255.255.255).  "
"Avoid its use in favor of B<inet_aton>(), B<inet_pton>(3), or "
"B<getaddrinfo>(3), which provide a cleaner way to indicate error return."
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:172
msgid ""
"The B<inet_network>()  function converts I<cp>, a string in IPv4 "
"numbers-and-dots notation, into a number in host byte order suitable for use "
"as an Internet network address.  On success, the converted address is "
"returned.  If the input is invalid, -1 is returned."
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:180
msgid ""
"The B<inet_ntoa>()  function converts the Internet host address I<in>, given "
"in network byte order, to a string in IPv4 dotted-decimal notation.  The "
"string is returned in a statically allocated buffer, which subsequent calls "
"will overwrite."
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:186
msgid ""
"The B<inet_lnaof>()  function returns the local network address part of the "
"Internet address I<in>.  The returned value is in host byte order."
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:192
msgid ""
"The B<inet_netof>()  function returns the network number part of the "
"Internet address I<in>.  The returned value is in host byte order."
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:203
msgid ""
"The B<inet_makeaddr>()  function is the converse of B<inet_netof>()  and "
"B<inet_lnaof>().  It returns an Internet host address in network byte order, "
"created by combining the network number I<net> with the local address "
"I<host>, both in host byte order."
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:213
msgid ""
"The structure I<in_addr> as used in B<inet_ntoa>(), B<inet_makeaddr>(), "
"B<inet_lnaof>(), and B<inet_netof>()  is defined in "
"I<E<lt>netinet/in.hE<gt>> as:"
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:217
#, no-wrap
msgid "typedef uint32_t in_addr_t;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:221
#, no-wrap
msgid ""
"struct in_addr {\n"
"    in_addr_t s_addr;\n"
"};\n"
msgstr ""

#. type: tbl table
#: build/C/man3/inet.3:234
#, no-wrap
msgid ""
"B<inet_aton>(),\n"
"B<inet_addr>(),\n"
msgstr ""

#. type: tbl table
#: build/C/man3/inet.3:237
#, no-wrap
msgid ""
"B<inet_network>(),\n"
"B<inet_ntoa>()"
msgstr ""

#. type: tbl table
#: build/C/man3/inet.3:241
#, no-wrap
msgid ""
"B<inet_makeaddr>(),\n"
"B<inet_lnaof>(),\n"
msgstr ""

#. type: tbl table
#: build/C/man3/inet.3:243
#, no-wrap
msgid "B<inet_netof>()"
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:249
msgid "B<inet_addr>(), B<inet_ntoa>(): POSIX.1-2001, POSIX.1-2008, 4.3BSD."
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:252
msgid ""
"B<inet_aton>()  is not specified in POSIX.1, but is available on most "
"systems."
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:256
msgid ""
"On x86 architectures, the host byte order is Least Significant Byte first "
"(little endian), whereas the network byte order, as used on the Internet, is "
"Most Significant Byte first (big endian)."
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:265
msgid ""
"B<inet_lnaof>(), B<inet_netof>(), and B<inet_makeaddr>()  are legacy "
"functions that assume they are dealing with I<classful network addresses>.  "
"Classful networking divides IPv4 network addresses into host and network "
"components at byte boundaries, as follows:"
msgstr ""

#. type: TP
#: build/C/man3/inet.3:265
#, no-wrap
msgid "Class A"
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:271
msgid ""
"This address type is indicated by the value 0 in the most significant bit of "
"the (network byte ordered) address.  The network address is contained in the "
"most significant byte, and the host address occupies the remaining three "
"bytes."
msgstr ""

#. type: TP
#: build/C/man3/inet.3:271
#, no-wrap
msgid "Class B"
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:277
msgid ""
"This address type is indicated by the binary value 10 in the most "
"significant two bits of the address.  The network address is contained in "
"the two most significant bytes, and the host address occupies the remaining "
"two bytes."
msgstr ""

#. type: TP
#: build/C/man3/inet.3:277
#, no-wrap
msgid "Class C"
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:283
msgid ""
"This address type is indicated by the binary value 110 in the most "
"significant three bits of the address.  The network address is contained in "
"the three most significant bytes, and the host address occupies the "
"remaining byte."
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:288
msgid ""
"Classful network addresses are now obsolete, having been superseded by "
"Classless Inter-Domain Routing (CIDR), which divides addresses into network "
"and host components at arbitrary bit (rather than byte) boundaries."
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:295
msgid ""
"An example of the use of B<inet_aton>()  and B<inet_ntoa>()  is shown "
"below.  Here are some example runs:"
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:302
#, no-wrap
msgid ""
"$B< ./a.out 226.000.000.037>      # Last byte is in octal\n"
"226.0.0.31\n"
"$B< ./a.out 0x7f.1         >      # First byte is in hex\n"
"127.0.0.1\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:311
#, no-wrap
msgid ""
"#define _BSD_SOURCE\n"
"#include E<lt>arpa/inet.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:316
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct in_addr addr;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:321
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"%s E<lt>dotted-addressE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:326
#, no-wrap
msgid ""
"    if (inet_aton(argv[1], &addr) == 0) {\n"
"        fprintf(stderr, \"Invalid address\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:330
#, no-wrap
msgid ""
"    printf(\"%s\\en\", inet_ntoa(addr));\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:342
msgid ""
"B<byteorder>(3), B<getaddrinfo>(3), B<gethostbyname>(3), B<getnameinfo>(3), "
"B<getnetent>(3), B<inet_net_pton>(3), B<inet_ntop>(3), B<inet_pton>(3), "
"B<hosts>(5), B<networks>(5)"
msgstr ""

#. type: TH
#: build/C/man3/inet_net_pton.3:25
#, no-wrap
msgid "INET_NET_PTON"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_net_pton.3:28
msgid "inet_net_pton, inet_net_ntop - Internet network number conversion"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_net_pton.3:34
#, no-wrap
msgid ""
"B<int inet_net_pton(int >I<af>B<, const char *>I<pres>B<,>\n"
"B<                  void *>I<netp>B<, size_t >I<nsize>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_net_pton.3:37
#, no-wrap
msgid ""
"B<char *inet_net_ntop(int >I<af>B<, const void *>I<netp>B<, int "
">I<bits>B<,>\n"
"B<                    char *>I<pres>B<, size_t >I<psize>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_net_pton.3:40 build/C/man3/resolver.3:110
msgid "Link with I<-lresolv>."
msgstr ""

#. type: Plain text
#: build/C/man3/inet_net_pton.3:48
msgid "B<inet_net_pton>(), B<inet_net_ntop>():"
msgstr ""

#. type: TP
#: build/C/man3/inet_net_pton.3:51
#, no-wrap
msgid "Since glibc 2.20:"
msgstr ""

#. type: TP
#: build/C/man3/inet_net_pton.3:54
#, no-wrap
msgid "Before glibc 2.20:"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_net_pton.3:63
msgid ""
"These functions convert network numbers between presentation (i.e., "
"printable) format and network (i.e., binary) format."
msgstr ""

#. type: Plain text
#: build/C/man3/inet_net_pton.3:69
msgid ""
"For both functions, I<af> specifies the address family for the conversion; "
"the only supported value is B<AF_INET>."
msgstr ""

#. type: SS
#: build/C/man3/inet_net_pton.3:69
#, no-wrap
msgid "inet_net_pton()"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_net_pton.3:88
msgid ""
"The B<inet_net_pton>()  function converts I<pres>, a null-terminated string "
"containing an Internet network number in presentation format to network "
"format.  The result of the conversion, which is in network byte order, is "
"placed in the buffer pointed to by I<net>.  (The I<netp> argument typically "
"points to an I<in_addr> structure.)  The I<nsize> argument specifies the "
"number of bytes available in I<netp>."
msgstr ""

#. type: Plain text
#: build/C/man3/inet_net_pton.3:96
msgid ""
"On success, B<inet_net_pton>()  returns the number of bits in the network "
"number field of the result placed in I<netp>.  For a discussion of the input "
"presentation format and the return value, see NOTES."
msgstr ""

#. type: Plain text
#: build/C/man3/inet_net_pton.3:106
msgid ""
"I<Note>: the buffer pointed to by I<netp> should be zeroed out before "
"calling B<inet_net_pton>(), since the call writes only as many bytes as are "
"required for the network number (or as are explicitly specified by I<pres>), "
"which may be less than the number of bytes in a complete network address."
msgstr ""

#. type: SS
#: build/C/man3/inet_net_pton.3:106
#, no-wrap
msgid "inet_net_ntop()"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_net_pton.3:118
msgid ""
"The B<inet_net_ntop>()  function converts the network number in the buffer "
"pointed to by I<netp> to presentation format; I<*netp> is interpreted as a "
"value in network byte order.  The I<bits> argument specifies the number of "
"bits in the network number in I<*netp>."
msgstr ""

#. type: Plain text
#: build/C/man3/inet_net_pton.3:129
msgid ""
"The null-terminated presentation-format string is placed in the buffer "
"pointed to by I<pres>.  The I<psize> argument specifies the number of bytes "
"available in I<pres>.  The presentation string is in CIDR format: a "
"dotted-decimal number representing the network address, followed by a slash, "
"and the size of the network number in bits."
msgstr ""

#. type: Plain text
#: build/C/man3/inet_net_pton.3:136
msgid ""
"On success, B<inet_net_pton>()  returns the number of bits in the network "
"number.  On error, it returns -1, and I<errno> is set to indicate the cause "
"of the error."
msgstr ""

#. type: Plain text
#: build/C/man3/inet_net_pton.3:144
msgid ""
"On success, B<inet_net_ntop>()  returns I<pres>.  On error, it returns NULL, "
"and I<errno> is set to indicate the cause of the error."
msgstr ""

#. type: TP
#: build/C/man3/inet_net_pton.3:145 build/C/man3/inet_ntop.3:92
#, no-wrap
msgid "B<EAFNOSUPPORT>"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_net_pton.3:150
msgid "I<af> specified a value other than B<AF_INET>."
msgstr ""

#. type: Plain text
#: build/C/man3/inet_net_pton.3:153
msgid "The size of the output buffer was insufficient."
msgstr ""

#. type: Plain text
#: build/C/man3/inet_net_pton.3:158
msgid "(B<inet_net_pton>())  I<pres> was not in correct presentation format."
msgstr ""

#. type: Plain text
#: build/C/man3/inet_net_pton.3:164
msgid ""
"The B<inet_net_pton>()  and B<inet_net_ntop>()  functions are nonstandard, "
"but widely available."
msgstr ""

#. type: SS
#: build/C/man3/inet_net_pton.3:165
#, no-wrap
msgid "Input presentation format for inet_net_pton()"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_net_pton.3:169
msgid ""
"The network number may be specified either as a hexadecimal value or in "
"dotted-decimal notation."
msgstr ""

#.  If the hexadecimal string is short, the remaining nibbles are zeroed.
#. type: Plain text
#: build/C/man3/inet_net_pton.3:174
msgid ""
"Hexadecimal values are indicated by an initial \"0x\" or \"0X\".  The "
"hexadecimal digits populate the nibbles (half octets) of the network number "
"from left to right in network byte order."
msgstr ""

#. type: Plain text
#: build/C/man3/inet_net_pton.3:178
msgid ""
"In dotted-decimal notation, up to four octets are specified, as decimal "
"numbers separated by dots.  Thus, any of the following forms are accepted:"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_net_pton.3:183
#, no-wrap
msgid ""
"    a.b.c.d\n"
"    a.b.c\n"
"    a.b\n"
"    a\n"
msgstr ""

#.  Reading other man pages, some other implementations treat
#.  	'c' in a.b.c as a 16-bit number that populates right-most two bytes
#.      'b' in a.b as a 24-bit number that populates right-most three bytes
#. type: Plain text
#: build/C/man3/inet_net_pton.3:191
msgid ""
"Each part is a number in the range 0 to 255 that populates one byte of the "
"resulting network number, going from left to right, in network-byte (big "
"endian) order.  Where a part is omitted, the resulting byte in the network "
"number is zero."
msgstr ""

#. type: Plain text
#: build/C/man3/inet_net_pton.3:196
msgid ""
"For either hexadecimal or dotted-decimal format, the network number can "
"optionally be followed by a slash and a number in the range 0 to 32, which "
"specifies the size of the network number in bits."
msgstr ""

#. type: SS
#: build/C/man3/inet_net_pton.3:196
#, no-wrap
msgid "Return value of inet_net_pton()"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_net_pton.3:206
msgid ""
"The return value of B<inet_net_pton>()  is the number of bits in the network "
"number field.  If the input presentation string terminates with a slash and "
"an explicit size value, then that size becomes the return value of "
"B<inet_net_pton>().  Otherwise, the return value, I<bits>, is inferred as "
"follows:"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_net_pton.3:212
msgid ""
"If the most significant byte of the network number is greater than or equal "
"to 240, then I<bits> is 32."
msgstr ""

#. type: Plain text
#: build/C/man3/inet_net_pton.3:219
msgid ""
"Otherwise, if the most significant byte of the network number is greater "
"than or equal to 224, then I<bits> is 4."
msgstr ""

#. type: Plain text
#: build/C/man3/inet_net_pton.3:226
msgid ""
"Otherwise, if the most significant byte of the network number is greater "
"than or equal to 192, then I<bits> is 24."
msgstr ""

#. type: Plain text
#: build/C/man3/inet_net_pton.3:233
msgid ""
"Otherwise, if the most significant byte of the network number is greater "
"than or equal to 128, then I<bits> is 16."
msgstr ""

#. type: Plain text
#: build/C/man3/inet_net_pton.3:237
msgid "Otherwise, I<bits> is 8."
msgstr ""

#. type: Plain text
#: build/C/man3/inet_net_pton.3:246
msgid ""
"If the resulting I<bits> value from the above steps is greater than or equal "
"to 8, but the number of octets specified in the network number exceed "
"I<bits/8>, then I<bits> is set to 8 times the number of octets actually "
"specified."
msgstr ""

#. type: Plain text
#: build/C/man3/inet_net_pton.3:260
msgid ""
"The program below demonstrates the use of B<inet_net_pton>()  and "
"B<inet_net_ntop>().  It uses B<inet_net_pton>()  to convert the presentation "
"format network address provided in its first command-line argument to binary "
"form, displays the return value from B<inet_net_pton>().  It then uses "
"B<inet_net_ntop>()  to convert the binary form back to presentation format, "
"and displays the resulting string."
msgstr ""

#. type: Plain text
#: build/C/man3/inet_net_pton.3:274
msgid ""
"In order to demonstrate that B<inet_net_pton>()  may not write to all bytes "
"of its I<netp> argument, the program allows an optional second command-line "
"argument, a number used to initialize the buffer before B<inet_net_pton>()  "
"is called.  As its final line of output, the program displays all of the "
"bytes of the buffer returned by B<inet_net_pton>()  allowing the user to see "
"which bytes have not been touched by B<inet_net_pton>()."
msgstr ""

#. type: Plain text
#: build/C/man3/inet_net_pton.3:278
msgid ""
"An example run, showing that B<inet_net_pton>()  infers the number of bits "
"in the network number:"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_net_pton.3:285
#, no-wrap
msgid ""
"$ B<./a.out 193.168>\n"
"inet_net_pton() returned: 24\n"
"inet_net_ntop() yielded:  193.168.0/24\n"
"Raw address:              c1a80000\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_net_pton.3:291
msgid ""
"Demonstrate that B<inet_net_pton>()  does not zero out unused bytes in its "
"result buffer:"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_net_pton.3:298
#, no-wrap
msgid ""
"$ B<./a.out 193.168 0xffffffff>\n"
"inet_net_pton() returned: 24\n"
"inet_net_ntop() yielded:  193.168.0/24\n"
"Raw address:              c1a800ff\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_net_pton.3:306
msgid ""
"Demonstrate that B<inet_net_pton>()  will widen the inferred size of the "
"network number, if the supplied number of bytes in the presentation string "
"exceeds the inferred value:"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_net_pton.3:313
#, no-wrap
msgid ""
"$ B<./a.out 193.168.1.128>\n"
"inet_net_pton() returned: 32\n"
"inet_net_ntop() yielded:  193.168.1.128/32\n"
"Raw address:              c1a80180\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_net_pton.3:321
msgid ""
"Explicitly specifying the size of the network number overrides any inference "
"about its size (but any extra bytes that are explicitly specified will still "
"be used by B<inet_net_pton>(): to populate the result buffer):"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_net_pton.3:328
#, no-wrap
msgid ""
"$ B<./a.out 193.168.1.128/24>\n"
"inet_net_pton() returned: 24\n"
"inet_net_ntop() yielded:  193.168.1/24\n"
"Raw address:              c1a80180\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_net_pton.3:333
#, no-wrap
msgid "/* Link with \"-lresolv\" */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_net_pton.3:337
#, no-wrap
msgid ""
"#include E<lt>arpa/inet.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_net_pton.3:340
#, no-wrap
msgid ""
"#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                        } while (0)\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_net_pton.3:347
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char buf[100];\n"
"    struct in_addr addr;\n"
"    int bits;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_net_pton.3:354
#, no-wrap
msgid ""
"    if (argc E<lt> 2) {\n"
"        fprintf(stderr,\n"
"                \"Usage: %s presentation-form [addr-init-value]\\en\",\n"
"                argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_net_pton.3:360
#, no-wrap
msgid ""
"    /* If argv[2] is supplied (a numeric value), use it to initialize\n"
"       the output buffer given to inet_net_pton(), so that we can see\n"
"       that inet_net_pton() initializes only those bytes needed for\n"
"       the network number. If argv[2] is not supplied, then initialize\n"
"       the buffer to zero (as is recommended practice). */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_net_pton.3:362
#, no-wrap
msgid "    addr.s_addr = (argc E<gt> 2) ? strtod(argv[2], NULL) : 0;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_net_pton.3:364
#, no-wrap
msgid "    /* Convert presentation network number in argv[1] to binary */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_net_pton.3:368
#, no-wrap
msgid ""
"    bits = inet_net_pton(AF_INET, argv[1], &addr, sizeof(addr));\n"
"    if (bits == -1)\n"
"        errExit(\"inet_net_ntop\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_net_pton.3:370
#, no-wrap
msgid "    printf(\"inet_net_pton() returned: %d\\en\", bits);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_net_pton.3:373
#, no-wrap
msgid ""
"    /* Convert binary format back to presentation, using \\(aqbits\\(aq\n"
"       returned by inet_net_pton() */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_net_pton.3:376
#, no-wrap
msgid ""
"    if (inet_net_ntop(AF_INET, &addr, bits, buf, sizeof(buf)) == NULL)\n"
"        errExit(\"inet_net_ntop\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_net_pton.3:378
#, no-wrap
msgid "    printf(\"inet_net_ntop() yielded:  %s\\en\", buf);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_net_pton.3:383
#, no-wrap
msgid ""
"    /* Display \\(aqaddr\\(aq in raw form (in network byte order), so we "
"can\n"
"       see bytes not displayed by inet_net_ntop(); some of those bytes\n"
"       may not have been touched by inet_net_ntop(), and so will still\n"
"       have any initial value that was specified in argv[2]. */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_net_pton.3:385
#, no-wrap
msgid "    printf(\"Raw address:              %x\\en\", htonl(addr.s_addr));\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_net_pton.3:392
msgid "B<inet>(3), B<networks>(5)"
msgstr ""

#. type: TH
#: build/C/man3/inet_ntop.3:26
#, no-wrap
msgid "INET_NTOP"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_ntop.3:29
msgid "inet_ntop - convert IPv4 and IPv6 addresses from binary to text form"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_ntop.3:35
#, no-wrap
msgid ""
"B<const char *inet_ntop(int >I<af>B<, const void *>I<src>B<,>\n"
"B<                      char *>I<dst>B<, socklen_t >I<size>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_ntop.3:48
msgid ""
"This function converts the network address structure I<src> in the I<af> "
"address family into a character string.  The resulting string is copied to "
"the buffer pointed to by I<dst>, which must be a non-null pointer.  The "
"caller specifies the number of bytes available in this buffer in the "
"argument I<size>."
msgstr ""

#. type: Plain text
#: build/C/man3/inet_ntop.3:57
msgid ""
"B<inet_ntop>()  extends the B<inet_ntoa>(3)  function to support multiple "
"address families, B<inet_ntoa>(3)  is now considered to be deprecated in "
"favor of B<inet_ntop>().  The following address families are currently "
"supported:"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_ntop.3:70
msgid ""
"I<src> points to a I<struct in_addr> (in network byte order)  which is "
"converted to an IPv4 network address in the dotted-decimal format, "
"\"I<ddd.ddd.ddd.ddd>\".  The buffer I<dst> must be at least "
"B<INET_ADDRSTRLEN> bytes long."
msgstr ""

#. type: Plain text
#: build/C/man3/inet_ntop.3:83
msgid ""
"I<src> points to a I<struct in6_addr> (in network byte order)  which is "
"converted to a representation of this address in the most appropriate IPv6 "
"network address format for this address.  The buffer I<dst> must be at least "
"B<INET6_ADDRSTRLEN> bytes long."
msgstr ""

#. type: Plain text
#: build/C/man3/inet_ntop.3:91
msgid ""
"On success, B<inet_ntop>()  returns a non-null pointer to I<dst>.  NULL is "
"returned if there was an error, with I<errno> set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man3/inet_ntop.3:96
msgid "I<af> was not a valid address family."
msgstr ""

#. type: TP
#: build/C/man3/inet_ntop.3:96
#, no-wrap
msgid "B<ENOSPC>"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_ntop.3:100
msgid "The converted address string would exceed the size given by I<size>."
msgstr ""

#. type: tbl table
#: build/C/man3/inet_ntop.3:110
#, no-wrap
msgid "B<inet_ntop>()"
msgstr ""

#.  2.1.3: size_t, 2.1.91: socklen_t
#. type: Plain text
#: build/C/man3/inet_ntop.3:125
msgid ""
"POSIX.1-2001, POSIX.1-2008.  Note that RFC\\ 2553 defines a prototype where "
"the last argument I<size> is of type I<size_t>.  Many systems follow RFC\\ "
"2553.  Glibc 2.0 and 2.1 have I<size_t>, but 2.2 and later have "
"I<socklen_t>."
msgstr ""

#. type: Plain text
#: build/C/man3/inet_ntop.3:128
msgid "B<AF_INET6> converts IPv4-mapped IPv6 addresses into an IPv6 format."
msgstr ""

#. type: Plain text
#: build/C/man3/inet_ntop.3:131
msgid "See B<inet_pton>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/inet_ntop.3:135
msgid "B<getnameinfo>(3), B<inet>(3), B<inet_pton>(3)"
msgstr ""

#. type: TH
#: build/C/man3/inet_pton.3:27
#, no-wrap
msgid "INET_PTON"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_pton.3:30
msgid "inet_pton - convert IPv4 and IPv6 addresses from text to binary form"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_pton.3:35
#, no-wrap
msgid "B<int inet_pton(int >I<af>B<, const char *>I<src>B<, void *>I<dst>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_pton.3:53
msgid ""
"This function converts the character string I<src> into a network address "
"structure in the I<af> address family, then copies the network address "
"structure to I<dst>.  The I<af> argument must be either B<AF_INET> or "
"B<AF_INET6>.  I<dst> is written in network byte order."
msgstr ""

#. type: Plain text
#: build/C/man3/inet_pton.3:55
msgid "The following address families are currently supported:"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_pton.3:69
msgid ""
"I<src> points to a character string containing an IPv4 network address in "
"dotted-decimal format, \"I<ddd.ddd.ddd.ddd>\", where I<ddd> is a decimal "
"number of up to three digits in the range 0 to 255.  The address is "
"converted to a I<struct in_addr> and copied to I<dst>, which must be "
"I<sizeof(struct in_addr)> (4) bytes (32 bits) long."
msgstr ""

#. type: Plain text
#: build/C/man3/inet_pton.3:81
msgid ""
"I<src> points to a character string containing an IPv6 network address.  The "
"address is converted to a I<struct in6_addr> and copied to I<dst>, which "
"must be I<sizeof(struct in6_addr)> (16) bytes (128 bits) long.  The allowed "
"formats for IPv6 addresses follow these rules:"
msgstr ""

#. type: IP
#: build/C/man3/inet_pton.3:82 build/C/man7/unix.7:595
#, no-wrap
msgid "1."
msgstr ""

#. type: Plain text
#: build/C/man3/inet_pton.3:89
msgid ""
"The preferred format is I<x:x:x:x:x:x:x:x>.  This form consists of eight "
"hexadecimal numbers, each of which expresses a 16-bit value (i.e., each I<x> "
"can be up to 4 hex digits)."
msgstr ""

#. type: IP
#: build/C/man3/inet_pton.3:89 build/C/man7/unix.7:598
#, no-wrap
msgid "2."
msgstr ""

#. type: Plain text
#: build/C/man3/inet_pton.3:102
msgid ""
"A series of contiguous zero values in the preferred format can be "
"abbreviated to I<::>.  Only one instance of I<::> can occur in an address.  "
"For example, the loopback address I<0:0:0:0:0:0:0:1> can be abbreviated as "
"I<::1>.  The wildcard address, consisting of all zeros, can be written as "
"I<::>."
msgstr ""

#. type: IP
#: build/C/man3/inet_pton.3:102 build/C/man7/unix.7:601
#, no-wrap
msgid "3."
msgstr ""

#. type: Plain text
#: build/C/man3/inet_pton.3:115
msgid ""
"An alternate format is useful for expressing IPv4-mapped IPv6 addresses.  "
"This form is written as I<x:x:x:x:x:x:d.d.d.d>, where the six leading I<x>s "
"are hexadecimal values that define the six most-significant 16-bit pieces of "
"the address (i.e., 96 bits), and the I<d>s express a value in dotted-decimal "
"notation that defines the least significant 32 bits of the address.  An "
"example of such an address is I<::FFFF:204.152.189.116>."
msgstr ""

#. type: Plain text
#: build/C/man3/inet_pton.3:118
msgid "See RFC 2373 for further details on the representation of IPv6 addresses."
msgstr ""

#. type: Plain text
#: build/C/man3/inet_pton.3:131
msgid ""
"B<inet_pton>()  returns 1 on success (network address was successfully "
"converted).  0 is returned if I<src> does not contain a character string "
"representing a valid network address in the specified address family.  If "
"I<af> does not contain a valid address family, -1 is returned and I<errno> "
"is set to B<EAFNOSUPPORT>."
msgstr ""

#. type: tbl table
#: build/C/man3/inet_pton.3:141
#, no-wrap
msgid "B<inet_pton>()"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_pton.3:164
msgid ""
"Unlike B<inet_aton>(3)  and B<inet_addr>(3), B<inet_pton>()  supports IPv6 "
"addresses.  On the other hand, B<inet_pton>()  accepts only IPv4 addresses "
"in dotted-decimal notation, whereas B<inet_aton>(3)  and B<inet_addr>(3)  "
"allow the more general numbers-and-dots notation (hexadecimal and octal "
"number formats, and formats that don't require all four bytes to be "
"explicitly written).  For an interface that handles both IPv6 addresses, and "
"IPv4 addresses in numbers-and-dots notation, see B<getaddrinfo>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/inet_pton.3:170
msgid ""
"B<AF_INET6> does not recognize IPv4 addresses.  An explicit IPv4-mapped IPv6 "
"address must be supplied in I<src> instead."
msgstr ""

#. type: Plain text
#: build/C/man3/inet_pton.3:176
msgid ""
"The program below demonstrates the use of B<inet_pton>()  and "
"B<inet_ntop>(3).  Here are some example runs:"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_pton.3:185
#, no-wrap
msgid ""
"$B< ./a.out i6 0:0:0:0:0:0:0:0>\n"
"::\n"
"$B< ./a.out i6 1:0:0:0:0:0:0:8>\n"
"1::8\n"
"$B< ./a.out i6 0:0:0:0:0:FFFF:204.152.189.116>\n"
"::ffff:204.152.189.116\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_pton.3:194
#, no-wrap
msgid ""
"#include E<lt>arpa/inet.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_pton.3:201
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    unsigned char buf[sizeof(struct in6_addr)];\n"
"    int domain, s;\n"
"    char str[INET6_ADDRSTRLEN];\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_pton.3:206
#, no-wrap
msgid ""
"    if (argc != 3) {\n"
"        fprintf(stderr, \"Usage: %s {i4|i6|E<lt>numE<gt>} string\\en\", "
"argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_pton.3:209
#, no-wrap
msgid ""
"    domain = (strcmp(argv[1], \"i4\") == 0) ? AF_INET :\n"
"             (strcmp(argv[1], \"i6\") == 0) ? AF_INET6 : atoi(argv[1]);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_pton.3:218
#, no-wrap
msgid ""
"    s = inet_pton(domain, argv[2], buf);\n"
"    if (s E<lt>= 0) {\n"
"        if (s == 0)\n"
"            fprintf(stderr, \"Not in presentation format\");\n"
"        else\n"
"            perror(\"inet_pton\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_pton.3:223
#, no-wrap
msgid ""
"    if (inet_ntop(domain, buf, str, INET6_ADDRSTRLEN) == NULL) {\n"
"        perror(\"inet_ntop\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_pton.3:225
#, no-wrap
msgid "    printf(\"%s\\en\", str);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_pton.3:233
msgid "B<getaddrinfo>(3), B<inet>(3), B<inet_ntop>(3)"
msgstr ""

#. type: TH
#: build/C/man7/ip.7:42
#, no-wrap
msgid "IP"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:45
msgid "ip - Linux IPv4 protocol implementation"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:51 build/C/man7/ipv6.7:93 build/C/man7/raw.7:19 build/C/man7/tcp.7:103 build/C/man7/udp.7:19
msgid "B<#include E<lt>netinet/in.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:53
msgid "B<#include E<lt>netinet/ip.hE<gt> >/* superset of previous */"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:55
msgid "I<tcp_socket>B< = socket(AF_INET, SOCK_STREAM, 0);>"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:57
msgid "I<udp_socket>B< = socket(AF_INET, SOCK_DGRAM, 0);>"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:59
msgid "I<raw_socket>B< = socket(AF_INET, SOCK_RAW, >I<protocol>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:65
msgid ""
"Linux implements the Internet Protocol, version 4, described in RFC\\ 791 "
"and RFC\\ 1122.  B<ip> contains a level 2 multicasting implementation "
"conforming to RFC\\ 1112.  It also contains an IP router including a packet "
"filter."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:69
msgid ""
"The programming interface is BSD-sockets compatible.  For more information "
"on sockets, see B<socket>(7)."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:72
msgid "An IP socket is created using B<socket>(2):"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:74
#, no-wrap
msgid "    socket(AF_INET, socket_type, protocol);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:84
msgid ""
"Valid socket types include B<SOCK_STREAM> to open a stream socket, "
"B<SOCK_DGRAM> to open a datagram socket, and B<SOCK_RAW> to open a B<raw>(7)  "
"socket to access the IP protocol directly."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:90
msgid ""
"I<protocol> is the IP protocol in the IP header to be received or sent.  "
"Valid values for I<protocol> include:"
msgstr ""

#. type: IP
#: build/C/man7/ip.7:90 build/C/man7/ip.7:96 build/C/man7/ip.7:102 build/C/man7/ip.7:107
#, no-wrap
msgid "\\(bu"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:96
msgid "0 and B<IPPROTO_TCP> for B<tcp>(7)  stream sockets;"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:102
msgid "0 and B<IPPROTO_UDP> for B<udp>(7)  datagram sockets;"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:107
msgid "B<IPPROTO_SCTP> for B<sctp>(7)  stream sockets; and"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:112
msgid "B<IPPROTO_UDPLITE> for B<udplite>(7)  datagram sockets."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:117
msgid ""
"For B<SOCK_RAW> you may specify a valid IANA IP protocol defined in RFC\\ "
"1700 assigned numbers."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:139
msgid ""
"When a process wants to receive new incoming packets or connections, it "
"should bind a socket to a local interface address using B<bind>(2).  In this "
"case, only one IP socket may be bound to any given local (address, port) "
"pair.  When B<INADDR_ANY> is specified in the bind call, the socket will be "
"bound to I<all> local interfaces.  When B<listen>(2)  is called on an "
"unbound socket, the socket is automatically bound to a random free port with "
"the local address set to B<INADDR_ANY>.  When B<connect>(2)  is called on an "
"unbound socket, the socket is automatically bound to a random free port or "
"to a usable shared port with the local address set to B<INADDR_ANY>."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:145
msgid ""
"A TCP local socket address that has been bound is unavailable for some time "
"after closing, unless the B<SO_REUSEADDR> flag has been set.  Care should be "
"taken when using this flag as it makes TCP less reliable."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:156
msgid ""
"An IP socket address is defined as a combination of an IP interface address "
"and a 16-bit port number.  The basic IP protocol does not supply port "
"numbers, they are implemented by higher level protocols like B<udp>(7)  and "
"B<tcp>(7).  On raw sockets I<sin_port> is set to the IP protocol."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:164
#, no-wrap
msgid ""
"struct sockaddr_in {\n"
"    sa_family_t    sin_family; /* address family: AF_INET */\n"
"    in_port_t      sin_port;   /* port in network byte order */\n"
"    struct in_addr sin_addr;   /* internet address */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:169
#, no-wrap
msgid ""
"/* Internet address. */\n"
"struct in_addr {\n"
"    uint32_t       s_addr;     /* address in network byte order */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:195
msgid ""
"I<sin_family> is always set to B<AF_INET>.  This is required; in Linux 2.2 "
"most networking functions return B<EINVAL> when this setting is missing.  "
"I<sin_port> contains the port in network byte order.  The port numbers below "
"1024 are called I<privileged ports> (or sometimes: I<reserved ports>).  Only "
"a privileged process (on Linux: a process that has the "
"B<CAP_NET_BIND_SERVICE> capability in the user namespace governing its "
"network namespace) may B<bind>(2)  to these sockets.  Note that the raw IPv4 "
"protocol as such has no concept of a port, they are implemented only by "
"higher protocols like B<tcp>(7)  and B<udp>(7)."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:217
msgid ""
"I<sin_addr> is the IP host address.  The I<s_addr> member of I<struct "
"in_addr> contains the host interface address in network byte order.  "
"I<in_addr> should be assigned one of the B<INADDR_*> values (e.g., "
"B<INADDR_LOOPBACK>)  using B<htonl>(3)  or set using the B<inet_aton>(3), "
"B<inet_addr>(3), B<inet_makeaddr>(3)  library functions or directly with the "
"name resolver (see B<gethostbyname>(3))."
msgstr ""

#.  Leave a loophole for XTP @)
#. type: Plain text
#: build/C/man7/ip.7:229
msgid ""
"IPv4 addresses are divided into unicast, broadcast, and multicast "
"addresses.  Unicast addresses specify a single interface of a host, "
"broadcast addresses specify all hosts on a network, and multicast addresses "
"address all hosts in a multicast group.  Datagrams to broadcast addresses "
"can be sent or received only when the B<SO_BROADCAST> socket flag is set.  "
"In the current implementation, connection-oriented sockets are allowed to "
"use only unicast addresses."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:237
msgid ""
"Note that the address and the port are always stored in network byte order.  "
"In particular, this means that you need to call B<htons>(3)  on the number "
"that is assigned to a port.  All address/port manipulation functions in the "
"standard library work in network byte order."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:250
msgid ""
"There are several special addresses: B<INADDR_LOOPBACK> (127.0.0.1)  always "
"refers to the local host via the loopback device; B<INADDR_ANY> (0.0.0.0)  "
"means any address for binding; B<INADDR_BROADCAST> (255.255.255.255)  means "
"any host and has the same effect on bind as B<INADDR_ANY> for historical "
"reasons."
msgstr ""

#.  or SOL_IP on Linux
#. type: Plain text
#: build/C/man7/ip.7:259
msgid ""
"IP supports some protocol-specific socket options that can be set with "
"B<setsockopt>(2)  and read with B<getsockopt>(2).  The socket option level "
"for IP is B<IPPROTO_IP>.  A boolean integer flag is zero when it is false, "
"otherwise true."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:266
msgid ""
"When an invalid socket option is specified, B<getsockopt>(2)  and "
"B<setsockopt>(2)  fail with the error B<ENOPROTOOPT>."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:266
#, no-wrap
msgid "B<IP_ADD_MEMBERSHIP> (since Linux 1.2)"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:272
msgid "Join a multicast group.  Argument is an I<ip_mreqn> structure."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:282
#, no-wrap
msgid ""
"struct ip_mreqn {\n"
"    struct in_addr imr_multiaddr; /* IP multicast group\n"
"                                     address */\n"
"    struct in_addr imr_address;   /* IP address of local\n"
"                                     interface */\n"
"    int            imr_ifindex;   /* interface index */\n"
"};\n"
msgstr ""

#.  (i.e., within the 224.0.0.0-239.255.255.255 range)
#. type: Plain text
#: build/C/man7/ip.7:303
msgid ""
"I<imr_multiaddr> contains the address of the multicast group the application "
"wants to join or leave.  It must be a valid multicast address (or "
"B<setsockopt>(2)  fails with the error B<EINVAL>).  I<imr_address> is the "
"address of the local interface with which the system should join the "
"multicast group; if it is equal to B<INADDR_ANY>, an appropriate interface "
"is chosen by the system.  I<imr_ifindex> is the interface index of the "
"interface that should join/leave the I<imr_multiaddr> group, or 0 to "
"indicate any interface."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:318
msgid ""
"The I<ip_mreqn> structure is available only since Linux 2.2.  For "
"compatibility, the old I<ip_mreq> structure (present since Linux 1.2) is "
"still supported; it differs from I<ip_mreqn> only by not including the "
"I<imr_ifindex> field.  (The kernel determines which structure is being "
"passed based on the size passed in I<optlen>.)"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:323
msgid "B<IP_ADD_MEMBERSHIP> is valid only for B<setsockopt>(2)."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:323
#, no-wrap
msgid "B<IP_ADD_SOURCE_MEMBERSHIP> (since Linux 2.4.22 / 2.5.68)"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:330
msgid ""
"Join a multicast group and allow receiving data only from a specified "
"source.  Argument is an I<ip_mreq_source> structure."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:341
#, no-wrap
msgid ""
"struct ip_mreq_source {\n"
"    struct in_addr imr_multiaddr;  /* IP multicast group\n"
"                                      address */\n"
"    struct in_addr imr_interface;  /* IP address of local\n"
"                                      interface */\n"
"    struct in_addr imr_sourceaddr; /* IP address of\n"
"                                      multicast source */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:362
msgid ""
"The I<ip_mreq_source> structure is similar to I<ip_mreqn> described under "
"B<IP_ADD_MEMBERSHIP>.  The I<imr_multiaddr> field contains the address of "
"the multicast group the application wants to join or leave.  The "
"I<imr_interface> field is the address of the local interface with which the "
"system should join the multicast group.  Finally, the I<imr_sourceaddr> "
"field contains the address of the source the application wants to receive "
"data from."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:365
msgid ""
"This option can be used multiple times to allow receiving data from more "
"than one source."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:365
#, no-wrap
msgid "B<IP_BIND_ADDRESS_NO_PORT> (since Linux 4.2)"
msgstr ""

#.  commit 90c337da1524863838658078ec34241f45d8394d
#. type: Plain text
#: build/C/man7/ip.7:375
msgid ""
"Inform the kernel to not reserve an ephemeral port when using B<bind>(2)  "
"with a port number of 0.  The port will later be automatically chosen at "
"B<connect>(2)  time, in a way that allows sharing a source port as long as "
"the 4-tuple is unique."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:375
#, no-wrap
msgid "B<IP_BLOCK_SOURCE> (since Linux 2.4.22 / 2.5.68)"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:383
msgid ""
"Stop receiving multicast data from a specific source in a given group.  This "
"is valid only after the application has subscribed to the multicast group "
"using either B<IP_ADD_MEMBERSHIP> or B<IP_ADD_SOURCE_MEMBERSHIP>."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:388 build/C/man7/ip.7:410 build/C/man7/ip.7:1016
msgid ""
"Argument is an I<ip_mreq_source> structure as described under "
"B<IP_ADD_SOURCE_MEMBERSHIP>."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:388
#, no-wrap
msgid "B<IP_DROP_MEMBERSHIP> (since Linux 1.2)"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:397
msgid ""
"Leave a multicast group.  Argument is an I<ip_mreqn> or I<ip_mreq> structure "
"similar to B<IP_ADD_MEMBERSHIP>."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:397
#, no-wrap
msgid "B<IP_DROP_SOURCE_MEMBERSHIP> (since Linux 2.4.22 / 2.5.68)"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:405
msgid ""
"Leave a source-specific group\\(emthat is, stop receiving data from a given "
"multicast group that come from a given source.  If the application has "
"subscribed to multiple sources within the same group, data from the "
"remaining sources will still be delivered.  To stop receiving data from all "
"sources at once, use B<IP_DROP_MEMBERSHIP>."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:410
#, no-wrap
msgid "B<IP_FREEBIND> (since Linux 2.4)"
msgstr ""

#.  Precisely: 2.4.0-test10
#. type: Plain text
#: build/C/man7/ip.7:423
msgid ""
"If enabled, this boolean option allows binding to an IP address that is "
"nonlocal or does not (yet) exist.  This permits listening on a socket, "
"without requiring the underlying network interface or the specified dynamic "
"IP address to be up at the time that the application is trying to bind to "
"it.  This option is the per-socket equivalent of the I<ip_nonlocal_bind> "
"I</proc> interface described below."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:423
#, no-wrap
msgid "B<IP_HDRINCL> (since Linux 2.0)"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:438
msgid ""
"If enabled, the user supplies an IP header in front of the user data.  Valid "
"only for B<SOCK_RAW> sockets; see B<raw>(7)  for more information.  When "
"this flag is enabled, the values set by B<IP_OPTIONS>, B<IP_TTL>, and "
"B<IP_TOS> are ignored."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:438
#, no-wrap
msgid "B<IP_MSFILTER> (since Linux 2.4.22 / 2.5.68)"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:444
msgid ""
"This option provides access to the advanced full-state filtering API.  "
"Argument is an I<ip_msfilter> structure."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:453
#, no-wrap
msgid ""
"struct ip_msfilter {\n"
"    struct in_addr imsf_multiaddr; /* IP multicast group\n"
"                                      address */\n"
"    struct in_addr imsf_interface; /* IP address of local\n"
"                                      interface */\n"
"    uint32_t       imsf_fmode;     /* Filter-mode */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:459
#, no-wrap
msgid ""
"    uint32_t       imsf_numsrc;    /* Number of sources in\n"
"                                      the following array */\n"
"    struct in_addr imsf_slist[1];  /* Array of source\n"
"                                      addresses */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:474
msgid ""
"There are two macros, B<MCAST_INCLUDE> and B<MCAST_EXCLUDE>, which can be "
"used to specify the filtering mode.  Additionally, the "
"B<IP_MSFILTER_SIZE>(n)  macro exists to determine how much memory is needed "
"to store I<ip_msfilter> structure with I<n> sources in the source list."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:477
msgid "For the full description of multicast source filtering refer to RFC 3376."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:477
#, no-wrap
msgid "B<IP_MTU> (since Linux 2.2)"
msgstr ""

#.  Precisely: 2.1.124
#. type: Plain text
#: build/C/man7/ip.7:482
msgid ""
"Retrieve the current known path MTU of the current socket.  Returns an "
"integer."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:487
msgid ""
"B<IP_MTU> is valid only for B<getsockopt>(2)  and can be employed only when "
"the socket has been connected."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:487
#, no-wrap
msgid "B<IP_MTU_DISCOVER> (since Linux 2.2)"
msgstr ""

#.  Precisely: 2.1.124
#. type: Plain text
#: build/C/man7/ip.7:508
msgid ""
"Set or receive the Path MTU Discovery setting for a socket.  When enabled, "
"Linux will perform Path MTU Discovery as defined in RFC\\ 1191 on "
"B<SOCK_STREAM> sockets.  For non-B<SOCK_STREAM> sockets, B<IP_PMTUDISC_DO> "
"forces the don't-fragment flag to be set on all outgoing packets.  It is the "
"user's responsibility to packetize the data in MTU-sized chunks and to do "
"the retransmits if necessary.  The kernel will reject (with B<EMSGSIZE>)  "
"datagrams that are bigger than the known path MTU.  B<IP_PMTUDISC_WANT> will "
"fragment a datagram if needed according to the path MTU, or will set the "
"don't-fragment flag otherwise."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:516
msgid ""
"The system-wide default can be toggled between B<IP_PMTUDISC_WANT> and "
"B<IP_PMTUDISC_DONT> by writing (respectively, zero and nonzero values) to "
"the I</proc/sys/net/ipv4/ip_no_pmtu_disc> file."
msgstr ""

#. type: tbl table
#: build/C/man7/ip.7:520
#, no-wrap
msgid "Path MTU discovery value"
msgstr ""

#. type: tbl table
#: build/C/man7/ip.7:520
#, no-wrap
msgid "Meaning"
msgstr ""

#. type: tbl table
#: build/C/man7/ip.7:521
#, no-wrap
msgid "IP_PMTUDISC_WANT"
msgstr ""

#. type: tbl table
#: build/C/man7/ip.7:521
#, no-wrap
msgid "Use per-route settings."
msgstr ""

#. type: tbl table
#: build/C/man7/ip.7:522
#, no-wrap
msgid "IP_PMTUDISC_DONT"
msgstr ""

#. type: tbl table
#: build/C/man7/ip.7:522
#, no-wrap
msgid "Never do Path MTU Discovery."
msgstr ""

#. type: tbl table
#: build/C/man7/ip.7:523
#, no-wrap
msgid "IP_PMTUDISC_DO"
msgstr ""

#. type: tbl table
#: build/C/man7/ip.7:523
#, no-wrap
msgid "Always do Path MTU Discovery."
msgstr ""

#. type: tbl table
#: build/C/man7/ip.7:524
#, no-wrap
msgid "IP_PMTUDISC_PROBE"
msgstr ""

#. type: tbl table
#: build/C/man7/ip.7:524
#, no-wrap
msgid "Set DF but ignore Path MTU."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:542
msgid ""
"When PMTU discovery is enabled, the kernel automatically keeps track of the "
"path MTU per destination host.  When it is connected to a specific peer with "
"B<connect>(2), the currently known path MTU can be retrieved conveniently "
"using the B<IP_MTU> socket option (e.g., after an B<EMSGSIZE> error "
"occurred).  The path MTU may change over time.  For connectionless sockets "
"with many destinations, the new MTU for a given destination can also be "
"accessed using the error queue (see B<IP_RECVERR>).  A new error will be "
"queued for every incoming MTU update."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:547
msgid ""
"While MTU discovery is in progress, initial packets from datagram sockets "
"may be dropped.  Applications using UDP should be aware of this and not take "
"it into account for their packet retransmit strategy."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:551
msgid ""
"To bootstrap the path MTU discovery process on unconnected sockets, it is "
"possible to start with a big datagram size (headers up to 64 kilobytes long) "
"and let it shrink by updates of the path MTU."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:560
msgid ""
"To get an initial estimate of the path MTU, connect a datagram socket to the "
"destination address using B<connect>(2)  and retrieve the MTU by calling "
"B<getsockopt>(2)  with the B<IP_MTU> option."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:572
msgid ""
"It is possible to implement RFC 4821 MTU probing with B<SOCK_DGRAM> or "
"B<SOCK_RAW> sockets by setting a value of B<IP_PMTUDISC_PROBE> (available "
"since Linux 2.6.22).  This is also particularly useful for diagnostic tools "
"such as B<tracepath>(8)  that wish to deliberately send probe packets larger "
"than the observed Path MTU."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:572
#, no-wrap
msgid "B<IP_MULTICAST_ALL> (since Linux 2.6.31)"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:586
msgid ""
"This option can be used to modify the delivery policy of multicast messages "
"to sockets bound to the wildcard B<INADDR_ANY> address.  The argument is a "
"boolean integer (defaults to 1).  If set to 1, the socket will receive "
"messages from all the groups that have been joined globally on the whole "
"system.  Otherwise, it will deliver messages only from the groups that have "
"been explicitly joined (for example via the B<IP_ADD_MEMBERSHIP> option) on "
"this particular socket."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:586
#, no-wrap
msgid "B<IP_MULTICAST_IF> (since Linux 1.2)"
msgstr ""

#.  net: IP_MULTICAST_IF setsockopt now recognizes struct mreq
#.  Commit: 3a084ddb4bf299a6e898a9a07c89f3917f0713f7
#. type: Plain text
#: build/C/man7/ip.7:611
msgid ""
"Set the local device for a multicast socket.  The argument for "
"B<setsockopt>(2)  is an I<ip_mreqn> or (since Linux 3.5)  I<ip_mreq> "
"structure similar to B<IP_ADD_MEMBERSHIP>, or an I<in_addr> structure.  (The "
"kernel determines which structure is being passed based on the size passed "
"in I<optlen>.)  For B<getsockopt>(2), the argument is an I<in_addr> "
"structure."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:611
#, no-wrap
msgid "B<IP_MULTICAST_LOOP> (since Linux 1.2)"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:615
msgid ""
"Set or read a boolean integer argument that determines whether sent "
"multicast packets should be looped back to the local sockets."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:615
#, no-wrap
msgid "B<IP_MULTICAST_TTL> (since Linux 1.2)"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:623
msgid ""
"Set or read the time-to-live value of outgoing multicast packets for this "
"socket.  It is very important for multicast packets to set the smallest TTL "
"possible.  The default is 1 which means that multicast packets don't leave "
"the local network unless the user program explicitly requests it.  Argument "
"is an integer."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:623
#, no-wrap
msgid "B<IP_NODEFRAG> (since Linux 2.6.36)"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:628
msgid ""
"If enabled (argument is nonzero), the reassembly of outgoing packets is "
"disabled in the netfilter layer.  The argument is an integer."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:632
msgid "This option is valid only for B<SOCK_RAW> sockets."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:632
#, no-wrap
msgid "B<IP_OPTIONS> (since Linux 2.0)"
msgstr ""

#.  Precisely: 1.3.30
#. type: Plain text
#: build/C/man7/ip.7:661
msgid ""
"Set or get the IP options to be sent with every packet from this socket.  "
"The arguments are a pointer to a memory buffer containing the options and "
"the option length.  The B<setsockopt>(2)  call sets the IP options "
"associated with a socket.  The maximum option size for IPv4 is 40 bytes.  "
"See RFC\\ 791 for the allowed options.  When the initial connection request "
"packet for a B<SOCK_STREAM> socket contains IP options, the IP options will "
"be set automatically to the options from the initial packet with routing "
"headers reversed.  Incoming packets are not allowed to change options after "
"the connection is established.  The processing of all incoming source "
"routing options is disabled by default and can be enabled by using the "
"I<accept_source_route> I</proc> interface.  Other options like timestamps "
"are still handled.  For datagram sockets, IP options can be set only by the "
"local user.  Calling B<getsockopt>(2)  with B<IP_OPTIONS> puts the current "
"IP options used for sending into the supplied buffer."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:661
#, no-wrap
msgid "B<IP_PASSSEC> (since Linux 2.6.17)"
msgstr ""

#.  commit 2c7946a7bf45ae86736ab3b43d0085e43947945c
#. type: Plain text
#: build/C/man7/ip.7:674
msgid ""
"If labeled IPSEC or NetLabel is configured on the sending and receiving "
"hosts, this option enables receiving of the security context of the peer "
"socket in an ancillary message of type B<SCM_SECURITY> retrieved using "
"B<recvmsg>(2).  This option is supported only for UDP sockets; for TCP or "
"SCTP sockets, see the description of the B<SO_PEERSEC> option below."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:680 build/C/man7/unix.7:302 build/C/man7/unix.7:314
msgid ""
"The value given as an argument to B<setsockopt>(2)  and returned as the "
"result of B<getsockopt>(2)  is an integer boolean flag."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:687
msgid ""
"The security context returned in the B<SCM_SECURITY> ancillary message is of "
"the same format as the one described under the B<SO_PEERSEC> option below."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:700
msgid ""
"Note: the reuse of the B<SCM_SECURITY> message type for the B<IP_PASSSEC> "
"socket option was likely a mistake, since other IP control messages use "
"their own numbering scheme in the IP namespace and often use the socket "
"option value as the message type.  There is no conflict currently since the "
"IP option with the same value as B<SCM_SECURITY> is B<IP_HDRINCL> and this "
"is never used for a control message type."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:700
#, no-wrap
msgid "B<IP_PKTINFO> (since Linux 2.2)"
msgstr ""

#.  Precisely: 2.1.68
#. type: Plain text
#: build/C/man7/ip.7:717
msgid ""
"Pass an B<IP_PKTINFO> ancillary message that contains a I<pktinfo> structure "
"that supplies some information about the incoming packet.  This works only "
"for datagram oriented sockets.  The argument is a flag that tells the socket "
"whether the B<IP_PKTINFO> message should be passed or not.  The message "
"itself can be sent/retrieved only as a control message with a packet using "
"B<recvmsg>(2)  or B<sendmsg>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:726
#, no-wrap
msgid ""
"struct in_pktinfo {\n"
"    unsigned int   ipi_ifindex;  /* Interface index */\n"
"    struct in_addr ipi_spec_dst; /* Local address */\n"
"    struct in_addr ipi_addr;     /* Header Destination\n"
"                                    address */\n"
"};\n"
msgstr ""

#.  This field is grossly misnamed
#. type: Plain text
#: build/C/man7/ip.7:750
msgid ""
"I<ipi_ifindex> is the unique index of the interface the packet was received "
"on.  I<ipi_spec_dst> is the local address of the packet and I<ipi_addr> is "
"the destination address in the packet header.  If B<IP_PKTINFO> is passed to "
"B<sendmsg>(2)  and I<ipi_spec_dst> is not zero, then it is used as the local "
"source address for the routing table lookup and for setting up IP source "
"route options.  When I<ipi_ifindex> is not zero, the primary local address "
"of the interface specified by the index overwrites I<ipi_spec_dst> for the "
"routing table lookup."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:750
#, no-wrap
msgid "B<IP_RECVERR> (since Linux 2.2)"
msgstr ""

#.  Precisely: 2.1.15
#.  or SOL_IP on Linux
#. type: Plain text
#: build/C/man7/ip.7:772
msgid ""
"Enable extended reliable error message passing.  When enabled on a datagram "
"socket, all generated errors will be queued in a per-socket error queue.  "
"When the user receives an error from a socket operation, the errors can be "
"received by calling B<recvmsg>(2)  with the B<MSG_ERRQUEUE> flag set.  The "
"I<sock_extended_err> structure describing the error will be passed in an "
"ancillary message with the type B<IP_RECVERR> and the level B<IPPROTO_IP>.  "
"This is useful for reliable error handling on unconnected sockets.  The "
"received data portion of the error queue contains the error packet."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:778
msgid "The B<IP_RECVERR> control message contains a I<sock_extended_err> structure:"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:785
#, no-wrap
msgid ""
"#define SO_EE_ORIGIN_NONE    0\n"
"#define SO_EE_ORIGIN_LOCAL   1\n"
"#define SO_EE_ORIGIN_ICMP    2\n"
"#define SO_EE_ORIGIN_ICMP6   3\n"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:796
#, no-wrap
msgid ""
"struct sock_extended_err {\n"
"    uint32_t ee_errno;   /* error number */\n"
"    uint8_t  ee_origin;  /* where the error originated */\n"
"    uint8_t  ee_type;    /* type */\n"
"    uint8_t  ee_code;    /* code */\n"
"    uint8_t  ee_pad;\n"
"    uint32_t ee_info;    /* additional information */\n"
"    uint32_t ee_data;    /* other data */\n"
"    /* More data may follow */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:798
#, no-wrap
msgid "struct sockaddr *SO_EE_OFFENDER(struct sock_extended_err *);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:821
msgid ""
"I<ee_errno> contains the I<errno> number of the queued error.  I<ee_origin> "
"is the origin code of where the error originated.  The other fields are "
"protocol-specific.  The macro B<SO_EE_OFFENDER> returns a pointer to the "
"address of the network object where the error originated from given a "
"pointer to the ancillary message.  If this address is not known, the "
"I<sa_family> member of the I<sockaddr> contains B<AF_UNSPEC> and the other "
"fields of the I<sockaddr> are undefined."
msgstr ""

#.  FIXME . Is it a good idea to document that? It is a dubious feature.
#.  On
#.  .B SOCK_STREAM
#.  sockets,
#.  .B IP_RECVERR
#.  has slightly different semantics. Instead of
#.  saving the errors for the next timeout, it passes all incoming
#.  errors immediately to the user.
#.  This might be useful for very short-lived TCP connections which
#.  need fast error handling. Use this option with care:
#.  it makes TCP unreliable
#.  by not allowing it to recover properly from routing
#.  shifts and other normal
#.  conditions and breaks the protocol specification.
#. type: Plain text
#: build/C/man7/ip.7:880
msgid ""
"IP uses the I<sock_extended_err> structure as follows: I<ee_origin> is set "
"to B<SO_EE_ORIGIN_ICMP> for errors received as an ICMP packet, or "
"B<SO_EE_ORIGIN_LOCAL> for locally generated errors.  Unknown values should "
"be ignored.  I<ee_type> and I<ee_code> are set from the type and code fields "
"of the ICMP header.  I<ee_info> contains the discovered MTU for B<EMSGSIZE> "
"errors.  The message also contains the I<sockaddr_in of the node> caused the "
"error, which can be accessed with the B<SO_EE_OFFENDER> macro.  The "
"I<sin_family> field of the B<SO_EE_OFFENDER> address is B<AF_UNSPEC> when "
"the source was unknown.  When the error originated from the network, all IP "
"options (B<IP_OPTIONS>, B<IP_TTL>, etc.) enabled on the socket and contained "
"in the error packet are passed as control messages.  The payload of the "
"packet causing the error is returned as normal payload.  Note that TCP has "
"no error queue; B<MSG_ERRQUEUE> is not permitted on B<SOCK_STREAM> sockets.  "
"B<IP_RECVERR> is valid for TCP, but all errors are returned by socket "
"function return or B<SO_ERROR> only."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:885
msgid ""
"For raw sockets, B<IP_RECVERR> enables passing of all received ICMP errors "
"to the application, otherwise errors are reported only on connected sockets"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:889
msgid ""
"It sets or retrieves an integer boolean flag.  B<IP_RECVERR> defaults to "
"off."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:889
#, no-wrap
msgid "B<IP_RECVOPTS> (since Linux 2.2)"
msgstr ""

#.  Precisely: 2.1.15
#. type: Plain text
#: build/C/man7/ip.7:900
msgid ""
"Pass all incoming IP options to the user in a B<IP_OPTIONS> control "
"message.  The routing header and other options are already filled in for the "
"local host.  Not supported for B<SOCK_STREAM> sockets."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:900
#, no-wrap
msgid "B<IP_RECVORIGDSTADDR> (since Linux 2.6.29)"
msgstr ""

#.  commit e8b2dfe9b4501ed0047459b2756ba26e5a940a69
#. type: Plain text
#: build/C/man7/ip.7:911
msgid ""
"This boolean option enables the B<IP_ORIGDSTADDR> ancillary message in "
"B<recvmsg>(2), in which the kernel returns the original destination address "
"of the datagram being received.  The ancillary message contains a I<struct "
"sockaddr_in>."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:911
#, no-wrap
msgid "B<IP_RECVTOS> (since Linux 2.2)"
msgstr ""

#.  Precisely: 2.1.68
#. type: Plain text
#: build/C/man7/ip.7:920
msgid ""
"If enabled, the B<IP_TOS> ancillary message is passed with incoming "
"packets.  It contains a byte which specifies the Type of Service/Precedence "
"field of the packet header.  Expects a boolean integer flag."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:920
#, no-wrap
msgid "B<IP_RECVTTL> (since Linux 2.2)"
msgstr ""

#.  Precisely: 2.1.68
#. type: Plain text
#: build/C/man7/ip.7:930
msgid ""
"When this flag is set, pass a B<IP_TTL> control message with the "
"time-to-live field of the received packet as a 32 bit integer.  Not "
"supported for B<SOCK_STREAM> sockets."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:930
#, no-wrap
msgid "B<IP_RETOPTS> (since Linux 2.2)"
msgstr ""

#.  Precisely: 2.1.15
#. type: Plain text
#: build/C/man7/ip.7:937
msgid ""
"Identical to B<IP_RECVOPTS>, but returns raw unprocessed options with "
"timestamp and route record options not filled in for this hop."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:937
#, no-wrap
msgid "B<IP_ROUTER_ALERT> (since Linux 2.2)"
msgstr ""

#.  Precisely: 2.1.68
#. type: Plain text
#: build/C/man7/ip.7:949
msgid ""
"Pass all to-be forwarded packets with the IP Router Alert option set to this "
"socket.  Valid only for raw sockets.  This is useful, for instance, for "
"user-space RSVP daemons.  The tapped packets are not forwarded by the "
"kernel; it is the user's responsibility to send them out again.  Socket "
"binding is ignored, such packets are filtered only by protocol.  Expects an "
"integer flag."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:949
#, no-wrap
msgid "B<IP_TOS> (since Linux 1.0)"
msgstr ""

#.  FIXME elaborate on this
#.  The priority can also be set in a protocol-independent way by the
#.  .RB ( SOL_SOCKET ", " SO_PRIORITY )
#.  socket option (see
#.  .BR socket (7)).
#. type: Plain text
#: build/C/man7/ip.7:978
msgid ""
"Set or receive the Type-Of-Service (TOS) field that is sent with every IP "
"packet originating from this socket.  It is used to prioritize packets on "
"the network.  TOS is a byte.  There are some standard TOS flags defined: "
"B<IPTOS_LOWDELAY> to minimize delays for interactive traffic, "
"B<IPTOS_THROUGHPUT> to optimize throughput, B<IPTOS_RELIABILITY> to optimize "
"for reliability, B<IPTOS_MINCOST> should be used for \"filler data\" where "
"slow transmission doesn't matter.  At most one of these TOS values can be "
"specified.  Other bits are invalid and shall be cleared.  Linux sends "
"B<IPTOS_LOWDELAY> datagrams first by default, but the exact behavior depends "
"on the configured queueing discipline.  Some high-priority levels may "
"require superuser privileges (the B<CAP_NET_ADMIN> capability)."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:978
#, no-wrap
msgid "B<IP_TRANSPARENT> (since Linux 2.6.24)"
msgstr ""

#.  commit f5715aea4564f233767ea1d944b2637a5fd7cd2e
#.      This patch introduces the IP_TRANSPARENT socket option: enabling that
#.      will make the IPv4 routing omit the non-local source address check on
#.      output. Setting IP_TRANSPARENT requires NET_ADMIN capability.
#.  http://lwn.net/Articles/252545/
#. type: Plain text
#: build/C/man7/ip.7:998
msgid ""
"Setting this boolean option enables transparent proxying on this socket.  "
"This socket option allows the calling application to bind to a nonlocal IP "
"address and operate both as a client and a server with the foreign address "
"as the local endpoint.  NOTE: this requires that routing be set up in a way "
"that packets going to the foreign address are routed through the TProxy box "
"(i.e., the system hosting the application that employs the B<IP_TRANSPARENT> "
"socket option).  Enabling this socket option requires superuser privileges "
"(the B<CAP_NET_ADMIN> capability)."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:1001
msgid ""
"TProxy redirection with the iptables TPROXY target also requires that this "
"option be set on the redirected socket."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:1001
#, no-wrap
msgid "B<IP_TTL> (since Linux 1.0)"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:1005
msgid ""
"Set or retrieve the current time-to-live field that is used in every packet "
"sent from this socket."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:1005
#, no-wrap
msgid "B<IP_UNBLOCK_SOURCE> (since Linux 2.4.22 / 2.5.68)"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:1011
msgid ""
"Unblock previously blocked multicast source.  Returns B<EADDRNOTAVAIL> when "
"given source is not being blocked."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:1016
#, no-wrap
msgid "B<SO_PEERSEC> (since Linux 2.6.17)"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:1025
msgid ""
"If labeled IPSEC or NetLabel is configured on both the sending and receiving "
"hosts, this read-only socket option returns the security context of the peer "
"socket connected to this socket.  By default, this will be the same as the "
"security context of the process that created the peer socket unless "
"overridden by the policy or by a process with the required permissions."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:1045 build/C/man7/unix.7:379
msgid ""
"The argument to B<getsockopt>(2)  is a pointer to a buffer of the specified "
"length in bytes into which the security context string will be copied.  If "
"the buffer length is less than the length of the security context string, "
"then B<getsockopt>(2)  returns -1, sets I<errno> to B<ERANGE>, and returns "
"the required length via I<optlen>.  The caller should allocate at least "
"B<NAME_MAX> bytes for the buffer initially, although this is not guaranteed "
"to be sufficient.  Resizing the buffer to the returned length and retrying "
"may be necessary."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:1054 build/C/man7/unix.7:388
msgid ""
"The security context string may include a terminating null character in the "
"returned length, but is not guaranteed to do so: a security context \"foo\" "
"might be represented as either {'f','o','o'} of length 3 or "
"{'f','o','o','\\e0'} of length 4, which are considered to be "
"interchangeable.  The string is printable, does not contain non-terminating "
"null characters, and is in an unspecified encoding (in particular, it is not "
"guaranteed to be ASCII or UTF-8)."
msgstr ""

#.  commit 2c7946a7bf45ae86736ab3b43d0085e43947945c
#.  commit d452930fd3b9031e59abfeddb2fa383f1403d61a
#. type: Plain text
#: build/C/man7/ip.7:1062
msgid ""
"The use of this option for sockets in the B<AF_INET> address family is "
"supported since Linux 2.6.17 for TCP sockets, and since Linux 4.17 for SCTP "
"sockets."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:1073
msgid ""
"For SELinux, NetLabel conveys only the MLS portion of the security context "
"of the peer across the wire, defaulting the rest of the security context to "
"the values defined in the policy for the netmsg initial security identifier "
"(SID).  However, NetLabel can be configured to pass full security contexts "
"over loopback.  Labeled IPSEC always passes full security contexts as part "
"of establishing the security association (SA) and looks them up based on the "
"association for each packet."
msgstr ""

#.  FIXME As at 2.6.12, 14 Jun 2005, the following are undocumented:
#.   ip_queue_maxlen
#.   ip_conntrack_max
#. type: Plain text
#: build/C/man7/ip.7:1089
msgid ""
"The IP protocol supports a set of I</proc> interfaces to configure some "
"global parameters.  The parameters can be accessed by reading or writing "
"files in the directory I</proc/sys/net/ipv4/>.  Interfaces described as "
"I<Boolean> take an integer value, with a nonzero value (\"true\") meaning "
"that the corresponding option is enabled, and a zero value (\"false\")  "
"meaning that the option is disabled."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:1089
#, no-wrap
msgid "I<ip_always_defrag> (Boolean; since Linux 2.2.13)"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:1095
msgid ""
"[New with kernel 2.2.13; in earlier kernel versions this feature was "
"controlled at compile time by the B<CONFIG_IP_ALWAYS_DEFRAG> option; this "
"option is not present in 2.4.x and later]"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:1102
msgid ""
"When this boolean flag is enabled (not equal 0), incoming fragments (parts "
"of IP packets that arose when some host between origin and destination "
"decided that the packets were too large and cut them into pieces) will be "
"reassembled (defragmented) before being processed, even if they are about to "
"be forwarded."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:1109
msgid ""
"Enable only if running either a firewall that is the sole link to your "
"network or a transparent proxy; never ever use it for a normal router or "
"host.  Otherwise, fragmented communication can be disturbed if the fragments "
"travel over different links.  Defragmentation also has a large memory and "
"CPU time cost."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:1113
msgid ""
"This is automagically turned on when masquerading or transparent proxying "
"are configured."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:1113
#, no-wrap
msgid "I<ip_autoconfig> (since Linux 2.2 to 2.6.17)"
msgstr ""

#.  Precisely: since 2.1.68
#.  FIXME document ip_autoconfig
#. type: Plain text
#: build/C/man7/ip.7:1119
msgid "Not documented."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:1119
#, no-wrap
msgid "I<ip_default_ttl> (integer; default: 64; since Linux 2.2)"
msgstr ""

#.  Precisely: 2.1.15
#. type: Plain text
#: build/C/man7/ip.7:1127
msgid ""
"Set the default time-to-live value of outgoing packets.  This can be changed "
"per socket with the B<IP_TTL> option."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:1127
#, no-wrap
msgid "I<ip_dynaddr> (Boolean; default: disabled; since Linux 2.0.31)"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:1134
msgid ""
"Enable dynamic socket address and masquerading entry rewriting on interface "
"address change.  This is useful for dialup interface with changing IP "
"addresses.  0 means no rewriting, 1 turns it on and 2 enables verbose mode."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:1134
#, no-wrap
msgid "I<ip_forward> (Boolean; default: disabled; since Linux 1.2)"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:1139
msgid ""
"Enable IP forwarding with a boolean flag.  IP forwarding can be also set on "
"a per-interface basis."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:1139
#, no-wrap
msgid "I<ip_local_port_range> (since Linux 2.2)"
msgstr ""

#.  Precisely: since 2.1.68
#. type: Plain text
#: build/C/man7/ip.7:1147
msgid ""
"This file contains two integers that define the default local port range "
"allocated to sockets that are not explicitly bound to a port number\\(emthat "
"is, the range used for I<ephemeral ports>.  An ephemeral port is allocated "
"to a socket in the following circumstances:"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:1151
msgid ""
"the port number in a socket address is specified as 0 when calling "
"B<bind>(2);"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:1154
msgid "B<listen>(2)  is called on a stream socket that was not previously bound;"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:1157
msgid "B<connect>(2)  was called on a socket that was not previously bound;"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:1160
msgid "B<sendto>(2)  is called on a datagram socket that was not previously bound."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:1167
msgid ""
"Allocation of ephemeral ports starts with the first number in "
"I<ip_local_port_range> and ends with the second number.  If the range of "
"ephemeral ports is exhausted, then the relevant system call returns an error "
"(but see BUGS)."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:1178
msgid ""
"Note that the port range in I<ip_local_port_range> should not conflict with "
"the ports used by masquerading (although the case is handled).  Also, "
"arbitrary choices may cause problems with some firewall packet filters that "
"make assumptions about the local ports in use.  The first number should be "
"at least greater than 1024, or better, greater than 4096, to avoid clashes "
"with well known ports and to minimize firewall problems."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:1178
#, no-wrap
msgid "I<ip_no_pmtu_disc> (Boolean; default: disabled; since Linux 2.2)"
msgstr ""

#.  Precisely: 2.1.15
#
#.  The following is from 2.6.12: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/ip.7:1190
msgid ""
"If enabled, don't do Path MTU Discovery for TCP sockets by default.  Path "
"MTU discovery may fail if misconfigured firewalls (that drop all ICMP "
"packets) or misconfigured interfaces (e.g., a point-to-point link where the "
"both ends don't agree on the MTU) are on the path.  It is better to fix the "
"broken routers on the path than to turn off Path MTU Discovery globally, "
"because not doing it incurs a high cost to the network."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:1190
#, no-wrap
msgid "I<ip_nonlocal_bind> (Boolean; default: disabled; since Linux 2.4)"
msgstr ""

#.  Precisely: patch-2.4.0-test10
#
#.  The following is from 2.6.12: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/ip.7:1199
msgid ""
"If set, allows processes to B<bind>(2)  to nonlocal IP addresses, which can "
"be quite useful, but may break some applications."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:1199
#, no-wrap
msgid "I<ip6frag_time> (integer; default: 30)"
msgstr ""

#
#.  The following is from 2.6.12: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/ip.7:1204
msgid "Time in seconds to keep an IPv6 fragment in memory."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:1204
#, no-wrap
msgid "I<ip6frag_secret_interval> (integer; default: 600)"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:1208
msgid ""
"Regeneration interval (in seconds) of the hash secret (or lifetime for the "
"hash secret) for IPv6 fragments."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:1208
#, no-wrap
msgid "I<ipfrag_high_thresh> (integer), I<ipfrag_low_thresh> (integer)"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:1215
msgid ""
"If the amount of queued IP fragments reaches I<ipfrag_high_thresh>, the "
"queue is pruned down to I<ipfrag_low_thresh>.  Contains an integer with the "
"number of bytes."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:1215
#, no-wrap
msgid "I<neigh/*>"
msgstr ""

#.  FIXME Document the conf/*/* interfaces
#
#.  FIXME Document the route/* interfaces
#. type: Plain text
#: build/C/man7/ip.7:1222
msgid "See B<arp>(7)."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:1227
msgid "All ioctls described in B<socket>(7)  apply to B<ip>."
msgstr ""

#.  FIXME Add a discussion of multicasting
#. type: Plain text
#: build/C/man7/ip.7:1231
msgid ""
"Ioctls to configure generic device parameters are described in "
"B<netdevice>(7)."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:1251
msgid ""
"The user tried to execute an operation without the necessary permissions.  "
"These include: sending a packet to a broadcast address without having the "
"B<SO_BROADCAST> flag set; sending a packet via a I<prohibit> route; "
"modifying firewall settings without superuser privileges (the "
"B<CAP_NET_ADMIN> capability); binding to a privileged port without superuser "
"privileges (the B<CAP_NET_BIND_SERVICE> capability)."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:1273
msgid ""
"No valid routing table entry matches the destination address.  This error "
"can be caused by an ICMP message from a remote router or for the local "
"routing table."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:1279
msgid ""
"Invalid argument passed.  For send operations this can be caused by sending "
"to a I<blackhole> route."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:1286
msgid "Datagram is bigger than an MTU on the path and it cannot be fragmented."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:1286
#, no-wrap
msgid "B<ENOBUFS>, B<ENOMEM>"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:1291
msgid ""
"Not enough free memory.  This often means that the memory allocation is "
"limited by the socket buffer limits, not by the system memory, but this is "
"not 100% consistent."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:1309
msgid ""
"User doesn't have permission to set high priority, change configuration, or "
"send signals to the requested process or group."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:1315
msgid "The socket is not configured or an unknown socket type was requested."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:1322
msgid ""
"Other errors may be generated by the overlaying protocols; see B<tcp>(7), "
"B<raw>(7), B<udp>(7), and B<socket>(7)."
msgstr ""

#.  IP_XFRM_POLICY is Linux-specific
#.  IP_IPSEC_POLICY is a nonstandard extension, also present on some BSDs
#. type: Plain text
#: build/C/man7/ip.7:1337
msgid ""
"B<IP_FREEBIND>, B<IP_MSFILTER>, B<IP_MTU>, B<IP_MTU_DISCOVER>, "
"B<IP_RECVORIGDSTADDR>, B<IP_PASSSEC>, B<IP_PKTINFO>, B<IP_RECVERR>, "
"B<IP_ROUTER_ALERT>, and B<IP_TRANSPARENT> are Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:1346
msgid ""
"Be very careful with the B<SO_BROADCAST> option - it is not privileged in "
"Linux.  It is easy to overload the network with careless broadcasts.  For "
"new application protocols it is better to use a multicast group instead of "
"broadcasting.  Broadcasting is discouraged."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:1356
msgid ""
"Some other BSD sockets implementations provide B<IP_RCVDSTADDR> and "
"B<IP_RECVIF> socket options to get the destination address and the interface "
"of received datagrams.  Linux has the more general B<IP_PKTINFO> for the "
"same task."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:1365
msgid ""
"Some BSD sockets implementations also provide an B<IP_RECVTTL> option, but "
"an ancillary message with type B<IP_RECVTTL> is passed with the incoming "
"packet.  This is different from the B<IP_TTL> option used in Linux."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:1371
msgid ""
"Using the B<SOL_IP> socket options level isn't portable; BSD-based stacks "
"use the B<IPPROTO_IP> level."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:1379
#, no-wrap
msgid ""
"B<INADDR_ANY>\n"
"(0.0.0.0) and\n"
"B<INADDR_BROADCAST>\n"
"(255.255.255.255) are byte-order-neutral.\n"
" This means\n"
"B<htonl>(3)\n"
"has no effect on them.\n"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:1392
msgid ""
"For compatibility with Linux 2.0, the obsolete B<socket(AF_INET, "
"SOCK_PACKET, >I<protocol>B<)> syntax is still supported to open a "
"B<packet>(7)  socket.  This is deprecated and should be replaced by "
"B<socket(AF_PACKET, SOCK_RAW, >I<protocol>B<)> instead.  The main difference "
"is the new I<sockaddr_ll> address structure for generic link layer "
"information instead of the old B<sockaddr_pkt>."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:1402
msgid ""
"The error used to diagnose exhaustion of the ephemeral port range differs "
"across the various system calls (B<connect>(2), B<bind>(2), B<listen>(2), "
"B<sendto>(2))  that can assign ephemeral ports."
msgstr ""

#.  .PP
#.  Some versions of glibc forget to declare
#.  .IR in_pktinfo .
#.  Workaround currently is to copy it into your program from this man page.
#. type: Plain text
#: build/C/man7/ip.7:1409
msgid ""
"The ioctls to configure IP-specific interface options and ARP tables are not "
"described."
msgstr ""

#.  .SH AUTHORS
#.  This man page was written by Andi Kleen.
#. type: Plain text
#: build/C/man7/ip.7:1419
msgid ""
"Receiving the original destination address with B<MSG_ERRQUEUE> in "
"I<msg_name> by B<recvmsg>(2)  does not work in some 2.2 kernels."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:1433
msgid ""
"B<recvmsg>(2), B<sendmsg>(2), B<byteorder>(3), B<capabilities>(7), "
"B<icmp>(7), B<ipv6>(7), B<netdevice>(7), B<netlink>(7), B<raw>(7), "
"B<socket>(7), B<tcp>(7), B<udp>(7), B<ip>(8)"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:1436 build/C/man7/tcp.7:1392 build/C/man7/udp.7:269
msgid "The kernel source file I<Documentation/networking/ip-sysctl.txt>."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:1440
msgid ""
"RFC\\ 791 for the original IP specification.  RFC\\ 1122 for the IPv4 host "
"requirements.  RFC\\ 1812 for the IPv4 router requirements."
msgstr ""

#. type: TH
#: build/C/man7/ipv6.7:86
#, no-wrap
msgid "IPV6"
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:89
msgid "ipv6 - Linux IPv6 protocol implementation"
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:95
msgid "I<tcp6_socket>B< = socket(AF_INET6, SOCK_STREAM, 0);>"
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:97
msgid "I<raw6_socket>B< = socket(AF_INET6, SOCK_RAW, >I<protocol>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:99
msgid "I<udp6_socket>B< = socket(AF_INET6, SOCK_DGRAM, >I<protocol>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:106
msgid ""
"Linux 2.2 optionally implements the Internet Protocol, version 6.  This man "
"page contains a description of the IPv6 basic API as implemented by the "
"Linux kernel and glibc 2.1.  The interface is based on the BSD sockets "
"interface; see B<socket>(7)."
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:111
msgid ""
"The IPv6 API aims to be mostly compatible with the IPv4 API (see B<ip>(7)).  "
"Only differences are described in this man page."
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:123
msgid ""
"To bind an B<AF_INET6> socket to any process, the local address should be "
"copied from the I<in6addr_any> variable which has I<in6_addr> type.  In "
"static initializations, B<IN6ADDR_ANY_INIT> may also be used, which expands "
"to a constant expression.  Both of them are in network byte order."
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:130
msgid ""
"The IPv6 loopback address (::1) is available in the global "
"I<in6addr_loopback> variable.  For initializations, B<IN6ADDR_LOOPBACK_INIT> "
"should be used."
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:137
msgid ""
"IPv4 connections can be handled with the v6 API by using the v4-mapped-on-v6 "
"address type; thus a program needs to support only this API type to support "
"both protocols.  This is handled transparently by the address handling "
"functions in the C library."
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:142
msgid ""
"IPv4 and IPv6 share the local port space.  When you get an IPv4 connection "
"or packet to an IPv6 socket, its source address will be mapped to v6 and it "
"will be mapped to v6."
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:152
#, no-wrap
msgid ""
"struct sockaddr_in6 {\n"
"    sa_family_t     sin6_family;   /* AF_INET6 */\n"
"    in_port_t       sin6_port;     /* port number */\n"
"    uint32_t        sin6_flowinfo; /* IPv6 flow information */\n"
"    struct in6_addr sin6_addr;     /* IPv6 address */\n"
"    uint32_t        sin6_scope_id; /* Scope ID (new in 2.4) */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:156
#, no-wrap
msgid ""
"struct in6_addr {\n"
"    unsigned char   s6_addr[16];   /* IPv6 address */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:178
msgid ""
"I<sin6_family> is always set to B<AF_INET6>; I<sin6_port> is the protocol "
"port (see I<sin_port> in B<ip>(7)); I<sin6_flowinfo> is the IPv6 flow "
"identifier; I<sin6_addr> is the 128-bit IPv6 address.  I<sin6_scope_id> is "
"an ID depending on the scope of the address.  It is new in Linux 2.4.  Linux "
"supports it only for link-local addresses, in that case I<sin6_scope_id> "
"contains the interface index (see B<netdevice>(7))"
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:184
msgid ""
"IPv6 supports several address types: unicast to address a single host, "
"multicast to address a group of hosts, anycast to address the nearest member "
"of a group of hosts (not implemented in Linux), IPv4-on-IPv6 to address an "
"IPv4 host, and other reserved address types."
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:190
msgid ""
"The address notation for IPv6 is a group of 8 4-digit hexadecimal numbers, "
"separated with a \\(aq:\\(aq.  \\&\"::\" stands for a string of 0 bits.  "
"Special addresses are ::1 for loopback and ::FFFF:E<lt>IPv4 addressE<gt> for "
"IPv4-mapped-on-IPv6."
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:192
msgid "The port space of IPv6 is shared with IPv4."
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:200
msgid ""
"IPv6 supports some protocol-specific socket options that can be set with "
"B<setsockopt>(2)  and read with B<getsockopt>(2).  The socket option level "
"for IPv6 is B<IPPROTO_IPV6>.  A boolean integer flag is zero when it is "
"false, otherwise true."
msgstr ""

#. type: TP
#: build/C/man7/ipv6.7:200
#, no-wrap
msgid "B<IPV6_ADDRFORM>"
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:214
msgid ""
"Turn an B<AF_INET6> socket into a socket of a different address family.  "
"Only B<AF_INET> is currently supported for that.  It is allowed only for "
"IPv6 sockets that are connected and bound to a v4-mapped-on-v6 address.  The "
"argument is a pointer to an integer containing B<AF_INET>.  This is useful "
"to pass v4-mapped sockets as file descriptors to programs that don't know "
"how to deal with the IPv6 API."
msgstr ""

#. type: TP
#: build/C/man7/ipv6.7:214
#, no-wrap
msgid "B<IPV6_ADD_MEMBERSHIP, IPV6_DROP_MEMBERSHIP>"
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:219
msgid ""
"Control membership in multicast groups.  Argument is a pointer to a I<struct "
"ipv6_mreq>."
msgstr ""

#. type: TP
#: build/C/man7/ipv6.7:219
#, no-wrap
msgid "B<IPV6_MTU>"
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:225
msgid ""
"B<getsockopt>(): Retrieve the current known path MTU of the current socket.  "
"Valid only when the socket has been connected.  Returns an integer."
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:231
msgid ""
"B<setsockopt>(): Set the MTU to be used for the socket.  The MTU is limited "
"by the device MTU or the path MTU when path MTU discovery is enabled.  "
"Argument is a pointer to integer."
msgstr ""

#. type: TP
#: build/C/man7/ipv6.7:231
#, no-wrap
msgid "B<IPV6_MTU_DISCOVER>"
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:239
msgid ""
"Control path-MTU discovery on the socket.  See B<IP_MTU_DISCOVER> in "
"B<ip>(7)  for details."
msgstr ""

#. type: TP
#: build/C/man7/ipv6.7:239
#, no-wrap
msgid "B<IPV6_MULTICAST_HOPS>"
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:246
msgid ""
"Set the multicast hop limit for the socket.  Argument is a pointer to an "
"integer.  -1 in the value means use the route default, otherwise it should "
"be between 0 and 255."
msgstr ""

#. type: TP
#: build/C/man7/ipv6.7:246
#, no-wrap
msgid "B<IPV6_MULTICAST_IF>"
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:257
msgid ""
"Set the device for outgoing multicast packets on the socket.  This is "
"allowed only for B<SOCK_DGRAM> and B<SOCK_RAW> socket.  The argument is a "
"pointer to an interface index (see B<netdevice>(7))  in an integer."
msgstr ""

#. type: TP
#: build/C/man7/ipv6.7:257
#, no-wrap
msgid "B<IPV6_MULTICAST_LOOP>"
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:261
msgid ""
"Control whether the socket sees multicast packets that it has send itself.  "
"Argument is a pointer to boolean."
msgstr ""

#. type: TP
#: build/C/man7/ipv6.7:261
#, no-wrap
msgid "B<IPV6_RECVPKTINFO> (since Linux 2.6.14)"
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:275
msgid ""
"Set delivery of the B<IPV6_PKTINFO> control message on incoming datagrams.  "
"Such control messages contain a I<struct in6_pktinfo>, as per RFC 3542.  "
"Allowed only for B<SOCK_DGRAM> or B<SOCK_RAW> sockets.  Argument is a "
"pointer to a boolean value in an integer."
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:278
#, no-wrap
msgid ""
"B<IPV6_RTHDR, IPV6_AUTHHDR, IPV6_DSTOPTS, IPV6_HOPOPTS, IPV6_FLOWINFO, "
"IPV6_HOPLIMIT>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:303
msgid ""
"Set delivery of control messages for incoming datagrams containing extension "
"headers from the received packet.  B<IPV6_RTHDR> delivers the routing "
"header, B<IPV6_AUTHHDR> delivers the authentication header, B<IPV6_DSTOPTS> "
"delivers the destination options, B<IPV6_HOPOPTS> delivers the hop options, "
"B<IPV6_FLOWINFO> delivers an integer containing the flow ID, "
"B<IPV6_HOPLIMIT> delivers an integer containing the hop count of the "
"packet.  The control messages have the same type as the socket option.  All "
"these header options can also be set for outgoing packets by putting the "
"appropriate control message into the control buffer of B<sendmsg>(2).  "
"Allowed only for B<SOCK_DGRAM> or B<SOCK_RAW> sockets.  Argument is a "
"pointer to a boolean value."
msgstr ""

#. type: TP
#: build/C/man7/ipv6.7:303
#, no-wrap
msgid "B<IPV6_RECVERR>"
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:312
msgid ""
"Control receiving of asynchronous error options.  See B<IP_RECVERR> in "
"B<ip>(7)  for details.  Argument is a pointer to boolean."
msgstr ""

#. type: TP
#: build/C/man7/ipv6.7:312
#, no-wrap
msgid "B<IPV6_ROUTER_ALERT>"
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:327
msgid ""
"Pass forwarded packets containing a router alert hop-by-hop option to this "
"socket.  Allowed only for B<SOCK_RAW> sockets.  The tapped packets are not "
"forwarded by the kernel, it is the user's responsibility to send them out "
"again.  Argument is a pointer to an integer.  A positive integer indicates a "
"router alert option value to intercept.  Packets carrying a router alert "
"option with a value field containing this integer will be delivered to the "
"socket.  A negative integer disables delivery of packets with router alert "
"options to this socket."
msgstr ""

#. type: TP
#: build/C/man7/ipv6.7:327
#, no-wrap
msgid "B<IPV6_UNICAST_HOPS>"
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:333
msgid ""
"Set the unicast hop limit for the socket.  Argument is a pointer to an "
"integer.  -1 in the value means use the route default, otherwise it should "
"be between 0 and 255."
msgstr ""

#. type: TP
#: build/C/man7/ipv6.7:333
#, no-wrap
msgid "B<IPV6_V6ONLY> (since Linux 2.4.21 and 2.6)"
msgstr ""

#.  See RFC 3493
#. type: Plain text
#: build/C/man7/ipv6.7:340
msgid ""
"If this flag is set to true (nonzero), then the socket is restricted to "
"sending and receiving IPv6 packets only.  In this case, an IPv4 and an IPv6 "
"application can bind to a single port at the same time."
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:344
msgid ""
"If this flag is set to false (zero), then the socket can be used to send and "
"receive packets to and from an IPv6 address or an IPv4-mapped IPv6 address."
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:346
msgid "The argument is a pointer to a boolean value in an integer."
msgstr ""

#.  FLOWLABEL_MGR, FLOWINFO_SEND
#. type: Plain text
#: build/C/man7/ipv6.7:351
msgid ""
"The default value for this flag is defined by the contents of the file "
"I</proc/sys/net/ipv6/bindv6only>.  The default value for that file is 0 "
"(false)."
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:362
msgid ""
"The user tried to B<bind>(2)  to a link-local IPv6 address, but the "
"I<sin6_scope_id> in the supplied I<sockaddr_in6> structure is not a valid "
"interface index."
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:378
msgid ""
"Linux 2.4 will break binary compatibility for the I<sockaddr_in6> for 64-bit "
"hosts by changing the alignment of I<in6_addr> and adding an additional "
"I<sin6_scope_id> field.  The kernel interfaces stay compatible, but a "
"program including I<sockaddr_in6> or I<in6_addr> into other structures may "
"not be.  This is not a problem for 32-bit hosts like i386."
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:386
msgid ""
"The I<sin6_flowinfo> field is new in Linux 2.4.  It is transparently "
"passed/read by the kernel when the passed address length contains it.  Some "
"programs that pass a longer address buffer and then check the outgoing "
"address length may break."
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:396
msgid ""
"The I<sockaddr_in6> structure is bigger than the generic I<sockaddr>.  "
"Programs that assume that all address types can be stored safely in a "
"I<struct sockaddr> need to be changed to use I<struct sockaddr_storage> for "
"that instead."
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:406
msgid ""
"B<SOL_IP>, B<SOL_IPV6>, B<SOL_ICMPV6>, and other B<SOL_*> socket options are "
"nonportable variants of B<IPPROTO_*>.  See also B<ip>(7)."
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:411
msgid ""
"The IPv6 extended API as in RFC\\ 2292 is currently only partly implemented; "
"although the 2.2 kernel has near complete support for receiving options, the "
"macros for generating IPv6 options are missing in glibc 2.1."
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:413
msgid "IPSec support for EH and AH headers is missing."
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:415
msgid "Flow label management is not complete and not documented here."
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:417
msgid "This man page is not complete."
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:420
msgid "B<cmsg>(3), B<ip>(7)"
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:424
msgid ""
"RFC\\ 2553: IPv6 BASIC API; Linux tries to be compliant to this.  RFC\\ "
"2460: IPv6 specification."
msgstr ""

#. type: TH
#: build/C/man7/netdevice.7:17
#, no-wrap
msgid "NETDEVICE"
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:20
msgid "netdevice - low-level access to Linux network devices"
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:22
msgid "B<#include E<lt>sys/ioctl.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:24
msgid "B<#include E<lt>net/if.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:27
msgid ""
"This man page describes the sockets interface which is used to configure "
"network devices."
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:34
msgid ""
"Linux supports some standard ioctls to configure network devices.  They can "
"be used on any socket's file descriptor regardless of the family or type.  "
"Most of them pass an I<ifreq> structure:"
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:55
#, no-wrap
msgid ""
"struct ifreq {\n"
"    char ifr_name[IFNAMSIZ]; /* Interface name */\n"
"    union {\n"
"        struct sockaddr ifr_addr;\n"
"        struct sockaddr ifr_dstaddr;\n"
"        struct sockaddr ifr_broadaddr;\n"
"        struct sockaddr ifr_netmask;\n"
"        struct sockaddr ifr_hwaddr;\n"
"        short           ifr_flags;\n"
"        int             ifr_ifindex;\n"
"        int             ifr_metric;\n"
"        int             ifr_mtu;\n"
"        struct ifmap    ifr_map;\n"
"        char            ifr_slave[IFNAMSIZ];\n"
"        char            ifr_newname[IFNAMSIZ];\n"
"        char           *ifr_data;\n"
"    };\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:63
msgid ""
"Normally, the user specifies which device to affect by setting I<ifr_name> "
"to the name of the interface.  All other members of the structure may share "
"memory."
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:71
msgid ""
"If an ioctl is marked as privileged, then using it requires an effective "
"user ID of 0 or the B<CAP_NET_ADMIN> capability.  If this is not the case, "
"B<EPERM> will be returned."
msgstr ""

#. type: TP
#: build/C/man7/netdevice.7:71
#, no-wrap
msgid "B<SIOCGIFNAME>"
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:79
msgid ""
"Given the I<ifr_ifindex>, return the name of the interface in I<ifr_name>.  "
"This is the only ioctl which returns its result in I<ifr_name>."
msgstr ""

#. type: TP
#: build/C/man7/netdevice.7:79
#, no-wrap
msgid "B<SIOCGIFINDEX>"
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:83
msgid "Retrieve the interface index of the interface into I<ifr_ifindex>."
msgstr ""

#. type: TP
#: build/C/man7/netdevice.7:83
#, no-wrap
msgid "B<SIOCGIFFLAGS>, B<SIOCSIFFLAGS>"
msgstr ""

#.  Do not right adjust text blocks in tables
#. type: Plain text
#: build/C/man7/netdevice.7:89
msgid ""
"Get or set the active flag word of the device.  I<ifr_flags> contains a bit "
"mask of the following values:"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:94
#, no-wrap
msgid "Device flags"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:95
#, no-wrap
msgid "IFF_UP"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:95
#, no-wrap
msgid "Interface is running."
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:96
#, no-wrap
msgid "IFF_BROADCAST"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:96
#, no-wrap
msgid "Valid broadcast address set."
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:97
#, no-wrap
msgid "IFF_DEBUG"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:97
#, no-wrap
msgid "Internal debugging flag."
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:98
#, no-wrap
msgid "IFF_LOOPBACK"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:98
#, no-wrap
msgid "Interface is a loopback interface."
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:99
#, no-wrap
msgid "IFF_POINTOPOINT"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:99
#, no-wrap
msgid "Interface is a point-to-point link."
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:100
#, no-wrap
msgid "IFF_RUNNING"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:100
#, no-wrap
msgid "Resources allocated."
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:101
#, no-wrap
msgid "IFF_NOARP"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:103
#, no-wrap
msgid "No arp protocol, L2 destination address not set."
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:104
#, no-wrap
msgid "IFF_PROMISC"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:104
#, no-wrap
msgid "Interface is in promiscuous mode."
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:105
#, no-wrap
msgid "IFF_NOTRAILERS"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:105
#, no-wrap
msgid "Avoid use of trailers."
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:106
#, no-wrap
msgid "IFF_ALLMULTI"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:106
#, no-wrap
msgid "Receive all multicast packets."
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:107
#, no-wrap
msgid "IFF_MASTER"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:107
#, no-wrap
msgid "Master of a load balancing bundle."
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:108
#, no-wrap
msgid "IFF_SLAVE"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:108
#, no-wrap
msgid "Slave of a load balancing bundle."
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:109
#, no-wrap
msgid "IFF_MULTICAST"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:109
#, no-wrap
msgid "Supports multicast"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:110
#, no-wrap
msgid "IFF_PORTSEL"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:110
#, no-wrap
msgid "Is able to select media type via ifmap."
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:111
#, no-wrap
msgid "IFF_AUTOMEDIA"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:111
#, no-wrap
msgid "Auto media selection active."
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:112
#, no-wrap
msgid "IFF_DYNAMIC"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:114
#, no-wrap
msgid "The addresses are lost when the interface goes down."
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:115
#, no-wrap
msgid "IFF_LOWER_UP"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:115
#, no-wrap
msgid "Driver signals L1 up (since Linux 2.6.17)"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:116
#, no-wrap
msgid "IFF_DORMANT"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:116
#, no-wrap
msgid "Driver signals dormant (since Linux 2.6.17)"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:117
#, no-wrap
msgid "IFF_ECHO"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:117
#, no-wrap
msgid "Echo sent packets (since Linux 2.6.25)"
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:123
msgid ""
"Setting the active flag word is a privileged operation, but any process may "
"read it."
msgstr ""

#. type: TP
#: build/C/man7/netdevice.7:123
#, no-wrap
msgid "B<SIOCGIFPFLAGS>, B<SIOCSIFPFLAGS>"
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:128
msgid ""
"Get or set extended (private) flags for the device.  I<ifr_flags> contains a "
"bit mask of the following values:"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:132
#, no-wrap
msgid "Private flags"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:133
#, no-wrap
msgid "IFF_802_1Q_VLAN"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:133
#, no-wrap
msgid "Interface is 802.1Q VLAN device."
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:134
#, no-wrap
msgid "IFF_EBRIDGE"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:134
#, no-wrap
msgid "Interface is Ethernet bridging device."
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:135
#, no-wrap
msgid "IFF_SLAVE_INACTIVE"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:135
#, no-wrap
msgid "Interface is inactive bonding slave."
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:136
#, no-wrap
msgid "IFF_MASTER_8023AD"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:136
#, no-wrap
msgid "Interface is 802.3ad bonding master."
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:137
#, no-wrap
msgid "IFF_MASTER_ALB"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:137
#, no-wrap
msgid "Interface is balanced-alb bonding master."
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:138
#, no-wrap
msgid "IFF_BONDING"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:138
#, no-wrap
msgid "Interface is a bonding master or slave."
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:139
#, no-wrap
msgid "IFF_SLAVE_NEEDARP"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:139
#, no-wrap
msgid "Interface needs ARPs for validation."
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:140
#, no-wrap
msgid "IFF_ISATAP"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:140
#, no-wrap
msgid "Interface is RFC4214 ISATAP interface."
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:144
msgid "Setting the extended (private) interface flags is a privileged operation."
msgstr ""

#. type: TP
#: build/C/man7/netdevice.7:144
#, no-wrap
msgid "B<SIOCGIFADDR>, B<SIOCSIFADDR>"
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:152
msgid ""
"Get or set the address of the device using I<ifr_addr>.  Setting the "
"interface address is a privileged operation.  For compatibility, only "
"B<AF_INET> addresses are accepted or returned."
msgstr ""

#. type: TP
#: build/C/man7/netdevice.7:152
#, no-wrap
msgid "B<SIOCGIFDSTADDR>, B<SIOCSIFDSTADDR>"
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:160
msgid ""
"Get or set the destination address of a point-to-point device using "
"I<ifr_dstaddr>.  For compatibility, only B<AF_INET> addresses are accepted "
"or returned.  Setting the destination address is a privileged operation."
msgstr ""

#. type: TP
#: build/C/man7/netdevice.7:160
#, no-wrap
msgid "B<SIOCGIFBRDADDR>, B<SIOCSIFBRDADDR>"
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:168
msgid ""
"Get or set the broadcast address for a device using I<ifr_brdaddr>.  For "
"compatibility, only B<AF_INET> addresses are accepted or returned.  Setting "
"the broadcast address is a privileged operation."
msgstr ""

#. type: TP
#: build/C/man7/netdevice.7:168
#, no-wrap
msgid "B<SIOCGIFNETMASK>, B<SIOCSIFNETMASK>"
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:176
msgid ""
"Get or set the network mask for a device using I<ifr_netmask>.  For "
"compatibility, only B<AF_INET> addresses are accepted or returned.  Setting "
"the network mask is a privileged operation."
msgstr ""

#. type: TP
#: build/C/man7/netdevice.7:176
#, no-wrap
msgid "B<SIOCGIFMETRIC>, B<SIOCSIFMETRIC>"
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:185
msgid ""
"Get or set the metric of the device using I<ifr_metric>.  This is currently "
"not implemented; it sets I<ifr_metric> to 0 if you attempt to read it and "
"returns B<EOPNOTSUPP> if you attempt to set it."
msgstr ""

#. type: TP
#: build/C/man7/netdevice.7:185
#, no-wrap
msgid "B<SIOCGIFMTU>, B<SIOCSIFMTU>"
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:192
msgid ""
"Get or set the MTU (Maximum Transfer Unit) of a device using I<ifr_mtu>.  "
"Setting the MTU is a privileged operation.  Setting the MTU to too small "
"values may cause kernel crashes."
msgstr ""

#. type: TP
#: build/C/man7/netdevice.7:192
#, no-wrap
msgid "B<SIOCGIFHWADDR>, B<SIOCSIFHWADDR>"
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:203
msgid ""
"Get or set the hardware address of a device using I<ifr_hwaddr>.  The "
"hardware address is specified in a struct I<sockaddr>.  I<sa_family> "
"contains the ARPHRD_* device type, I<sa_data> the L2 hardware address "
"starting from byte 0.  Setting the hardware address is a privileged "
"operation."
msgstr ""

#. type: TP
#: build/C/man7/netdevice.7:203
#, no-wrap
msgid "B<SIOCSIFHWBROADCAST>"
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:208
msgid ""
"Set the hardware broadcast address of a device from I<ifr_hwaddr>.  This is "
"a privileged operation."
msgstr ""

#. type: TP
#: build/C/man7/netdevice.7:208
#, no-wrap
msgid "B<SIOCGIFMAP>, B<SIOCSIFMAP>"
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:213
msgid ""
"Get or set the interface's hardware parameters using I<ifr_map>.  Setting "
"the parameters is a privileged operation."
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:224
#, no-wrap
msgid ""
"struct ifmap {\n"
"    unsigned long   mem_start;\n"
"    unsigned long   mem_end;\n"
"    unsigned short  base_addr;\n"
"    unsigned char   irq;\n"
"    unsigned char   dma;\n"
"    unsigned char   port;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:229
msgid ""
"The interpretation of the ifmap structure depends on the device driver and "
"the architecture."
msgstr ""

#. type: TP
#: build/C/man7/netdevice.7:229
#, no-wrap
msgid "B<SIOCADDMULTI>, B<SIOCDELMULTI>"
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:238
msgid ""
"Add an address to or delete an address from the device's link layer "
"multicast filters using I<ifr_hwaddr>.  These are privileged operations.  "
"See also B<packet>(7)  for an alternative."
msgstr ""

#. type: TP
#: build/C/man7/netdevice.7:238
#, no-wrap
msgid "B<SIOCGIFTXQLEN>, B<SIOCSIFTXQLEN>"
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:243
msgid ""
"Get or set the transmit queue length of a device using I<ifr_qlen>.  Setting "
"the transmit queue length is a privileged operation."
msgstr ""

#. type: TP
#: build/C/man7/netdevice.7:243
#, no-wrap
msgid "B<SIOCSIFNAME>"
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:252
msgid ""
"Changes the name of the interface specified in I<ifr_name> to "
"I<ifr_newname>.  This is a privileged operation.  It is allowed only when "
"the interface is not up."
msgstr ""

#. type: TP
#: build/C/man7/netdevice.7:252
#, no-wrap
msgid "B<SIOCGIFCONF>"
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:262
msgid ""
"Return a list of interface (network layer) addresses.  This currently means "
"only addresses of the B<AF_INET> (IPv4) family for compatibility.  Unlike "
"the others, this ioctl passes an I<ifconf> structure:"
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:272
#, no-wrap
msgid ""
"struct ifconf {\n"
"    int                 ifc_len; /* size of buffer */\n"
"    union {\n"
"        char           *ifc_buf; /* buffer address */\n"
"        struct ifreq   *ifc_req; /* array of structures */\n"
"    };\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:298
msgid ""
"If I<ifc_req> is NULL, B<SIOCGIFCONF> returns the necessary buffer size in "
"bytes for receiving all available addresses in I<ifc_len>.  Otherwise, "
"I<ifc_req> contains a pointer to an array of I<ifreq> structures to be "
"filled with all currently active L3 interface addresses.  I<ifc_len> "
"contains the size of the array in bytes.  Within each I<ifreq> structure, "
"I<ifr_name> will receive the interface name, and I<ifr_addr> the address.  "
"The actual number of bytes transferred is returned in I<ifc_len>."
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:314
msgid ""
"If the size specified by I<ifc_len> is insufficient to store all the "
"addresses, the kernel will skip the exceeding ones and return success.  "
"There is no reliable way of detecting this condition once it has occurred.  "
"It is therefore recommended to either determine the necessary buffer size "
"beforehand by calling B<SIOCGIFCONF> with I<ifc_req> set to NULL, or to "
"retry the call with a bigger buffer whenever I<ifc_len> upon return differs "
"by less than I<sizeof(struct ifreq)> from its original value."
msgstr ""

#.  Slaving isn't supported in 2.2
#.  .
#.  .TP
#.  .BR SIOCGIFSLAVE ", " SIOCSIFSLAVE
#.  Get or set the slave device using
#.  .IR ifr_slave .
#.  Setting the slave device is a privileged operation.
#.  .PP
#.  FIXME . add amateur radio stuff.
#. type: Plain text
#: build/C/man7/netdevice.7:331
msgid ""
"If an error occurs accessing the I<ifconf> or I<ifreq> structures, B<EFAULT> "
"will be returned."
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:337
msgid ""
"Most protocols support their own ioctls to configure protocol-specific "
"interface options.  See the protocol man pages for a description.  For "
"configuring IP addresses, see B<ip>(7)."
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:340
msgid ""
"In addition, some devices support private ioctls.  These are not described "
"here."
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:347
msgid ""
"B<SIOCGIFCONF> and the other ioctls that accept or return only B<AF_INET> "
"socket addresses are IP-specific and perhaps should rather be documented in "
"B<ip>(7)."
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:352
msgid ""
"The names of interfaces with no addresses or that don't have the "
"B<IFF_RUNNING> flag set can be found via I</proc/net/dev>."
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:357
msgid ""
"Local IPv6 IP addresses can be found via I</proc/net> or via "
"B<rtnetlink>(7)."
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:363
msgid ""
"glibc 2.1 is missing the I<ifr_newname> macro in I<E<lt>net/if.hE<gt>>.  Add "
"the following to your program as a workaround:"
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:369
#, no-wrap
msgid ""
"#ifndef ifr_newname\n"
"#define ifr_newname     ifr_ifru.ifru_slave\n"
"#endif\n"
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:376
msgid "B<proc>(5), B<capabilities>(7), B<ip>(7), B<rtnetlink>(7)"
msgstr ""

#. type: TH
#: build/C/man5/networks.5:26
#, no-wrap
msgid "NETWORKS"
msgstr ""

#. type: TH
#: build/C/man5/networks.5:26
#, no-wrap
msgid "2008-09-04"
msgstr ""

#. type: TH
#: build/C/man5/networks.5:26
#, no-wrap
msgid "GNU/Linux"
msgstr ""

#. type: Plain text
#: build/C/man5/networks.5:29
msgid "networks - network name information"
msgstr ""

#. type: Plain text
#: build/C/man5/networks.5:35
msgid ""
"The file I</etc/networks> is a plain ASCII file that describes known DARPA "
"networks and symbolic names for these networks.  Each line represents a "
"network and has the following structure:"
msgstr ""

#. type: Plain text
#: build/C/man5/networks.5:38
msgid "I<name number aliases ...>"
msgstr ""

#. type: Plain text
#: build/C/man5/networks.5:46
msgid ""
"where the fields are delimited by spaces or tabs.  Empty lines are ignored.  "
"The hash character (B<#>) indicates the start of a comment: this character, "
"and the remaining characters up to the end of the current line, are ignored "
"by library functions that process the file."
msgstr ""

#. type: Plain text
#: build/C/man5/networks.5:48 build/C/man5/protocols.5:59
msgid "The field descriptions are:"
msgstr ""

#. type: TP
#: build/C/man5/networks.5:48
#, no-wrap
msgid "I<name>"
msgstr ""

#. type: Plain text
#: build/C/man5/networks.5:53
msgid ""
"The symbolic name for the network.  Network names can contain any printable "
"characters except white-space characters or the comment character."
msgstr ""

#. type: TP
#: build/C/man5/networks.5:53 build/C/man5/protocols.5:67
#, no-wrap
msgid "I<number>"
msgstr ""

#. type: Plain text
#: build/C/man5/networks.5:58
msgid ""
"The official number for this network in numbers-and-dots notation (see "
"B<inet>(3)).  The trailing \".0\" (for the host component of the network "
"address) may be omitted."
msgstr ""

#. type: TP
#: build/C/man5/networks.5:58 build/C/man5/protocols.5:71 build/C/man5/services.5:120
#, no-wrap
msgid "I<aliases>"
msgstr ""

#. type: Plain text
#: build/C/man5/networks.5:61
msgid "Optional aliases for the network."
msgstr ""

#. type: Plain text
#: build/C/man5/networks.5:70
msgid ""
"This file is read by the B<route>(8)  and B<netstat>(8)  utilities.  Only "
"Class A, B or C networks are supported, partitioned networks (i.e., "
"network/26 or network/28) are not supported by this file."
msgstr ""

#. type: Plain text
#: build/C/man5/networks.5:74
msgid "The networks definition file."
msgstr ""

#. type: Plain text
#: build/C/man5/networks.5:80
msgid ""
"B<getnetbyaddr>(3), B<getnetbyname>(3), B<getnetent>(3), B<netstat>(8), "
"B<route>(8)"
msgstr ""

#. type: TH
#: build/C/man8/nscd.8:23
#, no-wrap
msgid "NSCD"
msgstr ""

#. type: TH
#: build/C/man8/nscd.8:23
#, no-wrap
msgid "2015-05-07"
msgstr ""

#. type: Plain text
#: build/C/man8/nscd.8:26
msgid "nscd - name service cache daemon"
msgstr ""

#. type: Plain text
#: build/C/man8/nscd.8:35
msgid ""
"B<nscd> is a daemon that provides a cache for the most common name service "
"requests.  The default configuration file, I</etc/nscd.conf>, determines the "
"behavior of the cache daemon.  See B<nscd.conf>(5)."
msgstr ""

#. type: Plain text
#: build/C/man8/nscd.8:51
msgid ""
"B<nscd> provides caching for accesses of the B<passwd>(5), B<group>(5), "
"B<hosts>(5)  B<services>(5)  and I<netgroup> databases through standard libc "
"interfaces, such as B<getpwnam>(3), B<getpwuid>(3), B<getgrnam>(3), "
"B<getgrgid>(3), B<gethostbyname>(3), and others."
msgstr ""

#. type: Plain text
#: build/C/man8/nscd.8:60
msgid ""
"There are two caches for each database: a positive one for items found, and "
"a negative one for items not found.  Each cache has a separate TTL "
"(time-to-live)  period for its data.  Note that the shadow file is "
"specifically not cached.  B<getspnam>(3)  calls remain uncached as a result."
msgstr ""

#. type: TP
#: build/C/man8/nscd.8:61
#, no-wrap
msgid "B<--help>"
msgstr ""

#. type: Plain text
#: build/C/man8/nscd.8:64
msgid "will give you a list with all options and what they do."
msgstr ""

#. type: Plain text
#: build/C/man8/nscd.8:87
msgid ""
"The daemon will try to watch for changes in configuration files appropriate "
"for each database (e.g., I</etc/passwd> for the I<passwd> database or "
"I</etc/hosts> and I</etc/resolv.conf> for the I<hosts> database), and flush "
"the cache when these are changed.  However, this will happen only after a "
"short delay (unless the B<inotify>(7)  mechanism is available and glibc 2.9 "
"or later is available), and this auto-detection does not cover configuration "
"files required by nonstandard NSS modules, if any are specified in "
"I</etc/nsswitch.conf>.  In that case, you need to run the following command "
"after changing the configuration file of the database so that B<nscd> "
"invalidates its cache:"
msgstr ""

#. type: Plain text
#: build/C/man8/nscd.8:91
#, no-wrap
msgid "$ B<nscd -i> I<E<lt>databaseE<gt>>\n"
msgstr ""

#.  .SH AUTHOR
#.  .B nscd
#.  was written by Thorsten Kukuk and Ulrich Drepper.
#. type: Plain text
#: build/C/man8/nscd.8:99
msgid "B<nscd.conf>(5), B<nsswitch.conf>(5)"
msgstr ""

#. type: TH
#: build/C/man5/nscd.conf.5:20
#, no-wrap
msgid "NSCD.CONF"
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:23
msgid "nscd.conf - name service cache daemon configuration file"
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:36
msgid ""
"The file I</etc/nscd.conf> is read from B<nscd>(8)  at startup.  Each line "
"specifies either an attribute and a value, or an attribute, service, and a "
"value.  Fields are separated either by SPACE or TAB characters.  A "
"\\(aq#\\(aq (number sign) indicates the beginning of a comment; following "
"characters, up to the end of the line, are not interpreted by nscd."
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:39
msgid ""
"Valid services are I<passwd>, I<group>, I<hosts>, I<services>, or "
"I<netgroup>."
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:42
msgid "B<logfile> I<debug-file-name>"
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:44
msgid "Specifies name of the file to which debug info should be written."
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:48
msgid "B<debug-level> I<value>"
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:51
msgid "Sets the desired debug level.  The default is 0."
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:55
msgid "B<threads> I<number>"
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:59
msgid ""
"This is the number of threads that are started to wait for requests.  At "
"least five threads will always be created."
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:63
msgid "B<max-threads> I<number>"
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:66
msgid "Specifies the maximum number of threads.  The default is 32."
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:70
msgid "B<server-user> I<user>"
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:74
msgid ""
"If this option is set, nscd will run as this user and not as root.  If a "
"separate cache for every user is used (-S parameter), this option is "
"ignored."
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:78
msgid "B<stat-user> I<user>"
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:80
msgid "Specifies the user who is allowed to request statistics."
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:85
msgid "B<reload-count> unlimited | I<number>"
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:89
msgid ""
"Limit on the number of times a cached entry gets reloaded without being used "
"before it gets removed.  The default is 5."
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:93
msgid "B<paranoia> I<E<lt>yes|noE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:96
msgid ""
"Enabling paranoia mode causes nscd to restart itself periodically.  The "
"default is no."
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:100
msgid "B<restart-interval> I<time>"
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:108
msgid ""
"Sets the restart interval to I<time> seconds if periodic restart is enabled "
"by enabling B<paranoia> mode.  The default is 3600."
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:113
msgid "B<enable-cache> I<service> I<E<lt>yes|noE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:118
msgid "Enables or disables the specified I<service> cache.  The default is no."
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:123
msgid "B<positive-time-to-live> I<service> I<value>"
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:131
msgid ""
"Sets the TTL (time-to-live) for positive entries (successful queries)  in "
"the specified cache for I<service>.  I<Value> is in seconds.  Larger values "
"increase cache hit rates and reduce mean response times, but increase "
"problems with cache coherence."
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:136
msgid "B<negative-time-to-live> I<service> I<value>"
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:146
msgid ""
"Sets the TTL (time-to-live) for negative entries (unsuccessful queries)  in "
"the specified cache for I<service>.  I<Value> is in seconds.  Can result in "
"significant performance improvements if there are several files owned by "
"UIDs (user IDs) not in system databases (for example untarring the Linux "
"kernel sources as root); should be kept small to reduce cache coherency "
"problems."
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:151
msgid "B<suggested-size> I<service> I<value>"
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:156
msgid ""
"This is the internal hash table size, I<value> should remain a prime number "
"for optimum efficiency.  The default is 211."
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:161
msgid "B<check-files> I<service> I<E<lt>yes|noE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:173
msgid ""
"Enables or disables checking the file belonging to the specified I<service> "
"for changes.  The files are I</etc/passwd>, I</etc/group>, I</etc/hosts>, "
"I</etc/services>, and I</etc/netgroup>.  The default is yes."
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:178
msgid "B<persistent> I<service> I<E<lt>yes|noE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:185
msgid ""
"Keep the content of the cache for I<service> over server restarts; useful "
"when B<paranoia> mode is set.  The default is no."
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:190
msgid "B<shared> I<service> I<E<lt>yes|noE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:197
msgid ""
"The memory mapping of the nscd databases for I<service> is shared with the "
"clients so that they can directly search in them instead of having to ask "
"the daemon over the socket each time a lookup is performed.  The default is "
"no."
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:202
msgid "B<max-db-size> I<service> I<bytes>"
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:206
msgid ""
"The maximum allowable size, in bytes, of the database files for the "
"I<service>.  The default is 33554432."
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:211
msgid "B<auto-propagate> I<service> I<E<lt>yes|noE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:231
msgid ""
"When set to I<no> for I<passwd> or I<group> service, then the I<.byname> "
"requests are not added to I<passwd.byuid> or I<group.bygid> cache.  This can "
"help with tables containing multiple records for the same ID.  The default "
"is yes.  This option is valid only for services I<passwd> and I<group>."
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:239
msgid ""
"The default values stated in this manual page originate from the source code "
"of B<nscd>(8)  and are used if not overridden in the configuration file.  "
"The default values used in the configuration file of your distribution might "
"differ."
msgstr ""

#.  .SH AUTHOR
#.  .B nscd
#.  was written by Thorsten Kukuk and Ulrich Drepper.
#. type: Plain text
#: build/C/man5/nscd.conf.5:244
msgid "B<nscd>(8)"
msgstr ""

#. type: TH
#: build/C/man5/nss.5:19
#, no-wrap
msgid "NSS"
msgstr ""

#. type: Plain text
#: build/C/man5/nss.5:22
msgid "nss - Name Service Switch configuration file"
msgstr ""

#. type: Plain text
#: build/C/man5/nss.5:29
msgid ""
"Each call to a function which retrieves data from a system database like the "
"password or group database is handled by the Name Service Switch "
"implementation in the GNU C library.  The various services provided are "
"implemented by independent modules, each of which naturally varies widely "
"from the other."
msgstr ""

#. type: Plain text
#: build/C/man5/nss.5:38
msgid ""
"The default implementations coming with the GNU C library are by default "
"conservative and do not use unsafe data.  This might be very costly in some "
"situations, especially when the databases are large.  Some modules allow the "
"system administrator to request taking shortcuts if these are known to be "
"safe.  It is then the system administrator's responsibility to ensure the "
"assumption is correct."
msgstr ""

#. type: Plain text
#: build/C/man5/nss.5:42
msgid ""
"There are other modules where the implementation changed over time.  If an "
"implementation used to sacrifice speed for memory consumption, it might "
"create problems if the preference is switched."
msgstr ""

#. type: Plain text
#: build/C/man5/nss.5:51
msgid ""
"The I</etc/default/nss> file contains a number of variable assignments.  "
"Each variable controls the behavior of one or more NSS modules.  White "
"spaces are ignored.  Lines beginning with \\(aq#\\(aq are treated as "
"comments."
msgstr ""

#. type: Plain text
#: build/C/man5/nss.5:53
msgid "The variables currently recognized are:"
msgstr ""

#. type: TP
#: build/C/man5/nss.5:53
#, no-wrap
msgid "B<NETID_AUTHORITATIVE => I<TRUE>|I<FALSE>"
msgstr ""

#. type: Plain text
#: build/C/man5/nss.5:68
msgid ""
"If set to TRUE, the NIS backend for the B<initgroups>(3)  function will "
"accept the information from the I<netid.byname> NIS map as authoritative.  "
"This can speed up the function significantly if the I<group.byname> map is "
"large.  The content of the I<netid.byname> map is used B<as is>.  The system "
"administrator has to make sure it is correctly generated."
msgstr ""

#. type: TP
#: build/C/man5/nss.5:68
#, no-wrap
msgid "B<SERVICES_AUTHORITATIVE => I<TRUE>|I<FALSE>"
msgstr ""

#. type: Plain text
#: build/C/man5/nss.5:80
msgid ""
"If set to TRUE, the NIS backend for the B<getservbyname>(3)  and "
"B<getservbyname_r>(3)  functions will assume that the "
"I<services.byservicename> NIS map exists and is authoritative, particularly "
"that it contains both keys with /proto and without /proto for both primary "
"service names and service aliases.  The system administrator has to make "
"sure it is correctly generated."
msgstr ""

#. type: TP
#: build/C/man5/nss.5:80
#, no-wrap
msgid "B<SETENT_BATCH_READ => I<TRUE>|I<FALSE>"
msgstr ""

#. type: Plain text
#: build/C/man5/nss.5:98
msgid ""
"If set to TRUE, the NIS backend for the B<setpwent>(3)  and B<setgrent>(3)  "
"functions will read the entire database at once and then hand out the "
"requests one by one from memory with every corresponding B<getpwent>(3)  or "
"B<getgrent>(3)  call respectively.  Otherwise, each B<getpwent>(3)  or "
"B<getgrent>(3)  call might result in a network communication with the server "
"to get the next entry."
msgstr ""

#. type: Plain text
#: build/C/man5/nss.5:100
msgid "I</etc/default/nss>"
msgstr ""

#. type: Plain text
#: build/C/man5/nss.5:102
msgid "The default configuration corresponds to the following configuration file:"
msgstr ""

#. type: Plain text
#: build/C/man5/nss.5:108
#, no-wrap
msgid ""
"NETID_AUTHORITATIVE=FALSE\n"
"SERVICES_AUTHORITATIVE=FALSE\n"
"SETENT_BATCH_READ=FALSE\n"
msgstr ""

#. type: Plain text
#: build/C/man5/nss.5:115
msgid "I<nsswitch.conf>"
msgstr ""

#. type: TH
#: build/C/man5/nsswitch.conf.5:25
#, no-wrap
msgid "NSSWITCH.CONF"
msgstr ""

#. type: TH
#: build/C/man5/nsswitch.conf.5:25
#, no-wrap
msgid "2017-05-03"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:28
msgid "nsswitch.conf - Name Service Switch configuration file"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:36
msgid ""
"The Name Service Switch (NSS) configuration file, I</etc/nsswitch.conf>, is "
"used by the GNU C Library and certain other applications to determine the "
"sources from which to obtain name-service information in a range of "
"categories, and in what order.  Each category of information is identified "
"by a database name."
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:42
msgid ""
"The file is plain ASCII text, with columns separated by spaces or tab "
"characters.  The first column specifies the database name.  The remaining "
"columns describe the order of sources to query and a limited set of actions "
"that can be performed by lookup result."
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:44
msgid "The following databases are understood by the GNU C Library:"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:49
msgid "Mail aliases, used by B<getaliasent>(3)  and related functions."
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:52
msgid "Ethernet numbers."
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:57
msgid "Groups of users, used by B<getgrent>(3)  and related functions."
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:62
msgid "Host names and numbers, used by B<gethostbyname>(3)  and related functions."
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:67
msgid "Supplementary group access list, used by B<getgrouplist>(3)  function."
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:71
msgid ""
"Network-wide list of hosts and users, used for access rules.  C libraries "
"before glibc 2.1 supported netgroups only over NIS."
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:76
msgid "Network names and numbers, used by B<getnetent>(3)  and related functions."
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:81
msgid "User passwords, used by B<getpwent>(3)  and related functions."
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:86
msgid "Network protocols, used by B<getprotoent>(3)  and related functions."
msgstr ""

#. type: TP
#: build/C/man5/nsswitch.conf.5:86 build/C/man5/nsswitch.conf.5:399
#, no-wrap
msgid "B<publickey>"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:89
msgid "Public and secret keys for Secure_RPC used by NFS and NIS+."
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:94
msgid ""
"Remote procedure call names and numbers, used by B<getrpcbyname>(3)  and "
"related functions."
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:99
msgid "Network services, used by B<getservent>(3)  and related functions."
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:104
msgid "Shadow user passwords, used by B<getspnam>(3)  and related functions."
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:112
msgid ""
"The GNU C Library ignores databases with unknown names.  Some applications "
"use this to implement special handling for their own databases.  For "
"example, B<sudo>(8)  consults the B<sudoers> database."
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:116
msgid "Here is an example I</etc/nsswitch.conf> file:"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:122
#, no-wrap
msgid ""
"passwd:         compat\n"
"group:          compat\n"
"shadow:         compat\n"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:129
#, no-wrap
msgid ""
"hosts:          dns [!UNAVAIL=return] files\n"
"networks:       nis [NOTFOUND=return] files\n"
"ethers:         nis [NOTFOUND=return] files\n"
"protocols:      nis [NOTFOUND=return] files\n"
"rpc:            nis [NOTFOUND=return] files\n"
"services:       nis [NOTFOUND=return] files\n"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:134
msgid "The first column is the database name.  The remaining columns specify:"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:138
msgid ""
"One or more service specifications, for example, \"files\", \"db\", or "
"\"nis\".  The order of the services on the line determines the order in "
"which those services will be queried, in turn, until a result is found."
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:141
msgid ""
"Optional actions to perform if a particular result is obtained from the "
"preceding service, for example, \"[NOTFOUND=return]\"."
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:167
msgid ""
"The service specifications supported on your system depend on the presence "
"of shared libraries, and are therefore extensible.  Libraries called "
"I</lib/libnss_SERVICE.so.>B<X> will provide the named I<SERVICE>.  On a "
"standard installation, you can use \"files\", \"db\", \"nis\", and "
"\"nisplus\".  For the B<hosts> database, you can additionally specify "
"\"dns\".  For the B<passwd>, B<group>, and B<shadow> databases, you can "
"additionally specify \"compat\" (see B<Compatibility mode> below).  The "
"version number B<X> may be 1 for glibc 2.0, or 2 for glibc 2.1 and later.  "
"On systems with additional libraries installed, you may have access to "
"further services such as \"hesiod\", \"ldap\", \"winbind\" and \"wins\"."
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:172
msgid ""
"An action may also be specified following a service specification.  The "
"action modifies the behavior following a result obtained from the preceding "
"data source.  Action items take the general form:"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:175
msgid "[I<STATUS>=I<ACTION>]"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:177
msgid "[!I<STATUS>=I<ACTION>]"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:180
msgid "where"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:191
msgid "I<STATUS> =E<gt> B<success> | B<notfound> | B<unavail> | B<tryagain>"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:199
msgid "I<ACTION> =E<gt> B<return> | B<continue> | B<merge>"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:204
msgid ""
"The ! negates the test, matching all possible results except the one "
"specified.  The case of the keywords is not significant."
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:209
msgid ""
"The I<STATUS> value is matched against the result of the lookup function "
"called by the preceding service specification, and can be one of:"
msgstr ""

#. type: TP
#: build/C/man5/nsswitch.conf.5:210
#, no-wrap
msgid "B<success>"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:214
msgid ""
"No error occurred and the requested entry is returned.  The default action "
"for this condition is \"return\"."
msgstr ""

#. type: TP
#: build/C/man5/nsswitch.conf.5:214
#, no-wrap
msgid "B<notfound>"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:218
msgid ""
"The lookup succeeded, but the requested entry was not found.  The default "
"action for this condition is \"continue\"."
msgstr ""

#. type: TP
#: build/C/man5/nsswitch.conf.5:218
#, no-wrap
msgid "B<unavail>"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:225
msgid ""
"The service is permanently unavailable.  This can mean either that the "
"required file cannot be read, or, for network services, that the server is "
"not available or does not allow queries.  The default action for this "
"condition is \"continue\"."
msgstr ""

#. type: TP
#: build/C/man5/nsswitch.conf.5:225
#, no-wrap
msgid "B<tryagain>"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:231
msgid ""
"The service is temporarily unavailable.  This could mean a file is locked or "
"a server currently cannot accept more connections.  The default action for "
"this condition is \"continue\"."
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:236
msgid "The I<ACTION> value can be one of:"
msgstr ""

#. type: TP
#: build/C/man5/nsswitch.conf.5:237
#, no-wrap
msgid "B<return>"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:249
msgid ""
"Return a result now.  Do not call any further lookup functions.  However, "
"for compatibility reasons, if this is the selected action for the B<group> "
"database and the B<notfound> status, and the configuration file does not "
"contain the B<initgroups> line, the next lookup function is always called, "
"without affecting the search result."
msgstr ""

#. type: TP
#: build/C/man5/nsswitch.conf.5:249
#, no-wrap
msgid "B<continue>"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:252
msgid "Call the next lookup function."
msgstr ""

#. type: TP
#: build/C/man5/nsswitch.conf.5:252
#, no-wrap
msgid "B<merge>"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:266
msgid ""
"I<[SUCCESS=merge]> is used between two database entries.  When a group is "
"located in the first of the two group entries, processing will continue on "
"to the next one.  If the group is also found in the next entry (and the "
"group name and GID are an exact match), the member list of the second entry "
"will be added to the group object to be returned.  Available since glibc "
"2.24.  Note that merging will not be done for B<getgrent>(3)  nor will "
"duplicate members be pruned when they occur in both entries being merged."
msgstr ""

#. type: SS
#: build/C/man5/nsswitch.conf.5:267
#, no-wrap
msgid "Compatibility mode (compat)"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:272
msgid ""
"The NSS \"compat\" service is similar to \"files\" except that it "
"additionally permits special entries in corresponding files for granting "
"users or members of netgroups access to the system.  The following entries "
"are valid in this mode:"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:279
msgid "For B<passwd> and B<shadow> databases:"
msgstr ""

#. type: TP
#: build/C/man5/nsswitch.conf.5:280
#, no-wrap
msgid "B<+>I<user>"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:285
msgid "Include the specified I<user> from the NIS passwd/shadow map."
msgstr ""

#. type: TP
#: build/C/man5/nsswitch.conf.5:285
#, no-wrap
msgid "B<+@>I<netgroup>"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:289
msgid "Include all users in the given I<netgroup>."
msgstr ""

#. type: TP
#: build/C/man5/nsswitch.conf.5:289
#, no-wrap
msgid "B<->I<user>"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:294
msgid "Exclude the specified I<user> from the NIS passwd/shadow map."
msgstr ""

#. type: TP
#: build/C/man5/nsswitch.conf.5:294
#, no-wrap
msgid "B<-@>I<netgroup>"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:298
msgid "Exclude all users in the given I<netgroup>."
msgstr ""

#. type: TP
#: build/C/man5/nsswitch.conf.5:298 build/C/man5/nsswitch.conf.5:318
#, no-wrap
msgid "B<+>"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:302
msgid ""
"Include every user, except previously excluded ones, from the NIS "
"passwd/shadow map."
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:307
msgid "For B<group> database:"
msgstr ""

#. type: TP
#: build/C/man5/nsswitch.conf.5:308
#, no-wrap
msgid "B<+>I<group>"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:313
msgid "Include the specified I<group> from the NIS group map."
msgstr ""

#. type: TP
#: build/C/man5/nsswitch.conf.5:313
#, no-wrap
msgid "B<->I<group>"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:318
msgid "Exclude the specified I<group> from the NIS group map."
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:322
msgid ""
"Include every group, except previously excluded ones, from the NIS group "
"map."
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:332
msgid ""
"By default, the source is \"nis\", but this may be overridden by specifying "
"any NSS service except \"compat\" itself as the source for the "
"pseudo-databases B<passwd_compat>, B<group_compat>, and B<shadow_compat>."
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:339
msgid ""
"A service named I<SERVICE> is implemented by a shared object library named "
"I<libnss_SERVICE.so.>B<X> that resides in I</lib>."
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:344
msgid "NSS configuration file."
msgstr ""

#. type: TP
#: build/C/man5/nsswitch.conf.5:344
#, no-wrap
msgid "I</lib/libnss_compat.so.>B<X>"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:347
msgid "implements \"compat\" source."
msgstr ""

#. type: TP
#: build/C/man5/nsswitch.conf.5:347
#, no-wrap
msgid "I</lib/libnss_db.so.>B<X>"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:350
msgid "implements \"db\" source."
msgstr ""

#. type: TP
#: build/C/man5/nsswitch.conf.5:350
#, no-wrap
msgid "I</lib/libnss_dns.so.>B<X>"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:353
msgid "implements \"dns\" source."
msgstr ""

#. type: TP
#: build/C/man5/nsswitch.conf.5:353
#, no-wrap
msgid "I</lib/libnss_files.so.>B<X>"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:356
msgid "implements \"files\" source."
msgstr ""

#. type: TP
#: build/C/man5/nsswitch.conf.5:356
#, no-wrap
msgid "I</lib/libnss_hesiod.so.>B<X>"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:359
msgid "implements \"hesiod\" source."
msgstr ""

#. type: TP
#: build/C/man5/nsswitch.conf.5:359
#, no-wrap
msgid "I</lib/libnss_nis.so.>B<X>"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:362
msgid "implements \"nis\" source."
msgstr ""

#. type: TP
#: build/C/man5/nsswitch.conf.5:362
#, no-wrap
msgid "I</lib/libnss_nisplus.so.>B<X>"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:365
msgid "implements \"nisplus\" source."
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:370
msgid ""
"The following files are read when \"files\" source is specified for "
"respective databases:"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:375
msgid "I</etc/aliases>"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:378
msgid "I</etc/ethers>"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:381 build/C/man5/nsswitch.conf.5:387
msgid "I</etc/group>"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:390 build/C/man3/setnetgrent.3:93
msgid "I</etc/netgroup>"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:396
msgid "I</etc/passwd>"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:402
msgid "I</etc/publickey>"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:405
msgid "I</etc/rpc>"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:411
msgid "I</etc/shadow>"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:419
msgid ""
"Within each process that uses B<nsswitch.conf>, the entire file is read only "
"once.  If the file is later changed, the process will continue using the old "
"configuration."
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:432
msgid ""
"Traditionally, there was only a single source for service information, often "
"in the form of a single configuration file (e.g., I</etc/passwd>).  However, "
"as other name services, such as the Network Information Service (NIS) and "
"the Domain Name Service (DNS), became popular, a method was needed that "
"would be more flexible than fixed search orders coded into the C library.  "
"The Name Service Switch mechanism, which was based on the mechanism used by "
"Sun Microsystems in the Solaris 2 C library, introduced a cleaner solution "
"to the problem."
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:435
msgid "B<getent>(1), B<nss>(5)"
msgstr ""

#. type: TH
#: build/C/man7/packet.7:12
#, no-wrap
msgid "PACKET"
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:15
msgid "packet - packet interface on device level"
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:20
#, no-wrap
msgid ""
"B<#include E<lt>sys/socket.hE<gt>>\n"
"B<#include E<lt>linux/if_packet.hE<gt>>\n"
"B<#include E<lt>net/ethernet.hE<gt> /* the L2 protocols */>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:22
#, no-wrap
msgid ""
"B<packet_socket = socket(AF_PACKET, int >I<socket_type>B<, int "
">I<protocol>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:28
msgid ""
"Packet sockets are used to receive or send raw packets at the device driver "
"(OSI Layer 2) level.  They allow the user to implement protocol modules in "
"user space on top of the physical layer."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:50
msgid ""
"The I<socket_type> is either B<SOCK_RAW> for raw packets including the "
"link-level header or B<SOCK_DGRAM> for cooked packets with the link-level "
"header removed.  The link-level header information is available in a common "
"format in a I<sockaddr_ll> structure.  I<protocol> is the IEEE 802.3 "
"protocol number in network byte order.  See the "
"I<E<lt>linux/if_ether.hE<gt>> include file for a list of allowed protocols.  "
"When protocol is set to B<htons(ETH_P_ALL)>, then all protocols are "
"received.  All incoming packets of that protocol type will be passed to the "
"packet socket before they are passed to the protocols implemented in the "
"kernel."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:54
msgid ""
"In order to create a packet socket, a process must have the B<CAP_NET_RAW> "
"capability in the user namespace that governs its network namespace."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:72
msgid ""
"B<SOCK_RAW> packets are passed to and from the device driver without any "
"changes in the packet data.  When receiving a packet, the address is still "
"parsed and passed in a standard I<sockaddr_ll> address structure.  When "
"transmitting a packet, the user-supplied buffer should contain the "
"physical-layer header.  That packet is then queued unmodified to the network "
"driver of the interface defined by the destination address.  Some device "
"drivers always add other headers.  B<SOCK_RAW> is similar to but not "
"compatible with the obsolete B<AF_INET/SOCK_PACKET> of Linux 2.0."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:82
msgid ""
"B<SOCK_DGRAM> operates on a slightly higher level.  The physical header is "
"removed before the packet is passed to the user.  Packets sent through a "
"B<SOCK_DGRAM> packet socket get a suitable physical-layer header based on "
"the information in the I<sockaddr_ll> destination address before they are "
"queued."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:97
msgid ""
"By default, all packets of the specified protocol type are passed to a "
"packet socket.  To get packets only from a specific interface use B<bind>(2)  "
"specifying an address in a I<struct sockaddr_ll> to bind the packet socket "
"to an interface.  Fields used for binding are I<sll_family> (should be "
"B<AF_PACKET>), I<sll_protocol>, and I<sll_ifindex>."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:101
msgid "The B<connect>(2)  operation is not supported on packet sockets."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:111
msgid ""
"When the B<MSG_TRUNC> flag is passed to B<recvmsg>(2), B<recv>(2), or "
"B<recvfrom>(2), the real length of the packet on the wire is always "
"returned, even when it is longer than the buffer."
msgstr ""

#. type: SS
#: build/C/man7/packet.7:111
#, no-wrap
msgid "Address types"
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:115
msgid "The I<sockaddr_ll> structure is a device-independent physical-layer address."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:127
#, no-wrap
msgid ""
"struct sockaddr_ll {\n"
"    unsigned short sll_family;   /* Always AF_PACKET */\n"
"    unsigned short sll_protocol; /* Physical-layer protocol */\n"
"    int            sll_ifindex;  /* Interface number */\n"
"    unsigned short sll_hatype;   /* ARP hardware type */\n"
"    unsigned char  sll_pkttype;  /* Packet type */\n"
"    unsigned char  sll_halen;    /* Length of address */\n"
"    unsigned char  sll_addr[8];  /* Physical-layer address */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:131
msgid "The fields of this structure are as follows:"
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:138
msgid ""
"I<sll_protocol> is the standard ethernet protocol type in network byte order "
"as defined in the I<E<lt>linux/if_ether.hE<gt>> include file.  It defaults "
"to the socket's protocol."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:148
msgid ""
"I<sll_ifindex> is the interface index of the interface (see "
"B<netdevice>(7)); 0 matches any interface (only permitted for binding).  "
"I<sll_hatype> is an ARP type as defined in the I<E<lt>linux/if_arp.hE<gt>> "
"include file."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:165
msgid ""
"I<sll_pkttype> contains the packet type.  Valid types are B<PACKET_HOST> for "
"a packet addressed to the local host, B<PACKET_BROADCAST> for a "
"physical-layer broadcast packet, B<PACKET_MULTICAST> for a packet sent to a "
"physical-layer multicast address, B<PACKET_OTHERHOST> for a packet to some "
"other host that has been caught by a device driver in promiscuous mode, and "
"B<PACKET_OUTGOING> for a packet originating from the local host that is "
"looped back to a packet socket.  These types make sense only for receiving."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:171
msgid ""
"I<sll_addr> and I<sll_halen> contain the physical-layer (e.g., IEEE 802.3) "
"address and its length.  The exact interpretation depends on the device."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:184
msgid ""
"When you send packets, it is enough to specify I<sll_family>, I<sll_addr>, "
"I<sll_halen>, I<sll_ifindex>, and I<sll_protocol>.  The other fields should "
"be 0.  I<sll_hatype> and I<sll_pkttype> are set on received packets for your "
"information."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:189
msgid ""
"Packet socket options are configured by calling B<setsockopt>(2)  with level "
"B<SOL_PACKET>."
msgstr ""

#. type: TP
#: build/C/man7/packet.7:189
#, no-wrap
msgid "B<PACKET_ADD_MEMBERSHIP>"
msgstr ""

#. type: TP
#: build/C/man7/packet.7:192
#, no-wrap
msgid "B<PACKET_DROP_MEMBERSHIP>"
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:204
msgid ""
"Packet sockets can be used to configure physical-layer multicasting and "
"promiscuous mode.  B<PACKET_ADD_MEMBERSHIP> adds a binding and "
"B<PACKET_DROP_MEMBERSHIP> drops it.  They both expect a I<packet_mreq> "
"structure as argument:"
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:213
#, no-wrap
msgid ""
"struct packet_mreq {\n"
"    int            mr_ifindex;    /* interface index */\n"
"    unsigned short mr_type;       /* action */\n"
"    unsigned short mr_alen;       /* address length */\n"
"    unsigned char  mr_address[8]; /* physical-layer address */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:234
msgid ""
"I<mr_ifindex> contains the interface index for the interface whose status "
"should be changed.  The I<mr_type> field specifies which action to perform.  "
"B<PACKET_MR_PROMISC> enables receiving all packets on a shared medium (often "
"known as \"promiscuous mode\"), B<PACKET_MR_MULTICAST> binds the socket to "
"the physical-layer multicast group specified in I<mr_address> and "
"I<mr_alen>, and B<PACKET_MR_ALLMULTI> sets the socket up to receive all "
"multicast packets arriving at the interface."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:240
msgid ""
"In addition, the traditional ioctls B<SIOCSIFFLAGS>, B<SIOCADDMULTI>, "
"B<SIOCDELMULTI> can be used for the same purpose."
msgstr ""

#. type: TP
#: build/C/man7/packet.7:240
#, no-wrap
msgid "B<PACKET_AUXDATA> (since Linux 2.6.21)"
msgstr ""

#.  commit 8dc4194474159660d7f37c495e3fc3f10d0db8cc
#. type: Plain text
#: build/C/man7/packet.7:250
msgid ""
"If this binary option is enabled, the packet socket passes a metadata "
"structure along with each packet in the B<recvmsg>(2)  control field.  The "
"structure can be read with B<cmsg>(3).  It is defined as"
msgstr ""

#.  commit a0cdfcf39362410d5ea983f4daf67b38de129408 added tp_vlan_tpid
#. type: Plain text
#: build/C/man7/packet.7:264
#, no-wrap
msgid ""
"struct tpacket_auxdata {\n"
"    __u32 tp_status;\n"
"    __u32 tp_len;      /* packet length */\n"
"    __u32 tp_snaplen;  /* captured length */\n"
"    __u16 tp_mac;\n"
"    __u16 tp_net;\n"
"    __u16 tp_vlan_tci;\n"
"    __u16 tp_vlan_tpid; /* Since Linux 3.14; earlier, these\n"
"                           were unused padding bytes */\n"
"};\n"
msgstr ""

#. type: TP
#: build/C/man7/packet.7:266
#, no-wrap
msgid "B<PACKET_FANOUT> (since Linux 3.1)"
msgstr ""

#.  commit dc99f600698dcac69b8f56dda9a8a00d645c5ffc
#. type: Plain text
#: build/C/man7/packet.7:288
msgid ""
"To scale processing across threads, packet sockets can form a fanout group.  "
"In this mode, each matching packet is enqueued onto only one socket in the "
"group.  A socket joins a fanout group by calling B<setsockopt>(2)  with "
"level B<SOL_PACKET> and option B<PACKET_FANOUT>.  Each network namespace can "
"have up to 65536 independent groups.  A socket selects a group by encoding "
"the ID in the first 16 bits of the integer option value.  The first packet "
"socket to join a group implicitly creates it.  To successfully join an "
"existing group, subsequent packet sockets must have the same protocol, "
"device settings, fanout mode and flags (see below).  Packet sockets can "
"leave a fanout group only by closing the socket.  The group is deleted when "
"the last socket is closed."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:291
msgid ""
"Fanout supports multiple algorithms to spread traffic between sockets, as "
"follows:"
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:300
msgid ""
"The default mode, B<PACKET_FANOUT_HASH>, sends packets from the same flow to "
"the same socket to maintain per-flow ordering.  For each packet, it chooses "
"a socket by taking the packet flow hash modulo the number of sockets in the "
"group, where a flow hash is a hash over network-layer address and optional "
"transport-layer port fields."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:304
msgid ""
"The load-balance mode B<PACKET_FANOUT_LB> implements a round-robin "
"algorithm."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:307
msgid ""
"B<PACKET_FANOUT_CPU> selects the socket based on the CPU that the packet "
"arrived on."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:311
msgid ""
"B<PACKET_FANOUT_ROLLOVER> processes all data on a single socket, moving to "
"the next when one becomes backlogged."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:314
msgid ""
"B<PACKET_FANOUT_RND> selects the socket using a pseudo-random number "
"generator."
msgstr ""

#.  commit 2d36097d26b5991d71a2cf4a20c1a158f0f1bfcd
#. type: Plain text
#: build/C/man7/packet.7:319
msgid ""
"B<PACKET_FANOUT_QM> (available since Linux 3.14)  selects the socket using "
"the recorded queue_mapping of the received skb."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:335
msgid ""
"Fanout modes can take additional options.  IP fragmentation causes packets "
"from the same flow to have different flow hashes.  The flag "
"B<PACKET_FANOUT_FLAG_DEFRAG>, if set, causes packets to be defragmented "
"before fanout is applied, to preserve order even in this case.  Fanout mode "
"and options are communicated in the second 16 bits of the integer option "
"value.  The flag B<PACKET_FANOUT_FLAG_ROLLOVER> enables the roll over "
"mechanism as a backup strategy: if the original fanout algorithm selects a "
"backlogged socket, the packet rolls over to the next available one."
msgstr ""

#. type: TP
#: build/C/man7/packet.7:335
#, no-wrap
msgid "B<PACKET_LOSS> (with B<PACKET_TX_RING>)"
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:358
msgid ""
"When a malformed packet is encountered on a transmit ring, the default is to "
"reset its I<tp_status> to B<TP_STATUS_WRONG_FORMAT> and abort the "
"transmission immediately.  The malformed packet blocks itself and "
"subsequently enqueued packets from being sent.  The format error must be "
"fixed, the associated I<tp_status> reset to B<TP_STATUS_SEND_REQUEST>, and "
"the transmission process restarted via B<send>(2).  However, if "
"B<PACKET_LOSS> is set, any malformed packet will be skipped, its "
"I<tp_status> reset to B<TP_STATUS_AVAILABLE>, and the transmission process "
"continued."
msgstr ""

#. type: TP
#: build/C/man7/packet.7:358
#, no-wrap
msgid "B<PACKET_RESERVE> (with B<PACKET_RX_RING>)"
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:363
msgid ""
"By default, a packet receive ring writes packets immediately following the "
"metadata structure and alignment padding.  This integer option reserves "
"additional headroom."
msgstr ""

#. type: TP
#: build/C/man7/packet.7:363
#, no-wrap
msgid "B<PACKET_RX_RING>"
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:405
msgid ""
"Create a memory-mapped ring buffer for asynchronous packet reception.  The "
"packet socket reserves a contiguous region of application address space, "
"lays it out into an array of packet slots and copies packets (up to "
"I<tp_snaplen>)  into subsequent slots.  Each packet is preceded by a "
"metadata structure similar to I<tpacket_auxdata>.  The protocol fields "
"encode the offset to the data from the start of the metadata header.  "
"I<tp_net> stores the offset to the network layer.  If the packet socket is "
"of type B<SOCK_DGRAM>, then I<tp_mac> is the same.  If it is of type "
"B<SOCK_RAW>, then that field stores the offset to the link-layer frame.  "
"Packet socket and application communicate the head and tail of the ring "
"through the I<tp_status> field.  The packet socket owns all slots with "
"I<tp_status> equal to B<TP_STATUS_KERNEL>.  After filling a slot, it changes "
"the status of the slot to transfer ownership to the application.  During "
"normal operation, the new I<tp_status> value has at least the "
"B<TP_STATUS_USER> bit set to signal that a received packet has been stored.  "
"When the application has finished processing a packet, it transfers "
"ownership of the slot back to the socket by setting I<tp_status> equal to "
"B<TP_STATUS_KERNEL>."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:410
msgid ""
"Packet sockets implement multiple variants of the packet ring.  The "
"implementation details are described in "
"I<Documentation/networking/packet_mmap.rst> in the Linux kernel source tree."
msgstr ""

#. type: TP
#: build/C/man7/packet.7:410
#, no-wrap
msgid "B<PACKET_STATISTICS>"
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:413
msgid "Retrieve packet socket statistics in the form of a structure"
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:420
#, no-wrap
msgid ""
"struct tpacket_stats {\n"
"    unsigned int tp_packets;  /* Total packet count */\n"
"    unsigned int tp_drops;    /* Dropped packet count */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:426
msgid ""
"Receiving statistics resets the internal counters.  The statistics structure "
"differs when using a ring of variant B<TPACKET_V3>."
msgstr ""

#. type: TP
#: build/C/man7/packet.7:426
#, no-wrap
msgid "B<PACKET_TIMESTAMP> (with B<PACKET_RX_RING>; since Linux 2.6.36)"
msgstr ""

#.  commit 614f60fa9d73a9e8fdff3df83381907fea7c5649
#. type: Plain text
#: build/C/man7/packet.7:436
msgid ""
"The packet receive ring always stores a timestamp in the metadata header.  "
"By default, this is a software generated timestamp generated when the packet "
"is copied into the ring.  This integer option selects the type of "
"timestamp.  Besides the default, it support the two hardware formats "
"described in I<Documentation/networking/timestamping.rst> in the Linux "
"kernel source tree."
msgstr ""

#. type: TP
#: build/C/man7/packet.7:436
#, no-wrap
msgid "B<PACKET_TX_RING> (since Linux 2.6.31)"
msgstr ""

#.  commit 69e3c75f4d541a6eb151b3ef91f34033cb3ad6e1
#. type: Plain text
#: build/C/man7/packet.7:471
msgid ""
"Create a memory-mapped ring buffer for packet transmission.  This option is "
"similar to B<PACKET_RX_RING> and takes the same arguments.  The application "
"writes packets into slots with I<tp_status> equal to B<TP_STATUS_AVAILABLE> "
"and schedules them for transmission by changing I<tp_status> to "
"B<TP_STATUS_SEND_REQUEST>.  When packets are ready to be transmitted, the "
"application calls B<send>(2)  or a variant thereof.  The I<buf> and I<len> "
"fields of this call are ignored.  If an address is passed using B<sendto>(2)  "
"or B<sendmsg>(2), then that overrides the socket default.  On successful "
"transmission, the socket resets I<tp_status> to B<TP_STATUS_AVAILABLE>.  It "
"immediately aborts the transmission on error unless B<PACKET_LOSS> is set."
msgstr ""

#. type: TP
#: build/C/man7/packet.7:471
#, no-wrap
msgid "B<PACKET_VERSION> (with B<PACKET_RX_RING>; since Linux 2.6.27)"
msgstr ""

#.  commit bbd6ef87c544d88c30e4b762b1b61ef267a7d279
#. type: Plain text
#: build/C/man7/packet.7:480
msgid ""
"By default, B<PACKET_RX_RING> creates a packet receive ring of variant "
"B<TPACKET_V1>.  To create another variant, configure the desired variant by "
"setting this integer option before creating the ring."
msgstr ""

#. type: TP
#: build/C/man7/packet.7:480
#, no-wrap
msgid "B<PACKET_QDISC_BYPASS> (since Linux 3.14)"
msgstr ""

#.  commit d346a3fae3ff1d99f5d0c819bf86edf9094a26a1
#. type: Plain text
#: build/C/man7/packet.7:495
msgid ""
"By default, packets sent through packet sockets pass through the kernel's "
"qdisc (traffic control) layer, which is fine for the vast majority of use "
"cases.  For traffic generator appliances using packet sockets that intend to "
"brute-force flood the network\\(emfor example, to test devices under load in "
"a similar fashion to pktgen\\(emthis layer can be bypassed by setting this "
"integer option to 1.  A side effect is that packet buffering in the qdisc "
"layer is avoided, which will lead to increased drops when network device "
"transmit queues are busy; therefore, use at your own risk."
msgstr ""

#.  FIXME Document SIOCGSTAMPNS
#. type: Plain text
#: build/C/man7/packet.7:502
msgid ""
"B<SIOCGSTAMP> can be used to receive the timestamp of the last received "
"packet.  Argument is a I<struct timeval> variable."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:508
msgid ""
"In addition, all standard ioctls defined in B<netdevice>(7)  and "
"B<socket>(7)  are valid on packet sockets."
msgstr ""

#. type: SS
#: build/C/man7/packet.7:508 build/C/man7/raw.7:136 build/C/man7/tcp.7:1324 build/C/man7/udp.7:103
#, no-wrap
msgid "Error handling"
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:512
msgid ""
"Packet sockets do no error handling other than errors occurred while passing "
"the packet to the device driver.  They don't have the concept of a pending "
"error."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:516
msgid "Unknown multicast group address passed."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:519
msgid "User passed invalid memory address."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:522 build/C/man7/raw.7:160
msgid "Invalid argument."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:525
msgid "Packet is bigger than interface MTU."
msgstr ""

#. type: TP
#: build/C/man7/packet.7:525
#, no-wrap
msgid "B<ENETDOWN>"
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:528
msgid "Interface is not up."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:531
msgid "Not enough memory to allocate the packet."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:534
msgid "Unknown device name or interface index specified in interface address."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:537
msgid "No packet received."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:540
msgid "No interface address passed."
msgstr ""

#. type: TP
#: build/C/man7/packet.7:540
#, no-wrap
msgid "B<ENXIO>"
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:543
msgid "Interface address contained an invalid interface index."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:546
msgid "User has insufficient privileges to carry out this operation."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:548
msgid "In addition, other errors may be generated by the low-level driver."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:553
msgid ""
"B<AF_PACKET> is a new feature in Linux 2.2.  Earlier Linux versions "
"supported only B<SOCK_PACKET>."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:562
msgid ""
"For portable programs it is suggested to use B<AF_PACKET> via B<pcap>(3); "
"although this covers only a subset of the B<AF_PACKET> features."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:583
msgid ""
"The B<SOCK_DGRAM> packet sockets make no attempt to create or parse the IEEE "
"802.2 LLC header for a IEEE 802.3 frame.  When B<ETH_P_802_3> is specified "
"as protocol for sending the kernel creates the 802.3 frame and fills out the "
"length field; the user has to supply the LLC header to get a fully "
"conforming packet.  Incoming 802.3 packets are not multiplexed on the "
"DSAP/SSAP protocol fields; instead they are supplied to the user as protocol "
"B<ETH_P_802_2> with the LLC header prefixed.  It is thus not possible to "
"bind to B<ETH_P_802_3>; bind to B<ETH_P_802_2> instead and do the protocol "
"multiplex yourself.  The default for sending is the standard Ethernet DIX "
"encapsulation with the protocol filled in."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:585
msgid "Packet sockets are not subject to the input or output firewall chains."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:587
msgid "In Linux 2.0, the only way to get a packet socket was with the call:"
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:589
#, no-wrap
msgid "    socket(AF_INET, SOCK_PACKET, protocol)\n"
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:597
msgid ""
"This is still supported, but deprecated and strongly discouraged.  The main "
"difference between the two methods is that B<SOCK_PACKET> uses the old "
"I<struct sockaddr_pkt> to specify an interface, which doesn't provide "
"physical-layer independence."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:605
#, no-wrap
msgid ""
"struct sockaddr_pkt {\n"
"    unsigned short spkt_family;\n"
"    unsigned char  spkt_device[14];\n"
"    unsigned short spkt_protocol;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:617
msgid ""
"I<spkt_family> contains the device type, I<spkt_protocol> is the IEEE 802.3 "
"protocol type as defined in I<E<lt>sys/if_ether.hE<gt>> and I<spkt_device> "
"is the device name as a null-terminated string, for example, eth0."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:619
msgid "This structure is obsolete and should not be used in new code."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:621
msgid "The IEEE 802.2/803.3 LLC handling could be considered as a bug."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:623
msgid "Socket filters are not documented."
msgstr ""

#.  .SH CREDITS
#.  This man page was written by Andi Kleen with help from Matthew Wilcox.
#.  AF_PACKET in Linux 2.2 was implemented
#.  by Alexey Kuznetsov, based on code by Alan Cox and others.
#. type: Plain text
#: build/C/man7/packet.7:635
msgid ""
"The B<MSG_TRUNC> B<recvmsg>(2)  extension is an ugly hack and should be "
"replaced by a control message.  There is currently no way to get the "
"original destination address of packets via B<SOCK_DGRAM>."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:642
msgid ""
"B<socket>(2), B<pcap>(3), B<capabilities>(7), B<ip>(7), B<raw>(7), "
"B<socket>(7)"
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:645
msgid ""
"RFC\\ 894 for the standard IP Ethernet encapsulation.  RFC\\ 1700 for the "
"IEEE 802.3 IP encapsulation."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:649
msgid "The I<E<lt>linux/if_ether.hE<gt>> include file for physical-layer protocols."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:658
msgid ""
"The Linux kernel source tree.  I<Documentation/networking/filter.rst> "
"describes how to apply Berkeley Packet Filters to packet sockets.  "
"I<tools/testing/selftests/net/psock_tpacket.c> contains example source code "
"for all available versions of B<PACKET_RX_RING> and B<PACKET_TX_RING>."
msgstr ""

#. type: TH
#: build/C/man5/protocols.5:29
#, no-wrap
msgid "PROTOCOLS"
msgstr ""

#. type: TH
#: build/C/man5/protocols.5:29
#, no-wrap
msgid "2012-08-05"
msgstr ""

#. type: Plain text
#: build/C/man5/protocols.5:32
msgid "protocols - protocols definition file"
msgstr ""

#. type: Plain text
#: build/C/man5/protocols.5:40
msgid ""
"This file is a plain ASCII file, describing the various DARPA internet "
"protocols that are available from the TCP/IP subsystem.  It should be "
"consulted instead of using the numbers in the ARPA include files, or, even "
"worse, just guessing them.  These numbers will occur in the protocol field "
"of any IP header."
msgstr ""

#.  .. by the DDN Network Information Center.
#. type: Plain text
#: build/C/man5/protocols.5:46
msgid ""
"Keep this file untouched since changes would result in incorrect IP "
"packages.  Protocol numbers and names are specified by the IANA (Internet "
"Assigned Numbers Authority)."
msgstr ""

#. type: Plain text
#: build/C/man5/protocols.5:48
msgid "Each line is of the following format:"
msgstr ""

#. type: Plain text
#: build/C/man5/protocols.5:51
msgid "I<protocol number aliases ...>"
msgstr ""

#. type: Plain text
#: build/C/man5/protocols.5:57
msgid ""
"where the fields are delimited by spaces or tabs.  Empty lines are ignored.  "
"If a line contains a hash mark (#), the hash mark and the part of the line "
"following it are ignored."
msgstr ""

#. type: TP
#: build/C/man5/protocols.5:59 build/C/man5/services.5:109
#, no-wrap
msgid "I<protocol>"
msgstr ""

#. type: Plain text
#: build/C/man5/protocols.5:67
msgid "the native name for the protocol.  For example I<ip>, I<tcp>, or I<udp>."
msgstr ""

#. type: Plain text
#: build/C/man5/protocols.5:71
msgid ""
"the official number for this protocol as it will appear within the IP "
"header."
msgstr ""

#. type: Plain text
#: build/C/man5/protocols.5:74
msgid "optional aliases for the protocol."
msgstr ""

#.  The following is not true as at glibc 2.8 (a line with a comma is
#.  ignored by getservent()); it's not clear if/when it was ever true.
#.    As a backward compatibility feature, the slash (/) between the
#.    .I port
#.    number and
#.    .I protocol
#.    name can in fact be either a slash or a comma (,).
#.    Use of the comma in
#.    modern installations is deprecated.
#. type: Plain text
#: build/C/man5/protocols.5:77 build/C/man5/services.5:165
msgid ""
"This file might be distributed over a network using a network-wide naming "
"service like Yellow Pages/NIS or BIND/Hesiod."
msgstr ""

#. type: Plain text
#: build/C/man5/protocols.5:81
msgid "The protocols definition file."
msgstr ""

#. type: Plain text
#: build/C/man5/protocols.5:83
msgid "B<getprotoent>(3)"
msgstr ""

#. type: Plain text
#: build/C/man5/protocols.5:86
msgid "E<.UR http://www.iana.org\\:/assignments\\:/protocol-numbers> E<.UE>"
msgstr ""

#. type: TH
#: build/C/man7/raw.7:12
#, no-wrap
msgid "RAW"
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:15
msgid "raw - Linux IPv4 raw sockets"
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:21
msgid "B<raw_socket = socket(AF_INET, SOCK_RAW, int >I<protocol>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:25
msgid ""
"Raw sockets allow new IPv4 protocols to be implemented in user space.  A raw "
"socket receives or sends the raw datagram not including link level headers."
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:31
msgid ""
"The IPv4 layer generates an IP header when sending a packet unless the "
"B<IP_HDRINCL> socket option is enabled on the socket.  When it is enabled, "
"the packet must contain an IP header.  For receiving, the IP header is "
"always included in the packet."
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:35
msgid ""
"In order to create a raw socket, a process must have the B<CAP_NET_RAW> "
"capability in the user namespace that governs its network namespace."
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:46
msgid ""
"All packets or errors matching the I<protocol> number specified for the raw "
"socket are passed to this socket.  For a list of the allowed protocols, see "
"the IANA list of assigned protocol numbers at E<.UR "
"http://www.iana.org/assignments/protocol-numbers/> E<.UE> and "
"B<getprotobyname>(3)."
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:56
msgid ""
"A protocol of B<IPPROTO_RAW> implies enabled B<IP_HDRINCL> and is able to "
"send any IP protocol that is specified in the passed header.  Receiving of "
"all IP protocols via B<IPPROTO_RAW> is not possible using raw sockets."
msgstr ""

#. type: tbl table
#: build/C/man7/raw.7:61
#, no-wrap
msgid "IP Header fields modified on sending by B<IP_HDRINCL>"
msgstr ""

#. type: tbl table
#: build/C/man7/raw.7:62
#, no-wrap
msgid "IP Checksum"
msgstr ""

#. type: tbl table
#: build/C/man7/raw.7:62 build/C/man7/raw.7:65
#, no-wrap
msgid "Always filled in"
msgstr ""

#. type: tbl table
#: build/C/man7/raw.7:63
#, no-wrap
msgid "Source Address"
msgstr ""

#. type: tbl table
#: build/C/man7/raw.7:63 build/C/man7/raw.7:64
#, no-wrap
msgid "Filled in when zero"
msgstr ""

#. type: tbl table
#: build/C/man7/raw.7:64
#, no-wrap
msgid "Packet ID"
msgstr ""

#. type: tbl table
#: build/C/man7/raw.7:65
#, no-wrap
msgid "Total Length"
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:79
msgid ""
"If B<IP_HDRINCL> is specified and the IP header has a nonzero destination "
"address, then the destination address of the socket is used to route the "
"packet.  When B<MSG_DONTROUTE> is specified, the destination address should "
"refer to a local interface, otherwise a routing table lookup is done anyway "
"but gatewayed routes are ignored."
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:87
msgid ""
"If B<IP_HDRINCL> isn't set, then IP header options can be set on raw sockets "
"with B<setsockopt>(2); see B<ip>(7)  for more information."
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:92
msgid ""
"Starting with Linux 2.2, all IP header fields and options can be set using "
"IP socket options.  This means raw sockets are usually needed only for new "
"protocols or protocols with no user interface (like ICMP)."
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:96
msgid ""
"When a packet is received, it is passed to any raw sockets which have been "
"bound to its protocol before it is passed to other protocol handlers (e.g., "
"kernel protocol modules)."
msgstr ""

#.  commit f59fc7f30b710d45aadf715460b3e60dbe9d3418
#. type: Plain text
#: build/C/man7/raw.7:114
msgid ""
"For sending and receiving datagrams (B<sendto>(2), B<recvfrom>(2), and "
"similar), raw sockets use the standard I<sockaddr_in> address structure "
"defined in B<ip>(7).  The I<sin_port> field could be used to specify the IP "
"protocol number, but it is ignored for sending in Linux 2.2 and later, and "
"should be always set to 0 (see BUGS).  For incoming packets, I<sin_port> is "
"set to zero."
msgstr ""

#.  Or SOL_RAW on Linux
#. type: Plain text
#: build/C/man7/raw.7:123
msgid ""
"Raw socket options can be set with B<setsockopt>(2)  and read with "
"B<getsockopt>(2)  by passing the B<IPPROTO_RAW> family flag."
msgstr ""

#. type: TP
#: build/C/man7/raw.7:123
#, no-wrap
msgid "B<ICMP_FILTER>"
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:131
msgid ""
"Enable a special filter for raw sockets bound to the B<IPPROTO_ICMP> "
"protocol.  The value has a bit set for each ICMP message type which should "
"be filtered out.  The default is to filter no ICMP messages."
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:136
msgid ""
"In addition, all B<ip>(7)  B<IPPROTO_IP> socket options valid for datagram "
"sockets are supported."
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:149
msgid ""
"Errors originating from the network are passed to the user only when the "
"socket is connected or the B<IP_RECVERR> flag is enabled.  For connected "
"sockets, only B<EMSGSIZE> and B<EPROTO> are passed for compatibility.  With "
"B<IP_RECVERR>, all network errors are saved in the error queue."
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:154
msgid ""
"User tried to send to a broadcast address without having the broadcast flag "
"set on the socket."
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:157
msgid "An invalid memory address was supplied."
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:167
msgid ""
"Packet too big.  Either Path MTU Discovery is enabled (the "
"B<IP_MTU_DISCOVER> socket flag) or the packet size exceeds the maximum "
"allowed IPv4 packet size of 64\\ kB."
msgstr ""

#. type: TP
#: build/C/man7/raw.7:167 build/C/man7/unix.7:734
#, no-wrap
msgid "B<EOPNOTSUPP>"
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:171
msgid "Invalid flag has been passed to a socket call (like B<MSG_OOB>)."
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:177
msgid ""
"The user doesn't have permission to open raw sockets.  Only processes with "
"an effective user ID of 0 or the B<CAP_NET_RAW> attribute may do that."
msgstr ""

#. type: TP
#: build/C/man7/raw.7:177
#, no-wrap
msgid "B<EPROTO>"
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:180
msgid "An ICMP error has arrived reporting a parameter problem."
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:186
msgid ""
"B<IP_RECVERR> and B<ICMP_FILTER> are new in Linux 2.2.  They are Linux "
"extensions and should not be used in portable programs."
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:192
msgid ""
"Linux 2.0 enabled some bug-to-bug compatibility with BSD in the raw socket "
"code when the B<SO_BSDCOMPAT> socket option was set; since Linux 2.2, this "
"option no longer has that effect."
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:210
msgid ""
"By default, raw sockets do path MTU (Maximum Transmission Unit) discovery.  "
"This means the kernel will keep track of the MTU to a specific target IP "
"address and return B<EMSGSIZE> when a raw packet write exceeds it.  When "
"this happens, the application should decrease the packet size.  Path MTU "
"discovery can be also turned off using the B<IP_MTU_DISCOVER> socket option "
"or the I</proc/sys/net/ipv4/ip_no_pmtu_disc> file, see B<ip>(7)  for "
"details.  When turned off, raw sockets will fragment outgoing packets that "
"exceed the interface MTU.  However, disabling it is not recommended for "
"performance and reliability reasons."
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:219
msgid ""
"A raw socket can be bound to a specific local address using the B<bind>(2)  "
"call.  If it isn't bound, all packets with the specified IP protocol are "
"received.  In addition, a raw socket can be bound to a specific network "
"device using B<SO_BINDTODEVICE>; see B<socket>(7)."
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:230
msgid ""
"An B<IPPROTO_RAW> socket is send only.  If you really want to receive all IP "
"packets, use a B<packet>(7)  socket with the B<ETH_P_IP> protocol.  Note "
"that packet sockets don't reassemble IP fragments, unlike raw sockets."
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:236
msgid ""
"If you want to receive all ICMP packets for a datagram socket, it is often "
"better to use B<IP_RECVERR> on that particular socket; see B<ip>(7)."
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:243
msgid ""
"Raw sockets may tap all IP protocols in Linux, even protocols like ICMP or "
"TCP which have a protocol module in the kernel.  In this case, the packets "
"are passed to both the kernel module and the raw socket(s).  This should not "
"be relied upon in portable programs, many other BSD socket implementation "
"have limitations here."
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:248
msgid ""
"Linux never changes headers passed from the user (except for filling in some "
"zeroed fields as described for B<IP_HDRINCL>).  This differs from many other "
"implementations of raw sockets."
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:251
msgid ""
"Raw sockets are generally rather unportable and should be avoided in "
"programs intended to be portable."
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:257
msgid ""
"Sending on raw sockets should take the IP protocol from I<sin_port>; this "
"ability was lost in Linux 2.2.  The workaround is to use B<IP_HDRINCL>."
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:259
msgid "Transparent proxy extensions are not described."
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:264
msgid ""
"When the B<IP_HDRINCL> option is set, datagrams will not be fragmented and "
"are limited to the interface MTU."
msgstr ""

#.  .SH AUTHORS
#.  This man page was written by Andi Kleen.
#. type: Plain text
#: build/C/man7/raw.7:274
msgid ""
"Setting the IP protocol for sending in I<sin_port> got lost in Linux 2.2.  "
"The protocol that the socket was bound to or that was specified in the "
"initial B<socket>(2)  call is always used."
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:280
msgid "B<recvmsg>(2), B<sendmsg>(2), B<capabilities>(7), B<ip>(7), B<socket>(7)"
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:287
msgid ""
"B<RFC\\ 1191> for path MTU discovery.  B<RFC\\ 791> and the "
"I<E<lt>linux/ip.hE<gt>> header file for the IP protocol."
msgstr ""

#. type: TH
#: build/C/man3/rcmd.3:43
#, no-wrap
msgid "RCMD"
msgstr ""

#. type: Plain text
#: build/C/man3/rcmd.3:48
msgid ""
"rcmd, rresvport, iruserok, ruserok, rcmd_af, rresvport_af, iruserok_af, "
"ruserok_af - routines for returning a stream to a remote command"
msgstr ""

#. type: Plain text
#: build/C/man3/rcmd.3:51
#, no-wrap
msgid ""
"B<#include E<lt>netdb.hE<gt> \\ \\ >/* Or E<lt>unistd.hE<gt> on some systems "
"*/\n"
msgstr ""

#. type: Plain text
#: build/C/man3/rcmd.3:54
#, no-wrap
msgid ""
"B<int rcmd(char **>I<ahost>B<, unsigned short >I<inport>B<, const char "
"*>I<locuser>B<,>\n"
"B<         const char *>I<remuser>B<, const char *>I<cmd>B<, int "
"*>I<fd2p>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/rcmd.3:56
#, no-wrap
msgid "B<int rresvport(int *>I<port>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/rcmd.3:59
#, no-wrap
msgid ""
"B<int iruserok(uint32_t >I<raddr>B<, int >I<superuser>B<,>\n"
"B<             const char *>I<ruser>B<, const char *>I<luser>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/rcmd.3:62
#, no-wrap
msgid ""
"B<int ruserok(const char *>I<rhost>B<, int >I<superuser>B<,>\n"
"B<            const char *>I<ruser>B<, const char *>I<luser>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/rcmd.3:66
#, no-wrap
msgid ""
"B<int rcmd_af(char **>I<ahost>B<, unsigned short >I<inport>B<, const char "
"*>I<locuser>B<,>\n"
"B<            const char *>I<remuser>B<, const char *>I<cmd>B<, int "
"*>I<fd2p>B<,>\n"
"B<            sa_family_t >I<af>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/rcmd.3:68
#, no-wrap
msgid "B<int rresvport_af(int *>I<port>B<, sa_family_t >I<af>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/rcmd.3:72
#, no-wrap
msgid ""
"B<int iruserok_af(const void *>I<raddr>B<, int >I<superuser>B<,>\n"
"B<                const char *>I<ruser>B<, const char *>I<luser>B<, "
"sa_family_t >I<af>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/rcmd.3:76
#, no-wrap
msgid ""
"B<int ruserok_af(const char *>I<rhost>B<, int >I<superuser>B<,>\n"
"B<               const char *>I<ruser>B<, const char *>I<luser>B<, "
"sa_family_t >I<af>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/rcmd.3:95
#, no-wrap
msgid ""
"B<rcmd>(),\n"
"B<rcmd_af>(),\n"
"B<rresvport>(),\n"
"B<rresvport_af>(),\n"
"B<iruserok>(),\n"
"B<iruserok_af>(),\n"
"B<ruserok>(),\n"
"B<ruserok_af>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man3/rcmd.3:116
msgid ""
"The B<rcmd>()  function is used by the superuser to execute a command on a "
"remote machine using an authentication scheme based on privileged port "
"numbers.  The B<rresvport>()  function returns a file descriptor to a socket "
"with an address in the privileged port space.  The B<iruserok>()  and "
"B<ruserok>()  functions are used by servers to authenticate clients "
"requesting service with B<rcmd>().  All four functions are used by the "
"B<rshd>(8)  server (among others)."
msgstr ""

#. type: SS
#: build/C/man3/rcmd.3:116
#, no-wrap
msgid "rcmd()"
msgstr ""

#. type: Plain text
#: build/C/man3/rcmd.3:131
msgid ""
"The B<rcmd>()  function looks up the host I<*ahost> using "
"B<gethostbyname>(3), returning -1 if the host does not exist.  Otherwise, "
"I<*ahost> is set to the standard name of the host and a connection is "
"established to a server residing at the well-known Internet port I<inport>."
msgstr ""

#. type: Plain text
#: build/C/man3/rcmd.3:160
msgid ""
"If the connection succeeds, a socket in the Internet domain of type "
"B<SOCK_STREAM> is returned to the caller, and given to the remote command as "
"I<stdin> and I<stdout>.  If I<fd2p> is nonzero, then an auxiliary channel to "
"a control process will be set up, and a file descriptor for it will be "
"placed in I<*fd2p>.  The control process will return diagnostic output from "
"the command (unit 2) on this channel, and will also accept bytes on this "
"channel as being UNIX signal numbers, to be forwarded to the process group "
"of the command.  If I<fd2p> is 0, then the I<stderr> (unit 2 of the remote "
"command) will be made the same as the I<stdout> and no provision is made for "
"sending arbitrary signals to the remote process, although you may be able to "
"get its attention by using out-of-band data."
msgstr ""

#. type: Plain text
#: build/C/man3/rcmd.3:163
msgid "The protocol is described in detail in B<rshd>(8)."
msgstr ""

#. type: SS
#: build/C/man3/rcmd.3:163
#, no-wrap
msgid "rresvport()"
msgstr ""

#. type: Plain text
#: build/C/man3/rcmd.3:186
msgid ""
"The B<rresvport>()  function is used to obtain a socket with a privileged "
"port bound to it.  This socket is suitable for use by B<rcmd>()  and several "
"other functions.  Privileged ports are those in the range 0 to 1023.  Only a "
"privileged process (on Linux: a process that has the B<CAP_NET_BIND_SERVICE> "
"capability in the user namespace governing its network namespace).  is "
"allowed to bind to a privileged port.  In the glibc implementation, this "
"function restricts its search to the ports from 512 to 1023.  The I<port> "
"argument is value-result: the value it supplies to the call is used as the "
"starting point for a circular search of the port range; on (successful) "
"return, it contains the port number that was bound to."
msgstr ""

#. type: SS
#: build/C/man3/rcmd.3:186
#, no-wrap
msgid "iruserok() and ruserok()"
msgstr ""

#. type: Plain text
#: build/C/man3/rcmd.3:203
msgid ""
"The B<iruserok>()  and B<ruserok>()  functions take a remote host's IP "
"address or name, respectively, two usernames and a flag indicating whether "
"the local user's name is that of the superuser.  Then, if the user is I<not> "
"the superuser, it checks the I</etc/hosts.equiv> file.  If that lookup is "
"not done, or is unsuccessful, the I<.rhosts> in the local user's home "
"directory is checked to see if the request for service is allowed."
msgstr ""

#. type: Plain text
#: build/C/man3/rcmd.3:219
msgid ""
"If this file does not exist, is not a regular file, is owned by anyone other "
"than the user or the superuser, is writable by anyone other than the owner, "
"or is hardlinked anywhere, the check automatically fails.  Zero is returned "
"if the machine name is listed in the I<hosts.equiv> file, or the host and "
"remote username are found in the I<.rhosts> file; otherwise B<iruserok>()  "
"and B<ruserok>()  return -1.  If the local domain (as obtained from "
"B<gethostname>(2))  is the same as the remote domain, only the machine name "
"need be specified."
msgstr ""

#. type: Plain text
#: build/C/man3/rcmd.3:225
msgid ""
"If the IP address of the remote host is known, B<iruserok>()  should be used "
"in preference to B<ruserok>(), as it does not require trusting the DNS "
"server for the remote host's domain."
msgstr ""

#. type: SS
#: build/C/man3/rcmd.3:225
#, no-wrap
msgid "*_af() variants"
msgstr ""

#. type: Plain text
#: build/C/man3/rcmd.3:241
msgid ""
"All of the functions described above work with IPv4 (B<AF_INET>)  sockets.  "
"The \"_af\" variants take an extra argument that allows the socket address "
"family to be specified.  For these functions, the I<af> argument can be "
"specified as B<AF_INET> or B<AF_INET6>.  In addition, B<rcmd_af>()  supports "
"the use of B<AF_UNSPEC>."
msgstr ""

#. type: Plain text
#: build/C/man3/rcmd.3:247
msgid ""
"The B<rcmd>()  function returns a valid socket descriptor on success.  It "
"returns -1 on error and prints a diagnostic message on the standard error."
msgstr ""

#. type: Plain text
#: build/C/man3/rcmd.3:258
msgid ""
"The B<rresvport>()  function returns a valid, bound socket descriptor on "
"success.  It returns -1 on error with the global value I<errno> set "
"according to the reason for failure.  The error code B<EAGAIN> is overloaded "
"to mean \"All network ports in use.\""
msgstr ""

#. type: Plain text
#: build/C/man3/rcmd.3:264
msgid ""
"For information on the return from B<ruserok>()  and B<iruserok>(), see "
"above."
msgstr ""

#. type: Plain text
#: build/C/man3/rcmd.3:272
msgid ""
"The functions B<iruserok_af>(), B<rcmd_af>(), B<rresvport_af>(), and "
"B<ruserok_af>()  functions are provide in glibc since version 2.2."
msgstr ""

#. type: tbl table
#: build/C/man3/rcmd.3:283
#, no-wrap
msgid ""
"B<rcmd>(),\n"
"B<rcmd_af>()"
msgstr ""

#. type: tbl table
#: build/C/man3/rcmd.3:287
#, no-wrap
msgid ""
"B<rresvport>(),\n"
"B<rresvport_af>()"
msgstr ""

#. type: tbl table
#: build/C/man3/rcmd.3:291
#, no-wrap
msgid ""
"B<iruserok>(),\n"
"B<ruserok>(),\n"
msgstr ""

#. type: tbl table
#: build/C/man3/rcmd.3:294
#, no-wrap
msgid ""
"B<iruserok_af>(),\n"
"B<ruserok_af>()"
msgstr ""

#. type: Plain text
#: build/C/man3/rcmd.3:305
msgid ""
"Not in POSIX.1.  Present on the BSDs, Solaris, and many other systems.  "
"These functions appeared in 4.2BSD.  The \"_af\" variants are more recent "
"additions, and are not present on as wide a range of systems."
msgstr ""

#.  Bug filed 25 Nov 2007:
#.  http://sources.redhat.com/bugzilla/show_bug.cgi?id=5399
#. type: Plain text
#: build/C/man3/rcmd.3:312
msgid ""
"B<iruserok>()  and B<iruserok_af>()  are declared in glibc headers only "
"since version 2.12."
msgstr ""

#. type: Plain text
#: build/C/man3/rcmd.3:319
msgid ""
"B<rlogin>(1), B<rsh>(1), B<rexec>(3), B<rexecd>(8), B<rlogind>(8), "
"B<rshd>(8)"
msgstr ""

#. type: TH
#: build/C/man5/resolv.conf.5:23
#, no-wrap
msgid "RESOLV.CONF"
msgstr ""

#. type: Plain text
#: build/C/man5/resolv.conf.5:27
msgid "resolv.conf - resolver configuration file"
msgstr ""

#. type: Plain text
#: build/C/man5/resolv.conf.5:29
msgid "B</etc/resolv.conf>"
msgstr ""

#. type: Plain text
#: build/C/man5/resolv.conf.5:42
msgid ""
"The I<resolver> is a set of routines in the C library that provide access to "
"the Internet Domain Name System (DNS).  The resolver configuration file "
"contains information that is read by the resolver routines the first time "
"they are invoked by a process.  The file is designed to be human readable "
"and contains a list of keywords with values that provide various types of "
"resolver information.  The configuration file is considered a trusted source "
"of DNS information; see the B<trust-ad> option below for details."
msgstr ""

#. type: Plain text
#: build/C/man5/resolv.conf.5:46
msgid ""
"If this file does not exist, only the name server on the local machine will "
"be queried, and the search list contains the local domain name determined "
"from the hostname."
msgstr ""

#. type: Plain text
#: build/C/man5/resolv.conf.5:48
msgid "The different configuration options are:"
msgstr ""

#. type: TP
#: build/C/man5/resolv.conf.5:48
#, no-wrap
msgid "B<nameserver> Name server IP address"
msgstr ""

#. type: Plain text
#: build/C/man5/resolv.conf.5:65
msgid ""
"Internet address of a name server that the resolver should query, either an "
"IPv4 address (in dot notation), or an IPv6 address in colon (and possibly "
"dot) notation as per RFC 2373.  Up to B<MAXNS> (currently 3, see "
"I<E<lt>resolv.hE<gt>>) name servers may be listed, one per keyword.  If "
"there are multiple servers, the resolver library queries them in the order "
"listed.  If no B<nameserver> entries are present, the default is to use the "
"name server on the local machine.  (The algorithm used is to try a name "
"server, and if the query times out, try the next, until out of name servers, "
"then repeat trying all the name servers until a maximum number of retries "
"are made.)"
msgstr ""

#. type: TP
#: build/C/man5/resolv.conf.5:65
#, no-wrap
msgid "B<search> Search list for host-name lookup."
msgstr ""

#. type: Plain text
#: build/C/man5/resolv.conf.5:74
msgid ""
"By default, the search list contains one entry, the local domain name.  It "
"is determined from the local hostname returned by B<gethostname>(2); the "
"local domain name is taken to be everything after the first \\(aq.\\(aq.  "
"Finally, if the hostname does not contain a \\(aq.\\(aq, the root domain is "
"assumed as the local domain name."
msgstr ""

#.  When having a resolv.conv with a line
#.   search subdomain.domain.tld domain.tld
#.  and doing a hostlookup, for example by
#.   ping host.anothersubdomain
#.  it sends dns-requests for
#.   host.anothersubdomain.
#.   host.anothersubdomain.subdomain.domain.tld.
#.   host.anothersubdomain.domain.tld.
#.  thus not only causing unnecessary traffic for the root-dns-servers
#.  but broadcasting information to the outside and making man-in-the-middle
#.  attacks possible.
#. type: Plain text
#: build/C/man5/resolv.conf.5:101
msgid ""
"This may be changed by listing the desired domain search path following the "
"I<search> keyword with spaces or tabs separating the names.  Resolver "
"queries having fewer than I<ndots> dots (default is 1) in them will be "
"attempted using each component of the search path in turn until a match is "
"found.  For environments with multiple subdomains please read B<options "
"ndots:>I<n> below to avoid man-in-the-middle attacks and unnecessary traffic "
"for the root-dns-servers.  Note that this process may be slow and will "
"generate a lot of network traffic if the servers for the listed domains are "
"not local, and that queries will time out if no server is available for one "
"of the domains."
msgstr ""

#. type: Plain text
#: build/C/man5/resolv.conf.5:105
msgid ""
"If there are multiple B<search> directives, only the search list from the "
"last instance is used."
msgstr ""

#.  glibc commit 3f853f22c87f0b671c0366eb290919719fa56c0e
#. type: Plain text
#: build/C/man5/resolv.conf.5:111
msgid ""
"In glibc 2.25 and earlier, the search list is limited to six domains with a "
"total of 256 characters.  Since glibc 2.26, the search list is unlimited."
msgstr ""

#. type: Plain text
#: build/C/man5/resolv.conf.5:117
msgid ""
"The B<domain> directive is an obsolete name for the B<search> directive that "
"handles one search list entry only."
msgstr ""

#. type: TP
#: build/C/man5/resolv.conf.5:117
#, no-wrap
msgid "B<sortlist>"
msgstr ""

#. type: Plain text
#: build/C/man5/resolv.conf.5:130
msgid ""
"This option allows addresses returned by B<gethostbyname>(3)  to be sorted.  "
"A sortlist is specified by IP-address-netmask pairs.  The netmask is "
"optional and defaults to the natural netmask of the net.  The IP address and "
"optional network pairs are separated by slashes.  Up to 10 pairs may be "
"specified.  Here is an example:"
msgstr ""

#. type: Plain text
#: build/C/man5/resolv.conf.5:133
msgid "sortlist 130.155.160.0/255.255.240.0 130.155.0.0"
msgstr ""

#. type: TP
#: build/C/man5/resolv.conf.5:134
#, no-wrap
msgid "B<options>"
msgstr ""

#. type: Plain text
#: build/C/man5/resolv.conf.5:138
msgid ""
"Options allows certain internal resolver variables to be modified.  The "
"syntax is"
msgstr ""

#. type: Plain text
#: build/C/man5/resolv.conf.5:141
msgid "B<options> I<option> I<...>"
msgstr ""

#. type: Plain text
#: build/C/man5/resolv.conf.5:143
msgid "where I<option> is one of the following:"
msgstr ""

#. type: TP
#: build/C/man5/resolv.conf.5:143
#, no-wrap
msgid "B<debug>"
msgstr ""

#.  Since glibc 2.2?
#. type: Plain text
#: build/C/man5/resolv.conf.5:152
msgid ""
"Sets B<RES_DEBUG> in I<_res.options> (effective only if glibc was built with "
"debug support; see B<resolver>(3))."
msgstr ""

#. type: TP
#: build/C/man5/resolv.conf.5:152
#, no-wrap
msgid "B<ndots:>I<n>"
msgstr ""

#.  Since glibc 2.2
#. type: Plain text
#: build/C/man5/resolv.conf.5:166
msgid ""
"Sets a threshold for the number of dots which must appear in a name given to "
"B<res_query>(3)  (see B<resolver>(3))  before an I<initial absolute query> "
"will be made.  The default for I<n> is 1, meaning that if there are any dots "
"in a name, the name will be tried first as an absolute name before any "
"I<search list> elements are appended to it.  The value for this option is "
"silently capped to 15."
msgstr ""

#. type: TP
#: build/C/man5/resolv.conf.5:166
#, no-wrap
msgid "B<timeout:>I<n>"
msgstr ""

#.  Since glibc 2.2
#. type: Plain text
#: build/C/man5/resolv.conf.5:181
msgid ""
"Sets the amount of time the resolver will wait for a response from a remote "
"name server before retrying the query via a different name server.  This may "
"B<not> be the total time taken by any resolver API call and there is no "
"guarantee that a single resolver API call maps to a single timeout.  "
"Measured in seconds, the default is B<RES_TIMEOUT> (currently 5, see "
"I<E<lt>resolv.hE<gt>>).  The value for this option is silently capped to 30."
msgstr ""

#. type: TP
#: build/C/man5/resolv.conf.5:181
#, no-wrap
msgid "B<attempts:>I<n>"
msgstr ""

#. type: Plain text
#: build/C/man5/resolv.conf.5:190
msgid ""
"Sets the number of times the resolver will send a query to its name servers "
"before giving up and returning an error to the calling application.  The "
"default is B<RES_DFLRETRY> (currently 2, see I<E<lt>resolv.hE<gt>>).  The "
"value for this option is silently capped to 5."
msgstr ""

#. type: TP
#: build/C/man5/resolv.conf.5:190
#, no-wrap
msgid "B<rotate>"
msgstr ""

#.  Since glibc 2.2
#. type: Plain text
#: build/C/man5/resolv.conf.5:200
msgid ""
"Sets B<RES_ROTATE> in I<_res.options>, which causes round-robin selection of "
"name servers from among those listed.  This has the effect of spreading the "
"query load among all listed servers, rather than having all clients try the "
"first listed server first every time."
msgstr ""

#. type: TP
#: build/C/man5/resolv.conf.5:200
#, no-wrap
msgid "B<no-check-names>"
msgstr ""

#.  since glibc 2.2
#. type: Plain text
#: build/C/man5/resolv.conf.5:210
msgid ""
"Sets B<RES_NOCHECKNAME> in I<_res.options>, which disables the modern BIND "
"checking of incoming hostnames and mail names for invalid characters such as "
"underscore (_), non-ASCII, or control characters."
msgstr ""

#. type: TP
#: build/C/man5/resolv.conf.5:210
#, no-wrap
msgid "B<inet6>"
msgstr ""

#.  Since glibc 2.2
#.  b76e065991ec01299225d9da90a627ebe6c1ac97
#. type: Plain text
#: build/C/man5/resolv.conf.5:227
msgid ""
"Sets B<RES_USE_INET6> in I<_res.options>.  This has the effect of trying an "
"AAAA query before an A query inside the B<gethostbyname>(3)  function, and "
"of mapping IPv4 responses in IPv6 \"tunneled form\" if no AAAA records are "
"found but an A record set exists.  Since glibc 2.25, this option is "
"deprecated; applications should use B<getaddrinfo>(3), rather than "
"B<gethostbyname>(3)."
msgstr ""

#. type: TP
#: build/C/man5/resolv.conf.5:227
#, no-wrap
msgid "B<ip6-bytestring> (since glibc 2.3.4 to 2.24)"
msgstr ""

#. type: Plain text
#: build/C/man5/resolv.conf.5:239
msgid ""
"Sets B<RES_USEBSTRING> in I<_res.options>.  This causes reverse IPv6 lookups "
"to be made using the bit-label format described in RFC\\ 2673; if this "
"option is not set (which is the default), then nibble format is used.  This "
"option was removed in glibc 2.25, since it relied on a backward-incompatible "
"DNS extension that was never deployed on the Internet."
msgstr ""

#. type: TP
#: build/C/man5/resolv.conf.5:239
#, no-wrap
msgid "B<ip6-dotint>/B<no-ip6-dotint> (glibc 2.3.4 to 2.24)"
msgstr ""

#. type: Plain text
#: build/C/man5/resolv.conf.5:262
msgid ""
"Clear/set B<RES_NOIP6DOTINT> in I<_res.options>.  When this option is clear "
"(B<ip6-dotint>), reverse IPv6 lookups are made in the (deprecated)  "
"I<ip6.int> zone; when this option is set (B<no-ip6-dotint>), reverse IPv6 "
"lookups are made in the I<ip6.arpa> zone by default.  These options are "
"available in glibc versions up to 2.24, where B<no-ip6-dotint> is the "
"default.  Since B<ip6-dotint> support long ago ceased to be available on the "
"Internet, these options were removed in glibc 2.25."
msgstr ""

#. type: TP
#: build/C/man5/resolv.conf.5:262
#, no-wrap
msgid "B<edns0> (since glibc 2.6)"
msgstr ""

#. type: Plain text
#: build/C/man5/resolv.conf.5:269
msgid ""
"Sets B<RES_USE_EDNSO> in I<_res.options>.  This enables support for the DNS "
"extensions described in RFC\\ 2671."
msgstr ""

#. type: TP
#: build/C/man5/resolv.conf.5:269
#, no-wrap
msgid "B<single-request> (since glibc 2.10)"
msgstr ""

#. type: Plain text
#: build/C/man5/resolv.conf.5:282
msgid ""
"Sets B<RES_SNGLKUP> in I<_res.options>.  By default, glibc performs IPv4 and "
"IPv6 lookups in parallel since version 2.9.  Some appliance DNS servers "
"cannot handle these queries properly and make the requests time out.  This "
"option disables the behavior and makes glibc perform the IPv6 and IPv4 "
"requests sequentially (at the cost of some slowdown of the resolving "
"process)."
msgstr ""

#. type: TP
#: build/C/man5/resolv.conf.5:282
#, no-wrap
msgid "B<single-request-reopen> (since glibc 2.9)"
msgstr ""

#. type: Plain text
#: build/C/man5/resolv.conf.5:294
msgid ""
"Sets B<RES_SNGLKUPREOP> in I<_res.options>.  The resolver uses the same "
"socket for the A and AAAA requests.  Some hardware mistakenly sends back "
"only one reply.  When that happens the client system will sit and wait for "
"the second reply.  Turning this option on changes this behavior so that if "
"two requests from the same port are not handled correctly it will close the "
"socket and open a new one before sending the second request."
msgstr ""

#. type: TP
#: build/C/man5/resolv.conf.5:294
#, no-wrap
msgid "B<no-tld-query> (since glibc 2.14)"
msgstr ""

#. type: Plain text
#: build/C/man5/resolv.conf.5:307
msgid ""
"Sets B<RES_NOTLDQUERY> in I<_res.options>.  This option causes "
"B<res_nsearch>()  to not attempt to resolve an unqualified name as if it "
"were a top level domain (TLD).  This option can cause problems if the site "
"has ``localhost'' as a TLD rather than having localhost on one or more "
"elements of the search list.  This option has no effect if neither "
"RES_DEFNAMES or RES_DNSRCH is set."
msgstr ""

#. type: TP
#: build/C/man5/resolv.conf.5:307
#, no-wrap
msgid "B<use-vc> (since glibc 2.14)"
msgstr ""

#.  aef16cc8a4c670036d45590877d411a97f01e0cd
#. type: Plain text
#: build/C/man5/resolv.conf.5:315
msgid ""
"Sets B<RES_USEVC> in I<_res.options>.  This option forces the use of TCP for "
"DNS resolutions."
msgstr ""

#. type: TP
#: build/C/man5/resolv.conf.5:315
#, no-wrap
msgid "B<no-reload> (since glibc 2.26)"
msgstr ""

#. type: Plain text
#: build/C/man5/resolv.conf.5:322
msgid ""
"Sets B<RES_NORELOAD> in I<_res.options>.  This option disables automatic "
"reloading of a changed configuration file."
msgstr ""

#. type: TP
#: build/C/man5/resolv.conf.5:322
#, no-wrap
msgid "B<trust-ad> (since glibc 2.31)"
msgstr ""

#.  446997ff1433d33452b81dfa9e626b8dccf101a4
#. type: Plain text
#: build/C/man5/resolv.conf.5:346
msgid ""
"Sets B<RES_TRUSTAD> in I<_res.options>.  This option controls the AD bit "
"behavior of the stub resolver.  If a validating resolver sets the AD bit in "
"a response, it indicates that the data in the response was verified "
"according to the DNSSEC protocol.  In order to rely on the AD bit, the local "
"system has to trust both the DNSSEC-validating resolver and the network path "
"to it, which is why an explicit opt-in is required.  If the B<trust-ad> "
"option is active, the stub resolver sets the AD bit in outgoing DNS queries "
"(to enable AD bit support), and preserves the AD bit in responses.  Without "
"this option, the AD bit is not set in queries, and it is always removed from "
"responses before they are returned to the application.  This means that "
"applications can trust the AD bit in responses if the B<trust-ad> option has "
"been set correctly."
msgstr ""

#. type: Plain text
#: build/C/man5/resolv.conf.5:350
msgid ""
"In glibc version 2.30 and earlier, the AD is not set automatically in "
"queries, and is passed through unchanged to applications in responses."
msgstr ""

#. type: Plain text
#: build/C/man5/resolv.conf.5:356
msgid ""
"The I<search> keyword of a system's I<resolv.conf> file can be overridden on "
"a per-process basis by setting the environment variable B<LOCALDOMAIN> to a "
"space-separated list of search domains."
msgstr ""

#. type: Plain text
#: build/C/man5/resolv.conf.5:362
msgid ""
"The I<options> keyword of a system's I<resolv.conf> file can be amended on a "
"per-process basis by setting the environment variable B<RES_OPTIONS> to a "
"space-separated list of resolver options as explained above under "
"B<options>."
msgstr ""

#. type: Plain text
#: build/C/man5/resolv.conf.5:366
msgid ""
"The keyword and value must appear on a single line, and the keyword (e.g., "
"B<nameserver>) must start the line.  The value follows the keyword, "
"separated by white space."
msgstr ""

#. type: Plain text
#: build/C/man5/resolv.conf.5:369
msgid ""
"Lines that contain a semicolon (;) or hash character (#)  in the first "
"column are treated as comments."
msgstr ""

#. type: Plain text
#: build/C/man5/resolv.conf.5:372
msgid "I</etc/resolv.conf>, I<E<lt>resolv.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man5/resolv.conf.5:380
msgid ""
"B<gethostbyname>(3), B<resolver>(3), B<host.conf>(5), B<hosts>(5), "
"B<nsswitch.conf>(5), B<hostname>(7), B<named>(8)"
msgstr ""

#. type: Plain text
#: build/C/man5/resolv.conf.5:382
msgid "Name Server Operations Guide for BIND"
msgstr ""

#. type: TH
#: build/C/man3/resolver.3:33
#, no-wrap
msgid "RESOLVER"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:38
msgid ""
"res_ninit, res_nclose, res_nquery, res_nsearch, res_nquerydomain, "
"res_nmkquery, res_nsend, res_init, res_query, res_search, res_querydomain, "
"res_mkquery, res_send, dn_comp, dn_expand - resolver routines"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:43
#, no-wrap
msgid ""
"B<#include E<lt>netinet/in.hE<gt>>\n"
"B<#include E<lt>arpa/nameser.hE<gt>>\n"
"B<#include E<lt>resolv.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:46
#, no-wrap
msgid ""
"B<struct __res_state;>\n"
"B<typedef struct __res_state *res_state;>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:48
#, no-wrap
msgid "B<int res_ninit(res_state >I<statep>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:50
#, no-wrap
msgid "B<void res_nclose(res_state >I<statep>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:54
#, no-wrap
msgid ""
"B<int res_nquery(res_state >I<statep>B<,>\n"
"B<           const char *>I<dname>B<, int >I<class>B<, int >I<type>B<,>\n"
"B<           unsigned char *>I<answer>B<, int >I<anslen>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:58
#, no-wrap
msgid ""
"B<int res_nsearch(res_state >I<statep>B<,>\n"
"B<           const char *>I<dname>B<, int >I<class>B<, int >I<type>B<,>\n"
"B<           unsigned char *>I<answer>B<, int >I<anslen>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:63
#, no-wrap
msgid ""
"B<int res_nquerydomain(res_state >I<statep>B<,>\n"
"B<           const char *>I<name>B<, const char *>I<domain>B<,>\n"
"B<           int >I<class>B<, int >I<type>B<, unsigned char "
"*>I<answer>B<,>\n"
"B<           int >I<anslen>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:69
#, no-wrap
msgid ""
"B<int res_nmkquery(res_state >I<statep>B<,>\n"
"B<           int >I<op>B<, const char *>I<dname>B<, int >I<class>B<,>\n"
"B<           int >I<type>B<, const unsigned char *>I<data>B<, int "
">I<datalen>B<,>\n"
"B<           const unsigned char *>I<newrr>B<,>\n"
"B<           unsigned char *>I<buf>B<, int >I<buflen>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:73
#, no-wrap
msgid ""
"B<int res_nsend(res_state >I<statep>B<,>\n"
"B<           const unsigned char *>I<msg>B<, int >I<msglen>B<,>\n"
"B<           unsigned char *>I<answer>B<, int >I<anslen>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:77
#, no-wrap
msgid ""
"B<int dn_comp(const char *>I<exp_dn>B<, unsigned char *>I<comp_dn>B<,>\n"
"B<           int >I<length>B<, unsigned char **>I<dnptrs>B<,>\n"
"B<           unsigned char **>I<lastdnptr>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:82
#, no-wrap
msgid ""
"B<int dn_expand(const unsigned char *>I<msg>B<,>\n"
"B<           const unsigned char *>I<eomorig>B<,>\n"
"B<           const unsigned char *>I<comp_dn>B<, char *>I<exp_dn>B<,>\n"
"B<           int >I<length>B<);>\n"
msgstr ""

#. type: SS
#: build/C/man3/resolver.3:84
#, no-wrap
msgid "Deprecated"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:87
#, no-wrap
msgid "B<extern struct __res_state _res;>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:89
#, no-wrap
msgid "B<int res_init(void);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:92
#, no-wrap
msgid ""
"B<int res_query(const char *>I<dname>B<, int >I<class>B<, int >I<type>B<,>\n"
"B<           unsigned char *>I<answer>B<, int >I<anslen>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:95
#, no-wrap
msgid ""
"B<int res_search(const char *>I<dname>B<, int >I<class>B<, int "
">I<type>B<,>\n"
"B<           unsigned char *>I<answer>B<, int >I<anslen>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:99
#, no-wrap
msgid ""
"B<int res_querydomain(const char *>I<name>B<, const char *>I<domain>B<,>\n"
"B<           int >I<class>B<, int >I<type>B<, unsigned char "
"*>I<answer>B<,>\n"
"B<           int >I<anslen>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:104
#, no-wrap
msgid ""
"B<int res_mkquery(int >I<op>B<, const char *>I<dname>B<, int >I<class>B<,>\n"
"B<           int >I<type>B<, const unsigned char *>I<data>B<, int "
">I<datalen>B<,>\n"
"B<           const unsigned char *>I<newrr>B<,>\n"
"B<           unsigned char *>I<buf>B<, int >I<buflen>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:107
#, no-wrap
msgid ""
"B<int res_send(const unsigned char *>I<msg>B<, int >I<msglen>B<,>\n"
"B<           unsigned char *>I<answer>B<, int >I<anslen>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:114
msgid ""
"B<Note:> This page is incomplete (various resolver functions provided by "
"glibc are not described) and likely out of date."
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:117
msgid ""
"The functions described below make queries to and interpret the responses "
"from Internet domain name servers."
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:133
msgid ""
"The API consists of a set of more modern, reentrant functions and an older "
"set of nonreentrant functions that have been superseded.  The traditional "
"resolver interfaces such as B<res_init>()  and B<res_query>()  use some "
"static (global) state stored in the I<_res> structure, rendering these "
"functions non-thread-safe.  BIND 8.2 introduced a set of new interfaces "
"B<res_ninit>(), B<res_nquery>(), and so on, which take a I<res_state> as "
"their first argument, so you can use a per-thread resolver state."
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:159
msgid ""
"The B<res_ninit>()  and B<res_init>()  functions read the configuration "
"files (see B<resolv.conf>(5))  to get the default domain name and name "
"server address(es).  If no server is given, the local host is tried.  If no "
"domain is given, that associated with the local host is used.  It can be "
"overridden with the environment variable B<LOCALDOMAIN>.  B<res_ninit>()  or "
"B<res_init>()  is normally executed by the first call to one of the other "
"functions.  Every call to B<res_ninit>()  requires a corresponding call to "
"B<res_nclose>()  to free memory allocated by B<res_ninit>()  and subsequent "
"calls to B<res_nquery>()."
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:169
msgid ""
"The B<res_nquery>()  and B<res_query>()  functions query the name server for "
"the fully qualified domain name I<name> of specified I<type> and I<class>.  "
"The reply is left in the buffer I<answer> of length I<anslen> supplied by "
"the caller."
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:185
msgid ""
"The B<res_nsearch>()  and B<res_search>()  functions make a query and waits "
"for the response like B<res_nquery>()  and B<res_query>(), but in addition "
"they implement the default and search rules controlled by B<RES_DEFNAMES> "
"and B<RES_DNSRCH> (see description of I<_res> options below)."
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:193
msgid ""
"The B<res_nquerydomain>()  and B<res_querydomain>()  functions make a query "
"using B<res_nquery>()/B<res_query>()  on the concatenation of I<name> and "
"I<domain>."
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:196
msgid ""
"The following functions are lower-level routines used by "
"B<res_nquery>()/B<res_query>()."
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:206
msgid ""
"The B<res_nmkquery>()  and B<res_mkquery>()  functions construct a query "
"message in I<buf> of length I<buflen> for the domain name I<dname>.  The "
"query type I<op> is one of the following (typically B<QUERY>):"
msgstr ""

#. type: TP
#: build/C/man3/resolver.3:206
#, no-wrap
msgid "B<QUERY>"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:209
msgid "Standard query."
msgstr ""

#. type: TP
#: build/C/man3/resolver.3:209
#, no-wrap
msgid "B<IQUERY>"
msgstr ""

#.  commit e4e794841e3140875f2aa86b90e2ada3d61e1244
#. type: Plain text
#: build/C/man3/resolver.3:215
msgid ""
"Inverse query.  This option was removed in glibc 2.26, since it has not been "
"supported by DNS servers for a very long time."
msgstr ""

#. type: TP
#: build/C/man3/resolver.3:215
#, no-wrap
msgid "B<NS_NOTIFY_OP>"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:218
msgid "Notify secondary of SOA (Start of Authority) change."
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:220
msgid "I<newrr> is currently unused."
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:231
msgid ""
"The B<res_nsend>()  and B<res_send>()  function send a preformatted query "
"given in I<msg> of length I<msglen> and returns the answer in I<answer> "
"which is of length I<anslen>.  They will call B<res_ninit>()/B<res_init>()  "
"if it has not already been called."
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:244
msgid ""
"The B<dn_comp>()  function compresses the domain name I<exp_dn> and stores "
"it in the buffer I<comp_dn> of length I<length>.  The compression uses an "
"array of pointers I<dnptrs> to previously compressed names in the current "
"message.  The first pointer points to the beginning of the message and the "
"list ends with NULL.  The limit of the array is specified by I<lastdnptr>.  "
"If I<dnptr> is NULL, domain names are not compressed.  If I<lastdnptr> is "
"NULL, the list of labels is not updated."
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:253
msgid ""
"The B<dn_expand>()  function expands the compressed domain name I<comp_dn> "
"to a full domain name, which is placed in the buffer I<exp_dn> of size "
"I<length>.  The compressed name is contained in a query or reply message, "
"and I<msg> points to the beginning of the message."
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:268
msgid ""
"The resolver routines use configuration and state information contained in a "
"I<__res_state> structure (either passed as the I<statep> argument, or in the "
"global variable I<_res>, in the case of the older nonreentrant functions).  "
"The only field of this structure that is normally manipulated by the user is "
"the I<options> field.  This field can contain the bitwise \"OR\" of the "
"following options:"
msgstr ""

#. type: TP
#: build/C/man3/resolver.3:268
#, no-wrap
msgid "B<RES_INIT>"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:275
msgid "True if B<res_ninit>()  or B<res_init>()  has been called."
msgstr ""

#. type: TP
#: build/C/man3/resolver.3:275
#, no-wrap
msgid "B<RES_DEBUG>"
msgstr ""

#.  See resolv/README.
#.  Support for RES_DEBUG was made conditional in glibc 2.2.
#. type: Plain text
#: build/C/man3/resolver.3:282
msgid ""
"Print debugging messages.  This option is available only if glibc was built "
"with debugging enabled, which is not the default."
msgstr ""

#. type: TP
#: build/C/man3/resolver.3:282
#, no-wrap
msgid "B<RES_AAONLY> (unimplemented; deprecated in glibc 2.25)"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:290
msgid ""
"Accept authoritative answers only.  B<res_send>()  continues until it finds "
"an authoritative answer or returns an error.  This option was present but "
"unimplemented in glibc until version 2.24; since glibc 2.25, it is "
"deprecated, and its usage produces a warning."
msgstr ""

#. type: TP
#: build/C/man3/resolver.3:290
#, no-wrap
msgid "B<RES_USEVC>"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:293
msgid "Use TCP connections for queries rather than UDP datagrams."
msgstr ""

#. type: TP
#: build/C/man3/resolver.3:293
#, no-wrap
msgid "B<RES_PRIMARY> (unimplemented; deprecated in glibc 2.25)"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:298
msgid ""
"Query primary domain name server only.  This option was present but "
"unimplemented in glibc until version 2.24; since glibc 2.25, it is "
"deprecated, and its usage produces a warning."
msgstr ""

#. type: TP
#: build/C/man3/resolver.3:298
#, no-wrap
msgid "B<RES_IGNTC>"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:302
msgid "Ignore truncation errors.  Don't retry with TCP."
msgstr ""

#. type: TP
#: build/C/man3/resolver.3:302
#, no-wrap
msgid "B<RES_RECURSE>"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:309
msgid ""
"Set the recursion desired bit in queries.  Recursion is carried out by the "
"domain name server, not by B<res_send>().  [Enabled by default]."
msgstr ""

#. type: TP
#: build/C/man3/resolver.3:309
#, no-wrap
msgid "B<RES_DEFNAMES>"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:316
msgid ""
"If set, B<res_search>()  will append the default domain name to single "
"component names\\(emthat is, those that do not contain a dot.  [Enabled by "
"default]."
msgstr ""

#. type: TP
#: build/C/man3/resolver.3:316
#, no-wrap
msgid "B<RES_STAYOPEN>"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:321
msgid "Used with B<RES_USEVC> to keep the TCP connection open between queries."
msgstr ""

#. type: TP
#: build/C/man3/resolver.3:321
#, no-wrap
msgid "B<RES_DNSRCH>"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:330
msgid ""
"If set, B<res_search>()  will search for hostnames in the current domain and "
"in parent domains.  This option is used by B<gethostbyname>(3).  [Enabled by "
"default]."
msgstr ""

#. type: TP
#: build/C/man3/resolver.3:330
#, no-wrap
msgid "B<RES_INSECURE1>"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:337
msgid ""
"Accept a response from a wrong server.  This can be used to detect potential "
"security hazards, but you need to compile glibc with debugging enabled and "
"use B<RES_DEBUG> option (for debug purpose only)."
msgstr ""

#. type: TP
#: build/C/man3/resolver.3:337
#, no-wrap
msgid "B<RES_INSECURE2>"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:344
msgid ""
"Accept a response which contains a wrong query.  This can be used to detect "
"potential security hazards, but you need to compile glibc with debugging "
"enabled and use B<RES_DEBUG> option (for debug purpose only)."
msgstr ""

#. type: TP
#: build/C/man3/resolver.3:344
#, no-wrap
msgid "B<RES_NOALIASES>"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:349
msgid "Disable usage of B<HOSTALIASES> environment variable."
msgstr ""

#. type: TP
#: build/C/man3/resolver.3:349
#, no-wrap
msgid "B<RES_USE_INET6>"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:361
msgid ""
"Try an AAAA query before an A query inside the B<gethostbyname>(3)  "
"function, and map IPv4 responses in IPv6 \"tunneled form\" if no AAAA "
"records are found but an A record set exists.  Since glibc 2.25, this option "
"is deprecated, and its usage produces a warning; applications should use "
"B<getaddrinfo>(3), rather than B<gethostbyname>(3)."
msgstr ""

#. type: TP
#: build/C/man3/resolver.3:361
#, no-wrap
msgid "B<RES_ROTATE>"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:367
msgid ""
"Causes round-robin selection of name servers from among those listed.  This "
"has the effect of spreading the query load among all listed servers, rather "
"than having all clients try the first listed server first every time."
msgstr ""

#. type: TP
#: build/C/man3/resolver.3:367
#, no-wrap
msgid "B<RES_NOCHECKNAME> (unimplemented; deprecated in glibc 2.25)"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:374
msgid ""
"Disable the modern BIND checking of incoming hostnames and mail names for "
"invalid characters such as underscore (_), non-ASCII, or control "
"characters.  This option was present in glibc until version 2.24; since "
"glibc 2.25, it is deprecated, and its usage produces a warning."
msgstr ""

#. type: TP
#: build/C/man3/resolver.3:374
#, no-wrap
msgid "B<RES_KEEPTSIG> (unimplemented; deprecated in glibc 2.25)"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:379
msgid ""
"Do not strip TSIG records.  This option was present but unimplemented in "
"glibc until version 2.24; since glibc 2.25, it is deprecated, and its usage "
"produces a warning."
msgstr ""

#. type: TP
#: build/C/man3/resolver.3:379
#, no-wrap
msgid "B<RES_BLAST> (unimplemented; deprecated in glibc 2.25)"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:384
msgid ""
"Send each query simultaneously and recursively to all servers.  This option "
"was present but unimplemented in glibc until version 2.24; since glibc 2.25, "
"it is deprecated, and its usage produces a warning."
msgstr ""

#. type: TP
#: build/C/man3/resolver.3:384
#, no-wrap
msgid "B<RES_USEBSTRING> (glibc 2.3.4 to 2.24)"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:391
msgid ""
"Make reverse IPv6 lookups using the bit-label format described in RFC 2673; "
"if this option is not set (which is the default), then nibble format is "
"used.  This option was removed in glibc 2.25, since it relied on a "
"backward-incompatible DNS extension that was never deployed on the Internet."
msgstr ""

#. type: TP
#: build/C/man3/resolver.3:391
#, no-wrap
msgid "B<RES_NOIP6DOTINT> (glibc 2.24 and earlier)"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:401
msgid ""
"Use I<ip6.arpa> zone in IPv6 reverse lookup instead of I<ip6.int>, which is "
"deprecated since glibc 2.3.4.  This option is present in glibc up to and "
"including version 2.24, where it is enabled by default.  In glibc 2.25, this "
"option was removed."
msgstr ""

#. type: TP
#: build/C/man3/resolver.3:401
#, no-wrap
msgid "B<RES_USE_EDNS0> (since glibc 2.6)"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:404
msgid "Enables support for the DNS extensions (EDNS0) described in RFC 2671."
msgstr ""

#. type: TP
#: build/C/man3/resolver.3:404
#, no-wrap
msgid "B<RES_SNGLKUP> (since glibc 2.10)"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:413
msgid ""
"By default, glibc performs IPv4 and IPv6 lookups in parallel since version "
"2.9.  Some appliance DNS servers cannot handle these queries properly and "
"make the requests time out.  This option disables the behavior and makes "
"glibc perform the IPv6 and IPv4 requests sequentially (at the cost of some "
"slowdown of the resolving process)."
msgstr ""

#. type: TP
#: build/C/man3/resolver.3:413
#, no-wrap
msgid "B<RES_SNGLKUPREOP>"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:418
msgid ""
"When B<RES_SNGLKUP> option is enabled, opens a new socket for the each "
"request."
msgstr ""

#. type: TP
#: build/C/man3/resolver.3:418
#, no-wrap
msgid "B<RES_USE_DNSSEC>"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:423
msgid "Use DNSSEC with OK bit in OPT record.  This option implies B<RES_USE_EDNS0>."
msgstr ""

#. type: TP
#: build/C/man3/resolver.3:423
#, no-wrap
msgid "B<RES_NOTLDQUERY>"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:426
msgid "Do not look up unqualified name as a top-level domain (TLD)."
msgstr ""

#. type: TP
#: build/C/man3/resolver.3:426
#, no-wrap
msgid "B<RES_DEFAULT>"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:435
msgid ""
"Default option which implies: B<RES_RECURSE>, B<RES_DEFNAMES>, "
"B<RES_DNSRCH>, and B<RES_NOIP6DOTINT>."
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:442
msgid ""
"The B<res_ninit>()  and B<res_init>()  functions return 0 on success, or -1 "
"if an error occurs."
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:457
msgid ""
"The B<res_nquery>(), B<res_query>(), B<res_nsearch>(), B<res_search>(), "
"B<res_nquerydomain>(), B<res_querydomain>(), B<res_nmkquery>(), "
"B<res_mkquery>(), B<res_nsend>(), and B<res_send>()  functions return the "
"length of the response, or -1 if an error occurs."
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:464
msgid ""
"The B<dn_comp>()  and B<dn_expand>()  functions return the length of the "
"compressed name, or -1 if an error occurs."
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:478
msgid ""
"In the case of an error return from B<res_nquery>(), B<res_query>(), "
"B<res_nsearch>(), B<res_search>(), B<res_nquerydomain>(), or "
"B<res_querydomain>(), the global variable I<h_errno> (see "
"B<gethostbyname>(3))  can be consulted to determine the cause of the error."
msgstr ""

#. type: tbl table
#: build/C/man3/resolver.3:497
#, no-wrap
msgid ""
"B<res_ninit>(),\n"
"B<res_nclose>(),\n"
"B<res_nquery>(),\n"
msgstr ""

#. type: tbl table
#: build/C/man3/resolver.3:501
#, no-wrap
msgid ""
"B<res_nsearch>(),\n"
"B<res_nquerydomain>(),\n"
"B<res_nsend>()"
msgstr ""

#. type: tbl table
#: build/C/man3/resolver.3:505
#, no-wrap
msgid ""
"B<res_nmkquery>(),\n"
"B<dn_comp>(),\n"
msgstr ""

#. type: tbl table
#: build/C/man3/resolver.3:507
#, no-wrap
msgid "B<dn_expand>()"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:512
msgid "4.3BSD."
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:518
msgid ""
"B<gethostbyname>(3), B<resolv.conf>(5), B<resolver>(5), B<hostname>(7), "
"B<named>(8)"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:521
msgid "The GNU C library source file I<resolv/README>."
msgstr ""

#. type: TH
#: build/C/man3/rexec.3:41
#, no-wrap
msgid "REXEC"
msgstr ""

#. type: Plain text
#: build/C/man3/rexec.3:44
msgid "rexec, rexec_af - return stream to a remote command"
msgstr ""

#. type: Plain text
#: build/C/man3/rexec.3:50
#, no-wrap
msgid ""
"B<int rexec(char **>I<ahost>B<, int >I<inport>B<, const char *>I<user>B<,>\n"
"B<          const char *>I<passwd>B<, const char *>I<cmd>B<, int "
"*>I<fd2p>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/rexec.3:54
#, no-wrap
msgid ""
"B<int rexec_af(char **>I<ahost>B<, int >I<inport>B<, const char "
"*>I<user>B<,>\n"
"B<             const char *>I<passwd>B<, const char *>I<cmd>B<, int "
"*>I<fd2p>B<,>\n"
"B<             sa_family_t >I<af>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/rexec.3:58
msgid "B<rexec>(), B<rexec_af>():"
msgstr ""

#. type: Plain text
#: build/C/man3/rexec.3:67
msgid "This interface is obsoleted by B<rcmd>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/rexec.3:86
msgid ""
"The B<rexec>()  function looks up the host I<*ahost> using "
"B<gethostbyname>(3), returning -1 if the host does not exist.  Otherwise, "
"I<*ahost> is set to the standard name of the host.  If a username and "
"password are both specified, then these are used to authenticate to the "
"foreign host; otherwise the environment and then the I<.netrc> file in "
"user's home directory are searched for appropriate information.  If all this "
"fails, the user is prompted for the information."
msgstr ""

#. type: Plain text
#: build/C/man3/rexec.3:97
msgid ""
"The port I<inport> specifies which well-known DARPA Internet port to use for "
"the connection; the call I<getservbyname(\"exec\", \"tcp\")> (see "
"B<getservent>(3))  will return a pointer to a structure that contains the "
"necessary port.  The protocol for connection is described in detail in "
"B<rexecd>(8)."
msgstr ""

#. type: Plain text
#: build/C/man3/rexec.3:130
msgid ""
"If the connection succeeds, a socket in the Internet domain of type "
"B<SOCK_STREAM> is returned to the caller, and given to the remote command as "
"I<stdin> and I<stdout>.  If I<fd2p> is nonzero, then an auxiliary channel to "
"a control process will be setup, and a file descriptor for it will be placed "
"in I<*fd2p>.  The control process will return diagnostic output from the "
"command (unit 2) on this channel, and will also accept bytes on this channel "
"as being UNIX signal numbers, to be forwarded to the process group of the "
"command.  The diagnostic information returned does not include remote "
"authorization failure, as the secondary connection is set up after "
"authorization has been verified.  If I<fd2p> is 0, then the I<stderr> (unit "
"2 of the remote command) will be made the same as the I<stdout> and no "
"provision is made for sending arbitrary signals to the remote process, "
"although you may be able to get its attention by using out-of-band data."
msgstr ""

#. type: SS
#: build/C/man3/rexec.3:130
#, no-wrap
msgid "rexec_af()"
msgstr ""

#. type: Plain text
#: build/C/man3/rexec.3:146
msgid ""
"The B<rexec>()  function works over IPv4 (B<AF_INET>).  By contrast, the "
"B<rexec_af>()  function provides an extra argument, I<af>, that allows the "
"caller to select the protocol.  This argument can be specified as "
"B<AF_INET>, B<AF_INET6>, or B<AF_UNSPEC> (to allow the implementation to "
"select the protocol)."
msgstr ""

#. type: Plain text
#: build/C/man3/rexec.3:150
msgid "The B<rexec_af>()  function was added to glibc in version 2.2."
msgstr ""

#. type: tbl table
#: build/C/man3/rexec.3:161
#, no-wrap
msgid ""
"B<rexec>(),\n"
"B<rexec_af>()"
msgstr ""

#. type: Plain text
#: build/C/man3/rexec.3:172
msgid ""
"These functions are not in POSIX.1.  The B<rexec>()  function first appeared "
"in 4.2BSD, and is present on the BSDs, Solaris, and many other systems.  The "
"B<rexec_af>()  function is more recent, and less widespread."
msgstr ""

#. type: Plain text
#: build/C/man3/rexec.3:176
msgid "The B<rexec>()  function sends the unencrypted password across the network."
msgstr ""

#. type: Plain text
#: build/C/man3/rexec.3:181
msgid ""
"The underlying service is considered a big security hole and therefore not "
"enabled on many sites; see B<rexecd>(8)  for explanations."
msgstr ""

#. type: Plain text
#: build/C/man3/rexec.3:184
msgid "B<rcmd>(3), B<rexecd>(8)"
msgstr ""

#. type: TH
#: build/C/man5/services.5:34
#, no-wrap
msgid "SERVICES"
msgstr ""

#. type: TH
#: build/C/man5/services.5:34 build/C/man7/udp.7:12
#, no-wrap
msgid "2020-04-11"
msgstr ""

#. type: Plain text
#: build/C/man5/services.5:37
msgid "services - Internet network services list"
msgstr ""

#. type: Plain text
#: build/C/man5/services.5:52
msgid ""
"B<services> is a plain ASCII file providing a mapping between human-friendly "
"textual names for internet services, and their underlying assigned port "
"numbers and protocol types.  Every networking program should look into this "
"file to get the port number (and protocol) for its service.  The C library "
"routines B<getservent>(3), B<getservbyname>(3), B<getservbyport>(3), "
"B<setservent>(3), and B<endservent>(3)  support querying this file from "
"programs."
msgstr ""

#. type: Plain text
#: build/C/man5/services.5:58
msgid ""
"Port numbers are assigned by the IANA (Internet Assigned Numbers Authority), "
"and their current policy is to assign both TCP and UDP protocols when "
"assigning a port number.  Therefore, most entries will have two entries, "
"even for TCP-only services."
msgstr ""

#. type: Plain text
#: build/C/man5/services.5:70
msgid ""
"Port numbers below 1024 (so-called \"low numbered\" ports) can be bound to "
"only by root (see B<bind>(2), B<tcp>(7), and B<udp>(7)).  This is so clients "
"connecting to low numbered ports can trust that the service running on the "
"port is the standard implementation, and not a rogue service run by a user "
"of the machine.  Well-known port numbers specified by the IANA are normally "
"located in this root-only space."
msgstr ""

#. type: Plain text
#: build/C/man5/services.5:85
msgid ""
"The presence of an entry for a service in the B<services> file does not "
"necessarily mean that the service is currently running on the machine.  See "
"B<inetd.conf>(5)  for the configuration of Internet services offered.  Note "
"that not all networking services are started by B<inetd>(8), and so won't "
"appear in B<inetd.conf>(5).  In particular, news (NNTP) and mail (SMTP) "
"servers are often initialized from the system boot scripts."
msgstr ""

#. type: Plain text
#: build/C/man5/services.5:94
msgid ""
"The location of the B<services> file is defined by B<_PATH_SERVICES> in "
"I<E<lt>netdb.hE<gt>>.  This is usually set to I</etc/services>."
msgstr ""

#. type: Plain text
#: build/C/man5/services.5:96
msgid "Each line describes one service, and is of the form:"
msgstr ""

#. type: Plain text
#: build/C/man5/services.5:98
msgid "I<service-name\\ \\ \\ port>B</>I<protocol\\ \\ \\ >[I<aliases ...>]"
msgstr ""

#. type: TP
#: build/C/man5/services.5:98
#, no-wrap
msgid "where:"
msgstr ""

#. type: TP
#: build/C/man5/services.5:100
#, no-wrap
msgid "I<service-name>"
msgstr ""

#. type: Plain text
#: build/C/man5/services.5:106
msgid ""
"is the friendly name the service is known by and looked up under.  It is "
"case sensitive.  Often, the client program is named after the "
"I<service-name>."
msgstr ""

#. type: TP
#: build/C/man5/services.5:106
#, no-wrap
msgid "I<port>"
msgstr ""

#. type: Plain text
#: build/C/man5/services.5:109
msgid "is the port number (in decimal) to use for this service."
msgstr ""

#. type: Plain text
#: build/C/man5/services.5:120
msgid ""
"is the type of protocol to be used.  This field should match an entry in the "
"B<protocols>(5)  file.  Typical values include B<tcp> and B<udp>."
msgstr ""

#. type: Plain text
#: build/C/man5/services.5:126
msgid ""
"is an optional space or tab separated list of other names for this service.  "
"Again, the names are case sensitive."
msgstr ""

#. type: Plain text
#: build/C/man5/services.5:128
msgid "Either spaces or tabs may be used to separate the fields."
msgstr ""

#. type: Plain text
#: build/C/man5/services.5:132
msgid ""
"Comments are started by the hash sign (#) and continue until the end of the "
"line.  Blank lines are skipped."
msgstr ""

#. type: Plain text
#: build/C/man5/services.5:143
msgid ""
"The I<service-name> should begin in the first column of the file, since "
"leading spaces are not stripped.  I<service-names> can be any printable "
"characters excluding space and tab.  However, a conservative choice of "
"characters should be used to minimize compatibility problems.  For example, "
"a-z, 0-9, and hyphen (-) would seem a sensible choice."
msgstr ""

#. type: Plain text
#: build/C/man5/services.5:152
msgid ""
"Lines not matching this format should not be present in the file.  "
"(Currently, they are silently skipped by B<getservent>(3), "
"B<getservbyname>(3), and B<getservbyport>(3).  However, this behavior should "
"not be relied on.)"
msgstr ""

#. type: Plain text
#: build/C/man5/services.5:169
msgid "A sample B<services> file might look like this:"
msgstr ""

#. type: Plain text
#: build/C/man5/services.5:181
#, no-wrap
msgid ""
"netstat         15/tcp\n"
"qotd            17/tcp          quote\n"
"msp             18/tcp          # message send protocol\n"
"msp             18/udp          # message send protocol\n"
"chargen         19/tcp          ttytst source\n"
"chargen         19/udp          ttytst source\n"
"ftp             21/tcp\n"
"# 22 - unassigned\n"
"telnet          23/tcp\n"
msgstr ""

#. type: Plain text
#: build/C/man5/services.5:187
msgid "The Internet network services list"
msgstr ""

#. type: TP
#: build/C/man5/services.5:187
#, no-wrap
msgid "I<E<lt>netdb.hE<gt>>"
msgstr ""

#.  .SH BUGS
#.  It's not clear when/if the following was ever true;
#.  it isn't true for glibc 2.8:
#.     There is a maximum of 35 aliases, due to the way the
#.     .BR getservent (3)
#.     code is written.
#
#.  It's not clear when/if the following was ever true;
#.  it isn't true for glibc 2.8:
#.     Lines longer than
#.     .B BUFSIZ
#.     (currently 1024) characters will be ignored by
#.     .BR getservent (3),
#.     .BR getservbyname (3),
#.     and
#.     .BR getservbyport (3).
#.     However, this will also cause the next line to be mis-parsed.
#. type: Plain text
#: build/C/man5/services.5:208
msgid "Definition of B<_PATH_SERVICES>"
msgstr ""

#. type: Plain text
#: build/C/man5/services.5:218
msgid ""
"B<listen>(2), B<endservent>(3), B<getservbyname>(3), B<getservbyport>(3), "
"B<getservent>(3), B<setservent>(3), B<inetd.conf>(5), B<protocols>(5), "
"B<inetd>(8)"
msgstr ""

#. type: Plain text
#: build/C/man5/services.5:220
msgid "Assigned Numbers RFC, most recently RFC\\ 1700, (AKA STD0002)."
msgstr ""

#. type: TH
#: build/C/man3/setnetgrent.3:10
#, no-wrap
msgid "SETNETGRENT"
msgstr ""

#. type: Plain text
#: build/C/man3/setnetgrent.3:14
msgid ""
"setnetgrent, endnetgrent, getnetgrent, getnetgrent_r, innetgr - handle "
"network group entries"
msgstr ""

#. type: Plain text
#: build/C/man3/setnetgrent.3:19
#, no-wrap
msgid "B<int setnetgrent(const char *>I<netgroup>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/setnetgrent.3:21
#, no-wrap
msgid "B<void endnetgrent(void);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/setnetgrent.3:23
#, no-wrap
msgid ""
"B<int getnetgrent(char **>I<host>B<, char **>I<user>B<, char "
"**>I<domain>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/setnetgrent.3:26
#, no-wrap
msgid ""
"B<int getnetgrent_r(char **>I<host>B<, char **>I<user>B<,>\n"
"B<                  char **>I<domain>B<, char *>I<buf>B<, size_t "
">I<buflen>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/setnetgrent.3:29
#, no-wrap
msgid ""
"B<int innetgr(const char *>I<netgroup>B<, const char *>I<host>B<,>\n"
"B<            const char *>I<user>B<, const char *>I<domain>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/setnetgrent.3:46
#, no-wrap
msgid ""
"B<setnetgrent>(),\n"
"B<endnetgrent>(),\n"
"B<getnetgrent>(),\n"
"B<getnetgrent_r>(),\n"
"B<innetgr>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man3/setnetgrent.3:60
msgid ""
"The I<netgroup> is a SunOS invention.  A netgroup database is a list of "
"string triples (I<hostname>, I<username>, I<domainname>)  or other netgroup "
"names.  Any of the elements in a triple can be empty, which means that "
"anything matches.  The functions described here allow access to the netgroup "
"databases.  The file I</etc/nsswitch.conf> defines what database is "
"searched."
msgstr ""

#. type: Plain text
#: build/C/man3/setnetgrent.3:80
msgid ""
"The B<setnetgrent>()  call defines the netgroup that will be searched by "
"subsequent B<getnetgrent>()  calls.  The B<getnetgrent>()  function "
"retrieves the next netgroup entry, and returns pointers in I<host>, I<user>, "
"I<domain>.  A null pointer means that the corresponding entry matches any "
"string.  The pointers are valid only as long as there is no call to other "
"netgroup-related functions.  To avoid this problem you can use the GNU "
"function B<getnetgrent_r>()  that stores the strings in the supplied "
"buffer.  To free all allocated buffers use B<endnetgrent>()."
msgstr ""

#. type: Plain text
#: build/C/man3/setnetgrent.3:89
msgid ""
"In most cases you want to check only if the triplet (I<hostname>, "
"I<username>, I<domainname>)  is a member of a netgroup.  The function "
"B<innetgr>()  can be used for this without calling the above three "
"functions.  Again, a null pointer is a wildcard and matches any string.  The "
"function is thread-safe."
msgstr ""

#. type: Plain text
#: build/C/man3/setnetgrent.3:91
msgid "These functions return 1 on success and 0 for failure."
msgstr ""

#. type: tbl table
#: build/C/man3/setnetgrent.3:105
#, no-wrap
msgid "B<setnetgrent>(),\n"
msgstr ""

#. type: tbl table
#: build/C/man3/setnetgrent.3:107
#, no-wrap
msgid "B<getnetgrent_r>(),\n"
msgstr ""

#. type: tbl table
#: build/C/man3/setnetgrent.3:109
#, no-wrap
msgid "B<innetgr>()"
msgstr ""

#. type: tbl table
#: build/C/man3/setnetgrent.3:111 build/C/man3/setnetgrent.3:121
#, no-wrap
msgid "MT-Unsafe race:netgrent\n"
msgstr ""

#. type: tbl table
#: build/C/man3/setnetgrent.3:116
#, no-wrap
msgid "B<endnetgrent>()"
msgstr ""

#. type: tbl table
#: build/C/man3/setnetgrent.3:116
#, no-wrap
msgid "MT-Unsafe race:netgrent"
msgstr ""

#. type: tbl table
#: build/C/man3/setnetgrent.3:119
#, no-wrap
msgid "B<getnetgrent>()"
msgstr ""

#. type: tbl table
#: build/C/man3/setnetgrent.3:123
#, no-wrap
msgid "race:netgrentbuf locale"
msgstr ""

#. type: Plain text
#: build/C/man3/setnetgrent.3:139
msgid ""
"In the above table, I<netgrent> in I<race:netgrent> signifies that if any of "
"the functions B<setnetgrent>(), B<getnetgrent_r>(), B<innetgr>(), "
"B<getnetgrent>(), or B<endnetgrent>()  are used in parallel in different "
"threads of a program, then data races could occur."
msgstr ""

#.  getnetgrent_r() is on Solaris 8 and AIX 5.1, but not the BSDs.
#. type: Plain text
#: build/C/man3/setnetgrent.3:150
msgid ""
"These functions are not in POSIX.1, but B<setnetgrent>(), B<endnetgrent>(), "
"B<getnetgrent>(), and B<innetgr>()  are available on most UNIX systems.  "
"B<getnetgrent_r>()  is not widely available on other systems."
msgstr ""

#. type: Plain text
#: build/C/man3/setnetgrent.3:154
msgid "In the BSD implementation, B<setnetgrent>()  returns void."
msgstr ""

#. type: Plain text
#: build/C/man3/setnetgrent.3:158
msgid "B<sethostent>(3), B<setprotoent>(3), B<setservent>(3)"
msgstr ""

#. type: TH
#: build/C/man2/shutdown.2:40
#, no-wrap
msgid "SHUTDOWN"
msgstr ""

#. type: TH
#: build/C/man2/shutdown.2:40
#, no-wrap
msgid "2018-04-30"
msgstr ""

#. type: Plain text
#: build/C/man2/shutdown.2:43
msgid "shutdown - shut down part of a full-duplex connection"
msgstr ""

#. type: Plain text
#: build/C/man2/shutdown.2:47
msgid "B<int shutdown(int >I<sockfd>B<, int >I<how>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/shutdown.2:69
msgid ""
"The B<shutdown>()  call causes all or part of a full-duplex connection on "
"the socket associated with I<sockfd> to be shut down.  If I<how> is "
"B<SHUT_RD>, further receptions will be disallowed.  If I<how> is B<SHUT_WR>, "
"further transmissions will be disallowed.  If I<how> is B<SHUT_RDWR>, "
"further receptions and transmissions will be disallowed."
msgstr ""

#. type: Plain text
#: build/C/man2/shutdown.2:79
msgid "I<sockfd> is not a valid file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/shutdown.2:84
msgid "An invalid value was specified in I<how> (but see BUGS)."
msgstr ""

#. type: Plain text
#: build/C/man2/shutdown.2:87
msgid "The specified socket is not connected."
msgstr ""

#. type: Plain text
#: build/C/man2/shutdown.2:96
msgid ""
"POSIX.1-2001, POSIX.1-2008, 4.4BSD (B<shutdown>()  first appeared in "
"4.2BSD)."
msgstr ""

#. type: Plain text
#: build/C/man2/shutdown.2:105
msgid ""
"The constants B<SHUT_RD>, B<SHUT_WR>, B<SHUT_RDWR> have the value 0, 1, 2, "
"respectively, and are defined in I<E<lt>sys/socket.hE<gt>> since "
"glibc-2.1.91."
msgstr ""

#.  https://bugzilla.kernel.org/show_bug.cgi?id=47111
#.  commit fc61b928dc4d72176cf4bd4d30bf1d22e599aefc
#.  and for DECnet sockets in commit 46b66d7077b89fb4917ceef19b3f7dd86055c94a
#. type: Plain text
#: build/C/man2/shutdown.2:116
msgid ""
"Checks for the validity of I<how> are done in domain-specific code, and "
"before Linux 3.7 not all domains performed these checks.  Most notably, UNIX "
"domain sockets simply ignored invalid values.  This problem was fixed for "
"UNIX domain sockets in Linux 3.7."
msgstr ""

#. type: Plain text
#: build/C/man2/shutdown.2:121
msgid "B<close>(2), B<connect>(2), B<socket>(2), B<socket>(7)"
msgstr ""

#. type: TH
#: build/C/man7/tcp.7:96
#, no-wrap
msgid "TCP"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:99
msgid "tcp - TCP protocol"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:105
msgid "B<#include E<lt>netinet/tcp.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:107
msgid "B<tcp_socket = socket(AF_INET, SOCK_STREAM, 0);>"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:120
msgid ""
"This is an implementation of the TCP protocol defined in RFC\\ 793, RFC\\ "
"1122 and RFC\\ 2001 with the NewReno and SACK extensions.  It provides a "
"reliable, stream-oriented, full-duplex connection between two sockets on top "
"of B<ip>(7), for both v4 and v6 versions.  TCP guarantees that the data "
"arrives in order and retransmits lost packets.  It generates and checks a "
"per-packet checksum to catch transmission errors.  TCP does not preserve "
"record boundaries."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:139
msgid ""
"A newly created TCP socket has no remote or local address and is not fully "
"specified.  To create an outgoing TCP connection use B<connect>(2)  to "
"establish a connection to another TCP socket.  To receive new incoming "
"connections, first B<bind>(2)  the socket to a local address and port and "
"then call B<listen>(2)  to put the socket into the listening state.  After "
"that a new socket for each incoming connection can be accepted using "
"B<accept>(2).  A socket which has had B<accept>(2)  or B<connect>(2)  "
"successfully called on it is fully specified and may transmit data.  Data "
"cannot be transmitted on listening or not yet connected sockets."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:159
msgid ""
"Linux supports RFC\\ 1323 TCP high performance extensions.  These include "
"Protection Against Wrapped Sequence Numbers (PAWS), Window Scaling and "
"Timestamps.  Window scaling allows the use of large (E<gt> 64\\ kB) TCP "
"windows in order to support links with high latency or bandwidth.  To make "
"use of them, the send and receive buffer sizes must be increased.  They can "
"be set globally with the I</proc/sys/net/ipv4/tcp_wmem> and "
"I</proc/sys/net/ipv4/tcp_rmem> files, or on individual sockets by using the "
"B<SO_SNDBUF> and B<SO_RCVBUF> socket options with the B<setsockopt>(2)  "
"call."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:190
msgid ""
"The maximum sizes for socket buffers declared via the B<SO_SNDBUF> and "
"B<SO_RCVBUF> mechanisms are limited by the values in the "
"I</proc/sys/net/core/rmem_max> and I</proc/sys/net/core/wmem_max> files.  "
"Note that TCP actually allocates twice the size of the buffer requested in "
"the B<setsockopt>(2)  call, and so a succeeding B<getsockopt>(2)  call will "
"not return the same size of buffer as requested in the B<setsockopt>(2)  "
"call.  TCP uses the extra space for administrative purposes and internal "
"kernel structures, and the I</proc> file values reflect the larger sizes "
"compared to the actual TCP windows.  On individual connections, the socket "
"buffer size must be set prior to the B<listen>(2)  or B<connect>(2)  calls "
"in order to have it take effect.  See B<socket>(7)  for more information."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:222
msgid ""
"TCP supports urgent data.  Urgent data is used to signal the receiver that "
"some important message is part of the data stream and that it should be "
"processed as soon as possible.  To send urgent data specify the B<MSG_OOB> "
"option to B<send>(2).  When urgent data is received, the kernel sends a "
"B<SIGURG> signal to the process or process group that has been set as the "
"socket \"owner\" using the B<SIOCSPGRP> or B<FIOSETOWN> ioctls (or the "
"POSIX.1-specified B<fcntl>(2)  B<F_SETOWN> operation).  When the "
"B<SO_OOBINLINE> socket option is enabled, urgent data is put into the normal "
"data stream (a program can test for its location using the B<SIOCATMARK> "
"ioctl described below), otherwise it can be received only when the "
"B<MSG_OOB> flag is set for B<recv>(2)  or B<recvmsg>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:230
msgid ""
"When out-of-band data is present, B<select>(2)  indicates the file "
"descriptor as having an exceptional condition and I<poll (2)> indicates a "
"B<POLLPRI> event."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:238
msgid ""
"Linux 2.4 introduced a number of changes for improved throughput and "
"scaling, as well as enhanced functionality.  Some of these features include "
"support for zero-copy B<sendfile>(2), Explicit Congestion Notification, new "
"management of TIME_WAIT sockets, keep-alive socket options and support for "
"Duplicate SACK extensions."
msgstr ""

#. type: SS
#: build/C/man7/tcp.7:238
#, no-wrap
msgid "Address formats"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:247
msgid ""
"TCP is built on top of IP (see B<ip>(7)).  The address formats defined by "
"B<ip>(7)  apply to TCP.  TCP supports point-to-point communication only; "
"broadcasting and multicasting are not supported."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:259
msgid ""
"System-wide TCP parameter settings can be accessed by files in the directory "
"I</proc/sys/net/ipv4/>.  In addition, most IP I</proc> interfaces also apply "
"to TCP; see B<ip>(7).  Variables described as I<Boolean> take an integer "
"value, with a nonzero value (\"true\") meaning that the corresponding option "
"is enabled, and a zero value (\"false\")  meaning that the option is "
"disabled."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:259
#, no-wrap
msgid "I<tcp_abc> (Integer; default: 0; Linux 2.6.15 to Linux 3.8)"
msgstr ""

#.  Since 2.6.15; removed in 3.9
#.  commit ca2eb5679f8ddffff60156af42595df44a315ef0
#.  The following is from 2.6.28-rc4: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:269
msgid ""
"Control the Appropriate Byte Count (ABC), defined in RFC 3465.  ABC is a way "
"of increasing the congestion window (I<cwnd>)  more slowly in response to "
"partial acknowledgments.  Possible values are:"
msgstr ""

#. type: IP
#: build/C/man7/tcp.7:270 build/C/man7/tcp.7:432 build/C/man7/tcp.7:486 build/C/man7/tcp.7:510 build/C/man7/tcp.7:669 build/C/man7/tcp.7:853 build/C/man7/tcp.7:869
#, no-wrap
msgid "0"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:274
msgid "increase I<cwnd> once per acknowledgment (no ABC)"
msgstr ""

#. type: IP
#: build/C/man7/tcp.7:274 build/C/man7/tcp.7:436 build/C/man7/tcp.7:489 build/C/man7/tcp.7:517 build/C/man7/tcp.7:671 build/C/man7/tcp.7:855 build/C/man7/tcp.7:871
#, no-wrap
msgid "1"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:278
msgid "increase I<cwnd> once per acknowledgment of full sized segment"
msgstr ""

#. type: IP
#: build/C/man7/tcp.7:278 build/C/man7/tcp.7:439 build/C/man7/tcp.7:491 build/C/man7/tcp.7:524 build/C/man7/tcp.7:673 build/C/man7/tcp.7:857 build/C/man7/tcp.7:874
#, no-wrap
msgid "2"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:283
msgid ""
"allow increase I<cwnd> by two if acknowledgment is of two segments to "
"compensate for delayed acknowledgments."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:284
#, no-wrap
msgid "I<tcp_abort_on_overflow> (Boolean; default: disabled; since Linux 2.4)"
msgstr ""

#.  Since 2.3.41
#. type: Plain text
#: build/C/man7/tcp.7:296
msgid ""
"Enable resetting connections if the listening service is too slow and unable "
"to keep up and accept them.  It means that if overflow occurred due to a "
"burst, the connection will recover.  Enable this option I<only> if you are "
"really sure that the listening daemon cannot be tuned to accept connections "
"faster.  Enabling this option can harm the clients of your server."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:296
#, no-wrap
msgid "I<tcp_adv_win_scale> (integer; default: 2; since Linux 2.4)"
msgstr ""

#.  Since 2.4.0-test7
#. type: Plain text
#: build/C/man7/tcp.7:308
msgid ""
"Count buffering overhead as I<bytes/2^tcp_adv_win_scale>, if "
"I<tcp_adv_win_scale> is greater than 0; or "
"I<bytes-bytes/2^(-tcp_adv_win_scale)>, if I<tcp_adv_win_scale> is less than "
"or equal to zero."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:321
msgid ""
"The socket receive buffer space is shared between the application and "
"kernel.  TCP maintains part of the buffer as the TCP window, this is the "
"size of the receive window advertised to the other end.  The rest of the "
"space is used as the \"application\" buffer, used to isolate the network "
"from scheduling and application latencies.  The I<tcp_adv_win_scale> default "
"value of 2 implies that the space used for the application buffer is one "
"fourth that of the total."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:321
#, no-wrap
msgid ""
"I<tcp_allowed_congestion_control> (String; default: see text; since Linux "
"2.4.20)"
msgstr ""

#.  The following is from 2.6.28-rc4: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:334
msgid ""
"Show/set the congestion control algorithm choices available to unprivileged "
"processes (see the description of the B<TCP_CONGESTION> socket option).  The "
"items in the list are separated by white space and terminated by a newline "
"character.  The list is a subset of those listed in "
"I<tcp_available_congestion_control>.  The default value for this list is "
"\"reno\" plus the default setting of I<tcp_congestion_control>."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:334
#, no-wrap
msgid "I<tcp_autocorking> (Boolean; default: enabled; since Linux 3.14)"
msgstr ""

#.  commit f54b311142a92ea2e42598e347b84e1655caf8e3
#.  Text heavily based on Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:351
msgid ""
"If this option is enabled, the kernel tries to coalesce small writes (from "
"consecutive B<write>(2)  and B<sendmsg>(2)  calls) as much as possible, in "
"order to decrease the total number of sent packets.  Coalescing is done if "
"at least one prior packet for the flow is waiting in Qdisc queues or device "
"transmit queue.  Applications can still use the B<TCP_CORK> socket option to "
"obtain optimal behavior when they know how/when to uncork their sockets."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:351
#, no-wrap
msgid "I<tcp_available_congestion_control> (String; read-only; since Linux 2.4.20)"
msgstr ""

#.  The following is from 2.6.28-rc4: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:362
msgid ""
"Show a list of the congestion-control algorithms that are registered.  The "
"items in the list are separated by white space and terminated by a newline "
"character.  This list is a limiting set for the list in "
"I<tcp_allowed_congestion_control>.  More congestion-control algorithms may "
"be available as modules, but not loaded."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:362
#, no-wrap
msgid "I<tcp_app_win> (integer; default: 31; since Linux 2.4)"
msgstr ""

#.  Since 2.4.0-test7
#. type: Plain text
#: build/C/man7/tcp.7:367
msgid ""
"This variable defines how many bytes of the TCP window are reserved for "
"buffering overhead."
msgstr ""

#
#.  The following is from 2.6.28-rc4: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:373
msgid ""
"A maximum of (I<window/2^tcp_app_win>, mss) bytes in the window are reserved "
"for the application buffer.  A value of 0 implies that no amount is "
"reserved."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:373
#, no-wrap
msgid "I<tcp_base_mss> (Integer; default: 512; since Linux 2.6.17)"
msgstr ""

#
#.  The following is from 2.6.12: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:382
msgid ""
"The initial value of I<search_low> to be used by the packetization layer "
"Path MTU discovery (MTU probing).  If MTU probing is enabled, this is the "
"initial MSS used by the connection."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:382
#, no-wrap
msgid "I<tcp_bic> (Boolean; default: disabled; Linux 2.4.27/2.6.6 to 2.6.13)"
msgstr ""

#
#.  The following is from 2.6.12: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:396
msgid ""
"Enable BIC TCP congestion control algorithm.  BIC-TCP is a sender-side-only "
"change that ensures a linear RTT fairness under large windows while offering "
"both scalability and bounded TCP-friendliness.  The protocol combines two "
"schemes called additive increase and binary search increase.  When the "
"congestion window is large, additive increase with a large increment ensures "
"linear RTT fairness as well as good scalability.  Under small congestion "
"windows, binary search increase provides TCP friendliness."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:396
#, no-wrap
msgid "I<tcp_bic_low_window> (integer; default: 14; Linux 2.4.27/2.6.6 to 2.6.13)"
msgstr ""

#
#.  The following is from 2.6.12: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:403
msgid ""
"Set the threshold window (in packets) where BIC TCP starts to adjust the "
"congestion window.  Below this threshold BIC TCP behaves the same as the "
"default TCP Reno."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:403
#, no-wrap
msgid ""
"I<tcp_bic_fast_convergence> (Boolean; default: enabled; Linux 2.4.27/2.6.6 "
"to 2.6.13)"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:407
msgid ""
"Force BIC TCP to more quickly respond to changes in congestion window.  "
"Allows two flows sharing the same connection to converge more rapidly."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:407
#, no-wrap
msgid "I<tcp_congestion_control> (String; default: see text; since Linux 2.4.13)"
msgstr ""

#.  The following is from 2.6.28-rc4: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:414
msgid ""
"Set the default congestion-control algorithm to be used for new "
"connections.  The algorithm \"reno\" is always available, but additional "
"choices may be available depending on kernel configuration.  The default "
"value for this file is set as part of kernel configuration."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:414
#, no-wrap
msgid "I<tcp_dma_copybreak> (integer; default: 4096; since Linux 2.6.24)"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:421
msgid ""
"Lower limit, in bytes, of the size of socket reads that will be offloaded to "
"a DMA copy engine, if one is present in the system and the kernel was "
"configured with the B<CONFIG_NET_DMA> option."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:421
#, no-wrap
msgid "I<tcp_dsack> (Boolean; default: enabled; since Linux 2.4)"
msgstr ""

#.  Since 2.4.0-test7
#. type: Plain text
#: build/C/man7/tcp.7:425
msgid "Enable RFC\\ 2883 TCP Duplicate SACK support."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:425
#, no-wrap
msgid "I<tcp_ecn> (Integer; default: see below; since Linux 2.4)"
msgstr ""

#.  Since 2.4.0-test7
#. type: Plain text
#: build/C/man7/tcp.7:429
msgid "Enable RFC\\ 3168 Explicit Congestion Notification."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:431 build/C/man7/tcp.7:485
msgid "This file can have one of the following values:"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:436
msgid ""
"Disable ECN.  Neither initiate nor accept ECN.  This was the default up to "
"and including Linux 2.6.30."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:439
msgid ""
"Enable ECN when requested by incoming connections and also request ECN on "
"outgoing connection attempts."
msgstr ""

#.  commit 255cac91c3c9ce7dca7713b93ab03c75b7902e0e
#. type: Plain text
#: build/C/man7/tcp.7:444
msgid ""
"Enable ECN when requested by incoming connections, but do not request ECN on "
"outgoing connections.  This value is supported, and is the default, since "
"Linux 2.6.31."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:453
msgid ""
"When enabled, connectivity to some destinations could be affected due to "
"older, misbehaving middle boxes along the path, causing connections to be "
"dropped.  However, to facilitate and encourage deployment with option 1, and "
"to work around such buggy equipment, the B<tcp_ecn_fallback> option has been "
"introduced."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:453
#, no-wrap
msgid "I<tcp_ecn_fallback> (Boolean; default: enabled; since Linux 4.1)"
msgstr ""

#.  commit 492135557dc090a1abb2cfbe1a412757e3ed68ab
#. type: Plain text
#: build/C/man7/tcp.7:460
msgid ""
"Enable RFC\\ 3168, Section 6.1.1.1. fallback.  When enabled, outgoing "
"ECN-setup SYNs that time out within the normal SYN retransmission timeout "
"will be resent with CWR and ECE cleared."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:460
#, no-wrap
msgid "I<tcp_fack> (Boolean; default: enabled; since Linux 2.2)"
msgstr ""

#.  Since 2.1.92
#. type: Plain text
#: build/C/man7/tcp.7:464
msgid "Enable TCP Forward Acknowledgement support."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:464
#, no-wrap
msgid "I<tcp_fin_timeout> (integer; default: 60; since Linux 2.2)"
msgstr ""

#.  Since 2.1.53
#
#.  The following is from 2.6.12: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:474
msgid ""
"This specifies how many seconds to wait for a final FIN packet before the "
"socket is forcibly closed.  This is strictly a violation of the TCP "
"specification, but required to prevent denial-of-service attacks.  In Linux "
"2.2, the default value was 180."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:474
#, no-wrap
msgid "I<tcp_frto> (integer; default: see below; since Linux 2.4.21/2.6)"
msgstr ""

#.  Since 2.4.21/2.5.43
#. type: Plain text
#: build/C/man7/tcp.7:483
msgid ""
"Enable F-RTO, an enhanced recovery algorithm for TCP retransmission timeouts "
"(RTOs).  It is particularly beneficial in wireless environments where packet "
"loss is typically due to random radio interference rather than intermediate "
"router congestion.  See RFC 4138 for more details."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:489
msgid "Disabled.  This was the default up to and including Linux 2.6.23."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:491
msgid "The basic version F-RTO algorithm is enabled."
msgstr ""

#.  commit c96fd3d461fa495400df24be3b3b66f0e0b152f9
#. type: Plain text
#: build/C/man7/tcp.7:498
msgid ""
"Enable SACK-enhanced F-RTO if flow uses SACK.  The basic version can be used "
"also when SACK is in use though in that case scenario(s) exists where F-RTO "
"interacts badly with the packet counting of the SACK-enabled TCP flow.  This "
"value is the default since Linux 2.6.24."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:502
msgid ""
"Before Linux 2.6.22, this parameter was a Boolean value, supporting just "
"values 0 and 1 above."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:502
#, no-wrap
msgid "I<tcp_frto_response> (integer; default: 0; since Linux 2.6.22)"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:509
msgid ""
"When F-RTO has detected that a TCP retransmission timeout was spurious "
"(i.e., the timeout would have been avoided had TCP set a longer "
"retransmission timeout), TCP has several options concerning what to do "
"next.  Possible values are:"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:517
msgid ""
"Rate halving based; a smooth and conservative response, results in halved "
"congestion window (I<cwnd>)  and slow-start threshold (I<ssthresh>)  after "
"one RTT."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:524
msgid ""
"Very conservative response; not recommended because even though being valid, "
"it interacts poorly with the rest of Linux TCP; halves I<cwnd> and "
"I<ssthresh> immediately."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:533
msgid ""
"Aggressive response; undoes congestion-control measures that are now known "
"to be unnecessary (ignoring the possibility of a lost retransmission that "
"would require TCP to be more cautious); I<cwnd> and I<ssthresh> are restored "
"to the values prior to timeout."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:534
#, no-wrap
msgid "I<tcp_keepalive_intvl> (integer; default: 75; since Linux 2.4)"
msgstr ""

#.  Since 2.3.18
#. type: Plain text
#: build/C/man7/tcp.7:538
msgid "The number of seconds between TCP keep-alive probes."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:538
#, no-wrap
msgid "I<tcp_keepalive_probes> (integer; default: 9; since Linux 2.2)"
msgstr ""

#.  Since 2.1.43
#. type: Plain text
#: build/C/man7/tcp.7:544
msgid ""
"The maximum number of TCP keep-alive probes to send before giving up and "
"killing the connection if no response is obtained from the other end."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:544
#, no-wrap
msgid "I<tcp_keepalive_time> (integer; default: 7200; since Linux 2.2)"
msgstr ""

#.  Since 2.1.43
#. type: Plain text
#: build/C/man7/tcp.7:556
msgid ""
"The number of seconds a connection needs to be idle before TCP begins "
"sending out keep-alive probes.  Keep-alives are sent only when the "
"B<SO_KEEPALIVE> socket option is enabled.  The default value is 7200 seconds "
"(2 hours).  An idle connection is terminated after approximately an "
"additional 11 minutes (9 probes an interval of 75 seconds apart) when "
"keep-alive is enabled."
msgstr ""

#
#.  The following is from 2.6.12: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:561
msgid ""
"Note that underlying connection tracking mechanisms and application timeouts "
"may be much shorter."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:561
#, no-wrap
msgid ""
"I<tcp_low_latency> (Boolean; default: disabled; since Linux 2.4.21/2.6; "
"obsolete since Linux 4.14)"
msgstr ""

#.  Since 2.4.21/2.5.60
#.  commit b6690b14386698ce2c19309abad3f17656bdfaea
#. type: Plain text
#: build/C/man7/tcp.7:573
msgid ""
"If enabled, the TCP stack makes decisions that prefer lower latency as "
"opposed to higher throughput.  It this option is disabled, then higher "
"throughput is preferred.  An example of an application where this default "
"should be changed would be a Beowulf compute cluster.  Since Linux 4.14, "
"this file still exists, but its value is ignored."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:573
#, no-wrap
msgid "I<tcp_max_orphans> (integer; default: see below; since Linux 2.4)"
msgstr ""

#.  Since 2.3.41
#. type: Plain text
#: build/C/man7/tcp.7:587
msgid ""
"The maximum number of orphaned (not attached to any user file handle) TCP "
"sockets allowed in the system.  When this number is exceeded, the orphaned "
"connection is reset and a warning is printed.  This limit exists only to "
"prevent simple denial-of-service attacks.  Lowering this limit is not "
"recommended.  Network conditions might require you to increase the number of "
"orphans allowed, but note that each orphan can eat up to \\(ti64\\ kB of "
"unswappable memory.  The default initial value is set equal to the kernel "
"parameter NR_FILE.  This initial default is adjusted depending on the memory "
"in the system."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:587
#, no-wrap
msgid "I<tcp_max_syn_backlog> (integer; default: see below; since Linux 2.2)"
msgstr ""

#.  Since 2.1.53
#. type: Plain text
#: build/C/man7/tcp.7:598
msgid ""
"The maximum number of queued connection requests which have still not "
"received an acknowledgement from the connecting client.  If this number is "
"exceeded, the kernel will begin dropping requests.  The default value of 256 "
"is increased to 1024 when the memory present in the system is adequate or "
"greater (E<gt>= 128\\ MB), and reduced to 128 for those systems with very "
"low memory (E<lt>= 32\\ MB)."
msgstr ""

#.  commit 72a3effaf633bcae9034b7e176bdbd78d64a71db
#. type: Plain text
#: build/C/man7/tcp.7:607
msgid ""
"Prior to Linux 2.6.20, it was recommended that if this needed to be "
"increased above 1024, the size of the SYNACK hash table (B<TCP_SYNQ_HSIZE>)  "
"in I<include/net/tcp.h> should be modified to keep"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:609
#, no-wrap
msgid "    TCP_SYNQ_HSIZE * 16 E<lt>= tcp_max_syn_backlog\n"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:615
msgid ""
"and the kernel should be recompiled.  In Linux 2.6.20, the fixed sized "
"B<TCP_SYNQ_HSIZE> was removed in favor of dynamic sizing."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:615
#, no-wrap
msgid "I<tcp_max_tw_buckets> (integer; default: see below; since Linux 2.4)"
msgstr ""

#.  Since 2.3.41
#. type: Plain text
#: build/C/man7/tcp.7:625
msgid ""
"The maximum number of sockets in TIME_WAIT state allowed in the system.  "
"This limit exists only to prevent simple denial-of-service attacks.  The "
"default value of NR_FILE*2 is adjusted depending on the memory in the "
"system.  If this number is exceeded, the socket is closed and a warning is "
"printed."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:625
#, no-wrap
msgid "I<tcp_moderate_rcvbuf> (Boolean; default: enabled; since Linux 2.4.17/2.6.7)"
msgstr ""

#.  The following is from 2.6.28-rc4: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:632
msgid ""
"If enabled, TCP performs receive buffer auto-tuning, attempting to "
"automatically size the buffer (no greater than I<tcp_rmem[2]>)  to match the "
"size required by the path for full throughput."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:632
#, no-wrap
msgid "I<tcp_mem> (since Linux 2.4)"
msgstr ""

#.  Since 2.4.0-test7
#. type: Plain text
#: build/C/man7/tcp.7:644
msgid ""
"This is a vector of 3 integers: [low, pressure, high].  These bounds, "
"measured in units of the system page size, are used by TCP to track its "
"memory usage.  The defaults are calculated at boot time from the amount of "
"available memory.  (TCP can only use I<low memory> for this, which is "
"limited to around 900 megabytes on 32-bit systems.  64-bit systems do not "
"suffer this limitation.)"
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:645
#, no-wrap
msgid "I<low>"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:649
msgid ""
"TCP doesn't regulate its memory allocation when the number of pages it has "
"allocated globally is below this number."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:649 build/C/man7/udp.7:151
#, no-wrap
msgid "I<pressure>"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:658
msgid ""
"When the amount of memory allocated by TCP exceeds this number of pages, TCP "
"moderates its memory consumption.  This memory pressure state is exited once "
"the number of pages allocated falls below the I<low> mark."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:658
#, no-wrap
msgid "I<high>"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:662
msgid ""
"The maximum number of pages, globally, that TCP will allocate.  This value "
"overrides any other limits imposed by the kernel."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:663
#, no-wrap
msgid "I<tcp_mtu_probing> (integer; default: 0; since Linux 2.6.17)"
msgstr ""

#.  The following is from 2.6.28-rc4: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:668
msgid ""
"This parameter controls TCP Packetization-Layer Path MTU Discovery.  The "
"following values may be assigned to the file:"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:671
msgid "Disabled"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:673
msgid "Disabled by default, enabled when an ICMP black hole detected"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:676
msgid "Always enabled, use initial MSS of I<tcp_base_mss>."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:677
#, no-wrap
msgid "I<tcp_no_metrics_save> (Boolean; default: disabled; since Linux 2.6.6)"
msgstr ""

#.  The following is from 2.6.28-rc4: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:688
msgid ""
"By default, TCP saves various connection metrics in the route cache when the "
"connection closes, so that connections established in the near future can "
"use these to set initial conditions.  Usually, this increases overall "
"performance, but it may sometimes cause performance degradation.  If "
"I<tcp_no_metrics_save> is enabled, TCP will not cache metrics on closing "
"connections."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:688
#, no-wrap
msgid "I<tcp_orphan_retries> (integer; default: 8; since Linux 2.4)"
msgstr ""

#.  Since 2.3.41
#. type: Plain text
#: build/C/man7/tcp.7:693
msgid ""
"The maximum number of attempts made to probe the other end of a connection "
"which has been closed by our end."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:693
#, no-wrap
msgid "I<tcp_reordering> (integer; default: 3; since Linux 2.4)"
msgstr ""

#.  Since 2.4.0-test7
#. type: Plain text
#: build/C/man7/tcp.7:702
msgid ""
"The maximum a packet can be reordered in a TCP packet stream without TCP "
"assuming packet loss and going into slow start.  It is not advisable to "
"change this number.  This is a packet reordering detection metric designed "
"to minimize unnecessary back off and retransmits provoked by reordering of "
"packets on a connection."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:702
#, no-wrap
msgid "I<tcp_retrans_collapse> (Boolean; default: enabled; since Linux 2.2)"
msgstr ""

#.  Since 2.1.96
#. type: Plain text
#: build/C/man7/tcp.7:706
msgid "Try to send full-sized packets during retransmit."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:706
#, no-wrap
msgid "I<tcp_retries1> (integer; default: 3; since Linux 2.2)"
msgstr ""

#.  Since 2.1.43
#. type: Plain text
#: build/C/man7/tcp.7:716
msgid ""
"The number of times TCP will attempt to retransmit a packet on an "
"established connection normally, without the extra effort of getting the "
"network layers involved.  Once we exceed this number of retransmits, we "
"first have the network layer update the route if possible before each new "
"retransmit.  The default is the RFC specified minimum of 3."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:716
#, no-wrap
msgid "I<tcp_retries2> (integer; default: 15; since Linux 2.2)"
msgstr ""

#.  Since 2.1.43
#. type: Plain text
#: build/C/man7/tcp.7:726
msgid ""
"The maximum number of times a TCP packet is retransmitted in established "
"state before giving up.  The default value is 15, which corresponds to a "
"duration of approximately between 13 to 30 minutes, depending on the "
"retransmission timeout.  The RFC\\ 1122 specified minimum limit of 100 "
"seconds is typically deemed too short."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:726
#, no-wrap
msgid "I<tcp_rfc1337> (Boolean; default: disabled; since Linux 2.2)"
msgstr ""

#.  Since 2.1.90
#. type: Plain text
#: build/C/man7/tcp.7:734
msgid ""
"Enable TCP behavior conformant with RFC\\ 1337.  When disabled, if a RST is "
"received in TIME_WAIT state, we close the socket immediately without waiting "
"for the end of the TIME_WAIT period."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:734
#, no-wrap
msgid "I<tcp_rmem> (since Linux 2.4)"
msgstr ""

#.  Since 2.4.0-test7
#. type: Plain text
#: build/C/man7/tcp.7:742
msgid ""
"This is a vector of 3 integers: [min, default, max].  These parameters are "
"used by TCP to regulate receive buffer sizes.  TCP dynamically adjusts the "
"size of the receive buffer from the defaults listed below, in the range of "
"these values, depending on memory available in the system."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:743 build/C/man7/tcp.7:953 build/C/man7/udp.7:145
#, no-wrap
msgid "I<min>"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:758
msgid ""
"minimum size of the receive buffer used by each TCP socket.  The default "
"value is the system page size.  (On Linux 2.4, the default value is 4\\ kB, "
"lowered to B<PAGE_SIZE> bytes in low-memory systems.)  This value is used to "
"ensure that in memory pressure mode, allocations below this size will still "
"succeed.  This is not used to bound the size of the receive buffer declared "
"using B<SO_RCVBUF> on a socket."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:758 build/C/man7/tcp.7:963
#, no-wrap
msgid "I<default>"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:772
msgid ""
"the default size of the receive buffer for a TCP socket.  This value "
"overwrites the initial default buffer size from the generic global "
"I<net.core.rmem_default> defined for all protocols.  The default value is "
"87380 bytes.  (On Linux 2.4, this will be lowered to 43689 in low-memory "
"systems.)  If larger receive buffer sizes are desired, this value should be "
"increased (to affect all sockets).  To employ large TCP windows, the "
"I<net.ipv4.tcp_window_scaling> must be enabled (default)."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:772 build/C/man7/tcp.7:977 build/C/man7/udp.7:157
#, no-wrap
msgid "I<max>"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:781
msgid ""
"the maximum size of the receive buffer used by each TCP socket.  This value "
"does not override the global I<net.core.rmem_max>.  This is not used to "
"limit the size of the receive buffer declared using B<SO_RCVBUF> on a "
"socket.  The default value is calculated using the formula"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:783
#, no-wrap
msgid "    max(87380, min(4\\ MB, I<tcp_mem>[1]*PAGE_SIZE/128))\n"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:786
msgid ""
"(On Linux 2.4, the default is 87380*2 bytes, lowered to 87380 in low-memory "
"systems)."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:787
#, no-wrap
msgid "I<tcp_sack> (Boolean; default: enabled; since Linux 2.2)"
msgstr ""

#.  Since 2.1.36
#. type: Plain text
#: build/C/man7/tcp.7:791
msgid "Enable RFC\\ 2018 TCP Selective Acknowledgements."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:791
#, no-wrap
msgid "I<tcp_slow_start_after_idle> (Boolean; default: enabled; since Linux 2.6.18)"
msgstr ""

#.  The following is from 2.6.28-rc4: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:799
msgid ""
"If enabled, provide RFC 2861 behavior and time out the congestion window "
"after an idle period.  An idle period is defined as the current RTO "
"(retransmission timeout).  If disabled, the congestion window will not be "
"timed out after an idle period."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:799
#, no-wrap
msgid "I<tcp_stdurg> (Boolean; default: disabled; since Linux 2.2)"
msgstr ""

#.  Since 2.1.44
#.  RFC 793 was ambiguous in its specification of the meaning of the
#.  urgent pointer.  RFC 1122 (and RFC 961) fixed on a particular
#.  resolution of this ambiguity (unfortunately the "wrong" one).
#. type: Plain text
#: build/C/man7/tcp.7:813
msgid ""
"If this option is enabled, then use the RFC\\ 1122 interpretation of the TCP "
"urgent-pointer field.  According to this interpretation, the urgent pointer "
"points to the last byte of urgent data.  If this option is disabled, then "
"use the BSD-compatible interpretation of the urgent pointer: the urgent "
"pointer points to the first byte after the urgent data.  Enabling this "
"option may lead to interoperability problems."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:813
#, no-wrap
msgid "I<tcp_syn_retries> (integer; default: 6; since Linux 2.2)"
msgstr ""

#.  Since 2.1.38
#.  commit 6c9ff979d1921e9fd05d89e1383121c2503759b9
#. type: Plain text
#: build/C/man7/tcp.7:826
msgid ""
"The maximum number of times initial SYNs for an active TCP connection "
"attempt will be retransmitted.  This value should not be higher than 255.  "
"The default value is 6, which corresponds to retrying for up to "
"approximately 127 seconds.  Before Linux 3.7, the default value was 5, which "
"(in conjunction with calculation based on other kernel parameters)  "
"corresponded to approximately 180 seconds."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:826
#, no-wrap
msgid "I<tcp_synack_retries> (integer; default: 5; since Linux 2.2)"
msgstr ""

#.  Since 2.1.38
#. type: Plain text
#: build/C/man7/tcp.7:832
msgid ""
"The maximum number of times a SYN/ACK segment for a passive TCP connection "
"will be retransmitted.  This number should not be higher than 255."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:832
#, no-wrap
msgid "I<tcp_syncookies> (integer; default: 1; since Linux 2.2)"
msgstr ""

#.  Since 2.1.43
#. type: Plain text
#: build/C/man7/tcp.7:852
msgid ""
"Enable TCP syncookies.  The kernel must be compiled with "
"B<CONFIG_SYN_COOKIES>.  The syncookies feature attempts to protect a socket "
"from a SYN flood attack.  This should be used as a last resort, if at all.  "
"This is a violation of the TCP protocol, and conflicts with other areas of "
"TCP such as TCP extensions.  It can cause problems for clients and relays.  "
"It is not recommended as a tuning mechanism for heavily loaded servers to "
"help with overloaded or misconfigured conditions.  For recommended "
"alternatives see I<tcp_max_syn_backlog>, I<tcp_synack_retries>, and "
"I<tcp_abort_on_overflow>.  Set to one of the following values:"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:855
msgid "Disable TCP syncookies."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:857
msgid "Send out syncookies when the syn backlog queue of a socket overflows."
msgstr ""

#.  commit 5ad37d5deee1ff7150a2d0602370101de158ad86
#. type: Plain text
#: build/C/man7/tcp.7:862
msgid ""
"(since Linux 3.12)  Send out syncookies unconditionally.  This can be useful "
"for network testing."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:863
#, no-wrap
msgid "I<tcp_timestamps> (integer; default: 1; since Linux 2.2)"
msgstr ""

#.  Since 2.1.36
#. type: Plain text
#: build/C/man7/tcp.7:868
msgid ""
"Set to one of the following values to enable or disable RFC\\ 1323 TCP "
"timestamps:"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:871
msgid "Disable timestamps."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:874
msgid ""
"Enable timestamps as defined in RFC1323 and use random offset for each "
"connection rather than only using the current time."
msgstr ""

#.  commit 25429d7b7dca01dc4f17205de023a30ca09390d0
#. type: Plain text
#: build/C/man7/tcp.7:880
msgid ""
"As for the value 1, but without random offsets.  Setting I<tcp_timestamps> "
"to this value is meaningful since Linux 4.10."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:881
#, no-wrap
msgid "I<tcp_tso_win_divisor> (integer; default: 3; since Linux 2.6.9)"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:887
msgid ""
"This parameter controls what percentage of the congestion window can be "
"consumed by a single TCP Segmentation Offload (TSO) frame.  The setting of "
"this parameter is a tradeoff between burstiness and building larger TSO "
"frames."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:887
#, no-wrap
msgid "I<tcp_tw_recycle> (Boolean; default: disabled; Linux 2.4 to 4.11)"
msgstr ""

#.  Since 2.3.15
#.  removed in 4.12; commit 4396e46187ca5070219b81773c4e65088dac50cc
#
#.  The following is from 2.6.12: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:899
msgid ""
"Enable fast recycling of TIME_WAIT sockets.  Enabling this option is not "
"recommended as the remote IP may not use monotonically increasing timestamps "
"(devices behind NAT, devices with per-connection timestamp offsets).  See "
"RFC 1323 (PAWS) and RFC 6191."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:899
#, no-wrap
msgid "I<tcp_tw_reuse> (Boolean; default: disabled; since Linux 2.4.19/2.6)"
msgstr ""

#.  Since 2.4.19/2.5.43
#
#.  The following is from 2.6.12: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:907
msgid ""
"Allow to reuse TIME_WAIT sockets for new connections when it is safe from "
"protocol viewpoint.  It should not be changed without advice/request of "
"technical experts."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:907
#, no-wrap
msgid "I<tcp_vegas_cong_avoid> (Boolean; default: disabled; Linux 2.2 to 2.6.13)"
msgstr ""

#.  Since 2.1.8; removed in 2.6.13
#
#.  The following is from 2.6.12: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:918
msgid ""
"Enable TCP Vegas congestion avoidance algorithm.  TCP Vegas is a "
"sender-side-only change to TCP that anticipates the onset of congestion by "
"estimating the bandwidth.  TCP Vegas adjusts the sending rate by modifying "
"the congestion window.  TCP Vegas should provide less packet loss, but it is "
"not as aggressive as TCP Reno."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:918
#, no-wrap
msgid "I<tcp_westwood> (Boolean; default: disabled; Linux 2.4.26/2.6.3 to 2.6.13)"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:930
msgid ""
"Enable TCP Westwood+ congestion control algorithm.  TCP Westwood+ is a "
"sender-side-only modification of the TCP Reno protocol stack that optimizes "
"the performance of TCP congestion control.  It is based on end-to-end "
"bandwidth estimation to set congestion window and slow start threshold after "
"a congestion episode.  Using this estimation, TCP Westwood+ adaptively sets "
"a slow start threshold and a congestion window which takes into account the "
"bandwidth used at the time congestion is experienced.  TCP Westwood+ "
"significantly increases fairness with respect to TCP Reno in wired networks "
"and throughput over wireless links."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:930
#, no-wrap
msgid "I<tcp_window_scaling> (Boolean; default: enabled; since Linux 2.2)"
msgstr ""

#.  Since 2.1.36
#. type: Plain text
#: build/C/man7/tcp.7:944
msgid ""
"Enable RFC\\ 1323 TCP window scaling.  This feature allows the use of a "
"large window (E<gt> 64\\ kB) on a TCP connection, should the other end "
"support it.  Normally, the 16 bit window length field in the TCP header "
"limits the window size to less than 64\\ kB.  If larger windows are desired, "
"applications can increase the size of their socket buffers and the window "
"scaling option will be employed.  If I<tcp_window_scaling> is disabled, TCP "
"will not negotiate the use of window scaling with the other end during "
"connection setup."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:944
#, no-wrap
msgid "I<tcp_wmem> (since Linux 2.4)"
msgstr ""

#.  Since 2.4.0-test7
#. type: Plain text
#: build/C/man7/tcp.7:952
msgid ""
"This is a vector of 3 integers: [min, default, max].  These parameters are "
"used by TCP to regulate send buffer sizes.  TCP dynamically adjusts the size "
"of the send buffer from the default values listed below, in the range of "
"these values, depending on memory available."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:963
msgid ""
"Minimum size of the send buffer used by each TCP socket.  The default value "
"is the system page size.  (On Linux 2.4, the default value is 4\\ kB.)  This "
"value is used to ensure that in memory pressure mode, allocations below this "
"size will still succeed.  This is not used to bound the size of the send "
"buffer declared using B<SO_SNDBUF> on a socket."
msgstr ""

#.  True in Linux 2.4 and 2.6
#. type: Plain text
#: build/C/man7/tcp.7:977
msgid ""
"The default size of the send buffer for a TCP socket.  This value overwrites "
"the initial default buffer size from the generic global "
"I</proc/sys/net/core/wmem_default> defined for all protocols.  The default "
"value is 16\\ kB.  If larger send buffer sizes are desired, this value "
"should be increased (to affect all sockets).  To employ large TCP windows, "
"the I</proc/sys/net/ipv4/tcp_window_scaling> must be set to a nonzero value "
"(default)."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:986
msgid ""
"The maximum size of the send buffer used by each TCP socket.  This value "
"does not override the value in I</proc/sys/net/core/wmem_max>.  This is not "
"used to limit the size of the send buffer declared using B<SO_SNDBUF> on a "
"socket.  The default value is calculated using the formula"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:988
#, no-wrap
msgid "    max(65536, min(4\\ MB, I<tcp_mem>[1]*PAGE_SIZE/128))\n"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:991
msgid ""
"(On Linux 2.4, the default value is 128\\ kB, lowered 64\\ kB depending on "
"low-memory systems.)"
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:992
#, no-wrap
msgid ""
"I<tcp_workaround_signed_windows> (Boolean; default: disabled; since Linux "
"2.6.26)"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:998
msgid ""
"If enabled, assume that no receipt of a window-scaling option means that the "
"remote TCP is broken and treats the window as a signed quantity.  If "
"disabled, assume that the remote TCP is not broken even if we do not receive "
"a window scaling option from it."
msgstr ""

#.  or SOL_TCP on Linux
#. type: Plain text
#: build/C/man7/tcp.7:1016
msgid ""
"To set or get a TCP socket option, call B<getsockopt>(2)  to read or "
"B<setsockopt>(2)  to write the option with the option level argument set to "
"B<IPPROTO_TCP>.  Unless otherwise noted, I<optval> is a pointer to an "
"I<int>.  In addition, most B<IPPROTO_IP> socket options are valid on TCP "
"sockets.  For more information see B<ip>(7)."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:1021
msgid ""
"Following is a list of TCP-specific socket options.  For details of some "
"other socket options that are also applicable for TCP sockets, see "
"B<socket>(7)."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:1021
#, no-wrap
msgid "B<TCP_CONGESTION> (since Linux 2.6.13)"
msgstr ""

#. 	    commit 5f8ef48d240963093451bcf83df89f1a1364f51d
#. 	    Author: Stephen Hemminger <shemminger@osdl.org>
#. type: Plain text
#: build/C/man7/tcp.7:1037
msgid ""
"The argument for this option is a string.  This option allows the caller to "
"set the TCP congestion control algorithm to be used, on a per-socket basis.  "
"Unprivileged processes are restricted to choosing one of the algorithms in "
"I<tcp_allowed_congestion_control> (described above).  Privileged processes "
"(B<CAP_NET_ADMIN>)  can choose from any of the available congestion-control "
"algorithms (see the description of I<tcp_available_congestion_control> "
"above)."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:1037
#, no-wrap
msgid "B<TCP_CORK> (since Linux 2.2)"
msgstr ""

#.  precisely: since 2.1.127
#. type: Plain text
#: build/C/man7/tcp.7:1053
msgid ""
"If set, don't send out partial frames.  All queued partial frames are sent "
"when the option is cleared again.  This is useful for prepending headers "
"before calling B<sendfile>(2), or for throughput optimization.  As currently "
"implemented, there is a 200 millisecond ceiling on the time for which output "
"is corked by B<TCP_CORK>.  If this ceiling is reached, then queued data is "
"automatically transmitted.  This option can be combined with B<TCP_NODELAY> "
"only since Linux 2.5.71.  This option should not be used in code intended to "
"be portable."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:1053
#, no-wrap
msgid "B<TCP_DEFER_ACCEPT> (since Linux 2.4)"
msgstr ""

#.  Precisely: since 2.3.38
#.  Useful references:
#.  http://www.techrepublic.com/article/take-advantage-of-tcp-ip-options-to-optimize-data-transmission/
#.  http://unix.stackexchange.com/questions/94104/real-world-use-of-tcp-defer-accept
#. type: Plain text
#: build/C/man7/tcp.7:1064
msgid ""
"Allow a listener to be awakened only when data arrives on the socket.  Takes "
"an integer value (seconds), this can bound the maximum number of attempts "
"TCP will make to complete the connection.  This option should not be used in "
"code intended to be portable."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:1064
#, no-wrap
msgid "B<TCP_INFO> (since Linux 2.4)"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:1070
msgid ""
"Used to collect information about this socket.  The kernel returns a "
"I<struct tcp_info> as defined in the file I</usr/include/linux/tcp.h>.  This "
"option should not be used in code intended to be portable."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:1070
#, no-wrap
msgid "B<TCP_KEEPCNT> (since Linux 2.4)"
msgstr ""

#.  Precisely: since 2.3.18
#. type: Plain text
#: build/C/man7/tcp.7:1077
msgid ""
"The maximum number of keepalive probes TCP should send before dropping the "
"connection.  This option should not be used in code intended to be portable."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:1077
#, no-wrap
msgid "B<TCP_KEEPIDLE> (since Linux 2.4)"
msgstr ""

#.  Precisely: since 2.3.18
#. type: Plain text
#: build/C/man7/tcp.7:1086
msgid ""
"The time (in seconds) the connection needs to remain idle before TCP starts "
"sending keepalive probes, if the socket option B<SO_KEEPALIVE> has been set "
"on this socket.  This option should not be used in code intended to be "
"portable."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:1086
#, no-wrap
msgid "B<TCP_KEEPINTVL> (since Linux 2.4)"
msgstr ""

#.  Precisely: since 2.3.18
#. type: Plain text
#: build/C/man7/tcp.7:1091
msgid ""
"The time (in seconds) between individual keepalive probes.  This option "
"should not be used in code intended to be portable."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:1091
#, no-wrap
msgid "B<TCP_LINGER2> (since Linux 2.4)"
msgstr ""

#.  Precisely: since 2.3.41
#. type: Plain text
#: build/C/man7/tcp.7:1103
msgid ""
"The lifetime of orphaned FIN_WAIT2 state sockets.  This option can be used "
"to override the system-wide setting in the file "
"I</proc/sys/net/ipv4/tcp_fin_timeout> for this socket.  This is not to be "
"confused with the B<socket>(7)  level option B<SO_LINGER>.  This option "
"should not be used in code intended to be portable."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:1103
#, no-wrap
msgid "B<TCP_MAXSEG>"
msgstr ""

#.  Present in Linux 1.0
#. type: Plain text
#: build/C/man7/tcp.7:1113
msgid ""
"The maximum segment size for outgoing TCP packets.  In Linux 2.2 and "
"earlier, and in Linux 2.6.28 and later, if this option is set before "
"connection establishment, it also changes the MSS value announced to the "
"other end in the initial packet.  Values greater than the (eventual) "
"interface MTU have no effect.  TCP will also impose its minimum and maximum "
"bounds over the value provided."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:1113
#, no-wrap
msgid "B<TCP_NODELAY>"
msgstr ""

#.  Present in Linux 1.0
#. type: Plain text
#: build/C/man7/tcp.7:1130
msgid ""
"If set, disable the Nagle algorithm.  This means that segments are always "
"sent as soon as possible, even if there is only a small amount of data.  "
"When not set, data is buffered until there is a sufficient amount to send "
"out, thereby avoiding the frequent sending of small packets, which results "
"in poor utilization of the network.  This option is overridden by "
"B<TCP_CORK>; however, setting this option forces an explicit flush of "
"pending output, even if B<TCP_CORK> is currently set."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:1130
#, no-wrap
msgid "B<TCP_QUICKACK> (since Linux 2.4.4)"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:1145
msgid ""
"Enable quickack mode if set or disable quickack mode if cleared.  In "
"quickack mode, acks are sent immediately, rather than delayed if needed in "
"accordance to normal TCP operation.  This flag is not permanent, it only "
"enables a switch to or from quickack mode.  Subsequent operation of the TCP "
"protocol will once again enter/leave quickack mode depending on internal "
"protocol processing and factors such as delayed ack timeouts occurring and "
"data transfer.  This option should not be used in code intended to be "
"portable."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:1145
#, no-wrap
msgid "B<TCP_SYNCNT> (since Linux 2.4)"
msgstr ""

#.  Precisely: since 2.3.18
#. type: Plain text
#: build/C/man7/tcp.7:1152
msgid ""
"Set the number of SYN retransmits that TCP should send before aborting the "
"attempt to connect.  It cannot exceed 255.  This option should not be used "
"in code intended to be portable."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:1152
#, no-wrap
msgid "B<TCP_USER_TIMEOUT> (since Linux 2.6.37)"
msgstr ""

#. 	    commit dca43c75e7e545694a9dd6288553f55c53e2a3a3
#. 	    Author: Jerry Chu <hkchu@google.com>
#.  The following text taken nearly verbatim from Jerry Chu's (excellent)
#.  commit message.
#. type: Plain text
#: build/C/man7/tcp.7:1170
msgid ""
"This option takes an I<unsigned int> as an argument.  When the value is "
"greater than 0, it specifies the maximum amount of time in milliseconds that "
"transmitted data may remain unacknowledged before TCP will forcibly close "
"the corresponding connection and return B<ETIMEDOUT> to the application.  If "
"the option value is specified as 0, TCP will use the system default."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:1177
msgid ""
"Increasing user timeouts allows a TCP connection to survive extended periods "
"without end-to-end connectivity.  Decreasing user timeouts allows "
"applications to \"fail fast\", if so desired.  Otherwise, failure may take "
"up to 20 minutes with the current system defaults in a normal WAN "
"environment."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:1187
msgid ""
"This option can be set during any state of a TCP connection, but is "
"effective only during the synchronized states of a connection (ESTABLISHED, "
"FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, and LAST-ACK).  Moreover, when "
"used with the TCP keepalive (B<SO_KEEPALIVE>)  option, B<TCP_USER_TIMEOUT> "
"will override keepalive to determine when to close a connection due to "
"keepalive failure."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:1190
msgid ""
"The option has no effect on when TCP retransmits a packet, nor when a "
"keepalive probe is sent."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:1194
msgid ""
"This option, like many others, will be inherited by the socket returned by "
"B<accept>(2), if it was set on the listening socket."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:1197
msgid ""
"Further details on the user timeout feature can be found in RFC\\ 793 and "
"RFC\\ 5482 (\"TCP User Timeout Option\")."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:1197
#, no-wrap
msgid "B<TCP_WINDOW_CLAMP> (since Linux 2.4)"
msgstr ""

#.  Precisely: since 2.3.41
#. type: Plain text
#: build/C/man7/tcp.7:1204
msgid ""
"Bound the size of the advertised window to this value.  The kernel imposes a "
"minimum size of SOCK_MIN_RCVBUF/2.  This option should not be used in code "
"intended to be portable."
msgstr ""

#. type: SS
#: build/C/man7/tcp.7:1204 build/C/man7/unix.7:417
#, no-wrap
msgid "Sockets API"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:1213
msgid ""
"TCP provides limited support for out-of-band data, in the form of (a single "
"byte of) urgent data.  In Linux this means if the other end sends newer "
"out-of-band data the older urgent data is inserted as normal data into the "
"stream (even when B<SO_OOBINLINE> is not set).  This differs from BSD-based "
"stacks."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:1220
msgid ""
"Linux uses the BSD compatible interpretation of the urgent pointer field by "
"default.  This violates RFC\\ 1122, but is required for interoperability "
"with other stacks.  It can be changed via I</proc/sys/net/ipv4/tcp_stdurg>."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:1225
msgid ""
"It is possible to peek at out-of-band data using the B<recv>(2)  B<MSG_PEEK> "
"flag."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:1241
msgid ""
"Since version 2.4, Linux supports the use of B<MSG_TRUNC> in the I<flags> "
"argument of B<recv>(2)  (and B<recvmsg>(2)).  This flag causes the received "
"bytes of data to be discarded, rather than passed back in a caller-supplied "
"buffer.  Since Linux 2.4.4, B<MSG_TRUNC> also has this effect when used in "
"conjunction with B<MSG_OOB> to receive out-of-band data."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:1247 build/C/man7/unix.7:642
msgid ""
"The following B<ioctl>(2)  calls return information in I<value>.  The "
"correct syntax is:"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:1252
#, no-wrap
msgid ""
"B<int>I< value>B<;>\n"
"I<error>B< = ioctl(>I<tcp_socket>B<, >I<ioctl_type>B<, &>I<value>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:1257
msgid "I<ioctl_type> is one of the following:"
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:1257 build/C/man7/unix.7:652
#, no-wrap
msgid "B<SIOCINQ>"
msgstr ""

#.  FIXME http://sources.redhat.com/bugzilla/show_bug.cgi?id=12002,
#.  filed 2010-09-10, may cause SIOCINQ to be defined in glibc headers
#. type: Plain text
#: build/C/man7/tcp.7:1273
msgid ""
"Returns the amount of queued unread data in the receive buffer.  The socket "
"must not be in LISTEN state, otherwise an error (B<EINVAL>)  is returned.  "
"B<SIOCINQ> is defined in I<E<lt>linux/sockios.hE<gt>>.  Alternatively, you "
"can use the synonymous B<FIONREAD>, defined in I<E<lt>sys/ioctl.hE<gt>>."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:1273
#, no-wrap
msgid "B<SIOCATMARK>"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:1278
msgid ""
"Returns true (i.e., I<value> is nonzero) if the inbound data stream is at "
"the urgent mark."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:1294
msgid ""
"If the B<SO_OOBINLINE> socket option is set, and B<SIOCATMARK> returns true, "
"then the next read from the socket will return the urgent data.  If the "
"B<SO_OOBINLINE> socket option is not set, and B<SIOCATMARK> returns true, "
"then the next read from the socket will return the bytes following the "
"urgent data (to actually read the urgent data requires the B<recv(MSG_OOB)> "
"flag)."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:1308
msgid ""
"Note that a read never reads across the urgent mark.  If an application is "
"informed of the presence of urgent data via B<select>(2)  (using the "
"I<exceptfds> argument) or through delivery of a B<SIGURG> signal, then it "
"can advance up to the mark using a loop which repeatedly tests B<SIOCATMARK> "
"and performs a read (requesting any number of bytes) as long as "
"B<SIOCATMARK> returns false."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:1308
#, no-wrap
msgid "B<SIOCOUTQ>"
msgstr ""

#.  FIXME . http://sources.redhat.com/bugzilla/show_bug.cgi?id=12002,
#.  filed 2010-09-10, may cause SIOCOUTQ to be defined in glibc headers
#. type: Plain text
#: build/C/man7/tcp.7:1324
msgid ""
"Returns the amount of unsent data in the socket send queue.  The socket must "
"not be in LISTEN state, otherwise an error (B<EINVAL>)  is returned.  "
"B<SIOCOUTQ> is defined in I<E<lt>linux/sockios.hE<gt>>.  Alternatively, you "
"can use the synonymous B<TIOCOUTQ>, defined in I<E<lt>sys/ioctl.hE<gt>>."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:1329
msgid ""
"When a network error occurs, TCP tries to resend the packet.  If it doesn't "
"succeed after some time, either B<ETIMEDOUT> or the last received error on "
"this connection is reported."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:1340
msgid ""
"Some applications require a quicker error notification.  This can be enabled "
"with the B<IPPROTO_IP> level B<IP_RECVERR> socket option.  When this option "
"is enabled, all incoming errors are immediately passed to the user program.  "
"Use this option with care \\(em it makes TCP less tolerant to routing "
"changes and other normal network conditions."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:1341
#, no-wrap
msgid "B<EAFNOTSUPPORT>"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:1347
msgid "Passed socket address type in I<sin_family> was not B<AF_INET>."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:1351
msgid ""
"The other end closed the socket unexpectedly or a read is executed on a shut "
"down socket."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:1351
#, no-wrap
msgid "B<ETIMEDOUT>"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:1354
msgid "The other end didn't acknowledge retransmitted data after some time."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:1358
msgid ""
"Any errors defined for B<ip>(7)  or the generic socket layer may also be "
"returned for TCP."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:1365
msgid ""
"Support for Explicit Congestion Notification, zero-copy B<sendfile>(2), "
"reordering support and some SACK extensions (DSACK) were introduced in 2.4.  "
"Support for forward acknowledgement (FACK), TIME_WAIT recycling, and "
"per-connection keepalive socket options were introduced in 2.3."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:1367
msgid "Not all errors are documented."
msgstr ""

#.  Only a single Linux kernel version is described
#.  Info for 2.2 was lost. Should be added again,
#.  or put into a separate page.
#.  .SH AUTHORS
#.  This man page was originally written by Andi Kleen.
#.  It was updated for 2.4 by Nivedita Singhvi with input from
#.  Alexey Kuznetsov's Documentation/networking/ip-sysctl.txt
#.  document.
#. type: Plain text
#: build/C/man7/tcp.7:1377
msgid "IPv6 is not described."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:1389
msgid ""
"B<accept>(2), B<bind>(2), B<connect>(2), B<getsockopt>(2), B<listen>(2), "
"B<recvmsg>(2), B<sendfile>(2), B<sendmsg>(2), B<socket>(2), B<ip>(7), "
"B<socket>(7)"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:1394
msgid "RFC\\ 793 for the TCP specification."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:1396
msgid ""
"RFC\\ 1122 for the TCP requirements and a description of the Nagle "
"algorithm."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:1398
msgid "RFC\\ 1323 for TCP timestamp and window scaling options."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:1400
msgid "RFC\\ 1337 for a description of TIME_WAIT assassination hazards."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:1402
msgid "RFC\\ 3168 for a description of Explicit Congestion Notification."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:1404
msgid "RFC\\ 2581 for TCP congestion control algorithms."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:1406
msgid "RFC\\ 2018 and RFC\\ 2883 for SACK and extensions to SACK."
msgstr ""

#. type: TH
#: build/C/man7/udp.7:12
#, no-wrap
msgid "UDP"
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:15
msgid "udp - User Datagram Protocol for IPv4"
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:21
msgid "B<#include E<lt>netinet/udp.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:23
msgid "B<udp_socket = socket(AF_INET, SOCK_DGRAM, 0);>"
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:29
msgid ""
"This is an implementation of the User Datagram Protocol described in RFC\\ "
"768.  It implements a connectionless, unreliable datagram packet service.  "
"Packets may be reordered or duplicated before they arrive.  UDP generates "
"and checks checksums to catch transmission errors."
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:58
msgid ""
"When a UDP socket is created, its local and remote addresses are "
"unspecified.  Datagrams can be sent immediately using B<sendto>(2)  or "
"B<sendmsg>(2)  with a valid destination address as an argument.  When "
"B<connect>(2)  is called on the socket, the default destination address is "
"set and datagrams can now be sent using B<send>(2)  or B<write>(2)  without "
"specifying a destination address.  It is still possible to send to other "
"destinations by passing an address to B<sendto>(2)  or B<sendmsg>(2).  In "
"order to receive packets, the socket can be bound to a local address first "
"by using B<bind>(2).  Otherwise, the socket layer will automatically assign "
"a free local port out of the range defined by "
"I</proc/sys/net/ipv4/ip_local_port_range> and bind the socket to "
"B<INADDR_ANY>."
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:66
msgid ""
"All receive operations return only one packet.  When the packet is smaller "
"than the passed buffer, only that much data is returned; when it is bigger, "
"the packet is truncated and the B<MSG_TRUNC> flag is set.  B<MSG_WAITALL> is "
"not supported."
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:75
msgid ""
"IP options may be sent or received using the socket options described in "
"B<ip>(7).  They are processed by the kernel only when the appropriate "
"I</proc> parameter is enabled (but still passed to the user even when it is "
"turned off).  See B<ip>(7)."
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:80
msgid ""
"When the B<MSG_DONTROUTE> flag is set on sending, the destination address "
"must refer to a local interface address and the packet is sent only to that "
"interface."
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:98
msgid ""
"By default, Linux UDP does path MTU (Maximum Transmission Unit) discovery.  "
"This means the kernel will keep track of the MTU to a specific target IP "
"address and return B<EMSGSIZE> when a UDP packet write exceeds it.  When "
"this happens, the application should decrease the packet size.  Path MTU "
"discovery can be also turned off using the B<IP_MTU_DISCOVER> socket option "
"or the I</proc/sys/net/ipv4/ip_no_pmtu_disc> file; see B<ip>(7)  for "
"details.  When turned off, UDP will fragment outgoing UDP packets that "
"exceed the interface MTU.  However, disabling it is not recommended for "
"performance and reliability reasons."
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:103
msgid "UDP uses the IPv4 I<sockaddr_in> address format described in B<ip>(7)."
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:114
msgid ""
"All fatal errors will be passed to the user as an error return even when the "
"socket is not connected.  This includes asynchronous errors received from "
"the network.  You may get an error for an earlier packet that was sent on "
"the same socket.  This behavior differs from many other BSD socket "
"implementations which don't pass any errors unless the socket is connected.  "
"Linux's behavior is mandated by B<RFC\\ 1122>."
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:128
msgid ""
"For compatibility with legacy code, in Linux 2.0 and 2.2 it was possible to "
"set the B<SO_BSDCOMPAT> B<SOL_SOCKET> option to receive remote errors only "
"when the socket has been connected (except for B<EPROTO> and B<EMSGSIZE>).  "
"Locally generated errors are always passed.  Support for this socket option "
"was removed in later kernels; see B<socket>(7)  for further information."
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:137
msgid ""
"When the B<IP_RECVERR> option is enabled, all errors are stored in the "
"socket error queue, and can be received by B<recvmsg>(2)  with the "
"B<MSG_ERRQUEUE> flag set."
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:140
msgid ""
"System-wide UDP parameter settings can be accessed by files in the directory "
"I</proc/sys/net/ipv4/>."
msgstr ""

#. type: TP
#: build/C/man7/udp.7:140
#, no-wrap
msgid "I<udp_mem> (since Linux 2.6.25)"
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:144
msgid ""
"This is a vector of three integers governing the number of pages allowed for "
"queueing by all UDP sockets."
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:151
msgid ""
"Below this number of pages, UDP is not bothered about its memory appetite.  "
"When the amount of memory allocated by UDP exceeds this number, UDP starts "
"to moderate memory usage."
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:157
msgid ""
"This value was introduced to follow the format of I<tcp_mem> (see "
"B<tcp>(7))."
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:160
msgid "Number of pages allowed for queueing by all UDP sockets."
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:164
msgid ""
"Defaults values for these three items are calculated at boot time from the "
"amount of available memory."
msgstr ""

#. type: TP
#: build/C/man7/udp.7:164
#, no-wrap
msgid "I<udp_rmem_min> (integer; default value: PAGE_SIZE; since Linux 2.6.25)"
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:171
msgid ""
"Minimal size, in bytes, of receive buffers used by UDP sockets in "
"moderation.  Each UDP socket is able to use the size for receiving data, "
"even if total pages of UDP sockets exceed I<udp_mem> pressure."
msgstr ""

#. type: TP
#: build/C/man7/udp.7:171
#, no-wrap
msgid "I<udp_wmem_min> (integer; default value: PAGE_SIZE; since Linux 2.6.25)"
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:178
msgid ""
"Minimal size, in bytes, of send buffer used by UDP sockets in moderation.  "
"Each UDP socket is able to use the size for sending data, even if total "
"pages of UDP sockets exceed I<udp_mem> pressure."
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:189
msgid ""
"To set or get a UDP socket option, call B<getsockopt>(2)  to read or "
"B<setsockopt>(2)  to write the option with the option level argument set to "
"B<IPPROTO_UDP>.  Unless otherwise noted, I<optval> is a pointer to an "
"I<int>."
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:194
msgid ""
"Following is a list of UDP-specific socket options.  For details of some "
"other socket options that are also applicable for UDP sockets, see "
"B<socket>(7)."
msgstr ""

#. type: TP
#: build/C/man7/udp.7:194
#, no-wrap
msgid "B<UDP_CORK> (since Linux 2.5.44)"
msgstr ""

#.  FIXME document UDP_ENCAP (new in kernel 2.5.67)
#.  From include/linux/udp.h:
#.      UDP_ENCAP_ESPINUDP_NON_IKE draft-ietf-ipsec-nat-t-ike-00/01
#.      UDP_ENCAP_ESPINUDP draft-ietf-ipsec-udp-encaps-06
#.      UDP_ENCAP_L2TPINUDP rfc2661
#.  FIXME Document UDP_NO_CHECK6_TX and UDP_NO_CHECK6_RX, added in Linux 3.16
#. type: Plain text
#: build/C/man7/udp.7:207
msgid ""
"If this option is enabled, then all data output on this socket is "
"accumulated into a single datagram that is transmitted when the option is "
"disabled.  This option should not be used in code intended to be portable."
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:211
msgid "These ioctls can be accessed using B<ioctl>(2).  The correct syntax is:"
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:216
#, no-wrap
msgid ""
"B<int>I< value>B<;>\n"
"I<error>B< = ioctl(>I<udp_socket>B<, >I<ioctl_type>B<, &>I<value>B<);>\n"
msgstr ""

#. type: TP
#: build/C/man7/udp.7:218
#, no-wrap
msgid "B<FIONREAD> (B<SIOCINQ>)"
msgstr ""

#.  See http://www.securiteam.com/unixfocus/5KP0I15IKO.html
#.  "GNUnet DoS (UDP Socket Unreachable)", 14 May 2006
#. type: Plain text
#: build/C/man7/udp.7:236
msgid ""
"Gets a pointer to an integer as argument.  Returns the size of the next "
"pending datagram in the integer in bytes, or 0 when no datagram is pending.  "
"B<Warning:> Using B<FIONREAD>, it is impossible to distinguish the case "
"where no datagram is pending from the case where the next pending datagram "
"contains zero bytes of data.  It is safer to use B<select>(2), B<poll>(2), "
"or B<epoll>(7)  to distinguish these cases."
msgstr ""

#. type: TP
#: build/C/man7/udp.7:236
#, no-wrap
msgid "B<TIOCOUTQ> (B<SIOCOUTQ>)"
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:240
msgid ""
"Returns the number of data bytes in the local send queue.  Supported only "
"with Linux 2.4 and above."
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:246
msgid ""
"In addition, all ioctls documented in B<ip>(7)  and B<socket>(7)  are "
"supported."
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:252
msgid ""
"All errors documented for B<socket>(7)  or B<ip>(7)  may be returned by a "
"send or receive on a UDP socket."
msgstr ""

#. type: TP
#: build/C/man7/udp.7:252 build/C/man7/unix.7:697
#, no-wrap
msgid "B<ECONNREFUSED>"
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:256
msgid ""
"No receiver was associated with the destination address.  This might be "
"caused by a previous packet sent over the socket."
msgstr ""

#.  .SH CREDITS
#.  This man page was written by Andi Kleen.
#. type: Plain text
#: build/C/man7/udp.7:261
msgid "B<IP_RECVERR> is a new feature in Linux 2.2."
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:266
msgid "B<ip>(7), B<raw>(7), B<socket>(7), B<udplite>(7)"
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:271
msgid "RFC\\ 768 for the User Datagram Protocol."
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:273
msgid "RFC\\ 1122 for the host requirements."
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:275
msgid "RFC\\ 1191 for a description of path MTU discovery."
msgstr ""

#. type: TH
#: build/C/man7/udplite.7:27
#, no-wrap
msgid "UDPLITE"
msgstr ""

#. type: Plain text
#: build/C/man7/udplite.7:30
msgid "udplite - Lightweight User Datagram Protocol"
msgstr ""

#. type: Plain text
#: build/C/man7/udplite.7:38
msgid "B<sockfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDPLITE);>"
msgstr ""

#. type: Plain text
#: build/C/man7/udplite.7:41
msgid ""
"This is an implementation of the Lightweight User Datagram Protocol "
"(UDP-Lite), as described in RFC\\ 3828."
msgstr ""

#. type: Plain text
#: build/C/man7/udplite.7:47
msgid ""
"UDP-Lite is an extension of UDP (RFC\\ 768) to support variable-length "
"checksums.  This has advantages for some types of multimedia transport that "
"may be able to make use of slightly damaged datagrams, rather than having "
"them discarded by lower-layer protocols."
msgstr ""

#. type: Plain text
#: build/C/man7/udplite.7:53
msgid ""
"The variable-length checksum coverage is set via a B<setsockopt>(2)  "
"option.  If this option is not set, the only difference from UDP is in using "
"a different IP protocol identifier (IANA number 136)."
msgstr ""

#. type: Plain text
#: build/C/man7/udplite.7:58
msgid ""
"The UDP-Lite implementation is a full extension of B<udp>(7)\\(emthat is, it "
"shares the same API and API behavior, and in addition offers two socket "
"options to control the checksum coverage."
msgstr ""

#. type: Plain text
#: build/C/man7/udplite.7:67
msgid ""
"UDP-Litev4 uses the I<sockaddr_in> address format described in B<ip>(7).  "
"UDP-Litev6 uses the I<sockaddr_in6> address format described in B<ipv6>(7)."
msgstr ""

#. type: Plain text
#: build/C/man7/udplite.7:80
msgid ""
"To set or get a UDP-Lite socket option, call B<getsockopt>(2)  to read or "
"B<setsockopt>(2)  to write the option with the option level argument set to "
"B<IPPROTO_UDPLITE>.  In addition, all B<IPPROTO_UDP> socket options are "
"valid on a UDP-Lite socket.  See B<udp>(7)  for more information."
msgstr ""

#. type: Plain text
#: build/C/man7/udplite.7:82
msgid "The following two options are specific to UDP-Lite."
msgstr ""

#. type: TP
#: build/C/man7/udplite.7:82
#, no-wrap
msgid "B<UDPLITE_SEND_CSCOV>"
msgstr ""

#. type: Plain text
#: build/C/man7/udplite.7:87
msgid ""
"This option sets the sender checksum coverage and takes an I<int> as "
"argument, with a checksum coverage value in the range 0..2^16-1."
msgstr ""

#. type: Plain text
#: build/C/man7/udplite.7:91
msgid ""
"A value of 0 means that the entire datagram is always covered.  Values from "
"1-7 are illegal (RFC\\ 3828, 3.1) and are rounded up to the minimum coverage "
"of 8."
msgstr ""

#. type: Plain text
#: build/C/man7/udplite.7:97
msgid ""
"With regard to IPv6 jumbograms (RFC\\ 2675), the UDP-Litev6 checksum "
"coverage is limited to the first 2^16-1 octets, as per RFC\\ 3828, 3.5.  "
"Higher values are therefore silently truncated to 2^16-1.  If in doubt, the "
"current coverage value can always be queried using B<getsockopt>(2)."
msgstr ""

#. type: TP
#: build/C/man7/udplite.7:97
#, no-wrap
msgid "B<UDPLITE_RECV_CSCOV>"
msgstr ""

#. type: Plain text
#: build/C/man7/udplite.7:108
msgid ""
"This is the receiver-side analogue and uses the same argument format and "
"value range as B<UDPLITE_SEND_CSCOV>.  This option is not required to enable "
"traffic with partial checksum coverage.  Its function is that of a traffic "
"filter: when enabled, it instructs the kernel to drop all packets which have "
"a coverage I<less> than the specified coverage value."
msgstr ""

#.  SO_NO_CHECK exists and is supported by UDPv4, but is
#.  commented out in socket(7), hence also commented out here
#. .PP
#. Since UDP-Lite mandates checksums, checksumming can not be disabled
#. via the
#. .B SO_NO_CHECK
#. option from
#. .BR socket (7).
#. type: Plain text
#: build/C/man7/udplite.7:121
msgid ""
"When the value of B<UDPLITE_RECV_CSCOV> exceeds the actual packet coverage, "
"incoming packets are silently dropped, but may generate a warning message in "
"the system log."
msgstr ""

#. type: Plain text
#: build/C/man7/udplite.7:126
msgid ""
"All errors documented for B<udp>(7)  may be returned.  UDP-Lite does not add "
"further errors."
msgstr ""

#. type: TP
#: build/C/man7/udplite.7:127
#, no-wrap
msgid "I</proc/net/snmp>"
msgstr ""

#. type: Plain text
#: build/C/man7/udplite.7:130
msgid "Basic UDP-Litev4 statistics counters."
msgstr ""

#. type: TP
#: build/C/man7/udplite.7:130
#, no-wrap
msgid "I</proc/net/snmp6>"
msgstr ""

#. type: Plain text
#: build/C/man7/udplite.7:133
msgid "Basic UDP-Litev6 statistics counters."
msgstr ""

#. type: Plain text
#: build/C/man7/udplite.7:135
msgid "UDP-Litev4/v6 first appeared in Linux 2.6.20."
msgstr ""

#.  FIXME . remove this section once glibc supports UDP-Lite
#. type: Plain text
#: build/C/man7/udplite.7:138
msgid "Where glibc support is missing, the following definitions are needed:"
msgstr ""

#.  The following two are defined in the kernel in linux/net/udplite.h
#. type: Plain text
#: build/C/man7/udplite.7:145
#, no-wrap
msgid ""
"#define IPPROTO_UDPLITE     136\n"
"#define UDPLITE_SEND_CSCOV  10\n"
"#define UDPLITE_RECV_CSCOV  11\n"
msgstr ""

#. type: Plain text
#: build/C/man7/udplite.7:152
msgid "B<ip>(7), B<ipv6>(7), B<socket>(7), B<udp>(7)"
msgstr ""

#. type: Plain text
#: build/C/man7/udplite.7:154
msgid "RFC\\ 3828 for the Lightweight User Datagram Protocol (UDP-Lite)."
msgstr ""

#. type: Plain text
#: build/C/man7/udplite.7:157
msgid "I<Documentation/networking/udplite.txt> in the Linux kernel source tree"
msgstr ""

#. type: TH
#: build/C/man7/unix.7:20
#, no-wrap
msgid "UNIX"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:23
msgid "unix - sockets for local interprocess communication"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:27
msgid "B<#include E<lt>sys/un.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:29
msgid "I<unix_socket>B< = socket(AF_UNIX, type, 0);>"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:31
msgid "I<error>B< = socketpair(AF_UNIX, type, 0, int *>I<sv>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:42
msgid ""
"The B<AF_UNIX> (also known as B<AF_LOCAL>)  socket family is used to "
"communicate between processes on the same machine efficiently.  "
"Traditionally, UNIX domain sockets can be either unnamed, or bound to a "
"filesystem pathname (marked as being of type socket).  Linux also supports "
"an abstract namespace which is independent of the filesystem."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:55
msgid ""
"Valid socket types in the UNIX domain are: B<SOCK_STREAM>, for a "
"stream-oriented socket; B<SOCK_DGRAM>, for a datagram-oriented socket that "
"preserves message boundaries (as on most UNIX implementations, UNIX domain "
"datagram sockets are always reliable and don't reorder datagrams); and "
"(since Linux 2.6.4)  B<SOCK_SEQPACKET>, for a sequenced-packet socket that "
"is connection-oriented, preserves message boundaries, and delivers messages "
"in the order that they were sent."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:58
msgid ""
"UNIX domain sockets support passing file descriptors or process credentials "
"to other processes using ancillary data."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:60
msgid "A UNIX domain socket address is represented in the following structure:"
msgstr ""

#.  #define UNIX_PATH_MAX    108
#. type: Plain text
#: build/C/man7/unix.7:69
#, no-wrap
msgid ""
"struct sockaddr_un {\n"
"    sa_family_t sun_family;               /* AF_UNIX */\n"
"    char        sun_path[108];            /* Pathname */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:79
msgid ""
"The I<sun_family> field always contains B<AF_UNIX>.  On Linux, I<sun_path> "
"is 108 bytes in size; see also NOTES, below."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:95
msgid ""
"Various systems calls (for example, B<bind>(2), B<connect>(2), and "
"B<sendto>(2))  take a I<sockaddr_un> argument as input.  Some other system "
"calls (for example, B<getsockname>(2), B<getpeername>(2), B<recvfrom>(2), "
"and B<accept>(2))  return an argument of this type."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:99
msgid "Three types of address are distinguished in the I<sockaddr_un> structure:"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:107
msgid ""
"I<pathname>: a UNIX domain socket can be bound to a null-terminated "
"filesystem pathname using B<bind>(2).  When the address of a pathname socket "
"is returned (by one of the system calls noted above), its length is"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:109
#, no-wrap
msgid "    offsetof(struct sockaddr_un, sun_path) + strlen(sun_path) + 1\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:122
msgid ""
"and I<sun_path> contains the null-terminated pathname.  (On Linux, the above "
"B<offsetof>()  expression equates to the same value as "
"I<sizeof(sa_family_t)>, but some other implementations include other fields "
"before I<sun_path>, so the B<offsetof>()  expression more portably describes "
"the size of the address structure.)"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:124
msgid "For further details of pathname sockets, see below."
msgstr ""

#.  There is quite some variation across implementations: FreeBSD
#.  says the length is 16 bytes, HP-UX 11 says it's zero bytes.
#. type: Plain text
#: build/C/man7/unix.7:140
msgid ""
"I<unnamed>: A stream socket that has not been bound to a pathname using "
"B<bind>(2)  has no name.  Likewise, the two sockets created by "
"B<socketpair>(2)  are unnamed.  When the address of an unnamed socket is "
"returned, its length is I<sizeof(sa_family_t)>, and I<sun_path> should not "
"be inspected."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:162
msgid ""
"I<abstract>: an abstract socket address is distinguished (from a pathname "
"socket)  by the fact that I<sun_path[0]> is a null byte (\\(aq\\e0\\(aq).  "
"The socket's address in this namespace is given by the additional bytes in "
"I<sun_path> that are covered by the specified length of the address "
"structure.  (Null bytes in the name have no special significance.)  The name "
"has no connection with filesystem pathnames.  When the address of an "
"abstract socket is returned, the returned I<addrlen> is greater than "
"I<sizeof(sa_family_t)> (i.e., greater than 2), and the name of the socket is "
"contained in the first I<(addrlen - sizeof(sa_family_t))> bytes of "
"I<sun_path>."
msgstr ""

#. type: SS
#: build/C/man7/unix.7:162
#, no-wrap
msgid "Pathname sockets"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:165
msgid ""
"When binding a socket to a pathname, a few rules should be observed for "
"maximum portability and ease of coding:"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:169
msgid "The pathname in I<sun_path> should be null-terminated."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:173
msgid ""
"The length of the pathname, including the terminating null byte, should not "
"exceed the size of I<sun_path>."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:179
msgid ""
"The I<addrlen> argument that describes the enclosing I<sockaddr_un> "
"structure should have a value of at least:"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:182
#, no-wrap
msgid "    offsetof(struct sockaddr_un, sun_path)+strlen(addr.sun_path)+1\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:188
msgid ""
"or, more simply, I<addrlen> can be specified as I<sizeof(struct "
"sockaddr_un)>."
msgstr ""

#.  Linux does this, including for the case where the supplied path
#.  is 108 bytes
#. type: Plain text
#: build/C/man7/unix.7:196
msgid ""
"There is some variation in how implementations handle UNIX domain socket "
"addresses that do not follow the above rules.  For example, some (but not "
"all) implementations append a null terminator if none is present in the "
"supplied I<sun_path>."
msgstr ""

#.  HP-UX
#.  Modern BSDs generally have 104, Tru64 and AIX have 104,
#.  Solaris and Irix have 108
#. type: Plain text
#: build/C/man7/unix.7:205
msgid ""
"When coding portable applications, keep in mind that some implementations "
"have I<sun_path> as short as 92 bytes."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:224
msgid ""
"Various system calls (B<accept>(2), B<recvfrom>(2), B<getsockname>(2), "
"B<getpeername>(2))  return socket address structures.  When applied to UNIX "
"domain sockets, the value-result I<addrlen> argument supplied to the call "
"should be initialized as above.  Upon return, the argument is set to "
"indicate the I<actual> size of the address structure.  The caller should "
"check the value returned in this argument: if the output value exceeds the "
"input value, then there is no guarantee that a null terminator is present in "
"I<sun_path>.  (See BUGS.)"
msgstr ""

#. type: SS
#: build/C/man7/unix.7:224
#, no-wrap
msgid "Pathname socket ownership and permissions"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:229
msgid ""
"In the Linux implementation, pathname sockets honor the permissions of the "
"directory they are in.  Creation of a new socket fails if the process does "
"not have write and search (execute) permission on the directory in which the "
"socket is created."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:239
msgid ""
"On Linux, connecting to a stream socket object requires write permission on "
"that socket; sending a datagram to a datagram socket likewise requires write "
"permission on that socket.  POSIX does not make any statement about the "
"effect of the permissions on a socket file, and on some systems (e.g., older "
"BSDs), the socket permissions are ignored.  Portable programs should not "
"rely on this feature for security."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:245
msgid ""
"When creating a new socket, the owner and group of the socket file are set "
"according to the usual rules.  The socket file has all permissions enabled, "
"other than those that are turned off by the process B<umask>(2)."
msgstr ""

#.  However, fchown() and fchmod() do not seem to have an effect
#. type: Plain text
#: build/C/man7/unix.7:252
msgid ""
"The owner, group, and permissions of a pathname socket can be changed (using "
"B<chown>(2)  and B<chmod>(2))."
msgstr ""

#. type: SS
#: build/C/man7/unix.7:252
#, no-wrap
msgid "Abstract sockets"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:262
msgid ""
"Socket permissions have no meaning for abstract sockets: the process "
"B<umask>(2)  has no effect when binding an abstract socket, and changing the "
"ownership and permissions of the object (via B<fchown>(2)  and B<fchmod>(2))  "
"has no effect on the accessibility of the socket."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:265
msgid ""
"Abstract sockets automatically disappear when all open references to the "
"socket are closed."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:268
msgid "The abstract socket namespace is a nonportable Linux extension."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:281
msgid ""
"For historical reasons, these socket options are specified with a "
"B<SOL_SOCKET> type even though they are B<AF_UNIX> specific.  They can be "
"set with B<setsockopt>(2)  and read with B<getsockopt>(2)  by specifying "
"B<SOL_SOCKET> as the socket family."
msgstr ""

#. type: TP
#: build/C/man7/unix.7:281
#, no-wrap
msgid "B<SO_PASSCRED>"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:293
msgid ""
"Enabling this socket option causes receipt of the credentials of the sending "
"process in an B<SCM_CREDENTIALS ancillary> message in each subsequently "
"received message.  The returned credentials are those specified by the "
"sender using B<SCM_CREDENTIALS>, or a default that includes the sender's "
"PID, real user ID, and real group ID, if the sender did not specify "
"B<SCM_CREDENTIALS> ancillary data."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:296
msgid ""
"When this option is set and the socket is not yet connected, a unique name "
"in the abstract namespace will be generated automatically."
msgstr ""

#. type: TP
#: build/C/man7/unix.7:302
#, no-wrap
msgid "B<SO_PASSSEC>"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:308
msgid ""
"Enables receiving of the SELinux security label of the peer socket in an "
"ancillary message of type B<SCM_SECURITY> (see below)."
msgstr ""

#.  commit 877ce7c1b3afd69a9b1caeb1b9964c992641f52a
#.  commit 37a9a8df8ce9de6ea73349c9ac8bdf6ba4ec4f70
#. type: Plain text
#: build/C/man7/unix.7:323
msgid ""
"The B<SO_PASSSEC> option is supported for UNIX domain datagram sockets since "
"Linux 2.6.18; support for UNIX domain stream sockets was added in Linux 4.2."
msgstr ""

#. type: TP
#: build/C/man7/unix.7:323
#, no-wrap
msgid "B<SO_PEEK_OFF>"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:327
msgid "See B<socket>(7)."
msgstr ""

#. type: TP
#: build/C/man7/unix.7:327
#, no-wrap
msgid "B<SO_PEERCRED>"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:336
msgid ""
"This read-only socket option returns the credentials of the peer process "
"connected to this socket.  The returned credentials are those that were in "
"effect at the time of the call to B<connect>(2)  or B<socketpair>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:345
msgid ""
"The argument to B<getsockopt>(2)  is a pointer to a I<ucred> structure; "
"define the B<_GNU_SOURCE> feature test macro to obtain the definition of "
"that structure from I<E<lt>sys/socket.hE<gt>>."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:352
msgid ""
"The use of this option is possible only for connected B<AF_UNIX> stream "
"sockets and for B<AF_UNIX> stream and datagram socket pairs created using "
"B<socketpair>(2)."
msgstr ""

#. type: TP
#: build/C/man7/unix.7:352
#, no-wrap
msgid "B<SO_PEERSEC>"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:359
msgid ""
"This read-only socket option returns the security context of the peer socket "
"connected to this socket.  By default, this will be the same as the security "
"context of the process that created the peer socket unless overridden by the "
"policy or by a process with the required permissions."
msgstr ""

#.  commit 0b811db2cb2aabc910e53d34ebb95a15997c33e7
#. type: Plain text
#: build/C/man7/unix.7:397
msgid ""
"The use of this option for sockets in the B<AF_UNIX> address family is "
"supported since Linux 2.6.2 for connected stream sockets, and since Linux "
"4.18 also for stream and datagram socket pairs created using "
"B<socketpair>(2)."
msgstr ""

#. type: SS
#: build/C/man7/unix.7:397
#, no-wrap
msgid "Autobind feature"
msgstr ""

#.  i.e., sizeof(short)
#. type: Plain text
#: build/C/man7/unix.7:417
msgid ""
"If a B<bind>(2)  call specifies I<addrlen> as I<sizeof(sa_family_t)>, or the "
"B<SO_PASSCRED> socket option was specified for a socket that was not "
"explicitly bound to an address, then the socket is autobound to an abstract "
"address.  The address consists of a null byte followed by 5 bytes in the "
"character set I<[0-9a-f]>.  Thus, there is a limit of 2^20 autobind "
"addresses.  (From Linux 2.1.15, when the autobind feature was added, 8 bytes "
"were used, and the limit was thus 2^32 autobind addresses.  The change to 5 "
"bytes came in Linux 2.3.15.)"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:420
msgid ""
"The following paragraphs describe domain-specific details and unsupported "
"features of the sockets API for UNIX domain sockets on Linux."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:428
msgid ""
"UNIX domain sockets do not support the transmission of out-of-band data (the "
"B<MSG_OOB> flag for B<send>(2)  and B<recv>(2))."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:433
msgid "The B<send>(2)  B<MSG_MORE> flag is not supported by UNIX domain sockets."
msgstr ""

#.  commit 9f6f9af7694ede6314bed281eec74d588ba9474f
#. type: Plain text
#: build/C/man7/unix.7:443
msgid ""
"Before Linux 3.4, the use of B<MSG_TRUNC> in the I<flags> argument of "
"B<recv>(2)  was not supported by UNIX domain sockets."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:455
msgid ""
"The B<SO_SNDBUF> socket option does have an effect for UNIX domain sockets, "
"but the B<SO_RCVBUF> option does not.  For datagram sockets, the "
"B<SO_SNDBUF> value imposes an upper limit on the size of outgoing "
"datagrams.  This limit is calculated as the doubled (see B<socket>(7))  "
"option value less 32 bytes used for overhead."
msgstr ""

#. type: SS
#: build/C/man7/unix.7:455
#, no-wrap
msgid "Ancillary messages"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:477
msgid ""
"Ancillary data is sent and received using B<sendmsg>(2)  and B<recvmsg>(2).  "
"For historical reasons, the ancillary message types listed below are "
"specified with a B<SOL_SOCKET> type even though they are B<AF_UNIX> "
"specific.  To send them, set the I<cmsg_level> field of the struct "
"I<cmsghdr> to B<SOL_SOCKET> and the I<cmsg_type> field to the type.  For "
"more information, see B<cmsg>(3)."
msgstr ""

#. type: TP
#: build/C/man7/unix.7:477
#, no-wrap
msgid "B<SCM_RIGHTS>"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:481
msgid ""
"Send or receive a set of open file descriptors from another process.  The "
"data portion contains an integer array of the file descriptors."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:492
msgid ""
"Commonly, this operation is referred to as \"passing a file descriptor\" to "
"another process.  However, more accurately, what is being passed is a "
"reference to an open file description (see B<open>(2)), and in the receiving "
"process it is likely that a different file descriptor number will be used.  "
"Semantically, this operation is equivalent to duplicating (B<dup>(2))  a "
"file descriptor into the file descriptor table of another process."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:498
msgid ""
"If the buffer used to receive the ancillary data containing file descriptors "
"is too small (or is absent), then the ancillary data is truncated (or "
"discarded)  and the excess file descriptors are automatically closed in the "
"receiving process."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:506
msgid ""
"If the number of file descriptors received in the ancillary data would cause "
"the process to exceed its B<RLIMIT_NOFILE> resource limit (see "
"B<getrlimit>(2)), the excess file descriptors are automatically closed in "
"the receiving process."
msgstr ""

#.  commit bba14de98753cb6599a2dae0e520714b2153522d
#. type: Plain text
#: build/C/man7/unix.7:519
msgid ""
"The kernel constant B<SCM_MAX_FD> defines a limit on the number of file "
"descriptors in the array.  Attempting to send an array larger than this "
"limit causes B<sendmsg>(2)  to fail with the error B<EINVAL>.  B<SCM_MAX_FD> "
"has the value 253 (or 255 in kernels before 2.6.38)."
msgstr ""

#. type: TP
#: build/C/man7/unix.7:519
#, no-wrap
msgid "B<SCM_CREDENTIALS>"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:529
msgid ""
"Send or receive UNIX credentials.  This can be used for authentication.  The "
"credentials are passed as a I<struct ucred> ancillary message.  This "
"structure is defined in I<E<lt>sys/socket.hE<gt>> as follows:"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:537
#, no-wrap
msgid ""
"struct ucred {\n"
"    pid_t pid;    /* Process ID of the sending process */\n"
"    uid_t uid;    /* User ID of the sending process */\n"
"    gid_t gid;    /* Group ID of the sending process */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:546
msgid ""
"Since glibc 2.8, the B<_GNU_SOURCE> feature test macro must be defined "
"(before including I<any> header files) in order to obtain the definition of "
"this structure."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:557
msgid ""
"The credentials which the sender specifies are checked by the kernel.  A "
"privileged process is allowed to specify values that do not match its own.  "
"The sender must specify its own process ID (unless it has the capability "
"B<CAP_SYS_ADMIN>, in which case the PID of any existing process may be "
"specified), its real user ID, effective user ID, or saved set-user-ID "
"(unless it has B<CAP_SETUID>), and its real group ID, effective group ID, or "
"saved set-group-ID (unless it has B<CAP_SETGID>)."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:563
msgid ""
"To receive a I<struct ucred> message, the B<SO_PASSCRED> option must be "
"enabled on the socket."
msgstr ""

#. type: TP
#: build/C/man7/unix.7:563
#, no-wrap
msgid "B<SCM_SECURITY>"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:572
msgid ""
"Receive the SELinux security context (the security label)  of the peer "
"socket.  The received ancillary data is a null-terminated string containing "
"the security context.  The receiver should allocate at least B<NAME_MAX> "
"bytes in the data portion of the ancillary message for this data."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:576
msgid ""
"To receive the security context, the B<SO_PASSSEC> option must be enabled on "
"the socket (see above)."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:580
msgid ""
"When sending ancillary data with B<sendmsg>(2), only one item of each of the "
"above types may be included in the sent message."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:588
msgid ""
"At least one byte of real data should be sent when sending ancillary data.  "
"On Linux, this is required to successfully send ancillary data over a UNIX "
"domain stream socket.  When sending ancillary data over a UNIX domain "
"datagram socket, it is not necessary on Linux to send any accompanying real "
"data.  However, portable applications should also include at least one byte "
"of real data when sending ancillary data over a datagram socket."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:592
msgid ""
"When receiving from a stream socket, ancillary data forms a kind of barrier "
"for the received data.  For example, suppose that the sender transmits as "
"follows:"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:598 build/C/man7/unix.7:604
msgid "B<sendmsg>(2)  of four bytes, with no ancillary data."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:601
msgid "B<sendmsg>(2)  of one byte, with ancillary data."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:615
msgid ""
"Suppose that the receiver now performs B<recvmsg>(2)  calls each with a "
"buffer size of 20 bytes.  The first call will receive five bytes of data, "
"along with the ancillary data sent by the second B<sendmsg>(2)  call.  The "
"next call will receive the remaining four bytes of data."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:636
msgid ""
"If the space allocated for receiving incoming ancillary data is too small "
"then the ancillary data is truncated to the number of headers that will fit "
"in the supplied buffer (or, in the case of an B<SCM_RIGHTS> file descriptor "
"list, the list of file descriptors may be truncated).  If no buffer is "
"provided for incoming ancillary data (i.e., the I<msg_control> field of the "
"I<msghdr> structure supplied to B<recvmsg>(2)  is NULL), then the incoming "
"ancillary data is discarded.  In both of these cases, the B<MSG_CTRUNC> flag "
"will be set in the I<msg.msg_flags> value returned by B<recvmsg>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:647
#, no-wrap
msgid ""
"B<int>I< value>B<;>\n"
"I<error>B< = ioctl(>I<unix_socket>B<, >I<ioctl_type>B<, &>I<value>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:652
msgid "I<ioctl_type> can be:"
msgstr ""

#.  FIXME . http://sources.redhat.com/bugzilla/show_bug.cgi?id=12002,
#.  filed 2010-09-10, may cause SIOCINQ to be defined in glibc headers
#.  SIOCOUTQ also has an effect for UNIX domain sockets, but not
#.  quite what userland might expect. It seems to return the number
#.  of bytes allocated for buffers containing pending output.
#.  That number is normally larger than the number of bytes of pending
#.  output. Since this info is, from userland's point of view, imprecise,
#.  and it may well change, probably best not to document this now.
#. type: Plain text
#: build/C/man7/unix.7:683
msgid ""
"For B<SOCK_STREAM> sockets, this call returns the number of unread bytes in "
"the receive buffer.  The socket must not be in LISTEN state, otherwise an "
"error (B<EINVAL>)  is returned.  B<SIOCINQ> is defined in "
"I<E<lt>linux/sockios.hE<gt>>.  Alternatively, you can use the synonymous "
"B<FIONREAD>, defined in I<E<lt>sys/ioctl.hE<gt>>.  For B<SOCK_DGRAM> "
"sockets, the returned value is the same as for Internet domain datagram "
"sockets; see B<udp>(7)."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:688
msgid ""
"The specified local address is already in use or the filesystem socket "
"object already exists."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:697
msgid ""
"This error can occur for B<sendmsg>(2)  when sending a file descriptor as "
"ancillary data over a UNIX domain socket (see the description of "
"B<SCM_RIGHTS>, above), and indicates that the file descriptor number that is "
"being sent is not valid (e.g., it is not an open file descriptor)."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:703
msgid ""
"The remote address specified by B<connect>(2)  was not a listening socket.  "
"This error can also occur if the target pathname is not a socket."
msgstr ""

#. type: TP
#: build/C/man7/unix.7:703
#, no-wrap
msgid "B<ECONNRESET>"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:706
msgid "Remote socket was unexpectedly closed."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:709
msgid "User memory address was not valid."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:718
msgid ""
"Invalid argument passed.  A common cause is that the value B<AF_UNIX> was "
"not specified in the I<sun_type> field of passed addresses, or the socket "
"was in an invalid state for the applied operation."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:723
msgid ""
"B<connect>(2)  called on an already connected socket or a target address was "
"specified on a connected socket."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:728
msgid ""
"The pathname in the remote address specified to B<connect>(2)  did not "
"exist."
msgstr ""

#. type: TP
#: build/C/man7/unix.7:728
#, no-wrap
msgid "B<ENOMEM>"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:734
msgid "Socket operation needs a target address, but the socket is not connected."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:738
msgid ""
"Stream operation called on non-stream oriented socket or tried to use the "
"out-of-band data option."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:742
msgid "The sender passed invalid credentials in the I<struct ucred>."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:754
msgid ""
"Remote socket was closed on a stream socket.  If enabled, a B<SIGPIPE> is "
"sent as well.  This can be avoided by passing the B<MSG_NOSIGNAL> flag to "
"B<send>(2)  or B<sendmsg>(2)."
msgstr ""

#. type: TP
#: build/C/man7/unix.7:754
#, no-wrap
msgid "B<EPROTONOSUPPORT>"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:758
msgid "Passed protocol is not B<AF_UNIX>."
msgstr ""

#. type: TP
#: build/C/man7/unix.7:758
#, no-wrap
msgid "B<EPROTOTYPE>"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:764
msgid ""
"Remote socket does not match the local socket type (B<SOCK_DGRAM> versus "
"B<SOCK_STREAM>)."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:767
msgid "Unknown socket type."
msgstr ""

#. type: TP
#: build/C/man7/unix.7:767
#, no-wrap
msgid "B<ESRCH>"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:772
msgid ""
"While sending an ancillary message containing credentials "
"(B<SCM_CREDENTIALS>), the caller specified a PID that does not match any "
"existing process."
msgstr ""

#. type: TP
#: build/C/man7/unix.7:772
#, no-wrap
msgid "B<ETOOMANYREFS>"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:789
msgid ""
"This error can occur for B<sendmsg>(2)  when sending a file descriptor as "
"ancillary data over a UNIX domain socket (see the description of "
"B<SCM_RIGHTS>, above).  It occurs if the number of \"in-flight\" file "
"descriptors exceeds the B<RLIMIT_NOFILE> resource limit and the caller does "
"not have the B<CAP_SYS_RESOURCE> capability.  An in-flight file descriptor "
"is one that has been sent using B<sendmsg>(2)  but has not yet been accepted "
"in the recipient process using B<recvmsg>(2)."
msgstr ""

#.  commit 712f4aad406bb1ed67f3f98d04c044191f0ff593
#. type: Plain text
#: build/C/man7/unix.7:800
msgid ""
"This error is diagnosed since mainline Linux 4.5 (and in some earlier kernel "
"versions where the fix has been backported).  In earlier kernel versions, it "
"was possible to place an unlimited number of file descriptors in flight, by "
"sending each file descriptor with B<sendmsg>(2)  and then closing the file "
"descriptor so that it was not accounted against the B<RLIMIT_NOFILE> "
"resource limit."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:804
msgid ""
"Other errors can be generated by the generic socket layer or by the "
"filesystem while generating a filesystem socket object.  See the appropriate "
"manual pages for more information."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:810
msgid ""
"B<SCM_CREDENTIALS> and the abstract namespace were introduced with Linux 2.2 "
"and should not be used in portable programs.  (Some BSD-derived systems also "
"support credential passing, but the implementation details differ.)"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:818
msgid ""
"Binding to a socket with a filename creates a socket in the filesystem that "
"must be deleted by the caller when it is no longer needed (using "
"B<unlink>(2)).  The usual UNIX close-behind semantics apply; the socket can "
"be unlinked at any time and will be finally removed from the filesystem when "
"the last reference to it is closed."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:827
msgid ""
"To pass file descriptors or credentials over a B<SOCK_STREAM> socket, you "
"must to send or receive at least one byte of nonancillary data in the same "
"B<sendmsg>(2)  or B<recvmsg>(2)  call."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:830
msgid "UNIX domain stream sockets do not support the notion of out-of-band data."
msgstr ""

#.  The behavior on Solaris is quite similar.
#. type: Plain text
#: build/C/man7/unix.7:855
msgid ""
"When binding a socket to an address, Linux is one of the implementations "
"that appends a null terminator if none is supplied in I<sun_path>.  In most "
"cases this is unproblematic: when the socket address is retrieved, it will "
"be one byte longer than that supplied when the socket was bound.  However, "
"there is one case where confusing behavior can result: if 108 non-null bytes "
"are supplied when a socket is bound, then the addition of the null "
"terminator takes the length of the pathname beyond I<sizeof(sun_path)>.  "
"Consequently, when retrieving the socket address (for example, via "
"B<accept>(2)), if the input I<addrlen> argument for the retrieving call is "
"specified as I<sizeof(struct sockaddr_un)>, then the returned address "
"structure I<won't> have a null terminator in I<sun_path>."
msgstr ""

#.  i.e., traditional BSD
#. type: Plain text
#: build/C/man7/unix.7:865
msgid ""
"In addition, some implementations don't require a null terminator when "
"binding a socket (the I<addrlen> argument is used to determine the length of "
"I<sun_path>)  and when the socket address is retrieved on these "
"implementations, there is no null terminator in I<sun_path>."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:870
msgid ""
"Applications that retrieve socket addresses can (portably) code to handle "
"the possibility that there is no null terminator in I<sun_path> by "
"respecting the fact that the number of valid bytes in the pathname is:"
msgstr ""

#.  The following patch to amend kernel behavior was rejected:
#.  http://thread.gmane.org/gmane.linux.kernel.api/2437
#.  Subject: [patch] Fix handling of overlength pathname in AF_UNIX sun_path
#.  2012-04-17
#.  And there was a related discussion in the Austin list:
#.  http://thread.gmane.org/gmane.comp.standards.posix.austin.general/5735
#.  Subject: Having a sun_path with no null terminator
#.  2012-04-18
#
#.  FIXME . Track http://austingroupbugs.net/view.php?id=561
#. type: Plain text
#: build/C/man7/unix.7:882
#, no-wrap
msgid "    strnlen(addr.sun_path, addrlen - offsetof(sockaddr_un, sun_path))\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:894
msgid ""
"Alternatively, an application can retrieve the socket address by allocating "
"a buffer of size I<sizeof(struct sockaddr_un)+1> that is zeroed out before "
"the retrieval.  The retrieving call can specify I<addrlen> as "
"I<sizeof(struct sockaddr_un)>, and the extra zero byte ensures that there "
"will be a null terminator for the string returned in I<sun_path>:"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:898
#, no-wrap
msgid "void *addrp;\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:904
#, no-wrap
msgid ""
"addrlen = sizeof(struct sockaddr_un);\n"
"addrp = malloc(addrlen + 1);\n"
"if (addrp == NULL)\n"
"    /* Handle error */ ;\n"
"memset(addrp, 0, addrlen + 1);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:907
#, no-wrap
msgid ""
"if (getsockname(sfd, (struct sockaddr *) addrp, &addrlen)) == -1)\n"
"    /* handle error */ ;\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:909
#, no-wrap
msgid ""
"printf(\"sun_path = %s\\en\", ((struct sockaddr_un *) "
"addrp)-E<gt>sun_path);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:917
msgid ""
"This sort of messiness can be avoided if it is guaranteed that the "
"applications that I<create> pathname sockets follow the rules outlined above "
"under I<Pathname sockets>."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:929
msgid ""
"The following code demonstrates the use of sequenced-packet sockets for "
"local interprocess communication.  It consists of two programs.  The server "
"program waits for a connection from the client program.  The client sends "
"each of its command-line arguments in separate messages.  The server treats "
"the incoming messages as integers and adds them up.  The client sends the "
"command string \"END\".  The server sends back a message containing the sum "
"of the client's integers.  The client prints the sum and exits.  The server "
"waits for the next client to connect.  To stop the server, the client is "
"called with the command-line argument \"DOWN\"."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:933
msgid ""
"The following output was recorded while running the server in the background "
"and repeatedly executing the client.  Execution of the server program ends "
"when it receives the \"DOWN\" command."
msgstr ""

#. type: SS
#: build/C/man7/unix.7:933
#, no-wrap
msgid "Example output"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:946
#, no-wrap
msgid ""
"$ B<./server &>\n"
"[1] 25887\n"
"$ B<./client 3 4>\n"
"Result = 7\n"
"$ B<./client 11 -5>\n"
"Result = 6\n"
"$ B<./client DOWN>\n"
"Result = 0\n"
"[1]+  Done                    ./server\n"
"$\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:954
#, no-wrap
msgid ""
"/*\n"
" * File connection.h\n"
" */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:957
#, no-wrap
msgid ""
"#define SOCKET_NAME \"/tmp/9Lq7BNBnBycd6nxy.socket\"\n"
"#define BUFFER_SIZE 12\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:961
#, no-wrap
msgid ""
"/*\n"
" * File server.c\n"
" */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:969
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>sys/un.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include \"connection.h\"\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:980
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct sockaddr_un name;\n"
"    int down_flag = 0;\n"
"    int ret;\n"
"    int connection_socket;\n"
"    int data_socket;\n"
"    int result;\n"
"    char buffer[BUFFER_SIZE];\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:982 build/C/man7/unix.7:1115
#, no-wrap
msgid "    /* Create local socket. */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:988
#, no-wrap
msgid ""
"    connection_socket = socket(AF_UNIX, SOCK_SEQPACKET, 0);\n"
"    if (connection_socket == -1) {\n"
"        perror(\"socket\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:994 build/C/man7/unix.7:1127
#, no-wrap
msgid ""
"    /*\n"
"     * For portability clear the whole structure, since some\n"
"     * implementations have additional (nonstandard) fields in\n"
"     * the structure.\n"
"     */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:996
#, no-wrap
msgid "    memset(&name, 0, sizeof(name));\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:998
#, no-wrap
msgid "    /* Bind socket to socket name. */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:1001
#, no-wrap
msgid ""
"    name.sun_family = AF_UNIX;\n"
"    strncpy(name.sun_path, SOCKET_NAME, sizeof(name.sun_path) - 1);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:1008
#, no-wrap
msgid ""
"    ret = bind(connection_socket, (const struct sockaddr *) &name,\n"
"               sizeof(name));\n"
"    if (ret == -1) {\n"
"        perror(\"bind\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:1014
#, no-wrap
msgid ""
"    /*\n"
"     * Prepare for accepting connections. The backlog size is set\n"
"     * to 20. So while one request is being processed other requests\n"
"     * can be waiting.\n"
"     */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:1020
#, no-wrap
msgid ""
"    ret = listen(connection_socket, 20);\n"
"    if (ret == -1) {\n"
"        perror(\"listen\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:1022
#, no-wrap
msgid "    /* This is the main loop for handling connections. */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:1024
#, no-wrap
msgid "    for (;;) {\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:1026
#, no-wrap
msgid "        /* Wait for incoming connection. */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:1032
#, no-wrap
msgid ""
"        data_socket = accept(connection_socket, NULL, NULL);\n"
"        if (data_socket == -1) {\n"
"            perror(\"accept\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:1035
#, no-wrap
msgid ""
"        result = 0;\n"
"        for (;;) {\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:1037
#, no-wrap
msgid "            /* Wait for next data packet. */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:1043
#, no-wrap
msgid ""
"            ret = read(data_socket, buffer, sizeof(buffer));\n"
"            if (ret == -1) {\n"
"                perror(\"read\");\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:1045
#, no-wrap
msgid "            /* Ensure buffer is 0-terminated. */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:1047
#, no-wrap
msgid "            buffer[sizeof(buffer) - 1] = 0;\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:1049
#, no-wrap
msgid "            /* Handle commands. */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:1054
#, no-wrap
msgid ""
"            if (!strncmp(buffer, \"DOWN\", sizeof(buffer))) {\n"
"                down_flag = 1;\n"
"                break;\n"
"            }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:1058
#, no-wrap
msgid ""
"            if (!strncmp(buffer, \"END\", sizeof(buffer))) {\n"
"                break;\n"
"            }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:1060
#, no-wrap
msgid "            /* Add received summand. */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:1063
#, no-wrap
msgid ""
"            result += atoi(buffer);\n"
"        }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:1065
#, no-wrap
msgid "        /* Send result. */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:1072
#, no-wrap
msgid ""
"        sprintf(buffer, \"%d\", result);\n"
"        ret = write(data_socket, buffer, sizeof(buffer));\n"
"        if (ret == -1) {\n"
"            perror(\"write\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:1074
#, no-wrap
msgid "        /* Close socket. */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:1076
#, no-wrap
msgid "        close(data_socket);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:1078
#, no-wrap
msgid "        /* Quit on DOWN command. */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:1083
#, no-wrap
msgid ""
"        if (down_flag) {\n"
"            break;\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:1085
#, no-wrap
msgid "    close(connection_socket);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:1087
#, no-wrap
msgid "    /* Unlink the socket. */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:1089
#, no-wrap
msgid "    unlink(SOCKET_NAME);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:1096
#, no-wrap
msgid ""
"/*\n"
" * File client.c\n"
" */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:1105
#, no-wrap
msgid ""
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>sys/un.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include \"connection.h\"\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:1113
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct sockaddr_un addr;\n"
"    int ret;\n"
"    int data_socket;\n"
"    char buffer[BUFFER_SIZE];\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:1121
#, no-wrap
msgid ""
"    data_socket = socket(AF_UNIX, SOCK_SEQPACKET, 0);\n"
"    if (data_socket == -1) {\n"
"        perror(\"socket\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:1129
#, no-wrap
msgid "    memset(&addr, 0, sizeof(addr));\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:1131
#, no-wrap
msgid "    /* Connect socket to socket address */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:1134
#, no-wrap
msgid ""
"    addr.sun_family = AF_UNIX;\n"
"    strncpy(addr.sun_path, SOCKET_NAME, sizeof(addr.sun_path) - 1);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:1141
#, no-wrap
msgid ""
"    ret = connect(data_socket, (const struct sockaddr *) &addr,\n"
"                   sizeof(addr));\n"
"    if (ret == -1) {\n"
"        fprintf(stderr, \"The server is down.\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:1143
#, no-wrap
msgid "    /* Send arguments. */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:1151
#, no-wrap
msgid ""
"    for (int i = 1; i E<lt> argc; ++i) {\n"
"        ret = write(data_socket, argv[i], strlen(argv[i]) + 1);\n"
"        if (ret == -1) {\n"
"            perror(\"write\");\n"
"            break;\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:1153
#, no-wrap
msgid "    /* Request result. */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:1160
#, no-wrap
msgid ""
"    strcpy(buffer, \"END\");\n"
"    ret = write(data_socket, buffer, strlen(buffer) + 1);\n"
"    if (ret == -1) {\n"
"        perror(\"write\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:1162
#, no-wrap
msgid "    /* Receive result. */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:1168
#, no-wrap
msgid ""
"    ret = read(data_socket, buffer, sizeof(buffer));\n"
"    if (ret == -1) {\n"
"        perror(\"read\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:1170
#, no-wrap
msgid "    /* Ensure buffer is 0-terminated. */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:1172
#, no-wrap
msgid "    buffer[sizeof(buffer) - 1] = 0;\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:1174
#, no-wrap
msgid "    printf(\"Result = %s\\en\", buffer);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:1176
#, no-wrap
msgid "    /* Close socket. */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:1178
#, no-wrap
msgid "    close(data_socket);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:1187
msgid "For an example of the use of B<SCM_RIGHTS> see B<cmsg>(3)."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:1197
msgid ""
"B<recvmsg>(2), B<sendmsg>(2), B<socket>(2), B<socketpair>(2), B<cmsg>(3), "
"B<capabilities>(7), B<credentials>(7), B<socket>(7), B<udp>(7)"
msgstr ""

#. type: TH
#: build/C/man7/x25.7:12
#, no-wrap
msgid "X25"
msgstr ""

#. type: Plain text
#: build/C/man7/x25.7:15
msgid "x25 - ITU-T X.25 / ISO-8208 protocol interface"
msgstr ""

#. type: Plain text
#: build/C/man7/x25.7:19
msgid "B<#include E<lt>linux/x25.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man7/x25.7:21
msgid "B<x25_socket = socket(AF_X25, SOCK_SEQPACKET, 0);>"
msgstr ""

#. type: Plain text
#: build/C/man7/x25.7:30
msgid ""
"X25 sockets provide an interface to the X.25 packet layer protocol.  This "
"allows applications to communicate over a public X.25 data network as "
"standardized by International Telecommunication Union's recommendation X.25 "
"(X.25 DTE-DCE mode).  X25 sockets can also be used for communication without "
"an intermediate X.25 network (X.25 DTE-DTE mode) as described in ISO-8208."
msgstr ""

#. type: Plain text
#: build/C/man7/x25.7:47
msgid ""
"Message boundaries are preserved \\(em a B<read>(2)  from a socket will "
"retrieve the same chunk of data as output with the corresponding B<write>(2)  "
"to the peer socket.  When necessary, the kernel takes care of segmenting and "
"reassembling long messages by means of the X.25 M-bit.  There is no "
"hard-coded upper limit for the message size.  However, reassembling of a "
"long message might fail if there is a temporary lack of system resources or "
"when other constraints (such as socket memory or buffer size limits) become "
"effective.  If that occurs, the X.25 connection will be reset."
msgstr ""

#. type: SS
#: build/C/man7/x25.7:47
#, no-wrap
msgid "Socket addresses"
msgstr ""

#. type: Plain text
#: build/C/man7/x25.7:54
msgid ""
"The B<AF_X25> socket address family uses the I<struct sockaddr_x25> for "
"representing network addresses as defined in ITU-T recommendation X.121."
msgstr ""

#. type: Plain text
#: build/C/man7/x25.7:61
#, no-wrap
msgid ""
"struct sockaddr_x25 {\n"
"    sa_family_t sx25_family;    /* must be AF_X25 */\n"
"    x25_address sx25_addr;      /* X.121 Address */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/x25.7:72
msgid ""
"I<sx25_addr> contains a char array I<x25_addr[]> to be interpreted as a "
"null-terminated string.  I<sx25_addr.x25_addr[]> consists of up to 15 (not "
"counting the terminating null byte) ASCII characters forming the X.121 "
"address.  Only the decimal digit characters from \\(aq0\\(aq to \\(aq9\\(aq "
"are allowed."
msgstr ""

#. type: Plain text
#: build/C/man7/x25.7:81
msgid ""
"The following X.25-specific socket options can be set by using "
"B<setsockopt>(2)  and read with B<getsockopt>(2)  with the I<level> argument "
"set to B<SOL_X25>."
msgstr ""

#. type: TP
#: build/C/man7/x25.7:81
#, no-wrap
msgid "B<X25_QBITINCL>"
msgstr ""

#. type: Plain text
#: build/C/man7/x25.7:100
msgid ""
"Controls whether the X.25 Q-bit (Qualified Data Bit) is accessible by the "
"user.  It expects an integer argument.  If set to 0 (default), the Q-bit is "
"never set for outgoing packets and the Q-bit of incoming packets is "
"ignored.  If set to 1, an additional first byte is prepended to each message "
"read from or written to the socket.  For data read from the socket, a 0 "
"first byte indicates that the Q-bits of the corresponding incoming data "
"packets were not set.  A first byte with value 1 indicates that the Q-bit of "
"the corresponding incoming data packets was set.  If the first byte of the "
"data written to the socket is 1, the Q-bit of the corresponding outgoing "
"data packets will be set.  If the first byte is 0, the Q-bit will not be "
"set."
msgstr ""

#. type: Plain text
#: build/C/man7/x25.7:102
msgid "The AF_X25 protocol family is a new feature of Linux 2.2."
msgstr ""

#. type: Plain text
#: build/C/man7/x25.7:105
msgid "Plenty, as the X.25 PLP implementation is B<CONFIG_EXPERIMENTAL>."
msgstr ""

#. type: Plain text
#: build/C/man7/x25.7:107
msgid "This man page is incomplete."
msgstr ""

#. type: Plain text
#: build/C/man7/x25.7:114
msgid ""
"There is no dedicated application programmer's header file yet; you need to "
"include the kernel header file I<E<lt>linux/x25.hE<gt>>.  "
"B<CONFIG_EXPERIMENTAL> might also imply that future versions of the "
"interface are not binary compatible."
msgstr ""

#. type: Plain text
#: build/C/man7/x25.7:118
msgid ""
"X.25 N-Reset events are not propagated to the user process yet.  Thus, if a "
"reset occurred, data might be lost without notice."
msgstr ""

#. type: Plain text
#: build/C/man7/x25.7:121
msgid "B<socket>(2), B<socket>(7)"
msgstr ""

#. type: Plain text
#: build/C/man7/x25.7:127
msgid ""
"Jonathan Simon Naylor: \\(lqThe Re-Analysis and Re-Implementation of "
"X.25.\\(rq The URL is E<.UR "
"ftp://ftp.pspt.fi\\:/pub\\:/ham\\:/linux\\:/ax25\\:/x25doc.tgz> E<.UE .>"
msgstr ""
