# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-03-12 14:01+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man7/cgroup_namespaces.7:26
#, no-wrap
msgid "CGROUP_NAMESPACES"
msgstr ""

#. type: TH
#: build/C/man7/cgroup_namespaces.7:26 build/C/man7/mount_namespaces.7:26 build/C/man7/namespaces.7:27 build/C/man7/pid_namespaces.7:27 build/C/man7/user_namespaces.7:27
#, no-wrap
msgid "2020-11-01"
msgstr ""

#. type: TH
#: build/C/man7/cgroup_namespaces.7:26 build/C/man7/ipc_namespaces.7:26 build/C/man7/mount_namespaces.7:26 build/C/man7/namespaces.7:27 build/C/man7/network_namespaces.7:26 build/C/man7/pid_namespaces.7:27 build/C/man7/time_namespaces.7:26 build/C/man7/user_namespaces.7:27 build/C/man7/uts_namespaces.7:26
#, no-wrap
msgid "Linux"
msgstr ""

#. type: TH
#: build/C/man7/cgroup_namespaces.7:26 build/C/man7/ipc_namespaces.7:26 build/C/man7/mount_namespaces.7:26 build/C/man7/namespaces.7:27 build/C/man7/network_namespaces.7:26 build/C/man7/pid_namespaces.7:27 build/C/man7/time_namespaces.7:26 build/C/man7/user_namespaces.7:27 build/C/man7/uts_namespaces.7:26
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr ""

#. type: SH
#: build/C/man7/cgroup_namespaces.7:27 build/C/man7/ipc_namespaces.7:27 build/C/man7/mount_namespaces.7:27 build/C/man7/namespaces.7:28 build/C/man7/network_namespaces.7:27 build/C/man7/pid_namespaces.7:28 build/C/man7/time_namespaces.7:27 build/C/man7/user_namespaces.7:28 build/C/man7/uts_namespaces.7:27
#, no-wrap
msgid "NAME"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroup_namespaces.7:29
msgid "cgroup_namespaces - overview of Linux cgroup namespaces"
msgstr ""

#. type: SH
#: build/C/man7/cgroup_namespaces.7:29 build/C/man7/ipc_namespaces.7:29 build/C/man7/mount_namespaces.7:29 build/C/man7/namespaces.7:30 build/C/man7/network_namespaces.7:29 build/C/man7/pid_namespaces.7:30 build/C/man7/time_namespaces.7:29 build/C/man7/user_namespaces.7:30 build/C/man7/uts_namespaces.7:29
#, no-wrap
msgid "DESCRIPTION"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroup_namespaces.7:32 build/C/man7/mount_namespaces.7:32 build/C/man7/pid_namespaces.7:33 build/C/man7/user_namespaces.7:33
msgid "For an overview of namespaces, see B<namespaces>(7)."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroup_namespaces.7:39
msgid ""
"Cgroup namespaces virtualize the view of a process's cgroups (see "
"B<cgroups>(7))  as seen via I</proc/[pid]/cgroup> and "
"I</proc/[pid]/mountinfo>."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroup_namespaces.7:56
msgid ""
"Each cgroup namespace has its own set of cgroup root directories.  These "
"root directories are the base points for the relative locations displayed in "
"the corresponding records in the I</proc/[pid]/cgroup> file.  When a process "
"creates a new cgroup namespace using B<clone>(2)  or B<unshare>(2)  with the "
"B<CLONE_NEWCGROUP> flag, its current cgroups directories become the cgroup "
"root directories of the new namespace.  (This applies both for the cgroups "
"version 1 hierarchies and the cgroups version 2 unified hierarchy.)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroup_namespaces.7:67
msgid ""
"When reading the cgroup memberships of a \"target\" process from "
"I</proc/[pid]/cgroup>, the pathname shown in the third field of each record "
"will be relative to the reading process's root directory for the "
"corresponding cgroup hierarchy.  If the cgroup directory of the target "
"process lies outside the root directory of the reading process's cgroup "
"namespace, then the pathname will show I<../> entries for each ancestor "
"level in the cgroup hierarchy."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroup_namespaces.7:70
msgid ""
"The following shell session demonstrates the effect of creating a new cgroup "
"namespace."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroup_namespaces.7:76
msgid ""
"First, (as superuser) in a shell in the initial cgroup namespace, we create "
"a child cgroup in the I<freezer> hierarchy, and place a process in that "
"cgroup that we will use as part of the demonstration below:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroup_namespaces.7:83
#, no-wrap
msgid ""
"# B<mkdir -p /sys/fs/cgroup/freezer/sub2>\n"
"# B<sleep 10000 &>     # Create a process that lives for a while\n"
"[1] 20124\n"
"# B<echo 20124 E<gt> /sys/fs/cgroup/freezer/sub2/cgroup.procs>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroup_namespaces.7:89
msgid ""
"We then create another child cgroup in the I<freezer> hierarchy and put the "
"shell into that cgroup:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroup_namespaces.7:98
#, no-wrap
msgid ""
"# B<mkdir -p /sys/fs/cgroup/freezer/sub>\n"
"# B<echo $$>                      # Show PID of this shell\n"
"30655\n"
"# B<echo 30655 E<gt> /sys/fs/cgroup/freezer/sub/cgroup.procs>\n"
"# B<cat /proc/self/cgroup | grep freezer>\n"
"7:freezer:/sub\n"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroup_namespaces.7:104
msgid ""
"Next, we use B<unshare>(1)  to create a process running a new shell in new "
"cgroup and mount namespaces:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroup_namespaces.7:108
#, no-wrap
msgid "# B<PS1=\"sh2# \" unshare -Cm bash>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroup_namespaces.7:120
msgid ""
"From the new shell started by B<unshare>(1), we then inspect the "
"I</proc/[pid]/cgroup> files of, respectively, the new shell, a process that "
"is in the initial cgroup namespace (I<init>, with PID 1), and the process in "
"the sibling cgroup (I<sub2>):"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroup_namespaces.7:129
#, no-wrap
msgid ""
"sh2# B<cat /proc/self/cgroup | grep freezer>\n"
"7:freezer:/\n"
"sh2# B<cat /proc/1/cgroup | grep freezer>\n"
"7:freezer:/..\n"
"sh2# B<cat /proc/20124/cgroup | grep freezer>\n"
"7:freezer:/../sub2\n"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroup_namespaces.7:145
msgid ""
"From the output of the first command, we see that the freezer cgroup "
"membership of the new shell (which is in the same cgroup as the initial "
"shell)  is shown defined relative to the freezer cgroup root directory that "
"was established when the new cgroup namespace was created.  (In absolute "
"terms, the new shell is in the I</sub> freezer cgroup, and the root "
"directory of the freezer cgroup hierarchy in the new cgroup namespace is "
"also I</sub>.  Thus, the new shell's cgroup membership is displayed as "
"\\(aq/\\(aq.)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroup_namespaces.7:149
msgid ""
"However, when we look in I</proc/self/mountinfo> we see the following "
"anomaly:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroup_namespaces.7:154
#, no-wrap
msgid ""
"sh2# B<cat /proc/self/mountinfo | grep freezer>\n"
"155 145 0:32 /.. /sys/fs/cgroup/freezer ...\n"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroup_namespaces.7:171
msgid ""
"The fourth field of this line (I</..>)  should show the directory in the "
"cgroup filesystem which forms the root of this mount.  Since by the "
"definition of cgroup namespaces, the process's current freezer cgroup "
"directory became its root freezer cgroup directory, we should see "
"\\(aq/\\(aq in this field.  The problem here is that we are seeing a mount "
"entry for the cgroup filesystem corresponding to the initial cgroup "
"namespace (whose cgroup filesystem is indeed rooted at the parent directory "
"of I<sub>).  To fix this problem, we must remount the freezer cgroup "
"filesystem from the new shell (i.e., perform the mount from a process that "
"is in the new cgroup namespace), after which we see the expected results:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroup_namespaces.7:180
#, no-wrap
msgid ""
"sh2# B<mount --make-rslave />     # Don\\(aqt propagate mount events\n"
"                               # to other namespaces\n"
"sh2# B<umount /sys/fs/cgroup/freezer>\n"
"sh2# B<mount -t cgroup -o freezer freezer /sys/fs/cgroup/freezer>\n"
"sh2# B<cat /proc/self/mountinfo | grep freezer>\n"
"155 145 0:32 / /sys/fs/cgroup/freezer rw,relatime ...\n"
msgstr ""

#. type: SH
#: build/C/man7/cgroup_namespaces.7:183 build/C/man7/mount_namespaces.7:1041 build/C/man7/pid_namespaces.7:392 build/C/man7/user_namespaces.7:952
#, no-wrap
msgid "CONFORMING TO"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroup_namespaces.7:185 build/C/man7/mount_namespaces.7:1044 build/C/man7/pid_namespaces.7:394 build/C/man7/user_namespaces.7:955
msgid "Namespaces are a Linux-specific feature."
msgstr ""

#. type: SH
#: build/C/man7/cgroup_namespaces.7:185 build/C/man7/mount_namespaces.7:1044 build/C/man7/time_namespaces.7:187 build/C/man7/user_namespaces.7:955
#, no-wrap
msgid "NOTES"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroup_namespaces.7:189
msgid ""
"Use of cgroup namespaces requires a kernel that is configured with the "
"B<CONFIG_CGROUPS> option."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroup_namespaces.7:191
msgid ""
"The virtualization provided by cgroup namespaces serves a number of "
"purposes:"
msgstr ""

#. type: IP
#: build/C/man7/cgroup_namespaces.7:191 build/C/man7/cgroup_namespaces.7:197 build/C/man7/cgroup_namespaces.7:207 build/C/man7/ipc_namespaces.7:51 build/C/man7/ipc_namespaces.7:54 build/C/man7/ipc_namespaces.7:67 build/C/man7/mount_namespaces.7:60 build/C/man7/mount_namespaces.7:65 build/C/man7/mount_namespaces.7:83 build/C/man7/mount_namespaces.7:92 build/C/man7/mount_namespaces.7:99 build/C/man7/mount_namespaces.7:110 build/C/man7/mount_namespaces.7:131 build/C/man7/mount_namespaces.7:244 build/C/man7/mount_namespaces.7:246 build/C/man7/namespaces.7:329 build/C/man7/namespaces.7:331 build/C/man7/namespaces.7:334 build/C/man7/namespaces.7:338 build/C/man7/namespaces.7:340 build/C/man7/namespaces.7:343 build/C/man7/namespaces.7:350 build/C/man7/namespaces.7:357 build/C/man7/namespaces.7:383 build/C/man7/namespaces.7:387 build/C/man7/namespaces.7:390 build/C/man7/namespaces.7:392 build/C/man7/namespaces.7:397 build/C/man7/namespaces.7:402 build/C/man7/namespaces.7:408 build/C/man7/user_namespaces.7:257 build/C/man7/user_namespaces.7:260 build/C/man7/user_namespaces.7:263 build/C/man7/user_namespaces.7:266 build/C/man7/user_namespaces.7:269 build/C/man7/user_namespaces.7:272 build/C/man7/user_namespaces.7:275 build/C/man7/user_namespaces.7:518 build/C/man7/user_namespaces.7:521 build/C/man7/user_namespaces.7:523 build/C/man7/user_namespaces.7:538 build/C/man7/user_namespaces.7:551 build/C/man7/user_namespaces.7:578 build/C/man7/user_namespaces.7:592 build/C/man7/user_namespaces.7:903 build/C/man7/user_namespaces.7:905
#, no-wrap
msgid "*"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroup_namespaces.7:197
msgid ""
"It prevents information leaks whereby cgroup directory paths outside of a "
"container would otherwise be visible to processes in the container.  Such "
"leakages could, for example, reveal information about the container "
"framework to containerized applications."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroup_namespaces.7:207
msgid ""
"It eases tasks such as container migration.  The virtualization provided by "
"cgroup namespaces allows containers to be isolated from knowledge of the "
"pathnames of ancestor cgroups.  Without such isolation, the full cgroup "
"pathnames (displayed in I</proc/self/cgroups>)  would need to be replicated "
"on the target system when migrating a container; those pathnames would also "
"need to be unique, so that they don't conflict with other pathnames on the "
"target system."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroup_namespaces.7:212
msgid ""
"It allows better confinement of containerized processes, because it is "
"possible to mount the container's cgroup filesystems such that the container "
"processes can't gain access to ancestor cgroup directories.  Consider, for "
"example, the following scenario:"
msgstr ""

#. type: IP
#: build/C/man7/cgroup_namespaces.7:213 build/C/man7/cgroup_namespaces.7:217 build/C/man7/time_namespaces.7:31 build/C/man7/time_namespaces.7:39 build/C/man7/time_namespaces.7:170 build/C/man7/time_namespaces.7:174
#, no-wrap
msgid "\\(bu"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroup_namespaces.7:217
msgid "We have a cgroup directory, I</cg/1>, that is owned by user ID 9000."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroup_namespaces.7:232
msgid ""
"We have a process, I<X>, also owned by user ID 9000, that is namespaced "
"under the cgroup I</cg/1/2> (i.e., I<X> was placed in a new cgroup namespace "
"via B<clone>(2)  or B<unshare>(2)  with the B<CLONE_NEWCGROUP> flag)."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroup_namespaces.7:259
msgid ""
"In the absence of cgroup namespacing, because the cgroup directory I</cg/1> "
"is owned (and writable) by UID 9000 and process I<X> is also owned by user "
"ID 9000, process I<X> would be able to modify the contents of cgroups files "
"(i.e., change cgroup settings) not only in I</cg/1/2> but also in the "
"ancestor cgroup directory I</cg/1>.  Namespacing process I<X> under the "
"cgroup directory I</cg/1/2>, in combination with suitable mount operations "
"for the cgroup filesystem (as shown above), prevents it modifying files in "
"I</cg/1>, since it cannot even see the contents of that directory (or of "
"further removed cgroup ancestor directories).  Combined with correct "
"enforcement of hierarchical limits, this prevents process I<X> from escaping "
"the limits imposed by ancestor cgroups."
msgstr ""

#. type: SH
#: build/C/man7/cgroup_namespaces.7:259 build/C/man7/ipc_namespaces.7:78 build/C/man7/mount_namespaces.7:1123 build/C/man7/namespaces.7:417 build/C/man7/network_namespaces.7:66 build/C/man7/pid_namespaces.7:397 build/C/man7/time_namespaces.7:359 build/C/man7/user_namespaces.7:1370 build/C/man7/uts_namespaces.7:58
#, no-wrap
msgid "SEE ALSO"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroup_namespaces.7:269
msgid ""
"B<unshare>(1), B<clone>(2), B<setns>(2), B<unshare>(2), B<proc>(5), "
"B<cgroups>(7), B<credentials>(7), B<namespaces>(7), B<user_namespaces>(7)"
msgstr ""

#. type: SH
#: build/C/man7/cgroup_namespaces.7:269 build/C/man7/ipc_namespaces.7:87 build/C/man7/mount_namespaces.7:1141 build/C/man7/namespaces.7:438 build/C/man7/network_namespaces.7:82 build/C/man7/pid_namespaces.7:409 build/C/man7/time_namespaces.7:369 build/C/man7/user_namespaces.7:1388 build/C/man7/uts_namespaces.7:68
#, no-wrap
msgid "COLOPHON"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroup_namespaces.7:277 build/C/man7/ipc_namespaces.7:95 build/C/man7/mount_namespaces.7:1149 build/C/man7/namespaces.7:446 build/C/man7/network_namespaces.7:90 build/C/man7/pid_namespaces.7:417 build/C/man7/time_namespaces.7:377 build/C/man7/user_namespaces.7:1396 build/C/man7/uts_namespaces.7:76
msgid ""
"This page is part of release 5.10 of the Linux I<man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at "
"\\%https://www.kernel.org/doc/man-pages/."
msgstr ""

#. type: TH
#: build/C/man7/ipc_namespaces.7:26
#, no-wrap
msgid "IPC_NAMESPACES"
msgstr ""

#. type: TH
#: build/C/man7/ipc_namespaces.7:26
#, no-wrap
msgid "2019-08-02"
msgstr ""

#. type: Plain text
#: build/C/man7/ipc_namespaces.7:29
msgid "ipc_namespaces - overview of Linux IPC namespaces"
msgstr ""

#.  commit 7eafd7c74c3f2e67c27621b987b28397110d643f
#.  https://lwn.net/Articles/312232/
#. type: Plain text
#: build/C/man7/ipc_namespaces.7:41
msgid ""
"IPC namespaces isolate certain IPC resources, namely, System V IPC objects "
"(see B<sysvipc>(7))  and (since Linux 2.6.30)  POSIX message queues (see "
"B<mq_overview>(7)).  The common characteristic of these IPC mechanisms is "
"that IPC objects are identified by mechanisms other than filesystem "
"pathnames."
msgstr ""

#. type: Plain text
#: build/C/man7/ipc_namespaces.7:47
msgid ""
"Each IPC namespace has its own set of System V IPC identifiers and its own "
"POSIX message queue filesystem.  Objects created in an IPC namespace are "
"visible to all other processes that are members of that namespace, but are "
"not visible to processes in other IPC namespaces."
msgstr ""

#. type: Plain text
#: build/C/man7/ipc_namespaces.7:51
msgid "The following I</proc> interfaces are distinct in each IPC namespace:"
msgstr ""

#. type: Plain text
#: build/C/man7/ipc_namespaces.7:54
msgid "The POSIX message queue interfaces in I</proc/sys/fs/mqueue>."
msgstr ""

#. type: Plain text
#: build/C/man7/ipc_namespaces.7:67
msgid ""
"The System V IPC interfaces in I</proc/sys/kernel>, namely: I<msgmax>, "
"I<msgmnb>, I<msgmni>, I<sem>, I<shmall>, I<shmmax>, I<shmmni>, and "
"I<shm_rmid_forced>."
msgstr ""

#. type: Plain text
#: build/C/man7/ipc_namespaces.7:70
msgid "The System V IPC interfaces in I</proc/sysvipc>."
msgstr ""

#. type: Plain text
#: build/C/man7/ipc_namespaces.7:74
msgid ""
"When an IPC namespace is destroyed (i.e., when the last process that is a "
"member of the namespace terminates), all IPC objects in the namespace are "
"automatically destroyed."
msgstr ""

#. type: Plain text
#: build/C/man7/ipc_namespaces.7:78
msgid ""
"Use of IPC namespaces requires a kernel that is configured with the "
"B<CONFIG_IPC_NS> option."
msgstr ""

#. type: Plain text
#: build/C/man7/ipc_namespaces.7:87
msgid ""
"B<nsenter>(1), B<unshare>(1), B<clone>(2), B<setns>(2), B<unshare>(2), "
"B<mq_overview>(7), B<namespaces>(7), B<sysvipc>(7)"
msgstr ""

#. type: TH
#: build/C/man7/mount_namespaces.7:26
#, no-wrap
msgid "MOUNT_NAMESPACES"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:29
msgid "mount_namespaces - overview of Linux mount namespaces"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:37
msgid ""
"Mount namespaces provide isolation of the list of mount points seen by the "
"processes in each namespace instance.  Thus, the processes in each of the "
"mount namespace instances will see distinct single-directory hierarchies."
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:50
msgid ""
"The views provided by the I</proc/[pid]/mounts>, I</proc/[pid]/mountinfo>, "
"and I</proc/[pid]/mountstats> files (all described in B<proc>(5))  "
"correspond to the mount namespace in which the process with the PID I<[pid]> "
"resides.  (All of the processes that reside in the same mount namespace will "
"see the same view in these files.)"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:60
msgid ""
"A new mount namespace is created using either B<clone>(2)  or B<unshare>(2)  "
"with the B<CLONE_NEWNS> flag.  When a new mount namespace is created, its "
"mount point list is initialized as follows:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:65
msgid ""
"If the namespace is created using B<clone>(2), the mount point list of the "
"child's namespace is a copy of the mount point list in the parent's "
"namespace."
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:70
msgid ""
"If the namespace is created using B<unshare>(2), the mount point list of the "
"new namespace is a copy of the mount point list in the caller's previous "
"mount namespace."
msgstr ""

#
#.  ============================================================
#. type: Plain text
#: build/C/man7/mount_namespaces.7:81
msgid ""
"Subsequent modifications to the mount point list (B<mount>(2)  and "
"B<umount>(2))  in either mount namespace will not (by default) affect the "
"mount point list seen in the other namespace (but see the following "
"discussion of shared subtrees)."
msgstr ""

#. type: SS
#: build/C/man7/mount_namespaces.7:81
#, no-wrap
msgid "Restrictions on mount namespaces"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:83
msgid "Note the following points with respect to mount namespaces:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:92
msgid ""
"Each mount namespace has an owner user namespace.  As explained above, when "
"a new mount namespace is created, its mount point list is initialized as a "
"copy of the mount point list of another mount namespace.  If the new "
"namespace and the namespace from which the mount point list was copied are "
"owned by different user namespaces, then the new mount namespace is "
"considered I<less privileged>."
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:99
msgid ""
"When creating a less privileged mount namespace, shared mounts are reduced "
"to slave mounts.  (Shared and slave mounts are discussed below.)  This "
"ensures that mappings performed in less privileged mount namespaces will not "
"propagate to more privileged mount namespaces."
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:110
msgid ""
"Mounts that come as a single unit from a more privileged mount namespace are "
"locked together and may not be separated in a less privileged mount "
"namespace.  (The B<unshare>(2)  B<CLONE_NEWNS> operation brings across all "
"of the mounts from the original mount namespace as a single unit, and "
"recursive mounts that propagate between mount namespaces propagate as a "
"single unit.)"
msgstr ""

#.  commit 9566d6742852c527bf5af38af5cbb878dad75705
#.  Author: Eric W. Biederman <ebiederm@xmission.com>
#.  Date:   Mon Jul 28 17:26:07 2014 -0700
#
#.       mnt: Correct permission checks in do_remount
#. type: Plain text
#: build/C/man7/mount_namespaces.7:131
msgid ""
"The B<mount>(2)  flags B<MS_RDONLY>, B<MS_NOSUID>, B<MS_NOEXEC>, and the "
"\"atime\" flags (B<MS_NOATIME>, B<MS_NODIRATIME>, B<MS_RELATIME>)  settings "
"become locked when propagated from a more privileged to a less privileged "
"mount namespace, and may not be changed in the less privileged mount "
"namespace."
msgstr ""

#.  (As of 3.18-rc1 (in Al Viro's 2014-08-30 vfs.git#for-next tree))
#. type: Plain text
#: build/C/man7/mount_namespaces.7:140
msgid ""
"A file or directory that is a mount point in one namespace that is not a "
"mount point in another namespace, may be renamed, unlinked, or removed "
"(B<rmdir>(2))  in the mount namespace in which it is not a mount point "
"(subject to the usual permission checks).  Consequently, the mount point is "
"removed in the mount namespace where it was a mount point."
msgstr ""

#.  mtk: The change was in Linux 3.18, I think, with this commit:
#.      commit 8ed936b5671bfb33d89bc60bdcc7cf0470ba52fe
#.      Author: Eric W. Biederman <ebiederman@twitter.com>
#.      Date:   Tue Oct 1 18:33:48 2013 -0700
#
#.          vfs: Lazily remove mounts on unlinked files and directories.
#. type: Plain text
#: build/C/man7/mount_namespaces.7:156
msgid ""
"Previously (before Linux 3.18), attempting to unlink, rename, or remove a "
"file or directory that was a mount point in another mount namespace would "
"result in the error B<EBUSY>.  That behavior had technical problems of "
"enforcement (e.g., for NFS)  and permitted denial-of-service attacks against "
"more privileged users.  (i.e., preventing individual files from being "
"updated by bind mounting on top of them)."
msgstr ""

#. type: SH
#: build/C/man7/mount_namespaces.7:156
#, no-wrap
msgid "SHARED SUBTREES"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:171
msgid ""
"After the implementation of mount namespaces was completed, experience "
"showed that the isolation that they provided was, in some cases, too great.  "
"For example, in order to make a newly loaded optical disk available in all "
"mount namespaces, a mount operation was required in each namespace.  For "
"this use case, and others, the shared subtree feature was introduced in "
"Linux 2.6.15.  This feature allows for automatic, controlled propagation of "
"mount and unmount I<events> between namespaces (or, more precisely, between "
"the members of a I<peer group> that are propagating events to one another)."
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:176
msgid ""
"Each mount point is marked (via B<mount>(2))  as having one of the following "
"I<propagation types>:"
msgstr ""

#. type: TP
#: build/C/man7/mount_namespaces.7:176
#, no-wrap
msgid "B<MS_SHARED>"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:186
msgid ""
"This mount point shares events with members of a peer group.  Mount and "
"unmount events immediately under this mount point will propagate to the "
"other mount points that are members of the peer group.  I<Propagation> here "
"means that the same mount or unmount will automatically occur under all of "
"the other mount points in the peer group.  Conversely, mount and unmount "
"events that take place under peer mount points will propagate to this mount "
"point."
msgstr ""

#. type: TP
#: build/C/man7/mount_namespaces.7:186
#, no-wrap
msgid "B<MS_PRIVATE>"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:190
msgid ""
"This mount point is private; it does not have a peer group.  Mount and "
"unmount events do not propagate into or out of this mount point."
msgstr ""

#. type: TP
#: build/C/man7/mount_namespaces.7:190
#, no-wrap
msgid "B<MS_SLAVE>"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:195
msgid ""
"Mount and unmount events propagate into this mount point from a (master) "
"shared peer group.  Mount and unmount events under this mount point do not "
"propagate to any peer."
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:200
msgid ""
"Note that a mount point can be the slave of another peer group while at the "
"same time sharing mount and unmount events with a peer group of which it is "
"a member.  (More precisely, one peer group can be the slave of another peer "
"group.)"
msgstr ""

#. type: TP
#: build/C/man7/mount_namespaces.7:200
#, no-wrap
msgid "B<MS_UNBINDABLE>"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:209
msgid ""
"This is like a private mount, and in addition this mount can't be bind "
"mounted.  Attempts to bind mount this mount (B<mount>(2)  with the "
"B<MS_BIND> flag) will fail."
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:220
msgid ""
"When a recursive bind mount (B<mount>(2)  with the B<MS_BIND> and B<MS_REC> "
"flags) is performed on a directory subtree, any bind mounts within the "
"subtree are automatically pruned (i.e., not replicated)  when replicating "
"that subtree to produce the target subtree."
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:223
msgid "For a discussion of the propagation type assigned to a new mount, see NOTES."
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:229
msgid ""
"The propagation type is a per-mount-point setting; some mount points may be "
"marked as shared (with each shared mount point being a member of a distinct "
"peer group), while others are private (or slaved or unbindable)."
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:240
msgid ""
"Note that a mount's propagation type determines whether mounts and unmounts "
"of mount points I<immediately under> the mount point are propagated.  Thus, "
"the propagation type does not affect propagation of events for grandchildren "
"and further removed descendant mount points.  What happens if the mount "
"point itself is unmounted is determined by the propagation type that is in "
"effect for the I<parent> of the mount point."
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:244
msgid ""
"Members are added to a I<peer group> when a mount point is marked as shared "
"and either:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:246
msgid ""
"the mount point is replicated during the creation of a new mount namespace; "
"or"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:248
msgid "a new bind mount is created from the mount point."
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:251
msgid ""
"In both of these cases, the new mount point joins the peer group of which "
"the existing mount point is a member."
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:257
msgid ""
"A new peer group is also created when a child mount point is created under "
"an existing mount point that is marked as shared.  In this case, the new "
"child mount point is also marked as shared and the resulting peer group "
"consists of all the mount points that are replicated under the peers of "
"parent mount."
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:262
msgid ""
"A mount ceases to be a member of a peer group when either the mount is "
"explicitly unmounted, or when the mount is implicitly unmounted because a "
"mount namespace is removed (because it has no more member processes)."
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:271
msgid ""
"The propagation type of the mount points in a mount namespace can be "
"discovered via the \"optional fields\" exposed in I</proc/[pid]/mountinfo>.  "
"(See B<proc>(5)  for details of this file.)  The following tags can appear "
"in the optional fields for a record in that file:"
msgstr ""

#. type: TP
#: build/C/man7/mount_namespaces.7:271
#, no-wrap
msgid "I<shared:X>"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:280
msgid ""
"This mount point is shared in peer group I<X>.  Each peer group has a unique "
"ID that is automatically generated by the kernel, and all mount points in "
"the same peer group will show the same ID.  (These IDs are assigned starting "
"from the value 1, and may be recycled when a peer group ceases to have any "
"members.)"
msgstr ""

#. type: TP
#: build/C/man7/mount_namespaces.7:280
#, no-wrap
msgid "I<master:X>"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:284
msgid "This mount is a slave to shared peer group I<X>."
msgstr ""

#. type: TP
#: build/C/man7/mount_namespaces.7:284
#, no-wrap
msgid "I<propagate_from:X> (since Linux 2.6.26)"
msgstr ""

#.  commit 97e7e0f71d6d948c25f11f0a33878d9356d9579e
#. type: Plain text
#: build/C/man7/mount_namespaces.7:305
msgid ""
"This mount is a slave and receives propagation from shared peer group I<X>.  "
"This tag will always appear in conjunction with a I<master:X> tag.  Here, "
"I<X> is the closest dominant peer group under the process's root directory.  "
"If I<X> is the immediate master of the mount, or if there is no dominant "
"peer group under the same root, then only the I<master:X> field is present "
"and not the I<propagate_from:X> field.  For further details, see below."
msgstr ""

#. type: TP
#: build/C/man7/mount_namespaces.7:305
#, no-wrap
msgid "I<unbindable>"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:308
msgid "This is an unbindable mount."
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:310
msgid "If none of the above tags is present, then this is a private mount."
msgstr ""

#. type: SS
#: build/C/man7/mount_namespaces.7:310
#, no-wrap
msgid "MS_SHARED and MS_PRIVATE example"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:315
msgid ""
"Suppose that on a terminal in the initial mount namespace, we mark one mount "
"point as shared and another as private, and then view the mounts in "
"I</proc/self/mountinfo>:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:323
#, no-wrap
msgid ""
"sh1# B<mount --make-shared /mntS>\n"
"sh1# B<mount --make-private /mntP>\n"
"sh1# B<cat /proc/self/mountinfo | grep \\(aq/mnt\\(aq | sed \\(aqs/ - "
".*//\\(aq>\n"
"77 61 8:17 / /mntS rw,relatime shared:1\n"
"83 61 8:15 / /mntP rw,relatime\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:342
msgid ""
"From the I</proc/self/mountinfo> output, we see that I</mntS> is a shared "
"mount in peer group 1, and that I</mntP> has no optional tags, indicating "
"that it is a private mount.  The first two fields in each record in this "
"file are the unique ID for this mount, and the mount ID of the parent "
"mount.  We can further inspect this file to see that the parent mount point "
"of I</mntS> and I</mntP> is the root directory, I</>, which is mounted as "
"private:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:347
#, no-wrap
msgid ""
"sh1# B<cat /proc/self/mountinfo | awk \\(aq$1 == 61\\(aq | sed \\(aqs/ - "
".*//\\(aq>\n"
"61 0 8:2 / / rw,relatime\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:353
msgid ""
"On a second terminal, we create a new mount namespace where we run a second "
"shell and inspect the mounts:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:360
#, no-wrap
msgid ""
"$ B<PS1=\\(aqsh2# \\(aq sudo unshare -m --propagation unchanged sh>\n"
"sh2# B<cat /proc/self/mountinfo | grep \\(aq/mnt\\(aq | sed \\(aqs/ - "
".*//\\(aq>\n"
"222 145 8:17 / /mntS rw,relatime shared:1\n"
"225 145 8:15 / /mntP rw,relatime\n"
msgstr ""

#.  Since util-linux 2.27
#. type: Plain text
#: build/C/man7/mount_namespaces.7:374
msgid ""
"The new mount namespace received a copy of the initial mount namespace's "
"mount points.  These new mount points maintain the same propagation types, "
"but have unique mount IDs.  (The I<--propagation\\ unchanged> option "
"prevents B<unshare>(1)  from marking all mounts as private when creating a "
"new mount namespace, which it does by default.)"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:380
msgid ""
"In the second terminal, we then create submounts under each of I</mntS> and "
"I</mntP> and inspect the set-up:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:392
#, no-wrap
msgid ""
"sh2# B<mkdir /mntS/a>\n"
"sh2# B<mount /dev/sdb6 /mntS/a>\n"
"sh2# B<mkdir /mntP/b>\n"
"sh2# B<mount /dev/sdb7 /mntP/b>\n"
"sh2# B<cat /proc/self/mountinfo | grep \\(aq/mnt\\(aq | sed \\(aqs/ - "
".*//\\(aq>\n"
"222 145 8:17 / /mntS rw,relatime shared:1\n"
"225 145 8:15 / /mntP rw,relatime\n"
"178 222 8:22 / /mntS/a rw,relatime shared:2\n"
"230 225 8:23 / /mntP/b rw,relatime\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:400
msgid ""
"From the above, it can be seen that I</mntS/a> was created as shared "
"(inheriting this setting from its parent mount) and I</mntP/b> was created "
"as a private mount."
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:408
msgid ""
"Returning to the first terminal and inspecting the set-up, we see that the "
"new mount created under the shared mount point I</mntS> propagated to its "
"peer mount (in the initial mount namespace), but the new mount created under "
"the private mount point I</mntP> did not propagate:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:415
#, no-wrap
msgid ""
"sh1# B<cat /proc/self/mountinfo | grep \\(aq/mnt\\(aq | sed \\(aqs/ - "
".*//\\(aq>\n"
"77 61 8:17 / /mntS rw,relatime shared:1\n"
"83 61 8:15 / /mntP rw,relatime\n"
"179 77 8:22 / /mntS/a rw,relatime shared:2\n"
msgstr ""

#. type: SS
#: build/C/man7/mount_namespaces.7:418
#, no-wrap
msgid "MS_SLAVE example"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:427
msgid ""
"Making a mount point a slave allows it to receive propagated mount and "
"unmount events from a master shared peer group, while preventing it from "
"propagating events to that master.  This is useful if we want to (say) "
"receive a mount event when an optical disk is mounted in the master shared "
"peer group (in another mount namespace), but want to prevent mount and "
"unmount events under the slave mount from having side effects in other "
"namespaces."
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:430
msgid ""
"We can demonstrate the effect of slaving by first marking two mount points "
"as shared in the initial mount namespace:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:438
#, no-wrap
msgid ""
"sh1# B<mount --make-shared /mntX>\n"
"sh1# B<mount --make-shared /mntY>\n"
"sh1# B<cat /proc/self/mountinfo | grep \\(aq/mnt\\(aq | sed \\(aqs/ - "
".*//\\(aq>\n"
"132 83 8:23 / /mntX rw,relatime shared:1\n"
"133 83 8:22 / /mntY rw,relatime shared:2\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:443
msgid ""
"On a second terminal, we create a new mount namespace and inspect the mount "
"points:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:450
#, no-wrap
msgid ""
"sh2# B<unshare -m --propagation unchanged sh>\n"
"sh2# B<cat /proc/self/mountinfo | grep \\(aq/mnt\\(aq | sed \\(aqs/ - "
".*//\\(aq>\n"
"168 167 8:23 / /mntX rw,relatime shared:1\n"
"169 167 8:22 / /mntY rw,relatime shared:2\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:454
msgid "In the new mount namespace, we then mark one of the mount points as a slave:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:461
#, no-wrap
msgid ""
"sh2# B<mount --make-slave /mntY>\n"
"sh2# B<cat /proc/self/mountinfo | grep \\(aq/mnt\\(aq | sed \\(aqs/ - "
".*//\\(aq>\n"
"168 167 8:23 / /mntX rw,relatime shared:1\n"
"169 167 8:22 / /mntY rw,relatime master:2\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:468
msgid ""
"From the above output, we see that I</mntY> is now a slave mount that is "
"receiving propagation events from the shared peer group with the ID 2."
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:473
msgid ""
"Continuing in the new namespace, we create submounts under each of I</mntX> "
"and I</mntY>:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:480
#, no-wrap
msgid ""
"sh2# B<mkdir /mntX/a>\n"
"sh2# B<mount /dev/sda3 /mntX/a>\n"
"sh2# B<mkdir /mntY/b>\n"
"sh2# B<mount /dev/sda5 /mntY/b>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:490
msgid ""
"When we inspect the state of the mount points in the new mount namespace, we "
"see that I</mntX/a> was created as a new shared mount (inheriting the "
"\"shared\" setting from its parent mount) and I</mntY/b> was created as a "
"private mount:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:498
#, no-wrap
msgid ""
"sh2# B<cat /proc/self/mountinfo | grep \\(aq/mnt\\(aq | sed \\(aqs/ - "
".*//\\(aq>\n"
"168 167 8:23 / /mntX rw,relatime shared:1\n"
"169 167 8:22 / /mntY rw,relatime master:2\n"
"173 168 8:3 / /mntX/a rw,relatime shared:3\n"
"175 169 8:5 / /mntY/b rw,relatime\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:509
msgid ""
"Returning to the first terminal (in the initial mount namespace), we see "
"that the mount I</mntX/a> propagated to the peer (the shared I</mntX>), but "
"the mount I</mntY/b> was not propagated:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:516
#, no-wrap
msgid ""
"sh1# B<cat /proc/self/mountinfo | grep \\(aq/mnt\\(aq | sed \\(aqs/ - "
".*//\\(aq>\n"
"132 83 8:23 / /mntX rw,relatime shared:1\n"
"133 83 8:22 / /mntY rw,relatime shared:2\n"
"174 132 8:3 / /mntX/a rw,relatime shared:3\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:522
msgid "Now we create a new mount point under I</mntY> in the first shell:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:532
#, no-wrap
msgid ""
"sh1# B<mkdir /mntY/c>\n"
"sh1# B<mount /dev/sda1 /mntY/c>\n"
"sh1# B<cat /proc/self/mountinfo | grep \\(aq/mnt\\(aq | sed \\(aqs/ - "
".*//\\(aq>\n"
"132 83 8:23 / /mntX rw,relatime shared:1\n"
"133 83 8:22 / /mntY rw,relatime shared:2\n"
"174 132 8:3 / /mntX/a rw,relatime shared:3\n"
"178 133 8:1 / /mntY/c rw,relatime shared:4\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:539
msgid ""
"When we examine the mount points in the second mount namespace, we see that "
"in this case the new mount has been propagated to the slave mount point, and "
"that the new mount is itself a slave mount (to peer group 4):"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:548
#, no-wrap
msgid ""
"sh2# B<cat /proc/self/mountinfo | grep \\(aq/mnt\\(aq | sed \\(aqs/ - "
".*//\\(aq>\n"
"168 167 8:23 / /mntX rw,relatime shared:1\n"
"169 167 8:22 / /mntY rw,relatime master:2\n"
"173 168 8:3 / /mntX/a rw,relatime shared:3\n"
"175 169 8:5 / /mntY/b rw,relatime\n"
"179 169 8:1 / /mntY/c rw,relatime master:4\n"
msgstr ""

#. type: SS
#: build/C/man7/mount_namespaces.7:551
#, no-wrap
msgid "MS_UNBINDABLE example"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:556
msgid ""
"One of the primary purposes of unbindable mounts is to avoid the \"mount "
"point explosion\" problem when repeatedly performing bind mounts of a "
"higher-level subtree at a lower-level mount point.  The problem is "
"illustrated by the following shell session."
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:558
msgid "Suppose we have a system with the following mount points:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:565
#, no-wrap
msgid ""
"# B<mount | awk \\(aq{print $1, $2, $3}\\(aq>\n"
"/dev/sda1 on /\n"
"/dev/sdb6 on /mntX\n"
"/dev/sdb7 on /mntY\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:571
msgid ""
"Suppose furthermore that we wish to recursively bind mount the root "
"directory under several users' home directories.  We do this for the first "
"user, and inspect the mount points:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:582
#, no-wrap
msgid ""
"# B<mount --rbind / /home/cecilia/>\n"
"# B<mount | awk \\(aq{print $1, $2, $3}\\(aq>\n"
"/dev/sda1 on /\n"
"/dev/sdb6 on /mntX\n"
"/dev/sdb7 on /mntY\n"
"/dev/sda1 on /home/cecilia\n"
"/dev/sdb6 on /home/cecilia/mntX\n"
"/dev/sdb7 on /home/cecilia/mntY\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:587
msgid ""
"When we repeat this operation for the second user, we start to see the "
"explosion problem:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:604
#, no-wrap
msgid ""
"# B<mount --rbind / /home/henry>\n"
"# B<mount | awk \\(aq{print $1, $2, $3}\\(aq>\n"
"/dev/sda1 on /\n"
"/dev/sdb6 on /mntX\n"
"/dev/sdb7 on /mntY\n"
"/dev/sda1 on /home/cecilia\n"
"/dev/sdb6 on /home/cecilia/mntX\n"
"/dev/sdb7 on /home/cecilia/mntY\n"
"/dev/sda1 on /home/henry\n"
"/dev/sdb6 on /home/henry/mntX\n"
"/dev/sdb7 on /home/henry/mntY\n"
"/dev/sda1 on /home/henry/home/cecilia\n"
"/dev/sdb6 on /home/henry/home/cecilia/mntX\n"
"/dev/sdb7 on /home/henry/home/cecilia/mntY\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:618
msgid ""
"Under I</home/henry>, we have not only recursively added the I</mntX> and "
"I</mntY> mounts, but also the recursive mounts of those directories under "
"I</home/cecilia> that were created in the previous step.  Upon repeating the "
"step for a third user, it becomes obvious that the explosion is exponential "
"in nature:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:647
#, no-wrap
msgid ""
"# B<mount --rbind / /home/otto>\n"
"# B<mount | awk \\(aq{print $1, $2, $3}\\(aq>\n"
"/dev/sda1 on /\n"
"/dev/sdb6 on /mntX\n"
"/dev/sdb7 on /mntY\n"
"/dev/sda1 on /home/cecilia\n"
"/dev/sdb6 on /home/cecilia/mntX\n"
"/dev/sdb7 on /home/cecilia/mntY\n"
"/dev/sda1 on /home/henry\n"
"/dev/sdb6 on /home/henry/mntX\n"
"/dev/sdb7 on /home/henry/mntY\n"
"/dev/sda1 on /home/henry/home/cecilia\n"
"/dev/sdb6 on /home/henry/home/cecilia/mntX\n"
"/dev/sdb7 on /home/henry/home/cecilia/mntY\n"
"/dev/sda1 on /home/otto\n"
"/dev/sdb6 on /home/otto/mntX\n"
"/dev/sdb7 on /home/otto/mntY\n"
"/dev/sda1 on /home/otto/home/cecilia\n"
"/dev/sdb6 on /home/otto/home/cecilia/mntX\n"
"/dev/sdb7 on /home/otto/home/cecilia/mntY\n"
"/dev/sda1 on /home/otto/home/henry\n"
"/dev/sdb6 on /home/otto/home/henry/mntX\n"
"/dev/sdb7 on /home/otto/home/henry/mntY\n"
"/dev/sda1 on /home/otto/home/henry/home/cecilia\n"
"/dev/sdb6 on /home/otto/home/henry/home/cecilia/mntX\n"
"/dev/sdb7 on /home/otto/home/henry/home/cecilia/mntY\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:655
msgid ""
"The mount explosion problem in the above scenario can be avoided by making "
"each of the new mounts unbindable.  The effect of doing this is that "
"recursive mounts of the root directory will not replicate the unbindable "
"mounts.  We make such a mount for the first user:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:659
#, no-wrap
msgid "# B<mount --rbind --make-unbindable / /home/cecilia>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:663
msgid "Before going further, we show that unbindable mounts are indeed unbindable:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:670
#, no-wrap
msgid ""
"# B<mkdir /mntZ>\n"
"# B<mount --bind /home/cecilia /mntZ>\n"
"mount: wrong fs type, bad option, bad superblock on /home/cecilia,\n"
"       missing codepage or helper program, or other error\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:673
#, no-wrap
msgid ""
"       In some cases useful info is found in syslog - try\n"
"       dmesg | tail or so.\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:677
msgid "Now we create unbindable recursive bind mounts for the other two users:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:682
#, no-wrap
msgid ""
"# B<mount --rbind --make-unbindable / /home/henry>\n"
"# B<mount --rbind --make-unbindable / /home/otto>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:689
msgid ""
"Upon examining the list of mount points, we see there has been no explosion "
"of mount points, because the unbindable mounts were not replicated under "
"each user's directory:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:705
#, no-wrap
msgid ""
"# B<mount | awk \\(aq{print $1, $2, $3}\\(aq>\n"
"/dev/sda1 on /\n"
"/dev/sdb6 on /mntX\n"
"/dev/sdb7 on /mntY\n"
"/dev/sda1 on /home/cecilia\n"
"/dev/sdb6 on /home/cecilia/mntX\n"
"/dev/sdb7 on /home/cecilia/mntY\n"
"/dev/sda1 on /home/henry\n"
"/dev/sdb6 on /home/henry/mntX\n"
"/dev/sdb7 on /home/henry/mntY\n"
"/dev/sda1 on /home/otto\n"
"/dev/sdb6 on /home/otto/mntX\n"
"/dev/sdb7 on /home/otto/mntY\n"
msgstr ""

#. type: SS
#: build/C/man7/mount_namespaces.7:708
#, no-wrap
msgid "Propagation type transitions"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:717
msgid ""
"The following table shows the effect that applying a new propagation type "
"(i.e., I<mount --make-xxxx>)  has on the existing propagation type of a "
"mount point.  The rows correspond to existing propagation types, and the "
"columns are the new propagation settings.  For reasons of space, \"private\" "
"is abbreviated as \"priv\" and \"unbindable\" as \"unbind\"."
msgstr ""

#. type: tbl table
#: build/C/man7/mount_namespaces.7:720
#, no-wrap
msgid "make-shared"
msgstr ""

#. type: tbl table
#: build/C/man7/mount_namespaces.7:720
#, no-wrap
msgid "make-slave"
msgstr ""

#. type: tbl table
#: build/C/man7/mount_namespaces.7:720
#, no-wrap
msgid "make-priv"
msgstr ""

#. type: tbl table
#: build/C/man7/mount_namespaces.7:720
#, no-wrap
msgid "make-unbind"
msgstr ""

#. type: tbl table
#: build/C/man7/mount_namespaces.7:721 build/C/man7/mount_namespaces.7:771 build/C/man7/mount_namespaces.7:815
#, no-wrap
msgid "_"
msgstr ""

#. type: tbl table
#: build/C/man7/mount_namespaces.7:722 build/C/man7/mount_namespaces.7:725 build/C/man7/mount_namespaces.7:726 build/C/man7/mount_namespaces.7:770 build/C/man7/mount_namespaces.7:772 build/C/man7/mount_namespaces.7:773 build/C/man7/mount_namespaces.7:814 build/C/man7/mount_namespaces.7:816 build/C/man7/mount_namespaces.7:817
#, no-wrap
msgid "shared"
msgstr ""

#. type: tbl table
#: build/C/man7/mount_namespaces.7:722
#, no-wrap
msgid "slave/priv [1]"
msgstr ""

#. type: tbl table
#: build/C/man7/mount_namespaces.7:722 build/C/man7/mount_namespaces.7:723 build/C/man7/mount_namespaces.7:724 build/C/man7/mount_namespaces.7:725 build/C/man7/mount_namespaces.7:726
#, no-wrap
msgid "priv"
msgstr ""

#. type: tbl table
#: build/C/man7/mount_namespaces.7:722 build/C/man7/mount_namespaces.7:723 build/C/man7/mount_namespaces.7:724 build/C/man7/mount_namespaces.7:725 build/C/man7/mount_namespaces.7:726 build/C/man7/mount_namespaces.7:770 build/C/man7/mount_namespaces.7:814
#, no-wrap
msgid "unbind"
msgstr ""

#. type: tbl table
#: build/C/man7/mount_namespaces.7:723 build/C/man7/mount_namespaces.7:724 build/C/man7/mount_namespaces.7:770 build/C/man7/mount_namespaces.7:773 build/C/man7/mount_namespaces.7:814 build/C/man7/mount_namespaces.7:817
#, no-wrap
msgid "slave"
msgstr ""

#. type: tbl table
#: build/C/man7/mount_namespaces.7:723 build/C/man7/mount_namespaces.7:724 build/C/man7/mount_namespaces.7:772 build/C/man7/mount_namespaces.7:816
#, no-wrap
msgid "slave+shared"
msgstr ""

#. type: tbl table
#: build/C/man7/mount_namespaces.7:723
#, no-wrap
msgid "slave [2]"
msgstr ""

#. type: tbl table
#: build/C/man7/mount_namespaces.7:725 build/C/man7/mount_namespaces.7:770 build/C/man7/mount_namespaces.7:773 build/C/man7/mount_namespaces.7:814 build/C/man7/mount_namespaces.7:817
#, no-wrap
msgid "private"
msgstr ""

#. type: tbl table
#: build/C/man7/mount_namespaces.7:725
#, no-wrap
msgid "priv [2]"
msgstr ""

#. type: tbl table
#: build/C/man7/mount_namespaces.7:726 build/C/man7/mount_namespaces.7:817
#, no-wrap
msgid "unbindable"
msgstr ""

#. type: tbl table
#: build/C/man7/mount_namespaces.7:726
#, no-wrap
msgid "unbind [2]"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:730
msgid "Note the following details to the table:"
msgstr ""

#. type: IP
#: build/C/man7/mount_namespaces.7:730
#, no-wrap
msgid "[1]"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:733
msgid ""
"If a shared mount is the only mount in its peer group, making it a slave "
"automatically makes it private."
msgstr ""

#. type: IP
#: build/C/man7/mount_namespaces.7:733
#, no-wrap
msgid "[2]"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:736
msgid "Slaving a nonshared mount has no effect on the mount."
msgstr ""

#. type: SS
#: build/C/man7/mount_namespaces.7:736
#, no-wrap
msgid "Bind (MS_BIND) semantics"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:738 build/C/man7/mount_namespaces.7:786
msgid "Suppose that the following command is performed:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:742
#, no-wrap
msgid "mount --bind A/a B/b\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:764
msgid ""
"Here, I<A> is the source mount point, I<B> is the destination mount point, "
"I<a> is a subdirectory path under the mount point I<A>, and I<b> is a "
"subdirectory path under the mount point I<B>.  The propagation type of the "
"resulting mount, I<B/b>, depends on the propagation types of the mount "
"points I<A> and I<B>, and is summarized in the following table."
msgstr ""

#. type: tbl table
#: build/C/man7/mount_namespaces.7:769 build/C/man7/mount_namespaces.7:813
#, no-wrap
msgid "source(A)"
msgstr ""

#. type: tbl table
#: build/C/man7/mount_namespaces.7:772 build/C/man7/mount_namespaces.7:816
#, no-wrap
msgid "dest(B)"
msgstr ""

#. type: tbl table
#: build/C/man7/mount_namespaces.7:772 build/C/man7/mount_namespaces.7:773 build/C/man7/mount_namespaces.7:816
#, no-wrap
msgid "invalid"
msgstr ""

#. type: tbl table
#: build/C/man7/mount_namespaces.7:773 build/C/man7/mount_namespaces.7:817
#, no-wrap
msgid "nonshared"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:779
msgid ""
"Note that a recursive bind of a subtree follows the same semantics as for a "
"bind operation on each mount in the subtree.  (Unbindable mounts are "
"automatically pruned at the target mount point.)"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:784 build/C/man7/mount_namespaces.7:826
msgid ""
"For further details, see I<Documentation/filesystems/sharedsubtree.txt> in "
"the kernel source tree."
msgstr ""

#. type: SS
#: build/C/man7/mount_namespaces.7:784
#, no-wrap
msgid "Move (MS_MOVE) semantics"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:790
#, no-wrap
msgid "mount --move A B/b\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:808
msgid ""
"Here, I<A> is the source mount point, I<B> is the destination mount point, "
"and I<b> is a subdirectory path under the mount point I<B>.  The propagation "
"type of the resulting mount, I<B/b>, depends on the propagation types of the "
"mount points I<A> and I<B>, and is summarized in the following table."
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:821
msgid "Note: moving a mount that resides under a shared mount is invalid."
msgstr ""

#. type: SS
#: build/C/man7/mount_namespaces.7:826
#, no-wrap
msgid "Mount semantics"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:828
msgid "Suppose that we use the following command to create a mount point:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:832
#, no-wrap
msgid "mount device B/b\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:847
msgid ""
"Here, I<B> is the destination mount point, and I<b> is a subdirectory path "
"under the mount point I<B>.  The propagation type of the resulting mount, "
"I<B/b>, follows the same rules as for a bind mount, where the propagation "
"type of the source mount is considered always to be private."
msgstr ""

#. type: SS
#: build/C/man7/mount_namespaces.7:847
#, no-wrap
msgid "Unmount semantics"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:849
msgid "Suppose that we use the following command to tear down a mount point:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:853
#, no-wrap
msgid "unmount A\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:874
msgid ""
"Here, I<A> is a mount point on I<B/b>, where I<B> is the parent mount and "
"I<b> is a subdirectory path under the mount point I<B>.  If B<B> is shared, "
"then all most-recently-mounted mounts at I<b> on mounts that receive "
"propagation from mount I<B> and do not have submounts under them are "
"unmounted."
msgstr ""

#. type: SS
#: build/C/man7/mount_namespaces.7:874
#, no-wrap
msgid "The /proc/[pid]/mountinfo propagate_from tag"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:884
msgid ""
"The I<propagate_from:X> tag is shown in the optional fields of a "
"I</proc/[pid]/mountinfo> record in cases where a process can't see a slave's "
"immediate master (i.e., the pathname of the master is not reachable from the "
"filesystem root directory)  and so cannot determine the chain of propagation "
"between the mounts it can see."
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:899
msgid ""
"In the following example, we first create a two-link master-slave chain "
"between the mounts I</mnt>, I</tmp/etc>, and I</mnt/tmp/etc>.  Then the "
"B<chroot>(1)  command is used to make the I</tmp/etc> mount point "
"unreachable from the root directory, creating a situation where the master "
"of I</mnt/tmp/etc> is not reachable from the (new) root directory of the "
"process."
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:912
msgid ""
"First, we bind mount the root directory onto I</mnt> and then bind mount "
"I</proc> at I</mnt/proc> so that after the later B<chroot>(1)  the "
"B<proc>(5)  filesystem remains visible at the correct location in the "
"chroot-ed environment."
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:918
#, no-wrap
msgid ""
"# B<mkdir -p /mnt/proc>\n"
"# B<mount --bind / /mnt>\n"
"# B<mount --bind /proc /mnt/proc>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:924
msgid ""
"Next, we ensure that the I</mnt> mount is a shared mount in a new peer group "
"(with no peers):"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:932
#, no-wrap
msgid ""
"# B<mount --make-private /mnt>  # Isolate from any previous peer group\n"
"# B<mount --make-shared /mnt>\n"
"# B<cat /proc/self/mountinfo | grep \\(aq/mnt\\(aq | sed \\(aqs/ - "
".*//\\(aq>\n"
"239 61 8:2 / /mnt ... shared:102\n"
"248 239 0:4 / /mnt/proc ... shared:5\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:939
msgid "Next, we bind mount I</mnt/etc> onto I</tmp/etc>:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:948
#, no-wrap
msgid ""
"# B<mkdir -p /tmp/etc>\n"
"# B<mount --bind /mnt/etc /tmp/etc>\n"
"# B<cat /proc/self/mountinfo | egrep \\(aq/mnt|/tmp/\\(aq | sed \\(aqs/ - "
".*//\\(aq>\n"
"239 61 8:2 / /mnt ... shared:102\n"
"248 239 0:4 / /mnt/proc ... shared:5\n"
"267 40 8:2 /etc /tmp/etc ... shared:102\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:960
msgid ""
"Initially, these two mount points are in the same peer group, but we then "
"make the I</tmp/etc> a slave of I</mnt/etc>, and then make I</tmp/etc> "
"shared as well, so that it can propagate events to the next slave in the "
"chain:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:969
#, no-wrap
msgid ""
"# B<mount --make-slave /tmp/etc>\n"
"# B<mount --make-shared /tmp/etc>\n"
"# B<cat /proc/self/mountinfo | egrep \\(aq/mnt|/tmp/\\(aq | sed \\(aqs/ - "
".*//\\(aq>\n"
"239 61 8:2 / /mnt ... shared:102\n"
"248 239 0:4 / /mnt/proc ... shared:5\n"
"267 40 8:2 /etc /tmp/etc ... shared:105 master:102\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:981
msgid ""
"Then we bind mount I</tmp/etc> onto I</mnt/tmp/etc>.  Again, the two mount "
"points are initially in the same peer group, but we then make "
"I</mnt/tmp/etc> a slave of I</tmp/etc>:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:992
#, no-wrap
msgid ""
"# B<mkdir -p /mnt/tmp/etc>\n"
"# B<mount --bind /tmp/etc /mnt/tmp/etc>\n"
"# B<mount --make-slave /mnt/tmp/etc>\n"
"# B<cat /proc/self/mountinfo | egrep \\(aq/mnt|/tmp/\\(aq | sed \\(aqs/ - "
".*//\\(aq>\n"
"239 61 8:2 / /mnt ... shared:102\n"
"248 239 0:4 / /mnt/proc ... shared:5\n"
"267 40 8:2 /etc /tmp/etc ... shared:105 master:102\n"
"273 239 8:2 /etc /mnt/tmp/etc ... master:105\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:1001
msgid ""
"From the above, we see that I</mnt> is the master of the slave I</tmp/etc>, "
"which in turn is the master of the slave I</mnt/tmp/etc>."
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:1008
msgid ""
"We then B<chroot>(1)  to the I</mnt> directory, which renders the mount with "
"ID 267 unreachable from the (new) root directory:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:1012
#, no-wrap
msgid "# B<chroot /mnt>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:1017
msgid ""
"When we examine the state of the mounts inside the chroot-ed environment, we "
"see the following:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:1024
#, no-wrap
msgid ""
"# B<cat /proc/self/mountinfo | sed \\(aqs/ - .*//\\(aq>\n"
"239 61 8:2 / / ... shared:102\n"
"248 239 0:4 / /proc ... shared:5\n"
"273 239 8:2 /etc /tmp/etc ... master:105 propagate_from:102\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:1039
msgid ""
"Above, we see that the mount with ID 273 is a slave whose master is the peer "
"group 105.  The mount point for that master is unreachable, and so a "
"I<propagate_from> tag is displayed, indicating that the closest dominant "
"peer group (i.e., the nearest reachable mount in the slave chain)  is the "
"peer group with the ID 102 (corresponding to the I</mnt> mount point before "
"the B<chroot>(1)  was performed."
msgstr ""

#. type: SH
#: build/C/man7/mount_namespaces.7:1039
#, no-wrap
msgid "VERSIONS"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:1041
msgid "Mount namespaces first appeared in Linux 2.4.19."
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:1054
msgid ""
"The propagation type assigned to a new mount point depends on the "
"propagation type of the parent mount.  If the mount point has a parent "
"(i.e., it is a non-root mount point) and the propagation type of the parent "
"is B<MS_SHARED>, then the propagation type of the new mount is also "
"B<MS_SHARED>.  Otherwise, the propagation type of the new mount is "
"B<MS_PRIVATE>."
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:1067
msgid ""
"Notwithstanding the fact that the default propagation type for new mount "
"points is in many cases B<MS_PRIVATE>, B<MS_SHARED> is typically more "
"useful.  For this reason, B<systemd>(1)  automatically remounts all mount "
"points as B<MS_SHARED> on system startup.  Thus, on most modern systems, the "
"default propagation type is in practice B<MS_SHARED>."
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:1082
msgid ""
"Since, when one uses B<unshare>(1)  to create a mount namespace, the goal is "
"commonly to provide full isolation of the mount points in the new namespace, "
"B<unshare>(1)  (since I<util-linux> version 2.27) in turn reverses the step "
"performed by B<systemd>(1), by making all mount points private in the new "
"namespace.  That is, B<unshare>(1)  performs the equivalent of the following "
"in the new mount namespace:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:1086
#, no-wrap
msgid "mount --make-rprivate /\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:1093
msgid ""
"To prevent this, one can use the I<--propagation\\ unchanged> option to "
"B<unshare>(1)."
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:1107
msgid ""
"An application that creates a new mount namespace directly using B<clone>(2)  "
"or B<unshare>(2)  may desire to prevent propagation of mount events to other "
"mount namespaces (as is done by B<unshare>(1)).  This can be done by "
"changing the propagation type of mount points in the new namespace to either "
"B<MS_SLAVE> or B<MS_PRIVATE>.  using a call such as the following:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:1111
#, no-wrap
msgid "mount(NULL, \"/\", MS_SLAVE | MS_REC, NULL);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:1120
msgid ""
"For a discussion of propagation types when moving mounts (B<MS_MOVE>)  and "
"creating bind mounts (B<MS_BIND>), see "
"I<Documentation/filesystems/sharedsubtree.txt>."
msgstr ""

#. type: SH
#: build/C/man7/mount_namespaces.7:1120 build/C/man7/namespaces.7:412 build/C/man7/pid_namespaces.7:394 build/C/man7/time_namespaces.7:213 build/C/man7/user_namespaces.7:984
#, no-wrap
msgid "EXAMPLES"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:1123
msgid "See B<pivot_root>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:1138
msgid ""
"B<unshare>(1), B<clone>(2), B<mount>(2), B<pivot_root>(2), B<setns>(2), "
"B<umount>(2), B<unshare>(2), B<proc>(5), B<namespaces>(7), "
"B<user_namespaces>(7), B<findmnt>(8), B<mount>(8), B<pivot_root>(8), "
"B<umount>(8)"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:1141
msgid "I<Documentation/filesystems/sharedsubtree.txt> in the kernel source tree."
msgstr ""

#. type: TH
#: build/C/man7/namespaces.7:27
#, no-wrap
msgid "NAMESPACES"
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:30
msgid "namespaces - overview of Linux namespaces"
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:37
msgid ""
"A namespace wraps a global system resource in an abstraction that makes it "
"appear to the processes within the namespace that they have their own "
"isolated instance of the global resource.  Changes to the global resource "
"are visible to other processes that are members of the namespace, but are "
"invisible to other processes.  One use of namespaces is to implement "
"containers."
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:43
msgid ""
"This page provides pointers to information on the various namespace types, "
"describes the associated I</proc> files, and summarizes the APIs for working "
"with namespaces."
msgstr ""

#. type: SS
#: build/C/man7/namespaces.7:43
#, no-wrap
msgid "Namespace types"
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:51
msgid ""
"The following table shows the namespace types available on Linux.  The "
"second column of the table shows the flag value that is used to specify the "
"namespace type in various APIs.  The third column identifies the manual page "
"that provides details on the namespace type.  The last column is a summary "
"of the resources that are isolated by the namespace type."
msgstr ""

#. type: tbl table
#: build/C/man7/namespaces.7:54
#, no-wrap
msgid "Namespace"
msgstr ""

#. type: tbl table
#: build/C/man7/namespaces.7:54
#, no-wrap
msgid "Flag"
msgstr ""

#. type: tbl table
#: build/C/man7/namespaces.7:54
#, no-wrap
msgid "Page"
msgstr ""

#. type: tbl table
#: build/C/man7/namespaces.7:54
#, no-wrap
msgid "Isolates"
msgstr ""

#. type: tbl table
#: build/C/man7/namespaces.7:55
#, no-wrap
msgid "Cgroup"
msgstr ""

#. type: tbl table
#: build/C/man7/namespaces.7:55
#, no-wrap
msgid "CLONE_NEWCGROUP"
msgstr ""

#. type: tbl table
#: build/C/man7/namespaces.7:55
#, no-wrap
msgid "B<cgroup_namespaces>(7)"
msgstr ""

#. type: tbl table
#: build/C/man7/namespaces.7:55
#, no-wrap
msgid "Cgroup root directory"
msgstr ""

#. type: tbl table
#: build/C/man7/namespaces.7:56
#, no-wrap
msgid "IPC"
msgstr ""

#. type: tbl table
#: build/C/man7/namespaces.7:56
#, no-wrap
msgid "CLONE_NEWIPC"
msgstr ""

#. type: tbl table
#: build/C/man7/namespaces.7:56
#, no-wrap
msgid "B<ipc_namespaces>(7)"
msgstr ""

#. type: tbl table
#: build/C/man7/namespaces.7:58
#, no-wrap
msgid "System V IPC,\n"
msgstr ""

#. type: tbl table
#: build/C/man7/namespaces.7:58 build/C/man7/namespaces.7:63 build/C/man7/namespaces.7:70 build/C/man7/namespaces.7:76
#, no-wrap
msgid ".br\n"
msgstr ""

#. type: tbl table
#: build/C/man7/namespaces.7:60
#, no-wrap
msgid "POSIX message queues"
msgstr ""

#. type: tbl table
#: build/C/man7/namespaces.7:61
#, no-wrap
msgid "Network"
msgstr ""

#. type: tbl table
#: build/C/man7/namespaces.7:61
#, no-wrap
msgid "CLONE_NEWNET"
msgstr ""

#. type: tbl table
#: build/C/man7/namespaces.7:61
#, no-wrap
msgid "B<network_namespaces>(7)"
msgstr ""

#. type: tbl table
#: build/C/man7/namespaces.7:63
#, no-wrap
msgid "Network devices,\n"
msgstr ""

#. type: tbl table
#: build/C/man7/namespaces.7:65
#, no-wrap
msgid "stacks, ports, etc."
msgstr ""

#. type: tbl table
#: build/C/man7/namespaces.7:66
#, no-wrap
msgid "Mount"
msgstr ""

#. type: tbl table
#: build/C/man7/namespaces.7:66
#, no-wrap
msgid "CLONE_NEWNS"
msgstr ""

#. type: tbl table
#: build/C/man7/namespaces.7:66
#, no-wrap
msgid "B<mount_namespaces>(7)"
msgstr ""

#. type: tbl table
#: build/C/man7/namespaces.7:66
#, no-wrap
msgid "Mount points"
msgstr ""

#. type: tbl table
#: build/C/man7/namespaces.7:67
#, no-wrap
msgid "PID"
msgstr ""

#. type: tbl table
#: build/C/man7/namespaces.7:67
#, no-wrap
msgid "CLONE_NEWPID"
msgstr ""

#. type: tbl table
#: build/C/man7/namespaces.7:67
#, no-wrap
msgid "B<pid_namespaces>(7)"
msgstr ""

#. type: tbl table
#: build/C/man7/namespaces.7:67
#, no-wrap
msgid "Process IDs"
msgstr ""

#. type: tbl table
#: build/C/man7/namespaces.7:68
#, no-wrap
msgid "Time"
msgstr ""

#. type: tbl table
#: build/C/man7/namespaces.7:68
#, no-wrap
msgid "CLONE_NEWTIME"
msgstr ""

#. type: tbl table
#: build/C/man7/namespaces.7:68
#, no-wrap
msgid "B<time_namespaces>(7)"
msgstr ""

#. type: tbl table
#: build/C/man7/namespaces.7:70
#, no-wrap
msgid "Boot and monotonic\n"
msgstr ""

#. type: tbl table
#: build/C/man7/namespaces.7:72
#, no-wrap
msgid "clocks"
msgstr ""

#. type: tbl table
#: build/C/man7/namespaces.7:73
#, no-wrap
msgid "User"
msgstr ""

#. type: tbl table
#: build/C/man7/namespaces.7:73
#, no-wrap
msgid "CLONE_NEWUSER"
msgstr ""

#. type: tbl table
#: build/C/man7/namespaces.7:73
#, no-wrap
msgid "B<user_namespaces>(7)"
msgstr ""

#. type: tbl table
#: build/C/man7/namespaces.7:73
#, no-wrap
msgid "User and group IDs"
msgstr ""

#. type: tbl table
#: build/C/man7/namespaces.7:74
#, no-wrap
msgid "UTS"
msgstr ""

#. type: tbl table
#: build/C/man7/namespaces.7:74
#, no-wrap
msgid "CLONE_NEWUTS"
msgstr ""

#. type: tbl table
#: build/C/man7/namespaces.7:74
#, no-wrap
msgid "B<uts_namespaces>(7)"
msgstr ""

#. type: tbl table
#: build/C/man7/namespaces.7:76
#, no-wrap
msgid "Hostname and NIS\n"
msgstr ""

#. type: tbl table
#: build/C/man7/namespaces.7:78
#, no-wrap
msgid "domain name"
msgstr ""

#
#.  ==================== The namespaces API ====================
#. type: SS
#: build/C/man7/namespaces.7:83
#, no-wrap
msgid "The namespaces API"
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:88
msgid ""
"As well as various I</proc> files described below, the namespaces API "
"includes the following system calls:"
msgstr ""

#. type: TP
#: build/C/man7/namespaces.7:88
#, no-wrap
msgid "B<clone>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:101
msgid ""
"The B<clone>(2)  system call creates a new process.  If the I<flags> "
"argument of the call specifies one or more of the B<CLONE_NEW*> flags listed "
"below, then new namespaces are created for each flag, and the child process "
"is made a member of those namespaces.  (This system call also implements a "
"number of features unrelated to namespaces.)"
msgstr ""

#. type: TP
#: build/C/man7/namespaces.7:101
#, no-wrap
msgid "B<setns>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:110
msgid ""
"The B<setns>(2)  system call allows the calling process to join an existing "
"namespace.  The namespace to join is specified via a file descriptor that "
"refers to one of the I</proc/[pid]/ns> files described below."
msgstr ""

#. type: TP
#: build/C/man7/namespaces.7:110
#, no-wrap
msgid "B<unshare>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:123
msgid ""
"The B<unshare>(2)  system call moves the calling process to a new "
"namespace.  If the I<flags> argument of the call specifies one or more of "
"the B<CLONE_NEW*> flags listed below, then new namespaces are created for "
"each flag, and the calling process is made a member of those namespaces.  "
"(This system call also implements a number of features unrelated to "
"namespaces.)"
msgstr ""

#. type: TP
#: build/C/man7/namespaces.7:123
#, no-wrap
msgid "B<ioctl>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:130
msgid ""
"Various B<ioctl>(2)  operations can be used to discover information about "
"namespaces.  These operations are described in B<ioctl_ns>(2)."
msgstr ""

#
#.  ==================== The /proc/[pid]/ns/ directory ====================
#. type: Plain text
#: build/C/man7/namespaces.7:146
msgid ""
"Creation of new namespaces using B<clone>(2)  and B<unshare>(2)  in most "
"cases requires the B<CAP_SYS_ADMIN> capability, since, in the new namespace, "
"the creator will have the power to change global resources that are visible "
"to other processes that are subsequently created in, or join the namespace.  "
"User namespaces are the exception: since Linux 3.8, no privilege is required "
"to create a user namespace."
msgstr ""

#. type: SS
#: build/C/man7/namespaces.7:146
#, no-wrap
msgid "The /proc/[pid]/ns/ directory"
msgstr ""

#.  See commit 6b4e306aa3dc94a0545eb9279475b1ab6209a31f
#. type: Plain text
#: build/C/man7/namespaces.7:153
msgid ""
"Each process has a I</proc/[pid]/ns/> subdirectory containing one entry for "
"each namespace that supports being manipulated by B<setns>(2):"
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:168
#, no-wrap
msgid ""
"$ B<ls -l /proc/$$/ns | awk \\(aq{print $1, $9, $10, $11}\\(aq>\n"
"total 0\n"
"lrwxrwxrwx. cgroup -E<gt> cgroup:[4026531835]\n"
"lrwxrwxrwx. ipc -E<gt> ipc:[4026531839]\n"
"lrwxrwxrwx. mnt -E<gt> mnt:[4026531840]\n"
"lrwxrwxrwx. net -E<gt> net:[4026531969]\n"
"lrwxrwxrwx. pid -E<gt> pid:[4026531836]\n"
"lrwxrwxrwx. pid_for_children -E<gt> pid:[4026531834]\n"
"lrwxrwxrwx. time -E<gt> time:[4026531834]\n"
"lrwxrwxrwx. time_for_children -E<gt> time:[4026531834]\n"
"lrwxrwxrwx. user -E<gt> user:[4026531837]\n"
"lrwxrwxrwx. uts -E<gt> uts:[4026531838]\n"
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:178
msgid ""
"Bind mounting (see B<mount>(2))  one of the files in this directory to "
"somewhere else in the filesystem keeps the corresponding namespace of the "
"process specified by I<pid> alive even if all processes currently in the "
"namespace terminate."
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:189
msgid ""
"Opening one of the files in this directory (or a file that is bind mounted "
"to one of these files)  returns a file handle for the corresponding "
"namespace of the process specified by I<pid>.  As long as this file "
"descriptor remains open, the namespace will remain alive, even if all "
"processes in the namespace terminate.  The file descriptor can be passed to "
"B<setns>(2)."
msgstr ""

#.  commit bf056bfa80596a5d14b26b17276a56a0dcb080e5
#.  Eric Biederman: "I reserve the right for st_dev to be significant
#.  when comparing namespaces."
#.  https://lore.kernel.org/lkml/87poky5ca9.fsf@xmission.com/
#.  Re: Documenting the ioctl interfaces to discover relationships...
#.  Date: Mon, 12 Dec 2016 11:30:38 +1300
#. type: Plain text
#: build/C/man7/namespaces.7:210
msgid ""
"In Linux 3.7 and earlier, these files were visible as hard links.  Since "
"Linux 3.8, they appear as symbolic links.  If two processes are in the same "
"namespace, then the device IDs and inode numbers of their "
"I</proc/[pid]/ns/xxx> symbolic links will be the same; an application can "
"check this using the I<stat.st_dev> and I<stat.st_ino> fields returned by "
"B<stat>(2).  The content of this symbolic link is a string containing the "
"namespace type and inode number as in the following example:"
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:215
#, no-wrap
msgid ""
"$ B<readlink /proc/$$/ns/uts>\n"
"uts:[4026531838]\n"
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:219
msgid "The symbolic links in this subdirectory are as follows:"
msgstr ""

#. type: TP
#: build/C/man7/namespaces.7:219
#, no-wrap
msgid "I</proc/[pid]/ns/cgroup> (since Linux 4.6)"
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:222
msgid "This file is a handle for the cgroup namespace of the process."
msgstr ""

#. type: TP
#: build/C/man7/namespaces.7:222
#, no-wrap
msgid "I</proc/[pid]/ns/ipc> (since Linux 3.0)"
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:225
msgid "This file is a handle for the IPC namespace of the process."
msgstr ""

#. type: TP
#: build/C/man7/namespaces.7:225
#, no-wrap
msgid "I</proc/[pid]/ns/mnt> (since Linux 3.8)"
msgstr ""

#.  commit 8823c079ba7136dc1948d6f6dcb5f8022bde438e
#. type: Plain text
#: build/C/man7/namespaces.7:229
msgid "This file is a handle for the mount namespace of the process."
msgstr ""

#. type: TP
#: build/C/man7/namespaces.7:229
#, no-wrap
msgid "I</proc/[pid]/ns/net> (since Linux 3.0)"
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:232
msgid "This file is a handle for the network namespace of the process."
msgstr ""

#. type: TP
#: build/C/man7/namespaces.7:232
#, no-wrap
msgid "I</proc/[pid]/ns/pid> (since Linux 3.8)"
msgstr ""

#.  commit 57e8391d327609cbf12d843259c968b9e5c1838f
#. type: Plain text
#: build/C/man7/namespaces.7:238
msgid ""
"This file is a handle for the PID namespace of the process.  This handle is "
"permanent for the lifetime of the process (i.e., a process's PID namespace "
"membership never changes)."
msgstr ""

#. type: TP
#: build/C/man7/namespaces.7:238
#, no-wrap
msgid "I</proc/[pid]/ns/pid_for_children> (since Linux 4.12)"
msgstr ""

#.  commit eaa0d190bfe1ed891b814a52712dcd852554cb08
#. type: Plain text
#: build/C/man7/namespaces.7:256
msgid ""
"This file is a handle for the PID namespace of child processes created by "
"this process.  This can change as a consequence of calls to B<unshare>(2)  "
"and B<setns>(2)  (see B<pid_namespaces>(7)), so the file may differ from "
"I</proc/[pid]/ns/pid>.  The symbolic link gains a value only after the first "
"child process is created in the namespace.  (Beforehand, B<readlink>(2)  of "
"the symbolic link will return an empty buffer.)"
msgstr ""

#. type: TP
#: build/C/man7/namespaces.7:256
#, no-wrap
msgid "I</proc/[pid]/ns/time> (since Linux 5.6)"
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:259
msgid "This file is a handle for the time namespace of the process."
msgstr ""

#. type: TP
#: build/C/man7/namespaces.7:259
#, no-wrap
msgid "I</proc/[pid]/ns/time_for_children> (since Linux 5.6)"
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:271
msgid ""
"This file is a handle for the time namespace of child processes created by "
"this process.  This can change as a consequence of calls to B<unshare>(2)  "
"and B<setns>(2)  (see B<time_namespaces>(7)), so the file may differ from "
"I</proc/[pid]/ns/time>."
msgstr ""

#. type: TP
#: build/C/man7/namespaces.7:271
#, no-wrap
msgid "I</proc/[pid]/ns/user> (since Linux 3.8)"
msgstr ""

#.  commit cde1975bc242f3e1072bde623ef378e547b73f91
#. type: Plain text
#: build/C/man7/namespaces.7:275
msgid "This file is a handle for the user namespace of the process."
msgstr ""

#. type: TP
#: build/C/man7/namespaces.7:275
#, no-wrap
msgid "I</proc/[pid]/ns/uts> (since Linux 3.0)"
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:278
msgid "This file is a handle for the UTS namespace of the process."
msgstr ""

#
#.  ==================== The /proc/sys/user directory ====================
#. type: Plain text
#: build/C/man7/namespaces.7:288
msgid ""
"Permission to dereference or read (B<readlink>(2))  these symbolic links is "
"governed by a ptrace access mode B<PTRACE_MODE_READ_FSCREDS> check; see "
"B<ptrace>(2)."
msgstr ""

#. type: SS
#: build/C/man7/namespaces.7:288
#, no-wrap
msgid "The /proc/sys/user directory"
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:294
msgid ""
"The files in the I</proc/sys/user> directory (which is present since Linux "
"4.9) expose limits on the number of namespaces of various types that can be "
"created.  The files are as follows:"
msgstr ""

#. type: TP
#: build/C/man7/namespaces.7:294
#, no-wrap
msgid "I<max_cgroup_namespaces>"
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:298
msgid ""
"The value in this file defines a per-user limit on the number of cgroup "
"namespaces that may be created in the user namespace."
msgstr ""

#. type: TP
#: build/C/man7/namespaces.7:298
#, no-wrap
msgid "I<max_ipc_namespaces>"
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:302
msgid ""
"The value in this file defines a per-user limit on the number of ipc "
"namespaces that may be created in the user namespace."
msgstr ""

#. type: TP
#: build/C/man7/namespaces.7:302
#, no-wrap
msgid "I<max_mnt_namespaces>"
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:306
msgid ""
"The value in this file defines a per-user limit on the number of mount "
"namespaces that may be created in the user namespace."
msgstr ""

#. type: TP
#: build/C/man7/namespaces.7:306
#, no-wrap
msgid "I<max_net_namespaces>"
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:310
msgid ""
"The value in this file defines a per-user limit on the number of network "
"namespaces that may be created in the user namespace."
msgstr ""

#. type: TP
#: build/C/man7/namespaces.7:310
#, no-wrap
msgid "I<max_pid_namespaces>"
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:314
msgid ""
"The value in this file defines a per-user limit on the number of PID "
"namespaces that may be created in the user namespace."
msgstr ""

#. type: TP
#: build/C/man7/namespaces.7:314
#, no-wrap
msgid "I<max_time_namespaces> (since Linux 5.7)"
msgstr ""

#.  commit eeec26d5da8248ea4e240b8795bb4364213d3247
#. type: Plain text
#: build/C/man7/namespaces.7:319
msgid ""
"The value in this file defines a per-user limit on the number of time "
"namespaces that may be created in the user namespace."
msgstr ""

#. type: TP
#: build/C/man7/namespaces.7:319
#, no-wrap
msgid "I<max_user_namespaces>"
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:323
msgid ""
"The value in this file defines a per-user limit on the number of user "
"namespaces that may be created in the user namespace."
msgstr ""

#. type: TP
#: build/C/man7/namespaces.7:323
#, no-wrap
msgid "I<max_uts_namespaces>"
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:327
msgid ""
"The value in this file defines a per-user limit on the number of uts "
"namespaces that may be created in the user namespace."
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:329
msgid "Note the following details about these files:"
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:331
msgid "The values in these files are modifiable by privileged processes."
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:334
msgid ""
"The values exposed by these files are the limits for the user namespace in "
"which the opening process resides."
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:338
msgid ""
"The limits are per-user.  Each user in the same user namespace can create "
"namespaces up to the defined limit."
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:340
msgid "The limits apply to all users, including UID 0."
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:343
msgid ""
"These limits apply in addition to any other per-namespace limits (such as "
"those for PID and user namespaces) that may be enforced."
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:350
msgid ""
"Upon encountering these limits, B<clone>(2)  and B<unshare>(2)  fail with "
"the error B<ENOSPC>."
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:357
msgid ""
"For the initial user namespace, the default value in each of these files is "
"half the limit on the number of threads that may be created "
"(I</proc/sys/kernel/threads-max>).  In all descendant user namespaces, the "
"default value in each file is B<MAXINT>."
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:361
msgid ""
"When a namespace is created, the object is also accounted against ancestor "
"namespaces.  More precisely:"
msgstr ""

#. type: IP
#: build/C/man7/namespaces.7:362 build/C/man7/namespaces.7:364 build/C/man7/namespaces.7:370 build/C/man7/user_namespaces.7:587 build/C/man7/user_namespaces.7:596 build/C/man7/user_namespaces.7:604 build/C/man7/user_namespaces.7:607
#, no-wrap
msgid "+"
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:364
msgid "Each user namespace has a creator UID."
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:370
msgid ""
"When a namespace is created, it is accounted against the creator UIDs in "
"each of the ancestor user namespaces, and the kernel ensures that the "
"corresponding namespace limit for the creator UID in the ancestor namespace "
"is not exceeded."
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:374
msgid ""
"The aforementioned point ensures that creating a new user namespace cannot "
"be used as a means to escape the limits in force in the current user "
"namespace."
msgstr ""

#. type: SS
#: build/C/man7/namespaces.7:376
#, no-wrap
msgid "Namespace lifetime"
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:383
msgid ""
"Absent any other factors, a namespace is automatically torn down when the "
"last process in the namespace terminates or leaves the namespace.  However, "
"there are a number of other factors that may pin a namespace into existence "
"even though it has no member processes.  These factors include the "
"following:"
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:387
msgid ""
"An open file descriptor or a bind mount exists for the corresponding "
"I</proc/[pid]/ns/*> file."
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:390
msgid ""
"The namespace is hierarchical (i.e., a PID or user namespace), and has a "
"child namespace."
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:392
msgid "It is a user namespace that owns one or more nonuser namespaces."
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:397
msgid ""
"It is a PID namespace, and there is a process that refers to the namespace "
"via a I</proc/[pid]/ns/pid_for_children> symbolic link."
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:402
msgid ""
"It is a time namespace, and there is a process that refers to the namespace "
"via a I</proc/[pid]/ns/time_for_children> symbolic link."
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:408
msgid ""
"It is an IPC namespace, and a corresponding mount of an I<mqueue> filesystem "
"(see B<mq_overview>(7))  refers to this namespace."
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:412
msgid ""
"It is a PID namespace, and a corresponding mount of a B<proc>(5)  filesystem "
"refers to this namespace."
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:417
msgid "See B<clone>(2)  and B<user_namespaces>(7)."
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:438
msgid ""
"B<nsenter>(1), B<readlink>(1), B<unshare>(1), B<clone>(2), B<ioctl_ns>(2), "
"B<setns>(2), B<unshare>(2), B<proc>(5), B<capabilities>(7), "
"B<cgroup_namespaces>(7), B<cgroups>(7), B<credentials>(7), "
"B<ipc_namespaces>(7), B<network_namespaces>(7), B<pid_namespaces>(7), "
"B<user_namespaces>(7), B<uts_namespaces>(7), B<lsns>(8), "
"B<pam_namespace>(8), B<switch_root>(8)"
msgstr ""

#. type: TH
#: build/C/man7/network_namespaces.7:26
#, no-wrap
msgid "NETWORK_NAMESPACES"
msgstr ""

#. type: TH
#: build/C/man7/network_namespaces.7:26 build/C/man7/time_namespaces.7:26
#, no-wrap
msgid "2020-06-09"
msgstr ""

#. type: Plain text
#: build/C/man7/network_namespaces.7:29
msgid "network_namespaces - overview of Linux network namespaces"
msgstr ""

#. type: Plain text
#: build/C/man7/network_namespaces.7:44
msgid ""
"Network namespaces provide isolation of the system resources associated with "
"networking: network devices, IPv4 and IPv6 protocol stacks, IP routing "
"tables, firewall rules, the I</proc/net> directory (which is a symbolic link "
"to I</proc/PID/net>), the I</sys/class/net> directory, various files under "
"I</proc/sys/net>, port numbers (sockets), and so on.  In addition, network "
"namespaces isolate the UNIX domain abstract socket namespace (see "
"B<unix>(7))."
msgstr ""

#. type: Plain text
#: build/C/man7/network_namespaces.7:51
msgid ""
"A physical network device can live in exactly one network namespace.  When a "
"network namespace is freed (i.e., when the last process in the namespace "
"terminates), its physical network devices are moved back to the initial "
"network namespace (not to the parent of the process)."
msgstr ""

#. type: Plain text
#: build/C/man7/network_namespaces.7:61
msgid ""
"A virtual network (B<veth>(4))  device pair provides a pipe-like abstraction "
"that can be used to create tunnels between network namespaces, and can be "
"used to create a bridge to a physical network device in another namespace.  "
"When a namespace is freed, the B<veth>(4)  devices that it contains are "
"destroyed."
msgstr ""

#.  FIXME .SH EXAMPLES
#. type: Plain text
#: build/C/man7/network_namespaces.7:66
msgid ""
"Use of network namespaces requires a kernel that is configured with the "
"B<CONFIG_NET_NS> option."
msgstr ""

#. type: Plain text
#: build/C/man7/network_namespaces.7:82
msgid ""
"B<nsenter>(1), B<unshare>(1), B<clone>(2), B<veth>(4), B<proc>(5), "
"B<sysfs>(5), B<namespaces>(7), B<user_namespaces>(7), B<brctl>(8), B<ip>(8), "
"B<ip-address>(8), B<ip-link>(8), B<ip-netns>(8), B<iptables>(8), "
"B<ovs-vsctl>(8)"
msgstr ""

#. type: TH
#: build/C/man7/pid_namespaces.7:27
#, no-wrap
msgid "PID_NAMESPACES"
msgstr ""

#. type: Plain text
#: build/C/man7/pid_namespaces.7:30
msgid "pid_namespaces - overview of Linux PID namespaces"
msgstr ""

#. type: Plain text
#: build/C/man7/pid_namespaces.7:40
msgid ""
"PID namespaces isolate the process ID number space, meaning that processes "
"in different PID namespaces can have the same PID.  PID namespaces allow "
"containers to provide functionality such as suspending/resuming the set of "
"processes in the container and migrating the container to a new host while "
"the processes inside the container maintain the same PIDs."
msgstr ""

#. type: Plain text
#: build/C/man7/pid_namespaces.7:48
msgid ""
"PIDs in a new PID namespace start at 1, somewhat like a standalone system, "
"and calls to B<fork>(2), B<vfork>(2), or B<clone>(2)  will produce processes "
"with PIDs that are unique within the namespace."
msgstr ""

#
#.  ============================================================
#. type: Plain text
#: build/C/man7/pid_namespaces.7:55
msgid ""
"Use of PID namespaces requires a kernel that is configured with the "
"B<CONFIG_PID_NS> option."
msgstr ""

#. type: SS
#: build/C/man7/pid_namespaces.7:55
#, no-wrap
msgid "The namespace init process"
msgstr ""

#. type: Plain text
#: build/C/man7/pid_namespaces.7:70
msgid ""
"The first process created in a new namespace (i.e., the process created "
"using B<clone>(2)  with the B<CLONE_NEWPID> flag, or the first child created "
"by a process after a call to B<unshare>(2)  using the B<CLONE_NEWPID> flag) "
"has the PID 1, and is the \"init\" process for the namespace (see "
"B<init>(1)).  This process becomes the parent of any child processes that "
"are orphaned because a process that resides in this PID namespace terminated "
"(see below for further details)."
msgstr ""

#. type: Plain text
#: build/C/man7/pid_namespaces.7:97
msgid ""
"If the \"init\" process of a PID namespace terminates, the kernel terminates "
"all of the processes in the namespace via a B<SIGKILL> signal.  This "
"behavior reflects the fact that the \"init\" process is essential for the "
"correct operation of a PID namespace.  In this case, a subsequent B<fork>(2)  "
"into this PID namespace fail with the error B<ENOMEM>; it is not possible to "
"create a new process in a PID namespace whose \"init\" process has "
"terminated.  Such scenarios can occur when, for example, a process uses an "
"open file descriptor for a I</proc/[pid]/ns/pid> file corresponding to a "
"process that was in a namespace to B<setns>(2)  into that namespace after "
"the \"init\" process has terminated.  Another possible scenario can occur "
"after a call to B<unshare>(2): if the first child subsequently created by a "
"B<fork>(2)  terminates, then subsequent calls to B<fork>(2)  fail with "
"B<ENOMEM>."
msgstr ""

#. type: Plain text
#: build/C/man7/pid_namespaces.7:103
msgid ""
"Only signals for which the \"init\" process has established a signal handler "
"can be sent to the \"init\" process by other members of the PID namespace.  "
"This restriction applies even to privileged processes, and prevents other "
"members of the PID namespace from accidentally killing the \"init\" process."
msgstr ""

#. type: Plain text
#: build/C/man7/pid_namespaces.7:123
msgid ""
"Likewise, a process in an ancestor namespace can\\(emsubject to the usual "
"permission checks described in B<kill>(2)\\(emsend signals to the \"init\" "
"process of a child PID namespace only if the \"init\" process has "
"established a handler for that signal.  (Within the handler, the "
"I<siginfo_t> I<si_pid> field described in B<sigaction>(2)  will be zero.)  "
"B<SIGKILL> or B<SIGSTOP> are treated exceptionally: these signals are "
"forcibly delivered when sent from an ancestor PID namespace.  Neither of "
"these signals can be caught by the \"init\" process, and so will result in "
"the usual actions associated with those signals (respectively, terminating "
"and stopping the process)."
msgstr ""

#
#.  ============================================================
#. type: Plain text
#: build/C/man7/pid_namespaces.7:133
msgid ""
"Starting with Linux 3.4, the B<reboot>(2)  system call causes a signal to be "
"sent to the namespace \"init\" process.  See B<reboot>(2)  for more details."
msgstr ""

#. type: SS
#: build/C/man7/pid_namespaces.7:133
#, no-wrap
msgid "Nesting PID namespaces"
msgstr ""

#.  commit f2302505775fd13ba93f034206f1e2a587017929
#.  The kernel constant MAX_PID_NS_LEVEL
#. type: Plain text
#: build/C/man7/pid_namespaces.7:148
msgid ""
"PID namespaces can be nested: each PID namespace has a parent, except for "
"the initial (\"root\") PID namespace.  The parent of a PID namespace is the "
"PID namespace of the process that created the namespace using B<clone>(2)  "
"or B<unshare>(2).  PID namespaces thus form a tree, with all namespaces "
"ultimately tracing their ancestry to the root namespace.  Since Linux 3.7, "
"the kernel limits the maximum nesting depth for PID namespaces to 32."
msgstr ""

#. type: Plain text
#: build/C/man7/pid_namespaces.7:163
msgid ""
"A process is visible to other processes in its PID namespace, and to the "
"processes in each direct ancestor PID namespace going back to the root PID "
"namespace.  In this context, \"visible\" means that one process can be the "
"target of operations by another process using system calls that specify a "
"process ID.  Conversely, the processes in a child PID namespace can't see "
"processes in the parent and further removed ancestor namespaces.  More "
"succinctly: a process can see (e.g., send signals with B<kill>(2), set nice "
"values with B<setpriority>(2), etc.) only processes contained in its own PID "
"namespace and in descendants of that namespace."
msgstr ""

#. type: Plain text
#: build/C/man7/pid_namespaces.7:175
msgid ""
"A process has one process ID in each of the layers of the PID namespace "
"hierarchy in which is visible, and walking back though each direct ancestor "
"namespace through to the root PID namespace.  System calls that operate on "
"process IDs always operate using the process ID that is visible in the PID "
"namespace of the caller.  A call to B<getpid>(2)  always returns the PID "
"associated with the namespace in which the process was created."
msgstr ""

#. type: Plain text
#: build/C/man7/pid_namespaces.7:190
msgid ""
"Some processes in a PID namespace may have parents that are outside of the "
"namespace.  For example, the parent of the initial process in the namespace "
"(i.e., the B<init>(1)  process with PID 1) is necessarily in another "
"namespace.  Likewise, the direct children of a process that uses B<setns>(2)  "
"to cause its children to join a PID namespace are in a different PID "
"namespace from the caller of B<setns>(2).  Calls to B<getppid>(2)  for such "
"processes return 0."
msgstr ""

#. type: Plain text
#: build/C/man7/pid_namespaces.7:199
msgid ""
"While processes may freely descend into child PID namespaces (e.g., using "
"B<setns>(2)  with a PID namespace file descriptor), they may not move in the "
"other direction.  That is to say, processes may not enter any ancestor "
"namespaces (parent, grandparent, etc.).  Changing PID namespaces is a "
"one-way operation."
msgstr ""

#
#.  ============================================================
#. type: Plain text
#: build/C/man7/pid_namespaces.7:209
msgid ""
"The B<NS_GET_PARENT> B<ioctl>(2)  operation can be used to discover the "
"parental relationship between PID namespaces; see B<ioctl_ns>(2)."
msgstr ""

#. type: SS
#: build/C/man7/pid_namespaces.7:209
#, no-wrap
msgid "setns(2) and unshare(2) semantics"
msgstr ""

#. type: Plain text
#: build/C/man7/pid_namespaces.7:229
msgid ""
"Calls to B<setns>(2)  that specify a PID namespace file descriptor and calls "
"to B<unshare>(2)  with the B<CLONE_NEWPID> flag cause children subsequently "
"created by the caller to be placed in a different PID namespace from the "
"caller.  (Since Linux 4.12, that PID namespace is shown via the "
"I</proc/[pid]/ns/pid_for_children> file, as described in B<namespaces>(7).)  "
"These calls do not, however, change the PID namespace of the calling "
"process, because doing so would change the caller's idea of its own PID (as "
"reported by B<getpid>()), which would break many applications and libraries."
msgstr ""

#. type: Plain text
#: build/C/man7/pid_namespaces.7:237
msgid ""
"To put things another way: a process's PID namespace membership is "
"determined when the process is created and cannot be changed thereafter.  "
"Among other things, this means that the parental relationship between "
"processes mirrors the parental relationship between PID namespaces: the "
"parent of a process is either in the same namespace or resides in the "
"immediate parent PID namespace."
msgstr ""

#
#.  ============================================================
#. type: Plain text
#: build/C/man7/pid_namespaces.7:249
msgid ""
"A process may call B<unshare>(2)  with the B<CLONE_NEWPID> flag only once.  "
"After it has performed this operation, its I</proc/PID/ns/pid_for_children> "
"symbolic link will be empty until the first child is created in the "
"namespace."
msgstr ""

#. type: SS
#: build/C/man7/pid_namespaces.7:249
#, no-wrap
msgid "Adoption of orphaned children"
msgstr ""

#.  Furthermore, by definition, the parent of the "init" process
#.  of a PID namespace resides in the parent PID namespace.
#
#.  ============================================================
#. type: Plain text
#: build/C/man7/pid_namespaces.7:270
msgid ""
"When a child process becomes orphaned, it is reparented to the \"init\" "
"process in the PID namespace of its parent (unless one of the nearer "
"ancestors of the parent employed the B<prctl>(2)  B<PR_SET_CHILD_SUBREAPER> "
"command to mark itself as the reaper of orphaned descendant processes).  "
"Note that because of the B<setns>(2)  and B<unshare>(2)  semantics described "
"above, this may be the \"init\" process in the PID namespace that is the "
"I<parent> of the child's PID namespace, rather than the \"init\" process in "
"the child's own PID namespace."
msgstr ""

#. type: SS
#: build/C/man7/pid_namespaces.7:270
#, no-wrap
msgid "Compatibility of CLONE_NEWPID with other CLONE_* flags"
msgstr ""

#. type: Plain text
#: build/C/man7/pid_namespaces.7:291
msgid ""
"In current versions of Linux, B<CLONE_NEWPID> can't be combined with "
"B<CLONE_THREAD>.  Threads are required to be in the same PID namespace such "
"that the threads in a process can send signals to each other.  Similarly, it "
"must be possible to see all of the threads of a processes in the B<proc>(5)  "
"filesystem.  Additionally, if two threads were in different PID namespaces, "
"the process ID of the process sending a signal could not be meaningfully "
"encoded when a signal is sent (see the description of the I<siginfo_t> type "
"in B<sigaction>(2)).  Since this is computed when a signal is enqueued, a "
"signal queue shared by processes in multiple PID namespaces would defeat "
"that."
msgstr ""

#.  Note these restrictions were all introduced in
#.  8382fcac1b813ad0a4e68a838fc7ae93fa39eda0
#.  when CLONE_NEWPID|CLONE_VM was disallowed
#.  (restriction lifted in faf00da544045fdc1454f3b9e6d7f65c841de302)
#.  (restriction lifted in e79f525e99b04390ca4d2366309545a836c03bf1)
#
#.  ============================================================
#. type: Plain text
#: build/C/man7/pid_namespaces.7:311
msgid ""
"In earlier versions of Linux, B<CLONE_NEWPID> was additionally disallowed "
"(failing with the error B<EINVAL>)  in combination with B<CLONE_SIGHAND> "
"(before Linux 4.3) as well as B<CLONE_VM> (before Linux 3.12).  The changes "
"that lifted these restrictions have also been ported to earlier stable "
"kernels."
msgstr ""

#. type: SS
#: build/C/man7/pid_namespaces.7:311
#, no-wrap
msgid "/proc and PID namespaces"
msgstr ""

#. type: Plain text
#: build/C/man7/pid_namespaces.7:320
msgid ""
"A I</proc> filesystem shows (in the I</proc/[pid]> directories) only "
"processes visible in the PID namespace of the process that performed the "
"mount, even if the I</proc> filesystem is viewed from processes in other "
"namespaces."
msgstr ""

#. type: Plain text
#: build/C/man7/pid_namespaces.7:339
msgid ""
"After creating a new PID namespace, it is useful for the child to change its "
"root directory and mount a new procfs instance at I</proc> so that tools "
"such as B<ps>(1)  work correctly.  If a new mount namespace is "
"simultaneously created by including B<CLONE_NEWNS> in the I<flags> argument "
"of B<clone>(2)  or B<unshare>(2), then it isn't necessary to change the root "
"directory: a new procfs instance can be mounted directly over I</proc>."
msgstr ""

#. type: Plain text
#: build/C/man7/pid_namespaces.7:343
msgid "From a shell, the command to mount I</proc> is:"
msgstr ""

#. type: Plain text
#: build/C/man7/pid_namespaces.7:347
#, no-wrap
msgid "$ mount -t proc proc /proc\n"
msgstr ""

#
#.  ============================================================
#. type: Plain text
#: build/C/man7/pid_namespaces.7:361
msgid ""
"Calling B<readlink>(2)  on the path I</proc/self> yields the process ID of "
"the caller in the PID namespace of the procfs mount (i.e., the PID namespace "
"of the process that mounted the procfs).  This can be useful for "
"introspection purposes, when a process wants to discover its PID in other "
"namespaces."
msgstr ""

#. type: SS
#: build/C/man7/pid_namespaces.7:361
#, no-wrap
msgid "/proc files"
msgstr ""

#. type: TP
#: build/C/man7/pid_namespaces.7:362
#, no-wrap
msgid "B</proc/sys/kernel/ns_last_pid> (since Linux 3.3)"
msgstr ""

#.  commit b8f566b04d3cddd192cfd2418ae6d54ac6353792
#. type: Plain text
#: build/C/man7/pid_namespaces.7:372
msgid ""
"This file (which is virtualized per PID namespace)  displays the last PID "
"that was allocated in this PID namespace.  When the next PID is allocated, "
"the kernel will search for the lowest unallocated PID that is greater than "
"this value, and when this file is subsequently read it will show that PID."
msgstr ""

#.  This ability is necessary to support checkpoint restore in user-space
#
#.  ============================================================
#. type: Plain text
#: build/C/man7/pid_namespaces.7:384
msgid ""
"This file is writable by a process that has the B<CAP_SYS_ADMIN> or (since "
"Linux 5.9)  B<CAP_CHECKPOINT_RESTORE> capability inside the user namespace "
"that owns the PID namespace.  This makes it possible to determine the PID "
"that is allocated to the next process that is created inside this PID "
"namespace."
msgstr ""

#. type: SS
#: build/C/man7/pid_namespaces.7:384 build/C/man7/user_namespaces.7:942
#, no-wrap
msgid "Miscellaneous"
msgstr ""

#. type: Plain text
#: build/C/man7/pid_namespaces.7:392
msgid ""
"When a process ID is passed over a UNIX domain socket to a process in a "
"different PID namespace (see the description of B<SCM_CREDENTIALS> in "
"B<unix>(7)), it is translated into the corresponding PID value in the "
"receiving process's PID namespace."
msgstr ""

#. type: Plain text
#: build/C/man7/pid_namespaces.7:397
msgid "See B<user_namespaces>(7)."
msgstr ""

#. type: Plain text
#: build/C/man7/pid_namespaces.7:409
msgid ""
"B<clone>(2), B<reboot>(2), B<setns>(2), B<unshare>(2), B<proc>(5), "
"B<capabilities>(7), B<credentials>(7), B<mount_namespaces>(7), "
"B<namespaces>(7), B<user_namespaces>(7), B<switch_root>(8)"
msgstr ""

#. type: TH
#: build/C/man7/time_namespaces.7:26
#, no-wrap
msgid "TIME_NAMESPACES"
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:29
msgid "time_namespaces - overview of Linux time namespaces"
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:31
msgid "Time namespaces virtualize the values of two system clocks:"
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:39
msgid ""
"B<CLOCK_MONOTONIC> (and likewise B<CLOCK_MONOTONIC_COARSE> and "
"B<CLOCK_MONOTONIC_RAW>), a nonsettable clock that represents monotonic time "
"since\\(emas described by POSIX\\(em\"some unspecified point in the past\"."
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:46
msgid ""
"B<CLOCK_BOOTTIME> (and likewise B<CLOCK_BOOTTIME_ALARM>), a nonsettable "
"clock that is identical to B<CLOCK_MONOTONIC>, except that it also includes "
"any time that the system is suspended."
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:57
msgid ""
"Thus, the processes in a time namespace share per-namespace values for these "
"clocks.  This affects various APIs that measure against these clocks, "
"including: B<clock_gettime>(2), B<clock_nanosleep>(2), B<nanosleep>(2), "
"B<timer_settime>(2), B<timerfd_settime>(2), and I</proc/uptime>."
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:79
msgid ""
"Currently, the only way to create a time namespace is by calling "
"B<unshare>(2)  with the B<CLONE_NEWTIME> flag.  This call creates a new time "
"namespace but does I<not> place the calling process in the new namespace.  "
"Instead, the calling process's subsequently created children are placed in "
"the new namespace.  This allows clock offsets (see below) for the new "
"namespace to be set before the first process is placed in the namespace.  "
"The I</proc/[pid]/ns/time_for_children> symbolic link shows the time "
"namespace in which the children of a process will be created.  (A process "
"can use a file descriptor opened on this symbolic link in a call to "
"B<setns>(2)  in order to move into the namespace.)"
msgstr ""

#. type: SS
#: build/C/man7/time_namespaces.7:79
#, no-wrap
msgid "/proc/PID/timens_offsets"
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:89
msgid ""
"Associated with each time namespace are offsets, expressed with respect to "
"the initial time namespace, that define the values of the monotonic and "
"boot-time clocks in that namespace.  These offsets are exposed via the file "
"I</proc/PID/timens_offsets>.  Within this file, the offsets are expressed as "
"lines consisting of three space-delimited fields:"
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:93
#, no-wrap
msgid "E<lt>clock-idE<gt> E<lt>offset-secsE<gt> E<lt>offset-nanosecsE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:116
msgid ""
"The I<clock-id> is a string that identifies the clock whose offsets are "
"being shown.  This field is either I<monotonic>, for B<CLOCK_MONOTONIC>, or "
"I<boottime>, for B<CLOCK_BOOTTIME>.  The remaining fields express the offset "
"(seconds plus nanoseconds) for the clock in this time namespace.  These "
"offsets are expressed relative to the clock values in the initial time "
"namespace.  The I<offset-secs> value can be negative, subject to "
"restrictions noted below; I<offset-nanosecs> is an unsigned value."
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:120
msgid ""
"In the initial time namespace, the contents of the I<timens_offsets> file "
"are as follows:"
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:126
#, no-wrap
msgid ""
"$ B<cat /proc/self/timens_offsets>\n"
"monotonic           0         0\n"
"boottime            0         0\n"
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:144
msgid ""
"In a new time namespace that has had no member processes, the clock offsets "
"can be modified by writing newline-terminated records of the same form to "
"the I<timens_offsets> file.  The file can be written to multiple times, but "
"after the first process has been created in or has entered the namespace, "
"B<write>(2)s on this file fail with the error B<EACCES>.  In order to write "
"to the I<timens_offsets> file, a process must have the B<CAP_SYS_TIME> "
"capability in the user namespace that owns the time namespace."
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:148
msgid "Writes to the I<timens_offsets> file can fail with the following errors:"
msgstr ""

#. type: TP
#: build/C/man7/time_namespaces.7:148 build/C/man7/time_namespaces.7:153
#, no-wrap
msgid "B<EINVAL>"
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:153
msgid "An I<offset-nanosecs> value is greater than 999,999,999."
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:158
msgid "A I<clock-id> value is not valid."
msgstr ""

#. type: TP
#: build/C/man7/time_namespaces.7:158
#, no-wrap
msgid "B<EPERM>"
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:163
msgid "The caller does not have the B<CAP_SYS_TIME> capability."
msgstr ""

#. type: TP
#: build/C/man7/time_namespaces.7:163
#, no-wrap
msgid "B<ERANGE>"
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:169
msgid "An I<offset-secs> value is out of range.  In particular;"
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:174
msgid ""
"I<offset-secs> can't be set to a value which would make the current time on "
"the corresponding clock inside the namespace a negative value; and"
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:180
msgid ""
"I<offset-secs> can't be set to a value such that the time on the "
"corresponding clock inside the namespace would exceed half of the value of "
"the kernel constant B<KTIME_SEC_MAX> (this limits the clock value to a "
"maximum of approximately 146 years)."
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:187
msgid ""
"In a new time namespace created by B<unshare>(2), the contents of the "
"I<timens_offsets> file are inherited from the time namespace of the creating "
"process."
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:192
msgid ""
"Use of time namespaces requires a kernel that is configured with the "
"B<CONFIG_TIME_NS> option."
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:198
msgid ""
"Note that time namespaces do not virtualize the B<CLOCK_REALTIME> clock.  "
"Virtualization of this clock was avoided for reasons of complexity and "
"overhead within the kernel."
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:209
msgid ""
"For compatibility with the initial implementation, when writing a "
"I<clock-id> to the I</proc/[pid]/timens_offsets> file, the numerical values "
"of the IDs can be written instead of the symbolic names show above; i.e., 1 "
"instead of I<monotonic>, and 7 instead of I<boottime>.  For redability, the "
"use of the symbolic names over the numbers is preferred."
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:213
msgid ""
"The motivation for adding time namespaces was to allow the monotonic and "
"boot-time clocks to maintain consistent values during container migration "
"and checkpoint/restore."
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:218
msgid ""
"The following shell session demonstrates the operation of time namespaces.  "
"We begin by displaying the inode number of the time namespace of a shell in "
"the initial time namespace:"
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:223
#, no-wrap
msgid ""
"$ B<readlink /proc/$$/ns/time>\n"
"time:[4026531834]\n"
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:233
msgid ""
"Continuing in the initial time namespace, we display the system uptime using "
"B<uptime>(1)  and use the I<clock_times> example program shown in "
"B<clock_getres>(2)  to display the values of various clocks:"
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:243
#, no-wrap
msgid ""
"$ B<uptime --pretty>\n"
"up 21 hours, 17 minutes\n"
"$ B<./clock_times>\n"
"CLOCK_REALTIME : 1585989401.971 (18356 days +  8h 36m 41s)\n"
"CLOCK_TAI      : 1585989438.972 (18356 days +  8h 37m 18s)\n"
"CLOCK_MONOTONIC:      56338.247 (15h 38m 58s)\n"
"CLOCK_BOOTTIME :      76633.544 (21h 17m 13s)\n"
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:261
msgid ""
"We then use B<unshare>(1)  to create a time namespace and execute a "
"B<bash>(1)  shell.  From the new shell, we use the built-in B<echo> command "
"to write records to the I<timens_offsets> file adjusting the offset for the "
"B<CLOCK_MONOTONIC> clock forward 2 days and the offset for the "
"B<CLOCK_BOOTTIME> clock forward 7 days:"
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:267
#, no-wrap
msgid ""
"$ B<PS1=\"ns2# \" sudo unshare -T -- bash --norc>\n"
"ns2# B<echo \"monotonic $((2*24*60*60)) 0\" E<gt> /proc/$$/timens_offsets>\n"
"ns2# B<echo \"boottime  $((7*24*60*60)) 0\" E<gt> /proc/$$/timens_offsets>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:279
msgid ""
"Above, we started the B<bash>(1)  shell with the B<--norc> options so that "
"no start-up scripts were executed.  This ensures that no child processes are "
"created from the shell before we have a chance to update the "
"I<timens_offsets> file."
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:291
msgid ""
"We then use B<cat>(1)  to display the contents of the I<timens_offsets> "
"file.  The execution of B<cat>(1)  creates the first process in the new time "
"namespace, after which further attempts to update the I<timens_offsets> file "
"produce an error."
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:299
#, no-wrap
msgid ""
"ns2# B<cat /proc/$$/timens_offsets>\n"
"monotonic      172800         0\n"
"boottime       604800         0\n"
"ns2# B<echo \"boottime $((9*24*60*60)) 0\" E<gt> /proc/$$/timens_offsets>\n"
"bash: echo: write error: Permission denied\n"
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:307
msgid ""
"Continuing in the new namespace, we execute B<uptime>(1)  and the "
"I<clock_times> example program:"
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:317
#, no-wrap
msgid ""
"ns2# B<uptime --pretty>\n"
"up 1 week, 21 hours, 18 minutes\n"
"ns2# B<./clock_times>\n"
"CLOCK_REALTIME : 1585989457.056 (18356 days +  8h 37m 37s)\n"
"CLOCK_TAI      : 1585989494.057 (18356 days +  8h 38m 14s)\n"
"CLOCK_MONOTONIC:     229193.332 (2 days + 15h 39m 53s)\n"
"CLOCK_BOOTTIME :     681488.629 (7 days + 21h 18m  8s)\n"
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:322
msgid ""
"From the above output, we can see that the monotonic and boot-time clocks "
"have different values in the new time namespace."
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:329
msgid ""
"Examining the I</proc/[pid]/ns/time> and I</proc/[pid]/ns/time_for_children> "
"symbolic links, we see that the shell is a member of the initial time "
"namespace, but its children are created in the new namespace."
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:339
#, no-wrap
msgid ""
"ns2# B<readlink /proc/$$/ns/time>\n"
"time:[4026531834]\n"
"ns2# B<readlink /proc/$$/ns/time_for_children>\n"
"time:[4026532900]\n"
"ns2# B<readlink /proc/self/ns/time>   # Creates a child process\n"
"time:[4026532900]\n"
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:347
msgid ""
"Returning to the shell in the initial time namespace, we see that the "
"monotonic and boot-time clocks are unaffected by the I<timens_offsets> "
"changes that were made in the other time namespace:"
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:357
#, no-wrap
msgid ""
"$ B<uptime --pretty>\n"
"up 21 hours, 19 minutes\n"
"$ B<./clock_times>\n"
"CLOCK_REALTIME : 1585989401.971 (18356 days +  8h 38m 51s)\n"
"CLOCK_TAI      : 1585989438.972 (18356 days +  8h 39m 28s)\n"
"CLOCK_MONOTONIC:      56338.247 (15h 41m  8s)\n"
"CLOCK_BOOTTIME :      76633.544 (21h 19m 23s)\n"
msgstr ""

#.  clone3() support for time namespaces is a work in progress
#.  .BR clone3 (2),
#. type: Plain text
#: build/C/man7/time_namespaces.7:369
msgid ""
"B<nsenter>(1), B<unshare>(1), B<clock_settime>(2), B<setns>(2), "
"B<unshare>(2), B<namespaces>(7), B<time>(7)"
msgstr ""

#. type: TH
#: build/C/man7/user_namespaces.7:27
#, no-wrap
msgid "USER_NAMESPACES"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:30
msgid "user_namespaces - overview of Linux user namespaces"
msgstr ""

#.  FIXME: This page says very little about the interaction
#.  of user namespaces and keys. Add something on this topic.
#
#.  ============================================================
#. type: Plain text
#: build/C/man7/user_namespaces.7:56
msgid ""
"User namespaces isolate security-related identifiers and attributes, in "
"particular, user IDs and group IDs (see B<credentials>(7)), the root "
"directory, keys (see B<keyrings>(7)), and capabilities (see "
"B<capabilities>(7)).  A process's user and group IDs can be different inside "
"and outside a user namespace.  In particular, a process can have a normal "
"unprivileged user ID outside a user namespace while at the same time having "
"a user ID of 0 inside the namespace; in other words, the process has full "
"privileges for operations inside the user namespace, but is unprivileged for "
"operations outside the namespace."
msgstr ""

#. type: SS
#: build/C/man7/user_namespaces.7:56
#, no-wrap
msgid "Nested namespaces, namespace membership"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:69
msgid ""
"User namespaces can be nested; that is, each user namespace\\(emexcept the "
"initial (\"root\")  namespace\\(emhas a parent user namespace, and can have "
"zero or more child user namespaces.  The parent user namespace is the user "
"namespace of the process that creates the user namespace via a call to "
"B<unshare>(2)  or B<clone>(2)  with the B<CLONE_NEWUSER> flag."
msgstr ""

#.  commit 8742f229b635bf1c1c84a3dfe5e47c814c20b5c8
#.  FIXME Explain the rationale for this limit. (What is the rationale?)
#. type: Plain text
#: build/C/man7/user_namespaces.7:80
msgid ""
"The kernel imposes (since version 3.11) a limit of 32 nested levels of user "
"namespaces.  Calls to B<unshare>(2)  or B<clone>(2)  that would cause this "
"limit to be exceeded fail with the error B<EUSERS>."
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:95
msgid ""
"Each process is a member of exactly one user namespace.  A process created "
"via B<fork>(2)  or B<clone>(2)  without the B<CLONE_NEWUSER> flag is a "
"member of the same user namespace as its parent.  A single-threaded process "
"can join another user namespace with B<setns>(2)  if it has the "
"B<CAP_SYS_ADMIN> in that namespace; upon doing so, it gains a full set of "
"capabilities in that namespace."
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:107
msgid ""
"A call to B<clone>(2)  or B<unshare>(2)  with the B<CLONE_NEWUSER> flag "
"makes the new child process (for B<clone>(2))  or the caller (for "
"B<unshare>(2))  a member of the new user namespace created by the call."
msgstr ""

#
#.  ============================================================
#. type: Plain text
#: build/C/man7/user_namespaces.7:117
msgid ""
"The B<NS_GET_PARENT> B<ioctl>(2)  operation can be used to discover the "
"parental relationship between user namespaces; see B<ioctl_ns>(2)."
msgstr ""

#. type: SS
#: build/C/man7/user_namespaces.7:117
#, no-wrap
msgid "Capabilities"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:139
msgid ""
"The child process created by B<clone>(2)  with the B<CLONE_NEWUSER> flag "
"starts out with a complete set of capabilities in the new user namespace.  "
"Likewise, a process that creates a new user namespace using B<unshare>(2)  "
"or joins an existing user namespace using B<setns>(2)  gains a full set of "
"capabilities in that namespace.  On the other hand, that process has no "
"capabilities in the parent (in the case of B<clone>(2))  or previous (in the "
"case of B<unshare>(2)  and B<setns>(2))  user namespace, even if the new "
"namespace is created or joined by the root user (i.e., a process with user "
"ID 0 in the root namespace)."
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:149
msgid ""
"Note that a call to B<execve>(2)  will cause a process's capabilities to be "
"recalculated in the usual way (see B<capabilities>(7)).  Consequently, "
"unless the process has a user ID of 0 within the namespace, or the "
"executable file has a nonempty inheritable capabilities mask, the process "
"will lose all capabilities.  See the discussion of user and group ID "
"mappings, below."
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:177
msgid ""
"A call to B<clone>(2)  or B<unshare>(2)  using the B<CLONE_NEWUSER> flag or "
"a call to B<setns>(2)  that moves the caller into another user namespace "
"sets the \"securebits\" flags (see B<capabilities>(7))  to their default "
"values (all flags disabled) in the child (for B<clone>(2))  or caller (for "
"B<unshare>(2)  or B<setns>(2)).  Note that because the caller no longer has "
"capabilities in its original user namespace after a call to B<setns>(2), it "
"is not possible for a process to reset its \"securebits\" flags while "
"retaining its user namespace membership by using a pair of B<setns>(2)  "
"calls to move to another user namespace and then return to its original user "
"namespace."
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:180
msgid ""
"The rules for determining whether or not a process has a capability in a "
"particular user namespace are as follows:"
msgstr ""

#. type: IP
#: build/C/man7/user_namespaces.7:180 build/C/man7/user_namespaces.7:561
#, no-wrap
msgid "1."
msgstr ""

#.  In the 3.8 sources, see security/commoncap.c::cap_capable():
#. type: Plain text
#: build/C/man7/user_namespaces.7:196
msgid ""
"A process has a capability inside a user namespace if it is a member of that "
"namespace and it has the capability in its effective capability set.  A "
"process can gain capabilities in its effective capability set in various "
"ways.  For example, it may execute a set-user-ID program or an executable "
"with associated file capabilities.  In addition, a process may gain "
"capabilities via the effect of B<clone>(2), B<unshare>(2), or B<setns>(2), "
"as already described."
msgstr ""

#. type: IP
#: build/C/man7/user_namespaces.7:196 build/C/man7/user_namespaces.7:567
#, no-wrap
msgid "2."
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:200
msgid ""
"If a process has a capability in a user namespace, then it has that "
"capability in all child (and further removed descendant)  namespaces as "
"well."
msgstr ""

#. type: IP
#: build/C/man7/user_namespaces.7:200 build/C/man7/user_namespaces.7:572
#, no-wrap
msgid "3."
msgstr ""

#.  * The owner of the user namespace in the parent of the
#.  * user namespace has all caps.
#.  (and likewise associates the effective group ID of the creating process
#.  with the namespace).
#.  See kernel commit 520d9eabce18edfef76a60b7b839d54facafe1f9 for a fix
#.  on this point
#.      This includes the case where the process executes a set-user-ID
#.      program that confers the effective UID of the creator of the namespace.
#
#.  ============================================================
#. type: Plain text
#: build/C/man7/user_namespaces.7:227
msgid ""
"When a user namespace is created, the kernel records the effective user ID "
"of the creating process as being the \"owner\" of the namespace.  A process "
"that resides in the parent of the user namespace and whose effective user ID "
"matches the owner of the namespace has all capabilities in the namespace.  "
"By virtue of the previous rule, this means that the process has all "
"capabilities in all further removed descendant user namespaces as well.  The "
"B<NS_GET_OWNER_UID> B<ioctl>(2)  operation can be used to discover the user "
"ID of the owner of the namespace; see B<ioctl_ns>(2)."
msgstr ""

#. type: SS
#: build/C/man7/user_namespaces.7:227
#, no-wrap
msgid "Effect of capabilities within a user namespace"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:235
msgid ""
"Having a capability inside a user namespace permits a process to perform "
"operations (that require privilege)  only on resources governed by that "
"namespace.  In other words, having a capability in a user namespace permits "
"a process to perform privileged operations on resources that are governed by "
"(nonuser)  namespaces owned by (associated with) the user namespace (see the "
"next subsection)."
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:247
msgid ""
"On the other hand, there are many privileged operations that affect "
"resources that are not associated with any namespace type, for example, "
"changing the system (i.e., calendar) time (governed by B<CAP_SYS_TIME>), "
"loading a kernel module (governed by B<CAP_SYS_MODULE>), and creating a "
"device (governed by B<CAP_MKNOD>).  Only a process with privileges in the "
"I<initial> user namespace can perform such operations."
msgstr ""

#.  fs_flags = FS_USERNS_MOUNT in kernel sources
#. type: Plain text
#: build/C/man7/user_namespaces.7:254
msgid ""
"Holding B<CAP_SYS_ADMIN> within the user namespace that owns a process's "
"mount namespace allows that process to create bind mounts and mount the "
"following types of filesystems:"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:260
msgid "I</proc> (since Linux 3.8)"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:263
msgid "I</sys> (since Linux 3.8)"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:266
msgid "I<devpts> (since Linux 3.9)"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:269
msgid "B<tmpfs>(5)  (since Linux 3.9)"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:272
msgid "I<ramfs> (since Linux 3.9)"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:275
msgid "I<mqueue> (since Linux 3.9)"
msgstr ""

#.  commit b2197755b2633e164a439682fb05a9b5ea48f706
#. type: Plain text
#: build/C/man7/user_namespaces.7:279
msgid "I<bpf> (since Linux 4.4)"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:291
msgid ""
"Holding B<CAP_SYS_ADMIN> within the user namespace that owns a process's "
"cgroup namespace allows (since Linux 4.6)  that process to the mount the "
"cgroup version 2 filesystem and cgroup version 1 named hierarchies (i.e., "
"cgroup filesystems mounted with the I<\"none,name=\"> option)."
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:299
msgid ""
"Holding B<CAP_SYS_ADMIN> within the user namespace that owns a process's PID "
"namespace allows (since Linux 3.8)  that process to mount I</proc> "
"filesystems."
msgstr ""

#
#.  ============================================================
#. type: Plain text
#: build/C/man7/user_namespaces.7:307
msgid ""
"Note however, that mounting block-based filesystems can be done only by a "
"process that holds B<CAP_SYS_ADMIN> in the initial user namespace."
msgstr ""

#. type: SS
#: build/C/man7/user_namespaces.7:307
#, no-wrap
msgid "Interaction of user namespaces and other types of namespaces"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:312
msgid ""
"Starting in Linux 3.8, unprivileged processes can create user namespaces, "
"and the other types of namespaces can be created with just the "
"B<CAP_SYS_ADMIN> capability in the caller's user namespace."
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:319
msgid ""
"When a nonuser namespace is created, it is owned by the user namespace in "
"which the creating process was a member at the time of the creation of the "
"namespace.  Privileged operations on resources governed by the nonuser "
"namespace require that the process has the necessary capabilities in the "
"user namespace that owns the nonuser namespace."
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:336
msgid ""
"If B<CLONE_NEWUSER> is specified along with other B<CLONE_NEW*> flags in a "
"single B<clone>(2)  or B<unshare>(2)  call, the user namespace is guaranteed "
"to be created first, giving the child (B<clone>(2))  or caller "
"(B<unshare>(2))  privileges over the remaining namespaces created by the "
"call.  Thus, it is possible for an unprivileged caller to specify this "
"combination of flags."
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:358
msgid ""
"When a new namespace (other than a user namespace) is created via "
"B<clone>(2)  or B<unshare>(2), the kernel records the user namespace of the "
"creating process as the owner of the new namespace.  (This association can't "
"be changed.)  When a process in the new namespace subsequently performs "
"privileged operations that operate on global resources isolated by the "
"namespace, the permission checks are performed according to the process's "
"capabilities in the user namespace that the kernel associated with the new "
"namespace.  For example, suppose that a process attempts to change the "
"hostname (B<sethostname>(2)), a resource governed by the UTS namespace.  In "
"this case, the kernel will determine which user namespace owns the process's "
"UTS namespace, and check whether the process has the required capability "
"(B<CAP_SYS_ADMIN>)  in that user namespace."
msgstr ""

#
#.  ============================================================
#. type: Plain text
#: build/C/man7/user_namespaces.7:368
msgid ""
"The B<NS_GET_USERNS> B<ioctl>(2)  operation can be used to discover the user "
"namespace that owns a nonuser namespace; see B<ioctl_ns>(2)."
msgstr ""

#. type: SS
#: build/C/man7/user_namespaces.7:368
#, no-wrap
msgid "User and group ID mappings: uid_map and gid_map"
msgstr ""

#.  commit 22d917d80e842829d0ca0a561967d728eb1d6303
#. type: Plain text
#: build/C/man7/user_namespaces.7:383
msgid ""
"When a user namespace is created, it starts out without a mapping of user "
"IDs (group IDs)  to the parent user namespace.  The I</proc/[pid]/uid_map> "
"and I</proc/[pid]/gid_map> files (available since Linux 3.5)  expose the "
"mappings for user and group IDs inside the user namespace for the process "
"I<pid>.  These files can be read to view the mappings in a user namespace "
"and written to (once) to define the mappings."
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:389
msgid ""
"The description in the following paragraphs explains the details for "
"I<uid_map>; I<gid_map> is exactly the same, but each instance of \"user ID\" "
"is replaced by \"group ID\"."
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:403
msgid ""
"The I<uid_map> file exposes the mapping of user IDs from the user namespace "
"of the process I<pid> to the user namespace of the process that opened "
"I<uid_map> (but see a qualification to this point below).  In other words, "
"processes that are in different user namespaces will potentially see "
"different values when reading from a particular I<uid_map> file, depending "
"on the user ID mappings for the user namespaces of the reading processes."
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:415
msgid ""
"Each line in the I<uid_map> file specifies a 1-to-1 mapping of a range of "
"contiguous user IDs between two user namespaces.  (When a user namespace is "
"first created, this file is empty.)  The specification in each line takes "
"the form of three numbers delimited by white space.  The first two numbers "
"specify the starting user ID in each of the two user namespaces.  The third "
"number specifies the length of the mapped range.  In detail, the fields are "
"interpreted as follows:"
msgstr ""

#. type: IP
#: build/C/man7/user_namespaces.7:415
#, no-wrap
msgid "(1)"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:419
msgid ""
"The start of the range of user IDs in the user namespace of the process "
"I<pid>."
msgstr ""

#. type: IP
#: build/C/man7/user_namespaces.7:419
#, no-wrap
msgid "(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:427
msgid ""
"The start of the range of user IDs to which the user IDs specified by field "
"one map.  How field two is interpreted depends on whether the process that "
"opened I<uid_map> and the process I<pid> are in the same user namespace, as "
"follows:"
msgstr ""

#. type: IP
#: build/C/man7/user_namespaces.7:428
#, no-wrap
msgid "a)"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:433
msgid ""
"If the two processes are in different user namespaces: field two is the "
"start of a range of user IDs in the user namespace of the process that "
"opened I<uid_map>."
msgstr ""

#. type: IP
#: build/C/man7/user_namespaces.7:433
#, no-wrap
msgid "b)"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:444
msgid ""
"If the two processes are in the same user namespace: field two is the start "
"of the range of user IDs in the parent user namespace of the process "
"I<pid>.  This case enables the opener of I<uid_map> (the common case here is "
"opening I</proc/self/uid_map>)  to see the mapping of user IDs into the user "
"namespace of the process that created this user namespace."
msgstr ""

#. type: IP
#: build/C/man7/user_namespaces.7:445
#, no-wrap
msgid "(3)"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:448
msgid ""
"The length of the range of user IDs that is mapped between the two user "
"namespaces."
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:455
msgid ""
"System calls that return user IDs (group IDs)\\(emfor example, B<getuid>(2), "
"B<getgid>(2), and the credential fields in the structure returned by "
"B<stat>(2)\\(emreturn the user ID (group ID) mapped into the caller's user "
"namespace."
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:463
msgid ""
"When a process accesses a file, its user and group IDs are mapped into the "
"initial user namespace for the purpose of permission checking and assigning "
"IDs when creating a file.  When a process retrieves file user and group IDs "
"via B<stat>(2), the IDs are mapped in the opposite direction, to produce "
"values relative to the process user and group ID mappings."
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:472
msgid ""
"The initial user namespace has no parent namespace, but, for consistency, "
"the kernel provides dummy user and group ID mapping files for this "
"namespace.  Looking at the I<uid_map> file (I<gid_map> is the same) from a "
"shell in the initial namespace shows:"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:477
#, no-wrap
msgid ""
"$ B<cat /proc/$$/uid_map>\n"
"         0          0 4294967295\n"
msgstr ""

#
#.  ============================================================
#. type: Plain text
#: build/C/man7/user_namespaces.7:497
msgid ""
"This mapping tells us that the range starting at user ID 0 in this namespace "
"maps to a range starting at 0 in the (nonexistent) parent namespace, and the "
"length of the range is the largest 32-bit unsigned integer.  This leaves "
"4294967295 (the 32-bit signed -1 value) unmapped.  This is deliberate: "
"I<(uid_t)\\ -1> is used in several interfaces (e.g., B<setreuid>(2))  as a "
"way to specify \"no user ID\".  Leaving I<(uid_t)\\ -1> unmapped and "
"unusable guarantees that there will be no confusion when using these "
"interfaces."
msgstr ""

#. type: SS
#: build/C/man7/user_namespaces.7:497
#, no-wrap
msgid "Defining user and group ID mappings: writing to uid_map and gid_map"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:513
msgid ""
"After the creation of a new user namespace, the I<uid_map> file of I<one> of "
"the processes in the namespace may be written to I<once> to define the "
"mapping of user IDs in the new user namespace.  An attempt to write more "
"than once to a I<uid_map> file in a user namespace fails with the error "
"B<EPERM>.  Similar rules apply for I<gid_map> files."
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:518
msgid ""
"The lines written to I<uid_map> (I<gid_map>)  must conform to the following "
"rules:"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:521
msgid ""
"The three fields must be valid numbers, and the last field must be greater "
"than 0."
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:523
msgid "Lines are terminated by newline characters."
msgstr ""

#.  5*12-byte records could fit in a 64B cache line
#.  commit 6397fac4915ab3002dc15aae751455da1a852f25
#. type: Plain text
#: build/C/man7/user_namespaces.7:538
msgid ""
"There is a limit on the number of lines in the file.  In Linux 4.14 and "
"earlier, this limit was (arbitrarily)  set at 5 lines.  Since Linux 4.15, "
"the limit is 340 lines.  In addition, the number of bytes written to the "
"file must be less than the system page size, and the write must be performed "
"at the start of the file (i.e., B<lseek>(2)  and B<pwrite>(2)  can't be used "
"to write to nonzero offsets in the file)."
msgstr ""

#.  commit 0bd14b4fd72afd5df41e9fd59f356740f22fceba
#. type: Plain text
#: build/C/man7/user_namespaces.7:551
msgid ""
"The range of user IDs (group IDs)  specified in each line cannot overlap "
"with the ranges in any other lines.  In the initial implementation (Linux "
"3.8), this requirement was satisfied by a simplistic implementation that "
"imposed the further requirement that the values in both field 1 and field 2 "
"of successive lines must be in ascending numerical order, which prevented "
"some otherwise valid maps from being created.  Linux 3.9 and later fix this "
"limitation, allowing any valid set of nonoverlapping maps."
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:553
msgid "At least one line must be written to the file."
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:556
msgid "Writes that violate the above rules fail with the error B<EINVAL>."
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:561
msgid ""
"In order for a process to write to the I</proc/[pid]/uid_map> "
"(I</proc/[pid]/gid_map>)  file, all of the following requirements must be "
"met:"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:567
msgid ""
"The writing process must have the B<CAP_SETUID> (B<CAP_SETGID>)  capability "
"in the user namespace of the process I<pid>."
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:572
msgid ""
"The writing process must either be in the user namespace of the process "
"I<pid> or be in the parent user namespace of the process I<pid>."
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:575
msgid ""
"The mapped user IDs (group IDs) must in turn have a mapping in the parent "
"user namespace."
msgstr ""

#. type: IP
#: build/C/man7/user_namespaces.7:575
#, no-wrap
msgid "4."
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:577
msgid "One of the following two cases applies:"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:586
msgid ""
"I<Either> the writing process has the B<CAP_SETUID> (B<CAP_SETGID>)  "
"capability in the I<parent> user namespace."
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:591
msgid ""
"No further restrictions apply: the process can make mappings to arbitrary "
"user IDs (group IDs)  in the parent user namespace."
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:595
msgid "I<Or> otherwise all of the following restrictions apply:"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:604
msgid ""
"The data written to I<uid_map> (I<gid_map>)  must consist of a single line "
"that maps the writing process's effective user ID (group ID) in the parent "
"user namespace to a user ID (group ID)  in the user namespace."
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:607
msgid ""
"The writing process must have the same effective user ID as the process that "
"created the user namespace."
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:618
msgid ""
"In the case of I<gid_map>, use of the B<setgroups>(2)  system call must "
"first be denied by writing \"I<deny>\" to the I</proc/[pid]/setgroups> file "
"(see below) before writing to I<gid_map>."
msgstr ""

#
#.  ============================================================
#. type: Plain text
#: build/C/man7/user_namespaces.7:626
msgid "Writes that violate the above rules fail with the error B<EPERM>."
msgstr ""

#. type: SS
#: build/C/man7/user_namespaces.7:626
#, no-wrap
msgid "Interaction with system calls that change process UIDs or GIDs"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:639
msgid ""
"In a user namespace where the I<uid_map> file has not been written, the "
"system calls that change user IDs will fail.  Similarly, if the I<gid_map> "
"file has not been written, the system calls that change group IDs will "
"fail.  After the I<uid_map> and I<gid_map> files have been written, only the "
"mapped values may be used in system calls that change user and group IDs."
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:653
msgid ""
"For user IDs, the relevant system calls include B<setuid>(2), "
"B<setfsuid>(2), B<setreuid>(2), and B<setresuid>(2).  For group IDs, the "
"relevant system calls include B<setgid>(2), B<setfsgid>(2), B<setregid>(2), "
"B<setresgid>(2), and B<setgroups>(2)."
msgstr ""

#.  Things changed in Linux 3.19
#.  commit 9cc46516ddf497ea16e8d7cb986ae03a0f6b92f8
#.  commit 66d2f338ee4c449396b6f99f5e75cd18eb6df272
#.  http://lwn.net/Articles/626665/
#
#.  ============================================================
#. type: Plain text
#: build/C/man7/user_namespaces.7:674
msgid ""
"Writing \"I<deny>\" to the I</proc/[pid]/setgroups> file before writing to "
"I</proc/[pid]/gid_map> will permanently disable B<setgroups>(2)  in a user "
"namespace and allow writing to I</proc/[pid]/gid_map> without having the "
"B<CAP_SETGID> capability in the parent user namespace."
msgstr ""

#. type: SS
#: build/C/man7/user_namespaces.7:674
#, no-wrap
msgid "The /proc/[pid]/setgroups file"
msgstr ""

#
#.  commit 9cc46516ddf497ea16e8d7cb986ae03a0f6b92f8
#.  commit 66d2f338ee4c449396b6f99f5e75cd18eb6df272
#.  http://lwn.net/Articles/626665/
#.  http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2014-8989
#. type: Plain text
#: build/C/man7/user_namespaces.7:701
msgid ""
"The I</proc/[pid]/setgroups> file displays the string \"I<allow>\" if "
"processes in the user namespace that contains the process I<pid> are "
"permitted to employ the B<setgroups>(2)  system call; it displays "
"\"I<deny>\" if B<setgroups>(2)  is not permitted in that user namespace.  "
"Note that regardless of the value in the I</proc/[pid]/setgroups> file (and "
"regardless of the process's capabilities), calls to B<setgroups>(2)  are "
"also not permitted if I</proc/[pid]/gid_map> has not yet been set."
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:717
msgid ""
"A privileged process (one with the B<CAP_SYS_ADMIN> capability in the "
"namespace) may write either of the strings \"I<allow>\" or \"I<deny>\" to "
"this file I<before> writing a group ID mapping for this user namespace to "
"the file I</proc/[pid]/gid_map>.  Writing the string \"I<deny>\" prevents "
"any process in the user namespace from employing B<setgroups>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:736
msgid ""
"The essence of the restrictions described in the preceding paragraph is that "
"it is permitted to write to I</proc/[pid]/setgroups> only so long as calling "
"B<setgroups>(2)  is disallowed because I</proc/[pid]/gid_map> has not been "
"set.  This ensures that a process cannot transition from a state where "
"B<setgroups>(2)  is allowed to a state where B<setgroups>(2)  is denied; a "
"process can transition only from B<setgroups>(2)  being disallowed to "
"B<setgroups>(2)  being allowed."
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:739
msgid ""
"The default value of this file in the initial user namespace is "
"\"I<allow>\"."
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:754
msgid ""
"Once I</proc/[pid]/gid_map> has been written to (which has the effect of "
"enabling B<setgroups>(2)  in the user namespace), it is no longer possible "
"to disallow B<setgroups>(2)  by writing \"I<deny>\" to "
"I</proc/[pid]/setgroups> (the write fails with the error B<EPERM>)."
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:758
msgid ""
"A child user namespace inherits the I</proc/[pid]/setgroups> setting from "
"its parent."
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:772
msgid ""
"If the I<setgroups> file has the value \"I<deny>\", then the B<setgroups>(2)  "
"system call can't subsequently be reenabled (by writing \"I<allow>\" to the "
"file) in this user namespace.  (Attempts to do so fail with the error "
"B<EPERM>.)  This restriction also propagates down to all child user "
"namespaces of this user namespace."
msgstr ""

#
#.  /proc/PID/setgroups
#. 	[allow == setgroups() is allowed, "deny" == setgroups() is disallowed]
#. 	* Can write if have CAP_SYS_ADMIN in NS
#. 	* Must write BEFORE writing to /proc/PID/gid_map
#
#.  setgroups()
#. 	* Must already have written to gid_map
#. 	* /proc/PID/setgroups must be "allow"
#
#.  /proc/PID/gid_map -- writing
#. 	* Must already have written "deny" to /proc/PID/setgroups
#
#.  ============================================================
#. type: Plain text
#: build/C/man7/user_namespaces.7:814
msgid ""
"The I</proc/[pid]/setgroups> file was added in Linux 3.19, but was "
"backported to many earlier stable kernel series, because it addresses a "
"security issue.  The issue concerned files with permissions such as "
"\"rwx---rwx\".  Such files give fewer permissions to \"group\" than they do "
"to \"other\".  This means that dropping groups using B<setgroups>(2)  might "
"allow a process file access that it did not formerly have.  Before the "
"existence of user namespaces this was not a concern, since only a privileged "
"process (one with the B<CAP_SETGID> capability) could call B<setgroups>(2).  "
"However, with the introduction of user namespaces, it became possible for an "
"unprivileged process to create a new namespace in which the user had all "
"privileges.  This then allowed formerly unprivileged users to drop groups "
"and thus gain file access that they did not previously have.  The "
"I</proc/[pid]/setgroups> file was added to address this security issue, by "
"denying any pathway for an unprivileged process to drop groups with "
"B<setgroups>(2)."
msgstr ""

#. type: SS
#: build/C/man7/user_namespaces.7:814
#, no-wrap
msgid "Unmapped user and group IDs"
msgstr ""

#.  from_kuid_munged(), from_kgid_munged()
#. type: Plain text
#: build/C/man7/user_namespaces.7:831
msgid ""
"There are various places where an unmapped user ID (group ID)  may be "
"exposed to user space.  For example, the first process in a new user "
"namespace may call B<getuid>(2)  before a user ID mapping has been defined "
"for the namespace.  In most such cases, an unmapped user ID is converted to "
"the overflow user ID (group ID); the default value for the overflow user ID "
"(group ID) is 65534.  See the descriptions of "
"I</proc/sys/kernel/overflowuid> and I</proc/sys/kernel/overflowgid> in "
"B<proc>(5)."
msgstr ""

#.  also SO_PEERCRED
#. type: Plain text
#: build/C/man7/user_namespaces.7:859
msgid ""
"The cases where unmapped IDs are mapped in this fashion include system calls "
"that return user IDs (B<getuid>(2), B<getgid>(2), and similar), credentials "
"passed over a UNIX domain socket, credentials returned by B<stat>(2), "
"B<waitid>(2), and the System V IPC \"ctl\" B<IPC_STAT> operations, "
"credentials exposed by I</proc/[pid]/status> and the files in "
"I</proc/sysvipc/*>, credentials returned via the I<si_uid> field in the "
"I<siginfo_t> received with a signal (see B<sigaction>(2)), credentials "
"written to the process accounting file (see B<acct>(5)), and credentials "
"returned with POSIX message queue notifications (see B<mq_notify>(3))."
msgstr ""

#.  from_kuid(), from_kgid()
#.  Also F_GETOWNER_UIDS is an exception
#
#.  ============================================================
#. type: Plain text
#: build/C/man7/user_namespaces.7:874
msgid ""
"There is one notable case where unmapped user and group IDs are I<not> "
"converted to the corresponding overflow ID value.  When viewing a I<uid_map> "
"or I<gid_map> file in which there is no mapping for the second field, that "
"field is displayed as 4294967295 (-1 as an unsigned integer)."
msgstr ""

#. type: SS
#: build/C/man7/user_namespaces.7:874
#, no-wrap
msgid "Accessing files"
msgstr ""

#
#.  ============================================================
#. type: Plain text
#: build/C/man7/user_namespaces.7:886
msgid ""
"In order to determine permissions when an unprivileged process accesses a "
"file, the process credentials (UID, GID) and the file credentials are in "
"effect mapped back to what they would be in the initial user namespace and "
"then compared to determine the permissions that the process has on the "
"file.  The same is also of other objects that employ the credentials plus "
"permissions mask accessibility model, such as System V IPC objects"
msgstr ""

#. type: SS
#: build/C/man7/user_namespaces.7:886
#, no-wrap
msgid "Operation of file-related capabilities"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:898
msgid ""
"Certain capabilities allow a process to bypass various kernel-enforced "
"restrictions when performing operations on files owned by other users or "
"groups.  These capabilities are: B<CAP_CHOWN>, B<CAP_DAC_OVERRIDE>, "
"B<CAP_DAC_READ_SEARCH>, B<CAP_FOWNER>, and B<CAP_FSETID>."
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:903
msgid ""
"Within a user namespace, these capabilities allow a process to bypass the "
"rules if the process has the relevant capability over the file, meaning "
"that:"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:905
msgid "the process has the relevant effective capability in its user namespace; and"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:908
msgid ""
"the file's user ID and group ID both have valid mappings in the user "
"namespace."
msgstr ""

#.  These are the checks performed by the kernel function
#.  inode_owner_or_capable(). There is one exception to the exception:
#.  overriding the directory sticky permission bit requires that
#.  the file has a valid mapping for both its UID and GID.
#
#.  ============================================================
#. type: Plain text
#: build/C/man7/user_namespaces.7:922
msgid ""
"The B<CAP_FOWNER> capability is treated somewhat exceptionally: it allows a "
"process to bypass the corresponding rules so long as at least the file's "
"user ID has a mapping in the user namespace (i.e., the file's group ID does "
"not need to have a valid mapping)."
msgstr ""

#. type: SS
#: build/C/man7/user_namespaces.7:922
#, no-wrap
msgid "Set-user-ID and set-group-ID programs"
msgstr ""

#
#.  ============================================================
#. type: Plain text
#: build/C/man7/user_namespaces.7:942
msgid ""
"When a process inside a user namespace executes a set-user-ID (set-group-ID) "
"program, the process's effective user (group) ID inside the namespace is "
"changed to whatever value is mapped for the user (group) ID of the file.  "
"However, if either the user I<or> the group ID of the file has no mapping "
"inside the namespace, the set-user-ID (set-group-ID) bit is silently "
"ignored: the new program is executed, but the process's effective user "
"(group) ID is left unchanged.  (This mirrors the semantics of executing a "
"set-user-ID or set-group-ID program that resides on a filesystem that was "
"mounted with the B<MS_NOSUID> flag, as described in B<mount>(2).)"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:952
msgid ""
"When a process's user and group IDs are passed over a UNIX domain socket to "
"a process in a different user namespace (see the description of "
"B<SCM_CREDENTIALS> in B<unix>(7)), they are translated into the "
"corresponding values as per the receiving process's user and group ID "
"mappings."
msgstr ""

#
#.  ============================================================
#. type: Plain text
#: build/C/man7/user_namespaces.7:965
msgid ""
"Over the years, there have been a lot of features that have been added to "
"the Linux kernel that have been made available only to privileged users "
"because of their potential to confuse set-user-ID-root applications.  In "
"general, it becomes safe to allow the root user in a user namespace to use "
"those features because it is impossible, while in a user namespace, to gain "
"more privilege than the root user of a user namespace has."
msgstr ""

#. type: SS
#: build/C/man7/user_namespaces.7:965
#, no-wrap
msgid "Availability"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:973
msgid ""
"Use of user namespaces requires a kernel that is configured with the "
"B<CONFIG_USER_NS> option.  User namespaces require support in a range of "
"subsystems across the kernel.  When an unsupported subsystem is configured "
"into the kernel, it is not possible to configure user namespaces support."
msgstr ""

#.  commit d6970d4b726cea6d7a9bc4120814f95c09571fc3
#. type: Plain text
#: build/C/man7/user_namespaces.7:984
msgid ""
"As at Linux 3.8, most relevant subsystems supported user namespaces, but a "
"number of filesystems did not have the infrastructure needed to map user and "
"group IDs between user namespaces.  Linux 3.9 added the required "
"infrastructure support for many of the remaining unsupported filesystems "
"(Plan 9 (9P), Andrew File System (AFS), Ceph, CIFS, CODA, NFS, and OCFS2).  "
"Linux 3.12 added support for the last of the unsupported major filesystems, "
"XFS."
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:993
msgid ""
"The program below is designed to allow experimenting with user namespaces, "
"as well as other types of namespaces.  It creates namespaces as specified by "
"command-line options and then executes a command inside those namespaces.  "
"The comments and I<usage()> function inside the program provide a full "
"explanation of the program.  The following shell session demonstrates its "
"use."
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:995
msgid "First, we look at the run-time environment:"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1004
#, no-wrap
msgid ""
"$ B<uname -rs>     # Need Linux 3.8 or later\n"
"Linux 3.8.0\n"
"$ B<id -u>         # Running as unprivileged user\n"
"1000\n"
"$ B<id -g>\n"
"1000\n"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1018
msgid ""
"Now start a new shell in new user (I<-U>), mount (I<-m>), and PID (I<-p>)  "
"namespaces, with user ID (I<-M>)  and group ID (I<-G>)  1000 mapped to 0 "
"inside the user namespace:"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1022
#, no-wrap
msgid ""
"$ B<./userns_child_exec -p -m -U -M \\(aq0 1000 1\\(aq -G \\(aq0 1000 1\\(aq "
"bash>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1027
msgid ""
"The shell has PID 1, because it is the first process in the new PID "
"namespace:"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1032
#, no-wrap
msgid ""
"bash$ B<echo $$>\n"
"1\n"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1040
msgid ""
"Mounting a new I</proc> filesystem and listing all of the processes visible "
"in the new PID namespace shows that the shell can't see any processes "
"outside the PID namespace:"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1048
#, no-wrap
msgid ""
"bash$ B<mount -t proc proc /proc>\n"
"bash$ B<ps ax>\n"
"  PID TTY      STAT   TIME COMMAND\n"
"    1 pts/3    S      0:00 bash\n"
"   22 pts/3    R+     0:00 ps ax\n"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1053
msgid ""
"Inside the user namespace, the shell has user and group ID 0, and a full set "
"of permitted and effective capabilities:"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1063
#, no-wrap
msgid ""
"bash$ B<cat /proc/$$/status | egrep \\(aq\\(ha[UG]id\\(aq>\n"
"Uid:\t0\t0\t0\t0\n"
"Gid:\t0\t0\t0\t0\n"
"bash$ B<cat /proc/$$/status | egrep \\(aq\\(haCap(Prm|Inh|Eff)\\(aq>\n"
"CapInh:\t0000000000000000\n"
"CapPrm:\t0000001fffffffff\n"
"CapEff:\t0000001fffffffff\n"
msgstr ""

#. type: SS
#: build/C/man7/user_namespaces.7:1065
#, no-wrap
msgid "Program source"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1069
#, no-wrap
msgid "/* userns_child_exec.c\n"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1071
#, no-wrap
msgid "   Licensed under GNU General Public License v2 or later\n"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1088
#, no-wrap
msgid ""
"   Create a child process that executes a shell command in new\n"
"   namespace(s); allow UID and GID mappings to be specified when\n"
"   creating a user namespace.\n"
"*/\n"
"#define _GNU_SOURCE\n"
"#include E<lt>sched.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/wait.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>limits.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1091
#, no-wrap
msgid ""
"/* A simple error-handling function: print an error message based\n"
"   on the value in \\(aqerrno\\(aq and terminate the calling process */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1094
#, no-wrap
msgid ""
"#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                        } while (0)\n"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1099
#, no-wrap
msgid ""
"struct child_args {\n"
"    char **argv;        /* Command to be executed by child, with args */\n"
"    int    pipe_fd[2];  /* Pipe used to synchronize parent and child */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1101
#, no-wrap
msgid "static int verbose;\n"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1134
#, no-wrap
msgid ""
"static void\n"
"usage(char *pname)\n"
"{\n"
"    fprintf(stderr, \"Usage: %s [options] cmd [arg...]\\en\\en\", pname);\n"
"    fprintf(stderr, \"Create a child process that executes a shell \"\n"
"            \"command in a new user namespace,\\en\"\n"
"            \"and possibly also other new namespace(s).\\en\\en\");\n"
"    fprintf(stderr, \"Options can be:\\en\\en\");\n"
"#define fpe(str) fprintf(stderr, \"    %s\", str);\n"
"    fpe(\"-i          New IPC namespace\\en\");\n"
"    fpe(\"-m          New mount namespace\\en\");\n"
"    fpe(\"-n          New network namespace\\en\");\n"
"    fpe(\"-p          New PID namespace\\en\");\n"
"    fpe(\"-u          New UTS namespace\\en\");\n"
"    fpe(\"-U          New user namespace\\en\");\n"
"    fpe(\"-M uid_map  Specify UID map for user namespace\\en\");\n"
"    fpe(\"-G gid_map  Specify GID map for user namespace\\en\");\n"
"    fpe(\"-z          Map user\\(aqs UID and GID to 0 in user "
"namespace\\en\");\n"
"    fpe(\"            (equivalent to: -M \\(aq0 E<lt>uidE<gt> 1\\(aq -G "
"\\(aq0 E<lt>gidE<gt> 1\\(aq)\\en\");\n"
"    fpe(\"-v          Display verbose messages\\en\");\n"
"    fpe(\"\\en\");\n"
"    fpe(\"If -z, -M, or -G is specified, -U is required.\\en\");\n"
"    fpe(\"It is not permitted to specify both -z and either -M or "
"-G.\\en\");\n"
"    fpe(\"\\en\");\n"
"    fpe(\"Map strings for -M and -G consist of records of the "
"form:\\en\");\n"
"    fpe(\"\\en\");\n"
"    fpe(\"    ID-inside-ns   ID-outside-ns   len\\en\");\n"
"    fpe(\"\\en\");\n"
"    fpe(\"A map string can contain multiple records, separated\"\n"
"        \" by commas;\\en\");\n"
"    fpe(\"the commas are replaced by newlines before writing\"\n"
"        \" to map files.\\en\");\n"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1137
#, no-wrap
msgid ""
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1142
#, no-wrap
msgid ""
"/* Update the mapping file \\(aqmap_file\\(aq, with the value provided in\n"
"   \\(aqmapping\\(aq, a string that defines a UID or GID mapping. A UID or\n"
"   GID mapping consists of one or more newline-delimited records\n"
"   of the form:\n"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1144
#, no-wrap
msgid "       ID_inside-ns    ID-outside-ns   length\n"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1149
#, no-wrap
msgid ""
"   Requiring the user to supply a string that contains newlines is\n"
"   of course inconvenient for command-line use. Thus, we permit the\n"
"   use of commas to delimit records in this string, and replace them\n"
"   with newlines before writing the string to the file. */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1155
#, no-wrap
msgid ""
"static void\n"
"update_map(char *mapping, char *map_file)\n"
"{\n"
"    int fd;\n"
"    size_t map_len;     /* Length of \\(aqmapping\\(aq */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1157
#, no-wrap
msgid "    /* Replace commas in mapping string with newlines */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1162
#, no-wrap
msgid ""
"    map_len = strlen(mapping);\n"
"    for (int j = 0; j E<lt> map_len; j++)\n"
"        if (mapping[j] == \\(aq,\\(aq)\n"
"            mapping[j] = \\(aq\\en\\(aq;\n"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1169
#, no-wrap
msgid ""
"    fd = open(map_file, O_RDWR);\n"
"    if (fd == -1) {\n"
"        fprintf(stderr, \"ERROR: open %s: %s\\en\", map_file,\n"
"                strerror(errno));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1175
#, no-wrap
msgid ""
"    if (write(fd, mapping, map_len) != map_len) {\n"
"        fprintf(stderr, \"ERROR: write %s: %s\\en\", map_file,\n"
"                strerror(errno));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1178 build/C/man7/user_namespaces.7:1222
#, no-wrap
msgid ""
"    close(fd);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1187
#, no-wrap
msgid ""
"/* Linux 3.19 made a change in the handling of setgroups(2) and the\n"
"   \\(aqgid_map\\(aq file to address a security issue. The issue allowed\n"
"   *unprivileged* users to employ user namespaces in order to drop\n"
"   The upshot of the 3.19 changes is that in order to update the\n"
"   \\(aqgid_maps\\(aq file, use of the setgroups() system call in this\n"
"   user namespace must first be disabled by writing \"deny\" to one of\n"
"   the /proc/PID/setgroups files for this namespace.  That is the\n"
"   purpose of the following function. */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1193
#, no-wrap
msgid ""
"static void\n"
"proc_setgroups_write(pid_t child_pid, char *str)\n"
"{\n"
"    char setgroups_path[PATH_MAX];\n"
"    int fd;\n"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1196
#, no-wrap
msgid ""
"    snprintf(setgroups_path, PATH_MAX, \"/proc/%jd/setgroups\",\n"
"            (intmax_t) child_pid);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1199
#, no-wrap
msgid ""
"    fd = open(setgroups_path, O_RDWR);\n"
"    if (fd == -1) {\n"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1205
#, no-wrap
msgid ""
"        /* We may be on a system that doesn\\(aqt support\n"
"           /proc/PID/setgroups. In that case, the file won\\(aqt exist,\n"
"           and the system won\\(aqt impose the restrictions that Linux "
"3.19\n"
"           added. That\\(aqs fine: we don\\(aqt need to do anything in "
"order\n"
"           to permit \\(aqgid_map\\(aq to be updated.\n"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1209
#, no-wrap
msgid ""
"           However, if the error from open() was something other than\n"
"           the ENOENT error that is expected for that case,  let the\n"
"           user know. */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1215
#, no-wrap
msgid ""
"        if (errno != ENOENT)\n"
"            fprintf(stderr, \"ERROR: open %s: %s\\en\", setgroups_path,\n"
"                strerror(errno));\n"
"        return;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1219
#, no-wrap
msgid ""
"    if (write(fd, str, strlen(str)) == -1)\n"
"        fprintf(stderr, \"ERROR: write %s: %s\\en\", setgroups_path,\n"
"            strerror(errno));\n"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1228
#, no-wrap
msgid ""
"static int              /* Start function for cloned child */\n"
"childFunc(void *arg)\n"
"{\n"
"    struct child_args *args = arg;\n"
"    char ch;\n"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1233
#, no-wrap
msgid ""
"    /* Wait until the parent has updated the UID and GID mappings.\n"
"       See the comment in main(). We wait for end of file on a\n"
"       pipe that will be closed by the parent process once it has\n"
"       updated the mappings. */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1242
#, no-wrap
msgid ""
"    close(args-E<gt>pipe_fd[1]);    /* Close our descriptor for the write\n"
"                                   end of the pipe so that we see EOF\n"
"                                   when parent closes its descriptor */\n"
"    if (read(args-E<gt>pipe_fd[0], &ch, 1) != 0) {\n"
"        fprintf(stderr,\n"
"                \"Failure in child: read from pipe returned != 0\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1244
#, no-wrap
msgid "    close(args-E<gt>pipe_fd[0]);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1246
#, no-wrap
msgid "    /* Execute a shell command */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1251
#, no-wrap
msgid ""
"    printf(\"About to exec %s\\en\", args-E<gt>argv[0]);\n"
"    execvp(args-E<gt>argv[0], args-E<gt>argv);\n"
"    errExit(\"execvp\");\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1253
#, no-wrap
msgid "#define STACK_SIZE (1024 * 1024)\n"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1255
#, no-wrap
msgid "static char child_stack[STACK_SIZE];    /* Space for child\\(aqs stack */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1266
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int flags, opt, map_zero;\n"
"    pid_t child_pid;\n"
"    struct child_args args;\n"
"    char *uid_map, *gid_map;\n"
"    const int MAP_BUF_SIZE = 100;\n"
"    char map_buf[MAP_BUF_SIZE];\n"
"    char map_path[PATH_MAX];\n"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1273
#, no-wrap
msgid ""
"    /* Parse command-line options. The initial \\(aq+\\(aq character in\n"
"       the final getopt() argument prevents GNU-style permutation\n"
"       of command-line options. That\\(aqs useful, since sometimes\n"
"       the \\(aqcommand\\(aq to be executed by this program itself\n"
"       has command-line options. We don\\(aqt want getopt() to treat\n"
"       those as options to this program. */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1294
#, no-wrap
msgid ""
"    flags = 0;\n"
"    verbose = 0;\n"
"    gid_map = NULL;\n"
"    uid_map = NULL;\n"
"    map_zero = 0;\n"
"    while ((opt = getopt(argc, argv, \"+imnpuUM:G:zv\")) != -1) {\n"
"        switch (opt) {\n"
"        case \\(aqi\\(aq: flags |= CLONE_NEWIPC;        break;\n"
"        case \\(aqm\\(aq: flags |= CLONE_NEWNS;         break;\n"
"        case \\(aqn\\(aq: flags |= CLONE_NEWNET;        break;\n"
"        case \\(aqp\\(aq: flags |= CLONE_NEWPID;        break;\n"
"        case \\(aqu\\(aq: flags |= CLONE_NEWUTS;        break;\n"
"        case \\(aqv\\(aq: verbose = 1;                  break;\n"
"        case \\(aqz\\(aq: map_zero = 1;                 break;\n"
"        case \\(aqM\\(aq: uid_map = optarg;             break;\n"
"        case \\(aqG\\(aq: gid_map = optarg;             break;\n"
"        case \\(aqU\\(aq: flags |= CLONE_NEWUSER;       break;\n"
"        default:  usage(argv[0]);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1296
#, no-wrap
msgid "    /* -M or -G without -U is nonsensical */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1301
#, no-wrap
msgid ""
"    if (((uid_map != NULL || gid_map != NULL || map_zero) &&\n"
"                !(flags & CLONE_NEWUSER)) ||\n"
"            (map_zero && (uid_map != NULL || gid_map != NULL)))\n"
"        usage(argv[0]);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1303
#, no-wrap
msgid "    args.argv = &argv[optind];\n"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1313
#, no-wrap
msgid ""
"    /* We use a pipe to synchronize the parent and child, in order to\n"
"       ensure that the parent sets the UID and GID maps before the child\n"
"       calls execve(). This ensures that the child maintains its\n"
"       capabilities during the execve() in the common case where we\n"
"       want to map the child\\(aqs effective user ID to 0 in the new user\n"
"       namespace. Without this synchronization, the child would lose\n"
"       its capabilities if it performed an execve() with nonzero\n"
"       user IDs (see the capabilities(7) man page for details of the\n"
"       transformation of a process\\(aqs capabilities during execve()). */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1316
#, no-wrap
msgid ""
"    if (pipe(args.pipe_fd) == -1)\n"
"        errExit(\"pipe\");\n"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1318
#, no-wrap
msgid "    /* Create the child in new namespace(s) */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1323
#, no-wrap
msgid ""
"    child_pid = clone(childFunc, child_stack + STACK_SIZE,\n"
"                      flags | SIGCHLD, &args);\n"
"    if (child_pid == -1)\n"
"        errExit(\"clone\");\n"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1325
#, no-wrap
msgid "    /* Parent falls through to here */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1329
#, no-wrap
msgid ""
"    if (verbose)\n"
"        printf(\"%s: PID of child created by clone() is %jd\\en\",\n"
"                argv[0], (intmax_t) child_pid);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1331
#, no-wrap
msgid "    /* Update the UID and GID maps in the child */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1342
#, no-wrap
msgid ""
"    if (uid_map != NULL || map_zero) {\n"
"        snprintf(map_path, PATH_MAX, \"/proc/%jd/uid_map\",\n"
"                (intmax_t) child_pid);\n"
"        if (map_zero) {\n"
"            snprintf(map_buf, MAP_BUF_SIZE, \"0 %jd 1\",\n"
"                    (intmax_t) getuid());\n"
"            uid_map = map_buf;\n"
"        }\n"
"        update_map(uid_map, map_path);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1345
#, no-wrap
msgid ""
"    if (gid_map != NULL || map_zero) {\n"
"        proc_setgroups_write(child_pid, \"deny\");\n"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1355
#, no-wrap
msgid ""
"        snprintf(map_path, PATH_MAX, \"/proc/%jd/gid_map\",\n"
"                (intmax_t) child_pid);\n"
"        if (map_zero) {\n"
"            snprintf(map_buf, MAP_BUF_SIZE, \"0 %ld 1\",\n"
"                    (intmax_t) getgid());\n"
"            gid_map = map_buf;\n"
"        }\n"
"        update_map(gid_map, map_path);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1358
#, no-wrap
msgid ""
"    /* Close the write end of the pipe, to signal to the child that we\n"
"       have updated the UID and GID maps */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1360
#, no-wrap
msgid "    close(args.pipe_fd[1]);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1363
#, no-wrap
msgid ""
"    if (waitpid(child_pid, NULL, 0) == -1)      /* Wait for child */\n"
"        errExit(\"waitpid\");\n"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1366
#, no-wrap
msgid ""
"    if (verbose)\n"
"        printf(\"%s: terminating\\en\", argv[0]);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1369
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#.  From the shadow package
#.  From the shadow package
#.  From the shadow package
#.  From the shadow package
#. type: Plain text
#: build/C/man7/user_namespaces.7:1385
msgid ""
"B<newgidmap>(1), B<newuidmap>(1), B<clone>(2), B<ptrace>(2), B<setns>(2), "
"B<unshare>(2), B<proc>(5), B<subgid>(5), B<subuid>(5), B<capabilities>(7), "
"B<cgroup_namespaces>(7), B<credentials>(7), B<namespaces>(7), "
"B<pid_namespaces>(7)"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1388
msgid "The kernel source file I<Documentation/namespaces/resource-control.txt>."
msgstr ""

#. type: TH
#: build/C/man7/uts_namespaces.7:26
#, no-wrap
msgid "UTS_NAMESPACES"
msgstr ""

#. type: TH
#: build/C/man7/uts_namespaces.7:26
#, no-wrap
msgid "2019-11-19"
msgstr ""

#. type: Plain text
#: build/C/man7/uts_namespaces.7:29
msgid "uts_namespaces - overview of Linux UTS namespaces"
msgstr ""

#. type: Plain text
#: build/C/man7/uts_namespaces.7:44
msgid ""
"UTS namespaces provide isolation of two system identifiers: the hostname and "
"the NIS domain name.  These identifiers are set using B<sethostname>(2)  and "
"B<setdomainname>(2), and can be retrieved using B<uname>(2), "
"B<gethostname>(2), and B<getdomainname>(2).  Changes made to these "
"identifiers are visible to all other processes in the same UTS namespace, "
"but are not visible to processes in other UTS namespaces."
msgstr ""

#. type: Plain text
#: build/C/man7/uts_namespaces.7:54
msgid ""
"When a process creates a new UTS namespace using B<clone>(2)  or "
"B<unshare>(2)  with the B<CLONE_NEWUTS> flag, the hostname and domain of the "
"new UTS namespace are copied from the corresponding values in the caller's "
"UTS namespace."
msgstr ""

#. type: Plain text
#: build/C/man7/uts_namespaces.7:58
msgid ""
"Use of UTS namespaces requires a kernel that is configured with the "
"B<CONFIG_UTS_NS> option."
msgstr ""

#. type: Plain text
#: build/C/man7/uts_namespaces.7:68
msgid ""
"B<nsenter>(1), B<unshare>(1), B<clone>(2), B<getdomainname>(2), "
"B<gethostname>(2), B<setns>(2), B<uname>(2), B<unshare>(2), B<namespaces>(7)"
msgstr ""
