# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-03-12 14:01+0900\n"
"PO-Revision-Date: 2021-07-14 00:31+0900\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man7/cgroup_namespaces.7:26
#, no-wrap
msgid "CGROUP_NAMESPACES"
msgstr "CGROUP_NAMESPACES"

#. type: TH
#: build/C/man7/cgroup_namespaces.7:26 build/C/man7/mount_namespaces.7:26
#: build/C/man7/namespaces.7:27 build/C/man7/pid_namespaces.7:27
#: build/C/man7/user_namespaces.7:27
#, no-wrap
msgid "2020-11-01"
msgstr "2020-11-01"

#. type: TH
#: build/C/man7/cgroup_namespaces.7:26 build/C/man7/ipc_namespaces.7:26
#: build/C/man7/mount_namespaces.7:26 build/C/man7/namespaces.7:27
#: build/C/man7/network_namespaces.7:26 build/C/man7/pid_namespaces.7:27
#: build/C/man7/time_namespaces.7:26 build/C/man7/user_namespaces.7:27
#: build/C/man7/uts_namespaces.7:26
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#: build/C/man7/cgroup_namespaces.7:26 build/C/man7/ipc_namespaces.7:26
#: build/C/man7/mount_namespaces.7:26 build/C/man7/namespaces.7:27
#: build/C/man7/network_namespaces.7:26 build/C/man7/pid_namespaces.7:27
#: build/C/man7/time_namespaces.7:26 build/C/man7/user_namespaces.7:27
#: build/C/man7/uts_namespaces.7:26
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux Programmer's Manual"

#. type: SH
#: build/C/man7/cgroup_namespaces.7:27 build/C/man7/ipc_namespaces.7:27
#: build/C/man7/mount_namespaces.7:27 build/C/man7/namespaces.7:28
#: build/C/man7/network_namespaces.7:27 build/C/man7/pid_namespaces.7:28
#: build/C/man7/time_namespaces.7:27 build/C/man7/user_namespaces.7:28
#: build/C/man7/uts_namespaces.7:27
#, no-wrap
msgid "NAME"
msgstr "名前"

#. type: Plain text
#: build/C/man7/cgroup_namespaces.7:29
msgid "cgroup_namespaces - overview of Linux cgroup namespaces"
msgstr "cgroup_namespaces - Linux の cgroup 名前空間の概要"

#. type: SH
#: build/C/man7/cgroup_namespaces.7:29 build/C/man7/ipc_namespaces.7:29
#: build/C/man7/mount_namespaces.7:29 build/C/man7/namespaces.7:30
#: build/C/man7/network_namespaces.7:29 build/C/man7/pid_namespaces.7:30
#: build/C/man7/time_namespaces.7:29 build/C/man7/user_namespaces.7:30
#: build/C/man7/uts_namespaces.7:29
#, no-wrap
msgid "DESCRIPTION"
msgstr "説明"

#. type: Plain text
#: build/C/man7/cgroup_namespaces.7:32 build/C/man7/mount_namespaces.7:32
#: build/C/man7/pid_namespaces.7:33 build/C/man7/user_namespaces.7:33
msgid "For an overview of namespaces, see B<namespaces>(7)."
msgstr "名前空間の概要については B<namespaces>(7) を参照。"

#. type: Plain text
#: build/C/man7/cgroup_namespaces.7:39
msgid ""
"Cgroup namespaces virtualize the view of a process's cgroups (see "
"B<cgroups>(7))  as seen via I</proc/[pid]/cgroup> and I</proc/[pid]/"
"mountinfo>."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroup_namespaces.7:56
msgid ""
"Each cgroup namespace has its own set of cgroup root directories.  These "
"root directories are the base points for the relative locations displayed in "
"the corresponding records in the I</proc/[pid]/cgroup> file.  When a process "
"creates a new cgroup namespace using B<clone>(2)  or B<unshare>(2)  with the "
"B<CLONE_NEWCGROUP> flag, its current cgroups directories become the cgroup "
"root directories of the new namespace.  (This applies both for the cgroups "
"version 1 hierarchies and the cgroups version 2 unified hierarchy.)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroup_namespaces.7:67
msgid ""
"When reading the cgroup memberships of a \"target\" process from I</proc/"
"[pid]/cgroup>, the pathname shown in the third field of each record will be "
"relative to the reading process's root directory for the corresponding "
"cgroup hierarchy.  If the cgroup directory of the target process lies "
"outside the root directory of the reading process's cgroup namespace, then "
"the pathname will show I<../> entries for each ancestor level in the cgroup "
"hierarchy."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroup_namespaces.7:70
msgid ""
"The following shell session demonstrates the effect of creating a new cgroup "
"namespace."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroup_namespaces.7:76
msgid ""
"First, (as superuser) in a shell in the initial cgroup namespace, we create "
"a child cgroup in the I<freezer> hierarchy, and place a process in that "
"cgroup that we will use as part of the demonstration below:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroup_namespaces.7:83
#, no-wrap
msgid ""
"# B<mkdir -p /sys/fs/cgroup/freezer/sub2>\n"
"# B<sleep 10000 &>     # Create a process that lives for a while\n"
"[1] 20124\n"
"# B<echo 20124 E<gt> /sys/fs/cgroup/freezer/sub2/cgroup.procs>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroup_namespaces.7:89
msgid ""
"We then create another child cgroup in the I<freezer> hierarchy and put the "
"shell into that cgroup:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroup_namespaces.7:98
#, no-wrap
msgid ""
"# B<mkdir -p /sys/fs/cgroup/freezer/sub>\n"
"# B<echo $$>                      # Show PID of this shell\n"
"30655\n"
"# B<echo 30655 E<gt> /sys/fs/cgroup/freezer/sub/cgroup.procs>\n"
"# B<cat /proc/self/cgroup | grep freezer>\n"
"7:freezer:/sub\n"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroup_namespaces.7:104
msgid ""
"Next, we use B<unshare>(1)  to create a process running a new shell in new "
"cgroup and mount namespaces:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroup_namespaces.7:108
#, no-wrap
msgid "# B<PS1=\"sh2# \" unshare -Cm bash>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroup_namespaces.7:120
msgid ""
"From the new shell started by B<unshare>(1), we then inspect the I</proc/"
"[pid]/cgroup> files of, respectively, the new shell, a process that is in "
"the initial cgroup namespace (I<init>, with PID 1), and the process in the "
"sibling cgroup (I<sub2>):"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroup_namespaces.7:129
#, no-wrap
msgid ""
"sh2# B<cat /proc/self/cgroup | grep freezer>\n"
"7:freezer:/\n"
"sh2# B<cat /proc/1/cgroup | grep freezer>\n"
"7:freezer:/..\n"
"sh2# B<cat /proc/20124/cgroup | grep freezer>\n"
"7:freezer:/../sub2\n"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroup_namespaces.7:145
msgid ""
"From the output of the first command, we see that the freezer cgroup "
"membership of the new shell (which is in the same cgroup as the initial "
"shell)  is shown defined relative to the freezer cgroup root directory that "
"was established when the new cgroup namespace was created.  (In absolute "
"terms, the new shell is in the I</sub> freezer cgroup, and the root "
"directory of the freezer cgroup hierarchy in the new cgroup namespace is "
"also I</sub>.  Thus, the new shell's cgroup membership is displayed as \\(aq/"
"\\(aq.)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroup_namespaces.7:149
msgid ""
"However, when we look in I</proc/self/mountinfo> we see the following "
"anomaly:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroup_namespaces.7:154
#, no-wrap
msgid ""
"sh2# B<cat /proc/self/mountinfo | grep freezer>\n"
"155 145 0:32 /.. /sys/fs/cgroup/freezer ...\n"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroup_namespaces.7:171
msgid ""
"The fourth field of this line (I</..>)  should show the directory in the "
"cgroup filesystem which forms the root of this mount.  Since by the "
"definition of cgroup namespaces, the process's current freezer cgroup "
"directory became its root freezer cgroup directory, we should see \\(aq/"
"\\(aq in this field.  The problem here is that we are seeing a mount entry "
"for the cgroup filesystem corresponding to the initial cgroup namespace "
"(whose cgroup filesystem is indeed rooted at the parent directory of "
"I<sub>).  To fix this problem, we must remount the freezer cgroup filesystem "
"from the new shell (i.e., perform the mount from a process that is in the "
"new cgroup namespace), after which we see the expected results:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroup_namespaces.7:180
#, no-wrap
msgid ""
"sh2# B<mount --make-rslave />     # Don\\(aqt propagate mount events\n"
"                               # to other namespaces\n"
"sh2# B<umount /sys/fs/cgroup/freezer>\n"
"sh2# B<mount -t cgroup -o freezer freezer /sys/fs/cgroup/freezer>\n"
"sh2# B<cat /proc/self/mountinfo | grep freezer>\n"
"155 145 0:32 / /sys/fs/cgroup/freezer rw,relatime ...\n"
msgstr ""

#. type: SH
#: build/C/man7/cgroup_namespaces.7:183 build/C/man7/mount_namespaces.7:1041
#: build/C/man7/pid_namespaces.7:392 build/C/man7/user_namespaces.7:952
#, no-wrap
msgid "CONFORMING TO"
msgstr "準拠"

#. type: Plain text
#: build/C/man7/cgroup_namespaces.7:185 build/C/man7/mount_namespaces.7:1044
#: build/C/man7/pid_namespaces.7:394 build/C/man7/user_namespaces.7:955
msgid "Namespaces are a Linux-specific feature."
msgstr "名前空間は Linux 独自の機能である。"

#. type: SH
#: build/C/man7/cgroup_namespaces.7:185 build/C/man7/mount_namespaces.7:1044
#: build/C/man7/time_namespaces.7:187 build/C/man7/user_namespaces.7:955
#, no-wrap
msgid "NOTES"
msgstr "注意"

#
#. type: Plain text
#: build/C/man7/cgroup_namespaces.7:189
msgid ""
"Use of cgroup namespaces requires a kernel that is configured with the "
"B<CONFIG_CGROUPS> option."
msgstr "cgroup 名前空間を使用するには、設定 B<CONFIG_CGROUPS> が有効になったカーネルが必要である。"

#. type: Plain text
#: build/C/man7/cgroup_namespaces.7:191
msgid ""
"The virtualization provided by cgroup namespaces serves a number of purposes:"
msgstr ""

#. type: IP
#: build/C/man7/cgroup_namespaces.7:191 build/C/man7/cgroup_namespaces.7:197
#: build/C/man7/cgroup_namespaces.7:207 build/C/man7/ipc_namespaces.7:51
#: build/C/man7/ipc_namespaces.7:54 build/C/man7/ipc_namespaces.7:67
#: build/C/man7/mount_namespaces.7:60 build/C/man7/mount_namespaces.7:65
#: build/C/man7/mount_namespaces.7:83 build/C/man7/mount_namespaces.7:92
#: build/C/man7/mount_namespaces.7:99 build/C/man7/mount_namespaces.7:110
#: build/C/man7/mount_namespaces.7:131 build/C/man7/mount_namespaces.7:244
#: build/C/man7/mount_namespaces.7:246 build/C/man7/namespaces.7:329
#: build/C/man7/namespaces.7:331 build/C/man7/namespaces.7:334
#: build/C/man7/namespaces.7:338 build/C/man7/namespaces.7:340
#: build/C/man7/namespaces.7:343 build/C/man7/namespaces.7:350
#: build/C/man7/namespaces.7:357 build/C/man7/namespaces.7:383
#: build/C/man7/namespaces.7:387 build/C/man7/namespaces.7:390
#: build/C/man7/namespaces.7:392 build/C/man7/namespaces.7:397
#: build/C/man7/namespaces.7:402 build/C/man7/namespaces.7:408
#: build/C/man7/user_namespaces.7:257 build/C/man7/user_namespaces.7:260
#: build/C/man7/user_namespaces.7:263 build/C/man7/user_namespaces.7:266
#: build/C/man7/user_namespaces.7:269 build/C/man7/user_namespaces.7:272
#: build/C/man7/user_namespaces.7:275 build/C/man7/user_namespaces.7:518
#: build/C/man7/user_namespaces.7:521 build/C/man7/user_namespaces.7:523
#: build/C/man7/user_namespaces.7:538 build/C/man7/user_namespaces.7:551
#: build/C/man7/user_namespaces.7:578 build/C/man7/user_namespaces.7:592
#: build/C/man7/user_namespaces.7:903 build/C/man7/user_namespaces.7:905
#, no-wrap
msgid "*"
msgstr "*"

#. type: Plain text
#: build/C/man7/cgroup_namespaces.7:197
msgid ""
"It prevents information leaks whereby cgroup directory paths outside of a "
"container would otherwise be visible to processes in the container.  Such "
"leakages could, for example, reveal information about the container "
"framework to containerized applications."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroup_namespaces.7:207
msgid ""
"It eases tasks such as container migration.  The virtualization provided by "
"cgroup namespaces allows containers to be isolated from knowledge of the "
"pathnames of ancestor cgroups.  Without such isolation, the full cgroup "
"pathnames (displayed in I</proc/self/cgroups>)  would need to be replicated "
"on the target system when migrating a container; those pathnames would also "
"need to be unique, so that they don't conflict with other pathnames on the "
"target system."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroup_namespaces.7:212
msgid ""
"It allows better confinement of containerized processes, because it is "
"possible to mount the container's cgroup filesystems such that the container "
"processes can't gain access to ancestor cgroup directories.  Consider, for "
"example, the following scenario:"
msgstr ""

#. type: IP
#: build/C/man7/cgroup_namespaces.7:213 build/C/man7/cgroup_namespaces.7:217
#: build/C/man7/time_namespaces.7:31 build/C/man7/time_namespaces.7:39
#: build/C/man7/time_namespaces.7:170 build/C/man7/time_namespaces.7:174
#, no-wrap
msgid "\\(bu"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroup_namespaces.7:217
msgid "We have a cgroup directory, I</cg/1>, that is owned by user ID 9000."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroup_namespaces.7:232
msgid ""
"We have a process, I<X>, also owned by user ID 9000, that is namespaced "
"under the cgroup I</cg/1/2> (i.e., I<X> was placed in a new cgroup namespace "
"via B<clone>(2)  or B<unshare>(2)  with the B<CLONE_NEWCGROUP> flag)."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroup_namespaces.7:259
msgid ""
"In the absence of cgroup namespacing, because the cgroup directory I</cg/1> "
"is owned (and writable) by UID 9000 and process I<X> is also owned by user "
"ID 9000, process I<X> would be able to modify the contents of cgroups files "
"(i.e., change cgroup settings) not only in I</cg/1/2> but also in the "
"ancestor cgroup directory I</cg/1>.  Namespacing process I<X> under the "
"cgroup directory I</cg/1/2>, in combination with suitable mount operations "
"for the cgroup filesystem (as shown above), prevents it modifying files in "
"I</cg/1>, since it cannot even see the contents of that directory (or of "
"further removed cgroup ancestor directories).  Combined with correct "
"enforcement of hierarchical limits, this prevents process I<X> from escaping "
"the limits imposed by ancestor cgroups."
msgstr ""

#. type: SH
#: build/C/man7/cgroup_namespaces.7:259 build/C/man7/ipc_namespaces.7:78
#: build/C/man7/mount_namespaces.7:1123 build/C/man7/namespaces.7:417
#: build/C/man7/network_namespaces.7:66 build/C/man7/pid_namespaces.7:397
#: build/C/man7/time_namespaces.7:359 build/C/man7/user_namespaces.7:1370
#: build/C/man7/uts_namespaces.7:58
#, no-wrap
msgid "SEE ALSO"
msgstr "関連項目"

#. type: Plain text
#: build/C/man7/cgroup_namespaces.7:269
msgid ""
"B<unshare>(1), B<clone>(2), B<setns>(2), B<unshare>(2), B<proc>(5), "
"B<cgroups>(7), B<credentials>(7), B<namespaces>(7), B<user_namespaces>(7)"
msgstr "B<unshare>(1), B<clone>(2), B<setns>(2), B<unshare>(2), B<proc>(5), B<cgroups>(7), B<credentials>(7), B<namespaces>(7), B<user_namespaces>(7)"

#. type: SH
#: build/C/man7/cgroup_namespaces.7:269 build/C/man7/ipc_namespaces.7:87
#: build/C/man7/mount_namespaces.7:1141 build/C/man7/namespaces.7:438
#: build/C/man7/network_namespaces.7:82 build/C/man7/pid_namespaces.7:409
#: build/C/man7/time_namespaces.7:369 build/C/man7/user_namespaces.7:1388
#: build/C/man7/uts_namespaces.7:68
#, no-wrap
msgid "COLOPHON"
msgstr "この文書について"

#. type: Plain text
#: build/C/man7/cgroup_namespaces.7:277 build/C/man7/ipc_namespaces.7:95
#: build/C/man7/mount_namespaces.7:1149 build/C/man7/namespaces.7:446
#: build/C/man7/network_namespaces.7:90 build/C/man7/pid_namespaces.7:417
#: build/C/man7/time_namespaces.7:377 build/C/man7/user_namespaces.7:1396
#: build/C/man7/uts_namespaces.7:76
msgid ""
"This page is part of release 5.10 of the Linux I<man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at \\%https://www.kernel.org/doc/man-"
"pages/."
msgstr "この man ページは Linux I<man-pages> プロジェクトのリリース 5.10 の一部である。プロジェクトの説明とバグ報告に関する情報は \\%https://www.kernel.org/doc/man-pages/ に書かれている。"

#. type: TH
#: build/C/man7/ipc_namespaces.7:26
#, no-wrap
msgid "IPC_NAMESPACES"
msgstr "IPC_NAMESPACES"

#. type: TH
#: build/C/man7/ipc_namespaces.7:26
#, no-wrap
msgid "2019-08-02"
msgstr ""

#. type: Plain text
#: build/C/man7/ipc_namespaces.7:29
msgid "ipc_namespaces - overview of Linux IPC namespaces"
msgstr "ipc_namespaces - Linux の IPC 名前空間の概要"

#.  commit 7eafd7c74c3f2e67c27621b987b28397110d643f
#.  https://lwn.net/Articles/312232/
#. type: Plain text
#: build/C/man7/ipc_namespaces.7:41
msgid ""
"IPC namespaces isolate certain IPC resources, namely, System V IPC objects "
"(see B<sysvipc>(7))  and (since Linux 2.6.30)  POSIX message queues (see "
"B<mq_overview>(7)).  The common characteristic of these IPC mechanisms is "
"that IPC objects are identified by mechanisms other than filesystem "
"pathnames."
msgstr "IPC 名前空間は、 特定の IPC リソース、すなわち、System V IPC オブジェクト (B<sysvipc>(7) 参照)、(Linux 2.6.30 以降では) POSIX メッセージキュー (B<mq_overview>(7) 参照) を分離する。 これらの IPC 機構に共通の特徴は、 IPC オブジェクトがファイルシステムのパス名以外の方法で識別されるという点である。"

#. type: Plain text
#: build/C/man7/ipc_namespaces.7:47
msgid ""
"Each IPC namespace has its own set of System V IPC identifiers and its own "
"POSIX message queue filesystem.  Objects created in an IPC namespace are "
"visible to all other processes that are members of that namespace, but are "
"not visible to processes in other IPC namespaces."
msgstr ""
"各 IPC 名前空間はそれぞれ、 独自の System V IPC 識別子の集合と独自の POSIX "
"メッセージキューファイルシステムを持つ。 IPC 名前空間に作成されたオブジェクト"
"は、 その名前空間のメンバーの他のすべてのプロセスにも見えるが、 他の IPC 名前"
"空間のプロセスには見えない。"

#. type: Plain text
#: build/C/man7/ipc_namespaces.7:51
msgid "The following I</proc> interfaces are distinct in each IPC namespace:"
msgstr "以下の I</proc> インターフェースは各 IPC 名前空間で別のものとなる。"

#. type: Plain text
#: build/C/man7/ipc_namespaces.7:54
msgid "The POSIX message queue interfaces in I</proc/sys/fs/mqueue>."
msgstr "I</proc/sys/fs/mqueue> の POSIX メッセージキューインターフェース。"

#. type: Plain text
#: build/C/man7/ipc_namespaces.7:67
msgid ""
"The System V IPC interfaces in I</proc/sys/kernel>, namely: I<msgmax>, "
"I<msgmnb>, I<msgmni>, I<sem>, I<shmall>, I<shmmax>, I<shmmni>, and "
"I<shm_rmid_forced>."
msgstr ""
"I</proc/sys/kernel> の System V IPC インターフェース。 すなわち、 I<msgmax>, "
"I<msgmnb>, I<msgmni>, I<sem>, I<shmall>, I<shmmax>, I<shmmni>, "
"I<shm_rmid_forced>。"

#. type: Plain text
#: build/C/man7/ipc_namespaces.7:70
msgid "The System V IPC interfaces in I</proc/sysvipc>."
msgstr "I</proc/sysvipc> の System V IPC インターフェース。"

#. type: Plain text
#: build/C/man7/ipc_namespaces.7:74
msgid ""
"When an IPC namespace is destroyed (i.e., when the last process that is a "
"member of the namespace terminates), all IPC objects in the namespace are "
"automatically destroyed."
msgstr ""
"IPC 名前空間が破棄されたときに (すなわち、その名前空間のメンバーの最後のプロ"
"セスが終了したときに)、 その名前空間内のすべての IPC オブジェクトが自動的に破"
"棄される。"

#
#. type: Plain text
#: build/C/man7/ipc_namespaces.7:78
msgid ""
"Use of IPC namespaces requires a kernel that is configured with the "
"B<CONFIG_IPC_NS> option."
msgstr ""
"IPC 名前空間を使用するには、設定 B<CONFIG_IPC_NS> が有効になったカーネルが必"
"要である。"

#. type: Plain text
#: build/C/man7/ipc_namespaces.7:87
msgid ""
"B<nsenter>(1), B<unshare>(1), B<clone>(2), B<setns>(2), B<unshare>(2), "
"B<mq_overview>(7), B<namespaces>(7), B<sysvipc>(7)"
msgstr "B<nsenter>(1), B<unshare>(1), B<clone>(2), B<setns>(2), B<unshare>(2), B<mq_overview>(7), B<namespaces>(7), B<sysvipc>(7)"

#. type: TH
#: build/C/man7/mount_namespaces.7:26
#, no-wrap
msgid "MOUNT_NAMESPACES"
msgstr "MOUNT_NAMESPACES"

#. type: Plain text
#: build/C/man7/mount_namespaces.7:29
msgid "mount_namespaces - overview of Linux mount namespaces"
msgstr "mount_namespaces - Linux のマウント名前空間の概要"

#. type: Plain text
#: build/C/man7/mount_namespaces.7:37
msgid ""
"Mount namespaces provide isolation of the list of mount points seen by the "
"processes in each namespace instance.  Thus, the processes in each of the "
"mount namespace instances will see distinct single-directory hierarchies."
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:50
msgid ""
"The views provided by the I</proc/[pid]/mounts>, I</proc/[pid]/mountinfo>, "
"and I</proc/[pid]/mountstats> files (all described in B<proc>(5))  "
"correspond to the mount namespace in which the process with the PID I<[pid]> "
"resides.  (All of the processes that reside in the same mount namespace will "
"see the same view in these files.)"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:60
msgid ""
"A new mount namespace is created using either B<clone>(2)  or B<unshare>(2)  "
"with the B<CLONE_NEWNS> flag.  When a new mount namespace is created, its "
"mount point list is initialized as follows:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:65
msgid ""
"If the namespace is created using B<clone>(2), the mount point list of the "
"child's namespace is a copy of the mount point list in the parent's "
"namespace."
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:70
msgid ""
"If the namespace is created using B<unshare>(2), the mount point list of the "
"new namespace is a copy of the mount point list in the caller's previous "
"mount namespace."
msgstr ""

#
#.  ============================================================
#. type: Plain text
#: build/C/man7/mount_namespaces.7:81
msgid ""
"Subsequent modifications to the mount point list (B<mount>(2)  and "
"B<umount>(2))  in either mount namespace will not (by default) affect the "
"mount point list seen in the other namespace (but see the following "
"discussion of shared subtrees)."
msgstr ""

#. type: SS
#: build/C/man7/mount_namespaces.7:81
#, no-wrap
msgid "Restrictions on mount namespaces"
msgstr "マウント名前空間における制限"

#. type: Plain text
#: build/C/man7/mount_namespaces.7:83
msgid "Note the following points with respect to mount namespaces:"
msgstr "マウント名前空間に関しては以下の点に注意すること。"

#. type: Plain text
#: build/C/man7/mount_namespaces.7:92
msgid ""
"Each mount namespace has an owner user namespace.  As explained above, when "
"a new mount namespace is created, its mount point list is initialized as a "
"copy of the mount point list of another mount namespace.  If the new "
"namespace and the namespace from which the mount point list was copied are "
"owned by different user namespaces, then the new mount namespace is "
"considered I<less privileged>."
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:99
#, fuzzy
#| msgid ""
#| "When creating a less privileged mount namespace, shared mounts are "
#| "reduced to slave mounts.  This ensures that mappings performed in less "
#| "privileged mount namespaces will not propagate to more privileged mount "
#| "namespaces."
msgid ""
"When creating a less privileged mount namespace, shared mounts are reduced "
"to slave mounts.  (Shared and slave mounts are discussed below.)  This "
"ensures that mappings performed in less privileged mount namespaces will not "
"propagate to more privileged mount namespaces."
msgstr ""
"特権が少ないマウント名前空間を作成する場合、 共有マウントは slave マウントに"
"縮小される。 これにより、 特権の少ないマウント名前空間で実行されるマッピング"
"が、 より特権を持つマウント名前空間 (more privileged mount namespace) に伝搬"
"しないことが保証される。"

#. type: Plain text
#: build/C/man7/mount_namespaces.7:110
msgid ""
"Mounts that come as a single unit from a more privileged mount namespace are "
"locked together and may not be separated in a less privileged mount "
"namespace.  (The B<unshare>(2)  B<CLONE_NEWNS> operation brings across all "
"of the mounts from the original mount namespace as a single unit, and "
"recursive mounts that propagate between mount namespaces propagate as a "
"single unit.)"
msgstr "より特権を持つマウント名前空間で一つのまとまりとして行われたマウントは一つにまとまったままとなり、 特権が少ないマウント名前空間で分割することはできない。 (B<unshare>(2) の B<CLONE_NEWNS> 操作では、 元のマウント名前空間のすべてのマウントは一つのまとまりとして扱われ、 マウント名前空間間で伝わる再帰的なマウントでは一つのまとまりとして伝わる。)"

#
#.  commit 9566d6742852c527bf5af38af5cbb878dad75705
#.  Author: Eric W. Biederman <ebiederm@xmission.com>
#.  Date:   Mon Jul 28 17:26:07 2014 -0700
#.       mnt: Correct permission checks in do_remount
#. type: Plain text
#: build/C/man7/mount_namespaces.7:131
msgid ""
"The B<mount>(2)  flags B<MS_RDONLY>, B<MS_NOSUID>, B<MS_NOEXEC>, and the "
"\"atime\" flags (B<MS_NOATIME>, B<MS_NODIRATIME>, B<MS_RELATIME>)  settings "
"become locked when propagated from a more privileged to a less privileged "
"mount namespace, and may not be changed in the less privileged mount "
"namespace."
msgstr ""
"より特権を持つマウント名前空間から特権の少ないマウント名前空間に伝わる際に、 "
"B<mount>(2) の B<MS_RDONLY>, B<MS_NOSUID>, B<MS_NOEXEC> フラグと \"atime\" フ"
"ラグ (B<MS_NOATIME>, B<MS_NODIRATIME>, B<MS_REALTIME>) 設定はロックされ、 特"
"権の少ないマウント名前空間では変更することはできない。"

#.  (As of 3.18-rc1 (in Al Viro's 2014-08-30 vfs.git#for-next tree))
#. type: Plain text
#: build/C/man7/mount_namespaces.7:140
#, fuzzy
#| msgid ""
#| "A file or directory that is a mount point in one namespace that is not a "
#| "mount point in another namespace, may be renamed, unlinked, or removed "
#| "(B<rmdir>(2))  in the mount namespace in which it is not a mount point "
#| "(subject to the usual permission checks)."
msgid ""
"A file or directory that is a mount point in one namespace that is not a "
"mount point in another namespace, may be renamed, unlinked, or removed "
"(B<rmdir>(2))  in the mount namespace in which it is not a mount point "
"(subject to the usual permission checks).  Consequently, the mount point is "
"removed in the mount namespace where it was a mount point."
msgstr ""
"ある名前空間でマウントポイントとなっているが別の名前空間でのマウントポイント"
"になっていないファイルやディレクトリは、 マウントポイントになっていないマウン"
"ト名前空間では (通常のアクセス許可チェックにもとづいて) rename, unlink, "
"remove (B<rmdir>(2)) を行うことができる。"

#
#.  mtk: The change was in Linux 3.18, I think, with this commit:
#.      commit 8ed936b5671bfb33d89bc60bdcc7cf0470ba52fe
#.      Author: Eric W. Biederman <ebiederman@twitter.com>
#.      Date:   Tue Oct 1 18:33:48 2013 -0700
#.          vfs: Lazily remove mounts on unlinked files and directories.
#. type: Plain text
#: build/C/man7/mount_namespaces.7:156
msgid ""
"Previously (before Linux 3.18), attempting to unlink, rename, or remove a "
"file or directory that was a mount point in another mount namespace would "
"result in the error B<EBUSY>.  That behavior had technical problems of "
"enforcement (e.g., for NFS)  and permitted denial-of-service attacks against "
"more privileged users.  (i.e., preventing individual files from being "
"updated by bind mounting on top of them)."
msgstr "以前は (Linux 3.18 より前)、 別のマウント名前空間でマウントポイントとなっていたファイルやディレクトリを rename, unlink, remove しようとすると、 エラー B<EBUSY> が返されていた。 この動作は、 (NFS などで) 適用にあたっての技術的な問題があるとともに、 より特権を持つユーザーに対してサービス不能攻撃 (denial-of-service attack) を許してしまっていた (ファイルをバインドマウントで更新することができなくなっていた)。"

#. type: SH
#: build/C/man7/mount_namespaces.7:156
#, no-wrap
msgid "SHARED SUBTREES"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:171
msgid ""
"After the implementation of mount namespaces was completed, experience "
"showed that the isolation that they provided was, in some cases, too great.  "
"For example, in order to make a newly loaded optical disk available in all "
"mount namespaces, a mount operation was required in each namespace.  For "
"this use case, and others, the shared subtree feature was introduced in "
"Linux 2.6.15.  This feature allows for automatic, controlled propagation of "
"mount and unmount I<events> between namespaces (or, more precisely, between "
"the members of a I<peer group> that are propagating events to one another)."
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:176
msgid ""
"Each mount point is marked (via B<mount>(2))  as having one of the following "
"I<propagation types>:"
msgstr ""

#. type: TP
#: build/C/man7/mount_namespaces.7:176
#, no-wrap
msgid "B<MS_SHARED>"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:186
msgid ""
"This mount point shares events with members of a peer group.  Mount and "
"unmount events immediately under this mount point will propagate to the "
"other mount points that are members of the peer group.  I<Propagation> here "
"means that the same mount or unmount will automatically occur under all of "
"the other mount points in the peer group.  Conversely, mount and unmount "
"events that take place under peer mount points will propagate to this mount "
"point."
msgstr ""

#. type: TP
#: build/C/man7/mount_namespaces.7:186
#, no-wrap
msgid "B<MS_PRIVATE>"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:190
msgid ""
"This mount point is private; it does not have a peer group.  Mount and "
"unmount events do not propagate into or out of this mount point."
msgstr ""

#. type: TP
#: build/C/man7/mount_namespaces.7:190
#, no-wrap
msgid "B<MS_SLAVE>"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:195
msgid ""
"Mount and unmount events propagate into this mount point from a (master) "
"shared peer group.  Mount and unmount events under this mount point do not "
"propagate to any peer."
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:200
msgid ""
"Note that a mount point can be the slave of another peer group while at the "
"same time sharing mount and unmount events with a peer group of which it is "
"a member.  (More precisely, one peer group can be the slave of another peer "
"group.)"
msgstr ""

#. type: TP
#: build/C/man7/mount_namespaces.7:200
#, no-wrap
msgid "B<MS_UNBINDABLE>"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:209
msgid ""
"This is like a private mount, and in addition this mount can't be bind "
"mounted.  Attempts to bind mount this mount (B<mount>(2)  with the "
"B<MS_BIND> flag) will fail."
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:220
msgid ""
"When a recursive bind mount (B<mount>(2)  with the B<MS_BIND> and B<MS_REC> "
"flags) is performed on a directory subtree, any bind mounts within the "
"subtree are automatically pruned (i.e., not replicated)  when replicating "
"that subtree to produce the target subtree."
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:223
msgid ""
"For a discussion of the propagation type assigned to a new mount, see NOTES."
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:229
msgid ""
"The propagation type is a per-mount-point setting; some mount points may be "
"marked as shared (with each shared mount point being a member of a distinct "
"peer group), while others are private (or slaved or unbindable)."
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:240
msgid ""
"Note that a mount's propagation type determines whether mounts and unmounts "
"of mount points I<immediately under> the mount point are propagated.  Thus, "
"the propagation type does not affect propagation of events for grandchildren "
"and further removed descendant mount points.  What happens if the mount "
"point itself is unmounted is determined by the propagation type that is in "
"effect for the I<parent> of the mount point."
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:244
msgid ""
"Members are added to a I<peer group> when a mount point is marked as shared "
"and either:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:246
msgid ""
"the mount point is replicated during the creation of a new mount namespace; "
"or"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:248
msgid "a new bind mount is created from the mount point."
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:251
msgid ""
"In both of these cases, the new mount point joins the peer group of which "
"the existing mount point is a member."
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:257
msgid ""
"A new peer group is also created when a child mount point is created under "
"an existing mount point that is marked as shared.  In this case, the new "
"child mount point is also marked as shared and the resulting peer group "
"consists of all the mount points that are replicated under the peers of "
"parent mount."
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:262
msgid ""
"A mount ceases to be a member of a peer group when either the mount is "
"explicitly unmounted, or when the mount is implicitly unmounted because a "
"mount namespace is removed (because it has no more member processes)."
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:271
msgid ""
"The propagation type of the mount points in a mount namespace can be "
"discovered via the \"optional fields\" exposed in I</proc/[pid]/mountinfo>.  "
"(See B<proc>(5)  for details of this file.)  The following tags can appear "
"in the optional fields for a record in that file:"
msgstr ""

#. type: TP
#: build/C/man7/mount_namespaces.7:271
#, no-wrap
msgid "I<shared:X>"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:280
msgid ""
"This mount point is shared in peer group I<X>.  Each peer group has a unique "
"ID that is automatically generated by the kernel, and all mount points in "
"the same peer group will show the same ID.  (These IDs are assigned starting "
"from the value 1, and may be recycled when a peer group ceases to have any "
"members.)"
msgstr ""

#. type: TP
#: build/C/man7/mount_namespaces.7:280
#, no-wrap
msgid "I<master:X>"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:284
msgid "This mount is a slave to shared peer group I<X>."
msgstr ""

#. type: TP
#: build/C/man7/mount_namespaces.7:284
#, no-wrap
msgid "I<propagate_from:X> (since Linux 2.6.26)"
msgstr "I<propagate_from:X> (Linux 2.6.26 以降)"

#.  commit 97e7e0f71d6d948c25f11f0a33878d9356d9579e
#. type: Plain text
#: build/C/man7/mount_namespaces.7:305
msgid ""
"This mount is a slave and receives propagation from shared peer group I<X>.  "
"This tag will always appear in conjunction with a I<master:X> tag.  Here, "
"I<X> is the closest dominant peer group under the process's root directory.  "
"If I<X> is the immediate master of the mount, or if there is no dominant "
"peer group under the same root, then only the I<master:X> field is present "
"and not the I<propagate_from:X> field.  For further details, see below."
msgstr ""

#. type: TP
#: build/C/man7/mount_namespaces.7:305
#, no-wrap
msgid "I<unbindable>"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:308
msgid "This is an unbindable mount."
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:310
msgid "If none of the above tags is present, then this is a private mount."
msgstr ""

#. type: SS
#: build/C/man7/mount_namespaces.7:310
#, no-wrap
msgid "MS_SHARED and MS_PRIVATE example"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:315
msgid ""
"Suppose that on a terminal in the initial mount namespace, we mark one mount "
"point as shared and another as private, and then view the mounts in I</proc/"
"self/mountinfo>:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:323
#, no-wrap
msgid ""
"sh1# B<mount --make-shared /mntS>\n"
"sh1# B<mount --make-private /mntP>\n"
"sh1# B<cat /proc/self/mountinfo | grep \\(aq/mnt\\(aq | sed \\(aqs/ - .*//\\(aq>\n"
"77 61 8:17 / /mntS rw,relatime shared:1\n"
"83 61 8:15 / /mntP rw,relatime\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:342
msgid ""
"From the I</proc/self/mountinfo> output, we see that I</mntS> is a shared "
"mount in peer group 1, and that I</mntP> has no optional tags, indicating "
"that it is a private mount.  The first two fields in each record in this "
"file are the unique ID for this mount, and the mount ID of the parent "
"mount.  We can further inspect this file to see that the parent mount point "
"of I</mntS> and I</mntP> is the root directory, I</>, which is mounted as "
"private:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:347
#, no-wrap
msgid ""
"sh1# B<cat /proc/self/mountinfo | awk \\(aq$1 == 61\\(aq | sed \\(aqs/ - .*//\\(aq>\n"
"61 0 8:2 / / rw,relatime\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:353
msgid ""
"On a second terminal, we create a new mount namespace where we run a second "
"shell and inspect the mounts:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:360
#, no-wrap
msgid ""
"$ B<PS1=\\(aqsh2# \\(aq sudo unshare -m --propagation unchanged sh>\n"
"sh2# B<cat /proc/self/mountinfo | grep \\(aq/mnt\\(aq | sed \\(aqs/ - .*//\\(aq>\n"
"222 145 8:17 / /mntS rw,relatime shared:1\n"
"225 145 8:15 / /mntP rw,relatime\n"
msgstr ""

#.  Since util-linux 2.27
#. type: Plain text
#: build/C/man7/mount_namespaces.7:374
msgid ""
"The new mount namespace received a copy of the initial mount namespace's "
"mount points.  These new mount points maintain the same propagation types, "
"but have unique mount IDs.  (The I<--propagation\\ unchanged> option "
"prevents B<unshare>(1)  from marking all mounts as private when creating a "
"new mount namespace, which it does by default.)"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:380
msgid ""
"In the second terminal, we then create submounts under each of I</mntS> and "
"I</mntP> and inspect the set-up:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:392
#, no-wrap
msgid ""
"sh2# B<mkdir /mntS/a>\n"
"sh2# B<mount /dev/sdb6 /mntS/a>\n"
"sh2# B<mkdir /mntP/b>\n"
"sh2# B<mount /dev/sdb7 /mntP/b>\n"
"sh2# B<cat /proc/self/mountinfo | grep \\(aq/mnt\\(aq | sed \\(aqs/ - .*//\\(aq>\n"
"222 145 8:17 / /mntS rw,relatime shared:1\n"
"225 145 8:15 / /mntP rw,relatime\n"
"178 222 8:22 / /mntS/a rw,relatime shared:2\n"
"230 225 8:23 / /mntP/b rw,relatime\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:400
msgid ""
"From the above, it can be seen that I</mntS/a> was created as shared "
"(inheriting this setting from its parent mount) and I</mntP/b> was created "
"as a private mount."
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:408
msgid ""
"Returning to the first terminal and inspecting the set-up, we see that the "
"new mount created under the shared mount point I</mntS> propagated to its "
"peer mount (in the initial mount namespace), but the new mount created under "
"the private mount point I</mntP> did not propagate:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:415
#, no-wrap
msgid ""
"sh1# B<cat /proc/self/mountinfo | grep \\(aq/mnt\\(aq | sed \\(aqs/ - .*//\\(aq>\n"
"77 61 8:17 / /mntS rw,relatime shared:1\n"
"83 61 8:15 / /mntP rw,relatime\n"
"179 77 8:22 / /mntS/a rw,relatime shared:2\n"
msgstr ""

#. type: SS
#: build/C/man7/mount_namespaces.7:418
#, no-wrap
msgid "MS_SLAVE example"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:427
msgid ""
"Making a mount point a slave allows it to receive propagated mount and "
"unmount events from a master shared peer group, while preventing it from "
"propagating events to that master.  This is useful if we want to (say) "
"receive a mount event when an optical disk is mounted in the master shared "
"peer group (in another mount namespace), but want to prevent mount and "
"unmount events under the slave mount from having side effects in other "
"namespaces."
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:430
msgid ""
"We can demonstrate the effect of slaving by first marking two mount points "
"as shared in the initial mount namespace:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:438
#, no-wrap
msgid ""
"sh1# B<mount --make-shared /mntX>\n"
"sh1# B<mount --make-shared /mntY>\n"
"sh1# B<cat /proc/self/mountinfo | grep \\(aq/mnt\\(aq | sed \\(aqs/ - .*//\\(aq>\n"
"132 83 8:23 / /mntX rw,relatime shared:1\n"
"133 83 8:22 / /mntY rw,relatime shared:2\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:443
msgid ""
"On a second terminal, we create a new mount namespace and inspect the mount "
"points:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:450
#, no-wrap
msgid ""
"sh2# B<unshare -m --propagation unchanged sh>\n"
"sh2# B<cat /proc/self/mountinfo | grep \\(aq/mnt\\(aq | sed \\(aqs/ - .*//\\(aq>\n"
"168 167 8:23 / /mntX rw,relatime shared:1\n"
"169 167 8:22 / /mntY rw,relatime shared:2\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:454
msgid ""
"In the new mount namespace, we then mark one of the mount points as a slave:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:461
#, no-wrap
msgid ""
"sh2# B<mount --make-slave /mntY>\n"
"sh2# B<cat /proc/self/mountinfo | grep \\(aq/mnt\\(aq | sed \\(aqs/ - .*//\\(aq>\n"
"168 167 8:23 / /mntX rw,relatime shared:1\n"
"169 167 8:22 / /mntY rw,relatime master:2\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:468
msgid ""
"From the above output, we see that I</mntY> is now a slave mount that is "
"receiving propagation events from the shared peer group with the ID 2."
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:473
msgid ""
"Continuing in the new namespace, we create submounts under each of I</mntX> "
"and I</mntY>:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:480
#, no-wrap
msgid ""
"sh2# B<mkdir /mntX/a>\n"
"sh2# B<mount /dev/sda3 /mntX/a>\n"
"sh2# B<mkdir /mntY/b>\n"
"sh2# B<mount /dev/sda5 /mntY/b>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:490
msgid ""
"When we inspect the state of the mount points in the new mount namespace, we "
"see that I</mntX/a> was created as a new shared mount (inheriting the "
"\"shared\" setting from its parent mount) and I</mntY/b> was created as a "
"private mount:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:498
#, no-wrap
msgid ""
"sh2# B<cat /proc/self/mountinfo | grep \\(aq/mnt\\(aq | sed \\(aqs/ - .*//\\(aq>\n"
"168 167 8:23 / /mntX rw,relatime shared:1\n"
"169 167 8:22 / /mntY rw,relatime master:2\n"
"173 168 8:3 / /mntX/a rw,relatime shared:3\n"
"175 169 8:5 / /mntY/b rw,relatime\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:509
msgid ""
"Returning to the first terminal (in the initial mount namespace), we see "
"that the mount I</mntX/a> propagated to the peer (the shared I</mntX>), but "
"the mount I</mntY/b> was not propagated:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:516
#, no-wrap
msgid ""
"sh1# B<cat /proc/self/mountinfo | grep \\(aq/mnt\\(aq | sed \\(aqs/ - .*//\\(aq>\n"
"132 83 8:23 / /mntX rw,relatime shared:1\n"
"133 83 8:22 / /mntY rw,relatime shared:2\n"
"174 132 8:3 / /mntX/a rw,relatime shared:3\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:522
msgid "Now we create a new mount point under I</mntY> in the first shell:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:532
#, no-wrap
msgid ""
"sh1# B<mkdir /mntY/c>\n"
"sh1# B<mount /dev/sda1 /mntY/c>\n"
"sh1# B<cat /proc/self/mountinfo | grep \\(aq/mnt\\(aq | sed \\(aqs/ - .*//\\(aq>\n"
"132 83 8:23 / /mntX rw,relatime shared:1\n"
"133 83 8:22 / /mntY rw,relatime shared:2\n"
"174 132 8:3 / /mntX/a rw,relatime shared:3\n"
"178 133 8:1 / /mntY/c rw,relatime shared:4\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:539
msgid ""
"When we examine the mount points in the second mount namespace, we see that "
"in this case the new mount has been propagated to the slave mount point, and "
"that the new mount is itself a slave mount (to peer group 4):"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:548
#, no-wrap
msgid ""
"sh2# B<cat /proc/self/mountinfo | grep \\(aq/mnt\\(aq | sed \\(aqs/ - .*//\\(aq>\n"
"168 167 8:23 / /mntX rw,relatime shared:1\n"
"169 167 8:22 / /mntY rw,relatime master:2\n"
"173 168 8:3 / /mntX/a rw,relatime shared:3\n"
"175 169 8:5 / /mntY/b rw,relatime\n"
"179 169 8:1 / /mntY/c rw,relatime master:4\n"
msgstr ""

#. type: SS
#: build/C/man7/mount_namespaces.7:551
#, no-wrap
msgid "MS_UNBINDABLE example"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:556
msgid ""
"One of the primary purposes of unbindable mounts is to avoid the \"mount "
"point explosion\" problem when repeatedly performing bind mounts of a higher-"
"level subtree at a lower-level mount point.  The problem is illustrated by "
"the following shell session."
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:558
msgid "Suppose we have a system with the following mount points:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:565
#, no-wrap
msgid ""
"# B<mount | awk \\(aq{print $1, $2, $3}\\(aq>\n"
"/dev/sda1 on /\n"
"/dev/sdb6 on /mntX\n"
"/dev/sdb7 on /mntY\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:571
msgid ""
"Suppose furthermore that we wish to recursively bind mount the root "
"directory under several users' home directories.  We do this for the first "
"user, and inspect the mount points:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:582
#, no-wrap
msgid ""
"# B<mount --rbind / /home/cecilia/>\n"
"# B<mount | awk \\(aq{print $1, $2, $3}\\(aq>\n"
"/dev/sda1 on /\n"
"/dev/sdb6 on /mntX\n"
"/dev/sdb7 on /mntY\n"
"/dev/sda1 on /home/cecilia\n"
"/dev/sdb6 on /home/cecilia/mntX\n"
"/dev/sdb7 on /home/cecilia/mntY\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:587
msgid ""
"When we repeat this operation for the second user, we start to see the "
"explosion problem:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:604
#, no-wrap
msgid ""
"# B<mount --rbind / /home/henry>\n"
"# B<mount | awk \\(aq{print $1, $2, $3}\\(aq>\n"
"/dev/sda1 on /\n"
"/dev/sdb6 on /mntX\n"
"/dev/sdb7 on /mntY\n"
"/dev/sda1 on /home/cecilia\n"
"/dev/sdb6 on /home/cecilia/mntX\n"
"/dev/sdb7 on /home/cecilia/mntY\n"
"/dev/sda1 on /home/henry\n"
"/dev/sdb6 on /home/henry/mntX\n"
"/dev/sdb7 on /home/henry/mntY\n"
"/dev/sda1 on /home/henry/home/cecilia\n"
"/dev/sdb6 on /home/henry/home/cecilia/mntX\n"
"/dev/sdb7 on /home/henry/home/cecilia/mntY\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:618
msgid ""
"Under I</home/henry>, we have not only recursively added the I</mntX> and I</"
"mntY> mounts, but also the recursive mounts of those directories under I</"
"home/cecilia> that were created in the previous step.  Upon repeating the "
"step for a third user, it becomes obvious that the explosion is exponential "
"in nature:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:647
#, no-wrap
msgid ""
"# B<mount --rbind / /home/otto>\n"
"# B<mount | awk \\(aq{print $1, $2, $3}\\(aq>\n"
"/dev/sda1 on /\n"
"/dev/sdb6 on /mntX\n"
"/dev/sdb7 on /mntY\n"
"/dev/sda1 on /home/cecilia\n"
"/dev/sdb6 on /home/cecilia/mntX\n"
"/dev/sdb7 on /home/cecilia/mntY\n"
"/dev/sda1 on /home/henry\n"
"/dev/sdb6 on /home/henry/mntX\n"
"/dev/sdb7 on /home/henry/mntY\n"
"/dev/sda1 on /home/henry/home/cecilia\n"
"/dev/sdb6 on /home/henry/home/cecilia/mntX\n"
"/dev/sdb7 on /home/henry/home/cecilia/mntY\n"
"/dev/sda1 on /home/otto\n"
"/dev/sdb6 on /home/otto/mntX\n"
"/dev/sdb7 on /home/otto/mntY\n"
"/dev/sda1 on /home/otto/home/cecilia\n"
"/dev/sdb6 on /home/otto/home/cecilia/mntX\n"
"/dev/sdb7 on /home/otto/home/cecilia/mntY\n"
"/dev/sda1 on /home/otto/home/henry\n"
"/dev/sdb6 on /home/otto/home/henry/mntX\n"
"/dev/sdb7 on /home/otto/home/henry/mntY\n"
"/dev/sda1 on /home/otto/home/henry/home/cecilia\n"
"/dev/sdb6 on /home/otto/home/henry/home/cecilia/mntX\n"
"/dev/sdb7 on /home/otto/home/henry/home/cecilia/mntY\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:655
msgid ""
"The mount explosion problem in the above scenario can be avoided by making "
"each of the new mounts unbindable.  The effect of doing this is that "
"recursive mounts of the root directory will not replicate the unbindable "
"mounts.  We make such a mount for the first user:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:659
#, no-wrap
msgid "# B<mount --rbind --make-unbindable / /home/cecilia>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:663
msgid ""
"Before going further, we show that unbindable mounts are indeed unbindable:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:670
#, no-wrap
msgid ""
"# B<mkdir /mntZ>\n"
"# B<mount --bind /home/cecilia /mntZ>\n"
"mount: wrong fs type, bad option, bad superblock on /home/cecilia,\n"
"       missing codepage or helper program, or other error\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:673
#, no-wrap
msgid ""
"       In some cases useful info is found in syslog - try\n"
"       dmesg | tail or so.\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:677
msgid "Now we create unbindable recursive bind mounts for the other two users:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:682
#, no-wrap
msgid ""
"# B<mount --rbind --make-unbindable / /home/henry>\n"
"# B<mount --rbind --make-unbindable / /home/otto>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:689
msgid ""
"Upon examining the list of mount points, we see there has been no explosion "
"of mount points, because the unbindable mounts were not replicated under "
"each user's directory:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:705
#, no-wrap
msgid ""
"# B<mount | awk \\(aq{print $1, $2, $3}\\(aq>\n"
"/dev/sda1 on /\n"
"/dev/sdb6 on /mntX\n"
"/dev/sdb7 on /mntY\n"
"/dev/sda1 on /home/cecilia\n"
"/dev/sdb6 on /home/cecilia/mntX\n"
"/dev/sdb7 on /home/cecilia/mntY\n"
"/dev/sda1 on /home/henry\n"
"/dev/sdb6 on /home/henry/mntX\n"
"/dev/sdb7 on /home/henry/mntY\n"
"/dev/sda1 on /home/otto\n"
"/dev/sdb6 on /home/otto/mntX\n"
"/dev/sdb7 on /home/otto/mntY\n"
msgstr ""

#. type: SS
#: build/C/man7/mount_namespaces.7:708
#, no-wrap
msgid "Propagation type transitions"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:717
msgid ""
"The following table shows the effect that applying a new propagation type (i."
"e., I<mount --make-xxxx>)  has on the existing propagation type of a mount "
"point.  The rows correspond to existing propagation types, and the columns "
"are the new propagation settings.  For reasons of space, \"private\" is "
"abbreviated as \"priv\" and \"unbindable\" as \"unbind\"."
msgstr ""

#. type: tbl table
#: build/C/man7/mount_namespaces.7:720
#, no-wrap
msgid "make-shared"
msgstr ""

#. type: tbl table
#: build/C/man7/mount_namespaces.7:720
#, no-wrap
msgid "make-slave"
msgstr ""

#. type: tbl table
#: build/C/man7/mount_namespaces.7:720
#, no-wrap
msgid "make-priv"
msgstr ""

#. type: tbl table
#: build/C/man7/mount_namespaces.7:720
#, no-wrap
msgid "make-unbind"
msgstr ""

#. type: tbl table
#: build/C/man7/mount_namespaces.7:721 build/C/man7/mount_namespaces.7:771
#: build/C/man7/mount_namespaces.7:815
#, no-wrap
msgid "_"
msgstr ""

#. type: tbl table
#: build/C/man7/mount_namespaces.7:722 build/C/man7/mount_namespaces.7:725
#: build/C/man7/mount_namespaces.7:726 build/C/man7/mount_namespaces.7:770
#: build/C/man7/mount_namespaces.7:772 build/C/man7/mount_namespaces.7:773
#: build/C/man7/mount_namespaces.7:814 build/C/man7/mount_namespaces.7:816
#: build/C/man7/mount_namespaces.7:817
#, no-wrap
msgid "shared"
msgstr ""

#. type: tbl table
#: build/C/man7/mount_namespaces.7:722
#, no-wrap
msgid "slave/priv [1]"
msgstr ""

#. type: tbl table
#: build/C/man7/mount_namespaces.7:722 build/C/man7/mount_namespaces.7:723
#: build/C/man7/mount_namespaces.7:724 build/C/man7/mount_namespaces.7:725
#: build/C/man7/mount_namespaces.7:726
#, no-wrap
msgid "priv"
msgstr ""

#. type: tbl table
#: build/C/man7/mount_namespaces.7:722 build/C/man7/mount_namespaces.7:723
#: build/C/man7/mount_namespaces.7:724 build/C/man7/mount_namespaces.7:725
#: build/C/man7/mount_namespaces.7:726 build/C/man7/mount_namespaces.7:770
#: build/C/man7/mount_namespaces.7:814
#, no-wrap
msgid "unbind"
msgstr ""

#. type: tbl table
#: build/C/man7/mount_namespaces.7:723 build/C/man7/mount_namespaces.7:724
#: build/C/man7/mount_namespaces.7:770 build/C/man7/mount_namespaces.7:773
#: build/C/man7/mount_namespaces.7:814 build/C/man7/mount_namespaces.7:817
#, no-wrap
msgid "slave"
msgstr ""

#. type: tbl table
#: build/C/man7/mount_namespaces.7:723 build/C/man7/mount_namespaces.7:724
#: build/C/man7/mount_namespaces.7:772 build/C/man7/mount_namespaces.7:816
#, no-wrap
msgid "slave+shared"
msgstr ""

#. type: tbl table
#: build/C/man7/mount_namespaces.7:723
#, no-wrap
msgid "slave [2]"
msgstr ""

#. type: tbl table
#: build/C/man7/mount_namespaces.7:725 build/C/man7/mount_namespaces.7:770
#: build/C/man7/mount_namespaces.7:773 build/C/man7/mount_namespaces.7:814
#: build/C/man7/mount_namespaces.7:817
#, no-wrap
msgid "private"
msgstr ""

#. type: tbl table
#: build/C/man7/mount_namespaces.7:725
#, no-wrap
msgid "priv [2]"
msgstr ""

#. type: tbl table
#: build/C/man7/mount_namespaces.7:726 build/C/man7/mount_namespaces.7:817
#, no-wrap
msgid "unbindable"
msgstr ""

#. type: tbl table
#: build/C/man7/mount_namespaces.7:726
#, no-wrap
msgid "unbind [2]"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:730
#, fuzzy
#| msgid "One of the following is true:"
msgid "Note the following details to the table:"
msgstr "以下のいずれか一つが真である。"

#. type: IP
#: build/C/man7/mount_namespaces.7:730
#, no-wrap
msgid "[1]"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:733
msgid ""
"If a shared mount is the only mount in its peer group, making it a slave "
"automatically makes it private."
msgstr ""

#. type: IP
#: build/C/man7/mount_namespaces.7:733
#, no-wrap
msgid "[2]"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:736
msgid "Slaving a nonshared mount has no effect on the mount."
msgstr ""

#. type: SS
#: build/C/man7/mount_namespaces.7:736
#, no-wrap
msgid "Bind (MS_BIND) semantics"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:738 build/C/man7/mount_namespaces.7:786
msgid "Suppose that the following command is performed:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:742
#, no-wrap
msgid "mount --bind A/a B/b\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:764
msgid ""
"Here, I<A> is the source mount point, I<B> is the destination mount point, "
"I<a> is a subdirectory path under the mount point I<A>, and I<b> is a "
"subdirectory path under the mount point I<B>.  The propagation type of the "
"resulting mount, I<B/b>, depends on the propagation types of the mount "
"points I<A> and I<B>, and is summarized in the following table."
msgstr ""

#. type: tbl table
#: build/C/man7/mount_namespaces.7:769 build/C/man7/mount_namespaces.7:813
#, no-wrap
msgid "source(A)"
msgstr ""

#. type: tbl table
#: build/C/man7/mount_namespaces.7:772 build/C/man7/mount_namespaces.7:816
#, no-wrap
msgid "dest(B)"
msgstr ""

#. type: tbl table
#: build/C/man7/mount_namespaces.7:772 build/C/man7/mount_namespaces.7:773
#: build/C/man7/mount_namespaces.7:816
#, no-wrap
msgid "invalid"
msgstr ""

#. type: tbl table
#: build/C/man7/mount_namespaces.7:773 build/C/man7/mount_namespaces.7:817
#, no-wrap
msgid "nonshared"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:779
msgid ""
"Note that a recursive bind of a subtree follows the same semantics as for a "
"bind operation on each mount in the subtree.  (Unbindable mounts are "
"automatically pruned at the target mount point.)"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:784 build/C/man7/mount_namespaces.7:826
msgid ""
"For further details, see I<Documentation/filesystems/sharedsubtree.txt> in "
"the kernel source tree."
msgstr ""

#. type: SS
#: build/C/man7/mount_namespaces.7:784
#, no-wrap
msgid "Move (MS_MOVE) semantics"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:790
#, no-wrap
msgid "mount --move A B/b\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:808
msgid ""
"Here, I<A> is the source mount point, I<B> is the destination mount point, "
"and I<b> is a subdirectory path under the mount point I<B>.  The propagation "
"type of the resulting mount, I<B/b>, depends on the propagation types of the "
"mount points I<A> and I<B>, and is summarized in the following table."
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:821
msgid "Note: moving a mount that resides under a shared mount is invalid."
msgstr ""

#. type: SS
#: build/C/man7/mount_namespaces.7:826
#, fuzzy, no-wrap
#| msgid "Mount points"
msgid "Mount semantics"
msgstr "マウントポイント"

#. type: Plain text
#: build/C/man7/mount_namespaces.7:828
msgid "Suppose that we use the following command to create a mount point:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:832
#, no-wrap
msgid "mount device B/b\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:847
msgid ""
"Here, I<B> is the destination mount point, and I<b> is a subdirectory path "
"under the mount point I<B>.  The propagation type of the resulting mount, "
"I<B/b>, follows the same rules as for a bind mount, where the propagation "
"type of the source mount is considered always to be private."
msgstr ""

#. type: SS
#: build/C/man7/mount_namespaces.7:847
#, no-wrap
msgid "Unmount semantics"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:849
msgid "Suppose that we use the following command to tear down a mount point:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:853
#, no-wrap
msgid "unmount A\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:874
msgid ""
"Here, I<A> is a mount point on I<B/b>, where I<B> is the parent mount and "
"I<b> is a subdirectory path under the mount point I<B>.  If B<B> is shared, "
"then all most-recently-mounted mounts at I<b> on mounts that receive "
"propagation from mount I<B> and do not have submounts under them are "
"unmounted."
msgstr ""

#. type: SS
#: build/C/man7/mount_namespaces.7:874
#, no-wrap
msgid "The /proc/[pid]/mountinfo propagate_from tag"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:884
msgid ""
"The I<propagate_from:X> tag is shown in the optional fields of a I</proc/"
"[pid]/mountinfo> record in cases where a process can't see a slave's "
"immediate master (i.e., the pathname of the master is not reachable from the "
"filesystem root directory)  and so cannot determine the chain of propagation "
"between the mounts it can see."
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:899
msgid ""
"In the following example, we first create a two-link master-slave chain "
"between the mounts I</mnt>, I</tmp/etc>, and I</mnt/tmp/etc>.  Then the "
"B<chroot>(1)  command is used to make the I</tmp/etc> mount point "
"unreachable from the root directory, creating a situation where the master "
"of I</mnt/tmp/etc> is not reachable from the (new) root directory of the "
"process."
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:912
msgid ""
"First, we bind mount the root directory onto I</mnt> and then bind mount I</"
"proc> at I</mnt/proc> so that after the later B<chroot>(1)  the B<proc>(5)  "
"filesystem remains visible at the correct location in the chroot-ed "
"environment."
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:918
#, no-wrap
msgid ""
"# B<mkdir -p /mnt/proc>\n"
"# B<mount --bind / /mnt>\n"
"# B<mount --bind /proc /mnt/proc>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:924
msgid ""
"Next, we ensure that the I</mnt> mount is a shared mount in a new peer group "
"(with no peers):"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:932
#, no-wrap
msgid ""
"# B<mount --make-private /mnt>  # Isolate from any previous peer group\n"
"# B<mount --make-shared /mnt>\n"
"# B<cat /proc/self/mountinfo | grep \\(aq/mnt\\(aq | sed \\(aqs/ - .*//\\(aq>\n"
"239 61 8:2 / /mnt ... shared:102\n"
"248 239 0:4 / /mnt/proc ... shared:5\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:939
msgid "Next, we bind mount I</mnt/etc> onto I</tmp/etc>:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:948
#, no-wrap
msgid ""
"# B<mkdir -p /tmp/etc>\n"
"# B<mount --bind /mnt/etc /tmp/etc>\n"
"# B<cat /proc/self/mountinfo | egrep \\(aq/mnt|/tmp/\\(aq | sed \\(aqs/ - .*//\\(aq>\n"
"239 61 8:2 / /mnt ... shared:102\n"
"248 239 0:4 / /mnt/proc ... shared:5\n"
"267 40 8:2 /etc /tmp/etc ... shared:102\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:960
msgid ""
"Initially, these two mount points are in the same peer group, but we then "
"make the I</tmp/etc> a slave of I</mnt/etc>, and then make I</tmp/etc> "
"shared as well, so that it can propagate events to the next slave in the "
"chain:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:969
#, no-wrap
msgid ""
"# B<mount --make-slave /tmp/etc>\n"
"# B<mount --make-shared /tmp/etc>\n"
"# B<cat /proc/self/mountinfo | egrep \\(aq/mnt|/tmp/\\(aq | sed \\(aqs/ - .*//\\(aq>\n"
"239 61 8:2 / /mnt ... shared:102\n"
"248 239 0:4 / /mnt/proc ... shared:5\n"
"267 40 8:2 /etc /tmp/etc ... shared:105 master:102\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:981
msgid ""
"Then we bind mount I</tmp/etc> onto I</mnt/tmp/etc>.  Again, the two mount "
"points are initially in the same peer group, but we then make I</mnt/tmp/"
"etc> a slave of I</tmp/etc>:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:992
#, no-wrap
msgid ""
"# B<mkdir -p /mnt/tmp/etc>\n"
"# B<mount --bind /tmp/etc /mnt/tmp/etc>\n"
"# B<mount --make-slave /mnt/tmp/etc>\n"
"# B<cat /proc/self/mountinfo | egrep \\(aq/mnt|/tmp/\\(aq | sed \\(aqs/ - .*//\\(aq>\n"
"239 61 8:2 / /mnt ... shared:102\n"
"248 239 0:4 / /mnt/proc ... shared:5\n"
"267 40 8:2 /etc /tmp/etc ... shared:105 master:102\n"
"273 239 8:2 /etc /mnt/tmp/etc ... master:105\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:1001
msgid ""
"From the above, we see that I</mnt> is the master of the slave I</tmp/etc>, "
"which in turn is the master of the slave I</mnt/tmp/etc>."
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:1008
msgid ""
"We then B<chroot>(1)  to the I</mnt> directory, which renders the mount with "
"ID 267 unreachable from the (new) root directory:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:1012
#, no-wrap
msgid "# B<chroot /mnt>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:1017
msgid ""
"When we examine the state of the mounts inside the chroot-ed environment, we "
"see the following:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:1024
#, no-wrap
msgid ""
"# B<cat /proc/self/mountinfo | sed \\(aqs/ - .*//\\(aq>\n"
"239 61 8:2 / / ... shared:102\n"
"248 239 0:4 / /proc ... shared:5\n"
"273 239 8:2 /etc /tmp/etc ... master:105 propagate_from:102\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:1039
msgid ""
"Above, we see that the mount with ID 273 is a slave whose master is the peer "
"group 105.  The mount point for that master is unreachable, and so a "
"I<propagate_from> tag is displayed, indicating that the closest dominant "
"peer group (i.e., the nearest reachable mount in the slave chain)  is the "
"peer group with the ID 102 (corresponding to the I</mnt> mount point before "
"the B<chroot>(1)  was performed."
msgstr ""

#. type: SH
#: build/C/man7/mount_namespaces.7:1039
#, no-wrap
msgid "VERSIONS"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:1041
msgid "Mount namespaces first appeared in Linux 2.4.19."
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:1054
msgid ""
"The propagation type assigned to a new mount point depends on the "
"propagation type of the parent mount.  If the mount point has a parent (i."
"e., it is a non-root mount point) and the propagation type of the parent is "
"B<MS_SHARED>, then the propagation type of the new mount is also "
"B<MS_SHARED>.  Otherwise, the propagation type of the new mount is "
"B<MS_PRIVATE>."
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:1067
msgid ""
"Notwithstanding the fact that the default propagation type for new mount "
"points is in many cases B<MS_PRIVATE>, B<MS_SHARED> is typically more "
"useful.  For this reason, B<systemd>(1)  automatically remounts all mount "
"points as B<MS_SHARED> on system startup.  Thus, on most modern systems, the "
"default propagation type is in practice B<MS_SHARED>."
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:1082
msgid ""
"Since, when one uses B<unshare>(1)  to create a mount namespace, the goal is "
"commonly to provide full isolation of the mount points in the new namespace, "
"B<unshare>(1)  (since I<util-linux> version 2.27) in turn reverses the step "
"performed by B<systemd>(1), by making all mount points private in the new "
"namespace.  That is, B<unshare>(1)  performs the equivalent of the following "
"in the new mount namespace:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:1086
#, no-wrap
msgid "mount --make-rprivate /\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:1093
msgid ""
"To prevent this, one can use the I<--propagation\\ unchanged> option to "
"B<unshare>(1)."
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:1107
msgid ""
"An application that creates a new mount namespace directly using "
"B<clone>(2)  or B<unshare>(2)  may desire to prevent propagation of mount "
"events to other mount namespaces (as is done by B<unshare>(1)).  This can be "
"done by changing the propagation type of mount points in the new namespace "
"to either B<MS_SLAVE> or B<MS_PRIVATE>.  using a call such as the following:"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:1111
#, no-wrap
msgid "mount(NULL, \"/\", MS_SLAVE | MS_REC, NULL);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:1120
msgid ""
"For a discussion of propagation types when moving mounts (B<MS_MOVE>)  and "
"creating bind mounts (B<MS_BIND>), see I<Documentation/filesystems/"
"sharedsubtree.txt>."
msgstr ""

#. type: SH
#: build/C/man7/mount_namespaces.7:1120 build/C/man7/namespaces.7:412
#: build/C/man7/pid_namespaces.7:394 build/C/man7/time_namespaces.7:213
#: build/C/man7/user_namespaces.7:984
#, no-wrap
msgid "EXAMPLES"
msgstr "例"

#. type: Plain text
#: build/C/man7/mount_namespaces.7:1123
msgid "See B<pivot_root>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/mount_namespaces.7:1138
msgid ""
"B<unshare>(1), B<clone>(2), B<mount>(2), B<pivot_root>(2), B<setns>(2), "
"B<umount>(2), B<unshare>(2), B<proc>(5), B<namespaces>(7), "
"B<user_namespaces>(7), B<findmnt>(8), B<mount>(8), B<pivot_root>(8), "
"B<umount>(8)"
msgstr "B<unshare>(1), B<clone>(2), B<mount>(2), B<pivot_root>(2), B<setns>(2), B<umount>(2), B<unshare>(2), B<proc>(5), B<namespaces>(7), B<user_namespaces>(7), B<findmnt>(8), B<mount>(8), B<pivot_root>(8), B<umount>(8)"

#. type: Plain text
#: build/C/man7/mount_namespaces.7:1141
msgid ""
"I<Documentation/filesystems/sharedsubtree.txt> in the kernel source tree."
msgstr ""

#. type: TH
#: build/C/man7/namespaces.7:27
#, no-wrap
msgid "NAMESPACES"
msgstr "NAMESPACES"

#. type: Plain text
#: build/C/man7/namespaces.7:30
msgid "namespaces - overview of Linux namespaces"
msgstr "namespaces - Linux 名前空間の概要"

#. type: Plain text
#: build/C/man7/namespaces.7:37
msgid ""
"A namespace wraps a global system resource in an abstraction that makes it "
"appear to the processes within the namespace that they have their own "
"isolated instance of the global resource.  Changes to the global resource "
"are visible to other processes that are members of the namespace, but are "
"invisible to other processes.  One use of namespaces is to implement "
"containers."
msgstr ""
"名前空間は、 グローバルシステムリソースを抽象化層で覆うことで、 名前空間内の"
"プロセスに対して、 自分たちが専用の分離されたグローバルリソースを持っているか"
"のように見せる仕組みである。 グローバルリソースへの変更は、 名前空間のメン"
"バーである他のプロセスには見えるが、 それ以外のプロセスには見えない。 名前空"
"間の一つの利用方法はコンテナーの実装である。"

#
#. type: Plain text
#: build/C/man7/namespaces.7:43
#, fuzzy
#| msgid ""
#| "This page describes the various namespaces and the associated I</proc> "
#| "files, and summarizes the APIs for working with namespaces."
msgid ""
"This page provides pointers to information on the various namespace types, "
"describes the associated I</proc> files, and summarizes the APIs for working "
"with namespaces."
msgstr ""
"このページでは、各種の名前空間と関連する I</proc> ファイルの説明と、名前空間"
"とともに動作する API の概要を紹介する。"

#. type: SS
#: build/C/man7/namespaces.7:43
#, fuzzy, no-wrap
#| msgid "Namespace"
msgid "Namespace types"
msgstr "名前空間"

#. type: Plain text
#: build/C/man7/namespaces.7:51
msgid ""
"The following table shows the namespace types available on Linux.  The "
"second column of the table shows the flag value that is used to specify the "
"namespace type in various APIs.  The third column identifies the manual page "
"that provides details on the namespace type.  The last column is a summary "
"of the resources that are isolated by the namespace type."
msgstr ""

#. type: tbl table
#: build/C/man7/namespaces.7:54
#, no-wrap
msgid "Namespace"
msgstr "名前空間"

#. type: tbl table
#: build/C/man7/namespaces.7:54
#, no-wrap
msgid "Flag"
msgstr ""

#. type: tbl table
#: build/C/man7/namespaces.7:54
#, no-wrap
msgid "Page"
msgstr ""

#. type: tbl table
#: build/C/man7/namespaces.7:54
#, no-wrap
msgid "Isolates"
msgstr "分離対象"

#. type: tbl table
#: build/C/man7/namespaces.7:55
#, no-wrap
msgid "Cgroup"
msgstr ""

#. type: tbl table
#: build/C/man7/namespaces.7:55
#, no-wrap
msgid "CLONE_NEWCGROUP"
msgstr "CLONE_NEWCGROUP"

#
#. type: tbl table
#: build/C/man7/namespaces.7:55
#, no-wrap
msgid "B<cgroup_namespaces>(7)"
msgstr "B<cgroup_namespaces>(7)"

#. type: tbl table
#: build/C/man7/namespaces.7:55
#, no-wrap
msgid "Cgroup root directory"
msgstr ""

#. type: tbl table
#: build/C/man7/namespaces.7:56
#, no-wrap
msgid "IPC"
msgstr "IPC"

#. type: tbl table
#: build/C/man7/namespaces.7:56
#, no-wrap
msgid "CLONE_NEWIPC"
msgstr "CLONE_NEWIPC"

#
#. type: tbl table
#: build/C/man7/namespaces.7:56
#, no-wrap
msgid "B<ipc_namespaces>(7)"
msgstr "B<ipc_namespaces>(7)"

#. type: tbl table
#: build/C/man7/namespaces.7:58
#, no-wrap
msgid "System V IPC,\n"
msgstr "System V IPC,\n"

#. type: tbl table
#: build/C/man7/namespaces.7:58 build/C/man7/namespaces.7:63
#: build/C/man7/namespaces.7:70 build/C/man7/namespaces.7:76
#, no-wrap
msgid ".br\n"
msgstr ".br\n"

#. type: tbl table
#: build/C/man7/namespaces.7:60
#, no-wrap
msgid "POSIX message queues"
msgstr "POSIX メッセージキュー"

#. type: tbl table
#: build/C/man7/namespaces.7:61
#, no-wrap
msgid "Network"
msgstr "Network"

#. type: tbl table
#: build/C/man7/namespaces.7:61
#, no-wrap
msgid "CLONE_NEWNET"
msgstr "CLONE_NEWNET"

#. type: tbl table
#: build/C/man7/namespaces.7:61
#, no-wrap
msgid "B<network_namespaces>(7)"
msgstr "B<network_namespaces>(7)"

#. type: tbl table
#: build/C/man7/namespaces.7:63
#, no-wrap
msgid "Network devices,\n"
msgstr "ネットワークデバイス、\n"

#. type: tbl table
#: build/C/man7/namespaces.7:65
#, no-wrap
msgid "stacks, ports, etc."
msgstr "スタック、ポートなど"

#. type: tbl table
#: build/C/man7/namespaces.7:66
#, no-wrap
msgid "Mount"
msgstr "Mount"

#. type: tbl table
#: build/C/man7/namespaces.7:66
#, no-wrap
msgid "CLONE_NEWNS"
msgstr "CLONE_NEWNS"

#. type: tbl table
#: build/C/man7/namespaces.7:66
#, no-wrap
msgid "B<mount_namespaces>(7)"
msgstr "B<mount_namespaces>(7)"

#. type: tbl table
#: build/C/man7/namespaces.7:66
#, no-wrap
msgid "Mount points"
msgstr "マウントポイント"

#. type: tbl table
#: build/C/man7/namespaces.7:67
#, no-wrap
msgid "PID"
msgstr "PID"

#. type: tbl table
#: build/C/man7/namespaces.7:67
#, no-wrap
msgid "CLONE_NEWPID"
msgstr "CLONE_NEWPID"

#
#. type: tbl table
#: build/C/man7/namespaces.7:67
#, no-wrap
msgid "B<pid_namespaces>(7)"
msgstr "B<pid_namespaces>(7)"

#. type: tbl table
#: build/C/man7/namespaces.7:67
#, no-wrap
msgid "Process IDs"
msgstr "プロセス ID"

#. type: tbl table
#: build/C/man7/namespaces.7:68
#, no-wrap
msgid "Time"
msgstr ""

#. type: tbl table
#: build/C/man7/namespaces.7:68
#, no-wrap
msgid "CLONE_NEWTIME"
msgstr "CLONE_NEWTIME"

#
#. type: tbl table
#: build/C/man7/namespaces.7:68
#, no-wrap
msgid "B<time_namespaces>(7)"
msgstr "B<time_namespaces>(7)"

#. type: tbl table
#: build/C/man7/namespaces.7:70
#, no-wrap
msgid "Boot and monotonic\n"
msgstr ""

#. type: tbl table
#: build/C/man7/namespaces.7:72
#, no-wrap
msgid "clocks"
msgstr ""

#. type: tbl table
#: build/C/man7/namespaces.7:73
#, no-wrap
msgid "User"
msgstr "User"

#. type: tbl table
#: build/C/man7/namespaces.7:73
#, no-wrap
msgid "CLONE_NEWUSER"
msgstr "CLONE_NEWUSER"

#. type: tbl table
#: build/C/man7/namespaces.7:73
#, no-wrap
msgid "B<user_namespaces>(7)"
msgstr "B<user_namespaces>(7)"

#. type: tbl table
#: build/C/man7/namespaces.7:73
#, no-wrap
msgid "User and group IDs"
msgstr "ユーザー ID とグループ ID"

#. type: tbl table
#: build/C/man7/namespaces.7:74
#, no-wrap
msgid "UTS"
msgstr "UTS"

#. type: tbl table
#: build/C/man7/namespaces.7:74
#, no-wrap
msgid "CLONE_NEWUTS"
msgstr "CLONE_NEWUTS"

#. type: tbl table
#: build/C/man7/namespaces.7:74
#, no-wrap
msgid "B<uts_namespaces>(7)"
msgstr "B<uts_namespaces>(7)"

#. type: tbl table
#: build/C/man7/namespaces.7:76
#, no-wrap
msgid "Hostname and NIS\n"
msgstr "ホスト名と NIS\n"

#. type: tbl table
#: build/C/man7/namespaces.7:78
#, no-wrap
msgid "domain name"
msgstr "ドメイン名"

#.  ==================== The namespaces API ====================
#. type: SS
#: build/C/man7/namespaces.7:83
#, no-wrap
msgid "The namespaces API"
msgstr "名前空間 API"

#. type: Plain text
#: build/C/man7/namespaces.7:88
msgid ""
"As well as various I</proc> files described below, the namespaces API "
"includes the following system calls:"
msgstr ""
"後で説明する種々の I</proc> ファイル以外に、名前空間 API として以下のシステム"
"コールがある。"

#. type: TP
#: build/C/man7/namespaces.7:88
#, no-wrap
msgid "B<clone>(2)"
msgstr "B<clone>(2)"

#. type: Plain text
#: build/C/man7/namespaces.7:101
msgid ""
"The B<clone>(2)  system call creates a new process.  If the I<flags> "
"argument of the call specifies one or more of the B<CLONE_NEW*> flags listed "
"below, then new namespaces are created for each flag, and the child process "
"is made a member of those namespaces.  (This system call also implements a "
"number of features unrelated to namespaces.)"
msgstr ""
"B<clone>(2) システムコールは新しいプロセスを作成する。 呼び出し時に I<flags> "
"引数で以下のリストにある B<CLONE_NEW*> のフラグを一つ以上指定すると、 各フ"
"ラグに対応する新しい名前空間が作成され、 子プロセスはこれらの名前空間のメン"
"バーになる。 (このシステムコールは名前空間とは関係のない機能も多数実装してい"
"る。)"

#. type: TP
#: build/C/man7/namespaces.7:101
#, no-wrap
msgid "B<setns>(2)"
msgstr "B<setns>(2)"

#. type: Plain text
#: build/C/man7/namespaces.7:110
msgid ""
"The B<setns>(2)  system call allows the calling process to join an existing "
"namespace.  The namespace to join is specified via a file descriptor that "
"refers to one of the I</proc/[pid]/ns> files described below."
msgstr ""
"B<setns>(2) システムコールを使うと、呼び出したプロセスを既存の名前空間に参加"
"させることができる。 参加する名前空間は、 以下で説明する I</proc/[pid]/ns> "
"ファイルのいずれか一つを参照するファイルディスクリプターを使って指定する。"

#. type: TP
#: build/C/man7/namespaces.7:110
#, no-wrap
msgid "B<unshare>(2)"
msgstr "B<unshare>(2)"

#. type: Plain text
#: build/C/man7/namespaces.7:123
msgid ""
"The B<unshare>(2)  system call moves the calling process to a new "
"namespace.  If the I<flags> argument of the call specifies one or more of "
"the B<CLONE_NEW*> flags listed below, then new namespaces are created for "
"each flag, and the calling process is made a member of those namespaces.  "
"(This system call also implements a number of features unrelated to "
"namespaces.)"
msgstr ""
"B<unshare>(2) システムコールは、 呼び出したプロセスを新しい名前空間に移動す"
"る。 呼び出し時の I<flags> 引数に以下のリストにある B<CLONE_NEW*> フラグを"
"一つ以上指定すると、 各フラグに対応する新しい名前空間が作成され、 呼び出した"
"プロセスがこれらの名前空間のメンバーになる。 (このシステムコールは名前空間と"
"は関係のない機能も多数実装している。)"

#. type: TP
#: build/C/man7/namespaces.7:123
#, no-wrap
msgid "B<ioctl>(2)"
msgstr "B<ioctl>(2)"

#. type: Plain text
#: build/C/man7/namespaces.7:130
msgid ""
"Various B<ioctl>(2)  operations can be used to discover information about "
"namespaces.  These operations are described in B<ioctl_ns>(2)."
msgstr ""

#
#.  ==================== The /proc/[pid]/ns/ directory ====================
#. type: Plain text
#: build/C/man7/namespaces.7:146
#, fuzzy
#| msgid ""
#| "Creation of new namespaces using B<clone>(2)  and B<unshare>(2)  in most "
#| "cases requires the B<CAP_SYS_ADMIN> capability.  User namespaces are the "
#| "exception: since Linux 3.8, no privilege is required to create a user "
#| "namespace."
msgid ""
"Creation of new namespaces using B<clone>(2)  and B<unshare>(2)  in most "
"cases requires the B<CAP_SYS_ADMIN> capability, since, in the new namespace, "
"the creator will have the power to change global resources that are visible "
"to other processes that are subsequently created in, or join the namespace.  "
"User namespaces are the exception: since Linux 3.8, no privilege is required "
"to create a user namespace."
msgstr ""
"B<clone>(2) と B<unshare>(2) を使った新しい名前空間の作成のほとんどの場合で "
"B<CAP_SYS_ADMIN> ケーパビリティが必要である。 ユーザー名前空間は例外で、 "
"Linux 3.8 以降ではユーザー名前空間を作成するのに特権が不要である。"

#. type: SS
#: build/C/man7/namespaces.7:146
#, no-wrap
msgid "The /proc/[pid]/ns/ directory"
msgstr "/proc/[pid]/ns/ ディレクトリ"

#.  See commit 6b4e306aa3dc94a0545eb9279475b1ab6209a31f
#. type: Plain text
#: build/C/man7/namespaces.7:153
msgid ""
"Each process has a I</proc/[pid]/ns/> subdirectory containing one entry for "
"each namespace that supports being manipulated by B<setns>(2):"
msgstr ""
"各プロセスには I</proc/[pid]/ns/> サブディレクトリがあり、 このサブディレクト"
"リには B<setns>(2) での操作がサポートされている名前空間単位にエントリーが存在"
"する。"

#. type: Plain text
#: build/C/man7/namespaces.7:168
#, no-wrap
msgid ""
"$ B<ls -l /proc/$$/ns | awk \\(aq{print $1, $9, $10, $11}\\(aq>\n"
"total 0\n"
"lrwxrwxrwx. cgroup -E<gt> cgroup:[4026531835]\n"
"lrwxrwxrwx. ipc -E<gt> ipc:[4026531839]\n"
"lrwxrwxrwx. mnt -E<gt> mnt:[4026531840]\n"
"lrwxrwxrwx. net -E<gt> net:[4026531969]\n"
"lrwxrwxrwx. pid -E<gt> pid:[4026531836]\n"
"lrwxrwxrwx. pid_for_children -E<gt> pid:[4026531834]\n"
"lrwxrwxrwx. time -E<gt> time:[4026531834]\n"
"lrwxrwxrwx. time_for_children -E<gt> time:[4026531834]\n"
"lrwxrwxrwx. user -E<gt> user:[4026531837]\n"
"lrwxrwxrwx. uts -E<gt> uts:[4026531838]\n"
msgstr ""
"$ B<ls -l /proc/$$/ns | awk \\(aq{print $1, $9, $10, $11}\\(aq>\n"
"total 0\n"
"lrwxrwxrwx. cgroup -E<gt> cgroup:[4026531835]\n"
"lrwxrwxrwx. ipc -E<gt> ipc:[4026531839]\n"
"lrwxrwxrwx. mnt -E<gt> mnt:[4026531840]\n"
"lrwxrwxrwx. net -E<gt> net:[4026531969]\n"
"lrwxrwxrwx. pid -E<gt> pid:[4026531836]\n"
"lrwxrwxrwx. pid_for_children -E<gt> pid:[4026531834]\n"
"lrwxrwxrwx. time -E<gt> time:[4026531834]\n"
"lrwxrwxrwx. time_for_children -E<gt> time:[4026531834]\n"
"lrwxrwxrwx. user -E<gt> user:[4026531837]\n"
"lrwxrwxrwx. uts -E<gt> uts:[4026531838]\n"

#. type: Plain text
#: build/C/man7/namespaces.7:178
msgid ""
"Bind mounting (see B<mount>(2))  one of the files in this directory to "
"somewhere else in the filesystem keeps the corresponding namespace of the "
"process specified by I<pid> alive even if all processes currently in the "
"namespace terminate."
msgstr ""
"このディレクトリ内のファイルのいずれかをファイルシステムの他のどこかにバイン"
"ドマウント (B<mount>(2) 参照) することで、 その名前空間のすべてのプロセスが終"
"了した場合でも、 I<pid> で指定したプロセスの対応する名前空間を保持することが"
"できる。"

#. type: Plain text
#: build/C/man7/namespaces.7:189
msgid ""
"Opening one of the files in this directory (or a file that is bind mounted "
"to one of these files)  returns a file handle for the corresponding "
"namespace of the process specified by I<pid>.  As long as this file "
"descriptor remains open, the namespace will remain alive, even if all "
"processes in the namespace terminate.  The file descriptor can be passed to "
"B<setns>(2)."
msgstr ""
"このディレクトリ内のファイルのいずれか (またはこれらのファイルのいずれかにバ"
"インドマウントされたファイル) をオープンすると、 I<pid> で指定されたプロセス"
"の対応する名前空間に対するファイルハンドルが返される。 このファイルディスクリ"
"プターがオープンされている限り、 その名前空間のすべてのプロセスが終了した場合"
"であっても、 その名前空間は存在し続ける。 このファイルディスクリプターは "
"B<setns>(2) に渡すことができる。"

#.  commit bf056bfa80596a5d14b26b17276a56a0dcb080e5
#.  Eric Biederman: "I reserve the right for st_dev to be significant
#.  when comparing namespaces."
#.  https://lore.kernel.org/lkml/87poky5ca9.fsf@xmission.com/
#.  Re: Documenting the ioctl interfaces to discover relationships...
#.  Date: Mon, 12 Dec 2016 11:30:38 +1300
#. type: Plain text
#: build/C/man7/namespaces.7:210
#, fuzzy
#| msgid ""
#| "In Linux 3.7 and earlier, these files were visible as hard links.  Since "
#| "Linux 3.8, they appear as symbolic links.  If two processes are in the "
#| "same namespace, then the inode numbers of their I</proc/[pid]/ns/xxx> "
#| "symbolic links will be the same; an application can check this using the "
#| "I<stat.st_ino> field returned by B<stat>(2).  The content of this "
#| "symbolic link is a string containing the namespace type and inode number "
#| "as in the following example:"
msgid ""
"In Linux 3.7 and earlier, these files were visible as hard links.  Since "
"Linux 3.8, they appear as symbolic links.  If two processes are in the same "
"namespace, then the device IDs and inode numbers of their I</proc/[pid]/ns/"
"xxx> symbolic links will be the same; an application can check this using "
"the I<stat.st_dev> and I<stat.st_ino> fields returned by B<stat>(2).  The "
"content of this symbolic link is a string containing the namespace type and "
"inode number as in the following example:"
msgstr ""
"Linux 3.7 以前では、これらのファイルはハードリンクとして見えていた。 Linux "
"3.8 以降では、これらはシンボリックリンクとして見える。 2 つのプロセスが同じ名"
"前空間に所属している場合、 これらのプロセスの I</proc/[pid]/ns/xxx> シンボ"
"リックリンクの inode 番号は同じになる。 アプリケーションは、 B<stat>(2) が返"
"す I<stat.st_ino> フィールドを使ってこれを確認することができる。 シンボリック"
"リンクの内容は、 以下の例にあるように、名前空間種別と inode 番号を含む文字列"
"である。"

#. type: Plain text
#: build/C/man7/namespaces.7:215
#, no-wrap
msgid ""
"$ B<readlink /proc/$$/ns/uts>\n"
"uts:[4026531838]\n"
msgstr ""
"$ B<readlink /proc/$$/ns/uts>\n"
"uts:[4026531838]\n"

#. type: Plain text
#: build/C/man7/namespaces.7:219
#, fuzzy
#| msgid "The files in this subdirectory are as follows:"
msgid "The symbolic links in this subdirectory are as follows:"
msgstr "このサブディレクトリのファイルは以下のとおりである。"

#. type: TP
#: build/C/man7/namespaces.7:219
#, fuzzy, no-wrap
#| msgid "I</proc/[pid]/ns/ipc> (since Linux 3.0)"
msgid "I</proc/[pid]/ns/cgroup> (since Linux 4.6)"
msgstr "I</proc/[pid]/ns/ipc> (Linux 3.0 以降)"

#. type: Plain text
#: build/C/man7/namespaces.7:222
#, fuzzy
#| msgid "This file is a handle for the mount namespace of the process."
msgid "This file is a handle for the cgroup namespace of the process."
msgstr "このファイルはそのプロセスのマウント名前空間の操作用である。"

#. type: TP
#: build/C/man7/namespaces.7:222
#, no-wrap
msgid "I</proc/[pid]/ns/ipc> (since Linux 3.0)"
msgstr "I</proc/[pid]/ns/ipc> (Linux 3.0 以降)"

#. type: Plain text
#: build/C/man7/namespaces.7:225
msgid "This file is a handle for the IPC namespace of the process."
msgstr "このファイルはそのプロセスの IPC 名前空間の操作用である。"

#. type: TP
#: build/C/man7/namespaces.7:225
#, no-wrap
msgid "I</proc/[pid]/ns/mnt> (since Linux 3.8)"
msgstr "I</proc/[pid]/ns/mnt> (Linux 3.8 以降)"

#.  commit 8823c079ba7136dc1948d6f6dcb5f8022bde438e
#. type: Plain text
#: build/C/man7/namespaces.7:229
msgid "This file is a handle for the mount namespace of the process."
msgstr "このファイルはそのプロセスのマウント名前空間の操作用である。"

#. type: TP
#: build/C/man7/namespaces.7:229
#, no-wrap
msgid "I</proc/[pid]/ns/net> (since Linux 3.0)"
msgstr "I</proc/[pid]/ns/net> (Linux 3.0 以降)"

#. type: Plain text
#: build/C/man7/namespaces.7:232
msgid "This file is a handle for the network namespace of the process."
msgstr "このファイルはそのプロセスのネットワーク名前空間の操作用である。"

#. type: TP
#: build/C/man7/namespaces.7:232
#, no-wrap
msgid "I</proc/[pid]/ns/pid> (since Linux 3.8)"
msgstr "I</proc/[pid]/ns/pid> (Linux 3.8 以降)"

#.  commit 57e8391d327609cbf12d843259c968b9e5c1838f
#. type: Plain text
#: build/C/man7/namespaces.7:238
msgid ""
"This file is a handle for the PID namespace of the process.  This handle is "
"permanent for the lifetime of the process (i.e., a process's PID namespace "
"membership never changes)."
msgstr ""

#. type: TP
#: build/C/man7/namespaces.7:238
#, fuzzy, no-wrap
#| msgid "I</proc/[pid]/ns/pid> (since Linux 3.8)"
msgid "I</proc/[pid]/ns/pid_for_children> (since Linux 4.12)"
msgstr "I</proc/[pid]/ns/pid> (Linux 3.8 以降)"

#.  commit eaa0d190bfe1ed891b814a52712dcd852554cb08
#. type: Plain text
#: build/C/man7/namespaces.7:256
msgid ""
"This file is a handle for the PID namespace of child processes created by "
"this process.  This can change as a consequence of calls to B<unshare>(2)  "
"and B<setns>(2)  (see B<pid_namespaces>(7)), so the file may differ from I</"
"proc/[pid]/ns/pid>.  The symbolic link gains a value only after the first "
"child process is created in the namespace.  (Beforehand, B<readlink>(2)  of "
"the symbolic link will return an empty buffer.)"
msgstr ""

#. type: TP
#: build/C/man7/namespaces.7:256
#, fuzzy, no-wrap
#| msgid "I</proc/[pid]/ns/ipc> (since Linux 3.0)"
msgid "I</proc/[pid]/ns/time> (since Linux 5.6)"
msgstr "I</proc/[pid]/ns/ipc> (Linux 3.0 以降)"

#. type: Plain text
#: build/C/man7/namespaces.7:259
#, fuzzy
#| msgid "This file is a handle for the user namespace of the process."
msgid "This file is a handle for the time namespace of the process."
msgstr "このファイルはそのプロセスのユーザー名前空間の操作用である。"

#. type: TP
#: build/C/man7/namespaces.7:259
#, fuzzy, no-wrap
#| msgid "I</proc/[pid]/ns/ipc> (since Linux 3.0)"
msgid "I</proc/[pid]/ns/time_for_children> (since Linux 5.6)"
msgstr "I</proc/[pid]/ns/ipc> (Linux 3.0 以降)"

#. type: Plain text
#: build/C/man7/namespaces.7:271
msgid ""
"This file is a handle for the time namespace of child processes created by "
"this process.  This can change as a consequence of calls to B<unshare>(2)  "
"and B<setns>(2)  (see B<time_namespaces>(7)), so the file may differ from I</"
"proc/[pid]/ns/time>."
msgstr ""

#. type: TP
#: build/C/man7/namespaces.7:271
#, no-wrap
msgid "I</proc/[pid]/ns/user> (since Linux 3.8)"
msgstr "I</proc/[pid]/ns/user> (Linux 3.8 以降)"

#.  commit cde1975bc242f3e1072bde623ef378e547b73f91
#. type: Plain text
#: build/C/man7/namespaces.7:275
msgid "This file is a handle for the user namespace of the process."
msgstr "このファイルはそのプロセスのユーザー名前空間の操作用である。"

#. type: TP
#: build/C/man7/namespaces.7:275
#, no-wrap
msgid "I</proc/[pid]/ns/uts> (since Linux 3.0)"
msgstr "I</proc/[pid]/ns/uts> (Linux 3.0 以降)"

#
#. type: Plain text
#: build/C/man7/namespaces.7:278
msgid "This file is a handle for the UTS namespace of the process."
msgstr "このファイルはそのプロセスの UTS 名前空間の操作用である。"

#
#.  ==================== The /proc/sys/user directory ====================
#. type: Plain text
#: build/C/man7/namespaces.7:288
msgid ""
"Permission to dereference or read (B<readlink>(2))  these symbolic links is "
"governed by a ptrace access mode B<PTRACE_MODE_READ_FSCREDS> check; see "
"B<ptrace>(2)."
msgstr ""

#. type: SS
#: build/C/man7/namespaces.7:288
#, fuzzy, no-wrap
#| msgid "The /proc/[pid]/ns/ directory"
msgid "The /proc/sys/user directory"
msgstr "/proc/[pid]/ns/ ディレクトリ"

#. type: Plain text
#: build/C/man7/namespaces.7:294
msgid ""
"The files in the I</proc/sys/user> directory (which is present since Linux "
"4.9) expose limits on the number of namespaces of various types that can be "
"created.  The files are as follows:"
msgstr ""

#. type: TP
#: build/C/man7/namespaces.7:294
#, no-wrap
msgid "I<max_cgroup_namespaces>"
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:298
msgid ""
"The value in this file defines a per-user limit on the number of cgroup "
"namespaces that may be created in the user namespace."
msgstr ""

#
#. type: TP
#: build/C/man7/namespaces.7:298
#, fuzzy, no-wrap
#| msgid "See B<pid_namespaces>(7)."
msgid "I<max_ipc_namespaces>"
msgstr "B<pid_namespaces>(7) 参照。"

#. type: Plain text
#: build/C/man7/namespaces.7:302
msgid ""
"The value in this file defines a per-user limit on the number of ipc "
"namespaces that may be created in the user namespace."
msgstr ""

#. type: TP
#: build/C/man7/namespaces.7:302
#, no-wrap
msgid "I<max_mnt_namespaces>"
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:306
msgid ""
"The value in this file defines a per-user limit on the number of mount "
"namespaces that may be created in the user namespace."
msgstr ""

#. type: TP
#: build/C/man7/namespaces.7:306
#, no-wrap
msgid "I<max_net_namespaces>"
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:310
msgid ""
"The value in this file defines a per-user limit on the number of network "
"namespaces that may be created in the user namespace."
msgstr ""

#
#. type: TP
#: build/C/man7/namespaces.7:310
#, fuzzy, no-wrap
#| msgid "See B<pid_namespaces>(7)."
msgid "I<max_pid_namespaces>"
msgstr "B<pid_namespaces>(7) 参照。"

#. type: Plain text
#: build/C/man7/namespaces.7:314
msgid ""
"The value in this file defines a per-user limit on the number of PID "
"namespaces that may be created in the user namespace."
msgstr ""

#. type: TP
#: build/C/man7/namespaces.7:314
#, fuzzy, no-wrap
#| msgid "I</proc/[pid]/ns/ipc> (since Linux 3.0)"
msgid "I<max_time_namespaces> (since Linux 5.7)"
msgstr "I</proc/[pid]/ns/ipc> (Linux 3.0 以降)"

#.  commit eeec26d5da8248ea4e240b8795bb4364213d3247
#. type: Plain text
#: build/C/man7/namespaces.7:319
msgid ""
"The value in this file defines a per-user limit on the number of time "
"namespaces that may be created in the user namespace."
msgstr ""

#. type: TP
#: build/C/man7/namespaces.7:319
#, fuzzy, no-wrap
#| msgid "See B<user_namespaces>(7)."
msgid "I<max_user_namespaces>"
msgstr "B<user_namespaces>(7) 参照。"

#. type: Plain text
#: build/C/man7/namespaces.7:323
#, fuzzy
#| msgid ""
#| "The length of the range of user IDs that is mapped between the two user "
#| "namespaces."
msgid ""
"The value in this file defines a per-user limit on the number of user "
"namespaces that may be created in the user namespace."
msgstr "2 つのユーザー名前空間間でマッピングされるユーザー ID の範囲の長さ。"

#. type: TP
#: build/C/man7/namespaces.7:323
#, fuzzy, no-wrap
#| msgid "See B<user_namespaces>(7)."
msgid "I<max_uts_namespaces>"
msgstr "B<user_namespaces>(7) 参照。"

#. type: Plain text
#: build/C/man7/namespaces.7:327
msgid ""
"The value in this file defines a per-user limit on the number of uts "
"namespaces that may be created in the user namespace."
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:329
#, fuzzy
#| msgid "Note the following points with respect to mount namespaces:"
msgid "Note the following details about these files:"
msgstr "マウント名前空間に関しては以下の点に注意すること。"

#. type: Plain text
#: build/C/man7/namespaces.7:331
msgid "The values in these files are modifiable by privileged processes."
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:334
#, fuzzy
#| msgid "This file is a handle for the user namespace of the process."
msgid ""
"The values exposed by these files are the limits for the user namespace in "
"which the opening process resides."
msgstr "このファイルはそのプロセスのユーザー名前空間の操作用である。"

#. type: Plain text
#: build/C/man7/namespaces.7:338
msgid ""
"The limits are per-user.  Each user in the same user namespace can create "
"namespaces up to the defined limit."
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:340
msgid "The limits apply to all users, including UID 0."
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:343
msgid ""
"These limits apply in addition to any other per-namespace limits (such as "
"those for PID and user namespaces) that may be enforced."
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:350
msgid ""
"Upon encountering these limits, B<clone>(2)  and B<unshare>(2)  fail with "
"the error B<ENOSPC>."
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:357
msgid ""
"For the initial user namespace, the default value in each of these files is "
"half the limit on the number of threads that may be created (I</proc/sys/"
"kernel/threads-max>).  In all descendant user namespaces, the default value "
"in each file is B<MAXINT>."
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:361
msgid ""
"When a namespace is created, the object is also accounted against ancestor "
"namespaces.  More precisely:"
msgstr ""

#. type: IP
#: build/C/man7/namespaces.7:362 build/C/man7/namespaces.7:364
#: build/C/man7/namespaces.7:370 build/C/man7/user_namespaces.7:587
#: build/C/man7/user_namespaces.7:596 build/C/man7/user_namespaces.7:604
#: build/C/man7/user_namespaces.7:607
#, no-wrap
msgid "+"
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:364
msgid "Each user namespace has a creator UID."
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:370
msgid ""
"When a namespace is created, it is accounted against the creator UIDs in "
"each of the ancestor user namespaces, and the kernel ensures that the "
"corresponding namespace limit for the creator UID in the ancestor namespace "
"is not exceeded."
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:374
msgid ""
"The aforementioned point ensures that creating a new user namespace cannot "
"be used as a means to escape the limits in force in the current user "
"namespace."
msgstr ""

#. type: SS
#: build/C/man7/namespaces.7:376
#, fuzzy, no-wrap
#| msgid "Namespace"
msgid "Namespace lifetime"
msgstr "名前空間"

#. type: Plain text
#: build/C/man7/namespaces.7:383
msgid ""
"Absent any other factors, a namespace is automatically torn down when the "
"last process in the namespace terminates or leaves the namespace.  However, "
"there are a number of other factors that may pin a namespace into existence "
"even though it has no member processes.  These factors include the following:"
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:387
msgid ""
"An open file descriptor or a bind mount exists for the corresponding I</proc/"
"[pid]/ns/*> file."
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:390
msgid ""
"The namespace is hierarchical (i.e., a PID or user namespace), and has a "
"child namespace."
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:392
#, fuzzy
#| msgid "Interaction of user namespaces and other types of namespaces"
msgid "It is a user namespace that owns one or more nonuser namespaces."
msgstr "ユーザー名前空間と他の名前空間の関係"

#. type: Plain text
#: build/C/man7/namespaces.7:397
msgid ""
"It is a PID namespace, and there is a process that refers to the namespace "
"via a I</proc/[pid]/ns/pid_for_children> symbolic link."
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:402
msgid ""
"It is a time namespace, and there is a process that refers to the namespace "
"via a I</proc/[pid]/ns/time_for_children> symbolic link."
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:408
msgid ""
"It is an IPC namespace, and a corresponding mount of an I<mqueue> filesystem "
"(see B<mq_overview>(7))  refers to this namespace."
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:412
msgid ""
"It is a PID namespace, and a corresponding mount of a B<proc>(5)  filesystem "
"refers to this namespace."
msgstr ""

#. type: Plain text
#: build/C/man7/namespaces.7:417
#, fuzzy
#| msgid "See B<user_namespaces>(7)."
msgid "See B<clone>(2)  and B<user_namespaces>(7)."
msgstr "B<user_namespaces>(7) 参照。"

#. type: Plain text
#: build/C/man7/namespaces.7:438
#, fuzzy
#| msgid ""
#| "B<nsenter>(1), B<readlink>(1), B<unshare>(1), B<clone>(2), B<setns>(2), "
#| "B<unshare>(2), B<proc>(5), B<credentials>(7), B<capabilities>(7), "
#| "B<pid_namespaces>(7), B<user_namespaces>(7), B<switch_root>(8)"
msgid ""
"B<nsenter>(1), B<readlink>(1), B<unshare>(1), B<clone>(2), B<ioctl_ns>(2), "
"B<setns>(2), B<unshare>(2), B<proc>(5), B<capabilities>(7), "
"B<cgroup_namespaces>(7), B<cgroups>(7), B<credentials>(7), "
"B<ipc_namespaces>(7), B<network_namespaces>(7), B<pid_namespaces>(7), "
"B<user_namespaces>(7), B<uts_namespaces>(7), B<lsns>(8), "
"B<pam_namespace>(8), B<switch_root>(8)"
msgstr ""
"B<nsenter>(1), B<readlink>(1), B<unshare>(1), B<clone>(2), B<setns>(2), "
"B<unshare>(2), B<proc>(5), B<credentials>(7), B<capabilities>(7), "
"B<pid_namespaces>(7), B<user_namespaces>(7), B<switch_root>(8)"

#. type: TH
#: build/C/man7/network_namespaces.7:26
#, fuzzy, no-wrap
#| msgid "USER_NAMESPACES"
msgid "NETWORK_NAMESPACES"
msgstr "USER_NAMESPACES"

#. type: TH
#: build/C/man7/network_namespaces.7:26 build/C/man7/time_namespaces.7:26
#, no-wrap
msgid "2020-06-09"
msgstr ""

#. type: Plain text
#: build/C/man7/network_namespaces.7:29
#, fuzzy
#| msgid "user_namespaces - overview of Linux user namespaces"
msgid "network_namespaces - overview of Linux network namespaces"
msgstr "user_namespaces - Linux ユーザー名前空間の概要"

#. type: Plain text
#: build/C/man7/network_namespaces.7:44
#, fuzzy
#| msgid ""
#| "Network namespaces provide isolation of the system resources associated "
#| "with networking: network devices, IPv4 and IPv6 protocol stacks, IP "
#| "routing tables, firewalls, the I</proc/net> directory, the I</sys/class/"
#| "net> directory, port numbers (sockets), and so on.  A physical network "
#| "device can live in exactly one network namespace.  A virtual network "
#| "device (\"veth\") pair provides a pipe-like abstraction that can be used "
#| "to create tunnels between network namespaces, and can be used to create a "
#| "bridge to a physical network device in another namespace."
msgid ""
"Network namespaces provide isolation of the system resources associated with "
"networking: network devices, IPv4 and IPv6 protocol stacks, IP routing "
"tables, firewall rules, the I</proc/net> directory (which is a symbolic link "
"to I</proc/PID/net>), the I</sys/class/net> directory, various files under "
"I</proc/sys/net>, port numbers (sockets), and so on.  In addition, network "
"namespaces isolate the UNIX domain abstract socket namespace (see "
"B<unix>(7))."
msgstr ""
"ネットワーク名前空間は、 ネットワークに関連するシステムリソースの分離を提供す"
"る。 分離されるリソースは、 ネットワークデバイス、 IPv4 と IPv6 のプロトコル"
"スタック、 IP ルーティングテーブル、 ファイアウォール、 I</proc/net> ディレク"
"トリ、 I</sys/class/net> ディレクトリ、 (ソケットの) ポート番号などである。 "
"物理ネットワークデバイスは 1 つのネットワーク名前空間にのみ属すことができ"
"る。 仮想ネットワークデバイス (\"veth\") ペアは、 ネットワーク名前空間間のト"
"ンネルを作成するのに使うことができるパイプ風の抽象概念で、 別の名前空間に属す"
"物理ネットワークデバイスへのブリッジを作成するのに使用できる。"

#. type: Plain text
#: build/C/man7/network_namespaces.7:51
#, fuzzy
#| msgid ""
#| "When a network namespace is freed (i.e., when the last process in the "
#| "namespace terminates), its physical network devices are moved back to the "
#| "initial network namespace (not to the parent of the process)."
msgid ""
"A physical network device can live in exactly one network namespace.  When a "
"network namespace is freed (i.e., when the last process in the namespace "
"terminates), its physical network devices are moved back to the initial "
"network namespace (not to the parent of the process)."
msgstr ""
"ネットワーク名前空間が解放されたときに (すなわち、その名前空間の最後のプロセ"
"スがしゅうりょうしたときに)、 その名前空間に属していた物理ネットワークデバイ"
"スは初期ネットワーク名前空間に戻される (プロセスの親プロセスに戻されるわけで"
"はない)。"

#. type: Plain text
#: build/C/man7/network_namespaces.7:61
msgid ""
"A virtual network (B<veth>(4))  device pair provides a pipe-like abstraction "
"that can be used to create tunnels between network namespaces, and can be "
"used to create a bridge to a physical network device in another namespace.  "
"When a namespace is freed, the B<veth>(4)  devices that it contains are "
"destroyed."
msgstr ""

#
#.  FIXME .SH EXAMPLES
#. type: Plain text
#: build/C/man7/network_namespaces.7:66
msgid ""
"Use of network namespaces requires a kernel that is configured with the "
"B<CONFIG_NET_NS> option."
msgstr ""
"ネットワーク名前空間を使用するには、設定 B<CONFIG_NET_NS> が有効になったカー"
"ネルが必要である。"

#. type: Plain text
#: build/C/man7/network_namespaces.7:82
#, fuzzy
#| msgid ""
#| "B<nsenter>(1), B<readlink>(1), B<unshare>(1), B<clone>(2), B<setns>(2), "
#| "B<unshare>(2), B<proc>(5), B<credentials>(7), B<capabilities>(7), "
#| "B<pid_namespaces>(7), B<user_namespaces>(7), B<switch_root>(8)"
msgid ""
"B<nsenter>(1), B<unshare>(1), B<clone>(2), B<veth>(4), B<proc>(5), "
"B<sysfs>(5), B<namespaces>(7), B<user_namespaces>(7), B<brctl>(8), B<ip>(8), "
"B<ip-address>(8), B<ip-link>(8), B<ip-netns>(8), B<iptables>(8), B<ovs-"
"vsctl>(8)"
msgstr ""
"B<nsenter>(1), B<readlink>(1), B<unshare>(1), B<clone>(2), B<setns>(2), "
"B<unshare>(2), B<proc>(5), B<credentials>(7), B<capabilities>(7), "
"B<pid_namespaces>(7), B<user_namespaces>(7), B<switch_root>(8)"

#. type: TH
#: build/C/man7/pid_namespaces.7:27
#, no-wrap
msgid "PID_NAMESPACES"
msgstr "PID_NAMESPACES"

#. type: Plain text
#: build/C/man7/pid_namespaces.7:30
msgid "pid_namespaces - overview of Linux PID namespaces"
msgstr "pid_namespaces - Linux PID 名前空間の概要"

#. type: Plain text
#: build/C/man7/pid_namespaces.7:40
msgid ""
"PID namespaces isolate the process ID number space, meaning that processes "
"in different PID namespaces can have the same PID.  PID namespaces allow "
"containers to provide functionality such as suspending/resuming the set of "
"processes in the container and migrating the container to a new host while "
"the processes inside the container maintain the same PIDs."
msgstr ""
"PID 名前空間はプロセス ID 番号空間を分離する。 これは、異なる PID 名前空間の"
"プロセスは同じ PID を持つことができることを意味する。 PID 名前空間を使うこと"
"で、コンテナー内のプロセス群を中断、再開したり、 コンテナー内のプロセスの "
"PID を保持したままコンテナーを新しいホストに移行したりするといった機能をコン"
"テナーが提供することが可能になる。"

#. type: Plain text
#: build/C/man7/pid_namespaces.7:48
msgid ""
"PIDs in a new PID namespace start at 1, somewhat like a standalone system, "
"and calls to B<fork>(2), B<vfork>(2), or B<clone>(2)  will produce processes "
"with PIDs that are unique within the namespace."
msgstr ""
"新しい PID 名前空間の PID は、 独立したシステムであるかのように、 1 から始ま"
"る。 B<fork>(2), B<vfork>(2), B<clone>(2) を呼び出すと、 その名前空間内で一意"
"な PID でプロセスが生成される。"

#
#.  ============================================================
#. type: Plain text
#: build/C/man7/pid_namespaces.7:55
msgid ""
"Use of PID namespaces requires a kernel that is configured with the "
"B<CONFIG_PID_NS> option."
msgstr ""
"PID 名前空間を使用するには、設定 B<CONFIG_PID_NS> が有効になったカーネルが必"
"要である。"

#. type: SS
#: build/C/man7/pid_namespaces.7:55
#, no-wrap
msgid "The namespace init process"
msgstr "名前空間の init プロセス"

#. type: Plain text
#: build/C/man7/pid_namespaces.7:70
#, fuzzy
#| msgid ""
#| "The first process created in a new namespace (i.e., the process created "
#| "using B<clone>(2)  with the B<CLONE_NEWPID> flag, or the first child "
#| "created by a process after a call to B<unshare>(2)  using the "
#| "B<CLONE_NEWPID> flag) has the PID 1, and is the \"init\" process for the "
#| "namespace (see B<init>(1)).  A child process that is orphaned within the "
#| "namespace will be reparented to this process rather than B<init>(1)  "
#| "(unless one of the ancestors of the child in the same PID namespace "
#| "employed the B<prctl>(2)  B<PR_SET_CHILD_SUBREAPER> command to mark "
#| "itself as the reaper of orphaned descendant processes)."
msgid ""
"The first process created in a new namespace (i.e., the process created "
"using B<clone>(2)  with the B<CLONE_NEWPID> flag, or the first child created "
"by a process after a call to B<unshare>(2)  using the B<CLONE_NEWPID> flag) "
"has the PID 1, and is the \"init\" process for the namespace (see "
"B<init>(1)).  This process becomes the parent of any child processes that "
"are orphaned because a process that resides in this PID namespace terminated "
"(see below for further details)."
msgstr ""
"新しい名前空間で作成される最初のプロセス (すなわち、B<CLONE_NEWPID> フラグで "
"B<clone>(2) を使って作成されたプロセスや、 B<CLONE_NEWPID> フラグで "
"B<unshare>(2) を呼び出した後のプロセスによって作成された最初のプロセス) は "
"PID 1 を持ち、 そのプロセスはその名前空間の \"init\" プロセスとなる "
"(B<init>(1) 参照)。 名前空間内でみなしごになった (親プロセスがいなくなった) "
"子プロセスは、 B<init>(1) ではなくこのプロセスが親プロセスになる (ただし、 同"
"じ PID 名前空間内のその子プロセスの先祖が、 B<prctl>(2) の "
"B<PR_SET_CHILD_SUBREAPER> コマンドを使って、 自分自身をみなしごとなった子孫の"
"プロセスの引き取り手になっている場合はこの限りではなく)。"

#. type: Plain text
#: build/C/man7/pid_namespaces.7:97
#, fuzzy
#| msgid ""
#| "If the \"init\" process of a PID namespace terminates, the kernel "
#| "terminates all of the processes in the namespace via a B<SIGKILL> "
#| "signal.  This behavior reflects the fact that the \"init\" process is "
#| "essential for the correct operation of a PID namespace.  In this case, a "
#| "subsequent B<fork>(2)  into this PID namespace will fail with the error "
#| "B<ENOMEM>; it is not possible to create a new processes in a PID "
#| "namespace whose \"init\" process has terminated.  Such scenarios can "
#| "occur when, for example, a process uses an open file descriptor for a I</"
#| "proc/[pid]/ns/pid> file corresponding to a process that was in a "
#| "namespace to B<setns>(2)  into that namespace after the \"init\" process "
#| "has terminated.  Another possible scenario can occur after a call to "
#| "B<unshare>(2): if the first child subsequently created by a B<fork>(2)  "
#| "terminates, then subsequent calls to B<fork>(2)  will fail with B<ENOMEM>."
msgid ""
"If the \"init\" process of a PID namespace terminates, the kernel terminates "
"all of the processes in the namespace via a B<SIGKILL> signal.  This "
"behavior reflects the fact that the \"init\" process is essential for the "
"correct operation of a PID namespace.  In this case, a subsequent "
"B<fork>(2)  into this PID namespace fail with the error B<ENOMEM>; it is not "
"possible to create a new process in a PID namespace whose \"init\" process "
"has terminated.  Such scenarios can occur when, for example, a process uses "
"an open file descriptor for a I</proc/[pid]/ns/pid> file corresponding to a "
"process that was in a namespace to B<setns>(2)  into that namespace after "
"the \"init\" process has terminated.  Another possible scenario can occur "
"after a call to B<unshare>(2): if the first child subsequently created by a "
"B<fork>(2)  terminates, then subsequent calls to B<fork>(2)  fail with "
"B<ENOMEM>."
msgstr ""
"PID 名前空間の \"init\" プロセスが終了すると、 カーネルはその名前空間の全プロ"
"セスを B<SIGKILL> シグナルで終了する。 この動作は、 PID 名前空間の正しい操作"
"のためには \"init\" プロセスは不可欠であるという事実を反映したものである。 こ"
"の場合、 その PID 名前空間へのそれ以降の B<fork>(2) はエラー B<ENOMEM> で失敗"
"する。 \"init\" プロセスが終了している PID 名前空間に新しいプロセスを作成する"
"ことはできない。 このような状況は、 例えば、 名前空間にいたプロセスに対応す"
"る I</proc/[pid]/ns/pid> ファイルに対してオープンしたファイルディスクリプター"
"を使って、 \"init\" プロセスが終了した後にその名前空間に B<setns>(2) を行った"
"場合に起こり得る。 B<unshare>(2) を呼び出した後にも、この状況は起こり得る。 "
"それ以降に B<fork>(2) で作成された最初の子プロセスが終了すると、 それ以降の "
"B<fork>(2) の呼び出しは B<NOMEM> で失敗する。"

#. type: Plain text
#: build/C/man7/pid_namespaces.7:103
msgid ""
"Only signals for which the \"init\" process has established a signal handler "
"can be sent to the \"init\" process by other members of the PID namespace.  "
"This restriction applies even to privileged processes, and prevents other "
"members of the PID namespace from accidentally killing the \"init\" process."
msgstr ""
"PID 名前空間の他のメンバーは、 \"init\" プロセスがシグナルハンドラーを設定し"
"たシグナルだけを、 \"init\" プロセスに送信することができる。 この制限は特権プ"
"ロセスに対しても適用される。 この制限により、 PID 名前空間の他のメンバーが"
"うっかり \"init\" プロセスを殺してしまうのを防ぐことができる。"

#. type: Plain text
#: build/C/man7/pid_namespaces.7:123
msgid ""
"Likewise, a process in an ancestor namespace can\\(emsubject to the usual "
"permission checks described in B<kill>(2)\\(emsend signals to the \"init\" "
"process of a child PID namespace only if the \"init\" process has "
"established a handler for that signal.  (Within the handler, the "
"I<siginfo_t> I<si_pid> field described in B<sigaction>(2)  will be zero.)  "
"B<SIGKILL> or B<SIGSTOP> are treated exceptionally: these signals are "
"forcibly delivered when sent from an ancestor PID namespace.  Neither of "
"these signals can be caught by the \"init\" process, and so will result in "
"the usual actions associated with those signals (respectively, terminating "
"and stopping the process)."
msgstr ""
"同様に、 先祖の名前空間のプロセスは、 \"init\" プロセスがそのシグナルに対する"
"ハンドラーを設定している場合にのみ、 B<kill>(2) で説明されている通常のアクセ"
"ス許可のチェックを経た上で、 子供の PID 名前空間の \"init\" プロセスにシグナ"
"ルを送信できる。 (ハンドラー内では、 I<sigaction>(2) に説明がある "
"I<siginfo_t> の I<si_pid> フィールドは 0 になる。) B<SIGKILL> と B<SIGSTOP> "
"は例外として扱われ、 これらのシグナルが先祖の PID 名前空間から送信された場合"
"には強制的に配送される。 これらのシグナルはどちらも \"init\" プロセルが捕捉す"
"ることはできない。 そのため、これらのシグナルに関連付けられた通常のアクショ"
"ン (それぞれ、プロセスの終了とプロセスの強制停止) が実行される。"

#
#.  ============================================================
#. type: Plain text
#: build/C/man7/pid_namespaces.7:133
msgid ""
"Starting with Linux 3.4, the B<reboot>(2)  system call causes a signal to be "
"sent to the namespace \"init\" process.  See B<reboot>(2)  for more details."
msgstr ""
"Linux 3.4 以降では、 B<reboot>(2) システムコールを呼び出すと、 シグナルがその"
"名前空間の \"init\" プロセスに送信される。 詳細は B<reboot>(2) を参照。"

#. type: SS
#: build/C/man7/pid_namespaces.7:133
#, no-wrap
msgid "Nesting PID namespaces"
msgstr "ネストされた PID 名前空間"

#.  commit f2302505775fd13ba93f034206f1e2a587017929
#.  The kernel constant MAX_PID_NS_LEVEL
#. type: Plain text
#: build/C/man7/pid_namespaces.7:148
#, fuzzy
#| msgid ""
#| "PID namespaces can be nested: each PID namespace has a parent, except for "
#| "the initial (\"root\") PID namespace.  The parent of a PID namespace is "
#| "the PID namespace of the process that created the namespace using "
#| "B<clone>(2)  or B<unshare>(2).  PID namespaces thus form a tree, with all "
#| "namespaces ultimately tracing their ancestry to the root namespace."
msgid ""
"PID namespaces can be nested: each PID namespace has a parent, except for "
"the initial (\"root\") PID namespace.  The parent of a PID namespace is the "
"PID namespace of the process that created the namespace using B<clone>(2)  "
"or B<unshare>(2).  PID namespaces thus form a tree, with all namespaces "
"ultimately tracing their ancestry to the root namespace.  Since Linux 3.7, "
"the kernel limits the maximum nesting depth for PID namespaces to 32."
msgstr ""
"PID 名前空間は入れ子にすることができる。 最初の (\"root\") PID 名前空間以外の"
"各 PID 名前空間は親を持つ。 PID 名前空間の親は B<clone>(2) や B<unshare>(2) "
"を使ってその名前空間を作成したプロセスの PID 名前空間である。 したがって、 "
"PID 名前空間は木構造を構成し、 すべての名前空間は親を辿って行くと、最終的に"
"は root 名前空間に辿り着く。"

#. type: Plain text
#: build/C/man7/pid_namespaces.7:163
msgid ""
"A process is visible to other processes in its PID namespace, and to the "
"processes in each direct ancestor PID namespace going back to the root PID "
"namespace.  In this context, \"visible\" means that one process can be the "
"target of operations by another process using system calls that specify a "
"process ID.  Conversely, the processes in a child PID namespace can't see "
"processes in the parent and further removed ancestor namespaces.  More "
"succinctly: a process can see (e.g., send signals with B<kill>(2), set nice "
"values with B<setpriority>(2), etc.) only processes contained in its own PID "
"namespace and in descendants of that namespace."
msgstr ""
"プロセスは、所属する PID 名前空間の他のプロセスから見える。また、 root PID 名"
"前空間に向かう直径の先祖の各 PID 名前空間のプロセスからも見える。 この場合、"
"「見える」とは、 あるプロセスが、 他のプロセスがプロセス ID を指定するシステ"
"ムコールを使う際に操作の対象にできることを意味する。 逆に、子供 PID 名前空間"
"のプロセスから親や先祖の名前空間のプロセスは見えない。 あるプロセスは自分自身"
"の PID 名前空間とその子孫の名前空間のプロセスだけが見える (例えば、"
"B<kill>(2) でシグナルを送信したり、 B<setpriority>(2) で nice 値を設定した"
"り、など)。"

#. type: Plain text
#: build/C/man7/pid_namespaces.7:175
msgid ""
"A process has one process ID in each of the layers of the PID namespace "
"hierarchy in which is visible, and walking back though each direct ancestor "
"namespace through to the root PID namespace.  System calls that operate on "
"process IDs always operate using the process ID that is visible in the PID "
"namespace of the caller.  A call to B<getpid>(2)  always returns the PID "
"associated with the namespace in which the process was created."
msgstr ""
"プロセスは、そのプロセスが見える PID 名前空間の階層の各層においてプロセス ID "
"を一つ持ち、 直接の先祖の名前空間を辿ることで通って root PID 名前空間に至るこ"
"とができる。 プロセス ID に対して操作を行うシステムコールは、常に、呼び出し元"
"プロセスの PID 名前空間で見えるプロセス ID を使って操作を行う。 B<getpid>(2) "
"の呼び出しでは、 常に、 プロセスが作成された名前空間に関連付けられた PID を返"
"す。"

#
#. type: Plain text
#: build/C/man7/pid_namespaces.7:190
msgid ""
"Some processes in a PID namespace may have parents that are outside of the "
"namespace.  For example, the parent of the initial process in the namespace "
"(i.e., the B<init>(1)  process with PID 1) is necessarily in another "
"namespace.  Likewise, the direct children of a process that uses "
"B<setns>(2)  to cause its children to join a PID namespace are in a "
"different PID namespace from the caller of B<setns>(2).  Calls to "
"B<getppid>(2)  for such processes return 0."
msgstr ""
"PID 名前空間内のプロセスは名前空間の外部に親プロセスを持つことができる。 例え"
"ば、その名前空間の初期プロセス (すなわち PID 1 を持つ B<init>(1) プロセス) の"
"親プロセスは必然的に別の名前空間に属すことになる。 同様に、 あるプロセスが "
"B<setns>(2) を使って子プロセスを PID 名前空間に参加させた場合、 子プロセスは "
"B<setns>(2) の呼び出し元とは異なる PID 名前空間に属す。 子プロセスで "
"B<getppid>(2) を呼び出すと 0 が返される。"

#
#. type: Plain text
#: build/C/man7/pid_namespaces.7:199
#, fuzzy
#| msgid ""
#| "While processes may freely descend into child PID namespaces (e.g., using "
#| "B<setns>(2)  with B<CLONE_NEWPID>), they may not move in the other "
#| "direction.  That is to say, processes may not enter any ancestor "
#| "namespaces (parent, grandparent, etc.).  Changing PID namespaces is a one "
#| "way operation."
msgid ""
"While processes may freely descend into child PID namespaces (e.g., using "
"B<setns>(2)  with a PID namespace file descriptor), they may not move in the "
"other direction.  That is to say, processes may not enter any ancestor "
"namespaces (parent, grandparent, etc.).  Changing PID namespaces is a one-"
"way operation."
msgstr ""
"プロセスは (B<setns>(2) を B<CLONE_NEWPID> で使うなどで) 子供の PID 名前空間"
"に自由に入ることができるが、 逆の方向には移動できない。 つまり、 プロセスは先"
"祖の名前空間 (親、親の親など) に入ることはできない。 PID 名前空間の変更は一方"
"向の操作である。"

#
#.  ============================================================
#. type: Plain text
#: build/C/man7/pid_namespaces.7:209
msgid ""
"The B<NS_GET_PARENT> B<ioctl>(2)  operation can be used to discover the "
"parental relationship between PID namespaces; see B<ioctl_ns>(2)."
msgstr ""

#. type: SS
#: build/C/man7/pid_namespaces.7:209
#, no-wrap
msgid "setns(2) and unshare(2) semantics"
msgstr "setns(2) と unshare(2) の動作"

#. type: Plain text
#: build/C/man7/pid_namespaces.7:229
#, fuzzy
#| msgid ""
#| "Calls to B<setns>(2)  that specify a PID namespace file descriptor and "
#| "calls to B<unshare>(2)  with the B<CLONE_NEWPID> flag cause children "
#| "subsequently created by the caller to be placed in a different PID "
#| "namespace from the caller.  These calls do not, however, change the PID "
#| "namespace of the calling process, because doing so would change the "
#| "caller's idea of its own PID (as reported by B<getpid>()), which would "
#| "break many applications and libraries."
msgid ""
"Calls to B<setns>(2)  that specify a PID namespace file descriptor and calls "
"to B<unshare>(2)  with the B<CLONE_NEWPID> flag cause children subsequently "
"created by the caller to be placed in a different PID namespace from the "
"caller.  (Since Linux 4.12, that PID namespace is shown via the I</proc/"
"[pid]/ns/pid_for_children> file, as described in B<namespaces>(7).)  These "
"calls do not, however, change the PID namespace of the calling process, "
"because doing so would change the caller's idea of its own PID (as reported "
"by B<getpid>()), which would break many applications and libraries."
msgstr ""
"PID 名前空間のファイルディスクリプターを指定して B<setns>(2) を呼び出した"
"り、 B<CLONE_NEWPID> フラグ付きで B<unshare>(2) を呼び出したりすると、 その結"
"果作成された子プロセスは呼び出し元とは異なる PID 名前空間に置かれる。 しか"
"し、これらの呼び出しでは呼び出し元プロセスの PID 名前空間は変更されない。 な"
"ぜなら、PID 名前空間を変更してしまうと、 呼び出し元が認識する (B<getpid>() が"
"返す) 自分の PID が変わってしまい、 多くのアプリケーションやライブラリが正し"
"く動作しなくなるからである。"

#. type: Plain text
#: build/C/man7/pid_namespaces.7:237
msgid ""
"To put things another way: a process's PID namespace membership is "
"determined when the process is created and cannot be changed thereafter.  "
"Among other things, this means that the parental relationship between "
"processes mirrors the parental relationship between PID namespaces: the "
"parent of a process is either in the same namespace or resides in the "
"immediate parent PID namespace."
msgstr ""
"別の言い方をすると、 あるプロセスがどの PID 名前空間に所属するかは、 そのプロ"
"セスが作成されたときに決定され、 それ以降は変更されることはない。 いろいろあ"
"るが、プロセス間の親子関係には、PID 名前空間の親子関係がそのまま反映されると"
"いうことだ。 プロセスの親プロセスは、同じ名前空間にいるか、もしくは直接の親 "
"PID 名前空間にいるかのいずれかである。"

#
#.  ============================================================
#. type: Plain text
#: build/C/man7/pid_namespaces.7:249
msgid ""
"A process may call B<unshare>(2)  with the B<CLONE_NEWPID> flag only once.  "
"After it has performed this operation, its I</proc/PID/ns/pid_for_children> "
"symbolic link will be empty until the first child is created in the "
"namespace."
msgstr ""

#. type: SS
#: build/C/man7/pid_namespaces.7:249
#, no-wrap
msgid "Adoption of orphaned children"
msgstr ""

#
#.  Furthermore, by definition, the parent of the "init" process
#.  of a PID namespace resides in the parent PID namespace.
#.  ============================================================
#. type: Plain text
#: build/C/man7/pid_namespaces.7:270
msgid ""
"When a child process becomes orphaned, it is reparented to the \"init\" "
"process in the PID namespace of its parent (unless one of the nearer "
"ancestors of the parent employed the B<prctl>(2)  B<PR_SET_CHILD_SUBREAPER> "
"command to mark itself as the reaper of orphaned descendant processes).  "
"Note that because of the B<setns>(2)  and B<unshare>(2)  semantics described "
"above, this may be the \"init\" process in the PID namespace that is the "
"I<parent> of the child's PID namespace, rather than the \"init\" process in "
"the child's own PID namespace."
msgstr ""

#. type: SS
#: build/C/man7/pid_namespaces.7:270
#, no-wrap
msgid "Compatibility of CLONE_NEWPID with other CLONE_* flags"
msgstr "CLONE_NEWPID の他の CLONE_* フラグとの互換性"

#. type: Plain text
#: build/C/man7/pid_namespaces.7:291
#, fuzzy
#| msgid ""
#| "B<CLONE_SIGHAND> requires being in the same PID namespace; otherwise the "
#| "process ID of the process sending a signal could not be meaningfully "
#| "encoded when a signal is sent (see the description of the I<siginfo_t> "
#| "type in B<sigaction>(2)).  A signal queue shared by processes in multiple "
#| "PID namespaces will defeat that."
msgid ""
"In current versions of Linux, B<CLONE_NEWPID> can't be combined with "
"B<CLONE_THREAD>.  Threads are required to be in the same PID namespace such "
"that the threads in a process can send signals to each other.  Similarly, it "
"must be possible to see all of the threads of a processes in the B<proc>(5)  "
"filesystem.  Additionally, if two threads were in different PID namespaces, "
"the process ID of the process sending a signal could not be meaningfully "
"encoded when a signal is sent (see the description of the I<siginfo_t> type "
"in B<sigaction>(2)).  Since this is computed when a signal is enqueued, a "
"signal queue shared by processes in multiple PID namespaces would defeat "
"that."
msgstr ""
"B<CLONE_SIGHAND> は、同じ PID 名前空間である必要がある。 さもなければ、 シグ"
"ナルが送信された際に、シグナルを送信したプロセスのプロセス ID を意味のある形"
"でエンコードすることができない (B<sigaction>(2) の I<siginfo_t> 型の説明を参"
"照)。 複数の PID 名前空間に属するプロセス間で一つのシグナルキューを共有する"
"と、うまく動かなくなる。"

#
#.  Note these restrictions were all introduced in
#.  8382fcac1b813ad0a4e68a838fc7ae93fa39eda0
#.  when CLONE_NEWPID|CLONE_VM was disallowed
#.  (restriction lifted in faf00da544045fdc1454f3b9e6d7f65c841de302)
#.  (restriction lifted in e79f525e99b04390ca4d2366309545a836c03bf1)
#.  ============================================================
#. type: Plain text
#: build/C/man7/pid_namespaces.7:311
msgid ""
"In earlier versions of Linux, B<CLONE_NEWPID> was additionally disallowed "
"(failing with the error B<EINVAL>)  in combination with B<CLONE_SIGHAND> "
"(before Linux 4.3) as well as B<CLONE_VM> (before Linux 3.12).  The changes "
"that lifted these restrictions have also been ported to earlier stable "
"kernels."
msgstr ""

#
#. type: SS
#: build/C/man7/pid_namespaces.7:311
#, no-wrap
msgid "/proc and PID namespaces"
msgstr "/proc と PID 名前空間"

#. type: Plain text
#: build/C/man7/pid_namespaces.7:320
#, fuzzy
#| msgid ""
#| "A I</proc> filesystem shows (in the I</proc/PID> directories) only "
#| "processes visible in the PID namespace of the process that performed the "
#| "mount, even if the I</proc> filesystem is viewed from processes in other "
#| "namespaces."
msgid ""
"A I</proc> filesystem shows (in the I</proc/[pid]> directories) only "
"processes visible in the PID namespace of the process that performed the "
"mount, even if the I</proc> filesystem is viewed from processes in other "
"namespaces."
msgstr ""
"I</proc> ファイルシステムは、I</proc> のマウントを行ったプロセスの PID 名前空"
"間で見えるプロセスだけを表示する。 たとえ、 その I</proc> ファイルシステムが"
"他の名前空間のプロセスから参照されたとしても、そうである。"

#. type: Plain text
#: build/C/man7/pid_namespaces.7:339
msgid ""
"After creating a new PID namespace, it is useful for the child to change its "
"root directory and mount a new procfs instance at I</proc> so that tools "
"such as B<ps>(1)  work correctly.  If a new mount namespace is "
"simultaneously created by including B<CLONE_NEWNS> in the I<flags> argument "
"of B<clone>(2)  or B<unshare>(2), then it isn't necessary to change the root "
"directory: a new procfs instance can be mounted directly over I</proc>."
msgstr ""
"新しい PID 名前空間を作成した後、 子プロセスが、自身の root ディレクトリを変"
"更し、新しい procfs インスタンスを I</proc> にマウントするのは B<ps>(1) など"
"のツールが正しく動作するためにも有用である。 B<clone>(2) の I<flags> 引数"
"に B<CLONE_NEWNS> も指定されて新しいマウント名前空間が同時に作成された場合"
"は、 root ディレクトリを変更する必要はない。 新しい procfs インスタンスを I</"
"proc> にそのままマウントすることができる。"

#. type: Plain text
#: build/C/man7/pid_namespaces.7:343
msgid "From a shell, the command to mount I</proc> is:"
msgstr "シェルから、コマンドで I</proc> のマウントを行うには次のようにする。"

#. type: Plain text
#: build/C/man7/pid_namespaces.7:347
#, fuzzy, no-wrap
#| msgid "    $ mount -t proc proc /proc\n"
msgid "$ mount -t proc proc /proc\n"
msgstr "    $ mount -t proc proc /proc\n"

#
#.  ============================================================
#. type: Plain text
#: build/C/man7/pid_namespaces.7:361
msgid ""
"Calling B<readlink>(2)  on the path I</proc/self> yields the process ID of "
"the caller in the PID namespace of the procfs mount (i.e., the PID namespace "
"of the process that mounted the procfs).  This can be useful for "
"introspection purposes, when a process wants to discover its PID in other "
"namespaces."
msgstr ""
"パス I</proc/self> に対して B<readlink>(2) を呼び出すと、 procfs のマウントを"
"行ったプロセスの PID 名前空間におけるプロセス ID が得られる。 これは調査目的"
"でプロセスが他の名前空間で自身の PID を知りたい場合などに役立つ。"

#. type: SS
#: build/C/man7/pid_namespaces.7:361
#, no-wrap
msgid "/proc files"
msgstr ""

#. type: TP
#: build/C/man7/pid_namespaces.7:362
#, fuzzy, no-wrap
#| msgid "I</proc/[pid]/ns/pid> (since Linux 3.8)"
msgid "B</proc/sys/kernel/ns_last_pid> (since Linux 3.3)"
msgstr "I</proc/[pid]/ns/pid> (Linux 3.8 以降)"

#.  commit b8f566b04d3cddd192cfd2418ae6d54ac6353792
#. type: Plain text
#: build/C/man7/pid_namespaces.7:372
msgid ""
"This file (which is virtualized per PID namespace)  displays the last PID "
"that was allocated in this PID namespace.  When the next PID is allocated, "
"the kernel will search for the lowest unallocated PID that is greater than "
"this value, and when this file is subsequently read it will show that PID."
msgstr ""

#
#.  This ability is necessary to support checkpoint restore in user-space
#.  ============================================================
#. type: Plain text
#: build/C/man7/pid_namespaces.7:384
msgid ""
"This file is writable by a process that has the B<CAP_SYS_ADMIN> or (since "
"Linux 5.9)  B<CAP_CHECKPOINT_RESTORE> capability inside the user namespace "
"that owns the PID namespace.  This makes it possible to determine the PID "
"that is allocated to the next process that is created inside this PID "
"namespace."
msgstr ""

#. type: SS
#: build/C/man7/pid_namespaces.7:384 build/C/man7/user_namespaces.7:942
#, no-wrap
msgid "Miscellaneous"
msgstr "その他"

#. type: Plain text
#: build/C/man7/pid_namespaces.7:392
msgid ""
"When a process ID is passed over a UNIX domain socket to a process in a "
"different PID namespace (see the description of B<SCM_CREDENTIALS> in "
"B<unix>(7)), it is translated into the corresponding PID value in the "
"receiving process's PID namespace."
msgstr ""
"プロセス ID が UNIX ドメインソケット経由で別の PID 名前空間のプロセスに渡され"
"る場合 (B<unix>(7) の B<SCM_CREDENTIALS> の説明を参照)、 プロセス ID は受信プ"
"ロセスの PID 名前空間での対応する PID 値に翻訳される。"

#. type: Plain text
#: build/C/man7/pid_namespaces.7:397
msgid "See B<user_namespaces>(7)."
msgstr "B<user_namespaces>(7) 参照。"

#. type: Plain text
#: build/C/man7/pid_namespaces.7:409
#, fuzzy
#| msgid ""
#| "B<clone>(2), B<setns>(2), B<unshare>(2), B<proc>(5), B<credentials>(7), "
#| "B<capabilities>(7), B<user_namespaces>(7), B<switch_root>(8)"
msgid ""
"B<clone>(2), B<reboot>(2), B<setns>(2), B<unshare>(2), B<proc>(5), "
"B<capabilities>(7), B<credentials>(7), B<mount_namespaces>(7), "
"B<namespaces>(7), B<user_namespaces>(7), B<switch_root>(8)"
msgstr ""
"B<clone>(2), B<setns>(2), B<unshare>(2), B<proc>(5), B<credentials>(7), "
"B<capabilities>(7), B<user_namespaces>(7), B<switch_root>(8)"

#. type: TH
#: build/C/man7/time_namespaces.7:26
#, fuzzy, no-wrap
#| msgid "PID_NAMESPACES"
msgid "TIME_NAMESPACES"
msgstr "PID_NAMESPACES"

#. type: Plain text
#: build/C/man7/time_namespaces.7:29
#, fuzzy
#| msgid "namespaces - overview of Linux namespaces"
msgid "time_namespaces - overview of Linux time namespaces"
msgstr "namespaces - Linux 名前空間の概要"

#. type: Plain text
#: build/C/man7/time_namespaces.7:31
msgid "Time namespaces virtualize the values of two system clocks:"
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:39
msgid ""
"B<CLOCK_MONOTONIC> (and likewise B<CLOCK_MONOTONIC_COARSE> and "
"B<CLOCK_MONOTONIC_RAW>), a nonsettable clock that represents monotonic time "
"since\\(emas described by POSIX\\(em\"some unspecified point in the past\"."
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:46
msgid ""
"B<CLOCK_BOOTTIME> (and likewise B<CLOCK_BOOTTIME_ALARM>), a nonsettable "
"clock that is identical to B<CLOCK_MONOTONIC>, except that it also includes "
"any time that the system is suspended."
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:57
msgid ""
"Thus, the processes in a time namespace share per-namespace values for these "
"clocks.  This affects various APIs that measure against these clocks, "
"including: B<clock_gettime>(2), B<clock_nanosleep>(2), B<nanosleep>(2), "
"B<timer_settime>(2), B<timerfd_settime>(2), and I</proc/uptime>."
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:79
msgid ""
"Currently, the only way to create a time namespace is by calling "
"B<unshare>(2)  with the B<CLONE_NEWTIME> flag.  This call creates a new time "
"namespace but does I<not> place the calling process in the new namespace.  "
"Instead, the calling process's subsequently created children are placed in "
"the new namespace.  This allows clock offsets (see below) for the new "
"namespace to be set before the first process is placed in the namespace.  "
"The I</proc/[pid]/ns/time_for_children> symbolic link shows the time "
"namespace in which the children of a process will be created.  (A process "
"can use a file descriptor opened on this symbolic link in a call to "
"B<setns>(2)  in order to move into the namespace.)"
msgstr ""

#. type: SS
#: build/C/man7/time_namespaces.7:79
#, no-wrap
msgid "/proc/PID/timens_offsets"
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:89
msgid ""
"Associated with each time namespace are offsets, expressed with respect to "
"the initial time namespace, that define the values of the monotonic and boot-"
"time clocks in that namespace.  These offsets are exposed via the file I</"
"proc/PID/timens_offsets>.  Within this file, the offsets are expressed as "
"lines consisting of three space-delimited fields:"
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:93
#, no-wrap
msgid "E<lt>clock-idE<gt> E<lt>offset-secsE<gt> E<lt>offset-nanosecsE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:116
msgid ""
"The I<clock-id> is a string that identifies the clock whose offsets are "
"being shown.  This field is either I<monotonic>, for B<CLOCK_MONOTONIC>, or "
"I<boottime>, for B<CLOCK_BOOTTIME>.  The remaining fields express the offset "
"(seconds plus nanoseconds) for the clock in this time namespace.  These "
"offsets are expressed relative to the clock values in the initial time "
"namespace.  The I<offset-secs> value can be negative, subject to "
"restrictions noted below; I<offset-nanosecs> is an unsigned value."
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:120
msgid ""
"In the initial time namespace, the contents of the I<timens_offsets> file "
"are as follows:"
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:126
#, no-wrap
msgid ""
"$ B<cat /proc/self/timens_offsets>\n"
"monotonic           0         0\n"
"boottime            0         0\n"
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:144
msgid ""
"In a new time namespace that has had no member processes, the clock offsets "
"can be modified by writing newline-terminated records of the same form to "
"the I<timens_offsets> file.  The file can be written to multiple times, but "
"after the first process has been created in or has entered the namespace, "
"B<write>(2)s on this file fail with the error B<EACCES>.  In order to write "
"to the I<timens_offsets> file, a process must have the B<CAP_SYS_TIME> "
"capability in the user namespace that owns the time namespace."
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:148
msgid ""
"Writes to the I<timens_offsets> file can fail with the following errors:"
msgstr ""

#. type: TP
#: build/C/man7/time_namespaces.7:148 build/C/man7/time_namespaces.7:153
#, no-wrap
msgid "B<EINVAL>"
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:153
msgid "An I<offset-nanosecs> value is greater than 999,999,999."
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:158
msgid "A I<clock-id> value is not valid."
msgstr ""

#. type: TP
#: build/C/man7/time_namespaces.7:158
#, no-wrap
msgid "B<EPERM>"
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:163
msgid "The caller does not have the B<CAP_SYS_TIME> capability."
msgstr ""

#. type: TP
#: build/C/man7/time_namespaces.7:163
#, no-wrap
msgid "B<ERANGE>"
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:169
msgid "An I<offset-secs> value is out of range.  In particular;"
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:174
msgid ""
"I<offset-secs> can't be set to a value which would make the current time on "
"the corresponding clock inside the namespace a negative value; and"
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:180
msgid ""
"I<offset-secs> can't be set to a value such that the time on the "
"corresponding clock inside the namespace would exceed half of the value of "
"the kernel constant B<KTIME_SEC_MAX> (this limits the clock value to a "
"maximum of approximately 146 years)."
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:187
msgid ""
"In a new time namespace created by B<unshare>(2), the contents of the "
"I<timens_offsets> file are inherited from the time namespace of the creating "
"process."
msgstr ""

#
#. type: Plain text
#: build/C/man7/time_namespaces.7:192
#, fuzzy
#| msgid ""
#| "Use of IPC namespaces requires a kernel that is configured with the "
#| "B<CONFIG_IPC_NS> option."
msgid ""
"Use of time namespaces requires a kernel that is configured with the "
"B<CONFIG_TIME_NS> option."
msgstr ""
"IPC 名前空間を使用するには、設定 B<CONFIG_IPC_NS> が有効になったカーネルが必"
"要である。"

#. type: Plain text
#: build/C/man7/time_namespaces.7:198
msgid ""
"Note that time namespaces do not virtualize the B<CLOCK_REALTIME> clock.  "
"Virtualization of this clock was avoided for reasons of complexity and "
"overhead within the kernel."
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:209
msgid ""
"For compatibility with the initial implementation, when writing a I<clock-"
"id> to the I</proc/[pid]/timens_offsets> file, the numerical values of the "
"IDs can be written instead of the symbolic names show above; i.e., 1 instead "
"of I<monotonic>, and 7 instead of I<boottime>.  For redability, the use of "
"the symbolic names over the numbers is preferred."
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:213
msgid ""
"The motivation for adding time namespaces was to allow the monotonic and "
"boot-time clocks to maintain consistent values during container migration "
"and checkpoint/restore."
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:218
msgid ""
"The following shell session demonstrates the operation of time namespaces.  "
"We begin by displaying the inode number of the time namespace of a shell in "
"the initial time namespace:"
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:223
#, no-wrap
msgid ""
"$ B<readlink /proc/$$/ns/time>\n"
"time:[4026531834]\n"
msgstr ""
"$ B<readlink /proc/$$/ns/time>\n"
"time:[4026531834]\n"

#. type: Plain text
#: build/C/man7/time_namespaces.7:233
msgid ""
"Continuing in the initial time namespace, we display the system uptime using "
"B<uptime>(1)  and use the I<clock_times> example program shown in "
"B<clock_getres>(2)  to display the values of various clocks:"
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:243
#, no-wrap
msgid ""
"$ B<uptime --pretty>\n"
"up 21 hours, 17 minutes\n"
"$ B<./clock_times>\n"
"CLOCK_REALTIME : 1585989401.971 (18356 days +  8h 36m 41s)\n"
"CLOCK_TAI      : 1585989438.972 (18356 days +  8h 37m 18s)\n"
"CLOCK_MONOTONIC:      56338.247 (15h 38m 58s)\n"
"CLOCK_BOOTTIME :      76633.544 (21h 17m 13s)\n"
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:261
msgid ""
"We then use B<unshare>(1)  to create a time namespace and execute a "
"B<bash>(1)  shell.  From the new shell, we use the built-in B<echo> command "
"to write records to the I<timens_offsets> file adjusting the offset for the "
"B<CLOCK_MONOTONIC> clock forward 2 days and the offset for the "
"B<CLOCK_BOOTTIME> clock forward 7 days:"
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:267
#, no-wrap
msgid ""
"$ B<PS1=\"ns2# \" sudo unshare -T -- bash --norc>\n"
"ns2# B<echo \"monotonic $((2*24*60*60)) 0\" E<gt> /proc/$$/timens_offsets>\n"
"ns2# B<echo \"boottime  $((7*24*60*60)) 0\" E<gt> /proc/$$/timens_offsets>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:279
msgid ""
"Above, we started the B<bash>(1)  shell with the B<--norc> options so that "
"no start-up scripts were executed.  This ensures that no child processes are "
"created from the shell before we have a chance to update the "
"I<timens_offsets> file."
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:291
msgid ""
"We then use B<cat>(1)  to display the contents of the I<timens_offsets> "
"file.  The execution of B<cat>(1)  creates the first process in the new time "
"namespace, after which further attempts to update the I<timens_offsets> file "
"produce an error."
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:299
#, no-wrap
msgid ""
"ns2# B<cat /proc/$$/timens_offsets>\n"
"monotonic      172800         0\n"
"boottime       604800         0\n"
"ns2# B<echo \"boottime $((9*24*60*60)) 0\" E<gt> /proc/$$/timens_offsets>\n"
"bash: echo: write error: Permission denied\n"
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:307
msgid ""
"Continuing in the new namespace, we execute B<uptime>(1)  and the "
"I<clock_times> example program:"
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:317
#, no-wrap
msgid ""
"ns2# B<uptime --pretty>\n"
"up 1 week, 21 hours, 18 minutes\n"
"ns2# B<./clock_times>\n"
"CLOCK_REALTIME : 1585989457.056 (18356 days +  8h 37m 37s)\n"
"CLOCK_TAI      : 1585989494.057 (18356 days +  8h 38m 14s)\n"
"CLOCK_MONOTONIC:     229193.332 (2 days + 15h 39m 53s)\n"
"CLOCK_BOOTTIME :     681488.629 (7 days + 21h 18m  8s)\n"
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:322
msgid ""
"From the above output, we can see that the monotonic and boot-time clocks "
"have different values in the new time namespace."
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:329
msgid ""
"Examining the I</proc/[pid]/ns/time> and I</proc/[pid]/ns/time_for_children> "
"symbolic links, we see that the shell is a member of the initial time "
"namespace, but its children are created in the new namespace."
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:339
#, no-wrap
msgid ""
"ns2# B<readlink /proc/$$/ns/time>\n"
"time:[4026531834]\n"
"ns2# B<readlink /proc/$$/ns/time_for_children>\n"
"time:[4026532900]\n"
"ns2# B<readlink /proc/self/ns/time>   # Creates a child process\n"
"time:[4026532900]\n"
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:347
msgid ""
"Returning to the shell in the initial time namespace, we see that the "
"monotonic and boot-time clocks are unaffected by the I<timens_offsets> "
"changes that were made in the other time namespace:"
msgstr ""

#. type: Plain text
#: build/C/man7/time_namespaces.7:357
#, no-wrap
msgid ""
"$ B<uptime --pretty>\n"
"up 21 hours, 19 minutes\n"
"$ B<./clock_times>\n"
"CLOCK_REALTIME : 1585989401.971 (18356 days +  8h 38m 51s)\n"
"CLOCK_TAI      : 1585989438.972 (18356 days +  8h 39m 28s)\n"
"CLOCK_MONOTONIC:      56338.247 (15h 41m  8s)\n"
"CLOCK_BOOTTIME :      76633.544 (21h 19m 23s)\n"
msgstr ""

#.  clone3() support for time namespaces is a work in progress
#.  .BR clone3 (2),
#. type: Plain text
#: build/C/man7/time_namespaces.7:369
msgid ""
"B<nsenter>(1), B<unshare>(1), B<clock_settime>(2), B<setns>(2), "
"B<unshare>(2), B<namespaces>(7), B<time>(7)"
msgstr "B<nsenter>(1), B<unshare>(1), B<clock_settime>(2), B<setns>(2), B<unshare>(2), B<namespaces>(7), B<time>(7)"

#. type: TH
#: build/C/man7/user_namespaces.7:27
#, no-wrap
msgid "USER_NAMESPACES"
msgstr "USER_NAMESPACES"

#. type: Plain text
#: build/C/man7/user_namespaces.7:30
msgid "user_namespaces - overview of Linux user namespaces"
msgstr "user_namespaces - Linux ユーザー名前空間の概要"

#
#.  FIXME: This page says very little about the interaction
#.  of user namespaces and keys. Add something on this topic.
#.  ============================================================
#. type: Plain text
#: build/C/man7/user_namespaces.7:56
msgid ""
"User namespaces isolate security-related identifiers and attributes, in "
"particular, user IDs and group IDs (see B<credentials>(7)), the root "
"directory, keys (see B<keyrings>(7)), and capabilities (see "
"B<capabilities>(7)).  A process's user and group IDs can be different inside "
"and outside a user namespace.  In particular, a process can have a normal "
"unprivileged user ID outside a user namespace while at the same time having "
"a user ID of 0 inside the namespace; in other words, the process has full "
"privileges for operations inside the user namespace, but is unprivileged for "
"operations outside the namespace."
msgstr "ユーザー名前空間は、 セキュリティに関連する識別子や属性、 特にユーザー ID やグループ ID (B<credentials>(7) 参照)、 root ディレクトリ、 キー (B<keyrings>(7) 参照)、 ケーパビリティを分離する。 プロセスのユーザー ID とグループ ID はユーザー名前空間の内部と外部で異なる場合がある。 特に、 あるプロセスがユーザー名前空間の外部では通常の非特権ユーザー ID を持つが、 同時にユーザー名前空間の内部ではユーザー ID 0 を持つという場合がある。 言い換えると、 そのプロセスはそのユーザー名前空間の内部での操作に対してすべての特権を持つが、 名前空間の外部での操作では特権を持たない。"

#. type: SS
#: build/C/man7/user_namespaces.7:56
#, no-wrap
msgid "Nested namespaces, namespace membership"
msgstr "ネストされた名前空間、名前空間のメンバー"

#. type: Plain text
#: build/C/man7/user_namespaces.7:69
msgid ""
"User namespaces can be nested; that is, each user namespace\\(emexcept the "
"initial (\"root\")  namespace\\(emhas a parent user namespace, and can have "
"zero or more child user namespaces.  The parent user namespace is the user "
"namespace of the process that creates the user namespace via a call to "
"B<unshare>(2)  or B<clone>(2)  with the B<CLONE_NEWUSER> flag."
msgstr ""
"ユーザー名前空間は入れ子にすることができる。 つまり、 最初の (\"root\") 名前"
"空間以外の各名前空間は親のユーザー名前空間を持ち、 0 個以上のユーザー名前空間"
"を持つということである。 親のユーザー名前空間は、 B<CLONE_NEWUSER> フラグを指"
"定して B<unshare>(2) や B<clone>(2) を呼び出してユーザー名前空間を作成したプ"
"ロセスのユーザー名前空間である。"

#.  commit 8742f229b635bf1c1c84a3dfe5e47c814c20b5c8
#.  FIXME Explain the rationale for this limit. (What is the rationale?)
#. type: Plain text
#: build/C/man7/user_namespaces.7:80
msgid ""
"The kernel imposes (since version 3.11) a limit of 32 nested levels of user "
"namespaces.  Calls to B<unshare>(2)  or B<clone>(2)  that would cause this "
"limit to be exceeded fail with the error B<EUSERS>."
msgstr ""
"カーネルにより (バージョン 3.11 以降では) ユーザー名前空間のネスト数に 32 と"
"いう上限が課される。 B<unshare>(2) や B<clone>(2) の呼び出しでこの上限を超え"
"てしまう場合はエラー B<EUSERS> で失敗する。"

#. type: Plain text
#: build/C/man7/user_namespaces.7:95
msgid ""
"Each process is a member of exactly one user namespace.  A process created "
"via B<fork>(2)  or B<clone>(2)  without the B<CLONE_NEWUSER> flag is a "
"member of the same user namespace as its parent.  A single-threaded process "
"can join another user namespace with B<setns>(2)  if it has the "
"B<CAP_SYS_ADMIN> in that namespace; upon doing so, it gains a full set of "
"capabilities in that namespace."
msgstr ""
"各プロセスは必ず 1 個のユーザー名前空間のメンバーとなる。 B<CLONE_NEWUSER> フ"
"ラグを指定せずに B<fork>(2) や B<clone>(2) でプロセスを作成した場合、 そのプ"
"ロセスは親プロセスと同じユーザー名前空間のメンバーとなる。 シングルスレッドの"
"プログラムは、 変更先のユーザー名前空間で B<CAP_SYS_ADMIN> を持っていれば、 "
"B<setns>(2) を使って別のユーザー名前空間に参加することができる。 変更時に、 "
"変更後の名前空間ですべてのケーパビリティを獲得する。"

#
#. type: Plain text
#: build/C/man7/user_namespaces.7:107
msgid ""
"A call to B<clone>(2)  or B<unshare>(2)  with the B<CLONE_NEWUSER> flag "
"makes the new child process (for B<clone>(2))  or the caller (for "
"B<unshare>(2))  a member of the new user namespace created by the call."
msgstr ""
"B<CLONE_NEWUSER> を指定して B<clone>(2) や B<unshare>(2) を呼び出すと、 新し"
"いプロセス (B<clone>(2) の場合) や呼び出したプロセス (B<unshare>(2) の場合) "
"がその呼び出しで作成された新しいユーザー名前空間のメンバーとなる。"

#
#.  ============================================================
#. type: Plain text
#: build/C/man7/user_namespaces.7:117
msgid ""
"The B<NS_GET_PARENT> B<ioctl>(2)  operation can be used to discover the "
"parental relationship between user namespaces; see B<ioctl_ns>(2)."
msgstr ""

#. type: SS
#: build/C/man7/user_namespaces.7:117
#, no-wrap
msgid "Capabilities"
msgstr "ケーパビリティ"

#. type: Plain text
#: build/C/man7/user_namespaces.7:139
msgid ""
"The child process created by B<clone>(2)  with the B<CLONE_NEWUSER> flag "
"starts out with a complete set of capabilities in the new user namespace.  "
"Likewise, a process that creates a new user namespace using B<unshare>(2)  "
"or joins an existing user namespace using B<setns>(2)  gains a full set of "
"capabilities in that namespace.  On the other hand, that process has no "
"capabilities in the parent (in the case of B<clone>(2))  or previous (in the "
"case of B<unshare>(2)  and B<setns>(2))  user namespace, even if the new "
"namespace is created or joined by the root user (i.e., a process with user "
"ID 0 in the root namespace)."
msgstr ""
"B<CLONE_NEWUSER> フラグが指定された B<clone>(2) で作成された子プロセスは、 新"
"しい名前空間ですべてのケーパビリティを持った状態で開始される。 同様に、 "
"B<unshare>(2) を使って新しいユーザー名前空間を作成したり、 B<setns>(2) を使っ"
"て既存のユーザー名前空間に参加したりしたプロセスは、 その名前空間ですべての"
"ケーパビリティを獲得する。 一方、 そのプロセスは、親のユーザー名前空間 "
"(B<clone>(2) の場合) や直前のユーザー名前空間 (B<unshare>(2) や B<setns>(2) "
"の場合) では、 root ユーザー (root 名前空間のユーザー ID 0 のプロセス) により"
"新しい名前空間の作成や参加が行われた場合であっても、 ケーパビリティを全く持た"
"ない。"

#. type: Plain text
#: build/C/man7/user_namespaces.7:149
msgid ""
"Note that a call to B<execve>(2)  will cause a process's capabilities to be "
"recalculated in the usual way (see B<capabilities>(7)).  Consequently, "
"unless the process has a user ID of 0 within the namespace, or the "
"executable file has a nonempty inheritable capabilities mask, the process "
"will lose all capabilities.  See the discussion of user and group ID "
"mappings, below."
msgstr "B<execve>(2) の呼び出しが行われると、 プロセスのケーパビリティは通常の方法 (B<capabilities>(7) 参照) で再計算される点に注意すること。その結果、そのプロセスが名前空間内でユーザー ID 0 を持つ場合やその実行ファイルが空でない継承可能ケーパビリティマスクを持っている場合でない限り、そのプロセスはすべてのケーパビリティを失うことになる。 下記の、ユーザー ID やグループ ID のマッピングの議論を参照。"

#. type: Plain text
#: build/C/man7/user_namespaces.7:177
#, fuzzy
#| msgid ""
#| "A call to B<clone>(2), B<unshare>(2), or B<setns>(2)  using the "
#| "B<CLONE_NEWUSER> flag sets the \"securebits\" flags (see "
#| "B<capabilities>(7))  to their default values (all flags disabled) in the "
#| "child (for B<clone>(2))  or caller (for B<unshare>(2), or B<setns>(2)).  "
#| "Note that because the caller no longer has capabilities in its original "
#| "user namespace after a call to B<setns>(2), it is not possible for a "
#| "process to reset its \"securebits\" flags while retaining its user "
#| "namespace membership by using a pair of B<setns>(2)  calls to move to "
#| "another user namespace and then return to its original user namespace."
msgid ""
"A call to B<clone>(2)  or B<unshare>(2)  using the B<CLONE_NEWUSER> flag or "
"a call to B<setns>(2)  that moves the caller into another user namespace "
"sets the \"securebits\" flags (see B<capabilities>(7))  to their default "
"values (all flags disabled) in the child (for B<clone>(2))  or caller (for "
"B<unshare>(2)  or B<setns>(2)).  Note that because the caller no longer has "
"capabilities in its original user namespace after a call to B<setns>(2), it "
"is not possible for a process to reset its \"securebits\" flags while "
"retaining its user namespace membership by using a pair of B<setns>(2)  "
"calls to move to another user namespace and then return to its original user "
"namespace."
msgstr ""
"B<CLONE_NEWUSER> フラグを使って B<clone>(2), B<unshare>(2), B<setns>(2) を呼"
"び出すと、 子プロセス (B<clone>(2) の場合) や呼び出し元 (B<unshare>(2) や "
"B<setns>(2) の場合) では \"securebits\" フラグ (B<capabilities>(7) 参照) がデ"
"フォルト値に設定される。 呼び出し元は B<setns>(2) の呼び出し後は元のユーザー"
"名前空間ではケーパビリティを持たないので、 B<setns>(2) を 2 回呼び出して一度"
"別のユーザー名前空間に移動して元のユーザー名前空間に戻ることで、 プロセスが元"
"のユーザー名前空間にとどまりつつ自身の \"securebits\" フラグを再設定すること"
"はできない。"

#. type: Plain text
#: build/C/man7/user_namespaces.7:180
msgid ""
"The rules for determining whether or not a process has a capability in a "
"particular user namespace are as follows:"
msgstr ""

#. type: IP
#: build/C/man7/user_namespaces.7:180 build/C/man7/user_namespaces.7:561
#, no-wrap
msgid "1."
msgstr "1."

#.  In the 3.8 sources, see security/commoncap.c::cap_capable():
#. type: Plain text
#: build/C/man7/user_namespaces.7:196
msgid ""
"A process has a capability inside a user namespace if it is a member of that "
"namespace and it has the capability in its effective capability set.  A "
"process can gain capabilities in its effective capability set in various "
"ways.  For example, it may execute a set-user-ID program or an executable "
"with associated file capabilities.  In addition, a process may gain "
"capabilities via the effect of B<clone>(2), B<unshare>(2), or B<setns>(2), "
"as already described."
msgstr ""
"プロセスがその名前空間のメンバーで、実効ケーパビリティセットにそのケーパビリ"
"ティがあれば、 そのプロセスはユーザー名前空間内でケーパビリティを持つ。 プロ"
"セスが実効ケーパビリティセットでケーパビリティを得るにはいくつかの方法があ"
"る。 例えば、 set-user-ID プログラムや関連するファイルケーパビリティを持った"
"実行ファイルを実行する。 また、 すでに説明したとおり、 プロセスは "
"B<clone>(2), B<unshare>(2), B<setns>(2) の結果としてケーパビリティを獲得する"
"こともできる。"

#. type: IP
#: build/C/man7/user_namespaces.7:196 build/C/man7/user_namespaces.7:567
#, no-wrap
msgid "2."
msgstr "2."

#. type: Plain text
#: build/C/man7/user_namespaces.7:200
msgid ""
"If a process has a capability in a user namespace, then it has that "
"capability in all child (and further removed descendant)  namespaces as well."
msgstr ""
"プロセスがユーザー名前空間でケーパビリティを持っている場合、 そのプロセスはす"
"べての子供の名前空間 (および削除された子孫の名前空間) でケーパビリティを持"
"つ。"

#. type: IP
#: build/C/man7/user_namespaces.7:200 build/C/man7/user_namespaces.7:572
#, no-wrap
msgid "3."
msgstr "3."

#
#.  * The owner of the user namespace in the parent of the
#.  * user namespace has all caps.
#.  (and likewise associates the effective group ID of the creating process
#.  with the namespace).
#.  See kernel commit 520d9eabce18edfef76a60b7b839d54facafe1f9 for a fix
#.  on this point
#.      This includes the case where the process executes a set-user-ID
#.      program that confers the effective UID of the creator of the namespace.
#.  ============================================================
#. type: Plain text
#: build/C/man7/user_namespaces.7:227
#, fuzzy
#| msgid ""
#| "When a user namespace is created, the kernel records the effective user "
#| "ID of the creating process as being the \"owner\" of the namespace.  A "
#| "process that resides in the parent of the user namespace and whose "
#| "effective user ID matches the owner of the namespace has all capabilities "
#| "in the namespace.  By virtue of the previous rule, this means that the "
#| "process has all capabilities in all further removed descendant user "
#| "namespaces as well."
msgid ""
"When a user namespace is created, the kernel records the effective user ID "
"of the creating process as being the \"owner\" of the namespace.  A process "
"that resides in the parent of the user namespace and whose effective user ID "
"matches the owner of the namespace has all capabilities in the namespace.  "
"By virtue of the previous rule, this means that the process has all "
"capabilities in all further removed descendant user namespaces as well.  The "
"B<NS_GET_OWNER_UID> B<ioctl>(2)  operation can be used to discover the user "
"ID of the owner of the namespace; see B<ioctl_ns>(2)."
msgstr ""
"ユーザー名前空間が作成された際、 カーネルはその名前空間の「所有者」として作成"
"したプロセスの実効ユーザー ID を記録する。 親のユーザー名前空間に属するプロセ"
"スで、 そのプロセスの実効ユーザー ID が名前空間の所有者と一致する場合、 その"
"プロセスはその名前空間ですべてのケーパビリティを持つ。 一つ前のルールも合わせ"
"て考えると、 このプロセスはすべての削除された子孫のユーザー名前空間ですべての"
"ケーパビリティを持つことを意味する。"

#. type: SS
#: build/C/man7/user_namespaces.7:227
#, no-wrap
msgid "Effect of capabilities within a user namespace"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:235
#, fuzzy
#| msgid ""
#| "Having a capability inside a user namespace permits a process to perform "
#| "operations (that require privilege)  only on resources governed by that "
#| "namespace.  The rules for determining whether or not a process has a "
#| "capability in a particular user namespace are as follows:"
msgid ""
"Having a capability inside a user namespace permits a process to perform "
"operations (that require privilege)  only on resources governed by that "
"namespace.  In other words, having a capability in a user namespace permits "
"a process to perform privileged operations on resources that are governed by "
"(nonuser)  namespaces owned by (associated with) the user namespace (see the "
"next subsection)."
msgstr ""
"ユーザー名前空間内部でケーパビリティを持つというのは、 そのプロセスがその名前"
"空間の支配下にあるリソースに対してのみ (特権を必要とする) 操作を実行できると"
"いうことである。 プロセスが特定のユーザー名前空間でケーパビリティを持つかどう"
"かを判定するルールは以下の通りである。"

#. type: Plain text
#: build/C/man7/user_namespaces.7:247
msgid ""
"On the other hand, there are many privileged operations that affect "
"resources that are not associated with any namespace type, for example, "
"changing the system (i.e., calendar) time (governed by B<CAP_SYS_TIME>), "
"loading a kernel module (governed by B<CAP_SYS_MODULE>), and creating a "
"device (governed by B<CAP_MKNOD>).  Only a process with privileges in the "
"I<initial> user namespace can perform such operations."
msgstr ""

#.  fs_flags = FS_USERNS_MOUNT in kernel sources
#. type: Plain text
#: build/C/man7/user_namespaces.7:254
msgid ""
"Holding B<CAP_SYS_ADMIN> within the user namespace that owns a process's "
"mount namespace allows that process to create bind mounts and mount the "
"following types of filesystems:"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:260
msgid "I</proc> (since Linux 3.8)"
msgstr "I</proc> (Linux 3.8 以降)"

#. type: Plain text
#: build/C/man7/user_namespaces.7:263
msgid "I</sys> (since Linux 3.8)"
msgstr "I</sys> (Linux 3.8 以降)"

#. type: Plain text
#: build/C/man7/user_namespaces.7:266
msgid "I<devpts> (since Linux 3.9)"
msgstr "I<devpts> (Linux 3.9 以降)"

#. type: Plain text
#: build/C/man7/user_namespaces.7:269
msgid "B<tmpfs>(5)  (since Linux 3.9)"
msgstr "B<tmpfs>(5)  (Linux 3.9 以降)"

#. type: Plain text
#: build/C/man7/user_namespaces.7:272
msgid "I<ramfs> (since Linux 3.9)"
msgstr "I<ramfs> (Linux 3.9 以降)"

#. type: Plain text
#: build/C/man7/user_namespaces.7:275
msgid "I<mqueue> (since Linux 3.9)"
msgstr "I<mqueue> (Linux 3.9 以降)"

#.  commit b2197755b2633e164a439682fb05a9b5ea48f706
#. type: Plain text
#: build/C/man7/user_namespaces.7:279
msgid "I<bpf> (since Linux 4.4)"
msgstr "I<bpf> (Linux 4.4 以降)"

#. type: Plain text
#: build/C/man7/user_namespaces.7:291
msgid ""
"Holding B<CAP_SYS_ADMIN> within the user namespace that owns a process's "
"cgroup namespace allows (since Linux 4.6)  that process to the mount the "
"cgroup version 2 filesystem and cgroup version 1 named hierarchies (i.e., "
"cgroup filesystems mounted with the I<\"none,name=\"> option)."
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:299
msgid ""
"Holding B<CAP_SYS_ADMIN> within the user namespace that owns a process's PID "
"namespace allows (since Linux 3.8)  that process to mount I</proc> "
"filesystems."
msgstr ""

#
#.  ============================================================
#. type: Plain text
#: build/C/man7/user_namespaces.7:307
msgid ""
"Note however, that mounting block-based filesystems can be done only by a "
"process that holds B<CAP_SYS_ADMIN> in the initial user namespace."
msgstr ""

#. type: SS
#: build/C/man7/user_namespaces.7:307
#, no-wrap
msgid "Interaction of user namespaces and other types of namespaces"
msgstr "ユーザー名前空間と他の名前空間の関係"

#. type: Plain text
#: build/C/man7/user_namespaces.7:312
#, fuzzy
#| msgid ""
#| "Starting in Linux 3.8, unprivileged processes can create user namespaces, "
#| "and mount, PID, IPC, network, and UTS namespaces can be created with just "
#| "the B<CAP_SYS_ADMIN> capability in the caller's user namespace."
msgid ""
"Starting in Linux 3.8, unprivileged processes can create user namespaces, "
"and the other types of namespaces can be created with just the "
"B<CAP_SYS_ADMIN> capability in the caller's user namespace."
msgstr ""
"Linux 3.8 以降では、 非特権プロセスがユーザー名前空間を作成することができ"
"る。 また、 呼び出し元のユーザー名前空間で B<CAP_SYS_ADMIN> ケーパビリティを"
"持っているだけで、 マウント名前空間、 PID 名前空間、 IPC 名前空間、 ネット"
"ワーク名前空間、 UTS 名前空間を作成できる。"

#. type: Plain text
#: build/C/man7/user_namespaces.7:319
#, fuzzy
#| msgid ""
#| "When a non-user-namespace is created, it is owned by the user namespace "
#| "in which the creating process was a member at the time of the creation of "
#| "the namespace.  Actions on the non-user-namespace require capabilities in "
#| "the corresponding user namespace."
msgid ""
"When a nonuser namespace is created, it is owned by the user namespace in "
"which the creating process was a member at the time of the creation of the "
"namespace.  Privileged operations on resources governed by the nonuser "
"namespace require that the process has the necessary capabilities in the "
"user namespace that owns the nonuser namespace."
msgstr ""
"ユーザー名前空間以外の名前空間が作成された場合、 その名前空間は呼び出したプロ"
"セスが名前空間の作成時にメンバーであったユーザー名前空間により所有される。 "
"ユーザー名前空間以外の名前空間における操作には、 対応するユーザー名前空間での"
"ケーパビリティが必要である。"

#. type: Plain text
#: build/C/man7/user_namespaces.7:336
msgid ""
"If B<CLONE_NEWUSER> is specified along with other B<CLONE_NEW*> flags in a "
"single B<clone>(2)  or B<unshare>(2)  call, the user namespace is guaranteed "
"to be created first, giving the child (B<clone>(2))  or caller "
"(B<unshare>(2))  privileges over the remaining namespaces created by the "
"call.  Thus, it is possible for an unprivileged caller to specify this "
"combination of flags."
msgstr ""
"一つの B<clone>(2) や B<unshare>(2) の呼び出しで B<CLONE_NEWUSER> が他の "
"B<CLONE_NEW*> フラグと一緒に指定された場合、 そのユーザー名前空間が最初に作成"
"されることが保証され、 子プロセス (B<clone>(2) の場合) や呼び出し元 "
"(B<unshare>(2) の場合) はその呼び出しで作成される残りの名前空間で特権を持"
"つ。 したがって、 特権を持たない呼び出し元がフラグを組み合わせて指定すること"
"ができる。"

#
#. type: Plain text
#: build/C/man7/user_namespaces.7:358
#, fuzzy
#| msgid ""
#| "When a new IPC, mount, network, PID, or UTS namespace is created via "
#| "B<clone>(2)  or B<unshare>(2), the kernel records the user namespace of "
#| "the creating process against the new namespace.  (This association can't "
#| "be changed.)  When a process in the new namespace subsequently performs "
#| "privileged operations that operate on global resources isolated by the "
#| "namespace, the permission checks are performed according to the process's "
#| "capabilities in the user namespace that the kernel associated with the "
#| "new namespace."
msgid ""
"When a new namespace (other than a user namespace) is created via "
"B<clone>(2)  or B<unshare>(2), the kernel records the user namespace of the "
"creating process as the owner of the new namespace.  (This association can't "
"be changed.)  When a process in the new namespace subsequently performs "
"privileged operations that operate on global resources isolated by the "
"namespace, the permission checks are performed according to the process's "
"capabilities in the user namespace that the kernel associated with the new "
"namespace.  For example, suppose that a process attempts to change the "
"hostname (B<sethostname>(2)), a resource governed by the UTS namespace.  In "
"this case, the kernel will determine which user namespace owns the process's "
"UTS namespace, and check whether the process has the required capability "
"(B<CAP_SYS_ADMIN>)  in that user namespace."
msgstr ""
"新しい IPC 名前空間、 マウント名前空間、 ネットワーク名前空間、 PID 名前空"
"間、 UTS 名前空間が B<clone>(2) や B<unshare>(2) で作成される際、 カーネルは"
"新しい名前空間に対して作成したプロセスのユーザー名前空間を記録する (この関連"
"付けは変更できない)。 その新しい名前空間のプロセスがその後名前空間で分離され"
"たグローバルリソースに対して特権操作を行う場合、 カーネルが新しい名前空間に対"
"して関連付けたユーザー名前空間でのプロセスのケーパビリティに基づいてアクセス"
"許可のチェックが行われる。"

#
#.  ============================================================
#. type: Plain text
#: build/C/man7/user_namespaces.7:368
msgid ""
"The B<NS_GET_USERNS> B<ioctl>(2)  operation can be used to discover the user "
"namespace that owns a nonuser namespace; see B<ioctl_ns>(2)."
msgstr ""

#. type: SS
#: build/C/man7/user_namespaces.7:368
#, no-wrap
msgid "User and group ID mappings: uid_map and gid_map"
msgstr "ユーザー ID とグループ ID のマッピング: uid_map と gid_map"

#.  commit 22d917d80e842829d0ca0a561967d728eb1d6303
#. type: Plain text
#: build/C/man7/user_namespaces.7:383
msgid ""
"When a user namespace is created, it starts out without a mapping of user "
"IDs (group IDs)  to the parent user namespace.  The I</proc/[pid]/uid_map> "
"and I</proc/[pid]/gid_map> files (available since Linux 3.5)  expose the "
"mappings for user and group IDs inside the user namespace for the process "
"I<pid>.  These files can be read to view the mappings in a user namespace "
"and written to (once) to define the mappings."
msgstr ""
"ユーザー名前空間が作成された際、 その名前空間は親のユーザー名前空間へのユー"
"ザー ID (とグループ ID) のマッピングを行わずに開始される。 ファイル I</proc/"
"[pid]/uid_map> と I</proc/[pid]/gid_map> (Linux 3.5 以降で利用可能) でプロセ"
"ス I<pid> のユーザー名前空間内でのユーザー ID とグループ ID のマッピングにア"
"クセスできる。 これらのファイルを読み出してユーザー名前空間内のマッピングを参"
"照したり、 これらのファイルに書き込んでマッピングを (一度だけ) 定義することが"
"できる。"

#. type: Plain text
#: build/C/man7/user_namespaces.7:389
msgid ""
"The description in the following paragraphs explains the details for "
"I<uid_map>; I<gid_map> is exactly the same, but each instance of \"user ID\" "
"is replaced by \"group ID\"."
msgstr ""
"以下の段落で I<uid_map> の詳細を説明する。 I<gid_map> に関しても全く同じであ"
"る。 \"user ID\" という部分を \"group ID\" に置き換えればよい。"

#. type: Plain text
#: build/C/man7/user_namespaces.7:403
msgid ""
"The I<uid_map> file exposes the mapping of user IDs from the user namespace "
"of the process I<pid> to the user namespace of the process that opened "
"I<uid_map> (but see a qualification to this point below).  In other words, "
"processes that are in different user namespaces will potentially see "
"different values when reading from a particular I<uid_map> file, depending "
"on the user ID mappings for the user namespaces of the reading processes."
msgstr ""
"I<uid_map> ファイルで、 プロセス I<pid> のユーザー名前空間から I<uid_map> を"
"オープンしたプロセスのユーザー名前空間にユーザー ID のマッピングが公開される "
"(公開するポリシーの条件については下記を参照)。 言い換えると、 別のユーザー名"
"前空間のプロセスでは、 特定の I<uid_map> ファイルを読み出した際に潜在的には別"
"の値が見えることがあるということである。 見える値は読み出したプロセスのユー"
"ザー名前空間のユーザー ID マッピングに依存する。"

#. type: Plain text
#: build/C/man7/user_namespaces.7:415
msgid ""
"Each line in the I<uid_map> file specifies a 1-to-1 mapping of a range of "
"contiguous user IDs between two user namespaces.  (When a user namespace is "
"first created, this file is empty.)  The specification in each line takes "
"the form of three numbers delimited by white space.  The first two numbers "
"specify the starting user ID in each of the two user namespaces.  The third "
"number specifies the length of the mapped range.  In detail, the fields are "
"interpreted as follows:"
msgstr ""
"I<uid_map> ファイルの各行は 2 つのユーザー名前空間間の連続するユーザー ID の"
"範囲の 1 対 1 マッピングを指定する (ユーザー名前空間が最初に作成された際には"
"このファイルは空である)。 各行の指定の形式はホワイトスペース区切りの 3 つの数"
"字である。 最初の 2 つの数字は 2 つの ユーザー名前空間それぞれの開始ユーザー "
"ID を指定する。 3 つ目の数字はマッピングされる範囲の長さを指定する。 詳しく"
"は、各フィールドは以下のように解釈される。"

#. type: IP
#: build/C/man7/user_namespaces.7:415
#, no-wrap
msgid "(1)"
msgstr "(1)"

#. type: Plain text
#: build/C/man7/user_namespaces.7:419
msgid ""
"The start of the range of user IDs in the user namespace of the process "
"I<pid>."
msgstr "プロセス I<pid> のユーザー名前空間におけるユーザー ID の範囲の開始値。"

#. type: IP
#: build/C/man7/user_namespaces.7:419
#, no-wrap
msgid "(2)"
msgstr "(2)"

#. type: Plain text
#: build/C/man7/user_namespaces.7:427
msgid ""
"The start of the range of user IDs to which the user IDs specified by field "
"one map.  How field two is interpreted depends on whether the process that "
"opened I<uid_map> and the process I<pid> are in the same user namespace, as "
"follows:"
msgstr ""
"1 番目のフィールドで指定されたユーザー ID がマッピングされる先のユーザー ID "
"の範囲の開始値。 2 番目のフィールドがどのように解釈されるかは、 I<uid_map> を"
"オープンしたプロセスとプロセス I<pid> が同じユーザー名前空間かどうかに依存す"
"る。 以下のとおり。"

#. type: IP
#: build/C/man7/user_namespaces.7:428
#, no-wrap
msgid "a)"
msgstr "a)"

#. type: Plain text
#: build/C/man7/user_namespaces.7:433
msgid ""
"If the two processes are in different user namespaces: field two is the "
"start of a range of user IDs in the user namespace of the process that "
"opened I<uid_map>."
msgstr ""
"2 つのプロセスが異なるユーザー名前空間に属す場合、 2 番目のフィールドは "
"I<uid_map> をオープンしたプロセスのユーザー名前空間におけるユーザー ID の範囲"
"の開始値である。"

#. type: IP
#: build/C/man7/user_namespaces.7:433
#, no-wrap
msgid "b)"
msgstr "b)"

#. type: Plain text
#: build/C/man7/user_namespaces.7:444
msgid ""
"If the two processes are in the same user namespace: field two is the start "
"of the range of user IDs in the parent user namespace of the process "
"I<pid>.  This case enables the opener of I<uid_map> (the common case here is "
"opening I</proc/self/uid_map>)  to see the mapping of user IDs into the user "
"namespace of the process that created this user namespace."
msgstr ""
"2 つのプロセスが同じユーザー名前空間に属す場合、 2 番目のフィールドはプロセ"
"ス I<pid> の親のユーザー名前空間におけるユーザー ID の範囲の開始値である。 こ"
"の場合、 I<uid_map> をオープンしたプロセス (よくあるのは I</proc/self/"
"uid_map> をオープンした場合である) は、 このユーザー名前空間を作成したプロセ"
"スのユーザー名前空間に対するユーザー ID マッピングを参照することができる。"

#. type: IP
#: build/C/man7/user_namespaces.7:445
#, no-wrap
msgid "(3)"
msgstr "(3)"

#. type: Plain text
#: build/C/man7/user_namespaces.7:448
msgid ""
"The length of the range of user IDs that is mapped between the two user "
"namespaces."
msgstr "2 つのユーザー名前空間間でマッピングされるユーザー ID の範囲の長さ。"

#. type: Plain text
#: build/C/man7/user_namespaces.7:455
msgid ""
"System calls that return user IDs (group IDs)\\(emfor example, B<getuid>(2), "
"B<getgid>(2), and the credential fields in the structure returned by "
"B<stat>(2)\\(emreturn the user ID (group ID) mapped into the caller's user "
"namespace."
msgstr ""
"ユーザー ID (グループ ID) を返すシステムコール、例えば B<getuid>(2), "
"B<getgid>(2) や B<stat>(2) が返す構造体の credential フィールド、は呼び出し元"
"のユーザー名前空間にマッピングされたユーザー ID (グループ ID) を返す。"

#. type: Plain text
#: build/C/man7/user_namespaces.7:463
msgid ""
"When a process accesses a file, its user and group IDs are mapped into the "
"initial user namespace for the purpose of permission checking and assigning "
"IDs when creating a file.  When a process retrieves file user and group IDs "
"via B<stat>(2), the IDs are mapped in the opposite direction, to produce "
"values relative to the process user and group ID mappings."
msgstr ""
"プロセスがファイルにアクセスする場合、 アクセス許可のチェックやファイル作成時"
"の ID 割り当てのために、 そのユーザー ID とグループ ID は初期ユーザー名前空間"
"にマッピングされる。 プロセスが B<stat>(2) を使ってファイルのユーザー ID やグ"
"ループ ID を取得する際には、 上記の反対方向に ID のマッピングが行われ、 プロ"
"セスにおける相対的なユーザー ID とグループ ID の値が生成される。"

#. type: Plain text
#: build/C/man7/user_namespaces.7:472
msgid ""
"The initial user namespace has no parent namespace, but, for consistency, "
"the kernel provides dummy user and group ID mapping files for this "
"namespace.  Looking at the I<uid_map> file (I<gid_map> is the same) from a "
"shell in the initial namespace shows:"
msgstr ""
"初期ユーザー名前空間は親の名前空間を持たないが、 一貫性を持たせるため、 カー"
"ネルは初期の名前空間に対してダミーのユーザー ID とグループ ID のマッピングを"
"提供する。 初期の名前空間のシェルから I<uid_map> ファイル (I<gid_map> も同"
"じ) を参照するには以下のようにする。"

#. type: Plain text
#: build/C/man7/user_namespaces.7:477
#, no-wrap
msgid ""
"$ B<cat /proc/$$/uid_map>\n"
"         0          0 4294967295\n"
msgstr ""
"$ B<cat /proc/$$/uid_map>\n"
"         0          0 4294967295\n"

#
#.  ============================================================
#. type: Plain text
#: build/C/man7/user_namespaces.7:497
msgid ""
"This mapping tells us that the range starting at user ID 0 in this namespace "
"maps to a range starting at 0 in the (nonexistent) parent namespace, and the "
"length of the range is the largest 32-bit unsigned integer.  This leaves "
"4294967295 (the 32-bit signed -1 value) unmapped.  This is deliberate: "
"I<(uid_t)\\ -1> is used in several interfaces (e.g., B<setreuid>(2))  as a "
"way to specify \"no user ID\".  Leaving I<(uid_t)\\ -1> unmapped and "
"unusable guarantees that there will be no confusion when using these "
"interfaces."
msgstr "このマッピングは、 この名前空間のユーザー ID 0 から始まる範囲が (実際には存在しない) 親の名前空間の 0 から始まる範囲にマッピングされ、 範囲の流さは 32 ビットの unsigned integer の最大値である、 と言っている。 (ここで 4294967295 (32 ビットの符号付き -1 の値) はマッピングされていない。 I<(uid_t)\\ -1> は (B<setreuid>(2) など) いくつかのインターフェースで \"no user ID\" (ユーザー ID なし) を示す手段として使用されているので、 意図的にこのようになっている。 I<(uid_t)\\ -1> をマッピングせず、 利用できないようにすることで、 これらのインターフェースを使った際に混乱が起こらないように保証している。)"

#. type: SS
#: build/C/man7/user_namespaces.7:497
#, no-wrap
msgid "Defining user and group ID mappings: writing to uid_map and gid_map"
msgstr "ユーザー ID とグループ ID のマッピングの定義: uid_map と gid_map への書き込み"

#. type: Plain text
#: build/C/man7/user_namespaces.7:513
msgid ""
"After the creation of a new user namespace, the I<uid_map> file of I<one> of "
"the processes in the namespace may be written to I<once> to define the "
"mapping of user IDs in the new user namespace.  An attempt to write more "
"than once to a I<uid_map> file in a user namespace fails with the error "
"B<EPERM>.  Similar rules apply for I<gid_map> files."
msgstr ""
"新しいユーザー名前空間を作成した後、 新しいユーザー名前空間におけるユーザー "
"ID のマッピングを定義するため、 その名前空間のプロセスの「一つ」の "
"I<uid_map> ファイルに「一度だけ」書き込みを行うことができる。 ユーザー名前空"
"間の I<uid_map> ファイルに二度目以降の書き込みを行おうとすると、 エラー "
"B<EPERM> で失敗する。 I<gid_map> ファイルについては同じルールが適用される。"

#. type: Plain text
#: build/C/man7/user_namespaces.7:518
msgid ""
"The lines written to I<uid_map> (I<gid_map>)  must conform to the following "
"rules:"
msgstr ""
"I<uid_map> (I<gid_map>) に書き込む行は以下のルールに従っていなければならな"
"い。"

#. type: Plain text
#: build/C/man7/user_namespaces.7:521
msgid ""
"The three fields must be valid numbers, and the last field must be greater "
"than 0."
msgstr ""
"3 のフィールドは有効な数字でなければならず、最後のフィールドは 0 より大きくな"
"ければならない。"

#. type: Plain text
#: build/C/man7/user_namespaces.7:523
msgid "Lines are terminated by newline characters."
msgstr "行は改行文字で終了しなければならない。"

#.  5*12-byte records could fit in a 64B cache line
#.  commit 6397fac4915ab3002dc15aae751455da1a852f25
#. type: Plain text
#: build/C/man7/user_namespaces.7:538
#, fuzzy
#| msgid ""
#| "There is an (arbitrary) limit on the number of lines in the file.  As at "
#| "Linux 3.8, the limit is five lines.  In addition, the number of bytes "
#| "written to the file must be less than the system page size, and the write "
#| "must be performed at the start of the file (i.e., B<lseek>(2)  and "
#| "B<pwrite>(2)  can't be used to write to nonzero offsets in the file)."
msgid ""
"There is a limit on the number of lines in the file.  In Linux 4.14 and "
"earlier, this limit was (arbitrarily)  set at 5 lines.  Since Linux 4.15, "
"the limit is 340 lines.  In addition, the number of bytes written to the "
"file must be less than the system page size, and the write must be performed "
"at the start of the file (i.e., B<lseek>(2)  and B<pwrite>(2)  can't be used "
"to write to nonzero offsets in the file)."
msgstr ""
"ファイルの行数には上限がある。 Linux 3.8 時点では、上限は 5 行である。 さら"
"に、 ファイルに書き込むバイト数はシステムページサイズより小さくなければなら"
"ず、 書き込みはファイルの先頭に対して行わなければならない (つまり、 "
"B<lseek>(2) や B<pwrite>(2) を使って 0 以外のファイルオフセットに書き込むこと"
"はできない)。"

#.  commit 0bd14b4fd72afd5df41e9fd59f356740f22fceba
#. type: Plain text
#: build/C/man7/user_namespaces.7:551
msgid ""
"The range of user IDs (group IDs)  specified in each line cannot overlap "
"with the ranges in any other lines.  In the initial implementation (Linux "
"3.8), this requirement was satisfied by a simplistic implementation that "
"imposed the further requirement that the values in both field 1 and field 2 "
"of successive lines must be in ascending numerical order, which prevented "
"some otherwise valid maps from being created.  Linux 3.9 and later fix this "
"limitation, allowing any valid set of nonoverlapping maps."
msgstr ""
"各行で指定されるユーザー ID (グループ ID) の範囲は他の行が指定する範囲と重"
"なってはならない。 最初の実装 (Linux 3.8) では、 この要件は、 後続行のフィー"
"ルド 1 とフィールド 2 の両方の値が昇順になっていなければならないという追加の"
"要件を設け、 これが満たされなかった場合は有効なマッピングは作成されない、 と"
"いう単純な実装により満たされていた。 Linux 3.9 以降ではこの制限は修正され、 "
"重複がない有効なマッピングであればどんな組み合わせでも指定できるようになっ"
"た。"

#. type: Plain text
#: build/C/man7/user_namespaces.7:553
msgid "At least one line must be written to the file."
msgstr "少なくとも 1 行はファイルに書き込まなければならない。"

#. type: Plain text
#: build/C/man7/user_namespaces.7:556
msgid "Writes that violate the above rules fail with the error B<EINVAL>."
msgstr "上記のルールを満たさない書き込みはエラー B<EINVAL> で失敗する。"

#. type: Plain text
#: build/C/man7/user_namespaces.7:561
msgid ""
"In order for a process to write to the I</proc/[pid]/uid_map> (I</proc/[pid]/"
"gid_map>)  file, all of the following requirements must be met:"
msgstr ""
"プロセスが I</proc/[pid]/uid_map> (I</proc/[pid]/gid_map>) ファイルに書き込む"
"ためには、 以下の要件がすべて満たされる必要がある。"

#. type: Plain text
#: build/C/man7/user_namespaces.7:567
msgid ""
"The writing process must have the B<CAP_SETUID> (B<CAP_SETGID>)  capability "
"in the user namespace of the process I<pid>."
msgstr ""
"書き込みプロセスは、 プロセス I<pid> のユーザー名前空間で B<CAP_SETUID> "
"(B<CAP_SETGID>) ケーパビリティを持っていなければならない。"

#. type: Plain text
#: build/C/man7/user_namespaces.7:572
msgid ""
"The writing process must either be in the user namespace of the process "
"I<pid> or be in the parent user namespace of the process I<pid>."
msgstr ""
"書き込みプロセスは、 プロセス I<pid> のユーザー名前空間もしくはプロセス "
"I<pid> の親のユーザー名前空間に属していなければならない。"

#. type: Plain text
#: build/C/man7/user_namespaces.7:575
msgid ""
"The mapped user IDs (group IDs) must in turn have a mapping in the parent "
"user namespace."
msgstr ""
"マッピングされたユーザー ID (グループ ID) は親のユーザー名前空間にマッピング"
"を持っていなければならない。"

#. type: IP
#: build/C/man7/user_namespaces.7:575
#, no-wrap
msgid "4."
msgstr "4."

#. type: Plain text
#: build/C/man7/user_namespaces.7:577
#, fuzzy
#| msgid "One of the following is true:"
msgid "One of the following two cases applies:"
msgstr "以下のいずれか一つが真である。"

#. type: Plain text
#: build/C/man7/user_namespaces.7:586
#, fuzzy
#| msgid ""
#| "The writing process must have the B<CAP_SETUID> (B<CAP_SETGID>)  "
#| "capability in the user namespace of the process I<pid>."
msgid ""
"I<Either> the writing process has the B<CAP_SETUID> (B<CAP_SETGID>)  "
"capability in the I<parent> user namespace."
msgstr ""
"書き込みプロセスは、 プロセス I<pid> のユーザー名前空間で B<CAP_SETUID> "
"(B<CAP_SETGID>) ケーパビリティを持っていなければならない。"

#. type: Plain text
#: build/C/man7/user_namespaces.7:591
#, fuzzy
#| msgid ""
#| "The opening process has the B<CAP_SETUID> (B<CAP_SETGID>)  capability in "
#| "the parent user namespace.  Thus, a privileged process can make mappings "
#| "to arbitrary user IDs (group IDs)  in the parent user namespace."
msgid ""
"No further restrictions apply: the process can make mappings to arbitrary "
"user IDs (group IDs)  in the parent user namespace."
msgstr ""
"オープンしたプロセスが親のユーザー名前空間で B<CAP_SETUID> (B<CAP_SETGID>) "
"ケーパビリティを持っている。 したがって、 特権プロセスは親のユーザー名前空間"
"の任意のユーザー ID (グループ ID) に対するマッピングを作成できる。"

#. type: Plain text
#: build/C/man7/user_namespaces.7:595
msgid "I<Or> otherwise all of the following restrictions apply:"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:604
#, fuzzy
#| msgid ""
#| "The data written to I<uid_map> (I<gid_map>)  consists of a single line "
#| "that maps the writing process's filesystem user ID (group ID) in the "
#| "parent user namespace to a user ID (group ID)  in the user namespace.  "
#| "The usual case here is that this single line provides a mapping for user "
#| "ID of the process that created the namespace."
msgid ""
"The data written to I<uid_map> (I<gid_map>)  must consist of a single line "
"that maps the writing process's effective user ID (group ID) in the parent "
"user namespace to a user ID (group ID)  in the user namespace."
msgstr ""
"I<uid_map> (I<gid_map>) に書き込まれるデータは、 書き込みを行うプロセスの親の"
"ユーザー名前空間でのファイルシステムユーザー ID (グループ ID) をそのユーザー"
"名前空間でのユーザー ID (グループ ID) にマッピングする 1 行で構成されている。"

#. type: Plain text
#: build/C/man7/user_namespaces.7:607
#, fuzzy
#| msgid ""
#| "The writing process must be in either the user namespace of the process "
#| "I<pid> or inside the parent user namespace of the process I<pid>."
msgid ""
"The writing process must have the same effective user ID as the process that "
"created the user namespace."
msgstr ""
"書き込みプロセスは、 プロセス I<pid> のユーザー名前空間もしくはプロセス "
"I<pid> の親のユーザー名前空間に属していなければならない。"

#. type: Plain text
#: build/C/man7/user_namespaces.7:618
msgid ""
"In the case of I<gid_map>, use of the B<setgroups>(2)  system call must "
"first be denied by writing \"I<deny>\" to the I</proc/[pid]/setgroups> file "
"(see below) before writing to I<gid_map>."
msgstr ""

#
#.  ============================================================
#. type: Plain text
#: build/C/man7/user_namespaces.7:626
msgid "Writes that violate the above rules fail with the error B<EPERM>."
msgstr "上記のルールを満たさない書き込みはエラー B<EPERM> で失敗する。"

#. type: SS
#: build/C/man7/user_namespaces.7:626
#, no-wrap
msgid "Interaction with system calls that change process UIDs or GIDs"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:639
msgid ""
"In a user namespace where the I<uid_map> file has not been written, the "
"system calls that change user IDs will fail.  Similarly, if the I<gid_map> "
"file has not been written, the system calls that change group IDs will "
"fail.  After the I<uid_map> and I<gid_map> files have been written, only the "
"mapped values may be used in system calls that change user and group IDs."
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:653
msgid ""
"For user IDs, the relevant system calls include B<setuid>(2), "
"B<setfsuid>(2), B<setreuid>(2), and B<setresuid>(2).  For group IDs, the "
"relevant system calls include B<setgid>(2), B<setfsgid>(2), B<setregid>(2), "
"B<setresgid>(2), and B<setgroups>(2)."
msgstr ""

#
#.  Things changed in Linux 3.19
#.  commit 9cc46516ddf497ea16e8d7cb986ae03a0f6b92f8
#.  commit 66d2f338ee4c449396b6f99f5e75cd18eb6df272
#.  http://lwn.net/Articles/626665/
#.  ============================================================
#. type: Plain text
#: build/C/man7/user_namespaces.7:674
msgid ""
"Writing \"I<deny>\" to the I</proc/[pid]/setgroups> file before writing to "
"I</proc/[pid]/gid_map> will permanently disable B<setgroups>(2)  in a user "
"namespace and allow writing to I</proc/[pid]/gid_map> without having the "
"B<CAP_SETGID> capability in the parent user namespace."
msgstr ""

#. type: SS
#: build/C/man7/user_namespaces.7:674
#, no-wrap
msgid "The /proc/[pid]/setgroups file"
msgstr "/proc/[pid]/setgroups ファイル"

#
#.  commit 9cc46516ddf497ea16e8d7cb986ae03a0f6b92f8
#.  commit 66d2f338ee4c449396b6f99f5e75cd18eb6df272
#.  http://lwn.net/Articles/626665/
#.  http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2014-8989
#. type: Plain text
#: build/C/man7/user_namespaces.7:701
msgid ""
"The I</proc/[pid]/setgroups> file displays the string \"I<allow>\" if "
"processes in the user namespace that contains the process I<pid> are "
"permitted to employ the B<setgroups>(2)  system call; it displays \"I<deny>"
"\" if B<setgroups>(2)  is not permitted in that user namespace.  Note that "
"regardless of the value in the I</proc/[pid]/setgroups> file (and regardless "
"of the process's capabilities), calls to B<setgroups>(2)  are also not "
"permitted if I</proc/[pid]/gid_map> has not yet been set."
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:717
msgid ""
"A privileged process (one with the B<CAP_SYS_ADMIN> capability in the "
"namespace) may write either of the strings \"I<allow>\" or \"I<deny>\" to "
"this file I<before> writing a group ID mapping for this user namespace to "
"the file I</proc/[pid]/gid_map>.  Writing the string \"I<deny>\" prevents "
"any process in the user namespace from employing B<setgroups>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:736
msgid ""
"The essence of the restrictions described in the preceding paragraph is that "
"it is permitted to write to I</proc/[pid]/setgroups> only so long as calling "
"B<setgroups>(2)  is disallowed because I</proc/[pid]/gid_map> has not been "
"set.  This ensures that a process cannot transition from a state where "
"B<setgroups>(2)  is allowed to a state where B<setgroups>(2)  is denied; a "
"process can transition only from B<setgroups>(2)  being disallowed to "
"B<setgroups>(2)  being allowed."
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:739
msgid ""
"The default value of this file in the initial user namespace is \"I<allow>\"."
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:754
msgid ""
"Once I</proc/[pid]/gid_map> has been written to (which has the effect of "
"enabling B<setgroups>(2)  in the user namespace), it is no longer possible "
"to disallow B<setgroups>(2)  by writing \"I<deny>\" to I</proc/[pid]/"
"setgroups> (the write fails with the error B<EPERM>)."
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:758
msgid ""
"A child user namespace inherits the I</proc/[pid]/setgroups> setting from "
"its parent."
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:772
msgid ""
"If the I<setgroups> file has the value \"I<deny>\", then the "
"B<setgroups>(2)  system call can't subsequently be reenabled (by writing "
"\"I<allow>\" to the file) in this user namespace.  (Attempts to do so fail "
"with the error B<EPERM>.)  This restriction also propagates down to all "
"child user namespaces of this user namespace."
msgstr ""

#
#
#
#
#.  /proc/PID/setgroups
#. 	[allow == setgroups() is allowed, "deny" == setgroups() is disallowed]
#. 	* Can write if have CAP_SYS_ADMIN in NS
#. 	* Must write BEFORE writing to /proc/PID/gid_map
#.  setgroups()
#. 	* Must already have written to gid_map
#. 	* /proc/PID/setgroups must be "allow"
#.  /proc/PID/gid_map -- writing
#. 	* Must already have written "deny" to /proc/PID/setgroups
#.  ============================================================
#. type: Plain text
#: build/C/man7/user_namespaces.7:814
msgid ""
"The I</proc/[pid]/setgroups> file was added in Linux 3.19, but was "
"backported to many earlier stable kernel series, because it addresses a "
"security issue.  The issue concerned files with permissions such as \"rwx---"
"rwx\".  Such files give fewer permissions to \"group\" than they do to "
"\"other\".  This means that dropping groups using B<setgroups>(2)  might "
"allow a process file access that it did not formerly have.  Before the "
"existence of user namespaces this was not a concern, since only a privileged "
"process (one with the B<CAP_SETGID> capability) could call B<setgroups>(2).  "
"However, with the introduction of user namespaces, it became possible for an "
"unprivileged process to create a new namespace in which the user had all "
"privileges.  This then allowed formerly unprivileged users to drop groups "
"and thus gain file access that they did not previously have.  The I</proc/"
"[pid]/setgroups> file was added to address this security issue, by denying "
"any pathway for an unprivileged process to drop groups with B<setgroups>(2)."
msgstr ""

#. type: SS
#: build/C/man7/user_namespaces.7:814
#, no-wrap
msgid "Unmapped user and group IDs"
msgstr "マッピングされていないユーザー ID とグループ ID"

#.  from_kuid_munged(), from_kgid_munged()
#. type: Plain text
#: build/C/man7/user_namespaces.7:831
msgid ""
"There are various places where an unmapped user ID (group ID)  may be "
"exposed to user space.  For example, the first process in a new user "
"namespace may call B<getuid>(2)  before a user ID mapping has been defined "
"for the namespace.  In most such cases, an unmapped user ID is converted to "
"the overflow user ID (group ID); the default value for the overflow user ID "
"(group ID) is 65534.  See the descriptions of I</proc/sys/kernel/"
"overflowuid> and I</proc/sys/kernel/overflowgid> in B<proc>(5)."
msgstr "マッピングされていないユーザー ID (グループ ID) がユーザー空間に公開される場合はいろいろある。例えば、 新しいユーザー名前空間の最初のプロセスが、 その名前空間に対するユーザー ID マッピングが定義される前に B<getuid>(2) を呼び出すなどである。 このようなほとんどの場合で、 マッピングされていないユーザー ID はオーバーフローユーザー ID (グループ ID)に変換される。 デフォルトのオーバーフローユーザー ID (グループ ID) は 65534 である。 B<proc>(5) の I</proc/sys/kernel/overflowuid> と I</proc/sys/kernel/overflowgid> の説明を参照。"

#.  also SO_PEERCRED
#. type: Plain text
#: build/C/man7/user_namespaces.7:859
msgid ""
"The cases where unmapped IDs are mapped in this fashion include system calls "
"that return user IDs (B<getuid>(2), B<getgid>(2), and similar), credentials "
"passed over a UNIX domain socket, credentials returned by B<stat>(2), "
"B<waitid>(2), and the System V IPC \"ctl\" B<IPC_STAT> operations, "
"credentials exposed by I</proc/[pid]/status> and the files in I</proc/"
"sysvipc/*>, credentials returned via the I<si_uid> field in the I<siginfo_t> "
"received with a signal (see B<sigaction>(2)), credentials written to the "
"process accounting file (see B<acct>(5)), and credentials returned with "
"POSIX message queue notifications (see B<mq_notify>(3))."
msgstr "マッピングされていない ID がこのようにマッピングされる場合としては、 ユーザー ID を返すシステムコール (B<getuid>(2), B<getgid>(2) やその同類)、 UNIX ドメインソケットで渡される ID 情報 (credential)、 B<stat>(2) が返す ID 情報、 B<waitid>(2)、 System V IPC \"ctl\" B<IPC_STAT> 操作、 I</proc/[pid]/status> や I</proc/sysvipc/*> 内のファイルで公開される ID 情報、 シグナル受信時の I<siginfo_t> の I<si_uid> フィールドで返される ID 情報 (B<sigaction>(2) 参照)、 プロセスアカウンティングファイルに書き込まれる ID 情報 (B<acct>(5) 参照)、 POSIX メッセージキュー通知で返される ID 情報 (B<mq_notify>(3) 参照) がある。"

#
#.  from_kuid(), from_kgid()
#.  Also F_GETOWNER_UIDS is an exception
#.  ============================================================
#. type: Plain text
#: build/C/man7/user_namespaces.7:874
msgid ""
"There is one notable case where unmapped user and group IDs are I<not> "
"converted to the corresponding overflow ID value.  When viewing a I<uid_map> "
"or I<gid_map> file in which there is no mapping for the second field, that "
"field is displayed as 4294967295 (-1 as an unsigned integer)."
msgstr ""
"マッピングされていないユーザー ID やグループ ID が対応するオーバーフロー ID "
"値に変換され「ない」重要な場合が一つある。 2 番目のフィールドにマッピングがな"
"い I<uid_map> や I<gid_map> ファイルを参照した際、 そのフィールドは "
"4294967295 (unsigned integer では -1) が表示される。"

#. type: SS
#: build/C/man7/user_namespaces.7:874
#, no-wrap
msgid "Accessing files"
msgstr ""

#
#.  ============================================================
#. type: Plain text
#: build/C/man7/user_namespaces.7:886
msgid ""
"In order to determine permissions when an unprivileged process accesses a "
"file, the process credentials (UID, GID) and the file credentials are in "
"effect mapped back to what they would be in the initial user namespace and "
"then compared to determine the permissions that the process has on the "
"file.  The same is also of other objects that employ the credentials plus "
"permissions mask accessibility model, such as System V IPC objects"
msgstr ""

#. type: SS
#: build/C/man7/user_namespaces.7:886
#, no-wrap
msgid "Operation of file-related capabilities"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:898
msgid ""
"Certain capabilities allow a process to bypass various kernel-enforced "
"restrictions when performing operations on files owned by other users or "
"groups.  These capabilities are: B<CAP_CHOWN>, B<CAP_DAC_OVERRIDE>, "
"B<CAP_DAC_READ_SEARCH>, B<CAP_FOWNER>, and B<CAP_FSETID>."
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:903
msgid ""
"Within a user namespace, these capabilities allow a process to bypass the "
"rules if the process has the relevant capability over the file, meaning that:"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:905
msgid ""
"the process has the relevant effective capability in its user namespace; and"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:908
#, fuzzy
#| msgid ""
#| "The mapped user IDs (group IDs) must in turn have a mapping in the parent "
#| "user namespace."
msgid ""
"the file's user ID and group ID both have valid mappings in the user "
"namespace."
msgstr ""
"マッピングされたユーザー ID (グループ ID) は親のユーザー名前空間にマッピング"
"を持っていなければならない。"

#
#.  These are the checks performed by the kernel function
#.  inode_owner_or_capable(). There is one exception to the exception:
#.  overriding the directory sticky permission bit requires that
#.  the file has a valid mapping for both its UID and GID.
#.  ============================================================
#. type: Plain text
#: build/C/man7/user_namespaces.7:922
msgid ""
"The B<CAP_FOWNER> capability is treated somewhat exceptionally: it allows a "
"process to bypass the corresponding rules so long as at least the file's "
"user ID has a mapping in the user namespace (i.e., the file's group ID does "
"not need to have a valid mapping)."
msgstr ""

#. type: SS
#: build/C/man7/user_namespaces.7:922
#, no-wrap
msgid "Set-user-ID and set-group-ID programs"
msgstr "set-user-ID や set-group-ID されたプログラム"

#
#.  ============================================================
#. type: Plain text
#: build/C/man7/user_namespaces.7:942
msgid ""
"When a process inside a user namespace executes a set-user-ID (set-group-ID) "
"program, the process's effective user (group) ID inside the namespace is "
"changed to whatever value is mapped for the user (group) ID of the file.  "
"However, if either the user I<or> the group ID of the file has no mapping "
"inside the namespace, the set-user-ID (set-group-ID) bit is silently "
"ignored: the new program is executed, but the process's effective user "
"(group) ID is left unchanged.  (This mirrors the semantics of executing a "
"set-user-ID or set-group-ID program that resides on a filesystem that was "
"mounted with the B<MS_NOSUID> flag, as described in B<mount>(2).)"
msgstr ""
"ユーザー名前空間内のプロセスが set-user-ID (set-group-ID) されたプログラムを"
"実行した場合、 そのプロセスの名前空間内の実効ユーザー ID (実効グループ ID) "
"は、 そのファイルのユーザー ID (グループ ID) にマッピングされる。 しかし、 そ"
"のファイルのユーザー ID 「か」グループ ID が名前空間内のマッピングにない場"
"合、 set-user-ID (set-group-ID) ビットは黙って無視される。 新しいプログラムは"
"実行されるが、 そのプロセスの実効ユーザー ID (実効グループ ID) は変更されない"
"ままとなる。 (これは B<MS_NOSUID> フラグ付きでマウントされたファイルシステム"
"上にある set-user-ID/set-group-ID プログラムを実行した場合の動作を反映したも"
"のである。 B<mount>(2) を参照。)"

#. type: Plain text
#: build/C/man7/user_namespaces.7:952
msgid ""
"When a process's user and group IDs are passed over a UNIX domain socket to "
"a process in a different user namespace (see the description of "
"B<SCM_CREDENTIALS> in B<unix>(7)), they are translated into the "
"corresponding values as per the receiving process's user and group ID "
"mappings."
msgstr ""
"プロセスのユーザー ID とグループ ID が UNIX ドメインソケットを通して別のユー"
"ザー名前空間のプロセスに渡された場合 (B<unix>(7) の B<SCM_CREDENTIALS> の説明"
"を参照)、 ユーザー ID とグループ ID は受信プロセスのユーザー ID とグループ "
"ID のマッピングに基づき対応する値に翻訳される。"

#
#.  ============================================================
#. type: Plain text
#: build/C/man7/user_namespaces.7:965
msgid ""
"Over the years, there have been a lot of features that have been added to "
"the Linux kernel that have been made available only to privileged users "
"because of their potential to confuse set-user-ID-root applications.  In "
"general, it becomes safe to allow the root user in a user namespace to use "
"those features because it is impossible, while in a user namespace, to gain "
"more privilege than the root user of a user namespace has."
msgstr ""
"長年にわたり、Linux カーネルには特権ユーザーに対してだけ利用できる機能が多く"
"追加されて来た。 これは set-user-ID-root アプリケーションを混乱させる潜在的な"
"可能性を考慮してである。 一般的には、 ユーザー名前空間の root ユーザーにだけ"
"これらの機能の使用を許可するのが安全である。 なぜなら、ユーザー名前空間の中に"
"いる間は、 ユーザー名前空間の root ユーザーが持っている以上の特権を得ることは"
"できないからである。"

#. type: SS
#: build/C/man7/user_namespaces.7:965
#, no-wrap
msgid "Availability"
msgstr "可用性"

#. type: Plain text
#: build/C/man7/user_namespaces.7:973
msgid ""
"Use of user namespaces requires a kernel that is configured with the "
"B<CONFIG_USER_NS> option.  User namespaces require support in a range of "
"subsystems across the kernel.  When an unsupported subsystem is configured "
"into the kernel, it is not possible to configure user namespaces support."
msgstr ""
"ユーザー名前空間を使用するには、 B<CONFIG_USER_NS> オプションが有効になった"
"カーネルが必要である。 ユーザー名前空間をカーネルの様々なサブシステムのサポー"
"トを必要とする。 サポートされていないサブシステムがカーネルに組み込まれている"
"場合、 ユーザー名前空間のサポートを有効にすることはできない。"

#.  commit d6970d4b726cea6d7a9bc4120814f95c09571fc3
#. type: Plain text
#: build/C/man7/user_namespaces.7:984
msgid ""
"As at Linux 3.8, most relevant subsystems supported user namespaces, but a "
"number of filesystems did not have the infrastructure needed to map user and "
"group IDs between user namespaces.  Linux 3.9 added the required "
"infrastructure support for many of the remaining unsupported filesystems "
"(Plan 9 (9P), Andrew File System (AFS), Ceph, CIFS, CODA, NFS, and OCFS2).  "
"Linux 3.12 added support for the last of the unsupported major filesystems, "
"XFS."
msgstr "Linux 3.8 時点では、 ほとんどの関連するサブシステムはユーザー名前空間に対応しているが、 多くのファイルシステムにユーザー名前空間間でユーザー ID やグループ ID のマッピングを行うのに必要な基盤がなかった。 Linux 3.9 では、 残りの未サポートのファイルシステムの多くで必要な基盤のサポートが追加された (Plan 9 (9P), Andrew File System (AFS), Ceph, CIFS, CODA, NFS, OCFS2)。 Linux 3.12 では、最後の主要な未サポートのファイルシステムであった XFS のサポートが追加された。"

#. type: Plain text
#: build/C/man7/user_namespaces.7:993
msgid ""
"The program below is designed to allow experimenting with user namespaces, "
"as well as other types of namespaces.  It creates namespaces as specified by "
"command-line options and then executes a command inside those namespaces.  "
"The comments and I<usage()> function inside the program provide a full "
"explanation of the program.  The following shell session demonstrates its "
"use."
msgstr ""
"以下のプログラムは、ユーザー名前空間で実験を行えるように設計されている。 他の"
"種類の名前空間も扱える。 このプログラムはコマンドライン引数で指定された名前"
"空間を作成し、作成した名前空間内でコマンドを実行する。 コメントとプログラム内"
"の I<usage()> 関数に、プログラムの詳しい説明が書かれている。 以下のシェルセッ"
"ションに実行例を示す。"

#. type: Plain text
#: build/C/man7/user_namespaces.7:995
msgid "First, we look at the run-time environment:"
msgstr "まず最初に、実行環境を確認しておく。"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1004
#, no-wrap
msgid ""
"$ B<uname -rs>     # Need Linux 3.8 or later\n"
"Linux 3.8.0\n"
"$ B<id -u>         # Running as unprivileged user\n"
"1000\n"
"$ B<id -g>\n"
"1000\n"
msgstr ""
"$ B<uname -rs>     # Linux 3.8 以降が必要\n"
"Linux 3.8.0\n"
"$ B<id -u>         # 非特権ユーザーで実行する\n"
"1000\n"
"$ B<id -g>\n"
"1000\n"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1018
msgid ""
"Now start a new shell in new user (I<-U>), mount (I<-m>), and PID (I<-p>)  "
"namespaces, with user ID (I<-M>)  and group ID (I<-G>)  1000 mapped to 0 "
"inside the user namespace:"
msgstr ""
"新しいユーザー名前空間 (I<-U>), マウント名前空間 (I<-m>), PID 名前空間 (I<-"
"p>) で新しいシェルを開始する。ユーザー ID (I<-M>) 1000 とグループ ID (I<-G>) "
"1000 をユーザー名前空間内で 0 にマッピングしている。"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1022
#, no-wrap
msgid "$ B<./userns_child_exec -p -m -U -M \\(aq0 1000 1\\(aq -G \\(aq0 1000 1\\(aq bash>\n"
msgstr "$ B<./userns_child_exec -p -m -U -M \\(aq0 1000 1\\(aq -G \\(aq0 1000 1\\(aq bash>\n"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1027
msgid ""
"The shell has PID 1, because it is the first process in the new PID "
"namespace:"
msgstr ""
"シェルは PID 1 を持つ。このシェルは新しい PID 名前空間の最初のプロセスだから"
"である。"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1032
#, no-wrap
msgid ""
"bash$ B<echo $$>\n"
"1\n"
msgstr ""
"bash$ B<echo $$>\n"
"1\n"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1040
msgid ""
"Mounting a new I</proc> filesystem and listing all of the processes visible "
"in the new PID namespace shows that the shell can't see any processes "
"outside the PID namespace:"
msgstr ""
"I</proc> ファイルシステムをマウントし、新しい PID 名前空間で見えるプロセス一"
"覧を表示すると、 シェルからは PID 名前空間外のプロセスが見えないことが分か"
"る。"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1048
#, no-wrap
msgid ""
"bash$ B<mount -t proc proc /proc>\n"
"bash$ B<ps ax>\n"
"  PID TTY      STAT   TIME COMMAND\n"
"    1 pts/3    S      0:00 bash\n"
"   22 pts/3    R+     0:00 ps ax\n"
msgstr ""
"bash$ B<mount -t proc proc /proc>\n"
"bash$ B<ps ax>\n"
"  PID TTY      STAT   TIME COMMAND\n"
"    1 pts/3    S      0:00 bash\n"
"   22 pts/3    R+     0:00 ps ax\n"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1053
msgid ""
"Inside the user namespace, the shell has user and group ID 0, and a full set "
"of permitted and effective capabilities:"
msgstr ""
"ユーザー名前空間内では、シェルのユーザー ID とグループ ID ともに 0 で、すべて"
"の許可ケーパビリティと実効ケーパビリティが有効になっている。"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1063
#, no-wrap
msgid ""
"bash$ B<cat /proc/$$/status | egrep \\(aq\\(ha[UG]id\\(aq>\n"
"Uid:\t0\t0\t0\t0\n"
"Gid:\t0\t0\t0\t0\n"
"bash$ B<cat /proc/$$/status | egrep \\(aq\\(haCap(Prm|Inh|Eff)\\(aq>\n"
"CapInh:\t0000000000000000\n"
"CapPrm:\t0000001fffffffff\n"
"CapEff:\t0000001fffffffff\n"
msgstr ""
"bash$ B<cat /proc/$$/status | egrep \\(aq\\(ha[UG]id\\(aq>\n"
"Uid:\t0\t0\t0\t0\n"
"Gid:\t0\t0\t0\t0\n"
"bash$ B<cat /proc/$$/status | egrep \\(aq\\(haCap(Prm|Inh|Eff)\\(aq>\n"
"CapInh:\t0000000000000000\n"
"CapPrm:\t0000001fffffffff\n"
"CapEff:\t0000001fffffffff\n"

#. type: SS
#: build/C/man7/user_namespaces.7:1065
#, no-wrap
msgid "Program source"
msgstr "プログラムのソース"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1069
#, no-wrap
msgid "/* userns_child_exec.c\n"
msgstr "/* userns_child_exec.c\n"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1071
#, no-wrap
msgid "   Licensed under GNU General Public License v2 or later\n"
msgstr "   GNU General Public License v2 以降の元でライセンスされる\n"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1088
#, no-wrap
msgid ""
"   Create a child process that executes a shell command in new\n"
"   namespace(s); allow UID and GID mappings to be specified when\n"
"   creating a user namespace.\n"
"*/\n"
"#define _GNU_SOURCE\n"
"#include E<lt>sched.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/wait.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>limits.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""
"   新しい名前空間でシェルコマンドを実行する子プロセスを作成する。\n"
"   ユーザー名前空間を作成する際に UID と GID のマッピングを\n"
"   指定することができる。\n"
"*/\n"
"#define _GNU_SOURCE\n"
"#include E<lt>sched.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/wait.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>limits.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1091
#, no-wrap
msgid ""
"/* A simple error-handling function: print an error message based\n"
"   on the value in \\(aqerrno\\(aq and terminate the calling process */\n"
msgstr ""
"/* 簡単なエラー処理関数: \\\\(aqerrno\\\\(aq の値に基づいて\n"
"   エラーメッセージを出力し、呼び出し元プロセスを終了する。 */\n"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1094
#, no-wrap
msgid ""
"#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                        } while (0)\n"
msgstr ""
"#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                        } while (0)\n"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1099
#, no-wrap
msgid ""
"struct child_args {\n"
"    char **argv;        /* Command to be executed by child, with args */\n"
"    int    pipe_fd[2];  /* Pipe used to synchronize parent and child */\n"
"};\n"
msgstr ""
"struct child_args {\n"
"    char **argv;        /* 子プロセスが実行するコマンドと引数 */\n"
"    int    pipe_fd[2];  /* 親プロセスと子プロセスを同期するためのパイプ */\n"
"};\n"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1101
#, no-wrap
msgid "static int verbose;\n"
msgstr "static int verbose;\n"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1134
#, no-wrap
msgid ""
"static void\n"
"usage(char *pname)\n"
"{\n"
"    fprintf(stderr, \"Usage: %s [options] cmd [arg...]\\en\\en\", pname);\n"
"    fprintf(stderr, \"Create a child process that executes a shell \"\n"
"            \"command in a new user namespace,\\en\"\n"
"            \"and possibly also other new namespace(s).\\en\\en\");\n"
"    fprintf(stderr, \"Options can be:\\en\\en\");\n"
"#define fpe(str) fprintf(stderr, \"    %s\", str);\n"
"    fpe(\"-i          New IPC namespace\\en\");\n"
"    fpe(\"-m          New mount namespace\\en\");\n"
"    fpe(\"-n          New network namespace\\en\");\n"
"    fpe(\"-p          New PID namespace\\en\");\n"
"    fpe(\"-u          New UTS namespace\\en\");\n"
"    fpe(\"-U          New user namespace\\en\");\n"
"    fpe(\"-M uid_map  Specify UID map for user namespace\\en\");\n"
"    fpe(\"-G gid_map  Specify GID map for user namespace\\en\");\n"
"    fpe(\"-z          Map user\\(aqs UID and GID to 0 in user namespace\\en\");\n"
"    fpe(\"            (equivalent to: -M \\(aq0 E<lt>uidE<gt> 1\\(aq -G \\(aq0 E<lt>gidE<gt> 1\\(aq)\\en\");\n"
"    fpe(\"-v          Display verbose messages\\en\");\n"
"    fpe(\"\\en\");\n"
"    fpe(\"If -z, -M, or -G is specified, -U is required.\\en\");\n"
"    fpe(\"It is not permitted to specify both -z and either -M or -G.\\en\");\n"
"    fpe(\"\\en\");\n"
"    fpe(\"Map strings for -M and -G consist of records of the form:\\en\");\n"
"    fpe(\"\\en\");\n"
"    fpe(\"    ID-inside-ns   ID-outside-ns   len\\en\");\n"
"    fpe(\"\\en\");\n"
"    fpe(\"A map string can contain multiple records, separated\"\n"
"        \" by commas;\\en\");\n"
"    fpe(\"the commas are replaced by newlines before writing\"\n"
"        \" to map files.\\en\");\n"
msgstr ""
"static void\n"
"usage(char *pname)\n"
"{\n"
"    fprintf(stderr, \"Usage: %s [options] cmd [arg...]\\en\\en\", pname);\n"
"    fprintf(stderr, \"Create a child process that executes a shell \"\n"
"            \"command in a new user namespace,\\en\"\n"
"            \"and possibly also other new namespace(s).\\en\\en\");\n"
"    fprintf(stderr, \"Options can be:\\en\\en\");\n"
"#define fpe(str) fprintf(stderr, \"    %s\", str);\n"
"    fpe(\"-i          New IPC namespace\\en\");\n"
"    fpe(\"-m          New mount namespace\\en\");\n"
"    fpe(\"-n          New network namespace\\en\");\n"
"    fpe(\"-p          New PID namespace\\en\");\n"
"    fpe(\"-u          New UTS namespace\\en\");\n"
"    fpe(\"-U          New user namespace\\en\");\n"
"    fpe(\"-M uid_map  Specify UID map for user namespace\\en\");\n"
"    fpe(\"-G gid_map  Specify GID map for user namespace\\en\");\n"
"    fpe(\"-z          Map user\\(aqs UID and GID to 0 in user namespace\\en\");\n"
"    fpe(\"            (equivalent to: -M \\(aq0 E<lt>uidE<gt> 1\\(aq -G \\(aq0 E<lt>gidE<gt> 1\\(aq)\\en\");\n"
"    fpe(\"-v          Display verbose messages\\en\");\n"
"    fpe(\"\\en\");\n"
"    fpe(\"If -z, -M, or -G is specified, -U is required.\\en\");\n"
"    fpe(\"It is not permitted to specify both -z and either -M or -G.\\en\");\n"
"    fpe(\"\\en\");\n"
"    fpe(\"Map strings for -M and -G consist of records of the form:\\en\");\n"
"    fpe(\"\\en\");\n"
"    fpe(\"    ID-inside-ns   ID-outside-ns   len\\en\");\n"
"    fpe(\"\\en\");\n"
"    fpe(\"A map string can contain multiple records, separated\"\n"
"        \" by commas;\\en\");\n"
"    fpe(\"the commas are replaced by newlines before writing\"\n"
"        \" to map files.\\en\");\n"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1137
#, no-wrap
msgid ""
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""
"    exit(EXIT_FAILURE);\n"
"}\n"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1142
#, no-wrap
msgid ""
"/* Update the mapping file \\(aqmap_file\\(aq, with the value provided in\n"
"   \\(aqmapping\\(aq, a string that defines a UID or GID mapping. A UID or\n"
"   GID mapping consists of one or more newline-delimited records\n"
"   of the form:\n"
msgstr ""
"/* マッピングファイル \\(aqmap_file\\(aq を \\(aqmapping\\(aq で指定\n"
"   された値で更新する。 \\(aqmapping\\(aq は UID や GID マッピングを\n"
"   定義する文字列である。 UID や GID マッピングは以下の形式の改行\n"
"   で区切られた 1 つ以上のレコードである。\n"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1144
#, no-wrap
msgid "       ID_inside-ns    ID-outside-ns   length\n"
msgstr "       NS 内 ID        NS 外 ID        長さ\n"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1149
#, no-wrap
msgid ""
"   Requiring the user to supply a string that contains newlines is\n"
"   of course inconvenient for command-line use. Thus, we permit the\n"
"   use of commas to delimit records in this string, and replace them\n"
"   with newlines before writing the string to the file. */\n"
msgstr ""
"   ユーザーに改行を含む文字列を指定するのを求めるのは、\n"
"   コマンドラインを使う場合にはもちろん不便なことである。\n"
"   そのため、 この文字列でレコードを区切るのにカンマを\n"
"   使えるようにして、ファイルにこの文字列を書き込む前に\n"
"   カンマを改行に置換する。 */\n"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1155
#, no-wrap
msgid ""
"static void\n"
"update_map(char *mapping, char *map_file)\n"
"{\n"
"    int fd;\n"
"    size_t map_len;     /* Length of \\(aqmapping\\(aq */\n"
msgstr ""
"static void\n"
"update_map(char *mapping, char *map_file)\n"
"{\n"
"    int fd;\n"
"    size_t map_len;     /* \\(aqmapping\\(aq の長さ */\n"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1157
#, no-wrap
msgid "    /* Replace commas in mapping string with newlines */\n"
msgstr "    /* マッピング文字列内のカンマを改行で置換する */\n"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1162
#, no-wrap
msgid ""
"    map_len = strlen(mapping);\n"
"    for (int j = 0; j E<lt> map_len; j++)\n"
"        if (mapping[j] == \\(aq,\\(aq)\n"
"            mapping[j] = \\(aq\\en\\(aq;\n"
msgstr ""
"    map_len = strlen(mapping);\n"
"    for (int j = 0; j E<lt> map_len; j++)\n"
"        if (mapping[j] == \\(aq,\\(aq)\n"
"            mapping[j] = \\(aq\\en\\(aq;\n"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1169
#, no-wrap
msgid ""
"    fd = open(map_file, O_RDWR);\n"
"    if (fd == -1) {\n"
"        fprintf(stderr, \"ERROR: open %s: %s\\en\", map_file,\n"
"                strerror(errno));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    fd = open(map_file, O_RDWR);\n"
"    if (fd == -1) {\n"
"        fprintf(stderr, \"ERROR: open %s: %s\\en\", map_file,\n"
"                strerror(errno));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1175
#, no-wrap
msgid ""
"    if (write(fd, mapping, map_len) != map_len) {\n"
"        fprintf(stderr, \"ERROR: write %s: %s\\en\", map_file,\n"
"                strerror(errno));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (write(fd, mapping, map_len) != map_len) {\n"
"        fprintf(stderr, \"ERROR: write %s: %s\\en\", map_file,\n"
"                strerror(errno));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1178 build/C/man7/user_namespaces.7:1222
#, no-wrap
msgid ""
"    close(fd);\n"
"}\n"
msgstr ""
"    close(fd);\n"
"}\n"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1187
#, no-wrap
msgid ""
"/* Linux 3.19 made a change in the handling of setgroups(2) and the\n"
"   \\(aqgid_map\\(aq file to address a security issue. The issue allowed\n"
"   *unprivileged* users to employ user namespaces in order to drop\n"
"   The upshot of the 3.19 changes is that in order to update the\n"
"   \\(aqgid_maps\\(aq file, use of the setgroups() system call in this\n"
"   user namespace must first be disabled by writing \"deny\" to one of\n"
"   the /proc/PID/setgroups files for this namespace.  That is the\n"
"   purpose of the following function. */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1193
#, no-wrap
msgid ""
"static void\n"
"proc_setgroups_write(pid_t child_pid, char *str)\n"
"{\n"
"    char setgroups_path[PATH_MAX];\n"
"    int fd;\n"
msgstr ""
"static void\n"
"proc_setgroups_write(pid_t child_pid, char *str)\n"
"{\n"
"    char setgroups_path[PATH_MAX];\n"
"    int fd;\n"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1196
#, no-wrap
msgid ""
"    snprintf(setgroups_path, PATH_MAX, \"/proc/%jd/setgroups\",\n"
"            (intmax_t) child_pid);\n"
msgstr ""
"    snprintf(setgroups_path, PATH_MAX, \"/proc/%jd/setgroups\",\n"
"            (intmax_t) child_pid);\n"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1199
#, no-wrap
msgid ""
"    fd = open(setgroups_path, O_RDWR);\n"
"    if (fd == -1) {\n"
msgstr ""
"    fd = open(setgroups_path, O_RDWR);\n"
"    if (fd == -1) {\n"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1205
#, no-wrap
msgid ""
"        /* We may be on a system that doesn\\(aqt support\n"
"           /proc/PID/setgroups. In that case, the file won\\(aqt exist,\n"
"           and the system won\\(aqt impose the restrictions that Linux 3.19\n"
"           added. That\\(aqs fine: we don\\(aqt need to do anything in order\n"
"           to permit \\(aqgid_map\\(aq to be updated.\n"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1209
#, no-wrap
msgid ""
"           However, if the error from open() was something other than\n"
"           the ENOENT error that is expected for that case,  let the\n"
"           user know. */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/user_namespaces.7:1215
#, no-wrap
msgid ""
"        if (errno != ENOENT)\n"
"            fprintf(stderr, \"ERROR: open %s: %s\\en\", setgroups_path,\n"
"                strerror(errno));\n"
"        return;\n"
"    }\n"
msgstr ""
"        if (errno != ENOENT)\n"
"            fprintf(stderr, \"ERROR: open %s: %s\\en\", setgroups_path,\n"
"                strerror(errno));\n"
"        return;\n"
"    }\n"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1219
#, no-wrap
msgid ""
"    if (write(fd, str, strlen(str)) == -1)\n"
"        fprintf(stderr, \"ERROR: write %s: %s\\en\", setgroups_path,\n"
"            strerror(errno));\n"
msgstr ""
"    if (write(fd, str, strlen(str)) == -1)\n"
"        fprintf(stderr, \"ERROR: write %s: %s\\en\", setgroups_path,\n"
"            strerror(errno));\n"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1228
#, no-wrap
msgid ""
"static int              /* Start function for cloned child */\n"
"childFunc(void *arg)\n"
"{\n"
"    struct child_args *args = arg;\n"
"    char ch;\n"
msgstr ""
"static int              /* クローンされた子プロセスの開始関数 */\n"
"childFunc(void *arg)\n"
"{\n"
"    struct child_args *args = arg;\n"
"    char ch;\n"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1233
#, no-wrap
msgid ""
"    /* Wait until the parent has updated the UID and GID mappings.\n"
"       See the comment in main(). We wait for end of file on a\n"
"       pipe that will be closed by the parent process once it has\n"
"       updated the mappings. */\n"
msgstr ""
"    /* 親プロセスが UID と GID マッピングを更新するまで待つ。\n"
"       main() のコメントを参照。 パイプの end of file を待つ。\n"
"       親プロセスが一旦マッピングを更新すると、\n"
"       パイプはクローズされる。 */\n"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1242
#, no-wrap
msgid ""
"    close(args-E<gt>pipe_fd[1]);    /* Close our descriptor for the write\n"
"                                   end of the pipe so that we see EOF\n"
"                                   when parent closes its descriptor */\n"
"    if (read(args-E<gt>pipe_fd[0], &ch, 1) != 0) {\n"
"        fprintf(stderr,\n"
"                \"Failure in child: read from pipe returned != 0\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    close(args-E<gt>pipe_fd[1]);    /* パイプのこちら側の書き込み端のディスク\n"
"                                       リプターをクローズする。これにより\n"
"                                       親プロセスがディスクリプターをクローズ\n"
"                                       すると EOF が見えるようになる。 */\n"
"    if (read(args-E<gt>pipe_fd[0], &ch, 1) != 0) {\n"
"        fprintf(stderr,\n"
"                \"Failure in child: read from pipe returned != 0\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1244
#, no-wrap
msgid "    close(args-E<gt>pipe_fd[0]);\n"
msgstr "    close(args-E<gt>pipe_fd[0]);\n"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1246
#, no-wrap
msgid "    /* Execute a shell command */\n"
msgstr "    /* シェルコマンドを実行する */\n"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1251
#, no-wrap
msgid ""
"    printf(\"About to exec %s\\en\", args-E<gt>argv[0]);\n"
"    execvp(args-E<gt>argv[0], args-E<gt>argv);\n"
"    errExit(\"execvp\");\n"
"}\n"
msgstr ""
"    printf(\"About to exec %s\\en\", args-E<gt>argv[0]);\n"
"    execvp(args-E<gt>argv[0], args-E<gt>argv);\n"
"    errExit(\"execvp\");\n"
"}\n"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1253
#, no-wrap
msgid "#define STACK_SIZE (1024 * 1024)\n"
msgstr "#define STACK_SIZE (1024 * 1024)\n"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1255
#, no-wrap
msgid "static char child_stack[STACK_SIZE];    /* Space for child\\(aqs stack */\n"
msgstr "static char child_stack[STACK_SIZE];    /* 子プロセスのスタック空間 */\n"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1266
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int flags, opt, map_zero;\n"
"    pid_t child_pid;\n"
"    struct child_args args;\n"
"    char *uid_map, *gid_map;\n"
"    const int MAP_BUF_SIZE = 100;\n"
"    char map_buf[MAP_BUF_SIZE];\n"
"    char map_path[PATH_MAX];\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int flags, opt, map_zero;\n"
"    pid_t child_pid;\n"
"    struct child_args args;\n"
"    char *uid_map, *gid_map;\n"
"    const int MAP_BUF_SIZE = 100;\n"
"    char map_buf[MAP_BUF_SIZE];\n"
"    char map_path[PATH_MAX];\n"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1273
#, no-wrap
msgid ""
"    /* Parse command-line options. The initial \\(aq+\\(aq character in\n"
"       the final getopt() argument prevents GNU-style permutation\n"
"       of command-line options. That\\(aqs useful, since sometimes\n"
"       the \\(aqcommand\\(aq to be executed by this program itself\n"
"       has command-line options. We don\\(aqt want getopt() to treat\n"
"       those as options to this program. */\n"
msgstr ""
"    /* コマンドラインオプションを解析する。\n"
"       最後の getopt() 引数の最初の \\(aq+\\(aq 文字は\n"
"       GNU 風のコマンドラインオプションの並び換えを防止する。\n"
"       このプログラム自身が実行する「コマンド」にコマンドライン\n"
"       オプションが含まれる場合があるからである。\n"
"       getopt() にこれらをこのプログラムのオプションとして\n"
"       扱ってほしくはないのだ。 */\n"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1294
#, no-wrap
msgid ""
"    flags = 0;\n"
"    verbose = 0;\n"
"    gid_map = NULL;\n"
"    uid_map = NULL;\n"
"    map_zero = 0;\n"
"    while ((opt = getopt(argc, argv, \"+imnpuUM:G:zv\")) != -1) {\n"
"        switch (opt) {\n"
"        case \\(aqi\\(aq: flags |= CLONE_NEWIPC;        break;\n"
"        case \\(aqm\\(aq: flags |= CLONE_NEWNS;         break;\n"
"        case \\(aqn\\(aq: flags |= CLONE_NEWNET;        break;\n"
"        case \\(aqp\\(aq: flags |= CLONE_NEWPID;        break;\n"
"        case \\(aqu\\(aq: flags |= CLONE_NEWUTS;        break;\n"
"        case \\(aqv\\(aq: verbose = 1;                  break;\n"
"        case \\(aqz\\(aq: map_zero = 1;                 break;\n"
"        case \\(aqM\\(aq: uid_map = optarg;             break;\n"
"        case \\(aqG\\(aq: gid_map = optarg;             break;\n"
"        case \\(aqU\\(aq: flags |= CLONE_NEWUSER;       break;\n"
"        default:  usage(argv[0]);\n"
"        }\n"
"    }\n"
msgstr ""
"    flags = 0;\n"
"    verbose = 0;\n"
"    gid_map = NULL;\n"
"    uid_map = NULL;\n"
"    map_zero = 0;\n"
"    while ((opt = getopt(argc, argv, \"+imnpuUM:G:zv\")) != -1) {\n"
"        switch (opt) {\n"
"        case \\(aqi\\(aq: flags |= CLONE_NEWIPC;        break;\n"
"        case \\(aqm\\(aq: flags |= CLONE_NEWNS;         break;\n"
"        case \\(aqn\\(aq: flags |= CLONE_NEWNET;        break;\n"
"        case \\(aqp\\(aq: flags |= CLONE_NEWPID;        break;\n"
"        case \\(aqu\\(aq: flags |= CLONE_NEWUTS;        break;\n"
"        case \\(aqv\\(aq: verbose = 1;                  break;\n"
"        case \\(aqz\\(aq: map_zero = 1;                 break;\n"
"        case \\(aqM\\(aq: uid_map = optarg;             break;\n"
"        case \\(aqG\\(aq: gid_map = optarg;             break;\n"
"        case \\(aqU\\(aq: flags |= CLONE_NEWUSER;       break;\n"
"        default:  usage(argv[0]);\n"
"        }\n"
"    }\n"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1296
#, no-wrap
msgid "    /* -M or -G without -U is nonsensical */\n"
msgstr "    /* -U なしの -M や -G の指定は意味がない */\n"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1301
#, no-wrap
msgid ""
"    if (((uid_map != NULL || gid_map != NULL || map_zero) &&\n"
"                !(flags & CLONE_NEWUSER)) ||\n"
"            (map_zero && (uid_map != NULL || gid_map != NULL)))\n"
"        usage(argv[0]);\n"
msgstr ""
"    if (((uid_map != NULL || gid_map != NULL || map_zero) &&\n"
"                !(flags & CLONE_NEWUSER)) ||\n"
"            (map_zero && (uid_map != NULL || gid_map != NULL)))\n"
"        usage(argv[0]);\n"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1303
#, no-wrap
msgid "    args.argv = &argv[optind];\n"
msgstr "    args.argv = &argv[optind];\n"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1313
#, no-wrap
msgid ""
"    /* We use a pipe to synchronize the parent and child, in order to\n"
"       ensure that the parent sets the UID and GID maps before the child\n"
"       calls execve(). This ensures that the child maintains its\n"
"       capabilities during the execve() in the common case where we\n"
"       want to map the child\\(aqs effective user ID to 0 in the new user\n"
"       namespace. Without this synchronization, the child would lose\n"
"       its capabilities if it performed an execve() with nonzero\n"
"       user IDs (see the capabilities(7) man page for details of the\n"
"       transformation of a process\\(aqs capabilities during execve()). */\n"
msgstr ""
"    /* 親プログラムと子プロセスを同期するためにパイプを使っている。\n"
"       これは、子プロセスが execve() を呼び出す前に、親プロセスにより\n"
"       UID と GID マップが設定されることを保証するためである。\n"
"       これにより、新しいユーザー名前空間において子プロセスの実効\n"
"       ユーザー ID を 0 にマッピングしたいという通常の状況で、\n"
"       子プロセスが execve() 実行中にそのケーパビリティを維持する\n"
"       ことができる。 この同期を行わないと、 0 以外のユーザー ID で\n"
"       execve() を実行した際に、子プロセスがそのケーパビリティを失う\n"
"       ことになる (execve() 実行中のプロセスのケーパビリティの変化の\n"
"       詳細については capabilities(7) マニュアルページを参照)。 */\n"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1316
#, no-wrap
msgid ""
"    if (pipe(args.pipe_fd) == -1)\n"
"        errExit(\"pipe\");\n"
msgstr ""
"    if (pipe(args.pipe_fd) == -1)\n"
"        errExit(\"pipe\");\n"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1318
#, no-wrap
msgid "    /* Create the child in new namespace(s) */\n"
msgstr "    /* 新しい名前空間で子プロセスを作成する */\n"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1323
#, no-wrap
msgid ""
"    child_pid = clone(childFunc, child_stack + STACK_SIZE,\n"
"                      flags | SIGCHLD, &args);\n"
"    if (child_pid == -1)\n"
"        errExit(\"clone\");\n"
msgstr ""
"    child_pid = clone(childFunc, child_stack + STACK_SIZE,\n"
"                      flags | SIGCHLD, &args);\n"
"    if (child_pid == -1)\n"
"        errExit(\"clone\");\n"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1325
#, no-wrap
msgid "    /* Parent falls through to here */\n"
msgstr "    /* 親プロセスはここを実行する */\n"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1329
#, no-wrap
msgid ""
"    if (verbose)\n"
"        printf(\"%s: PID of child created by clone() is %jd\\en\",\n"
"                argv[0], (intmax_t) child_pid);\n"
msgstr ""
"    if (verbose)\n"
"        printf(\"%s: PID of child created by clone() is %jd\\en\",\n"
"                argv[0], (intmax_t) child_pid);\n"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1331
#, no-wrap
msgid "    /* Update the UID and GID maps in the child */\n"
msgstr "    /* 子プロセスの UID と GID のマッピングを更新する */\n"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1342
#, no-wrap
msgid ""
"    if (uid_map != NULL || map_zero) {\n"
"        snprintf(map_path, PATH_MAX, \"/proc/%jd/uid_map\",\n"
"                (intmax_t) child_pid);\n"
"        if (map_zero) {\n"
"            snprintf(map_buf, MAP_BUF_SIZE, \"0 %jd 1\",\n"
"                    (intmax_t) getuid());\n"
"            uid_map = map_buf;\n"
"        }\n"
"        update_map(uid_map, map_path);\n"
"    }\n"
msgstr ""
"    if (uid_map != NULL || map_zero) {\n"
"        snprintf(map_path, PATH_MAX, \"/proc/%jd/uid_map\",\n"
"                (intmax_t) child_pid);\n"
"        if (map_zero) {\n"
"            snprintf(map_buf, MAP_BUF_SIZE, \"0 %jd 1\",\n"
"                    (intmax_t) getuid());\n"
"            uid_map = map_buf;\n"
"        }\n"
"        update_map(uid_map, map_path);\n"
"    }\n"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1345
#, no-wrap
msgid ""
"    if (gid_map != NULL || map_zero) {\n"
"        proc_setgroups_write(child_pid, \"deny\");\n"
msgstr ""
"    if (gid_map != NULL || map_zero) {\n"
"        proc_setgroups_write(child_pid, \"deny\");\n"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1355
#, no-wrap
msgid ""
"        snprintf(map_path, PATH_MAX, \"/proc/%jd/gid_map\",\n"
"                (intmax_t) child_pid);\n"
"        if (map_zero) {\n"
"            snprintf(map_buf, MAP_BUF_SIZE, \"0 %ld 1\",\n"
"                    (intmax_t) getgid());\n"
"            gid_map = map_buf;\n"
"        }\n"
"        update_map(gid_map, map_path);\n"
"    }\n"
msgstr ""
"        snprintf(map_path, PATH_MAX, \"/proc/%jd/gid_map\",\n"
"                (intmax_t) child_pid);\n"
"        if (map_zero) {\n"
"            snprintf(map_buf, MAP_BUF_SIZE, \"0 %ld 1\",\n"
"                    (intmax_t) getgid());\n"
"            gid_map = map_buf;\n"
"        }\n"
"        update_map(gid_map, map_path);\n"
"    }\n"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1358
#, no-wrap
msgid ""
"    /* Close the write end of the pipe, to signal to the child that we\n"
"       have updated the UID and GID maps */\n"
msgstr ""
"    /* パイプの書き込み端をクローズし、子プロセスに UID と GID の\n"
"       マッピングが更新されたことを知らせる */\n"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1360
#, no-wrap
msgid "    close(args.pipe_fd[1]);\n"
msgstr "    close(args.pipe_fd[1]);\n"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1363
#, no-wrap
msgid ""
"    if (waitpid(child_pid, NULL, 0) == -1)      /* Wait for child */\n"
"        errExit(\"waitpid\");\n"
msgstr ""
"    if (waitpid(child_pid, NULL, 0) == -1)      /* 子プロセスを待つ */\n"
"        errExit(\"waitpid\");\n"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1366
#, no-wrap
msgid ""
"    if (verbose)\n"
"        printf(\"%s: terminating\\en\", argv[0]);\n"
msgstr ""
"    if (verbose)\n"
"        printf(\"%s: terminating\\en\", argv[0]);\n"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1369
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    exit(EXIT_SUCCESS);\n"
"}\n"

#.  From the shadow package
#.  From the shadow package
#.  From the shadow package
#.  From the shadow package
#. type: Plain text
#: build/C/man7/user_namespaces.7:1385
msgid ""
"B<newgidmap>(1), B<newuidmap>(1), B<clone>(2), B<ptrace>(2), B<setns>(2), "
"B<unshare>(2), B<proc>(5), B<subgid>(5), B<subuid>(5), B<capabilities>(7), "
"B<cgroup_namespaces>(7), B<credentials>(7), B<namespaces>(7), "
"B<pid_namespaces>(7)"
msgstr "B<newgidmap>(1), B<newuidmap>(1), B<clone>(2), B<ptrace>(2), B<setns>(2), B<unshare>(2), B<proc>(5), B<subgid>(5), B<subuid>(5), B<capabilities>(7), B<cgroup_namespaces>(7), B<credentials>(7), B<namespaces>(7), B<pid_namespaces>(7)"

#. type: Plain text
#: build/C/man7/user_namespaces.7:1388
msgid ""
"The kernel source file I<Documentation/namespaces/resource-control.txt>."
msgstr ""
"カーネルのソースファイル I<Documentation/namespaces/resource-control.txt>"

#. type: TH
#: build/C/man7/uts_namespaces.7:26
#, no-wrap
msgid "UTS_NAMESPACES"
msgstr "UTS_NAMESPACES"

#. type: TH
#: build/C/man7/uts_namespaces.7:26
#, no-wrap
msgid "2019-11-19"
msgstr "2019-11-19"

#. type: Plain text
#: build/C/man7/uts_namespaces.7:29
msgid "uts_namespaces - overview of Linux UTS namespaces"
msgstr "uts_namespaces - Linux の UTS 名前空間の概要"

#. type: Plain text
#: build/C/man7/uts_namespaces.7:44
#, fuzzy
#| msgid ""
#| "UTS namespaces provide isolation of two system identifiers: the hostname "
#| "and the NIS domain name.  These identifiers are set using "
#| "B<sethostname>(2)  and B<setdomainname>(2), and can be retrieved using "
#| "B<uname>(2), B<gethostname>(2), and B<getdomainname>(2)."
msgid ""
"UTS namespaces provide isolation of two system identifiers: the hostname and "
"the NIS domain name.  These identifiers are set using B<sethostname>(2)  and "
"B<setdomainname>(2), and can be retrieved using B<uname>(2), "
"B<gethostname>(2), and B<getdomainname>(2).  Changes made to these "
"identifiers are visible to all other processes in the same UTS namespace, "
"but are not visible to processes in other UTS namespaces."
msgstr ""
"UTS 名前空間は、 ホスト名と NIS ドメイン名の 2 つのシステム識別子を分離す"
"る。 これらの識別子は B<sethostname>(2) と B<setdomainname>(2) を使って設定で"
"き、 B<uname>(2), B<gethostname>(2), B<getdomainname>(2) を使って取得できる。"

#. type: Plain text
#: build/C/man7/uts_namespaces.7:54
msgid ""
"When a process creates a new UTS namespace using B<clone>(2)  or "
"B<unshare>(2)  with the B<CLONE_NEWUTS> flag, the hostname and domain of the "
"new UTS namespace are copied from the corresponding values in the caller's "
"UTS namespace."
msgstr ""

#. type: Plain text
#: build/C/man7/uts_namespaces.7:58
msgid ""
"Use of UTS namespaces requires a kernel that is configured with the "
"B<CONFIG_UTS_NS> option."
msgstr ""
"UTS 名前空間を使用するには、設定 B<CONFIG_UTS_NS> が有効になったカーネルが必"
"要である。"

#. type: Plain text
#: build/C/man7/uts_namespaces.7:68
msgid ""
"B<nsenter>(1), B<unshare>(1), B<clone>(2), B<getdomainname>(2), "
"B<gethostname>(2), B<setns>(2), B<uname>(2), B<unshare>(2), B<namespaces>(7)"
msgstr "B<nsenter>(1), B<unshare>(1), B<clone>(2), B<getdomainname>(2), B<gethostname>(2), B<setns>(2), B<uname>(2), B<unshare>(2), B<namespaces>(7)"

#~ msgid "Linux provides the following namespaces:"
#~ msgstr "Linux では以下の名前空間が提供される。"

#~ msgid "Constant"
#~ msgstr "定数"

#~ msgid "This file is a handle for the PID namespace of the process."
#~ msgstr "このファイルはそのプロセスの PID 名前空間の操作用である。"

#~ msgid "IPC namespaces (CLONE_NEWIPC)"
#~ msgstr "IPC 名前空間 (CLONE_NEWIPC)"

#~ msgid "Network namespaces (CLONE_NEWNET)"
#~ msgstr "ネットワーク名前空間 (CLONE_NEWNET)"

#~ msgid "Mount namespaces (CLONE_NEWNS)"
#~ msgstr "マウント名前空間 (CLONE_NEWNS)"

#~ msgid ""
#~ "Mount namespaces isolate the set of filesystem mount points, meaning that "
#~ "processes in different mount namespaces can have different views of the "
#~ "filesystem hierarchy.  The set of mounts in a mount namespace is modified "
#~ "using B<mount>(2)  and B<umount>(2)."
#~ msgstr ""
#~ "マウント名前空間はファイルシステムのマウントポイントの集合を分離する。 つ"
#~ "まり、別のマウント名前空間のプロセスには別のファイルシステム階層が見えると"
#~ "いうことである。 マウント名前空間内のマウントの集合は B<mount>(2) と "
#~ "B<umount>(2) で変更される。"

#~ msgid ""
#~ "The I</proc/[pid]/mounts> file (present since Linux 2.4.19)  lists all "
#~ "the filesystems currently mounted in the process's mount namespace.  The "
#~ "format of this file is documented in B<fstab>(5).  Since kernel version "
#~ "2.6.15, this file is pollable: after opening the file for reading, a "
#~ "change in this file (i.e., a filesystem mount or unmount) causes "
#~ "B<select>(2)  to mark the file descriptor as readable, and B<poll>(2)  "
#~ "and B<epoll_wait>(2)  mark the file as having an error condition."
#~ msgstr ""
#~ "I</proc/[pid]/mounts> ファイル (Linux 2.4.19 以降に存在) は、 そのプロセス"
#~ "のマウント名前空間で現在マウントされている全ファイルシステムの一覧を表示す"
#~ "る。 このファイルのフォーマットは B<fstab>(5) に記載されている。 カーネル"
#~ "バージョン 2.6.15 以降では、このファイルをポーリングすることができる。 す"
#~ "なわち、このファイルを読み出し用にオープンした後、 このファイルの変化 "
#~ "(ファイルシステムのマウントやアンマウント) が発生すると、 B<select>(2) は"
#~ "ファイルディスクリプターが読み出し可能になったと印を付け、 B<poll>(2) や "
#~ "B<epoll_wait>(2) はファイルがエラー状態になったかのように印を付ける。"

#~ msgid ""
#~ "The I</proc/[pid]/mountstats> file (present since Linux 2.6.17)  exports "
#~ "information (statistics, configuration information)  about the mount "
#~ "points in the process's mount namespace.  This file is readable only by "
#~ "the owner of the process.  Lines in this file have the form:"
#~ msgstr ""
#~ "I</proc/[pid]/mountstats> ファイル (Linux 2.6.17 以降に存在) は、 そのプロ"
#~ "セスのマウントポイントに関する情報 (統計情報、設定情報) を公開する。 この"
#~ "ファイルはプロセスの所有者だけが読み出し可能である。 このファイルの各行は"
#~ "以下の形式である。"

#~ msgid "The fields in each line are:"
#~ msgstr "各行のフィールドは以下のとおりである。"

#~ msgid ""
#~ "The name of the mounted device (or \"nodevice\" if there is no "
#~ "corresponding device)."
#~ msgstr ""
#~ "マウントされているデバイス名 (もしくは、対応するデバイスがない場合は "
#~ "\"nodevice\")。"

#~ msgid "The mount point within the filesystem tree."
#~ msgstr "ファイルシステムツリー内のマウントポイント。"

#~ msgid "(4)"
#~ msgstr "(4)"

#~ msgid "The filesystem type."
#~ msgstr "ファイルシステム種別"

#~ msgid ""
#~ "Optional statistics and configuration information.  Currently (as at "
#~ "Linux 2.6.26), only NFS filesystems export information via this field."
#~ msgstr ""
#~ "統計情報と設定情報。 オプションフィールドである。 現在のところ (Linux "
#~ "2.6.26 時点)、NFS ファイルシステムだけがこのフィールドで情報を公開してい"
#~ "る。"

#
#~ msgid "PID namespaces (CLONE_NEWPID)"
#~ msgstr "PID 名前空間 (CLONE_NEWPID)"

#~ msgid "User namespaces (CLONE_NEWUSER)"
#~ msgstr "ユーザー名前空間 (CLONE_NEWUSER)"

#~ msgid "UTS namespaces (CLONE_NEWUTS)"
#~ msgstr "UTS 名前空間 (CLONE_NEWUTS)"

#~ msgid "B<CLONE_NEWPID> can't be combined with some other B<CLONE_*> flags:"
#~ msgstr ""
#~ "B<CLONE_NEWPID> はいくつかの他の B<CLONE_*> フラグと組み合わせることができ"
#~ "ない。"

#~ msgid ""
#~ "B<CLONE_THREAD> requires being in the same PID namespace in order that "
#~ "the threads in a process can send signals to each other.  Similarly, it "
#~ "must be possible to see all of the threads of a processes in the "
#~ "B<proc>(5)  filesystem."
#~ msgstr ""
#~ "B<CLONE_THREAD> は、 プロセス内のスレッド間で互いにシグナルを送信できるよ"
#~ "うにするため、 同じ PID 名前空間に属している必要がある。 同様に、 プロセス"
#~ "内の全スレッドが B<proc>(5) ファイルシステムで見える必要がある。"

#~ msgid ""
#~ "B<CLONE_VM> requires all of the threads to be in the same PID namespace, "
#~ "because, from the point of view of a core dump, if two processes share "
#~ "the same address space then they are threads and will be core dumped "
#~ "together.  When a core dump is written, the PID of each thread is written "
#~ "into the core dump.  Writing the process IDs could not meaningfully "
#~ "succeed if some of the process IDs were in a parent PID namespace."
#~ msgstr ""
#~ "B<CLONE_VM> は、全スレッドが同じ PID 名前空間に属している必要がある。 なぜ"
#~ "なら、 コアダンプの観点から見ると、 2 つのプロセスが同じアドレス空間を共有"
#~ "していれば、 これらはスレッドであり、コアダンプが一緒に行われるからであ"
#~ "る。 コアダンプが書き込まれる際に、 各スレッドの PID がコアダンプに書き込"
#~ "まれる。 もしプロセス ID のいくつかが親 PID 名前空間に属していたとする"
#~ "と、 プロセス ID の書き込みは意味を持たなくなってしまう。"

#~ msgid ""
#~ "To summarize: there is a technical requirement for each of "
#~ "B<CLONE_THREAD>, B<CLONE_SIGHAND>, and B<CLONE_VM> to share a PID "
#~ "namespace.  (Note furthermore that in B<clone>(2)  requires B<CLONE_VM> "
#~ "to be specified if B<CLONE_THREAD> or B<CLONE_SIGHAND> is specified.)  "
#~ "Thus, call sequences such as the following will fail (with the error "
#~ "B<EINVAL>):"
#~ msgstr ""
#~ "まとめると、 B<CLONE_THREAD>, B<CLONE_SIGHAND>, B<CLONE_VM> では技術的な要"
#~ "件として PID 名前空間が共有されている点がある。 (さらに B<clone>(2) では "
#~ "B<CLONE_THREAD> か B<CLONE_SIGHAND> が指定された際には B<CLONE_VM> が指定"
#~ "されている必要がある点にも注意。) したがって、以下のような順序で呼び出しを"
#~ "行うと (エラー B<EINVAL> で) 失敗する。"

#~ msgid ""
#~ "A mount namespace has an owner user namespace.  A mount namespace whose "
#~ "owner user namespace is different from the owner user namespace of its "
#~ "parent mount namespace is considered a less privileged mount namespace."
#~ msgstr ""
#~ "マウント名前空間は所有者のユーザー名前空間を持つ。 所有者のユーザー名前空"
#~ "間が親のマウント名前空間の所有者のユーザー名前空間と異なるマウント名前空間"
#~ "は、 特権が少ないマウント名前空間 (less privileged mount namespace) であ"
#~ "る。"
