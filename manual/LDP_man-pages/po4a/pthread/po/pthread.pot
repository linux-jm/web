# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-03-12 14:01+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man3/getcontext.3:25
#, no-wrap
msgid "GETCONTEXT"
msgstr ""

#. type: TH
#: build/C/man3/getcontext.3:25 build/C/man3/makecontext.3:28 build/C/man3/pthread_tryjoin_np.3:26 build/C/man7/pthreads.7:25 build/C/man7/attributes.7:24
#, no-wrap
msgid "2020-12-21"
msgstr ""

#. type: TH
#: build/C/man3/getcontext.3:25 build/C/man3/pthread_attr_init.3:26 build/C/man3/pthread_attr_setaffinity_np.3:26 build/C/man3/pthread_attr_setdetachstate.3:26 build/C/man3/pthread_attr_setguardsize.3:26 build/C/man3/pthread_attr_setinheritsched.3:26 build/C/man3/pthread_attr_setschedparam.3:26 build/C/man3/pthread_attr_setschedpolicy.3:26 build/C/man3/pthread_attr_setscope.3:26 build/C/man3/pthread_attr_setstack.3:26 build/C/man3/pthread_attr_setstackaddr.3:26 build/C/man3/pthread_attr_setstacksize.3:26 build/C/man3/pthread_cancel.3:26 build/C/man3/pthread_cleanup_push.3:26 build/C/man3/pthread_cleanup_push_defer_np.3:26 build/C/man3/pthread_create.3:26 build/C/man3/pthread_detach.3:26 build/C/man3/pthread_equal.3:26 build/C/man3/pthread_exit.3:26 build/C/man3/pthread_getattr_np.3:26 build/C/man3/pthread_getcpuclockid.3:26 build/C/man3/pthread_join.3:26 build/C/man3/pthread_kill.3:26 build/C/man3/pthread_kill_other_threads_np.3:26 build/C/man3/pthread_self.3:26 build/C/man3/pthread_setaffinity_np.3:26 build/C/man3/pthread_setcancelstate.3:26 build/C/man3/pthread_setconcurrency.3:25 build/C/man3/pthread_setname_np.3:26 build/C/man3/pthread_setschedparam.3:26 build/C/man3/pthread_setschedprio.3:26 build/C/man3/pthread_sigmask.3:26 build/C/man3/pthread_sigqueue.3:25 build/C/man3/pthread_testcancel.3:26 build/C/man3/pthread_tryjoin_np.3:26 build/C/man3/pthread_yield.3:25 build/C/man3/pthread_atfork.3:25 build/C/man3/pthread_attr_setsigmask_np.3:26 build/C/man3/pthread_getattr_default_np.3:25 build/C/man3/pthread_mutex_consistent.3:26 build/C/man3/pthread_mutexattr_getpshared.3:25 build/C/man3/pthread_mutexattr_init.3:25 build/C/man3/pthread_mutexattr_setrobust.3:26 build/C/man3/pthread_spin_init.3:25 build/C/man3/pthread_spin_lock.3:25 build/C/man7/pthreads.7:25 build/C/man7/attributes.7:24 build/C/man7/nptl.7:26
#, no-wrap
msgid "Linux"
msgstr ""

#. type: TH
#: build/C/man3/getcontext.3:25 build/C/man3/makecontext.3:28 build/C/man3/pthread_attr_init.3:26 build/C/man3/pthread_attr_setaffinity_np.3:26 build/C/man3/pthread_attr_setdetachstate.3:26 build/C/man3/pthread_attr_setguardsize.3:26 build/C/man3/pthread_attr_setinheritsched.3:26 build/C/man3/pthread_attr_setschedparam.3:26 build/C/man3/pthread_attr_setschedpolicy.3:26 build/C/man3/pthread_attr_setscope.3:26 build/C/man3/pthread_attr_setstack.3:26 build/C/man3/pthread_attr_setstackaddr.3:26 build/C/man3/pthread_attr_setstacksize.3:26 build/C/man3/pthread_cancel.3:26 build/C/man3/pthread_cleanup_push.3:26 build/C/man3/pthread_cleanup_push_defer_np.3:26 build/C/man3/pthread_create.3:26 build/C/man3/pthread_detach.3:26 build/C/man3/pthread_equal.3:26 build/C/man3/pthread_exit.3:26 build/C/man3/pthread_getattr_np.3:26 build/C/man3/pthread_getcpuclockid.3:26 build/C/man3/pthread_join.3:26 build/C/man3/pthread_kill.3:26 build/C/man3/pthread_kill_other_threads_np.3:26 build/C/man3/pthread_rwlockattr_setkind_np.3:25 build/C/man3/pthread_self.3:26 build/C/man3/pthread_setaffinity_np.3:26 build/C/man3/pthread_setcancelstate.3:26 build/C/man3/pthread_setconcurrency.3:25 build/C/man3/pthread_setname_np.3:26 build/C/man3/pthread_setschedparam.3:26 build/C/man3/pthread_setschedprio.3:26 build/C/man3/pthread_sigmask.3:26 build/C/man3/pthread_sigqueue.3:25 build/C/man3/pthread_testcancel.3:26 build/C/man3/pthread_tryjoin_np.3:26 build/C/man3/pthread_yield.3:25 build/C/man3/pthread_atfork.3:25 build/C/man3/pthread_attr_setsigmask_np.3:26 build/C/man3/pthread_getattr_default_np.3:25 build/C/man3/pthread_mutex_consistent.3:26 build/C/man3/pthread_mutexattr_getpshared.3:25 build/C/man3/pthread_mutexattr_init.3:25 build/C/man3/pthread_mutexattr_setrobust.3:26 build/C/man3/pthread_spin_init.3:25 build/C/man3/pthread_spin_lock.3:25 build/C/man7/pthreads.7:25 build/C/man7/attributes.7:24 build/C/man7/nptl.7:26
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr ""

#. type: SH
#: build/C/man3/getcontext.3:26 build/C/man3/makecontext.3:29 build/C/man3/pthread_attr_init.3:27 build/C/man3/pthread_attr_setaffinity_np.3:27 build/C/man3/pthread_attr_setdetachstate.3:27 build/C/man3/pthread_attr_setguardsize.3:27 build/C/man3/pthread_attr_setinheritsched.3:27 build/C/man3/pthread_attr_setschedparam.3:27 build/C/man3/pthread_attr_setschedpolicy.3:27 build/C/man3/pthread_attr_setscope.3:27 build/C/man3/pthread_attr_setstack.3:27 build/C/man3/pthread_attr_setstackaddr.3:27 build/C/man3/pthread_attr_setstacksize.3:27 build/C/man3/pthread_cancel.3:27 build/C/man3/pthread_cleanup_push.3:27 build/C/man3/pthread_cleanup_push_defer_np.3:27 build/C/man3/pthread_create.3:27 build/C/man3/pthread_detach.3:27 build/C/man3/pthread_equal.3:27 build/C/man3/pthread_exit.3:27 build/C/man3/pthread_getattr_np.3:27 build/C/man3/pthread_getcpuclockid.3:27 build/C/man3/pthread_join.3:27 build/C/man3/pthread_kill.3:27 build/C/man3/pthread_kill_other_threads_np.3:27 build/C/man3/pthread_rwlockattr_setkind_np.3:26 build/C/man3/pthread_self.3:27 build/C/man3/pthread_setaffinity_np.3:27 build/C/man3/pthread_setcancelstate.3:27 build/C/man3/pthread_setconcurrency.3:26 build/C/man3/pthread_setname_np.3:27 build/C/man3/pthread_setschedparam.3:27 build/C/man3/pthread_setschedprio.3:27 build/C/man3/pthread_sigmask.3:27 build/C/man3/pthread_sigqueue.3:26 build/C/man3/pthread_testcancel.3:27 build/C/man3/pthread_tryjoin_np.3:27 build/C/man3/pthread_yield.3:26 build/C/man3/pthread_atfork.3:26 build/C/man3/pthread_attr_setsigmask_np.3:27 build/C/man3/pthread_getattr_default_np.3:26 build/C/man3/pthread_mutex_consistent.3:27 build/C/man3/pthread_mutexattr_getpshared.3:26 build/C/man3/pthread_mutexattr_init.3:26 build/C/man3/pthread_mutexattr_setrobust.3:27 build/C/man3/pthread_spin_init.3:26 build/C/man3/pthread_spin_lock.3:26 build/C/man7/pthreads.7:26 build/C/man7/attributes.7:25 build/C/man7/nptl.7:27
#, no-wrap
msgid "NAME"
msgstr ""

#. type: Plain text
#: build/C/man3/getcontext.3:28
msgid "getcontext, setcontext - get or set the user context"
msgstr ""

#. type: SH
#: build/C/man3/getcontext.3:28 build/C/man3/makecontext.3:31 build/C/man3/pthread_attr_init.3:30 build/C/man3/pthread_attr_setaffinity_np.3:30 build/C/man3/pthread_attr_setdetachstate.3:30 build/C/man3/pthread_attr_setguardsize.3:30 build/C/man3/pthread_attr_setinheritsched.3:30 build/C/man3/pthread_attr_setschedparam.3:30 build/C/man3/pthread_attr_setschedpolicy.3:30 build/C/man3/pthread_attr_setscope.3:30 build/C/man3/pthread_attr_setstack.3:30 build/C/man3/pthread_attr_setstackaddr.3:30 build/C/man3/pthread_attr_setstacksize.3:30 build/C/man3/pthread_cancel.3:29 build/C/man3/pthread_cleanup_push.3:30 build/C/man3/pthread_cleanup_push_defer_np.3:30 build/C/man3/pthread_create.3:29 build/C/man3/pthread_detach.3:29 build/C/man3/pthread_equal.3:29 build/C/man3/pthread_exit.3:29 build/C/man3/pthread_getattr_np.3:29 build/C/man3/pthread_getcpuclockid.3:29 build/C/man3/pthread_join.3:29 build/C/man3/pthread_kill.3:29 build/C/man3/pthread_kill_other_threads_np.3:29 build/C/man3/pthread_rwlockattr_setkind_np.3:29 build/C/man3/pthread_self.3:29 build/C/man3/pthread_setaffinity_np.3:30 build/C/man3/pthread_setcancelstate.3:30 build/C/man3/pthread_setconcurrency.3:29 build/C/man3/pthread_setname_np.3:29 build/C/man3/pthread_setschedparam.3:30 build/C/man3/pthread_setschedprio.3:29 build/C/man3/pthread_sigmask.3:29 build/C/man3/pthread_sigqueue.3:28 build/C/man3/pthread_testcancel.3:29 build/C/man3/pthread_tryjoin_np.3:30 build/C/man3/pthread_yield.3:28 build/C/man3/pthread_atfork.3:28 build/C/man3/pthread_attr_setsigmask_np.3:30 build/C/man3/pthread_getattr_default_np.3:29 build/C/man3/pthread_mutex_consistent.3:29 build/C/man3/pthread_mutexattr_getpshared.3:29 build/C/man3/pthread_mutexattr_init.3:29 build/C/man3/pthread_mutexattr_setrobust.3:30 build/C/man3/pthread_spin_init.3:28 build/C/man3/pthread_spin_lock.3:29
#, no-wrap
msgid "SYNOPSIS"
msgstr ""

#. type: Plain text
#: build/C/man3/getcontext.3:30 build/C/man3/makecontext.3:33
msgid "B<#include E<lt>ucontext.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man3/getcontext.3:32
msgid "B<int getcontext(ucontext_t *>I<ucp>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/getcontext.3:34
msgid "B<int setcontext(const ucontext_t *>I<ucp>B<);>"
msgstr ""

#. type: SH
#: build/C/man3/getcontext.3:34 build/C/man3/makecontext.3:38 build/C/man3/pthread_attr_init.3:39 build/C/man3/pthread_attr_setaffinity_np.3:42 build/C/man3/pthread_attr_setdetachstate.3:41 build/C/man3/pthread_attr_setguardsize.3:41 build/C/man3/pthread_attr_setinheritsched.3:41 build/C/man3/pthread_attr_setschedparam.3:41 build/C/man3/pthread_attr_setschedpolicy.3:41 build/C/man3/pthread_attr_setscope.3:41 build/C/man3/pthread_attr_setstack.3:54 build/C/man3/pthread_attr_setstackaddr.3:41 build/C/man3/pthread_attr_setstacksize.3:41 build/C/man3/pthread_cancel.3:37 build/C/man3/pthread_cleanup_push.3:40 build/C/man3/pthread_cleanup_push_defer_np.3:53 build/C/man3/pthread_create.3:38 build/C/man3/pthread_detach.3:37 build/C/man3/pthread_equal.3:37 build/C/man3/pthread_exit.3:37 build/C/man3/pthread_getattr_np.3:38 build/C/man3/pthread_getcpuclockid.3:38 build/C/man3/pthread_join.3:37 build/C/man3/pthread_kill.3:49 build/C/man3/pthread_kill_other_threads_np.3:35 build/C/man3/pthread_rwlockattr_setkind_np.3:54 build/C/man3/pthread_self.3:37 build/C/man3/pthread_setaffinity_np.3:42 build/C/man3/pthread_setcancelstate.3:39 build/C/man3/pthread_setconcurrency.3:38 build/C/man3/pthread_setname_np.3:39 build/C/man3/pthread_setschedparam.3:41 build/C/man3/pthread_setschedprio.3:37 build/C/man3/pthread_sigmask.3:50 build/C/man3/pthread_sigqueue.3:46 build/C/man3/pthread_testcancel.3:37 build/C/man3/pthread_tryjoin_np.3:42 build/C/man3/pthread_yield.3:37 build/C/man3/pthread_atfork.3:37 build/C/man3/pthread_attr_setsigmask_np.3:42 build/C/man3/pthread_getattr_default_np.3:39 build/C/man3/pthread_mutex_consistent.3:50 build/C/man3/pthread_mutexattr_getpshared.3:40 build/C/man3/pthread_mutexattr_init.3:38 build/C/man3/pthread_mutexattr_setrobust.3:57 build/C/man3/pthread_spin_init.3:51 build/C/man3/pthread_spin_lock.3:53 build/C/man7/pthreads.7:28 build/C/man7/attributes.7:27 build/C/man7/nptl.7:29
#, no-wrap
msgid "DESCRIPTION"
msgstr ""

#. type: Plain text
#: build/C/man3/getcontext.3:49
msgid ""
"In a System V-like environment, one has the two types I<mcontext_t> and "
"I<ucontext_t> defined in I<E<lt>ucontext.hE<gt>> and the four functions "
"B<getcontext>(), B<setcontext>(), B<makecontext>(3), and B<swapcontext>(3)  "
"that allow user-level context switching between multiple threads of control "
"within a process."
msgstr ""

#. type: Plain text
#: build/C/man3/getcontext.3:57
msgid ""
"The I<mcontext_t> type is machine-dependent and opaque.  The I<ucontext_t> "
"type is a structure that has at least the following fields:"
msgstr ""

#. type: Plain text
#: build/C/man3/getcontext.3:67
#, no-wrap
msgid ""
"typedef struct ucontext_t {\n"
"    struct ucontext_t *uc_link;\n"
"    sigset_t          uc_sigmask;\n"
"    stack_t           uc_stack;\n"
"    mcontext_t        uc_mcontext;\n"
"    ...\n"
"} ucontext_t;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getcontext.3:94
msgid ""
"with I<sigset_t> and I<stack_t> defined in I<E<lt>signal.hE<gt>>.  Here "
"I<uc_link> points to the context that will be resumed when the current "
"context terminates (in case the current context was created using "
"B<makecontext>(3)), I<uc_sigmask> is the set of signals blocked in this "
"context (see B<sigprocmask>(2)), I<uc_stack> is the stack used by this "
"context (see B<sigaltstack>(2)), and I<uc_mcontext> is the machine-specific "
"representation of the saved context, that includes the calling thread's "
"machine registers."
msgstr ""

#. type: Plain text
#: build/C/man3/getcontext.3:101
msgid ""
"The function B<getcontext>()  initializes the structure pointed to by I<ucp> "
"to the currently active context."
msgstr ""

#. type: Plain text
#: build/C/man3/getcontext.3:117
msgid ""
"The function B<setcontext>()  restores the user context pointed to by "
"I<ucp>.  A successful call does not return.  The context should have been "
"obtained by a call of B<getcontext>(), or B<makecontext>(3), or received as "
"the third argument to a signal handler (see the discussion of the "
"B<SA_SIGINFO> flag in B<sigaction>(2))."
msgstr ""

#. type: Plain text
#: build/C/man3/getcontext.3:121
msgid ""
"If the context was obtained by a call of B<getcontext>(), program execution "
"continues as if this call just returned."
msgstr ""

#. type: Plain text
#: build/C/man3/getcontext.3:138
msgid ""
"If the context was obtained by a call of B<makecontext>(3), program "
"execution continues by a call to the function I<func> specified as the "
"second argument of that call to B<makecontext>(3).  When the function "
"I<func> returns, we continue with the I<uc_link> member of the structure "
"I<ucp> specified as the first argument of that call to B<makecontext>(3).  "
"When this member is NULL, the thread exits."
msgstr ""

#. type: Plain text
#: build/C/man3/getcontext.3:145
msgid ""
"If the context was obtained by a call to a signal handler, then old standard "
"text says that \"program execution continues with the program instruction "
"following the instruction interrupted by the signal\".  However, this "
"sentence was removed in SUSv2, and the present verdict is \"the result is "
"unspecified\"."
msgstr ""

#. type: SH
#: build/C/man3/getcontext.3:145 build/C/man3/makecontext.3:85 build/C/man3/pthread_attr_init.3:68 build/C/man3/pthread_attr_setaffinity_np.3:76 build/C/man3/pthread_attr_setdetachstate.3:77 build/C/man3/pthread_attr_setguardsize.3:90 build/C/man3/pthread_attr_setinheritsched.3:93 build/C/man3/pthread_attr_setschedparam.3:85 build/C/man3/pthread_attr_setschedpolicy.3:83 build/C/man3/pthread_attr_setscope.3:103 build/C/man3/pthread_attr_setstack.3:85 build/C/man3/pthread_attr_setstackaddr.3:74 build/C/man3/pthread_attr_setstacksize.3:61 build/C/man3/pthread_cancel.3:112 build/C/man3/pthread_cleanup_push.3:121 build/C/man3/pthread_create.3:115 build/C/man3/pthread_detach.3:49 build/C/man3/pthread_equal.3:41 build/C/man3/pthread_exit.3:71 build/C/man3/pthread_getattr_np.3:73 build/C/man3/pthread_getcpuclockid.3:49 build/C/man3/pthread_join.3:70 build/C/man3/pthread_kill.3:63 build/C/man3/pthread_rwlockattr_setkind_np.3:121 build/C/man3/pthread_self.3:46 build/C/man3/pthread_setaffinity_np.3:77 build/C/man3/pthread_setcancelstate.3:97 build/C/man3/pthread_setconcurrency.3:56 build/C/man3/pthread_setname_np.3:72 build/C/man3/pthread_setschedparam.3:104 build/C/man3/pthread_setschedprio.3:53 build/C/man3/pthread_sigmask.3:61 build/C/man3/pthread_sigqueue.3:66 build/C/man3/pthread_testcancel.3:50 build/C/man3/pthread_tryjoin_np.3:88 build/C/man3/pthread_yield.3:44 build/C/man3/pthread_atfork.3:67 build/C/man3/pthread_attr_setsigmask_np.3:67 build/C/man3/pthread_mutex_consistent.3:59 build/C/man3/pthread_mutexattr_getpshared.3:76 build/C/man3/pthread_mutexattr_init.3:56 build/C/man3/pthread_mutexattr_setrobust.3:129 build/C/man3/pthread_spin_init.3:111 build/C/man3/pthread_spin_lock.3:91
#, no-wrap
msgid "RETURN VALUE"
msgstr ""

#. type: Plain text
#: build/C/man3/getcontext.3:154
msgid ""
"When successful, B<getcontext>()  returns 0 and B<setcontext>()  does not "
"return.  On error, both return -1 and set I<errno> appropriately."
msgstr ""

#. type: SH
#: build/C/man3/getcontext.3:154 build/C/man3/makecontext.3:97 build/C/man3/pthread_attr_init.3:71 build/C/man3/pthread_attr_setaffinity_np.3:79 build/C/man3/pthread_attr_setdetachstate.3:80 build/C/man3/pthread_attr_setguardsize.3:93 build/C/man3/pthread_attr_setinheritsched.3:96 build/C/man3/pthread_attr_setschedparam.3:88 build/C/man3/pthread_attr_setschedpolicy.3:86 build/C/man3/pthread_attr_setscope.3:106 build/C/man3/pthread_attr_setstack.3:88 build/C/man3/pthread_attr_setstackaddr.3:77 build/C/man3/pthread_attr_setstacksize.3:64 build/C/man3/pthread_cancel.3:117 build/C/man3/pthread_cleanup_push.3:123 build/C/man3/pthread_create.3:122 build/C/man3/pthread_detach.3:54 build/C/man3/pthread_equal.3:45 build/C/man3/pthread_exit.3:73 build/C/man3/pthread_getattr_np.3:76 build/C/man3/pthread_getcpuclockid.3:52 build/C/man3/pthread_join.3:75 build/C/man3/pthread_kill.3:68 build/C/man3/pthread_rwlockattr_setkind_np.3:129 build/C/man3/pthread_self.3:48 build/C/man3/pthread_setaffinity_np.3:80 build/C/man3/pthread_setcancelstate.3:100 build/C/man3/pthread_setconcurrency.3:68 build/C/man3/pthread_setname_np.3:75 build/C/man3/pthread_setschedparam.3:112 build/C/man3/pthread_setschedprio.3:61 build/C/man3/pthread_sigmask.3:66 build/C/man3/pthread_sigqueue.3:71 build/C/man3/pthread_testcancel.3:54 build/C/man3/pthread_tryjoin_np.3:92 build/C/man3/pthread_yield.3:49 build/C/man3/pthread_atfork.3:82 build/C/man3/pthread_attr_setsigmask_np.3:84 build/C/man3/pthread_getattr_default_np.3:66 build/C/man3/pthread_mutex_consistent.3:65 build/C/man3/pthread_mutexattr_getpshared.3:79 build/C/man3/pthread_mutexattr_setrobust.3:136 build/C/man3/pthread_spin_init.3:117 build/C/man3/pthread_spin_lock.3:94
#, no-wrap
msgid "ERRORS"
msgstr ""

#. type: Plain text
#: build/C/man3/getcontext.3:156
msgid "None defined."
msgstr ""

#. type: TH
#: build/C/man3/getcontext.3:156 build/C/man3/makecontext.3:106 build/C/man3/pthread_attr_init.3:79 build/C/man3/pthread_attr_setaffinity_np.3:108 build/C/man3/pthread_attr_setdetachstate.3:87 build/C/man3/pthread_attr_setguardsize.3:106 build/C/man3/pthread_attr_setinheritsched.3:110 build/C/man3/pthread_attr_setschedparam.3:107 build/C/man3/pthread_attr_setschedpolicy.3:100 build/C/man3/pthread_attr_setscope.3:119 build/C/man3/pthread_attr_setstack.3:112 build/C/man3/pthread_attr_setstackaddr.3:83 build/C/man3/pthread_attr_setstacksize.3:83 build/C/man3/pthread_cancel.3:125 build/C/man3/pthread_cleanup_push.3:127 build/C/man3/pthread_create.3:153 build/C/man3/pthread_detach.3:64 build/C/man3/pthread_equal.3:47 build/C/man3/pthread_exit.3:75 build/C/man3/pthread_getattr_np.3:98 build/C/man3/pthread_getcpuclockid.3:68 build/C/man3/pthread_join.3:98 build/C/man3/pthread_kill.3:72 build/C/man3/pthread_kill_other_threads_np.3:47 build/C/man3/pthread_self.3:50 build/C/man3/pthread_setaffinity_np.3:117 build/C/man3/pthread_setcancelstate.3:118 build/C/man3/pthread_setconcurrency.3:83 build/C/man3/pthread_setname_np.3:102 build/C/man3/pthread_setschedparam.3:141 build/C/man3/pthread_setschedprio.3:83 build/C/man3/pthread_sigmask.3:69 build/C/man3/pthread_sigqueue.3:94 build/C/man3/pthread_testcancel.3:58 build/C/man3/pthread_tryjoin_np.3:123 build/C/man3/pthread_yield.3:53 build/C/man3/pthread_attr_setsigmask_np.3:91 build/C/man3/pthread_getattr_default_np.3:81 build/C/man7/attributes.7:24
#, no-wrap
msgid "ATTRIBUTES"
msgstr ""

#. type: Plain text
#: build/C/man3/getcontext.3:159 build/C/man3/makecontext.3:109 build/C/man3/pthread_attr_init.3:82 build/C/man3/pthread_attr_setaffinity_np.3:111 build/C/man3/pthread_attr_setdetachstate.3:90 build/C/man3/pthread_attr_setguardsize.3:109 build/C/man3/pthread_attr_setinheritsched.3:113 build/C/man3/pthread_attr_setschedparam.3:110 build/C/man3/pthread_attr_setschedpolicy.3:103 build/C/man3/pthread_attr_setscope.3:122 build/C/man3/pthread_attr_setstack.3:115 build/C/man3/pthread_attr_setstackaddr.3:86 build/C/man3/pthread_attr_setstacksize.3:86 build/C/man3/pthread_cancel.3:128 build/C/man3/pthread_cleanup_push.3:130 build/C/man3/pthread_create.3:156 build/C/man3/pthread_detach.3:67 build/C/man3/pthread_equal.3:50 build/C/man3/pthread_exit.3:78 build/C/man3/pthread_getattr_np.3:101 build/C/man3/pthread_getcpuclockid.3:71 build/C/man3/pthread_join.3:101 build/C/man3/pthread_kill.3:75 build/C/man3/pthread_kill_other_threads_np.3:50 build/C/man3/pthread_self.3:53 build/C/man3/pthread_setaffinity_np.3:120 build/C/man3/pthread_setcancelstate.3:121 build/C/man3/pthread_setconcurrency.3:86 build/C/man3/pthread_setname_np.3:105 build/C/man3/pthread_setschedparam.3:144 build/C/man3/pthread_setschedprio.3:86 build/C/man3/pthread_sigmask.3:72 build/C/man3/pthread_sigqueue.3:97 build/C/man3/pthread_testcancel.3:61 build/C/man3/pthread_tryjoin_np.3:126 build/C/man3/pthread_yield.3:56 build/C/man3/pthread_attr_setsigmask_np.3:94 build/C/man3/pthread_getattr_default_np.3:84
msgid "For an explanation of the terms used in this section, see B<attributes>(7)."
msgstr ""

#. type: tbl table
#: build/C/man3/getcontext.3:163 build/C/man3/makecontext.3:113 build/C/man3/pthread_attr_init.3:87 build/C/man3/pthread_attr_setaffinity_np.3:115 build/C/man3/pthread_attr_setdetachstate.3:94 build/C/man3/pthread_attr_setguardsize.3:113 build/C/man3/pthread_attr_setinheritsched.3:117 build/C/man3/pthread_attr_setschedparam.3:114 build/C/man3/pthread_attr_setschedpolicy.3:107 build/C/man3/pthread_attr_setscope.3:126 build/C/man3/pthread_attr_setstack.3:119 build/C/man3/pthread_attr_setstackaddr.3:90 build/C/man3/pthread_attr_setstacksize.3:90 build/C/man3/pthread_cancel.3:132 build/C/man3/pthread_cleanup_push.3:134 build/C/man3/pthread_create.3:160 build/C/man3/pthread_detach.3:71 build/C/man3/pthread_equal.3:54 build/C/man3/pthread_exit.3:82 build/C/man3/pthread_getattr_np.3:106 build/C/man3/pthread_getcpuclockid.3:75 build/C/man3/pthread_join.3:105 build/C/man3/pthread_kill.3:79 build/C/man3/pthread_kill_other_threads_np.3:54 build/C/man3/pthread_self.3:57 build/C/man3/pthread_setaffinity_np.3:124 build/C/man3/pthread_setcancelstate.3:126 build/C/man3/pthread_setconcurrency.3:90 build/C/man3/pthread_setname_np.3:109 build/C/man3/pthread_setschedparam.3:148 build/C/man3/pthread_setschedprio.3:90 build/C/man3/pthread_sigmask.3:76 build/C/man3/pthread_sigqueue.3:101 build/C/man3/pthread_testcancel.3:65 build/C/man3/pthread_tryjoin_np.3:131 build/C/man3/pthread_yield.3:60 build/C/man3/pthread_attr_setsigmask_np.3:98 build/C/man3/pthread_getattr_default_np.3:89
#, no-wrap
msgid "Interface"
msgstr ""

#. type: tbl table
#: build/C/man3/getcontext.3:163 build/C/man3/makecontext.3:113 build/C/man3/pthread_attr_init.3:87 build/C/man3/pthread_attr_setaffinity_np.3:115 build/C/man3/pthread_attr_setdetachstate.3:94 build/C/man3/pthread_attr_setguardsize.3:113 build/C/man3/pthread_attr_setinheritsched.3:117 build/C/man3/pthread_attr_setschedparam.3:114 build/C/man3/pthread_attr_setschedpolicy.3:107 build/C/man3/pthread_attr_setscope.3:126 build/C/man3/pthread_attr_setstack.3:119 build/C/man3/pthread_attr_setstackaddr.3:90 build/C/man3/pthread_attr_setstacksize.3:90 build/C/man3/pthread_cancel.3:132 build/C/man3/pthread_cleanup_push.3:134 build/C/man3/pthread_create.3:160 build/C/man3/pthread_detach.3:71 build/C/man3/pthread_equal.3:54 build/C/man3/pthread_exit.3:82 build/C/man3/pthread_getattr_np.3:106 build/C/man3/pthread_getcpuclockid.3:75 build/C/man3/pthread_join.3:105 build/C/man3/pthread_kill.3:79 build/C/man3/pthread_kill_other_threads_np.3:54 build/C/man3/pthread_self.3:57 build/C/man3/pthread_setaffinity_np.3:124 build/C/man3/pthread_setcancelstate.3:126 build/C/man3/pthread_setconcurrency.3:90 build/C/man3/pthread_setname_np.3:109 build/C/man3/pthread_setschedparam.3:148 build/C/man3/pthread_setschedprio.3:90 build/C/man3/pthread_sigmask.3:76 build/C/man3/pthread_sigqueue.3:101 build/C/man3/pthread_testcancel.3:65 build/C/man3/pthread_tryjoin_np.3:131 build/C/man3/pthread_yield.3:60 build/C/man3/pthread_attr_setsigmask_np.3:98 build/C/man3/pthread_getattr_default_np.3:89
#, no-wrap
msgid "Attribute"
msgstr ""

#. type: tbl table
#: build/C/man3/getcontext.3:163 build/C/man3/makecontext.3:113 build/C/man3/pthread_attr_init.3:87 build/C/man3/pthread_attr_setaffinity_np.3:115 build/C/man3/pthread_attr_setdetachstate.3:94 build/C/man3/pthread_attr_setguardsize.3:113 build/C/man3/pthread_attr_setinheritsched.3:117 build/C/man3/pthread_attr_setschedparam.3:114 build/C/man3/pthread_attr_setschedpolicy.3:107 build/C/man3/pthread_attr_setscope.3:126 build/C/man3/pthread_attr_setstack.3:119 build/C/man3/pthread_attr_setstackaddr.3:90 build/C/man3/pthread_attr_setstacksize.3:90 build/C/man3/pthread_cancel.3:132 build/C/man3/pthread_cleanup_push.3:134 build/C/man3/pthread_create.3:160 build/C/man3/pthread_detach.3:71 build/C/man3/pthread_equal.3:54 build/C/man3/pthread_exit.3:82 build/C/man3/pthread_getattr_np.3:106 build/C/man3/pthread_getcpuclockid.3:75 build/C/man3/pthread_join.3:105 build/C/man3/pthread_kill.3:79 build/C/man3/pthread_kill_other_threads_np.3:54 build/C/man3/pthread_self.3:57 build/C/man3/pthread_setaffinity_np.3:124 build/C/man3/pthread_setcancelstate.3:126 build/C/man3/pthread_setconcurrency.3:90 build/C/man3/pthread_setname_np.3:109 build/C/man3/pthread_setschedparam.3:148 build/C/man3/pthread_setschedprio.3:90 build/C/man3/pthread_sigmask.3:76 build/C/man3/pthread_sigqueue.3:101 build/C/man3/pthread_testcancel.3:65 build/C/man3/pthread_tryjoin_np.3:131 build/C/man3/pthread_yield.3:60 build/C/man3/pthread_attr_setsigmask_np.3:98 build/C/man3/pthread_getattr_default_np.3:89
#, no-wrap
msgid "Value"
msgstr ""

#. type: tbl table
#: build/C/man3/getcontext.3:167
#, no-wrap
msgid ""
"B<getcontext>(),\n"
"B<setcontext>()"
msgstr ""

#. type: tbl table
#: build/C/man3/getcontext.3:167 build/C/man3/makecontext.3:116 build/C/man3/makecontext.3:119 build/C/man3/pthread_attr_init.3:91 build/C/man3/pthread_attr_setaffinity_np.3:119 build/C/man3/pthread_attr_setdetachstate.3:98 build/C/man3/pthread_attr_setguardsize.3:117 build/C/man3/pthread_attr_setinheritsched.3:121 build/C/man3/pthread_attr_setschedparam.3:118 build/C/man3/pthread_attr_setschedpolicy.3:111 build/C/man3/pthread_attr_setscope.3:130 build/C/man3/pthread_attr_setstack.3:123 build/C/man3/pthread_attr_setstackaddr.3:94 build/C/man3/pthread_attr_setstacksize.3:94 build/C/man3/pthread_cancel.3:135 build/C/man3/pthread_cleanup_push.3:138 build/C/man3/pthread_create.3:163 build/C/man3/pthread_detach.3:74 build/C/man3/pthread_equal.3:57 build/C/man3/pthread_exit.3:85 build/C/man3/pthread_getattr_np.3:109 build/C/man3/pthread_getcpuclockid.3:78 build/C/man3/pthread_join.3:108 build/C/man3/pthread_kill.3:82 build/C/man3/pthread_kill_other_threads_np.3:57 build/C/man3/pthread_self.3:60 build/C/man3/pthread_setaffinity_np.3:128 build/C/man3/pthread_setcancelstate.3:130 build/C/man3/pthread_setconcurrency.3:94 build/C/man3/pthread_setname_np.3:113 build/C/man3/pthread_setschedparam.3:152 build/C/man3/pthread_setschedprio.3:93 build/C/man3/pthread_sigmask.3:79 build/C/man3/pthread_sigqueue.3:104 build/C/man3/pthread_testcancel.3:68 build/C/man3/pthread_tryjoin_np.3:135 build/C/man3/pthread_yield.3:63 build/C/man3/pthread_attr_setsigmask_np.3:102 build/C/man3/pthread_getattr_default_np.3:93
#, no-wrap
msgid "Thread safety"
msgstr ""

#. type: tbl table
#: build/C/man3/getcontext.3:167 build/C/man3/makecontext.3:116
#, no-wrap
msgid "MT-Safe race:ucp"
msgstr ""

#. type: SH
#: build/C/man3/getcontext.3:169 build/C/man3/makecontext.3:121 build/C/man3/pthread_attr_init.3:94 build/C/man3/pthread_attr_setaffinity_np.3:122 build/C/man3/pthread_attr_setdetachstate.3:100 build/C/man3/pthread_attr_setguardsize.3:119 build/C/man3/pthread_attr_setinheritsched.3:123 build/C/man3/pthread_attr_setschedparam.3:120 build/C/man3/pthread_attr_setschedpolicy.3:113 build/C/man3/pthread_attr_setscope.3:132 build/C/man3/pthread_attr_setstack.3:125 build/C/man3/pthread_attr_setstackaddr.3:96 build/C/man3/pthread_attr_setstacksize.3:96 build/C/man3/pthread_cancel.3:138 build/C/man3/pthread_cleanup_push.3:141 build/C/man3/pthread_cleanup_push_defer_np.3:114 build/C/man3/pthread_create.3:166 build/C/man3/pthread_detach.3:77 build/C/man3/pthread_equal.3:59 build/C/man3/pthread_exit.3:87 build/C/man3/pthread_getattr_np.3:112 build/C/man3/pthread_getcpuclockid.3:80 build/C/man3/pthread_join.3:111 build/C/man3/pthread_kill.3:84 build/C/man3/pthread_kill_other_threads_np.3:59 build/C/man3/pthread_rwlockattr_setkind_np.3:140 build/C/man3/pthread_self.3:62 build/C/man3/pthread_setaffinity_np.3:130 build/C/man3/pthread_setcancelstate.3:142 build/C/man3/pthread_setconcurrency.3:96 build/C/man3/pthread_setname_np.3:116 build/C/man3/pthread_setschedparam.3:154 build/C/man3/pthread_setschedprio.3:95 build/C/man3/pthread_sigmask.3:81 build/C/man3/pthread_sigqueue.3:106 build/C/man3/pthread_testcancel.3:70 build/C/man3/pthread_tryjoin_np.3:138 build/C/man3/pthread_yield.3:65 build/C/man3/pthread_atfork.3:86 build/C/man3/pthread_attr_setsigmask_np.3:105 build/C/man3/pthread_getattr_default_np.3:96 build/C/man3/pthread_mutex_consistent.3:72 build/C/man3/pthread_mutexattr_getpshared.3:92 build/C/man3/pthread_mutexattr_init.3:59 build/C/man3/pthread_mutexattr_setrobust.3:150 build/C/man3/pthread_spin_init.3:130 build/C/man3/pthread_spin_lock.3:109 build/C/man7/nptl.7:114
#, no-wrap
msgid "CONFORMING TO"
msgstr ""

#. type: Plain text
#: build/C/man3/getcontext.3:175
msgid ""
"SUSv2, POSIX.1-2001.  POSIX.1-2008 removes the specification of "
"B<getcontext>(), citing portability issues, and recommending that "
"applications be rewritten to use POSIX threads instead."
msgstr ""

#. type: SH
#: build/C/man3/getcontext.3:175 build/C/man3/makecontext.3:129 build/C/man3/pthread_attr_init.3:96 build/C/man3/pthread_attr_setaffinity_np.3:125 build/C/man3/pthread_attr_setdetachstate.3:102 build/C/man3/pthread_attr_setguardsize.3:121 build/C/man3/pthread_attr_setschedparam.3:122 build/C/man3/pthread_attr_setscope.3:134 build/C/man3/pthread_attr_setstack.3:127 build/C/man3/pthread_attr_setstackaddr.3:99 build/C/man3/pthread_attr_setstacksize.3:98 build/C/man3/pthread_cancel.3:140 build/C/man3/pthread_cleanup_push.3:143 build/C/man3/pthread_create.3:168 build/C/man3/pthread_detach.3:79 build/C/man3/pthread_equal.3:61 build/C/man3/pthread_exit.3:89 build/C/man3/pthread_getcpuclockid.3:82 build/C/man3/pthread_join.3:113 build/C/man3/pthread_kill.3:86 build/C/man3/pthread_kill_other_threads_np.3:62 build/C/man3/pthread_self.3:64 build/C/man3/pthread_setaffinity_np.3:133 build/C/man3/pthread_setcancelstate.3:144 build/C/man3/pthread_setconcurrency.3:98 build/C/man3/pthread_setname_np.3:119 build/C/man3/pthread_setschedparam.3:156 build/C/man3/pthread_setschedprio.3:97 build/C/man3/pthread_sigmask.3:83 build/C/man3/pthread_sigqueue.3:108 build/C/man3/pthread_yield.3:71 build/C/man3/pthread_atfork.3:88 build/C/man3/pthread_attr_setsigmask_np.3:108 build/C/man3/pthread_mutex_consistent.3:74 build/C/man3/pthread_mutexattr_init.3:61 build/C/man3/pthread_mutexattr_setrobust.3:152 build/C/man3/pthread_spin_init.3:135 build/C/man3/pthread_spin_lock.3:111 build/C/man7/nptl.7:117
#, no-wrap
msgid "NOTES"
msgstr ""

#. type: Plain text
#: build/C/man3/getcontext.3:192
msgid ""
"The earliest incarnation of this mechanism was the "
"B<setjmp>(3)/B<longjmp>(3)  mechanism.  Since that does not define the "
"handling of the signal context, the next stage was the "
"B<sigsetjmp>(3)/B<siglongjmp>(3)  pair.  The present mechanism gives much "
"more control.  On the other hand, there is no easy way to detect whether a "
"return from B<getcontext>()  is from the first call, or via a "
"B<setcontext>()  call.  The user has to invent their own bookkeeping device, "
"and a register variable won't do since registers are restored."
msgstr ""

#. type: Plain text
#: build/C/man3/getcontext.3:203
msgid ""
"When a signal occurs, the current user context is saved and a new context is "
"created by the kernel for the signal handler.  Do not leave the handler "
"using B<longjmp>(3): it is undefined what would happen with contexts.  Use "
"B<siglongjmp>(3)  or B<setcontext>()  instead."
msgstr ""

#. type: SH
#: build/C/man3/getcontext.3:203 build/C/man3/makecontext.3:235 build/C/man3/pthread_attr_init.3:312 build/C/man3/pthread_attr_setaffinity_np.3:132 build/C/man3/pthread_attr_setdetachstate.3:124 build/C/man3/pthread_attr_setguardsize.3:171 build/C/man3/pthread_attr_setinheritsched.3:144 build/C/man3/pthread_attr_setschedparam.3:129 build/C/man3/pthread_attr_setschedpolicy.3:118 build/C/man3/pthread_attr_setscope.3:145 build/C/man3/pthread_attr_setstack.3:168 build/C/man3/pthread_attr_setstackaddr.3:123 build/C/man3/pthread_attr_setstacksize.3:124 build/C/man3/pthread_cancel.3:239 build/C/man3/pthread_cleanup_push.3:329 build/C/man3/pthread_cleanup_push_defer_np.3:117 build/C/man3/pthread_create.3:405 build/C/man3/pthread_detach.3:110 build/C/man3/pthread_equal.3:68 build/C/man3/pthread_exit.3:117 build/C/man3/pthread_getattr_np.3:359 build/C/man3/pthread_getcpuclockid.3:186 build/C/man3/pthread_join.3:143 build/C/man3/pthread_kill.3:116 build/C/man3/pthread_kill_other_threads_np.3:78 build/C/man3/pthread_rwlockattr_setkind_np.3:143 build/C/man3/pthread_self.3:88 build/C/man3/pthread_setaffinity_np.3:215 build/C/man3/pthread_setcancelstate.3:208 build/C/man3/pthread_setconcurrency.3:113 build/C/man3/pthread_setname_np.3:214 build/C/man3/pthread_setschedparam.3:446 build/C/man3/pthread_setschedprio.3:103 build/C/man3/pthread_sigmask.3:167 build/C/man3/pthread_sigqueue.3:118 build/C/man3/pthread_testcancel.3:75 build/C/man3/pthread_tryjoin_np.3:175 build/C/man3/pthread_yield.3:85 build/C/man3/pthread_atfork.3:122 build/C/man3/pthread_attr_setsigmask_np.3:142 build/C/man3/pthread_getattr_default_np.3:196 build/C/man3/pthread_mutex_consistent.3:99 build/C/man3/pthread_mutexattr_getpshared.3:94 build/C/man3/pthread_mutexattr_init.3:64 build/C/man3/pthread_mutexattr_setrobust.3:276 build/C/man3/pthread_spin_init.3:162 build/C/man3/pthread_spin_lock.3:117 build/C/man7/pthreads.7:916 build/C/man7/attributes.7:882 build/C/man7/nptl.7:128
#, no-wrap
msgid "SEE ALSO"
msgstr ""

#. type: Plain text
#: build/C/man3/getcontext.3:211
msgid ""
"B<sigaction>(2), B<sigaltstack>(2), B<sigprocmask>(2), B<longjmp>(3), "
"B<makecontext>(3), B<sigsetjmp>(3), B<signal>(7)"
msgstr ""

#. type: SH
#: build/C/man3/getcontext.3:211 build/C/man3/makecontext.3:241 build/C/man3/pthread_attr_init.3:330 build/C/man3/pthread_attr_setaffinity_np.3:138 build/C/man3/pthread_attr_setdetachstate.3:130 build/C/man3/pthread_attr_setguardsize.3:179 build/C/man3/pthread_attr_setinheritsched.3:156 build/C/man3/pthread_attr_setschedparam.3:141 build/C/man3/pthread_attr_setschedpolicy.3:129 build/C/man3/pthread_attr_setscope.3:155 build/C/man3/pthread_attr_setstack.3:180 build/C/man3/pthread_attr_setstackaddr.3:129 build/C/man3/pthread_attr_setstacksize.3:131 build/C/man3/pthread_cancel.3:251 build/C/man3/pthread_cleanup_push.3:335 build/C/man3/pthread_cleanup_push_defer_np.3:123 build/C/man3/pthread_create.3:419 build/C/man3/pthread_detach.3:117 build/C/man3/pthread_equal.3:72 build/C/man3/pthread_exit.3:121 build/C/man3/pthread_getattr_np.3:375 build/C/man3/pthread_getcpuclockid.3:194 build/C/man3/pthread_join.3:150 build/C/man3/pthread_kill.3:125 build/C/man3/pthread_kill_other_threads_np.3:84 build/C/man3/pthread_rwlockattr_setkind_np.3:145 build/C/man3/pthread_self.3:92 build/C/man3/pthread_setaffinity_np.3:224 build/C/man3/pthread_setcancelstate.3:213 build/C/man3/pthread_setconcurrency.3:116 build/C/man3/pthread_setname_np.3:220 build/C/man3/pthread_setschedparam.3:460 build/C/man3/pthread_setschedprio.3:117 build/C/man3/pthread_sigmask.3:177 build/C/man3/pthread_sigqueue.3:126 build/C/man3/pthread_testcancel.3:80 build/C/man3/pthread_tryjoin_np.3:180 build/C/man3/pthread_yield.3:90 build/C/man3/pthread_atfork.3:126 build/C/man3/pthread_attr_setsigmask_np.3:148 build/C/man3/pthread_getattr_default_np.3:212 build/C/man3/pthread_mutex_consistent.3:107 build/C/man3/pthread_mutexattr_getpshared.3:99 build/C/man3/pthread_mutexattr_init.3:71 build/C/man3/pthread_mutexattr_setrobust.3:285 build/C/man3/pthread_spin_init.3:170 build/C/man3/pthread_spin_lock.3:124 build/C/man7/pthreads.7:958 build/C/man7/attributes.7:885 build/C/man7/nptl.7:133
#, no-wrap
msgid "COLOPHON"
msgstr ""

#. type: Plain text
#: build/C/man3/getcontext.3:219 build/C/man3/makecontext.3:249 build/C/man3/pthread_attr_init.3:338 build/C/man3/pthread_attr_setaffinity_np.3:146 build/C/man3/pthread_attr_setdetachstate.3:138 build/C/man3/pthread_attr_setguardsize.3:187 build/C/man3/pthread_attr_setinheritsched.3:164 build/C/man3/pthread_attr_setschedparam.3:149 build/C/man3/pthread_attr_setschedpolicy.3:137 build/C/man3/pthread_attr_setscope.3:163 build/C/man3/pthread_attr_setstack.3:188 build/C/man3/pthread_attr_setstackaddr.3:137 build/C/man3/pthread_attr_setstacksize.3:139 build/C/man3/pthread_cancel.3:259 build/C/man3/pthread_cleanup_push.3:343 build/C/man3/pthread_cleanup_push_defer_np.3:131 build/C/man3/pthread_create.3:427 build/C/man3/pthread_detach.3:125 build/C/man3/pthread_equal.3:80 build/C/man3/pthread_exit.3:129 build/C/man3/pthread_getattr_np.3:383 build/C/man3/pthread_getcpuclockid.3:202 build/C/man3/pthread_join.3:158 build/C/man3/pthread_kill.3:133 build/C/man3/pthread_kill_other_threads_np.3:92 build/C/man3/pthread_rwlockattr_setkind_np.3:153 build/C/man3/pthread_self.3:100 build/C/man3/pthread_setaffinity_np.3:232 build/C/man3/pthread_setcancelstate.3:221 build/C/man3/pthread_setconcurrency.3:124 build/C/man3/pthread_setname_np.3:228 build/C/man3/pthread_setschedparam.3:468 build/C/man3/pthread_setschedprio.3:125 build/C/man3/pthread_sigmask.3:185 build/C/man3/pthread_sigqueue.3:134 build/C/man3/pthread_testcancel.3:88 build/C/man3/pthread_tryjoin_np.3:188 build/C/man3/pthread_yield.3:98 build/C/man3/pthread_atfork.3:134 build/C/man3/pthread_attr_setsigmask_np.3:156 build/C/man3/pthread_getattr_default_np.3:220 build/C/man3/pthread_mutex_consistent.3:115 build/C/man3/pthread_mutexattr_getpshared.3:107 build/C/man3/pthread_mutexattr_init.3:79 build/C/man3/pthread_mutexattr_setrobust.3:293 build/C/man3/pthread_spin_init.3:178 build/C/man3/pthread_spin_lock.3:132 build/C/man7/pthreads.7:966 build/C/man7/attributes.7:893 build/C/man7/nptl.7:141
msgid ""
"This page is part of release 5.10 of the Linux I<man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at "
"\\%https://www.kernel.org/doc/man-pages/."
msgstr ""

#. type: TH
#: build/C/man3/makecontext.3:28
#, no-wrap
msgid "MAKECONTEXT"
msgstr ""

#. type: TH
#: build/C/man3/makecontext.3:28
#, no-wrap
msgid "GNU"
msgstr ""

#. type: Plain text
#: build/C/man3/makecontext.3:31
msgid "makecontext, swapcontext - manipulate user context"
msgstr ""

#. type: Plain text
#: build/C/man3/makecontext.3:36
msgid ""
"B<void makecontext(ucontext_t *>I<ucp>B<, void (*>I<func>B<)(),> B<int "
">I<argc>B<, ...);>"
msgstr ""

#. type: Plain text
#: build/C/man3/makecontext.3:38
msgid "B<int swapcontext(ucontext_t *>I<oucp>B<, const ucontext_t *>I<ucp>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/makecontext.3:53
msgid ""
"In a System V-like environment, one has the type I<ucontext_t> (defined in "
"I<E<lt>ucontext.hE<gt>> and described in B<getcontext>(3))  and the four "
"functions B<getcontext>(3), B<setcontext>(3), B<makecontext>(), and "
"B<swapcontext>()  that allow user-level context switching between multiple "
"threads of control within a process."
msgstr ""

#. type: Plain text
#: build/C/man3/makecontext.3:65
msgid ""
"The B<makecontext>()  function modifies the context pointed to by I<ucp> "
"(which was obtained from a call to B<getcontext>(3)).  Before invoking "
"B<makecontext>(), the caller must allocate a new stack for this context and "
"assign its address to I<ucp-E<gt>uc_stack>, and define a successor context "
"and assign its address to I<ucp-E<gt>uc_link>."
msgstr ""

#. type: Plain text
#: build/C/man3/makecontext.3:79
msgid ""
"When this context is later activated (using B<setcontext>(3)  or "
"B<swapcontext>())  the function I<func> is called, and passed the series of "
"integer (I<int>)  arguments that follow I<argc>; the caller must specify the "
"number of these arguments in I<argc>.  When this function returns, the "
"successor context is activated.  If the successor context pointer is NULL, "
"the thread exits."
msgstr ""

#. type: Plain text
#: build/C/man3/makecontext.3:85
msgid ""
"The B<swapcontext>()  function saves the current context in the structure "
"pointed to by I<oucp>, and then activates the context pointed to by I<ucp>."
msgstr ""

#. type: Plain text
#: build/C/man3/makecontext.3:97
msgid ""
"When successful, B<swapcontext>()  does not return.  (But we may return "
"later, in case I<oucp> is activated, in which case it looks like "
"B<swapcontext>()  returns 0.)  On error, B<swapcontext>()  returns -1 and "
"sets I<errno> appropriately."
msgstr ""

#. type: TP
#: build/C/man3/makecontext.3:98 build/C/man3/pthread_attr_setaffinity_np.3:102 build/C/man3/pthread_getattr_np.3:77 build/C/man3/pthread_atfork.3:83 build/C/man3/pthread_attr_setsigmask_np.3:85 build/C/man3/pthread_getattr_default_np.3:74 build/C/man3/pthread_spin_init.3:125
#, no-wrap
msgid "B<ENOMEM>"
msgstr ""

#. type: Plain text
#: build/C/man3/makecontext.3:101
msgid "Insufficient stack space left."
msgstr ""

#. type: SH
#: build/C/man3/makecontext.3:101 build/C/man3/pthread_attr_setaffinity_np.3:106 build/C/man3/pthread_attr_setguardsize.3:104 build/C/man3/pthread_attr_setstack.3:110 build/C/man3/pthread_attr_setstackaddr.3:81 build/C/man3/pthread_attr_setstacksize.3:81 build/C/man3/pthread_getattr_np.3:96 build/C/man3/pthread_getcpuclockid.3:66 build/C/man3/pthread_rwlockattr_setkind_np.3:134 build/C/man3/pthread_setaffinity_np.3:115 build/C/man3/pthread_setconcurrency.3:81 build/C/man3/pthread_setname_np.3:100 build/C/man3/pthread_setschedprio.3:81 build/C/man3/pthread_sigqueue.3:90 build/C/man3/pthread_tryjoin_np.3:121 build/C/man3/pthread_attr_setsigmask_np.3:89 build/C/man3/pthread_getattr_default_np.3:79 build/C/man3/pthread_mutex_consistent.3:69 build/C/man3/pthread_mutexattr_setrobust.3:145 build/C/man3/pthread_spin_init.3:128 build/C/man3/pthread_spin_lock.3:107
#, no-wrap
msgid "VERSIONS"
msgstr ""

#. type: Plain text
#: build/C/man3/makecontext.3:106
msgid ""
"B<makecontext>()  and B<swapcontext>()  are provided in glibc since version "
"2.1."
msgstr ""

#. type: tbl table
#: build/C/man3/makecontext.3:116
#, no-wrap
msgid "B<makecontext>()"
msgstr ""

#. type: tbl table
#: build/C/man3/makecontext.3:119
#, no-wrap
msgid "B<swapcontext>()"
msgstr ""

#. type: tbl table
#: build/C/man3/makecontext.3:119
#, no-wrap
msgid "MT-Safe race:oucp race:ucp"
msgstr ""

#. type: Plain text
#: build/C/man3/makecontext.3:129
msgid ""
"SUSv2, POSIX.1-2001.  POSIX.1-2008 removes the specifications of "
"B<makecontext>()  and B<swapcontext>(), citing portability issues, and "
"recommending that applications be rewritten to use POSIX threads instead."
msgstr ""

#. type: Plain text
#: build/C/man3/makecontext.3:137
msgid ""
"The interpretation of I<ucp-E<gt>uc_stack> is just as in B<sigaltstack>(2), "
"namely, this struct contains the start and length of a memory area to be "
"used as the stack, regardless of the direction of growth of the stack.  "
"Thus, it is not necessary for the user program to worry about this "
"direction."
msgstr ""

#. type: Plain text
#: build/C/man3/makecontext.3:153
msgid ""
"On architectures where I<int> and pointer types are the same size (e.g., "
"x86-32, where both types are 32 bits), you may be able to get away with "
"passing pointers as arguments to B<makecontext>()  following I<argc>.  "
"However, doing this is not guaranteed to be portable, is undefined according "
"to the standards, and won't work on architectures where pointers are larger "
"than I<int>s.  Nevertheless, starting with version 2.8, glibc makes some "
"changes to B<makecontext>(), to permit this on some 64-bit architectures "
"(e.g., x86-64)."
msgstr ""

#. type: SH
#: build/C/man3/makecontext.3:153 build/C/man3/pthread_attr_init.3:102 build/C/man3/pthread_attr_setdetachstate.3:121 build/C/man3/pthread_attr_setguardsize.3:168 build/C/man3/pthread_attr_setinheritsched.3:141 build/C/man3/pthread_attr_setschedparam.3:126 build/C/man3/pthread_attr_setschedpolicy.3:115 build/C/man3/pthread_attr_setstack.3:165 build/C/man3/pthread_attr_setstacksize.3:121 build/C/man3/pthread_cancel.3:148 build/C/man3/pthread_cleanup_push.3:169 build/C/man3/pthread_create.3:239 build/C/man3/pthread_detach.3:106 build/C/man3/pthread_getattr_np.3:115 build/C/man3/pthread_getcpuclockid.3:93 build/C/man3/pthread_join.3:140 build/C/man3/pthread_setaffinity_np.3:163 build/C/man3/pthread_setcancelstate.3:205 build/C/man3/pthread_setname_np.3:129 build/C/man3/pthread_setschedparam.3:162 build/C/man3/pthread_sigmask.3:93 build/C/man3/pthread_testcancel.3:72 build/C/man3/pthread_tryjoin_np.3:141 build/C/man3/pthread_getattr_default_np.3:99 build/C/man3/pthread_mutex_consistent.3:96 build/C/man3/pthread_mutexattr_setrobust.3:188
#, no-wrap
msgid "EXAMPLES"
msgstr ""

#. type: Plain text
#: build/C/man3/makecontext.3:160
msgid ""
"The example program below demonstrates the use of B<getcontext>(3), "
"B<makecontext>(), and B<swapcontext>().  Running the program produces the "
"following output:"
msgstr ""

#. type: Plain text
#: build/C/man3/makecontext.3:172
#, no-wrap
msgid ""
"$B< ./a.out>\n"
"main: swapcontext(&uctx_main, &uctx_func2)\n"
"func2: started\n"
"func2: swapcontext(&uctx_func2, &uctx_func1)\n"
"func1: started\n"
"func1: swapcontext(&uctx_func1, &uctx_func2)\n"
"func2: returning\n"
"func1: returning\n"
"main: exiting\n"
msgstr ""

#. type: SS
#: build/C/man3/makecontext.3:174 build/C/man3/pthread_attr_init.3:163 build/C/man3/pthread_cancel.3:164 build/C/man3/pthread_cleanup_push.3:245 build/C/man3/pthread_create.3:278 build/C/man3/pthread_getattr_np.3:193 build/C/man3/pthread_getcpuclockid.3:111 build/C/man3/pthread_setname_np.3:154 build/C/man3/pthread_setschedparam.3:237 build/C/man3/pthread_sigmask.3:111 build/C/man3/pthread_getattr_default_np.3:117 build/C/man3/pthread_mutexattr_setrobust.3:211
#, no-wrap
msgid "Program source"
msgstr ""

#. type: Plain text
#: build/C/man3/makecontext.3:180
#, no-wrap
msgid ""
"#include E<lt>ucontext.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/makecontext.3:182
#, no-wrap
msgid "static ucontext_t uctx_main, uctx_func1, uctx_func2;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/makecontext.3:185
#, no-wrap
msgid ""
"#define handle_error(msg) \\e\n"
"    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr ""

#. type: Plain text
#: build/C/man3/makecontext.3:195
#, no-wrap
msgid ""
"static void\n"
"func1(void)\n"
"{\n"
"    printf(\"func1: started\\en\");\n"
"    printf(\"func1: swapcontext(&uctx_func1, &uctx_func2)\\en\");\n"
"    if (swapcontext(&uctx_func1, &uctx_func2) == -1)\n"
"        handle_error(\"swapcontext\");\n"
"    printf(\"func1: returning\\en\");\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/makecontext.3:205
#, no-wrap
msgid ""
"static void\n"
"func2(void)\n"
"{\n"
"    printf(\"func2: started\\en\");\n"
"    printf(\"func2: swapcontext(&uctx_func2, &uctx_func1)\\en\");\n"
"    if (swapcontext(&uctx_func2, &uctx_func1) == -1)\n"
"        handle_error(\"swapcontext\");\n"
"    printf(\"func2: returning\\en\");\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/makecontext.3:211
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char func1_stack[16384];\n"
"    char func2_stack[16384];\n"
msgstr ""

#. type: Plain text
#: build/C/man3/makecontext.3:218
#, no-wrap
msgid ""
"    if (getcontext(&uctx_func1) == -1)\n"
"        handle_error(\"getcontext\");\n"
"    uctx_func1.uc_stack.ss_sp = func1_stack;\n"
"    uctx_func1.uc_stack.ss_size = sizeof(func1_stack);\n"
"    uctx_func1.uc_link = &uctx_main;\n"
"    makecontext(&uctx_func1, func1, 0);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/makecontext.3:226
#, no-wrap
msgid ""
"    if (getcontext(&uctx_func2) == -1)\n"
"        handle_error(\"getcontext\");\n"
"    uctx_func2.uc_stack.ss_sp = func2_stack;\n"
"    uctx_func2.uc_stack.ss_size = sizeof(func2_stack);\n"
"    /* Successor context is f1(), unless argc E<gt> 1 */\n"
"    uctx_func2.uc_link = (argc E<gt> 1) ? NULL : &uctx_func1;\n"
"    makecontext(&uctx_func2, func2, 0);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/makecontext.3:230
#, no-wrap
msgid ""
"    printf(\"main: swapcontext(&uctx_main, &uctx_func2)\\en\");\n"
"    if (swapcontext(&uctx_main, &uctx_func2) == -1)\n"
"        handle_error(\"swapcontext\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/makecontext.3:234
#, no-wrap
msgid ""
"    printf(\"main: exiting\\en\");\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/makecontext.3:241
msgid ""
"B<sigaction>(2), B<sigaltstack>(2), B<sigprocmask>(2), B<getcontext>(3), "
"B<sigsetjmp>(3)"
msgstr ""

#. type: TH
#: build/C/man3/pthread_attr_init.3:26
#, no-wrap
msgid "PTHREAD_ATTR_INIT"
msgstr ""

#. type: TH
#: build/C/man3/pthread_attr_init.3:26 build/C/man3/pthread_create.3:26 build/C/man3/pthread_getattr_np.3:26 build/C/man3/pthread_getcpuclockid.3:26 build/C/man3/pthread_setaffinity_np.3:26 build/C/man3/pthread_setname_np.3:26 build/C/man3/pthread_sigmask.3:26 build/C/man3/pthread_attr_setsigmask_np.3:26
#, no-wrap
msgid "2020-11-01"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:30
msgid ""
"pthread_attr_init, pthread_attr_destroy - initialize and destroy thread "
"attributes object"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:33 build/C/man3/pthread_attr_setdetachstate.3:33 build/C/man3/pthread_attr_setguardsize.3:33 build/C/man3/pthread_attr_setinheritsched.3:33 build/C/man3/pthread_attr_setschedparam.3:33 build/C/man3/pthread_attr_setschedpolicy.3:33 build/C/man3/pthread_attr_setscope.3:33 build/C/man3/pthread_attr_setstack.3:33 build/C/man3/pthread_attr_setstackaddr.3:33 build/C/man3/pthread_attr_setstacksize.3:33 build/C/man3/pthread_cancel.3:32 build/C/man3/pthread_cleanup_push.3:33 build/C/man3/pthread_cleanup_push_defer_np.3:33 build/C/man3/pthread_create.3:32 build/C/man3/pthread_detach.3:32 build/C/man3/pthread_equal.3:32 build/C/man3/pthread_exit.3:32 build/C/man3/pthread_join.3:32 build/C/man3/pthread_kill_other_threads_np.3:32 build/C/man3/pthread_rwlockattr_setkind_np.3:32 build/C/man3/pthread_self.3:32 build/C/man3/pthread_setcancelstate.3:33 build/C/man3/pthread_setconcurrency.3:32 build/C/man3/pthread_setschedparam.3:33 build/C/man3/pthread_setschedprio.3:32 build/C/man3/pthread_testcancel.3:32 build/C/man3/pthread_atfork.3:31 build/C/man3/pthread_mutex_consistent.3:32 build/C/man3/pthread_mutexattr_getpshared.3:32 build/C/man3/pthread_mutexattr_init.3:32 build/C/man3/pthread_mutexattr_setrobust.3:33 build/C/man3/pthread_spin_init.3:31 build/C/man3/pthread_spin_lock.3:32
#, no-wrap
msgid "B<#include E<lt>pthread.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:36
#, no-wrap
msgid ""
"B<int pthread_attr_init(pthread_attr_t *>I<attr>B<);>\n"
"B<int pthread_attr_destroy(pthread_attr_t *>I<attr>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:38 build/C/man3/pthread_attr_setaffinity_np.3:41 build/C/man3/pthread_attr_setdetachstate.3:40 build/C/man3/pthread_attr_setguardsize.3:40 build/C/man3/pthread_attr_setinheritsched.3:40 build/C/man3/pthread_attr_setschedparam.3:40 build/C/man3/pthread_attr_setschedpolicy.3:40 build/C/man3/pthread_attr_setscope.3:40 build/C/man3/pthread_attr_setstack.3:40 build/C/man3/pthread_attr_setstackaddr.3:40 build/C/man3/pthread_attr_setstacksize.3:40 build/C/man3/pthread_cancel.3:36 build/C/man3/pthread_cleanup_push.3:39 build/C/man3/pthread_equal.3:36 build/C/man3/pthread_exit.3:36 build/C/man3/pthread_getattr_np.3:37 build/C/man3/pthread_getcpuclockid.3:37 build/C/man3/pthread_rwlockattr_setkind_np.3:39 build/C/man3/pthread_self.3:36 build/C/man3/pthread_setaffinity_np.3:41 build/C/man3/pthread_setcancelstate.3:38 build/C/man3/pthread_setconcurrency.3:37 build/C/man3/pthread_setschedparam.3:40 build/C/man3/pthread_setschedprio.3:36 build/C/man3/pthread_testcancel.3:36 build/C/man3/pthread_attr_setsigmask_np.3:41 build/C/man3/pthread_getattr_default_np.3:38
#, no-wrap
msgid "Compile and link with I<-pthread>.\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:50
msgid ""
"The B<pthread_attr_init>()  function initializes the thread attributes "
"object pointed to by I<attr> with default attribute values.  After this "
"call, individual attributes of the object can be set using various related "
"functions (listed under SEE ALSO), and then the object can be used in one or "
"more B<pthread_create>(3)  calls that create threads."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:55
msgid ""
"Calling B<pthread_attr_init>()  on a thread attributes object that has "
"already been initialized results in undefined behavior."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:62
msgid ""
"When a thread attributes object is no longer required, it should be "
"destroyed using the B<pthread_attr_destroy>()  function.  Destroying a "
"thread attributes object has no effect on threads that were created using "
"that object."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:68
msgid ""
"Once a thread attributes object has been destroyed, it can be reinitialized "
"using B<pthread_attr_init>().  Any other use of a destroyed thread "
"attributes object has undefined results."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:71 build/C/man3/pthread_attr_setaffinity_np.3:79 build/C/man3/pthread_attr_setdetachstate.3:80 build/C/man3/pthread_attr_setguardsize.3:93 build/C/man3/pthread_attr_setinheritsched.3:96 build/C/man3/pthread_attr_setschedparam.3:88 build/C/man3/pthread_attr_setschedpolicy.3:86 build/C/man3/pthread_attr_setscope.3:106 build/C/man3/pthread_attr_setstack.3:88 build/C/man3/pthread_attr_setstackaddr.3:77 build/C/man3/pthread_attr_setstacksize.3:64 build/C/man3/pthread_setaffinity_np.3:80 build/C/man3/pthread_setcancelstate.3:100 build/C/man3/pthread_setname_np.3:75
msgid ""
"On success, these functions return 0; on error, they return a nonzero error "
"number."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:79
msgid ""
"POSIX.1 documents an B<ENOMEM> error for B<pthread_attr_init>(); on Linux "
"these functions always succeed (but portable and future-proof applications "
"should nevertheless handle a possible error return)."
msgstr ""

#. type: tbl table
#: build/C/man3/pthread_attr_init.3:91
#, no-wrap
msgid ""
"B<pthread_attr_init>(),\n"
"B<pthread_attr_destroy>()"
msgstr ""

#. type: tbl table
#: build/C/man3/pthread_attr_init.3:91 build/C/man3/pthread_attr_setaffinity_np.3:119 build/C/man3/pthread_attr_setdetachstate.3:98 build/C/man3/pthread_attr_setguardsize.3:117 build/C/man3/pthread_attr_setinheritsched.3:121 build/C/man3/pthread_attr_setschedparam.3:118 build/C/man3/pthread_attr_setschedpolicy.3:111 build/C/man3/pthread_attr_setscope.3:130 build/C/man3/pthread_attr_setstack.3:123 build/C/man3/pthread_attr_setstackaddr.3:94 build/C/man3/pthread_attr_setstacksize.3:94 build/C/man3/pthread_cancel.3:135 build/C/man3/pthread_cleanup_push.3:138 build/C/man3/pthread_create.3:163 build/C/man3/pthread_detach.3:74 build/C/man3/pthread_equal.3:57 build/C/man3/pthread_exit.3:85 build/C/man3/pthread_getattr_np.3:109 build/C/man3/pthread_getcpuclockid.3:78 build/C/man3/pthread_join.3:108 build/C/man3/pthread_kill.3:82 build/C/man3/pthread_kill_other_threads_np.3:57 build/C/man3/pthread_self.3:60 build/C/man3/pthread_setaffinity_np.3:128 build/C/man3/pthread_setcancelstate.3:132 build/C/man3/pthread_setconcurrency.3:94 build/C/man3/pthread_setname_np.3:113 build/C/man3/pthread_setschedparam.3:152 build/C/man3/pthread_setschedprio.3:93 build/C/man3/pthread_sigmask.3:79 build/C/man3/pthread_sigqueue.3:104 build/C/man3/pthread_testcancel.3:68 build/C/man3/pthread_tryjoin_np.3:135 build/C/man3/pthread_yield.3:63 build/C/man3/pthread_attr_setsigmask_np.3:102 build/C/man3/pthread_getattr_default_np.3:93
#, no-wrap
msgid "MT-Safe"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:96 build/C/man3/pthread_attr_setdetachstate.3:102 build/C/man3/pthread_attr_setguardsize.3:121 build/C/man3/pthread_attr_setinheritsched.3:125 build/C/man3/pthread_attr_setschedparam.3:122 build/C/man3/pthread_attr_setschedpolicy.3:115 build/C/man3/pthread_attr_setscope.3:134 build/C/man3/pthread_attr_setstack.3:127 build/C/man3/pthread_attr_setstacksize.3:98 build/C/man3/pthread_cancel.3:140 build/C/man3/pthread_cleanup_push.3:143 build/C/man3/pthread_create.3:168 build/C/man3/pthread_detach.3:79 build/C/man3/pthread_equal.3:61 build/C/man3/pthread_exit.3:89 build/C/man3/pthread_getcpuclockid.3:82 build/C/man3/pthread_join.3:113 build/C/man3/pthread_kill.3:86 build/C/man3/pthread_self.3:64 build/C/man3/pthread_setcancelstate.3:144 build/C/man3/pthread_setconcurrency.3:98 build/C/man3/pthread_setschedparam.3:156 build/C/man3/pthread_setschedprio.3:97 build/C/man3/pthread_sigmask.3:83 build/C/man3/pthread_testcancel.3:72 build/C/man3/pthread_atfork.3:88 build/C/man3/pthread_mutexattr_getpshared.3:94 build/C/man3/pthread_mutexattr_init.3:61
msgid "POSIX.1-2001, POSIX.1-2008."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:102
msgid ""
"The I<pthread_attr_t> type should be treated as opaque: any access to the "
"object other than via pthreads functions is nonportable and produces "
"undefined results."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:111
msgid ""
"The program below optionally makes use of B<pthread_attr_init>()  and "
"various related functions to initialize a thread attributes object that is "
"used to create a single thread.  Once created, the thread uses the "
"B<pthread_getattr_np>(3)  function (a nonstandard GNU extension) to retrieve "
"the thread's attributes, and then displays those attributes."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:120
msgid ""
"If the program is run with no command-line argument, then it passes NULL as "
"the I<attr> argument of B<pthread_create>(3), so that the thread is created "
"with default attributes.  Running the program on Linux/x86-32 with the NPTL "
"threading implementation, we see the following:"
msgstr ""

#.  Results from glibc 2.8, SUSE 11.0; Oct 2008
#. type: Plain text
#: build/C/man3/pthread_attr_init.3:136
#, no-wrap
msgid ""
"$B< ulimit -s>       # No stack limit ==E<gt> default stack size is 2 MB\n"
"unlimited\n"
"$B< ./a.out>\n"
"Thread attributes:\n"
"        Detach state        = PTHREAD_CREATE_JOINABLE\n"
"        Scope               = PTHREAD_SCOPE_SYSTEM\n"
"        Inherit scheduler   = PTHREAD_INHERIT_SCHED\n"
"        Scheduling policy   = SCHED_OTHER\n"
"        Scheduling priority = 0\n"
"        Guard size          = 4096 bytes\n"
"        Stack address       = 0x40196000\n"
"        Stack size          = 0x201000 bytes\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:146
msgid ""
"When we supply a stack size as a command-line argument, the program "
"initializes a thread attributes object, sets various attributes in that "
"object, and passes a pointer to the object in the call to "
"B<pthread_create>(3).  Running the program on Linux/x86-32 with the NPTL "
"threading implementation, we see the following:"
msgstr ""

#.  Results from glibc 2.8, SUSE 11.0; Oct 2008
#. type: Plain text
#: build/C/man3/pthread_attr_init.3:161
#, no-wrap
msgid ""
"$B< ./a.out 0x3000000>\n"
"posix_memalign() allocated at 0x40197000\n"
"Thread attributes:\n"
"        Detach state        = PTHREAD_CREATE_DETACHED\n"
"        Scope               = PTHREAD_SCOPE_SYSTEM\n"
"        Inherit scheduler   = PTHREAD_EXPLICIT_SCHED\n"
"        Scheduling policy   = SCHED_OTHER\n"
"        Scheduling priority = 0\n"
"        Guard size          = 0 bytes\n"
"        Stack address       = 0x40197000\n"
"        Stack size          = 0x3000000 bytes\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:172 build/C/man3/pthread_getattr_np.3:202
#, no-wrap
msgid ""
"#define _GNU_SOURCE     /* To get pthread_getattr_np() declaration */\n"
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:175 build/C/man3/pthread_cancel.3:175 build/C/man3/pthread_cleanup_push.3:257 build/C/man3/pthread_create.3:291 build/C/man3/pthread_getattr_np.3:205 build/C/man3/pthread_getcpuclockid.3:130 build/C/man3/pthread_setaffinity_np.3:181 build/C/man3/pthread_setschedparam.3:250 build/C/man3/pthread_sigmask.3:125 build/C/man3/pthread_mutexattr_setrobust.3:221
#, no-wrap
msgid ""
"#define handle_error_en(en, msg) \\e\n"
"        do { errno = en; perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:183
#, no-wrap
msgid ""
"static void\n"
"display_pthread_attr(pthread_attr_t *attr, char *prefix)\n"
"{\n"
"    int s, i;\n"
"    size_t v;\n"
"    void *stkaddr;\n"
"    struct sched_param sp;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:191
#, no-wrap
msgid ""
"    s = pthread_attr_getdetachstate(attr, &i);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getdetachstate\");\n"
"    printf(\"%sDetach state        = %s\\en\", prefix,\n"
"            (i == PTHREAD_CREATE_DETACHED) ? \"PTHREAD_CREATE_DETACHED\" :\n"
"            (i == PTHREAD_CREATE_JOINABLE) ? \"PTHREAD_CREATE_JOINABLE\" :\n"
"            \"???\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:199
#, no-wrap
msgid ""
"    s = pthread_attr_getscope(attr, &i);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getscope\");\n"
"    printf(\"%sScope               = %s\\en\", prefix,\n"
"            (i == PTHREAD_SCOPE_SYSTEM)  ? \"PTHREAD_SCOPE_SYSTEM\" :\n"
"            (i == PTHREAD_SCOPE_PROCESS) ? \"PTHREAD_SCOPE_PROCESS\" :\n"
"            \"???\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:207
#, no-wrap
msgid ""
"    s = pthread_attr_getinheritsched(attr, &i);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getinheritsched\");\n"
"    printf(\"%sInherit scheduler   = %s\\en\", prefix,\n"
"            (i == PTHREAD_INHERIT_SCHED)  ? \"PTHREAD_INHERIT_SCHED\" :\n"
"            (i == PTHREAD_EXPLICIT_SCHED) ? \"PTHREAD_EXPLICIT_SCHED\" :\n"
"            \"???\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:216
#, no-wrap
msgid ""
"    s = pthread_attr_getschedpolicy(attr, &i);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getschedpolicy\");\n"
"    printf(\"%sScheduling policy   = %s\\en\", prefix,\n"
"            (i == SCHED_OTHER) ? \"SCHED_OTHER\" :\n"
"            (i == SCHED_FIFO)  ? \"SCHED_FIFO\" :\n"
"            (i == SCHED_RR)    ? \"SCHED_RR\" :\n"
"            \"???\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:221
#, no-wrap
msgid ""
"    s = pthread_attr_getschedparam(attr, &sp);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getschedparam\");\n"
"    printf(\"%sScheduling priority = %d\\en\", prefix, sp.sched_priority);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:226
#, no-wrap
msgid ""
"    s = pthread_attr_getguardsize(attr, &v);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getguardsize\");\n"
"    printf(\"%sGuard size          = %zu bytes\\en\", prefix, v);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:233
#, no-wrap
msgid ""
"    s = pthread_attr_getstack(attr, &stkaddr, &v);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getstack\");\n"
"    printf(\"%sStack address       = %p\\en\", prefix, stkaddr);\n"
"    printf(\"%sStack size          = %#zx bytes\\en\", prefix, v);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:239
#, no-wrap
msgid ""
"static void *\n"
"thread_start(void *arg)\n"
"{\n"
"    int s;\n"
"    pthread_attr_t gattr;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:243
#, no-wrap
msgid ""
"    /* pthread_getattr_np() is a non-standard GNU extension that\n"
"       retrieves the attributes of the thread specified in its\n"
"       first argument */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:247
#, no-wrap
msgid ""
"    s = pthread_getattr_np(pthread_self(), &gattr);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_getattr_np\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:250
#, no-wrap
msgid ""
"    printf(\"Thread attributes:\\en\");\n"
"    display_pthread_attr(&gattr, \"\\et\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:253 build/C/man3/pthread_getattr_np.3:254
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);         /* Terminate all threads */\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:261
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pthread_t thr;\n"
"    pthread_attr_t attr;\n"
"    pthread_attr_t *attrp;      /* NULL or &attr */\n"
"    int s;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:263 build/C/man3/pthread_setschedparam.3:368
#, no-wrap
msgid "    attrp = NULL;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:267
#, no-wrap
msgid ""
"    /* If a command-line argument was supplied, use it to set the\n"
"       stack-size attribute and set a few other thread attributes,\n"
"       and set attrp pointing to thread attributes object */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:271
#, no-wrap
msgid ""
"    if (argc E<gt> 1) {\n"
"        size_t stack_size;\n"
"        void *sp;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:273
#, no-wrap
msgid "        attrp = &attr;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:277
#, no-wrap
msgid ""
"        s = pthread_attr_init(&attr);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_init\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:281
#, no-wrap
msgid ""
"        s = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setdetachstate\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:285
#, no-wrap
msgid ""
"        s = pthread_attr_setinheritsched(&attr, PTHREAD_EXPLICIT_SCHED);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setinheritsched\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:287
#, no-wrap
msgid "        stack_size = strtoul(argv[1], NULL, 0);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:291
#, no-wrap
msgid ""
"        s = posix_memalign(&sp, sysconf(_SC_PAGESIZE), stack_size);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"posix_memalign\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:293
#, no-wrap
msgid "        printf(\"posix_memalign() allocated at %p\\en\", sp);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:298
#, no-wrap
msgid ""
"        s = pthread_attr_setstack(&attr, sp, stack_size);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setstack\");\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:302 build/C/man3/pthread_getattr_np.3:349
#, no-wrap
msgid ""
"    s = pthread_create(&thr, attrp, &thread_start, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_create\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:308 build/C/man3/pthread_getattr_np.3:355
#, no-wrap
msgid ""
"    if (attrp != NULL) {\n"
"        s = pthread_attr_destroy(attrp);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_destroy\");\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:311 build/C/man3/pthread_getattr_np.3:358
#, no-wrap
msgid ""
"    pause();    /* Terminates when other thread calls exit() */\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:330
msgid ""
"B<pthread_attr_setaffinity_np>(3), B<pthread_attr_setdetachstate>(3), "
"B<pthread_attr_setguardsize>(3), B<pthread_attr_setinheritsched>(3), "
"B<pthread_attr_setschedparam>(3), B<pthread_attr_setschedpolicy>(3), "
"B<pthread_attr_setscope>(3), B<pthread_attr_setsigmask_np>(3), "
"B<pthread_attr_setstack>(3), B<pthread_attr_setstackaddr>(3), "
"B<pthread_attr_setstacksize>(3), B<pthread_create>(3), "
"B<pthread_getattr_np>(3), B<pthread_setattr_default_np>(3), B<pthreads>(7)"
msgstr ""

#. type: TH
#: build/C/man3/pthread_attr_setaffinity_np.3:26
#, no-wrap
msgid "PTHREAD_ATTR_SETAFFINITY_NP"
msgstr ""

#. type: TH
#: build/C/man3/pthread_attr_setaffinity_np.3:26 build/C/man3/pthread_attr_setscope.3:26 build/C/man3/pthread_attr_setstackaddr.3:26 build/C/man3/pthread_cleanup_push_defer_np.3:26 build/C/man3/pthread_exit.3:26 build/C/man3/pthread_kill.3:26 build/C/man3/pthread_kill_other_threads_np.3:26 build/C/man3/pthread_self.3:26 build/C/man3/pthread_setconcurrency.3:25 build/C/man3/pthread_sigqueue.3:25
#, no-wrap
msgid "2017-09-15"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setaffinity_np.3:30
msgid ""
"pthread_attr_setaffinity_np, pthread_attr_getaffinity_np - set/get CPU "
"affinity attribute in thread attributes object"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setaffinity_np.3:34 build/C/man3/pthread_getattr_np.3:33 build/C/man3/pthread_setaffinity_np.3:34 build/C/man3/pthread_tryjoin_np.3:34 build/C/man3/pthread_yield.3:32 build/C/man3/pthread_attr_setsigmask_np.3:34 build/C/man3/pthread_getattr_default_np.3:33
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>pthread.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setaffinity_np.3:39
#, no-wrap
msgid ""
"B<int pthread_attr_setaffinity_np(pthread_attr_t *>I<attr>B<,>\n"
"B<                   size_t >I<cpusetsize>B<, const cpu_set_t "
"*>I<cpuset>B<);>\n"
"B<int pthread_attr_getaffinity_np(const pthread_attr_t *>I<attr>B<,>\n"
"B<                   size_t >I<cpusetsize>B<, cpu_set_t *>I<cpuset>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setaffinity_np.3:54
msgid ""
"The B<pthread_attr_setaffinity_np>()  function sets the CPU affinity mask "
"attribute of the thread attributes object referred to by I<attr> to the "
"value specified in I<cpuset>.  This attribute determines the CPU affinity "
"mask of a thread created using the thread attributes object I<attr>."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setaffinity_np.3:63
msgid ""
"The B<pthread_attr_getaffinity_np>()  function returns the CPU affinity mask "
"attribute of the thread attributes object referred to by I<attr> in the "
"buffer pointed to by I<cpuset>."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setaffinity_np.3:70
msgid ""
"The argument I<cpusetsize> is the length (in bytes) of the buffer pointed to "
"by I<cpuset>.  Typically, this argument would be specified as "
"I<sizeof(cpu_set_t)>."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setaffinity_np.3:76 build/C/man3/pthread_setaffinity_np.3:67
msgid ""
"For more details on CPU affinity masks, see B<sched_setaffinity>(2).  For a "
"description of a set of macros that can be used to manipulate and inspect "
"CPU sets, see B<CPU_SET>(3)."
msgstr ""

#. type: TP
#: build/C/man3/pthread_attr_setaffinity_np.3:80 build/C/man3/pthread_attr_setaffinity_np.3:92 build/C/man3/pthread_attr_setdetachstate.3:83 build/C/man3/pthread_attr_setinheritsched.3:99 build/C/man3/pthread_attr_setschedparam.3:91 build/C/man3/pthread_attr_setschedpolicy.3:89 build/C/man3/pthread_attr_setscope.3:109 build/C/man3/pthread_attr_setstack.3:91 build/C/man3/pthread_attr_setstacksize.3:67 build/C/man3/pthread_create.3:144 build/C/man3/pthread_detach.3:55 build/C/man3/pthread_join.3:85 build/C/man3/pthread_join.3:89 build/C/man3/pthread_kill.3:69 build/C/man3/pthread_rwlockattr_setkind_np.3:130 build/C/man3/pthread_setaffinity_np.3:84 build/C/man3/pthread_setaffinity_np.3:93 build/C/man3/pthread_setaffinity_np.3:105 build/C/man3/pthread_setcancelstate.3:104 build/C/man3/pthread_setcancelstate.3:112 build/C/man3/pthread_setconcurrency.3:71 build/C/man3/pthread_setschedparam.3:122 build/C/man3/pthread_setschedprio.3:62 build/C/man3/pthread_sigqueue.3:78 build/C/man3/pthread_tryjoin_np.3:109 build/C/man3/pthread_getattr_default_np.3:67 build/C/man3/pthread_mutex_consistent.3:66 build/C/man3/pthread_mutexattr_getpshared.3:82 build/C/man3/pthread_mutexattr_setrobust.3:137
#, no-wrap
msgid "B<EINVAL>"
msgstr ""

#.  cpumask_t
#.  The raw sched_getaffinity() system call returns the size (in bytes)
#.  of the cpumask_t type.
#. type: Plain text
#: build/C/man3/pthread_attr_setaffinity_np.3:92
msgid ""
"(B<pthread_attr_setaffinity_np>())  I<cpuset> specified a CPU that was "
"outside the set supported by the kernel.  (The kernel configuration option "
"B<CONFIG_NR_CPUS> defines the range of the set supported by the kernel data "
"type used to represent CPU sets.)"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setaffinity_np.3:102
msgid ""
"(B<pthread_attr_getaffinity_np>())  A CPU in the affinity mask of the thread "
"attributes object referred to by I<attr> lies outside the range specified by "
"I<cpusetsize> (i.e., I<cpuset>/I<cpusetsize> is too small)."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setaffinity_np.3:106
msgid "(B<pthread_attr_setaffinity_np>())  Could not allocate memory."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setaffinity_np.3:108 build/C/man3/pthread_setaffinity_np.3:117
msgid "These functions are provided by glibc since version 2.3.4."
msgstr ""

#. type: tbl table
#: build/C/man3/pthread_attr_setaffinity_np.3:119
#, no-wrap
msgid ""
"B<pthread_attr_setaffinity_np>(),\n"
"B<pthread_attr_getaffinity_np>()"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setaffinity_np.3:125 build/C/man3/pthread_cleanup_push_defer_np.3:117 build/C/man3/pthread_setaffinity_np.3:133 build/C/man3/pthread_setname_np.3:119 build/C/man3/pthread_tryjoin_np.3:141 build/C/man3/pthread_attr_setsigmask_np.3:108
msgid ""
"These functions are nonstandard GNU extensions; hence the suffix \"_np\" "
"(nonportable) in the names."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setaffinity_np.3:132 build/C/man3/pthread_setaffinity_np.3:159
msgid ""
"In glibc 2.3.3 only, versions of these functions were provided that did not "
"have a I<cpusetsize> argument.  Instead the CPU set size given to the "
"underlying system calls was always I<sizeof(cpu_set_t)>."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setaffinity_np.3:138
msgid ""
"B<sched_setaffinity>(2), B<pthread_attr_init>(3), "
"B<pthread_setaffinity_np>(3), B<cpuset>(7), B<pthreads>(7)"
msgstr ""

#. type: TH
#: build/C/man3/pthread_attr_setdetachstate.3:26
#, no-wrap
msgid "PTHREAD_ATTR_SETDETACHSTATE"
msgstr ""

#. type: TH
#: build/C/man3/pthread_attr_setdetachstate.3:26 build/C/man3/pthread_attr_setguardsize.3:26 build/C/man3/pthread_attr_setinheritsched.3:26 build/C/man3/pthread_attr_setschedparam.3:26 build/C/man3/pthread_attr_setschedpolicy.3:26 build/C/man3/pthread_attr_setstack.3:26 build/C/man3/pthread_attr_setstacksize.3:26 build/C/man3/pthread_cancel.3:26 build/C/man3/pthread_cleanup_push.3:26 build/C/man3/pthread_detach.3:26 build/C/man3/pthread_join.3:26 build/C/man3/pthread_setcancelstate.3:26 build/C/man3/pthread_setschedparam.3:26 build/C/man3/pthread_testcancel.3:26 build/C/man3/pthread_getattr_default_np.3:25 build/C/man3/pthread_mutex_consistent.3:26 build/C/man3/pthread_mutexattr_setrobust.3:26 build/C/man3/pthread_spin_init.3:25
#, no-wrap
msgid "2020-06-09"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setdetachstate.3:30
msgid ""
"pthread_attr_setdetachstate, pthread_attr_getdetachstate - set/get detach "
"state attribute in thread attributes object"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setdetachstate.3:38
#, no-wrap
msgid ""
"B<int pthread_attr_setdetachstate(pthread_attr_t *>I<attr>B<, int "
">I<detachstate>B<);>\n"
"B<int pthread_attr_getdetachstate(const pthread_attr_t *>I<attr>B<,>\n"
"B<                                int *>I<detachstate>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setdetachstate.3:53
msgid ""
"The B<pthread_attr_setdetachstate>()  function sets the detach state "
"attribute of the thread attributes object referred to by I<attr> to the "
"value specified in I<detachstate>.  The detach state attribute determines "
"whether a thread created using the thread attributes object I<attr> will be "
"created in a joinable or a detached state."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setdetachstate.3:56
msgid "The following values may be specified in I<detachstate>:"
msgstr ""

#. type: TP
#: build/C/man3/pthread_attr_setdetachstate.3:56
#, no-wrap
msgid "B<PTHREAD_CREATE_DETACHED>"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setdetachstate.3:61
msgid "Threads that are created using I<attr> will be created in a detached state."
msgstr ""

#. type: TP
#: build/C/man3/pthread_attr_setdetachstate.3:61
#, no-wrap
msgid "B<PTHREAD_CREATE_JOINABLE>"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setdetachstate.3:66
msgid "Threads that are created using I<attr> will be created in a joinable state."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setdetachstate.3:70
msgid ""
"The default setting of the detach state attribute in a newly initialized "
"thread attributes object is B<PTHREAD_CREATE_JOINABLE>."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setdetachstate.3:77
msgid ""
"The B<pthread_attr_getdetachstate>()  returns the detach state attribute of "
"the thread attributes object I<attr> in the buffer pointed to by "
"I<detachstate>."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setdetachstate.3:83
msgid "B<pthread_attr_setdetachstate>()  can fail with the following error:"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setdetachstate.3:87
msgid "An invalid value was specified in I<detachstate>."
msgstr ""

#. type: tbl table
#: build/C/man3/pthread_attr_setdetachstate.3:98
#, no-wrap
msgid ""
"B<pthread_attr_setdetachstate>(),\n"
"B<pthread_attr_getdetachstate>()"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setdetachstate.3:106
msgid "See B<pthread_create>(3)  for more details on detached and joinable threads."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setdetachstate.3:114
msgid ""
"A thread that is created in a joinable state should eventually either be "
"joined using B<pthread_join>(3)  or detached using B<pthread_detach>(3); see "
"B<pthread_create>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setdetachstate.3:121
msgid ""
"It is an error to specify the thread ID of a thread that was created in a "
"detached state in a later call to B<pthread_detach>(3)  or "
"B<pthread_join>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setdetachstate.3:124 build/C/man3/pthread_attr_setstack.3:168
msgid "See B<pthread_attr_init>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setdetachstate.3:130
msgid ""
"B<pthread_attr_init>(3), B<pthread_create>(3), B<pthread_detach>(3), "
"B<pthread_join>(3), B<pthreads>(7)"
msgstr ""

#. type: TH
#: build/C/man3/pthread_attr_setguardsize.3:26
#, no-wrap
msgid "PTHREAD_ATTR_SETGUARDSIZE"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setguardsize.3:30
msgid ""
"pthread_attr_setguardsize, pthread_attr_getguardsize - set/get guard size "
"attribute in thread attributes object"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setguardsize.3:38
#, no-wrap
msgid ""
"B<int pthread_attr_setguardsize(pthread_attr_t *>I<attr>B<, size_t "
">I<guardsize>B<);>\n"
"B<int pthread_attr_getguardsize(const pthread_attr_t *>I<attr>B<,>\n"
"B<                              size_t *>I<guardsize>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setguardsize.3:49
msgid ""
"The B<pthread_attr_setguardsize>()  function sets the guard size attribute "
"of the thread attributes object referred to by I<attr> to the value "
"specified in I<guardsize>."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setguardsize.3:59
msgid ""
"If I<guardsize> is greater than 0, then for each new thread created using "
"I<attr> the system allocates an additional region of at least I<guardsize> "
"bytes at the end of the thread's stack to act as the guard area for the "
"stack (but see BUGS)."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setguardsize.3:65
msgid ""
"If I<guardsize> is 0, then new threads created with I<attr> will not have a "
"guard area."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setguardsize.3:67
msgid "The default guard size is the same as the system page size."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setguardsize.3:82
msgid ""
"If the stack address attribute has been set in I<attr> (using "
"B<pthread_attr_setstack>(3)  or B<pthread_attr_setstackaddr>(3)), meaning "
"that the caller is allocating the thread's stack, then the guard size "
"attribute is ignored (i.e., no guard area is created by the system): it is "
"the application's responsibility to handle stack overflow (perhaps by using "
"B<mprotect>(2)  to manually define a guard area at the end of the stack that "
"it has allocated)."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setguardsize.3:90
msgid ""
"The B<pthread_attr_getguardsize>()  function returns the guard size "
"attribute of the thread attributes object referred to by I<attr> in the "
"buffer pointed to by I<guardsize>."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setguardsize.3:104
msgid ""
"POSIX.1 documents an B<EINVAL> error if I<attr> or I<guardsize> is invalid.  "
"On Linux these functions always succeed (but portable and future-proof "
"applications should nevertheless handle a possible error return)."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setguardsize.3:106 build/C/man3/pthread_attr_setstackaddr.3:83 build/C/man3/pthread_attr_setstacksize.3:83
msgid "These functions are provided by glibc since version 2.1."
msgstr ""

#. type: tbl table
#: build/C/man3/pthread_attr_setguardsize.3:117
#, no-wrap
msgid ""
"B<pthread_attr_setguardsize>(),\n"
"B<pthread_attr_getguardsize>()"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setguardsize.3:135
msgid ""
"A guard area consists of virtual memory pages that are protected to prevent "
"read and write access.  If a thread overflows its stack into the guard area, "
"then, on most hard architectures, it receives a B<SIGSEGV> signal, thus "
"notifying it of the overflow.  Guard areas start on page boundaries, and the "
"guard size is internally rounded up to the system page size when creating a "
"thread.  (Nevertheless, B<pthread_attr_getguardsize>()  returns the guard "
"size that was set by B<pthread_attr_setguardsize>().)"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setguardsize.3:139
msgid ""
"Setting a guard size of 0 may be useful to save memory in an application "
"that creates many threads and knows that stack overflow can never occur."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setguardsize.3:143
msgid ""
"Choosing a guard size larger than the default size may be necessary for "
"detecting stack overflows if a thread allocates large data structures on the "
"stack."
msgstr ""

#. type: SH
#: build/C/man3/pthread_attr_setguardsize.3:143 build/C/man3/pthread_attr_setinheritsched.3:125 build/C/man3/pthread_attr_setstacksize.3:109 build/C/man3/pthread_create.3:233 build/C/man3/pthread_exit.3:105 build/C/man3/pthread_tryjoin_np.3:163
#, no-wrap
msgid "BUGS"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setguardsize.3:154
msgid ""
"As at glibc 2.8, the NPTL threading implementation includes the guard area "
"within the stack size allocation, rather than allocating extra space at the "
"end of the stack, as POSIX.1 requires.  (This can result in an B<EINVAL> "
"error from B<pthread_create>(3)  if the guard size value is too large, "
"leaving no space for the actual stack.)"
msgstr ""

#.  glibc includes the guardsize within the allocated stack size,
#.  which looks pretty clearly to be in violation of POSIX.
#
#.  Filed bug, 22 Oct 2008:
#.  http://sources.redhat.com/bugzilla/show_bug.cgi?id=6973
#
#.  Older reports:
#.  https//bugzilla.redhat.com/show_bug.cgi?id=435337
#.  Reportedly, LinuxThreads did the right thing, allocating
#.  extra space at the end of the stack:
#.  http://sourceware.org/ml/libc-alpha/2008-05/msg00086.html
#. type: Plain text
#: build/C/man3/pthread_attr_setguardsize.3:168
msgid ""
"The obsolete LinuxThreads implementation did the right thing, allocating "
"extra space at the end of the stack for the guard area."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setguardsize.3:171
msgid "See B<pthread_getattr_np>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setguardsize.3:179
msgid ""
"B<mmap>(2), B<mprotect>(2), B<pthread_attr_init>(3), "
"B<pthread_attr_setstack>(3), B<pthread_attr_setstacksize>(3), "
"B<pthread_create>(3), B<pthreads>(7)"
msgstr ""

#. type: TH
#: build/C/man3/pthread_attr_setinheritsched.3:26
#, no-wrap
msgid "PTHREAD_ATTR_SETINHERITSCHED"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setinheritsched.3:30
msgid ""
"pthread_attr_setinheritsched, pthread_attr_getinheritsched - set/get "
"inherit-scheduler attribute in thread attributes object"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setinheritsched.3:38
#, no-wrap
msgid ""
"B<int pthread_attr_setinheritsched(pthread_attr_t *>I<attr>B<,>\n"
"B<                                 int >I<inheritsched>B<);>\n"
"B<int pthread_attr_getinheritsched(const pthread_attr_t *>I<attr>B<,>\n"
"B<                                 int *>I<inheritsched>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setinheritsched.3:55
msgid ""
"The B<pthread_attr_setinheritsched>()  function sets the inherit-scheduler "
"attribute of the thread attributes object referred to by I<attr> to the "
"value specified in I<inheritsched>.  The inherit-scheduler attribute "
"determines whether a thread created using the thread attributes object "
"I<attr> will inherit its scheduling attributes from the calling thread or "
"whether it will take them from I<attr>."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setinheritsched.3:64
msgid ""
"The following scheduling attributes are affected by the inherit-scheduler "
"attribute: scheduling policy (B<pthread_attr_setschedpolicy>(3)), scheduling "
"priority (B<pthread_attr_setschedparam>(3)), and contention scope "
"(B<pthread_attr_setscope>(3))."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setinheritsched.3:67
msgid "The following values may be specified in I<inheritsched>:"
msgstr ""

#. type: TP
#: build/C/man3/pthread_attr_setinheritsched.3:67
#, no-wrap
msgid "B<PTHREAD_INHERIT_SCHED>"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setinheritsched.3:75
msgid ""
"Threads that are created using I<attr> inherit scheduling attributes from "
"the creating thread; the scheduling attributes in I<attr> are ignored."
msgstr ""

#. type: TP
#: build/C/man3/pthread_attr_setinheritsched.3:75
#, no-wrap
msgid "B<PTHREAD_EXPLICIT_SCHED>"
msgstr ""

#.  FIXME Document the defaults for scheduler settings
#. type: Plain text
#: build/C/man3/pthread_attr_setinheritsched.3:82
msgid ""
"Threads that are created using I<attr> take their scheduling attributes from "
"the values specified by the attributes object."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setinheritsched.3:86
msgid ""
"The default setting of the inherit-scheduler attribute in a newly "
"initialized thread attributes object is B<PTHREAD_INHERIT_SCHED>."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setinheritsched.3:93
msgid ""
"The B<pthread_attr_getinheritsched>()  returns the inherit-scheduler "
"attribute of the thread attributes object I<attr> in the buffer pointed to "
"by I<inheritsched>."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setinheritsched.3:99
msgid "B<pthread_attr_setinheritsched>()  can fail with the following error:"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setinheritsched.3:103
msgid "Invalid value in I<inheritsched>."
msgstr ""

#.  .SH VERSIONS
#.  Available since glibc 2.0.
#. type: Plain text
#: build/C/man3/pthread_attr_setinheritsched.3:110
msgid ""
"POSIX.1 also documents an optional B<ENOTSUP> error (\"attempt was made to "
"set the attribute to an unsupported value\") for "
"B<pthread_attr_setinheritsched>()."
msgstr ""

#. type: tbl table
#: build/C/man3/pthread_attr_setinheritsched.3:121
#, no-wrap
msgid ""
"B<pthread_attr_setinheritsched>(),\n"
"B<pthread_attr_getinheritsched>()"
msgstr ""

#.  FIXME . Track status of the following bug:
#.  http://sourceware.org/bugzilla/show_bug.cgi?id=7007
#. type: Plain text
#: build/C/man3/pthread_attr_setinheritsched.3:141
msgid ""
"As at glibc 2.8, if a thread attributes object is initialized using "
"B<pthread_attr_init>(3), then the scheduling policy of the attributes object "
"is set to B<SCHED_OTHER> and the scheduling priority is set to 0.  However, "
"if the inherit-scheduler attribute is then set to B<PTHREAD_EXPLICIT_SCHED>, "
"then a thread created using the attribute object wrongly inherits its "
"scheduling attributes from the creating thread.  This bug does not occur if "
"either the scheduling policy or scheduling priority attribute is explicitly "
"set in the thread attributes object before calling B<pthread_create>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setinheritsched.3:144 build/C/man3/pthread_attr_setschedparam.3:129 build/C/man3/pthread_attr_setschedpolicy.3:118
msgid "See B<pthread_setschedparam>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setinheritsched.3:156
msgid ""
"B<pthread_attr_init>(3), B<pthread_attr_setschedparam>(3), "
"B<pthread_attr_setschedpolicy>(3), B<pthread_attr_setscope>(3), "
"B<pthread_create>(3), B<pthread_setschedparam>(3), "
"B<pthread_setschedprio>(3), B<pthreads>(7), B<sched>(7)"
msgstr ""

#. type: TH
#: build/C/man3/pthread_attr_setschedparam.3:26
#, no-wrap
msgid "PTHREAD_ATTR_SETSCHEDPARAM"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setschedparam.3:30
msgid ""
"pthread_attr_setschedparam, pthread_attr_getschedparam - set/get scheduling "
"parameter attributes in thread attributes object"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setschedparam.3:38
#, no-wrap
msgid ""
"B<int pthread_attr_setschedparam(pthread_attr_t *>I<attr>B<,>\n"
"B<                               const struct sched_param *>I<param>B<);>\n"
"B<int pthread_attr_getschedparam(const pthread_attr_t *>I<attr>B<,>\n"
"B<                               struct sched_param *>I<param>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setschedparam.3:52
msgid ""
"The B<pthread_attr_setschedparam>()  function sets the scheduling parameter "
"attributes of the thread attributes object referred to by I<attr> to the "
"values specified in the buffer pointed to by I<param>.  These attributes "
"determine the scheduling parameters of a thread created using the thread "
"attributes object I<attr>."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setschedparam.3:59
msgid ""
"The B<pthread_attr_getschedparam>()  returns the scheduling parameter "
"attributes of the thread attributes object I<attr> in the buffer pointed to "
"by I<param>."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setschedparam.3:61
msgid "Scheduling parameters are maintained in the following structure:"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setschedparam.3:67 build/C/man3/pthread_setschedparam.3:69
#, no-wrap
msgid ""
"struct sched_param {\n"
"    int sched_priority;     /* Scheduling priority */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setschedparam.3:74 build/C/man3/pthread_setschedparam.3:76
msgid ""
"As can be seen, only one scheduling parameter is supported.  For details of "
"the permitted ranges for scheduling priorities in each scheduling policy, "
"see B<sched>(7)."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setschedparam.3:85
msgid ""
"In order for the parameter setting made by B<pthread_attr_setschedparam>()  "
"to have effect when calling B<pthread_create>(3), the caller must use "
"B<pthread_attr_setinheritsched>(3)  to set the inherit-scheduler attribute "
"of the attributes object I<attr> to B<PTHREAD_EXPLICIT_SCHED>."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setschedparam.3:91
msgid "B<pthread_attr_setschedparam>()  can fail with the following error:"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setschedparam.3:97
msgid ""
"The priority specified in I<param> does not make sense for the current "
"scheduling policy of I<attr>."
msgstr ""

#.  .SH VERSIONS
#.  Available since glibc 2.0.
#. type: Plain text
#: build/C/man3/pthread_attr_setschedparam.3:107
msgid ""
"POSIX.1 also documents an B<ENOTSUP> error for "
"B<pthread_attr_setschedparam>().  This value is never returned on Linux (but "
"portable and future-proof applications should nevertheless handle this error "
"return value)."
msgstr ""

#. type: tbl table
#: build/C/man3/pthread_attr_setschedparam.3:118
#, no-wrap
msgid ""
"B<pthread_attr_setschedparam>(),\n"
"B<pthread_attr_getschedparam>()"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setschedparam.3:126
msgid ""
"See B<pthread_attr_setschedpolicy>(3)  for a list of the thread scheduling "
"policies supported on Linux."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setschedparam.3:141
msgid ""
"B<sched_get_priority_min>(2), B<pthread_attr_init>(3), "
"B<pthread_attr_setinheritsched>(3), B<pthread_attr_setschedpolicy>(3), "
"B<pthread_create>(3), B<pthread_setschedparam>(3), "
"B<pthread_setschedprio>(3), B<pthreads>(7), B<sched>(7)"
msgstr ""

#. type: TH
#: build/C/man3/pthread_attr_setschedpolicy.3:26
#, no-wrap
msgid "PTHREAD_ATTR_SETSCHEDPOLICY"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setschedpolicy.3:30
msgid ""
"pthread_attr_setschedpolicy, pthread_attr_getschedpolicy - set/get "
"scheduling policy attribute in thread attributes object"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setschedpolicy.3:38
#, no-wrap
msgid ""
"B<int pthread_attr_setschedpolicy(pthread_attr_t *>I<attr>B<, int "
">I<policy>B<);>\n"
"B<int pthread_attr_getschedpolicy(const pthread_attr_t *>I<attr>B<, int "
">I<*policy>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setschedpolicy.3:52
msgid ""
"The B<pthread_attr_setschedpolicy>()  function sets the scheduling policy "
"attribute of the thread attributes object referred to by I<attr> to the "
"value specified in I<policy>.  This attribute determines the scheduling "
"policy of a thread created using the thread attributes object I<attr>."
msgstr ""

#.  FIXME . pthread_setschedparam() places no restriction on the policy,
#.  but pthread_attr_setschedpolicy() restricts policy to RR/FIFO/OTHER
#.  http://sourceware.org/bugzilla/show_bug.cgi?id=7013
#. type: Plain text
#: build/C/man3/pthread_attr_setschedpolicy.3:65
msgid ""
"The supported values for I<policy> are B<SCHED_FIFO>, B<SCHED_RR>, and "
"B<SCHED_OTHER>, with the semantics described in B<sched>(7)."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setschedpolicy.3:72
msgid ""
"The B<pthread_attr_getschedpolicy>()  returns the scheduling policy "
"attribute of the thread attributes object I<attr> in the buffer pointed to "
"by I<policy>."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setschedpolicy.3:83
msgid ""
"In order for the policy setting made by B<pthread_attr_setschedpolicy>()  to "
"have effect when calling B<pthread_create>(3), the caller must use "
"B<pthread_attr_setinheritsched>(3)  to set the inherit-scheduler attribute "
"of the attributes object I<attr> to B<PTHREAD_EXPLICIT_SCHED>."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setschedpolicy.3:89
msgid "B<pthread_attr_setschedpolicy>()  can fail with the following error:"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setschedpolicy.3:93
msgid "Invalid value in I<policy>."
msgstr ""

#.  .SH VERSIONS
#.  Available since glibc 2.0.
#. type: Plain text
#: build/C/man3/pthread_attr_setschedpolicy.3:100
msgid ""
"POSIX.1 also documents an optional B<ENOTSUP> error (\"attempt was made to "
"set the attribute to an unsupported value\") for "
"B<pthread_attr_setschedpolicy>()."
msgstr ""

#. type: tbl table
#: build/C/man3/pthread_attr_setschedpolicy.3:111
#, no-wrap
msgid ""
"B<pthread_attr_setschedpolicy>(),\n"
"B<pthread_attr_getschedpolicy>()"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setschedpolicy.3:129
msgid ""
"B<pthread_attr_init>(3), B<pthread_attr_setinheritsched>(3), "
"B<pthread_attr_setschedparam>(3), B<pthread_create>(3), "
"B<pthread_setschedparam>(3), B<pthread_setschedprio>(3), B<pthreads>(7), "
"B<sched>(7)"
msgstr ""

#. type: TH
#: build/C/man3/pthread_attr_setscope.3:26
#, no-wrap
msgid "PTHREAD_ATTR_SETSCOPE"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setscope.3:30
msgid ""
"pthread_attr_setscope, pthread_attr_getscope - set/get contention scope "
"attribute in thread attributes object"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setscope.3:38
#, no-wrap
msgid ""
"B<int pthread_attr_setscope(pthread_attr_t *>I<attr>B<, int >I<scope>B<);>\n"
"B<int pthread_attr_getscope(const pthread_attr_t *>I<attr>B<, int "
"*>I<scope>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setscope.3:53
msgid ""
"The B<pthread_attr_setscope>()  function sets the contention scope attribute "
"of the thread attributes object referred to by I<attr> to the value "
"specified in I<scope>.  The contention scope attribute defines the set of "
"threads against which a thread competes for resources such as the CPU.  "
"POSIX.1 specifies two possible values for I<scope>:"
msgstr ""

#. type: TP
#: build/C/man3/pthread_attr_setscope.3:53
#, no-wrap
msgid "B<PTHREAD_SCOPE_SYSTEM>"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setscope.3:61
msgid ""
"The thread competes for resources with all other threads in all processes on "
"the system that are in the same scheduling allocation domain (a group of one "
"or more processors).  B<PTHREAD_SCOPE_SYSTEM> threads are scheduled relative "
"to one another according to their scheduling policy and priority."
msgstr ""

#. type: TP
#: build/C/man3/pthread_attr_setscope.3:61
#, no-wrap
msgid "B<PTHREAD_SCOPE_PROCESS>"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setscope.3:76
msgid ""
"The thread competes for resources with all other threads in the same process "
"that were also created with the B<PTHREAD_SCOPE_PROCESS> contention scope.  "
"B<PTHREAD_SCOPE_PROCESS> threads are scheduled relative to other threads in "
"the process according to their scheduling policy and priority.  POSIX.1 "
"leaves it unspecified how these threads contend with other threads in other "
"process on the system or with other threads in the same process that were "
"created with the B<PTHREAD_SCOPE_SYSTEM> contention scope."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setscope.3:83
msgid ""
"POSIX.1 requires that an implementation support at least one of these "
"contention scopes.  Linux supports B<PTHREAD_SCOPE_SYSTEM>, but not "
"B<PTHREAD_SCOPE_PROCESS>."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setscope.3:95
msgid ""
"On systems that support multiple contention scopes, then, in order for the "
"parameter setting made by B<pthread_attr_setscope>()  to have effect when "
"calling B<pthread_create>(3), the caller must use "
"B<pthread_attr_setinheritsched>(3)  to set the inherit-scheduler attribute "
"of the attributes object I<attr> to B<PTHREAD_EXPLICIT_SCHED>."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setscope.3:103
msgid ""
"The B<pthread_attr_getscope>()  function returns the contention scope "
"attribute of the thread attributes object referred to by I<attr> in the "
"buffer pointed to by I<scope>."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setscope.3:109
msgid "B<pthread_attr_setscope>()  can fail with the following errors:"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setscope.3:113
msgid "An invalid value was specified in I<scope>."
msgstr ""

#. type: TP
#: build/C/man3/pthread_attr_setscope.3:113 build/C/man3/pthread_mutexattr_getpshared.3:87
#, no-wrap
msgid "B<ENOTSUP>"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setscope.3:119
msgid ""
"I<scope> specified the value B<PTHREAD_SCOPE_PROCESS>, which is not "
"supported on Linux."
msgstr ""

#. type: tbl table
#: build/C/man3/pthread_attr_setscope.3:130
#, no-wrap
msgid ""
"B<pthread_attr_setscope>(),\n"
"B<pthread_attr_getscope>()"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setscope.3:142
msgid ""
"The B<PTHREAD_SCOPE_SYSTEM> contention scope typically indicates that a "
"user-space thread is bound directly to a single kernel-scheduling entity.  "
"This is the case on Linux for the obsolete LinuxThreads implementation and "
"the modern NPTL implementation, which are both 1:1 threading "
"implementations."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setscope.3:145
msgid ""
"POSIX.1 specifies that the default contention scope is "
"implementation-defined."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setscope.3:155
msgid ""
"B<pthread_attr_init>(3), B<pthread_attr_setaffinity_np>(3), "
"B<pthread_attr_setinheritsched>(3), B<pthread_attr_setschedparam>(3), "
"B<pthread_attr_setschedpolicy>(3), B<pthread_create>(3), B<pthreads>(7)"
msgstr ""

#. type: TH
#: build/C/man3/pthread_attr_setstack.3:26
#, no-wrap
msgid "PTHREAD_ATTR_SETSTACK"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setstack.3:30
msgid ""
"pthread_attr_setstack, pthread_attr_getstack - set/get stack attributes in "
"thread attributes object"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setstack.3:38
#, no-wrap
msgid ""
"B<int pthread_attr_setstack(pthread_attr_t *>I<attr>B<,>\n"
"B<                          void *>I<stackaddr>B<, size_t "
">I<stacksize>B<);>\n"
"B<int pthread_attr_getstack(const pthread_attr_t *>I<attr>B<,>\n"
"B<                          void **>I<stackaddr>B<, size_t "
"*>I<stacksize>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setstack.3:45 build/C/man3/pthread_cleanup_push_defer_np.3:44 build/C/man3/pthread_kill.3:41 build/C/man3/pthread_rwlockattr_setkind_np.3:44 build/C/man3/pthread_sigmask.3:42 build/C/man3/pthread_sigqueue.3:42 build/C/man3/pthread_mutex_consistent.3:41 build/C/man3/pthread_mutexattr_setrobust.3:45 build/C/man3/pthread_spin_init.3:41 build/C/man3/pthread_spin_lock.3:43
msgid "Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setstack.3:50
msgid "B<pthread_attr_getstack>(), B<pthread_attr_setstack>():"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setstack.3:52
msgid "_POSIX_C_SOURCE\\ E<gt>=\\ 200112L"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setstack.3:68
msgid ""
"The B<pthread_attr_setstack>()  function sets the stack address and stack "
"size attributes of the thread attributes object referred to by I<attr> to "
"the values specified in I<stackaddr> and I<stacksize>, respectively.  These "
"attributes specify the location and size of the stack that should be used by "
"a thread that is created using the thread attributes object I<attr>."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setstack.3:74
msgid ""
"I<stackaddr> should point to the lowest addressable byte of a buffer of "
"I<stacksize> bytes that was allocated by the caller.  The pages of the "
"allocated buffer should be both readable and writable."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setstack.3:85
msgid ""
"The B<pthread_attr_getstack>()  function returns the stack address and stack "
"size attributes of the thread attributes object referred to by I<attr> in "
"the buffers pointed to by I<stackaddr> and I<stacksize>, respectively."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setstack.3:91
msgid "B<pthread_attr_setstack>()  can fail with the following error:"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setstack.3:102
msgid ""
"I<stacksize> is less than B<PTHREAD_STACK_MIN> (16384) bytes.  On some "
"systems, this error may also occur if I<stackaddr> or I<stackaddr\\ +\\ "
"stacksize> is not suitably aligned."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setstack.3:110
msgid ""
"POSIX.1 also documents an B<EACCES> error if the stack area described by "
"I<stackaddr> and I<stacksize> is not both readable and writable by the "
"caller."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setstack.3:112
msgid "These functions are provided by glibc since version 2.2."
msgstr ""

#. type: tbl table
#: build/C/man3/pthread_attr_setstack.3:123
#, no-wrap
msgid ""
"B<pthread_attr_setstack>(),\n"
"B<pthread_attr_getstack>()"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setstack.3:135
msgid ""
"These functions are provided for applications that must ensure that a "
"thread's stack is placed in a particular location.  For most applications, "
"this is not necessary, and the use of these functions should be avoided.  "
"(Use B<pthread_attr_setstacksize>(3)  if an application simply requires a "
"stack size other than the default.)"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setstack.3:146
msgid ""
"When an application employs B<pthread_attr_setstack>(), it takes over the "
"responsibility of allocating the stack.  Any guard size value that was set "
"using B<pthread_attr_setguardsize>(3)  is ignored.  If deemed necessary, it "
"is the application's responsibility to allocate a guard area (one or more "
"pages protected against reading and writing)  to handle the possibility of "
"stack overflow."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setstack.3:157
msgid ""
"The address specified in I<stackaddr> should be suitably aligned: for full "
"portability, align it on a page boundary (I<sysconf(_SC_PAGESIZE)>).  "
"B<posix_memalign>(3)  may be useful for allocation.  Probably, I<stacksize> "
"should also be a multiple of the system page size."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setstack.3:165
msgid ""
"If I<attr> is used to create multiple threads, then the caller must change "
"the stack address attribute between calls to B<pthread_create>(3); "
"otherwise, the threads will attempt to use the same memory area for their "
"stacks, and chaos will ensue."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setstack.3:180
msgid ""
"B<mmap>(2), B<mprotect>(2), B<posix_memalign>(3), B<pthread_attr_init>(3), "
"B<pthread_attr_setguardsize>(3), B<pthread_attr_setstackaddr>(3), "
"B<pthread_attr_setstacksize>(3), B<pthread_create>(3), B<pthreads>(7)"
msgstr ""

#. type: TH
#: build/C/man3/pthread_attr_setstackaddr.3:26
#, no-wrap
msgid "PTHREAD_ATTR_SETSTACKADDR"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setstackaddr.3:30
msgid ""
"pthread_attr_setstackaddr, pthread_attr_getstackaddr - set/get stack address "
"attribute in thread attributes object"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setstackaddr.3:38
#, no-wrap
msgid ""
"B<int pthread_attr_setstackaddr(pthread_attr_t *>I<attr>B<, void "
"*>I<stackaddr>B<);>\n"
"B<int pthread_attr_getstackaddr(const pthread_attr_t *>I<attr>B<,>\n"
"B<                              void **>I<stackaddr>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setstackaddr.3:49
msgid ""
"These functions are obsolete: B<do not use them.> Use "
"B<pthread_attr_setstack>(3)  and B<pthread_attr_getstack>(3)  instead."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setstackaddr.3:60
msgid ""
"The B<pthread_attr_setstackaddr>()  function sets the stack address "
"attribute of the thread attributes object referred to by I<attr> to the "
"value specified in I<stackaddr>.  This attribute specifies the location of "
"the stack that should be used by a thread that is created using the thread "
"attributes object I<attr>."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setstackaddr.3:66
msgid ""
"I<stackaddr> should point to a buffer of at least B<PTHREAD_STACK_MIN> bytes "
"that was allocated by the caller.  The pages of the allocated buffer should "
"be both readable and writable."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setstackaddr.3:74
msgid ""
"The B<pthread_attr_getstackaddr>()  function returns the stack address "
"attribute of the thread attributes object referred to by I<attr> in the "
"buffer pointed to by I<stackaddr>."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setstackaddr.3:81
msgid ""
"No errors are defined (but applications should nevertheless handle a "
"possible error return)."
msgstr ""

#. type: tbl table
#: build/C/man3/pthread_attr_setstackaddr.3:94
#, no-wrap
msgid ""
"B<pthread_attr_setstackaddr>(),\n"
"B<pthread_attr_getstackaddr>()"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setstackaddr.3:99
msgid ""
"POSIX.1-2001 specifies these functions but marks them as obsolete.  "
"POSIX.1-2008 removes the specification of these functions."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setstackaddr.3:123
msgid ""
"I<Do not use these functions!> They cannot be portably used, since they "
"provide no way of specifying the direction of growth or the range of the "
"stack.  For example, on architectures with a stack that grows downward, "
"I<stackaddr> specifies the next address past the I<highest> address of the "
"allocated stack area.  However, on architectures with a stack that grows "
"upward, I<stackaddr> specifies the I<lowest> address in the allocated stack "
"area.  By contrast, the I<stackaddr> used by B<pthread_attr_setstack>(3)  "
"and B<pthread_attr_getstack>(3), is always a pointer to the lowest address "
"in the allocated stack area (and the I<stacksize> argument specifies the "
"range of the stack)."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setstackaddr.3:129
msgid ""
"B<pthread_attr_init>(3), B<pthread_attr_setstack>(3), "
"B<pthread_attr_setstacksize>(3), B<pthread_create>(3), B<pthreads>(7)"
msgstr ""

#. type: TH
#: build/C/man3/pthread_attr_setstacksize.3:26
#, no-wrap
msgid "PTHREAD_ATTR_SETSTACKSIZE"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setstacksize.3:30
msgid ""
"pthread_attr_setstacksize, pthread_attr_getstacksize - set/get stack size "
"attribute in thread attributes object"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setstacksize.3:38
#, no-wrap
msgid ""
"B<int pthread_attr_setstacksize(pthread_attr_t *>I<attr>B<, size_t "
">I<stacksize>B<);>\n"
"B<int pthread_attr_getstacksize(const pthread_attr_t *>I<attr>B<,>\n"
"B<                              size_t *>I<stacksize>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setstacksize.3:49
msgid ""
"The B<pthread_attr_setstacksize>()  function sets the stack size attribute "
"of the thread attributes object referred to by I<attr> to the value "
"specified in I<stacksize>."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setstacksize.3:53
msgid ""
"The stack size attribute determines the minimum size (in bytes) that will be "
"allocated for threads created using the thread attributes object I<attr>."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setstacksize.3:61
msgid ""
"The B<pthread_attr_getstacksize>()  function returns the stack size "
"attribute of the thread attributes object referred to by I<attr> in the "
"buffer pointed to by I<stacksize>."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setstacksize.3:67
msgid "B<pthread_attr_setstacksize>()  can fail with the following error:"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setstacksize.3:72
msgid "The stack size is less than B<PTHREAD_STACK_MIN> (16384) bytes."
msgstr ""

#.  e.g., MacOS
#. type: Plain text
#: build/C/man3/pthread_attr_setstacksize.3:81
msgid ""
"On some systems, B<pthread_attr_setstacksize>()  can fail with the error "
"B<EINVAL> if I<stacksize> is not a multiple of the system page size."
msgstr ""

#. type: tbl table
#: build/C/man3/pthread_attr_setstacksize.3:94
#, no-wrap
msgid ""
"B<pthread_attr_setstacksize>(),\n"
"B<pthread_attr_getstacksize>()"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setstacksize.3:101
msgid ""
"For details on the default stack size of new threads, see "
"B<pthread_create>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setstacksize.3:104
msgid ""
"A thread's stack size is fixed at the time of thread creation.  Only the "
"main thread can dynamically grow its stack."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setstacksize.3:109
msgid ""
"The B<pthread_attr_setstack>(3)  function allows an application to set both "
"the size and location of a caller-allocated stack that is to be used by a "
"thread."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setstacksize.3:121
msgid ""
"As at glibc 2.8, if the specified I<stacksize> is not a multiple of "
"B<STACK_ALIGN> (16 bytes on most architectures), it may be rounded "
"I<downward>, in violation of POSIX.1, which says that the allocated stack "
"will be at least I<stacksize> bytes."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setstacksize.3:124 build/C/man3/pthread_join.3:143
msgid "See B<pthread_create>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setstacksize.3:131
msgid ""
"B<getrlimit>(2), B<pthread_attr_init>(3), B<pthread_attr_setguardsize>(3), "
"B<pthread_attr_setstack>(3), B<pthread_create>(3), B<pthreads>(7)"
msgstr ""

#. type: TH
#: build/C/man3/pthread_cancel.3:26
#, no-wrap
msgid "PTHREAD_CANCEL"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cancel.3:29
msgid "pthread_cancel - send a cancellation request to a thread"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cancel.3:34
#, no-wrap
msgid "B<int pthread_cancel(pthread_t >I<thread>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cancel.3:49
msgid ""
"The B<pthread_cancel>()  function sends a cancellation request to the thread "
"I<thread>.  Whether and when the target thread reacts to the cancellation "
"request depends on two attributes that are under the control of that thread: "
"its cancelability I<state> and I<type>."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cancel.3:61
msgid ""
"A thread's cancelability state, determined by B<pthread_setcancelstate>(3), "
"can be I<enabled> (the default for new threads) or I<disabled>.  If a thread "
"has disabled cancellation, then a cancellation request remains queued until "
"the thread enables cancellation.  If a thread has enabled cancellation, then "
"its cancelability type determines when cancellation occurs."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cancel.3:77
msgid ""
"A thread's cancellation type, determined by B<pthread_setcanceltype>(3), may "
"be either I<asynchronous> or I<deferred> (the default for new threads).  "
"Asynchronous cancelability means that the thread can be canceled at any time "
"(usually immediately, but the system does not guarantee this).  Deferred "
"cancelability means that cancellation will be delayed until the thread next "
"calls a function that is a I<cancellation point>.  A list of functions that "
"are or may be cancellation points is provided in B<pthreads>(7)."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cancel.3:81
msgid ""
"When a cancellation requested is acted on, the following steps occur for "
"I<thread> (in this order):"
msgstr ""

#. type: IP
#: build/C/man3/pthread_cancel.3:81 build/C/man3/pthread_cleanup_push.3:69
#, no-wrap
msgid "1."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cancel.3:86
msgid ""
"Cancellation clean-up handlers are popped (in the reverse of the order in "
"which they were pushed) and called.  (See B<pthread_cleanup_push>(3).)"
msgstr ""

#. type: IP
#: build/C/man3/pthread_cancel.3:86 build/C/man3/pthread_cleanup_push.3:73
#, no-wrap
msgid "2."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cancel.3:91
msgid ""
"Thread-specific data destructors are called, in an unspecified order.  (See "
"B<pthread_key_create>(3).)"
msgstr ""

#. type: IP
#: build/C/man3/pthread_cancel.3:91 build/C/man3/pthread_cleanup_push.3:83
#, no-wrap
msgid "3."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cancel.3:95
msgid "The thread is terminated.  (See B<pthread_exit>(3).)"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cancel.3:103
msgid ""
"The above steps happen asynchronously with respect to the "
"B<pthread_cancel>()  call; the return status of B<pthread_cancel>()  merely "
"informs the caller whether the cancellation request was successfully queued."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cancel.3:112
msgid ""
"After a canceled thread has terminated, a join with that thread using "
"B<pthread_join>(3)  obtains B<PTHREAD_CANCELED> as the thread's exit "
"status.  (Joining with a thread is the only way to know that cancellation "
"has completed.)"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cancel.3:117
msgid ""
"On success, B<pthread_cancel>()  returns 0; on error, it returns a nonzero "
"error number."
msgstr ""

#. type: TP
#: build/C/man3/pthread_cancel.3:118 build/C/man3/pthread_detach.3:59 build/C/man3/pthread_getcpuclockid.3:61 build/C/man3/pthread_join.3:93 build/C/man3/pthread_setaffinity_np.3:110 build/C/man3/pthread_setschedparam.3:114 build/C/man3/pthread_setschedprio.3:70 build/C/man3/pthread_sigqueue.3:86
#, no-wrap
msgid "B<ESRCH>"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cancel.3:125 build/C/man3/pthread_detach.3:64 build/C/man3/pthread_getcpuclockid.3:66 build/C/man3/pthread_join.3:98 build/C/man3/pthread_setaffinity_np.3:115 build/C/man3/pthread_setschedparam.3:119 build/C/man3/pthread_setschedprio.3:75
msgid "No thread with the ID I<thread> could be found."
msgstr ""

#. type: tbl table
#: build/C/man3/pthread_cancel.3:135
#, no-wrap
msgid "B<pthread_cancel>()"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cancel.3:148
msgid ""
"On Linux, cancellation is implemented using signals.  Under the NPTL "
"threading implementation, the first real-time signal (i.e., signal 32) is "
"used for this purpose.  On LinuxThreads, the second real-time signal is "
"used, if real-time signals are available, otherwise B<SIGUSR2> is used."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cancel.3:154
msgid ""
"The program below creates a thread and then cancels it.  The main thread "
"joins with the canceled thread to check that its exit status was "
"B<PTHREAD_CANCELED>.  The following shell session shows what happens when we "
"run the program:"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cancel.3:162
#, no-wrap
msgid ""
"$ ./a.out\n"
"thread_func(): started; cancellation disabled\n"
"main(): sending cancellation request\n"
"thread_func(): about to enable cancellation\n"
"main(): thread was canceled\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cancel.3:172
#, no-wrap
msgid ""
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cancel.3:180
#, no-wrap
msgid ""
"static void *\n"
"thread_func(void *ignored_argument)\n"
"{\n"
"    int s;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cancel.3:183
#, no-wrap
msgid ""
"    /* Disable cancellation for a while, so that we don\\(aqt\n"
"       immediately react to a cancellation request */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cancel.3:187
#, no-wrap
msgid ""
"    s = pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_setcancelstate\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cancel.3:191
#, no-wrap
msgid ""
"    printf(\"thread_func(): started; cancellation disabled\\en\");\n"
"    sleep(5);\n"
"    printf(\"thread_func(): about to enable cancellation\\en\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cancel.3:195
#, no-wrap
msgid ""
"    s = pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_setcancelstate\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cancel.3:197
#, no-wrap
msgid "    /* sleep() is a cancellation point */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cancel.3:199
#, no-wrap
msgid "    sleep(1000);        /* Should get canceled while we sleep */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cancel.3:201
#, no-wrap
msgid "    /* Should never get here */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cancel.3:205
#, no-wrap
msgid ""
"    printf(\"thread_func(): not canceled!\\en\");\n"
"    return NULL;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cancel.3:212
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    pthread_t thr;\n"
"    void *res;\n"
"    int s;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cancel.3:214
#, no-wrap
msgid "    /* Start a thread and then send it a cancellation request */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cancel.3:218
#, no-wrap
msgid ""
"    s = pthread_create(&thr, NULL, &thread_func, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_create\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cancel.3:220
#, no-wrap
msgid "    sleep(2);           /* Give thread a chance to get started */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cancel.3:225
#, no-wrap
msgid ""
"    printf(\"main(): sending cancellation request\\en\");\n"
"    s = pthread_cancel(thr);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_cancel\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cancel.3:227
#, no-wrap
msgid "    /* Join with thread to see what its exit status was */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cancel.3:231 build/C/man3/pthread_cleanup_push.3:321
#, no-wrap
msgid ""
"    s = pthread_join(thr, &res);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_join\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cancel.3:238
#, no-wrap
msgid ""
"    if (res == PTHREAD_CANCELED)\n"
"        printf(\"main(): thread was canceled\\en\");\n"
"    else\n"
"        printf(\"main(): thread wasn\\(aqt canceled (shouldn\\(aqt "
"happen!)\\en\");\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cancel.3:251
msgid ""
"B<pthread_cleanup_push>(3), B<pthread_create>(3), B<pthread_exit>(3), "
"B<pthread_join>(3), B<pthread_key_create>(3), B<pthread_setcancelstate>(3), "
"B<pthread_setcanceltype>(3), B<pthread_testcancel>(3), B<pthreads>(7)"
msgstr ""

#. type: TH
#: build/C/man3/pthread_cleanup_push.3:26
#, no-wrap
msgid "PTHREAD_CLEANUP_PUSH"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:30
msgid ""
"pthread_cleanup_push, pthread_cleanup_pop - push and pop thread cancellation "
"clean-up handlers"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:37
#, no-wrap
msgid ""
"B<void pthread_cleanup_push(void (*>I<routine>B<)(void *),>\n"
"B<                          void *>I<arg>B<);>\n"
"B<void pthread_cleanup_pop(int >I<execute>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:48
msgid ""
"These functions manipulate the calling thread's stack of thread-cancellation "
"clean-up handlers.  A clean-up handler is a function that is automatically "
"executed when a thread is canceled (or in various other circumstances "
"described below); it might, for example, unlock a mutex so that it becomes "
"available to other threads in the process."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:59
msgid ""
"The B<pthread_cleanup_push>()  function pushes I<routine> onto the top of "
"the stack of clean-up handlers.  When I<routine> is later invoked, it will "
"be given I<arg> as its argument."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:66
msgid ""
"The B<pthread_cleanup_pop>()  function removes the routine at the top of the "
"stack of clean-up handlers, and optionally executes it if I<execute> is "
"nonzero."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:69
msgid ""
"A cancellation clean-up handler is popped from the stack and executed in the "
"following circumstances:"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:73
msgid ""
"When a thread is canceled, all of the stacked clean-up handlers are popped "
"and executed in the reverse of the order in which they were pushed onto the "
"stack."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:83
msgid ""
"When a thread terminates by calling B<pthread_exit>(3), all clean-up "
"handlers are executed as described in the preceding point.  (Clean-up "
"handlers are I<not> called if the thread terminates by performing a "
"I<return> from the thread start function.)"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:89
msgid ""
"When a thread calls B<pthread_cleanup_pop>()  with a nonzero I<execute> "
"argument, the top-most clean-up handler is popped and executed."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:101
msgid ""
"POSIX.1 permits B<pthread_cleanup_push>()  and B<pthread_cleanup_pop>()  to "
"be implemented as macros that expand to text containing \\(aqB<{>\\(aq and "
"\\(aqB<}>\\(aq, respectively.  For this reason, the caller must ensure that "
"calls to these functions are paired within the same function, and at the "
"same lexical nesting level.  (In other words, a clean-up handler is "
"established only during the execution of a specified section of code.)"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:121
msgid ""
"Calling B<longjmp>(3)  (B<siglongjmp>(3))  produces undefined results if any "
"call has been made to B<pthread_cleanup_push>()  or B<pthread_cleanup_pop>()  "
"without the matching call of the pair since the jump buffer was filled by "
"B<setjmp>(3)  (B<sigsetjmp>(3)).  Likewise, calling B<longjmp>(3)  "
"(B<siglongjmp>(3))  from inside a clean-up handler produces undefined "
"results unless the jump buffer was also filled by B<setjmp>(3)  "
"(B<sigsetjmp>(3))  inside the handler."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:123
msgid "These functions do not return a value."
msgstr ""

#.  SH VERSIONS
#.  Available since glibc 2.0
#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:127
msgid "There are no errors."
msgstr ""

#. type: tbl table
#: build/C/man3/pthread_cleanup_push.3:138
#, no-wrap
msgid ""
"B<pthread_cleanup_push>(),\n"
"B<pthread_cleanup_pop>()"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:154
msgid ""
"On Linux, the B<pthread_cleanup_push>()  and B<pthread_cleanup_pop>()  "
"functions I<are> implemented as macros that expand to text containing "
"\\(aqB<{>\\(aq and \\(aqB<}>\\(aq, respectively.  This means that variables "
"declared within the scope of paired calls to these functions will be visible "
"within only that scope."
msgstr ""

#.  The text was actually added in the 2004 TC2
#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:169
msgid ""
"POSIX.1 says that the effect of using I<return>, I<break>, I<continue>, or "
"I<goto> to prematurely leave a block bracketed B<pthread_cleanup_push>()  "
"and B<pthread_cleanup_pop>()  is undefined.  Portable applications should "
"avoid doing this."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:184
msgid ""
"The program below provides a simple example of the use of the functions "
"described in this page.  The program creates a thread that executes a loop "
"bracketed by B<pthread_cleanup_push>()  and B<pthread_cleanup_pop>().  This "
"loop increments a global variable, I<cnt>, once each second.  Depending on "
"what command-line arguments are supplied, the main thread sends the other "
"thread a cancellation request, or sets a global variable that causes the "
"other thread to exit its loop and terminate normally (by doing a I<return>)."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:187
msgid ""
"In the following shell session, the main thread sends a cancellation request "
"to the other thread:"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:197
#, no-wrap
msgid ""
"$ B<./a.out>\n"
"New thread started\n"
"cnt = 0\n"
"cnt = 1\n"
"Canceling thread\n"
"Called clean-up handler\n"
"Thread was canceled; cnt = 0\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:205
msgid ""
"From the above, we see that the thread was canceled, and that the "
"cancellation clean-up handler was called and it reset the value of the "
"global variable I<cnt> to 0."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:208
msgid ""
"In the next run, the main program sets a global variable that causes other "
"thread to terminate normally:"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:216
#, no-wrap
msgid ""
"$ B<./a.out x>\n"
"New thread started\n"
"cnt = 0\n"
"cnt = 1\n"
"Thread terminated normally; cnt = 2\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:224
msgid ""
"From the above, we see that the clean-up handler was not executed (because "
"I<cleanup_pop_arg> was 0), and therefore the value of I<cnt> was not reset."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:229
msgid ""
"In the next run, the main program sets a global variable that causes the "
"other thread to terminate normally, and supplies a nonzero value for "
"I<cleanup_pop_arg>:"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:238
#, no-wrap
msgid ""
"$ B<./a.out x 1>\n"
"New thread started\n"
"cnt = 0\n"
"cnt = 1\n"
"Called clean-up handler\n"
"Thread terminated normally; cnt = 0\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:245
msgid ""
"In the above, we see that although the thread was not canceled, the clean-up "
"handler was executed, because the argument given to B<pthread_cleanup_pop>()  "
"was nonzero."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:254
#, no-wrap
msgid ""
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:261
#, no-wrap
msgid ""
"static int done = 0;\n"
"static int cleanup_pop_arg = 0;\n"
"static int cnt = 0;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:268
#, no-wrap
msgid ""
"static void\n"
"cleanup_handler(void *arg)\n"
"{\n"
"    printf(\"Called clean-up handler\\en\");\n"
"    cnt = 0;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:273
#, no-wrap
msgid ""
"static void *\n"
"thread_start(void *arg)\n"
"{\n"
"    time_t start, curr;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:275
#, no-wrap
msgid "    printf(\"New thread started\\en\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:277
#, no-wrap
msgid "    pthread_cleanup_push(cleanup_handler, NULL);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:279
#, no-wrap
msgid "    curr = start = time(NULL);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:288
#, no-wrap
msgid ""
"    while (!done) {\n"
"        pthread_testcancel();           /* A cancellation point */\n"
"        if (curr E<lt> time(NULL)) {\n"
"            curr = time(NULL);\n"
"            printf(\"cnt = %d\\en\", cnt);  /* A cancellation point */\n"
"            cnt++;\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:292
#, no-wrap
msgid ""
"    pthread_cleanup_pop(cleanup_pop_arg);\n"
"    return NULL;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:299
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pthread_t thr;\n"
"    int s;\n"
"    void *res;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:303
#, no-wrap
msgid ""
"    s = pthread_create(&thr, NULL, thread_start, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_create\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:305
#, no-wrap
msgid "    sleep(2);           /* Allow new thread to run a while */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:310
#, no-wrap
msgid ""
"    if (argc E<gt> 1) {\n"
"        if (argc E<gt> 2)\n"
"            cleanup_pop_arg = atoi(argv[2]);\n"
"        done = 1;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:317
#, no-wrap
msgid ""
"    } else {\n"
"        printf(\"Canceling thread\\en\");\n"
"        s = pthread_cancel(thr);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_cancel\");\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:328
#, no-wrap
msgid ""
"    if (res == PTHREAD_CANCELED)\n"
"        printf(\"Thread was canceled; cnt = %d\\en\", cnt);\n"
"    else\n"
"        printf(\"Thread terminated normally; cnt = %d\\en\", cnt);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:335
msgid ""
"B<pthread_cancel>(3), B<pthread_cleanup_push_defer_np>(3), "
"B<pthread_setcancelstate>(3), B<pthread_testcancel>(3), B<pthreads>(7)"
msgstr ""

#. type: TH
#: build/C/man3/pthread_cleanup_push_defer_np.3:26
#, no-wrap
msgid "PTHREAD_CLEANUP_PUSH_DEFER_NP"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push_defer_np.3:30
msgid ""
"pthread_cleanup_push_defer_np, pthread_cleanup_pop_restore_np - push and pop "
"thread cancellation clean-up handlers while saving cancelability type"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push_defer_np.3:37
#, no-wrap
msgid ""
"B<void pthread_cleanup_push_defer_np(void (*>I<routine>B<)(void *),>\n"
"B<                                   void *>I<arg>B<);>\n"
"B<void pthread_cleanup_pop_restore_np(int >I<execute>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push_defer_np.3:40 build/C/man3/pthread_create.3:38 build/C/man3/pthread_detach.3:37 build/C/man3/pthread_join.3:37 build/C/man3/pthread_kill.3:37 build/C/man3/pthread_setname_np.3:39 build/C/man3/pthread_sigmask.3:38 build/C/man3/pthread_sigqueue.3:38 build/C/man3/pthread_tryjoin_np.3:42 build/C/man3/pthread_yield.3:37 build/C/man3/pthread_mutex_consistent.3:37 build/C/man3/pthread_mutexattr_getpshared.3:40 build/C/man3/pthread_mutexattr_init.3:38 build/C/man3/pthread_mutexattr_setrobust.3:41 build/C/man3/pthread_spin_init.3:37 build/C/man3/pthread_spin_lock.3:39
msgid "Compile and link with I<-pthread>."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push_defer_np.3:49
msgid "B<pthread_cleanup_push_defer_np>(), B<pthread_cleanup_pop_defer_np>():"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push_defer_np.3:51
msgid "_GNU_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push_defer_np.3:59
msgid ""
"These functions are the same as B<pthread_cleanup_push>(3)  and "
"B<pthread_cleanup_pop>(3), except for the differences noted on this page."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push_defer_np.3:72
msgid ""
"Like B<pthread_cleanup_push>(3), B<pthread_cleanup_push_defer_np>()  pushes "
"I<routine> onto the thread's stack of cancellation clean-up handlers.  In "
"addition, it also saves the thread's current cancelability type, and sets "
"the cancelability type to \"deferred\" (see B<pthread_setcanceltype>(3)); "
"this ensures that cancellation clean-up will occur even if the thread's "
"cancelability type was \"asynchronous\" before the call."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push_defer_np.3:81
msgid ""
"Like B<pthread_cleanup_pop>(3), B<pthread_cleanup_pop_restore_np>()  pops "
"the top-most clean-up handler from the thread's stack of cancellation "
"clean-up handlers.  In addition, it restores the thread's cancelability type "
"to its value at the time of the matching B<pthread_cleanup_push_defer_np>()."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push_defer_np.3:87
msgid ""
"The caller must ensure that calls to these functions are paired within the "
"same function, and at the same lexical nesting level.  Other restrictions "
"apply, as described in B<pthread_cleanup_push>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push_defer_np.3:89
msgid "This sequence of calls:"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push_defer_np.3:94
#, no-wrap
msgid ""
"pthread_cleanup_push_defer_np(routine, arg);\n"
"pthread_cleanup_pop_restore_np(execute);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push_defer_np.3:98
msgid "is equivalent to (but shorter and more efficient than):"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push_defer_np.3:104
#, no-wrap
msgid "int oldtype;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push_defer_np.3:110
#, no-wrap
msgid ""
"pthread_cleanup_push(routine, arg);\n"
"pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, &oldtype);\n"
"\\&...\n"
"pthread_setcanceltype(oldtype, NULL);\n"
"pthread_cleanup_pop(execute);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push_defer_np.3:123
msgid ""
"B<pthread_cancel>(3), B<pthread_cleanup_push>(3), "
"B<pthread_setcancelstate>(3), B<pthread_testcancel>(3), B<pthreads>(7)"
msgstr ""

#. type: TH
#: build/C/man3/pthread_create.3:26
#, no-wrap
msgid "PTHREAD_CREATE"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_create.3:29
msgid "pthread_create - create a new thread"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_create.3:35
#, no-wrap
msgid ""
"B<int pthread_create(pthread_t *>I<thread>B<, const pthread_attr_t "
"*>I<attr>B<,>\n"
"B<                   void *(*>I<start_routine>B<) (void *), void "
"*>I<arg>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_create.3:47
msgid ""
"The B<pthread_create>()  function starts a new thread in the calling "
"process.  The new thread starts execution by invoking I<start_routine>(); "
"I<arg> is passed as the sole argument of I<start_routine>()."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_create.3:49
msgid "The new thread terminates in one of the following ways:"
msgstr ""

#. type: IP
#: build/C/man3/pthread_create.3:49 build/C/man3/pthread_create.3:55 build/C/man3/pthread_create.3:63 build/C/man3/pthread_create.3:66 build/C/man3/pthread_getattr_np.3:52 build/C/man3/pthread_getattr_np.3:55 build/C/man3/pthread_getattr_np.3:58 build/C/man3/pthread_atfork.3:47 build/C/man3/pthread_atfork.3:52 build/C/man3/pthread_atfork.3:57 build/C/man3/pthread_getattr_default_np.3:50 build/C/man3/pthread_getattr_default_np.3:52 build/C/man3/pthread_getattr_default_np.3:56 build/C/man7/nptl.7:49 build/C/man7/nptl.7:52 build/C/man7/nptl.7:60 build/C/man7/nptl.7:66 build/C/man7/nptl.7:75
#, no-wrap
msgid "*"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_create.3:55
msgid ""
"It calls B<pthread_exit>(3), specifying an exit status value that is "
"available to another thread in the same process that calls "
"B<pthread_join>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_create.3:63
msgid ""
"It returns from I<start_routine>().  This is equivalent to calling "
"B<pthread_exit>(3)  with the value supplied in the I<return> statement."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_create.3:66
msgid "It is canceled (see B<pthread_cancel>(3))."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_create.3:72
msgid ""
"Any of the threads in the process calls B<exit>(3), or the main thread "
"performs a return from I<main>().  This causes the termination of all "
"threads in the process."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_create.3:86
msgid ""
"The I<attr> argument points to a I<pthread_attr_t> structure whose contents "
"are used at thread creation time to determine attributes for the new thread; "
"this structure is initialized using B<pthread_attr_init>(3)  and related "
"functions.  If I<attr> is NULL, then the thread is created with default "
"attributes."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_create.3:93
msgid ""
"Before returning, a successful call to B<pthread_create>()  stores the ID of "
"the new thread in the buffer pointed to by I<thread>; this identifier is "
"used to refer to the thread in subsequent calls to other pthreads functions."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_create.3:101
msgid ""
"The new thread inherits a copy of the creating thread's signal mask "
"(B<pthread_sigmask>(3)).  The set of pending signals for the new thread is "
"empty (B<sigpending>(2)).  The new thread does not inherit the creating "
"thread's alternate signal stack (B<sigaltstack>(2))."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_create.3:104
msgid ""
"The new thread inherits the calling thread's floating-point environment "
"(B<fenv>(3))."
msgstr ""

#.  CLOCK_THREAD_CPUTIME_ID in clock_gettime(2)
#. type: Plain text
#: build/C/man3/pthread_create.3:109
msgid ""
"The initial value of the new thread's CPU-time clock is 0 (see "
"B<pthread_getcpuclockid>(3))."
msgstr ""

#. type: SS
#: build/C/man3/pthread_create.3:109
#, no-wrap
msgid "Linux-specific details"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_create.3:115
msgid ""
"The new thread inherits copies of the calling thread's capability sets (see "
"B<capabilities>(7))  and CPU affinity mask (see B<sched_setaffinity>(2))."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_create.3:122
msgid ""
"On success, B<pthread_create>()  returns 0; on error, it returns an error "
"number, and the contents of I<*thread> are undefined."
msgstr ""

#. type: TP
#: build/C/man3/pthread_create.3:123 build/C/man3/pthread_create.3:126 build/C/man3/pthread_sigqueue.3:72 build/C/man3/pthread_spin_init.3:121
#, no-wrap
msgid "B<EAGAIN>"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_create.3:126
msgid "Insufficient resources to create another thread."
msgstr ""

#.  NOTE! The following should match the description in fork(2)
#. type: Plain text
#: build/C/man3/pthread_create.3:144
msgid ""
"A system-imposed limit on the number of threads was encountered.  There are "
"a number of limits that may trigger this error: the B<RLIMIT_NPROC> soft "
"resource limit (set via B<setrlimit>(2)), which limits the number of "
"processes and threads for a real user ID, was reached; the kernel's "
"system-wide limit on the number of processes and threads, "
"I</proc/sys/kernel/threads-max>, was reached (see B<proc>(5)); or the "
"maximum number of PIDs, I</proc/sys/kernel/pid_max>, was reached (see "
"B<proc>(5))."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_create.3:148
msgid "Invalid settings in I<attr>."
msgstr ""

#. type: TP
#: build/C/man3/pthread_create.3:148 build/C/man3/pthread_setschedparam.3:129 build/C/man3/pthread_setschedprio.3:66
#, no-wrap
msgid "B<EPERM>"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_create.3:153
msgid ""
"No permission to set the scheduling policy and parameters specified in "
"I<attr>."
msgstr ""

#. type: tbl table
#: build/C/man3/pthread_create.3:163
#, no-wrap
msgid "B<pthread_create>()"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_create.3:180
msgid ""
"See B<pthread_self>(3)  for further information on the thread ID returned in "
"I<*thread> by B<pthread_create>().  Unless real-time scheduling policies are "
"being employed, after a call to B<pthread_create>(), it is indeterminate "
"which thread\\(emthe caller or the new thread\\(emwill next execute."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_create.3:200
msgid ""
"A thread may either be I<joinable> or I<detached>.  If a thread is joinable, "
"then another thread can call B<pthread_join>(3)  to wait for the thread to "
"terminate and fetch its exit status.  Only when a terminated joinable thread "
"has been joined are the last of its resources released back to the system.  "
"When a detached thread terminates, its resources are automatically released "
"back to the system: it is not possible to join with the thread in order to "
"obtain its exit status.  Making a thread detached is useful for some types "
"of daemon threads whose exit status the application does not need to care "
"about.  By default, a new thread is created in a joinable state, unless "
"I<attr> was set to create the thread in a detached state (using "
"B<pthread_attr_setdetachstate>(3))."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_create.3:218
msgid ""
"Under the NPTL threading implementation, if the B<RLIMIT_STACK> soft "
"resource limit I<at the time the program started> has any value other than "
"\"unlimited\", then it determines the default stack size of new threads.  "
"Using B<pthread_attr_setstacksize>(3), the stack size attribute can be "
"explicitly set in the I<attr> argument used to create a thread, in order to "
"obtain a stack size other than the default.  If the B<RLIMIT_STACK> resource "
"limit is set to \"unlimited\", a per-architecture value is used for the "
"stack size.  Here is the value for a few architectures:"
msgstr ""

#. type: tbl table
#: build/C/man3/pthread_create.3:223
#, no-wrap
msgid "Architecture"
msgstr ""

#. type: tbl table
#: build/C/man3/pthread_create.3:223
#, no-wrap
msgid "Default stack size"
msgstr ""

#. type: tbl table
#: build/C/man3/pthread_create.3:224
#, no-wrap
msgid "i386"
msgstr ""

#. type: tbl table
#: build/C/man3/pthread_create.3:224 build/C/man3/pthread_create.3:227 build/C/man3/pthread_create.3:228 build/C/man3/pthread_create.3:230
#, no-wrap
msgid "2 MB"
msgstr ""

#. type: tbl table
#: build/C/man3/pthread_create.3:225
#, no-wrap
msgid "IA-64"
msgstr ""

#. type: tbl table
#: build/C/man3/pthread_create.3:225
#, no-wrap
msgid "32 MB"
msgstr ""

#. type: tbl table
#: build/C/man3/pthread_create.3:226
#, no-wrap
msgid "PowerPC"
msgstr ""

#. type: tbl table
#: build/C/man3/pthread_create.3:226 build/C/man3/pthread_create.3:229
#, no-wrap
msgid "4 MB"
msgstr ""

#. type: tbl table
#: build/C/man3/pthread_create.3:227
#, no-wrap
msgid "S/390"
msgstr ""

#. type: tbl table
#: build/C/man3/pthread_create.3:228
#, no-wrap
msgid "Sparc-32"
msgstr ""

#. type: tbl table
#: build/C/man3/pthread_create.3:229
#, no-wrap
msgid "Sparc-64"
msgstr ""

#. type: tbl table
#: build/C/man3/pthread_create.3:230
#, no-wrap
msgid "x86_64"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_create.3:239
msgid ""
"In the obsolete LinuxThreads implementation, each of the threads in a "
"process has a different process ID.  This is in violation of the POSIX "
"threads specification, and is the source of many other nonconformances to "
"the standard; see B<pthreads>(7)."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_create.3:243
msgid ""
"The program below demonstrates the use of B<pthread_create>(), as well as a "
"number of other functions in the pthreads API."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_create.3:248
msgid ""
"In the following run, on a system providing the NPTL threading "
"implementation, the stack size defaults to the value given by the \"stack "
"size\" resource limit:"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_create.3:260
#, no-wrap
msgid ""
"$B< ulimit -s>\n"
"8192            # The stack size limit is 8 MB (0x800000 bytes)\n"
"$B< ./a.out hola salut servus>\n"
"Thread 1: top of stack near 0xb7dd03b8; argv_string=hola\n"
"Thread 2: top of stack near 0xb75cf3b8; argv_string=salut\n"
"Thread 3: top of stack near 0xb6dce3b8; argv_string=servus\n"
"Joined with thread 1; returned value was HOLA\n"
"Joined with thread 2; returned value was SALUT\n"
"Joined with thread 3; returned value was SERVUS\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_create.3:266
msgid ""
"In the next run, the program explicitly sets a stack size of 1\\ MB (using "
"B<pthread_attr_setstacksize>(3))  for the created threads:"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_create.3:276
#, no-wrap
msgid ""
"$B< ./a.out -s 0x100000 hola salut servus>\n"
"Thread 1: top of stack near 0xb7d723b8; argv_string=hola\n"
"Thread 2: top of stack near 0xb7c713b8; argv_string=salut\n"
"Thread 3: top of stack near 0xb7b703b8; argv_string=servus\n"
"Joined with thread 1; returned value was HOLA\n"
"Joined with thread 2; returned value was SALUT\n"
"Joined with thread 3; returned value was SERVUS\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_create.3:288
#, no-wrap
msgid ""
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>ctype.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_create.3:294 build/C/man3/pthread_getcpuclockid.3:127
#, no-wrap
msgid ""
"#define handle_error(msg) \\e\n"
"        do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_create.3:300
#, no-wrap
msgid ""
"struct thread_info {    /* Used as argument to thread_start() */\n"
"    pthread_t thread_id;        /* ID returned by pthread_create() */\n"
"    int       thread_num;       /* Application-defined thread # */\n"
"    char     *argv_string;      /* From command-line argument */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_create.3:303
#, no-wrap
msgid ""
"/* Thread start function: display address near top of our stack,\n"
"   and return upper-cased copy of argv_string */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_create.3:309
#, no-wrap
msgid ""
"static void *\n"
"thread_start(void *arg)\n"
"{\n"
"    struct thread_info *tinfo = arg;\n"
"    char *uargv;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_create.3:312
#, no-wrap
msgid ""
"    printf(\"Thread %d: top of stack near %p; argv_string=%s\\en\",\n"
"            tinfo-E<gt>thread_num, &p, tinfo-E<gt>argv_string);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_create.3:316
#, no-wrap
msgid ""
"    uargv = strdup(tinfo-E<gt>argv_string);\n"
"    if (uargv == NULL)\n"
"        handle_error(\"strdup\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_create.3:319
#, no-wrap
msgid ""
"    for (char *p = uargv; *p != \\(aq\\e0\\(aq; p++)\n"
"        *p = toupper(*p);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_create.3:322
#, no-wrap
msgid ""
"    return uargv;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_create.3:330
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int s, opt, num_threads;\n"
"    pthread_attr_t attr;\n"
"    size_t stack_size;\n"
"    void *res;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_create.3:332
#, no-wrap
msgid "    /* The \"-s\" option specifies a stack size for our threads */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_create.3:339
#, no-wrap
msgid ""
"    stack_size = -1;\n"
"    while ((opt = getopt(argc, argv, \"s:\")) != -1) {\n"
"        switch (opt) {\n"
"        case \\(aqs\\(aq:\n"
"            stack_size = strtoul(optarg, NULL, 0);\n"
"            break;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_create.3:346
#, no-wrap
msgid ""
"        default:\n"
"            fprintf(stderr, \"Usage: %s [-s stack-size] arg...\\en\",\n"
"                    argv[0]);\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_create.3:348
#, no-wrap
msgid "    num_threads = argc - optind;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_create.3:350
#, no-wrap
msgid "    /* Initialize thread creation attributes */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_create.3:354
#, no-wrap
msgid ""
"    s = pthread_attr_init(&attr);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_init\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_create.3:360
#, no-wrap
msgid ""
"    if (stack_size E<gt> 0) {\n"
"        s = pthread_attr_setstacksize(&attr, stack_size);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setstacksize\");\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_create.3:362
#, no-wrap
msgid "    /* Allocate memory for pthread_create() arguments */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_create.3:366
#, no-wrap
msgid ""
"    struct thread_info *tinfo = calloc(num_threads, sizeof(*tinfo));\n"
"    if (tinfo == NULL)\n"
"        handle_error(\"calloc\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_create.3:368
#, no-wrap
msgid "    /* Create one thread for each command-line argument */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_create.3:372
#, no-wrap
msgid ""
"    for (int tnum = 0; tnum E<lt> num_threads; tnum++) {\n"
"        tinfo[tnum].thread_num = tnum + 1;\n"
"        tinfo[tnum].argv_string = argv[optind + tnum];\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_create.3:375
#, no-wrap
msgid ""
"        /* The pthread_create() call stores the thread ID into\n"
"           corresponding element of tinfo[] */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_create.3:381
#, no-wrap
msgid ""
"        s = pthread_create(&tinfo[tnum].thread_id, &attr,\n"
"                           &thread_start, &tinfo[tnum]);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_create\");\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_create.3:384
#, no-wrap
msgid ""
"    /* Destroy the thread attributes object, since it is no\n"
"       longer needed */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_create.3:388
#, no-wrap
msgid ""
"    s = pthread_attr_destroy(&attr);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_destroy\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_create.3:390
#, no-wrap
msgid "    /* Now join with each thread, and display its returned value */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_create.3:395
#, no-wrap
msgid ""
"    for (int tnum = 0; tnum E<lt> num_threads; tnum++) {\n"
"        s = pthread_join(tinfo[tnum].thread_id, &res);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_join\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_create.3:400
#, no-wrap
msgid ""
"        printf(\"Joined with thread %d; returned value was %s\\en\",\n"
"                tinfo[tnum].thread_num, (char *) res);\n"
"        free(res);      /* Free memory allocated by thread */\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_create.3:404
#, no-wrap
msgid ""
"    free(tinfo);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_create.3:419
msgid ""
"B<getrlimit>(2), B<pthread_attr_init>(3), B<pthread_cancel>(3), "
"B<pthread_detach>(3), B<pthread_equal>(3), B<pthread_exit>(3), "
"B<pthread_getattr_np>(3), B<pthread_join>(3), B<pthread_self>(3), "
"B<pthread_setattr_default_np>(3), B<pthreads>(7)"
msgstr ""

#. type: TH
#: build/C/man3/pthread_detach.3:26
#, no-wrap
msgid "PTHREAD_DETACH"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_detach.3:29
msgid "pthread_detach - detach a thread"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_detach.3:34
#, no-wrap
msgid "B<int pthread_detach(pthread_t >I<thread>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_detach.3:46
msgid ""
"The B<pthread_detach>()  function marks the thread identified by I<thread> "
"as detached.  When a detached thread terminates, its resources are "
"automatically released back to the system without the need for another "
"thread to join with the terminated thread."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_detach.3:49
msgid ""
"Attempting to detach an already detached thread results in unspecified "
"behavior."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_detach.3:54
msgid ""
"On success, B<pthread_detach>()  returns 0; on error, it returns an error "
"number."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_detach.3:59 build/C/man3/pthread_join.3:89
msgid "I<thread> is not a joinable thread."
msgstr ""

#. type: tbl table
#: build/C/man3/pthread_detach.3:74
#, no-wrap
msgid "B<pthread_detach>()"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_detach.3:83
msgid ""
"Once a thread has been detached, it can't be joined with B<pthread_join>(3)  "
"or be made joinable again."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_detach.3:90
msgid ""
"A new thread can be created in a detached state using "
"B<pthread_attr_setdetachstate>(3)  to set the detached attribute of the "
"I<attr> argument of B<pthread_create>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_detach.3:97
msgid ""
"The detached attribute merely determines the behavior of the system when the "
"thread terminates; it does not prevent the thread from being terminated if "
"the process terminates using B<exit>(3)  (or equivalently, if the main "
"thread returns)."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_detach.3:106
msgid ""
"Either B<pthread_join>(3)  or B<pthread_detach>()  should be called for each "
"thread that an application creates, so that system resources for the thread "
"can be released.  (But note that the resources of any threads for which one "
"of these actions has not been done will be freed when the process "
"terminates.)"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_detach.3:108
msgid "The following statement detaches the calling thread:"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_detach.3:110
#, no-wrap
msgid "    pthread_detach(pthread_self());\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_detach.3:117
msgid ""
"B<pthread_attr_setdetachstate>(3), B<pthread_cancel>(3), "
"B<pthread_create>(3), B<pthread_exit>(3), B<pthread_join>(3), B<pthreads>(7)"
msgstr ""

#. type: TH
#: build/C/man3/pthread_equal.3:26
#, no-wrap
msgid "PTHREAD_EQUAL"
msgstr ""

#. type: TH
#: build/C/man3/pthread_equal.3:26 build/C/man3/pthread_setschedprio.3:26 build/C/man7/nptl.7:26
#, no-wrap
msgid "2015-08-08"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_equal.3:29
msgid "pthread_equal - compare thread IDs"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_equal.3:34
#, no-wrap
msgid "B<int pthread_equal(pthread_t >I<t1>B<, pthread_t >I<t2>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_equal.3:41
msgid "The B<pthread_equal>()  function compares two thread identifiers."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_equal.3:45
msgid ""
"If the two thread IDs are equal, B<pthread_equal>()  returns a nonzero "
"value; otherwise, it returns 0."
msgstr ""

#.  SH VERSIONS
#.  Available since glibc 2.0
#. type: Plain text
#: build/C/man3/pthread_equal.3:47 build/C/man3/pthread_exit.3:75 build/C/man3/pthread_self.3:50 build/C/man3/pthread_testcancel.3:58
msgid "This function always succeeds."
msgstr ""

#. type: tbl table
#: build/C/man3/pthread_equal.3:57
#, no-wrap
msgid "B<pthread_equal>()"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_equal.3:68
msgid ""
"The B<pthread_equal>()  function is necessary because thread IDs should be "
"considered opaque: there is no portable way for applications to directly "
"compare two I<pthread_t> values."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_equal.3:72
msgid "B<pthread_create>(3), B<pthread_self>(3), B<pthreads>(7)"
msgstr ""

#. type: TH
#: build/C/man3/pthread_exit.3:26
#, no-wrap
msgid "PTHREAD_EXIT"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_exit.3:29
msgid "pthread_exit - terminate calling thread"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_exit.3:34
#, no-wrap
msgid "B<void pthread_exit(void *>I<retval>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_exit.3:45
msgid ""
"The B<pthread_exit>()  function terminates the calling thread and returns a "
"value via I<retval> that (if the thread is joinable)  is available to "
"another thread in the same process that calls B<pthread_join>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_exit.3:55
msgid ""
"Any clean-up handlers established by B<pthread_cleanup_push>(3)  that have "
"not yet been popped, are popped (in the reverse of the order in which they "
"were pushed)  and executed.  If the thread has any thread-specific data, "
"then, after the clean-up handlers have been executed, the corresponding "
"destructor functions are called, in an unspecified order."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_exit.3:62
msgid ""
"When a thread terminates, process-shared resources (e.g., mutexes, condition "
"variables, semaphores, and file descriptors) are not released, and functions "
"registered using B<atexit>(3)  are not called."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_exit.3:71
msgid ""
"After the last thread in a process terminates, the process terminates as by "
"calling B<exit>(3)  with an exit status of zero; thus, process-shared "
"resources are released and functions registered using B<atexit>(3)  are "
"called."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_exit.3:73
msgid "This function does not return to the caller."
msgstr ""

#. type: tbl table
#: build/C/man3/pthread_exit.3:85
#, no-wrap
msgid "B<pthread_exit>()"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_exit.3:94
msgid ""
"Performing a return from the start function of any thread other than the "
"main thread results in an implicit call to B<pthread_exit>(), using the "
"function's return value as the thread's exit status."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_exit.3:100
msgid ""
"To allow other threads to continue execution, the main thread should "
"terminate by calling B<pthread_exit>()  rather than B<exit>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_exit.3:105
msgid ""
"The value pointed to by I<retval> should not be located on the calling "
"thread's stack, since the contents of that stack are undefined after the "
"thread terminates."
msgstr ""

#.  Linux 2.6.27
#.  FIXME . review a later kernel to see if this gets fixed
#.  http://thread.gmane.org/gmane.linux.kernel/611611
#.  http://marc.info/?l=linux-kernel&m=122525468300823&w=2
#. type: Plain text
#: build/C/man3/pthread_exit.3:117
msgid ""
"Currently, there are limitations in the kernel implementation logic for "
"B<wait>(2)ing on a stopped thread group with a dead thread group leader.  "
"This can manifest in problems such as a locked terminal if a stop signal is "
"sent to a foreground process whose thread group leader has already called "
"B<pthread_exit>()."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_exit.3:121
msgid "B<pthread_create>(3), B<pthread_join>(3), B<pthreads>(7)"
msgstr ""

#. type: TH
#: build/C/man3/pthread_getattr_np.3:26
#, no-wrap
msgid "PTHREAD_GETATTR_NP"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:29
msgid "pthread_getattr_np - get attributes of created thread"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:35
#, no-wrap
msgid ""
"B<int pthread_getattr_np(pthread_t >I<thread>B<, pthread_attr_t "
"*>I<attr>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:45
msgid ""
"The B<pthread_getattr_np>()  function initializes the thread attributes "
"object referred to by I<attr> so that it contains actual attribute values "
"describing the running thread I<thread>."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:52
msgid ""
"The returned attribute values may differ from the corresponding attribute "
"values passed in the I<attr> object that was used to create the thread using "
"B<pthread_create>(3).  In particular, the following attributes may differ:"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:55
msgid ""
"the detach state, since a joinable thread may have detached itself after "
"creation;"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:58
msgid "the stack size, which the implementation may align to a suitable boundary."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:63
msgid ""
"and the guard size, which the implementation may round upward to a multiple "
"of the page size, or ignore (i.e., treat as 0), if the application is "
"allocating its own stack."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:68
msgid ""
"Furthermore, if the stack address attribute was not set in the thread "
"attributes object used to create the thread, then the returned thread "
"attributes object will report the actual stack address that the "
"implementation selected for the thread."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:73
msgid ""
"When the thread attributes object returned by B<pthread_getattr_np>()  is no "
"longer required, it should be destroyed using B<pthread_attr_destroy>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:76 build/C/man3/pthread_getcpuclockid.3:52
msgid ""
"On success, this function returns 0; on error, it returns a nonzero error "
"number."
msgstr ""

#.  Can happen (but unlikely) while trying to allocate memory for cpuset
#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:81
msgid "Insufficient memory."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:96
msgid ""
"In addition, if I<thread> refers to the main thread, then "
"B<pthread_getattr_np>()  can fail because of errors from various underlying "
"calls: B<fopen>(3), if I</proc/self/maps> can't be opened; and "
"B<getrlimit>(2), if the B<RLIMIT_STACK> resource limit is not supported."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:98
msgid "This function is available in glibc since version 2.2.3."
msgstr ""

#. type: tbl table
#: build/C/man3/pthread_getattr_np.3:109
#, no-wrap
msgid "B<pthread_getattr_np>()"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:115 build/C/man3/pthread_kill_other_threads_np.3:62
msgid ""
"This function is a nonstandard GNU extension; hence the suffix \"_np\" "
"(nonportable) in the name."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:125
msgid ""
"The program below demonstrates the use of B<pthread_getattr_np>().  The "
"program creates a thread that then uses B<pthread_getattr_np>()  to retrieve "
"and display its guard size, stack address, and stack size attributes.  "
"Command-line arguments can be used to set these attributes to values other "
"than the default when creating the thread.  The shell sessions below "
"demonstrate the use of the program."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:128
msgid ""
"In the first run, on an x86-32 system, a thread is created using default "
"attributes:"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:138
#, no-wrap
msgid ""
"$B< ulimit -s>      # No stack limit ==E<gt> default stack size is 2 MB\n"
"unlimited\n"
"$B< ./a.out>\n"
"Attributes of created thread:\n"
"        Guard size          = 4096 bytes\n"
"        Stack address       = 0x40196000 (EOS = 0x40397000)\n"
"        Stack size          = 0x201000 (2101248) bytes\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:144
msgid ""
"In the following run, we see that if a guard size is specified, it is "
"rounded up to the next multiple of the system page size (4096 bytes on "
"x86-32):"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:152
#, no-wrap
msgid ""
"$B< ./a.out -g 4097>\n"
"Thread attributes object after initializations:\n"
"        Guard size          = 4097 bytes\n"
"        Stack address       = (nil)\n"
"        Stack size          = 0x0 (0) bytes\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:157
#, no-wrap
msgid ""
"Attributes of created thread:\n"
"        Guard size          = 8192 bytes\n"
"        Stack address       = 0x40196000 (EOS = 0x40397000)\n"
"        Stack size          = 0x201000 (2101248) bytes\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:176
msgid ""
"In the last run, the program manually allocates a stack for the thread.  In "
"this case, the guard size attribute is ignored."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:181
#, no-wrap
msgid ""
"$B< ./a.out -g 4096 -s 0x8000 -a>\n"
"Allocated thread stack at 0x804d000\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:186
#, no-wrap
msgid ""
"Thread attributes object after initializations:\n"
"        Guard size          = 4096 bytes\n"
"        Stack address       = 0x804d000 (EOS = 0x8055000)\n"
"        Stack size          = 0x8000 (32768) bytes\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:191
#, no-wrap
msgid ""
"Attributes of created thread:\n"
"        Guard size          = 0 bytes\n"
"        Stack address       = 0x804d000 (EOS = 0x8055000)\n"
"        Stack size          = 0x8000 (32768) bytes\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:212
#, no-wrap
msgid ""
"static void\n"
"display_stack_related_attributes(pthread_attr_t *attr, char *prefix)\n"
"{\n"
"    int s;\n"
"    size_t stack_size, guard_size;\n"
"    void *stack_addr;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:217
#, no-wrap
msgid ""
"    s = pthread_attr_getguardsize(attr, &guard_size);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getguardsize\");\n"
"    printf(\"%sGuard size          = %zu bytes\\en\", prefix, guard_size);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:228
#, no-wrap
msgid ""
"    s = pthread_attr_getstack(attr, &stack_addr, &stack_size);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getstack\");\n"
"    printf(\"%sStack address       = %p\", prefix, stack_addr);\n"
"    if (stack_size E<gt> 0)\n"
"        printf(\" (EOS = %p)\", (char *) stack_addr + stack_size);\n"
"    printf(\"\\en\");\n"
"    printf(\"%sStack size          = %#zx (%zu) bytes\\en\",\n"
"            prefix, stack_size, stack_size);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:234
#, no-wrap
msgid ""
"static void\n"
"display_thread_attributes(pthread_t thread, char *prefix)\n"
"{\n"
"    int s;\n"
"    pthread_attr_t attr;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:238
#, no-wrap
msgid ""
"    s = pthread_getattr_np(thread, &attr);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_getattr_np\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:240
#, no-wrap
msgid "    display_stack_related_attributes(&attr, prefix);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:245
#, no-wrap
msgid ""
"    s = pthread_attr_destroy(&attr);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_destroy\");\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:251
#, no-wrap
msgid ""
"static void *           /* Start function for thread we create */\n"
"thread_start(void *arg)\n"
"{\n"
"    printf(\"Attributes of created thread:\\en\");\n"
"    display_thread_attributes(pthread_self(), \"\\et\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:265
#, no-wrap
msgid ""
"static void\n"
"usage(char *pname, char *msg)\n"
"{\n"
"    if (msg != NULL)\n"
"        fputs(msg, stderr);\n"
"    fprintf(stderr, \"Usage: %s [-s stack-size [-a]]\"\n"
"            \" [-g guard-size]\\en\", pname);\n"
"    fprintf(stderr, \"\\et\\et-a means program should allocate "
"stack\\en\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:278
#, no-wrap
msgid ""
"static pthread_attr_t *   /* Get thread attributes from command line */\n"
"get_thread_attributes_from_cl(int argc, char *argv[],\n"
"                              pthread_attr_t *attrp)\n"
"{\n"
"    int s, opt, allocate_stack;\n"
"    size_t stack_size, guard_size;\n"
"    void *stack_addr;\n"
"    pthread_attr_t *ret_attrp = NULL;   /* Set to attrp if we initialize\n"
"                                           a thread attributes object */\n"
"    allocate_stack = 0;\n"
"    stack_size = -1;\n"
"    guard_size = -1;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:287
#, no-wrap
msgid ""
"    while ((opt = getopt(argc, argv, \"ag:s:\")) != -1) {\n"
"        switch (opt) {\n"
"        case \\(aqa\\(aq:   allocate_stack = 1;                     break;\n"
"        case \\(aqg\\(aq:   guard_size = strtoul(optarg, NULL, 0);  break;\n"
"        case \\(aqs\\(aq:   stack_size = strtoul(optarg, NULL, 0);  break;\n"
"        default:    usage(argv[0], NULL);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:290
#, no-wrap
msgid ""
"    if (allocate_stack && stack_size == -1)\n"
"        usage(argv[0], \"Specifying -a without -s makes no sense\\en\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:293
#, no-wrap
msgid ""
"    if (argc E<gt> optind)\n"
"        usage(argv[0], \"Extraneous command-line arguments\\en\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:296
#, no-wrap
msgid ""
"    if (stack_size E<gt>= 0 || guard_size E<gt> 0) {\n"
"        ret_attrp = attrp;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:301
#, no-wrap
msgid ""
"        s = pthread_attr_init(attrp);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_init\");\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:313
#, no-wrap
msgid ""
"    if (stack_size E<gt>= 0) {\n"
"        if (!allocate_stack) {\n"
"            s = pthread_attr_setstacksize(attrp, stack_size);\n"
"            if (s != 0)\n"
"                handle_error_en(s, \"pthread_attr_setstacksize\");\n"
"        } else {\n"
"            s = posix_memalign(&stack_addr, sysconf(_SC_PAGESIZE),\n"
"                               stack_size);\n"
"            if (s != 0)\n"
"                handle_error_en(s, \"posix_memalign\");\n"
"            printf(\"Allocated thread stack at %p\\en\\en\", stack_addr);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:319
#, no-wrap
msgid ""
"            s = pthread_attr_setstack(attrp, stack_addr, stack_size);\n"
"            if (s != 0)\n"
"                handle_error_en(s, \"pthread_attr_setstacksize\");\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:325
#, no-wrap
msgid ""
"    if (guard_size E<gt>= 0) {\n"
"        s = pthread_attr_setguardsize(attrp, guard_size);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setstacksize\");\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:328
#, no-wrap
msgid ""
"    return ret_attrp;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:337
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int s;\n"
"    pthread_t thr;\n"
"    pthread_attr_t attr;\n"
"    pthread_attr_t *attrp = NULL;    /* Set to &attr if we initialize\n"
"                                        a thread attributes object */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:339
#, no-wrap
msgid "    attrp = get_thread_attributes_from_cl(argc, argv, &attr);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:345
#, no-wrap
msgid ""
"    if (attrp != NULL) {\n"
"        printf(\"Thread attributes object after initializations:\\en\");\n"
"        display_stack_related_attributes(attrp, \"\\et\");\n"
"        printf(\"\\en\");\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:375 build/C/man3/pthread_getattr_default_np.3:212
msgid ""
"B<pthread_attr_getaffinity_np>(3), B<pthread_attr_getdetachstate>(3), "
"B<pthread_attr_getguardsize>(3), B<pthread_attr_getinheritsched>(3), "
"B<pthread_attr_getschedparam>(3), B<pthread_attr_getschedpolicy>(3), "
"B<pthread_attr_getscope>(3), B<pthread_attr_getstack>(3), "
"B<pthread_attr_getstackaddr>(3), B<pthread_attr_getstacksize>(3), "
"B<pthread_attr_init>(3), B<pthread_create>(3), B<pthreads>(7)"
msgstr ""

#. type: TH
#: build/C/man3/pthread_getcpuclockid.3:26
#, no-wrap
msgid "PTHREAD_GETCPUCLOCKID"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:29
msgid "pthread_getcpuclockid - retrieve ID of a thread's CPU time clock"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:33
#, no-wrap
msgid ""
"B<#include E<lt>pthread.hE<gt>>\n"
"B<#include E<lt>time.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:35
#, no-wrap
msgid ""
"B<int pthread_getcpuclockid(pthread_t >I<thread>B<, clockid_t "
"*>I<clockid>B<);>\n"
msgstr ""

#.  The clockid is constructed as follows:
#.  *clockid = CLOCK_THREAD_CPUTIME_ID | (pd->tid << CLOCK_IDFIELD_SIZE)
#.  where CLOCK_IDFIELD_SIZE is 3.
#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:49
msgid ""
"The B<pthread_getcpuclockid>()  function obtains the ID of the CPU-time "
"clock of the thread whose ID is given in I<thread>, and returns it in the "
"location pointed to by I<clockid>."
msgstr ""

#. type: TP
#: build/C/man3/pthread_getcpuclockid.3:53
#, no-wrap
msgid "B<ENOENT>"
msgstr ""

#.  CLOCK_THREAD_CPUTIME_ID not defined
#
#.  Looking at nptl/pthread_getcpuclockid.c an ERANGE error would
#.  be possible if kernel thread IDs took more than 29 bits (which
#.  they currently cannot).
#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:61
msgid "Per-thread CPU time clocks are not supported by the system."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:68
msgid "This function is available in glibc since version 2.2."
msgstr ""

#. type: tbl table
#: build/C/man3/pthread_getcpuclockid.3:78
#, no-wrap
msgid "B<pthread_getcpuclockid>()"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:93
msgid ""
"When I<thread> refers to the calling thread, this function returns an "
"identifier that refers to the same clock manipulated by B<clock_gettime>(2)  "
"and B<clock_settime>(2)  when given the clock ID B<CLOCK_THREAD_CPUTIME_ID>."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:99
msgid ""
"The program below creates a thread and then uses B<clock_gettime>(2)  to "
"retrieve the total process CPU time, and the per-thread CPU time consumed by "
"the two threads.  The following shell session shows an example run:"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:109
#, no-wrap
msgid ""
"$ B<./a.out>\n"
"Main thread sleeping\n"
"Subthread starting infinite loop\n"
"Main thread consuming some CPU time...\n"
"Process total CPU time:    1.368\n"
"Main thread CPU time:      0.376\n"
"Subthread CPU time:        0.992\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:115
#, no-wrap
msgid "/* Link with \"-lrt\" */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:124
#, no-wrap
msgid ""
"#include E<lt>time.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:138
#, no-wrap
msgid ""
"static void *\n"
"thread_start(void *arg)\n"
"{\n"
"    printf(\"Subthread starting infinite loop\\en\");\n"
"    for (;;)\n"
"        continue;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:143
#, no-wrap
msgid ""
"static void\n"
"pclock(char *msg, clockid_t cid)\n"
"{\n"
"    struct timespec ts;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:149
#, no-wrap
msgid ""
"    printf(\"%s\", msg);\n"
"    if (clock_gettime(cid, &ts) == -1)\n"
"        handle_error(\"clock_gettime\");\n"
"    printf(\"%4jd.%03ld\\en\", (intmax_t) ts.tv_sec, ts.tv_nsec / "
"1000000);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:156
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pthread_t thread;\n"
"    clockid_t cid;\n"
"    int s;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:160
#, no-wrap
msgid ""
"    s = pthread_create(&thread, NULL, thread_start, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_create\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:163
#, no-wrap
msgid ""
"    printf(\"Main thread sleeping\\en\");\n"
"    sleep(1);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:167
#, no-wrap
msgid ""
"    printf(\"Main thread consuming some CPU time...\\en\");\n"
"    for (int j = 0; j E<lt> 2000000; j++)\n"
"        getppid();\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:169
#, no-wrap
msgid "    pclock(\"Process total CPU time: \", CLOCK_PROCESS_CPUTIME_ID);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:174
#, no-wrap
msgid ""
"    s = pthread_getcpuclockid(pthread_self(), &cid);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_getcpuclockid\");\n"
"    pclock(\"Main thread CPU time:   \", cid);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:177
#, no-wrap
msgid ""
"    /* The preceding 4 lines of code could have been replaced by:\n"
"       pclock(\"Main thread CPU time:   \", CLOCK_THREAD_CPUTIME_ID); */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:182
#, no-wrap
msgid ""
"    s = pthread_getcpuclockid(thread, &cid);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_getcpuclockid\");\n"
"    pclock(\"Subthread CPU time: 1    \", cid);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:185
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);         /* Terminates both threads */\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:194
msgid ""
"B<clock_gettime>(2), B<clock_settime>(2), B<timer_create>(2), "
"B<clock_getcpuclockid>(3), B<pthread_self>(3), B<pthreads>(7), B<time>(7)"
msgstr ""

#. type: TH
#: build/C/man3/pthread_join.3:26
#, no-wrap
msgid "PTHREAD_JOIN"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_join.3:29
msgid "pthread_join - join with a terminated thread"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_join.3:34
#, no-wrap
msgid "B<int pthread_join(pthread_t >I<thread>B<, void **>I<retval>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_join.3:49
msgid ""
"The B<pthread_join>()  function waits for the thread specified by I<thread> "
"to terminate.  If that thread has already terminated, then B<pthread_join>()  "
"returns immediately.  The thread specified by I<thread> must be joinable."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_join.3:63
msgid ""
"If I<retval> is not NULL, then B<pthread_join>()  copies the exit status of "
"the target thread (i.e., the value that the target thread supplied to "
"B<pthread_exit>(3))  into the location pointed to by I<retval>.  If the "
"target thread was canceled, then B<PTHREAD_CANCELED> is placed in the "
"location pointed to by I<retval>."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_join.3:70
msgid ""
"If multiple threads simultaneously try to join with the same thread, the "
"results are undefined.  If the thread calling B<pthread_join>()  is "
"canceled, then the target thread will remain joinable (i.e., it will not be "
"detached)."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_join.3:75
msgid ""
"On success, B<pthread_join>()  returns 0; on error, it returns an error "
"number."
msgstr ""

#. type: TP
#: build/C/man3/pthread_join.3:76
#, no-wrap
msgid "B<EDEADLK>"
msgstr ""

#.  The following verified by testing on glibc 2.8/NPTL:
#.  The following verified by testing on glibc 2.8/NPTL:
#. type: Plain text
#: build/C/man3/pthread_join.3:85
msgid ""
"A deadlock was detected (e.g., two threads tried to join with each other); "
"or I<thread> specifies the calling thread."
msgstr ""

#.  POSIX.1-2001 does not specify this error case.
#. type: Plain text
#: build/C/man3/pthread_join.3:93
msgid "Another thread is already waiting to join with this thread."
msgstr ""

#. type: tbl table
#: build/C/man3/pthread_join.3:108
#, no-wrap
msgid "B<pthread_join>()"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_join.3:120
msgid ""
"After a successful call to B<pthread_join>(), the caller is guaranteed that "
"the target thread has terminated.  The caller may then choose to do any "
"clean-up that is required after termination of the thread (e.g., freeing "
"memory or other resources that were allocated to the target thread)."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_join.3:123
msgid ""
"Joining with a thread that has previously been joined results in undefined "
"behavior."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_join.3:131
msgid ""
"Failure to join with a thread that is joinable (i.e., one that is not "
"detached), produces a \"zombie thread\".  Avoid doing this, since each "
"zombie thread consumes some system resources, and when enough zombie threads "
"have accumulated, it will no longer be possible to create new threads (or "
"processes)."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_join.3:137
msgid ""
"There is no pthreads analog of I<waitpid(-1,\\ &status,\\ 0)>, that is, "
"\"join with any terminated thread\".  If you believe you need this "
"functionality, you probably need to rethink your application design."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_join.3:140
msgid ""
"All of the threads in a process are peers: any thread can join with any "
"other thread in the process."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_join.3:150
msgid ""
"B<pthread_cancel>(3), B<pthread_create>(3), B<pthread_detach>(3), "
"B<pthread_exit>(3), B<pthread_tryjoin_np>(3), B<pthreads>(7)"
msgstr ""

#. type: TH
#: build/C/man3/pthread_kill.3:26
#, no-wrap
msgid "PTHREAD_KILL"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_kill.3:29
msgid "pthread_kill - send a signal to a thread"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_kill.3:32 build/C/man3/pthread_sigmask.3:32
#, no-wrap
msgid "B<#include E<lt>signal.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_kill.3:34
#, no-wrap
msgid "B<int pthread_kill(pthread_t >I<thread>B<, int >I<sig>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_kill.3:45
msgid "B<pthread_kill>():"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_kill.3:47 build/C/man3/pthread_sigmask.3:48
msgid "_POSIX_C_SOURCE\\ E<gt>=\\ 199506L || _XOPEN_SOURCE\\ E<gt>=\\ 500"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_kill.3:59
msgid ""
"The B<pthread_kill>()  function sends the signal I<sig> to I<thread>, a "
"thread in the same process as the caller.  The signal is asynchronously "
"directed to I<thread>."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_kill.3:63
msgid ""
"If I<sig> is 0, then no signal is sent, but error checking is still "
"performed."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_kill.3:68
msgid ""
"On success, B<pthread_kill>()  returns 0; on error, it returns an error "
"number, and no signal is sent."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_kill.3:72
msgid "An invalid signal was specified."
msgstr ""

#. type: tbl table
#: build/C/man3/pthread_kill.3:82
#, no-wrap
msgid "B<pthread_kill>()"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_kill.3:93
msgid ""
"Signal dispositions are process-wide: if a signal handler is installed, the "
"handler will be invoked in the thread I<thread>, but if the disposition of "
"the signal is \"stop\", \"continue\", or \"terminate\", this action will "
"affect the whole process."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_kill.3:103
msgid ""
"The glibc implementation of B<pthread_kill>()  gives an error (B<EINVAL>)  "
"on attempts to send either of the real-time signals used internally by the "
"NPTL threading implementation.  See B<nptl>(7)  for details."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_kill.3:116
msgid ""
"POSIX.1-2008 recommends that if an implementation detects the use of a "
"thread ID after the end of its lifetime, B<pthread_kill>()  should return "
"the error B<ESRCH>.  The glibc implementation returns this error in the "
"cases where an invalid thread ID can be detected.  But note also that POSIX "
"says that an attempt to use a thread ID whose lifetime has ended produces "
"undefined behavior, and an attempt to use an invalid thread ID in a call to "
"B<pthread_kill>()  can, for example, cause a segmentation fault."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_kill.3:125
msgid ""
"B<kill>(2), B<sigaction>(2), B<sigpending>(2), B<pthread_self>(3), "
"B<pthread_sigmask>(3), B<raise>(3), B<pthreads>(7), B<signal>(7)"
msgstr ""

#. type: TH
#: build/C/man3/pthread_kill_other_threads_np.3:26
#, no-wrap
msgid "PTHREAD_KILL_OTHER_THREADS_NP"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_kill_other_threads_np.3:29
msgid "pthread_kill_other_threads_np - terminate all other threads in process"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_kill_other_threads_np.3:34
#, no-wrap
msgid "B<void pthread_kill_other_threads_np(void);>\n"
msgstr ""

#.  .SH VERSIONS
#.  Available since glibc 2.0
#. type: Plain text
#: build/C/man3/pthread_kill_other_threads_np.3:47
msgid ""
"B<pthread_kill_other_threads_np>()  has an effect only in the LinuxThreads "
"threading implementation.  On that implementation, calling this function "
"causes the immediate termination of all threads in the application, except "
"the calling thread.  The cancellation state and cancellation type of the "
"to-be-terminated threads are ignored, and the cleanup handlers are not "
"called in those threads."
msgstr ""

#. type: tbl table
#: build/C/man3/pthread_kill_other_threads_np.3:57
#, no-wrap
msgid "B<pthread_kill_other_threads_np>()"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_kill_other_threads_np.3:71
msgid ""
"B<pthread_kill_other_threads_np>()  is intended to be called just before a "
"thread calls B<execve>(2)  or a similar function.  This function is designed "
"to address a limitation in the obsolete LinuxThreads implementation whereby "
"the other threads of an application are not automatically terminated (as "
"POSIX.1-2001 requires) during B<execve>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_kill_other_threads_np.3:78
msgid ""
"In the NPTL threading implementation, B<pthread_kill_other_threads_np>()  "
"exists, but does nothing.  (Nothing needs to be done, because the "
"implementation does the right thing during an B<execve>(2).)"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_kill_other_threads_np.3:84
msgid ""
"B<execve>(2), B<pthread_cancel>(3), B<pthread_setcancelstate>(3), "
"B<pthread_setcanceltype>(3), B<pthreads>(7)"
msgstr ""

#. type: TH
#: build/C/man3/pthread_rwlockattr_setkind_np.3:25
#, no-wrap
msgid "PTHREAD_RWLOCKATTR_SETKIND_NP"
msgstr ""

#. type: TH
#: build/C/man3/pthread_rwlockattr_setkind_np.3:25 build/C/man3/pthread_atfork.3:25
#, no-wrap
msgid "2020-08-13"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_rwlockattr_setkind_np.3:29
msgid ""
"pthread_rwlockattr_setkind_np, pthread_rwlockattr_getkind_np - set/get the "
"read-write lock kind of the thread read-write lock attribute object"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_rwlockattr_setkind_np.3:37
#, no-wrap
msgid ""
"B<int pthread_rwlockattr_setkind_np(pthread_rwlockattr_t *>I<attr>B<,>\n"
"B<                                   int >I<pref>B<);>\n"
"B<int pthread_rwlockattr_getkind_np(const pthread_rwlockattr_t "
"*>I<attr>B<,>\n"
"B<                                   int *>I<pref>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_rwlockattr_setkind_np.3:48
msgid "B<pthread_rwlockattr_setkind_np>(), B<pthread_rwlockattr_getkind_np>():"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_rwlockattr_setkind_np.3:52
msgid "_XOPEN_SOURCE\\ E<gt>=\\ 500 || _POSIX_C_SOURCE E<gt>= 200809L"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_rwlockattr_setkind_np.3:65
msgid ""
"The B<pthread_rwlockattr_setkind_np>()  function sets the \"lock kind\" "
"attribute of the read-write lock attribute object referred to by I<attr> to "
"the value specified in I<pref>.  The argument I<pref> may be set to one of "
"the following:"
msgstr ""

#. type: TP
#: build/C/man3/pthread_rwlockattr_setkind_np.3:65
#, no-wrap
msgid "B<PTHREAD_RWLOCK_PREFER_READER_NP>"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_rwlockattr_setkind_np.3:78
msgid ""
"This is the default.  A thread may hold multiple read locks; that is, read "
"locks are recursive.  According to The Single Unix Specification, the "
"behavior is unspecified when a reader tries to place a lock, and there is no "
"write lock but writers are waiting.  Giving preference to the reader, as is "
"set by B<PTHREAD_RWLOCK_PREFER_READER_NP>, implies that the reader will "
"receive the requested lock, even if a writer is waiting.  As long as there "
"are readers, the writer will be starved."
msgstr ""

#. type: TP
#: build/C/man3/pthread_rwlockattr_setkind_np.3:78
#, no-wrap
msgid "B<PTHREAD_RWLOCK_PREFER_WRITER_NP>"
msgstr ""

#.  ---
#.  Here is the relevant wording:
#
#.      A thread may hold multiple concurrent read locks on rwlock (that is,
#.      successfully call the pthread_rwlock_rdlock() function n times). If
#.      so, the thread must perform matching unlocks (that is, it must call
#.      the pthread_rwlock_unlock() function n times).
#
#.  By making write-priority work correctly, I broke the above requirement,
#.  because I had no clue that recursive read locks are permissible.
#
#.  If a thread which holds a read lock tries to acquire another read lock,
#.  and now one or more writers is waiting for a write lock, then the algorithm
#.  will lead to an obvious deadlock. The reader will be suspended, waiting for
#.  the writers to acquire and release the lock, and the writers will be
#.  suspended waiting for every existing read lock to be released.
#.  ---
#.  https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_rwlock_rdlock.html
#.  https://sourceware.org/legacy-ml/libc-alpha/2000-01/msg00055.html
#.  https://sourceware.org/bugzilla/show_bug.cgi?id=7057
#. type: Plain text
#: build/C/man3/pthread_rwlockattr_setkind_np.3:108
msgid ""
"This is intended as the write lock analog of "
"B<PTHREAD_RWLOCK_PREFER_READER_NP>.  This is ignored by glibc because the "
"POSIX requirement to support recursive read locks would cause this option to "
"create trivial deadlocks; instead use "
"B<PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP> which ensures the "
"application developer will not take recursive read locks thus avoiding "
"deadlocks."
msgstr ""

#. type: TP
#: build/C/man3/pthread_rwlockattr_setkind_np.3:108
#, no-wrap
msgid "B<PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP>"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_rwlockattr_setkind_np.3:113
msgid ""
"Setting the lock kind to this avoids writer starvation as long as any read "
"locking is not done in a recursive fashion."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_rwlockattr_setkind_np.3:121
msgid ""
"The B<pthread_rwlockattr_getkind_np>()  function returns the value of the "
"lock kind attribute of the read-write lock attribute object referred to by "
"I<attr> in the pointer I<pref>."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_rwlockattr_setkind_np.3:129
msgid ""
"On success, these functions return 0.  Given valid pointer arguments, "
"B<pthread_rwlockattr_getkind_np>()  always succeeds.  On error, "
"B<pthread_rwlockattr_setkind_np>()  returns a nonzero error number."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_rwlockattr_setkind_np.3:134
msgid "I<pref> specifies an unsupported value."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_rwlockattr_setkind_np.3:140
msgid ""
"The B<pthread_rwlockattr_getkind_np>()  and "
"B<pthread_rwlockattr_setkind_np>()  functions first appeared in glibc 2.1."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_rwlockattr_setkind_np.3:143
msgid ""
"These functions are non-standard GNU extensions; hence the suffix \"_np\" "
"(nonportable) in the names."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_rwlockattr_setkind_np.3:145
msgid "B<pthreads>(7)"
msgstr ""

#. type: TH
#: build/C/man3/pthread_self.3:26
#, no-wrap
msgid "PTHREAD_SELF"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_self.3:29
msgid "pthread_self - obtain ID of the calling thread"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_self.3:34
#, no-wrap
msgid "B<pthread_t pthread_self(void);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_self.3:46
msgid ""
"The B<pthread_self>()  function returns the ID of the calling thread.  This "
"is the same value that is returned in I<*thread> in the B<pthread_create>(3)  "
"call that created this thread."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_self.3:48
msgid "This function always succeeds, returning the calling thread's ID."
msgstr ""

#. type: tbl table
#: build/C/man3/pthread_self.3:60
#, no-wrap
msgid "B<pthread_self>()"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_self.3:75
msgid ""
"POSIX.1 allows an implementation wide freedom in choosing the type used to "
"represent a thread ID; for example, representation using either an "
"arithmetic type or a structure is permitted.  Therefore, variables of type "
"I<pthread_t> can't portably be compared using the C equality operator "
"(B<==>); use B<pthread_equal>(3)  instead."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_self.3:79
msgid ""
"Thread identifiers should be considered opaque: any attempt to use a thread "
"ID other than in pthreads calls is nonportable and can lead to unspecified "
"results."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_self.3:83
msgid ""
"Thread IDs are guaranteed to be unique only within a process.  A thread ID "
"may be reused after a terminated thread has been joined, or a detached "
"thread has terminated."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_self.3:88
msgid ""
"The thread ID returned by B<pthread_self>()  is not the same thing as the "
"kernel thread ID returned by a call to B<gettid>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_self.3:92
msgid "B<pthread_create>(3), B<pthread_equal>(3), B<pthreads>(7)"
msgstr ""

#. type: TH
#: build/C/man3/pthread_setaffinity_np.3:26
#, no-wrap
msgid "PTHREAD_SETAFFINITY_NP"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:30
msgid ""
"pthread_setaffinity_np, pthread_getaffinity_np - set/get CPU affinity of a "
"thread"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:39
#, no-wrap
msgid ""
"B<int pthread_setaffinity_np(pthread_t >I<thread>B<, size_t "
">I<cpusetsize>B<,>\n"
"B<                           const cpu_set_t *>I<cpuset>B<);>\n"
"B<int pthread_getaffinity_np(pthread_t >I<thread>B<, size_t "
">I<cpusetsize>B<,>\n"
"B<                           cpu_set_t *>I<cpuset>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:54
msgid ""
"The B<pthread_setaffinity_np>()  function sets the CPU affinity mask of the "
"thread I<thread> to the CPU set pointed to by I<cpuset>.  If the call is "
"successful, and the thread is not currently running on one of the CPUs in "
"I<cpuset>, then it is migrated to one of those CPUs."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:61
msgid ""
"The B<pthread_getaffinity_np>()  function returns the CPU affinity mask of "
"the thread I<thread> in the buffer pointed to by I<cpuset>."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:77
msgid ""
"The argument I<cpusetsize> is the length (in bytes) of the buffer pointed to "
"by I<cpuset>.  Typically, this argument would be specified as "
"I<sizeof(cpu_set_t)>.  (It may be some other value, if using the macros "
"described in B<CPU_SET>(3)  for dynamically allocating a CPU set.)"
msgstr ""

#. type: TP
#: build/C/man3/pthread_setaffinity_np.3:81
#, no-wrap
msgid "B<EFAULT>"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:84
msgid "A supplied memory address was invalid."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:93
msgid ""
"(B<pthread_setaffinity_np>())  The affinity bit mask I<mask> contains no "
"processors that are currently physically on the system and permitted to the "
"thread according to any restrictions that may be imposed by the \"cpuset\" "
"mechanism described in B<cpuset>(7)."
msgstr ""

#.  cpumask_t
#.  The raw sched_getaffinity() system call returns the size (in bytes)
#.  of the cpumask_t type.
#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:105
msgid ""
"(B<pthread_setaffinity_np>())  I<cpuset> specified a CPU that was outside "
"the set supported by the kernel.  (The kernel configuration option "
"B<CONFIG_NR_CPUS> defines the range of the set supported by the kernel data "
"type used to represent CPU sets.)"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:110
msgid ""
"(B<pthread_getaffinity_np>())  I<cpusetsize> is smaller than the size of the "
"affinity mask used by the kernel."
msgstr ""

#. type: tbl table
#: build/C/man3/pthread_setaffinity_np.3:128
#, no-wrap
msgid ""
"B<pthread_setaffinity_np>(),\n"
"B<pthread_getaffinity_np>()"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:146
msgid ""
"After a call to B<pthread_setaffinity_np>(), the set of CPUs on which the "
"thread will actually run is the intersection of the set specified in the "
"I<cpuset> argument and the set of CPUs actually present on the system.  The "
"system may further restrict the set of CPUs on which the thread runs if the "
"\"cpuset\" mechanism described in B<cpuset>(7)  is being used.  These "
"restrictions on the actual set of CPUs on which the thread will run are "
"silently imposed by the kernel."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:152
msgid ""
"These functions are implemented on top of the B<sched_setaffinity>(2)  and "
"B<sched_getaffinity>(2)  system calls."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:163
msgid ""
"A new thread created by B<pthread_create>(3)  inherits a copy of its "
"creator's CPU affinity mask."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:171
msgid ""
"In the following program, the main thread uses B<pthread_setaffinity_np>()  "
"to set its CPU affinity mask to include CPUs 0 to 7 (which may not all be "
"available on the system), and then calls B<pthread_getaffinity_np>()  to "
"check the resulting CPU affinity mask of the thread."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:178 build/C/man3/pthread_getattr_default_np.3:125
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:188
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int s;\n"
"    cpu_set_t cpuset;\n"
"    pthread_t thread;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:190
#, no-wrap
msgid "    thread = pthread_self();\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:192
#, no-wrap
msgid "    /* Set affinity mask to include CPUs 0 to 7 */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:196
#, no-wrap
msgid ""
"    CPU_ZERO(&cpuset);\n"
"    for (int j = 0; j E<lt> 8; j++)\n"
"        CPU_SET(j, &cpuset);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:200
#, no-wrap
msgid ""
"    s = pthread_setaffinity_np(thread, sizeof(cpuset), &cpuset);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_setaffinity_np\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:202
#, no-wrap
msgid "    /* Check the actual affinity mask assigned to the thread */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:206
#, no-wrap
msgid ""
"    s = pthread_getaffinity_np(thread, sizeof(cpuset), &cpuset);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_getaffinity_np\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:211
#, no-wrap
msgid ""
"    printf(\"Set returned by pthread_getaffinity_np() contained:\\en\");\n"
"    for (int j = 0; j E<lt> CPU_SETSIZE; j++)\n"
"        if (CPU_ISSET(j, &cpuset))\n"
"            printf(\"    CPU %d\\en\", j);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:214 build/C/man3/pthread_setschedparam.3:445 build/C/man3/pthread_getattr_default_np.3:195
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:224
msgid ""
"B<sched_setaffinity>(2), B<CPU_SET>(3), B<pthread_attr_setaffinity_np>(3), "
"B<pthread_self>(3), B<sched_getcpu>(3), B<cpuset>(7), B<pthreads>(7), "
"B<sched>(7)"
msgstr ""

#. type: TH
#: build/C/man3/pthread_setcancelstate.3:26
#, no-wrap
msgid "PTHREAD_SETCANCELSTATE"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:30
msgid ""
"pthread_setcancelstate, pthread_setcanceltype - set cancelability state and "
"type"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:36
#, no-wrap
msgid ""
"B<int pthread_setcancelstate(int >I<state>B<, int *>I<oldstate>B<);>\n"
"B<int pthread_setcanceltype(int >I<type>B<, int *>I<oldtype>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:51
msgid ""
"The B<pthread_setcancelstate>()  sets the cancelability state of the calling "
"thread to the value given in I<state>.  The previous cancelability state of "
"the thread is returned in the buffer pointed to by I<oldstate>.  The "
"I<state> argument must have one of the following values:"
msgstr ""

#. type: TP
#: build/C/man3/pthread_setcancelstate.3:51
#, no-wrap
msgid "B<PTHREAD_CANCEL_ENABLE>"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:58
msgid ""
"The thread is cancelable.  This is the default cancelability state in all "
"new threads, including the initial thread.  The thread's cancelability type "
"determines when a cancelable thread will respond to a cancellation request."
msgstr ""

#. type: TP
#: build/C/man3/pthread_setcancelstate.3:58
#, no-wrap
msgid "B<PTHREAD_CANCEL_DISABLE>"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:63
msgid ""
"The thread is not cancelable.  If a cancellation request is received, it is "
"blocked until cancelability is enabled."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:75
msgid ""
"The B<pthread_setcanceltype>()  sets the cancelability type of the calling "
"thread to the value given in I<type>.  The previous cancelability type of "
"the thread is returned in the buffer pointed to by I<oldtype>.  The I<type> "
"argument must have one of the following values:"
msgstr ""

#. type: TP
#: build/C/man3/pthread_setcancelstate.3:75
#, no-wrap
msgid "B<PTHREAD_CANCEL_DEFERRED>"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:82
msgid ""
"A cancellation request is deferred until the thread next calls a function "
"that is a cancellation point (see B<pthreads>(7)).  This is the default "
"cancelability type in all new threads, including the initial thread."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:87
msgid ""
"Even with deferred cancellation, a cancellation point in an asynchronous "
"signal handler may still be acted upon and the effect is as if it was an "
"asynchronous cancellation."
msgstr ""

#. type: TP
#: build/C/man3/pthread_setcancelstate.3:87
#, no-wrap
msgid "B<PTHREAD_CANCEL_ASYNCHRONOUS>"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:93
msgid ""
"The thread can be canceled at any time.  (Typically, it will be canceled "
"immediately upon receiving a cancellation request, but the system doesn't "
"guarantee this.)"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:97
msgid ""
"The set-and-get operation performed by each of these functions is atomic "
"with respect to other threads in the process calling the same function."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:104
msgid "The B<pthread_setcancelstate>()  can fail with the following error:"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:108
msgid "Invalid value for I<state>."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:112
msgid "The B<pthread_setcanceltype>()  can fail with the following error:"
msgstr ""

#.  .SH VERSIONS
#.  Available since glibc 2.0
#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:118
msgid "Invalid value for I<type>."
msgstr ""

#. type: tbl table
#: build/C/man3/pthread_setcancelstate.3:130 build/C/man3/pthread_setcancelstate.3:136
#, no-wrap
msgid ""
"B<pthread_setcancelstate>(),\n"
"B<pthread_setcanceltype>()"
msgstr ""

#. type: tbl table
#: build/C/man3/pthread_setcancelstate.3:136
#, no-wrap
msgid "Async-cancel-safety"
msgstr ""

#. type: tbl table
#: build/C/man3/pthread_setcancelstate.3:138
#, no-wrap
msgid "AC-Safe"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:147
msgid ""
"For details of what happens when a thread is canceled, see "
"B<pthread_cancel>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:154
msgid ""
"Briefly disabling cancelability is useful if a thread performs some critical "
"action that must not be interrupted by a cancellation request.  Beware of "
"disabling cancelability for long periods, or around operations that may "
"block for long periods, since that will render the thread unresponsive to "
"cancellation requests."
msgstr ""

#. type: SS
#: build/C/man3/pthread_setcancelstate.3:154
#, no-wrap
msgid "Asynchronous cancelability"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:173
msgid ""
"Setting the cancelability type to B<PTHREAD_CANCEL_ASYNCHRONOUS> is rarely "
"useful.  Since the thread could be canceled at I<any> time, it cannot safely "
"reserve resources (e.g., allocating memory with B<malloc>(3)), acquire "
"mutexes, semaphores, or locks, and so on.  Reserving resources is unsafe "
"because the application has no way of knowing what the state of these "
"resources is when the thread is canceled; that is, did cancellation occur "
"before the resources were reserved, while they were reserved, or after they "
"were released? Furthermore, some internal data structures (e.g., the linked "
"list of free blocks managed by the B<malloc>(3)  family of functions) may be "
"left in an inconsistent state if cancellation occurs in the middle of the "
"function call.  Consequently, clean-up handlers cease to be useful."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:184
msgid ""
"Functions that can be safely asynchronously canceled are called "
"I<async-cancel-safe functions>.  POSIX.1-2001 and POSIX.1-2008 require only "
"that B<pthread_cancel>(3), B<pthread_setcancelstate>(), and "
"B<pthread_setcanceltype>()  be async-cancel-safe.  In general, other library "
"functions can't be safely called from an asynchronously cancelable thread."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:187
msgid ""
"One of the few circumstances in which asynchronous cancelability is useful "
"is for cancellation of a thread that is in a pure compute-bound loop."
msgstr ""

#. type: SS
#: build/C/man3/pthread_setcancelstate.3:187
#, no-wrap
msgid "Portability notes"
msgstr ""

#.  It looks like at least Solaris, FreeBSD and Tru64 support this.
#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:205
msgid ""
"The Linux threading implementations permit the I<oldstate> argument of "
"B<pthread_setcancelstate>()  to be NULL, in which case the information about "
"the previous cancelability state is not returned to the caller.  Many other "
"implementations also permit a NULL I<oldstat> argument, but POSIX.1 does not "
"specify this point, so portable applications should always specify a "
"non-NULL value in I<oldstate>.  A precisely analogous set of statements "
"applies for the I<oldtype> argument of B<pthread_setcanceltype>()."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:208
msgid "See B<pthread_cancel>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:213
msgid ""
"B<pthread_cancel>(3), B<pthread_cleanup_push>(3), B<pthread_testcancel>(3), "
"B<pthreads>(7)"
msgstr ""

#. type: TH
#: build/C/man3/pthread_setconcurrency.3:25
#, no-wrap
msgid "PTHREAD_SETCONCURRENCY"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setconcurrency.3:29
msgid ""
"pthread_setconcurrency, pthread_getconcurrency - set/get the concurrency "
"level"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setconcurrency.3:35
#, no-wrap
msgid ""
"B<int pthread_setconcurrency(int >I<new_level>B<);>\n"
"B<int pthread_getconcurrency(>I<void>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setconcurrency.3:48
msgid ""
"The B<pthread_setconcurrency>()  function informs the implementation of the "
"application's desired concurrency level, specified in I<new_level>.  The "
"implementation takes this only as a hint: POSIX.1 does not specify the level "
"of concurrency that should be provided as a result of calling "
"B<pthread_setconcurrency>()."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setconcurrency.3:53
msgid ""
"Specifying I<new_level> as 0 instructs the implementation to manage the "
"concurrency level as it deems appropriate."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setconcurrency.3:56
msgid ""
"B<pthread_getconcurrency>()  returns the current value of the concurrency "
"level for this process."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setconcurrency.3:61
msgid ""
"On success, B<pthread_setconcurrency>()  returns 0; on error, it returns a "
"nonzero error number."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setconcurrency.3:68
msgid ""
"B<pthread_getconcurrency>()  always succeeds, returning the concurrency "
"level set by a previous call to B<pthread_setconcurrency>(), or 0, if "
"B<pthread_setconcurrency>()  has not previously been called."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setconcurrency.3:71
msgid "B<pthread_setconcurrency>()  can fail with the following error:"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setconcurrency.3:75
msgid "I<new_level> is negative."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setconcurrency.3:81
msgid ""
"POSIX.1 also documents an B<EAGAIN> error (\"the value specified by "
"I<new_level> would cause a system resource to be exceeded\")."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setconcurrency.3:83
msgid "These functions are available in glibc since version 2.1."
msgstr ""

#. type: tbl table
#: build/C/man3/pthread_setconcurrency.3:94
#, no-wrap
msgid ""
"B<pthread_setconcurrency>(),\n"
"B<pthread_getconcurrency>()"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setconcurrency.3:100
msgid "The default concurrency level is 0."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setconcurrency.3:107
msgid ""
"Concurrency levels are meaningful only for M:N threading implementations, "
"where at any moment a subset of a process's set of user-level threads may be "
"bound to a smaller number of kernel-scheduling entities.  Setting the "
"concurrency level allows the application to give the system a hint as to the "
"number of kernel-scheduling entities that should be provided for efficient "
"execution of the application."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setconcurrency.3:113
msgid ""
"Both LinuxThreads and NPTL are 1:1 threading implementations, so setting the "
"concurrency level has no meaning.  In other words, on Linux these functions "
"merely exist for compatibility with other systems, and they have no effect "
"on the execution of a program."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setconcurrency.3:116
msgid "B<pthread_attr_setscope>(3), B<pthreads>(7)"
msgstr ""

#. type: TH
#: build/C/man3/pthread_setname_np.3:26
#, no-wrap
msgid "PTHREAD_SETNAME_NP"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setname_np.3:29
msgid "pthread_setname_np, pthread_getname_np - set/get the name of a thread"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setname_np.3:36
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>pthread.hE<gt>>\n"
"B<int pthread_setname_np(pthread_t >I<thread>B<, const char *>I<name>B<);>\n"
"B<int pthread_getname_np(pthread_t >I<thread>B<,>\n"
"B<                       char *>I<name>B<, size_t >I<len>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setname_np.3:55
msgid ""
"By default, all the threads created using B<pthread_create>()  inherit the "
"program name.  The B<pthread_setname_np>()  function can be used to set a "
"unique name for a thread, which can be useful for debugging multithreaded "
"applications.  The thread name is a meaningful C language string, whose "
"length is restricted to 16 characters, including the terminating null byte "
"(\\(aq\\e0\\(aq).  The I<thread> argument specifies the thread whose name is "
"to be changed; I<name> specifies the new name."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setname_np.3:72
msgid ""
"The B<pthread_getname_np>()  function can be used to retrieve the name of "
"the thread.  The I<thread> argument specifies the thread whose name is to be "
"retrieved.  The buffer I<name> is used to return the thread name; I<len> "
"specifies the number of bytes available in I<name>.  The buffer specified by "
"I<name> should be at least 16 characters in length.  The returned thread "
"name in the output buffer will be null terminated."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setname_np.3:79
msgid "The B<pthread_setname_np>()  function can fail with the following error:"
msgstr ""

#. type: TP
#: build/C/man3/pthread_setname_np.3:79 build/C/man3/pthread_setname_np.3:88
#, no-wrap
msgid "B<ERANGE>"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setname_np.3:84
msgid ""
"The length of the string specified pointed to by I<name> exceeds the allowed "
"limit."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setname_np.3:88
msgid "The B<pthread_getname_np>()  function can fail with the following error:"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setname_np.3:95
msgid ""
"The buffer specified by I<name> and I<len> is too small to hold the thread "
"name."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setname_np.3:100
msgid ""
"If either of these functions fails to open I</proc/self/task/[tid]/comm>, "
"then the call may fail with one of the errors described in B<open>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setname_np.3:102
msgid "These functions first appeared in glibc in version 2.12."
msgstr ""

#. type: tbl table
#: build/C/man3/pthread_setname_np.3:113
#, no-wrap
msgid ""
"B<pthread_setname_np>(),\n"
"B<pthread_getname_np>()"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setname_np.3:129
msgid ""
"B<pthread_setname_np>()  internally writes to the thread-specific I<comm> "
"file under the I</proc> filesystem: I</proc/self/task/[tid]/comm>.  "
"B<pthread_getname_np>()  retrieves it from the same location."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setname_np.3:134
msgid ""
"The program below demonstrates the use of B<pthread_setname_np>()  and "
"B<pthread_getname_np>()."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setname_np.3:136
msgid "The following shell session shows a sample run of the program:"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setname_np.3:152
#, no-wrap
msgid ""
"$B< ./a.out>\n"
"Created a thread. Default name is: a.out\n"
"The thread name after setting it is THREADFOO.\n"
"B<\\(haZ>                           # Suspend the program\n"
"[1]+  Stopped           ./a.out\n"
"$ B<ps H -C a.out -o \\(aqpid tid cmd comm\\(aq>\n"
"  PID   TID CMD                         COMMAND\n"
" 5990  5990 ./a.out                     a.out\n"
" 5990  5991 ./a.out                     THREADFOO\n"
"$ B<cat /proc/5990/task/5990/comm>\n"
"a.out\n"
"$ B<cat /proc/5990/task/5991/comm>\n"
"THREADFOO\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setname_np.3:164
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setname_np.3:166
#, no-wrap
msgid "#define NAMELEN 16\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setname_np.3:170 build/C/man3/pthread_getattr_default_np.3:129
#, no-wrap
msgid ""
"#define errExitEN(en, msg) \\e\n"
"                        do { errno = en; perror(msg); \\e\n"
"                             exit(EXIT_FAILURE); } while (0)\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setname_np.3:177
#, no-wrap
msgid ""
"static void *\n"
"threadfunc(void *parm)\n"
"{\n"
"    sleep(5);          // allow main program to set the thread name\n"
"    return NULL;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setname_np.3:184
#, no-wrap
msgid ""
"int\n"
"main(int argc, char **argv)\n"
"{\n"
"    pthread_t thread;\n"
"    int rc;\n"
"    char thread_name[NAMELEN];\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setname_np.3:188
#, no-wrap
msgid ""
"    rc = pthread_create(&thread, NULL, threadfunc, NULL);\n"
"    if (rc != 0)\n"
"        errExitEN(rc, \"pthread_create\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setname_np.3:192
#, no-wrap
msgid ""
"    rc = pthread_getname_np(thread, thread_name, NAMELEN);\n"
"    if (rc != 0)\n"
"        errExitEN(rc, \"pthread_getname_np\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setname_np.3:197
#, no-wrap
msgid ""
"    printf(\"Created a thread. Default name is: %s\\en\", thread_name);\n"
"    rc = pthread_setname_np(thread, (argc E<gt> 1) ? argv[1] : "
"\"THREADFOO\");\n"
"    if (rc != 0)\n"
"        errExitEN(rc, \"pthread_setname_np\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setname_np.3:199 build/C/man3/pthread_mutexattr_setrobust.3:250
#, no-wrap
msgid "    sleep(2);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setname_np.3:205
#, no-wrap
msgid ""
"    rc = pthread_getname_np(thread, thread_name,\n"
"                            (argc E<gt> 2) ? atoi(argv[1]) : NAMELEN);\n"
"    if (rc != 0)\n"
"        errExitEN(rc, \"pthread_getname_np\");\n"
"    printf(\"The thread name after setting it is %s.\\en\", thread_name);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setname_np.3:209
#, no-wrap
msgid ""
"    rc = pthread_join(thread, NULL);\n"
"    if (rc != 0)\n"
"        errExitEN(rc, \"pthread_join\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setname_np.3:213
#, no-wrap
msgid ""
"    printf(\"Done\\en\");\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setname_np.3:220
msgid "B<prctl>(2), B<pthread_create>(3), B<pthreads>(7)"
msgstr ""

#. type: TH
#: build/C/man3/pthread_setschedparam.3:26
#, no-wrap
msgid "PTHREAD_SETSCHEDPARAM"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:30
msgid ""
"pthread_setschedparam, pthread_getschedparam - set/get scheduling policy and "
"parameters of a thread"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:38
#, no-wrap
msgid ""
"B<int pthread_setschedparam(pthread_t >I<thread>B<, int >I<policy>B<,>\n"
"B<                          const struct sched_param *>I<param>B<);>\n"
"B<int pthread_getschedparam(pthread_t >I<thread>B<, int *>I<policy>B<,>\n"
"B<                          struct sched_param *>I<param>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:46
msgid ""
"The B<pthread_setschedparam>()  function sets the scheduling policy and "
"parameters of the thread I<thread>."
msgstr ""

#.  FIXME . pthread_setschedparam() places no restriction on the policy,
#.  but pthread_attr_setschedpolicy() restricts policy to RR/FIFO/OTHER
#.  http://sourceware.org/bugzilla/show_bug.cgi?id=7013
#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:57
msgid ""
"I<policy> specifies the new scheduling policy for I<thread>.  The supported "
"values for I<policy>, and their semantics, are described in B<sched>(7)."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:63
msgid ""
"The structure pointed to by I<param> specifies the new scheduling parameters "
"for I<thread>.  Scheduling parameters are maintained in the following "
"structure:"
msgstr ""

#.  FIXME . nptl/pthread_setschedparam.c has the following
#.    /* If the thread should have higher priority because of some
#.       PTHREAD_PRIO_PROTECT mutexes it holds, adjust the priority. */
#.  Eventually (perhaps after writing the mutexattr pages), we
#.  may want to add something on the topic to this page.
#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:104
msgid ""
"The B<pthread_getschedparam>()  function returns the scheduling policy and "
"parameters of the thread I<thread>, in the buffers pointed to by I<policy> "
"and I<param>, respectively.  The returned priority value is that set by the "
"most recent B<pthread_setschedparam>(), B<pthread_setschedprio>(3), or "
"B<pthread_create>(3)  call that affected I<thread>.  The returned priority "
"does not reflect any temporary priority adjustments as a result of calls to "
"any priority inheritance or priority ceiling functions (see, for example, "
"B<pthread_mutexattr_setprioceiling>(3)  and "
"B<pthread_mutexattr_setprotocol>(3))."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:112
msgid ""
"On success, these functions return 0; on error, they return a nonzero error "
"number.  If B<pthread_setschedparam>()  fails, the scheduling policy and "
"parameters of I<thread> are not changed."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:114
msgid "Both of these functions can fail with the following error:"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:122
msgid "B<pthread_setschedparam>()  may additionally fail with the following errors:"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:129
msgid ""
"I<policy> is not a recognized policy, or I<param> does not make sense for "
"the I<policy>."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:133
msgid ""
"The caller does not have appropriate privileges to set the specified "
"scheduling policy and parameters."
msgstr ""

#.  .SH VERSIONS
#.  Available since glibc 2.0
#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:141
msgid ""
"POSIX.1 also documents an B<ENOTSUP> (\"attempt was made to set the policy "
"or scheduling parameters to an unsupported value\") error for "
"B<pthread_setschedparam>()."
msgstr ""

#. type: tbl table
#: build/C/man3/pthread_setschedparam.3:152
#, no-wrap
msgid ""
"B<pthread_setschedparam>(),\n"
"B<pthread_getschedparam>()"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:162
msgid ""
"For a description of the permissions required to, and the effect of, "
"changing a thread's scheduling policy and priority, and details of the "
"permitted ranges for priorities in each scheduling policy, see B<sched>(7)."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:169
msgid ""
"The program below demonstrates the use of B<pthread_setschedparam>()  and "
"B<pthread_getschedparam>(), as well as the use of a number of other "
"scheduling-related pthreads functions."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:185
msgid ""
"In the following run, the main thread sets its scheduling policy to "
"B<SCHED_FIFO> with a priority of 10, and initializes a thread attributes "
"object with a scheduling policy attribute of B<SCHED_RR> and a scheduling "
"priority attribute of 20.  The program then sets (using "
"B<pthread_attr_setinheritsched>(3))  the inherit scheduler attribute of the "
"thread attributes object to B<PTHREAD_EXPLICIT_SCHED>, meaning that threads "
"created using this attributes object should take their scheduling attributes "
"from the thread attributes object.  The program then creates a thread using "
"the thread attributes object, and that thread displays its scheduling policy "
"and priority."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:193
#, no-wrap
msgid ""
"$ B<su>      # Need privilege to set real-time scheduling policies\n"
"Password:\n"
"# B<./a.out -mf10 -ar20 -i e>\n"
"Scheduler settings of main thread\n"
"    policy=SCHED_FIFO, priority=10\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:197
#, no-wrap
msgid ""
"Scheduler settings in \\(aqattr\\(aq\n"
"    policy=SCHED_RR, priority=20\n"
"    inheritsched is EXPLICIT\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:200
#, no-wrap
msgid ""
"Scheduler attributes of new thread\n"
"    policy=SCHED_RR, priority=20\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:205
msgid ""
"In the above output, one can see that the scheduling policy and priority "
"were taken from the values specified in the thread attributes object."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:212
msgid ""
"The next run is the same as the previous, except that the inherit scheduler "
"attribute is set to B<PTHREAD_INHERIT_SCHED>, meaning that threads created "
"using the thread attributes object should ignore the scheduling attributes "
"specified in the attributes object and instead take their scheduling "
"attributes from the creating thread."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:218
#, no-wrap
msgid ""
"# B<./a.out -mf10 -ar20 -i i>\n"
"Scheduler settings of main thread\n"
"    policy=SCHED_FIFO, priority=10\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:222
#, no-wrap
msgid ""
"Scheduler settings in \\(aqattr\\(aq\n"
"    policy=SCHED_RR, priority=20\n"
"    inheritsched is INHERIT\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:225
#, no-wrap
msgid ""
"Scheduler attributes of new thread\n"
"    policy=SCHED_FIFO, priority=10\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:231
msgid ""
"In the above output, one can see that the scheduling policy and priority "
"were taken from the creating thread, rather than the thread attributes "
"object."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:237
msgid ""
"Note that if we had omitted the I<-i\\ i> option, the output would have been "
"the same, since B<PTHREAD_INHERIT_SCHED> is the default for the inherit "
"scheduler attribute."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:241
#, no-wrap
msgid "/* pthreads_sched_test.c */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:247
#, no-wrap
msgid ""
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:256
#, no-wrap
msgid ""
"static void\n"
"usage(char *prog_name, char *msg)\n"
"{\n"
"    if (msg != NULL)\n"
"        fputs(msg, stderr);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:273
#, no-wrap
msgid ""
"    fprintf(stderr, \"Usage: %s [options]\\en\", prog_name);\n"
"    fprintf(stderr, \"Options are:\\en\");\n"
"#define fpe(msg) fprintf(stderr, \"\\et%s\", msg);          /* Shorter */\n"
"    fpe(\"-aE<lt>policyE<gt>E<lt>prioE<gt> Set scheduling policy and "
"priority in\\en\");\n"
"    fpe(\"                 thread attributes object\\en\");\n"
"    fpe(\"                 E<lt>policyE<gt> can be\\en\");\n"
"    fpe(\"                     f  SCHED_FIFO\\en\");\n"
"    fpe(\"                     r  SCHED_RR\\en\");\n"
"    fpe(\"                     o  SCHED_OTHER\\en\");\n"
"    fpe(\"-A               Use default thread attributes object\\en\");\n"
"    fpe(\"-i {e|i}         Set inherit scheduler attribute to\\en\");\n"
"    fpe(\"                 \\(aqexplicit\\(aq or \\(aqinherit\\(aq\\en\");\n"
"    fpe(\"-mE<lt>policyE<gt>E<lt>prioE<gt> Set scheduling policy and "
"priority on\\en\");\n"
"    fpe(\"                 main thread before pthread_create() "
"call\\en\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:284
#, no-wrap
msgid ""
"static int\n"
"get_policy(char p, int *policy)\n"
"{\n"
"    switch (p) {\n"
"    case \\(aqf\\(aq: *policy = SCHED_FIFO;     return 1;\n"
"    case \\(aqr\\(aq: *policy = SCHED_RR;       return 1;\n"
"    case \\(aqo\\(aq: *policy = SCHED_OTHER;    return 1;\n"
"    default:  return 0;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:295
#, no-wrap
msgid ""
"static void\n"
"display_sched_attr(int policy, struct sched_param *param)\n"
"{\n"
"    printf(\"    policy=%s, priority=%d\\en\",\n"
"            (policy == SCHED_FIFO)  ? \"SCHED_FIFO\" :\n"
"            (policy == SCHED_RR)    ? \"SCHED_RR\" :\n"
"            (policy == SCHED_OTHER) ? \"SCHED_OTHER\" :\n"
"            \"???\",\n"
"            param-E<gt>sched_priority);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:301
#, no-wrap
msgid ""
"static void\n"
"display_thread_sched_attr(char *msg)\n"
"{\n"
"    int policy, s;\n"
"    struct sched_param param;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:305
#, no-wrap
msgid ""
"    s = pthread_getschedparam(pthread_self(), &policy, &param);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_getschedparam\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:309
#, no-wrap
msgid ""
"    printf(\"%s\\en\", msg);\n"
"    display_sched_attr(policy, &param);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:314
#, no-wrap
msgid ""
"static void *\n"
"thread_start(void *arg)\n"
"{\n"
"    display_thread_sched_attr(\"Scheduler attributes of new thread\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:317
#, no-wrap
msgid ""
"    return NULL;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:327
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int s, opt, inheritsched, use_null_attrib, policy;\n"
"    pthread_t thread;\n"
"    pthread_attr_t attr;\n"
"    pthread_attr_t *attrp;\n"
"    char *attr_sched_str, *main_sched_str, *inheritsched_str;\n"
"    struct sched_param param;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:329
#, no-wrap
msgid "    /* Process command-line options */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:334
#, no-wrap
msgid ""
"    use_null_attrib = 0;\n"
"    attr_sched_str = NULL;\n"
"    main_sched_str = NULL;\n"
"    inheritsched_str = NULL;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:344
#, no-wrap
msgid ""
"    while ((opt = getopt(argc, argv, \"a:Ai:m:\")) != -1) {\n"
"        switch (opt) {\n"
"        case \\(aqa\\(aq: attr_sched_str = optarg;      break;\n"
"        case \\(aqA\\(aq: use_null_attrib = 1;          break;\n"
"        case \\(aqi\\(aq: inheritsched_str = optarg;    break;\n"
"        case \\(aqm\\(aq: main_sched_str = optarg;      break;\n"
"        default:  usage(argv[0], \"Unrecognized option\\en\");\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:348
#, no-wrap
msgid ""
"    if (use_null_attrib &&\n"
"            (inheritsched_str != NULL || attr_sched_str != NULL))\n"
"        usage(argv[0], \"Can\\(aqt specify -A with -i or -a\\en\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:351
#, no-wrap
msgid ""
"    /* Optionally set scheduling attributes of main thread,\n"
"       and display the attributes */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:356
#, no-wrap
msgid ""
"    if (main_sched_str != NULL) {\n"
"        if (!get_policy(main_sched_str[0], &policy))\n"
"            usage(argv[0], \"Bad policy for main thread (-m)\\en\");\n"
"        param.sched_priority = strtol(&main_sched_str[1], NULL, 0);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:361
#, no-wrap
msgid ""
"        s = pthread_setschedparam(pthread_self(), policy, &param);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_setschedparam\");\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:364
#, no-wrap
msgid ""
"    display_thread_sched_attr(\"Scheduler settings of main thread\");\n"
"    printf(\"\\en\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:366
#, no-wrap
msgid "    /* Initialize thread attributes object according to options */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:375
#, no-wrap
msgid ""
"    if (!use_null_attrib) {\n"
"        s = pthread_attr_init(&attr);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_init\");\n"
"        attrp = &attr;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:383
#, no-wrap
msgid ""
"    if (inheritsched_str != NULL) {\n"
"        if (inheritsched_str[0] == \\(aqe\\(aq)\n"
"            inheritsched = PTHREAD_EXPLICIT_SCHED;\n"
"        else if (inheritsched_str[0] == \\(aqi\\(aq)\n"
"            inheritsched = PTHREAD_INHERIT_SCHED;\n"
"        else\n"
"            usage(argv[0], \"Value for -i must be \\(aqe\\(aq or "
"\\(aqi\\(aq\\en\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:388
#, no-wrap
msgid ""
"        s = pthread_attr_setinheritsched(&attr, inheritsched);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setinheritsched\");\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:394
#, no-wrap
msgid ""
"    if (attr_sched_str != NULL) {\n"
"        if (!get_policy(attr_sched_str[0], &policy))\n"
"            usage(argv[0],\n"
"                    \"Bad policy for \\(aqattr\\(aq (-a)\\en\");\n"
"        param.sched_priority = strtol(&attr_sched_str[1], NULL, 0);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:402
#, no-wrap
msgid ""
"        s = pthread_attr_setschedpolicy(&attr, policy);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setschedpolicy\");\n"
"        s = pthread_attr_setschedparam(&attr, &param);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setschedparam\");\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:405
#, no-wrap
msgid ""
"    /* If we initialized a thread attributes object, display\n"
"       the scheduling attributes that were set in the object */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:413
#, no-wrap
msgid ""
"    if (attrp != NULL) {\n"
"        s = pthread_attr_getschedparam(&attr, &param);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_getschedparam\");\n"
"        s = pthread_attr_getschedpolicy(&attr, &policy);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_getschedpolicy\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:416
#, no-wrap
msgid ""
"        printf(\"Scheduler settings in \\(aqattr\\(aq\\en\");\n"
"        display_sched_attr(policy, &param);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:424
#, no-wrap
msgid ""
"        s = pthread_attr_getinheritsched(&attr, &inheritsched);\n"
"        printf(\"    inheritsched is %s\\en\",\n"
"                (inheritsched == PTHREAD_INHERIT_SCHED)  ? \"INHERIT\" :\n"
"                (inheritsched == PTHREAD_EXPLICIT_SCHED) ? \"EXPLICIT\" :\n"
"                \"???\");\n"
"        printf(\"\\en\");\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:426
#, no-wrap
msgid "    /* Create a thread that will display its scheduling attributes */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:430
#, no-wrap
msgid ""
"    s = pthread_create(&thread, attrp, &thread_start, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_create\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:432
#, no-wrap
msgid "    /* Destroy unneeded thread attributes object */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:438
#, no-wrap
msgid ""
"    if (!use_null_attrib) {\n"
"      s = pthread_attr_destroy(&attr);\n"
"      if (s != 0)\n"
"          handle_error_en(s, \"pthread_attr_destroy\");\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:442
#, no-wrap
msgid ""
"    s = pthread_join(thread, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_join\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:460
msgid ""
"B<getrlimit>(2), B<sched_get_priority_min>(2), B<pthread_attr_init>(3), "
"B<pthread_attr_setinheritsched>(3), B<pthread_attr_setschedparam>(3), "
"B<pthread_attr_setschedpolicy>(3), B<pthread_create>(3), B<pthread_self>(3), "
"B<pthread_setschedprio>(3), B<pthreads>(7), B<sched>(7)"
msgstr ""

#. type: TH
#: build/C/man3/pthread_setschedprio.3:26
#, no-wrap
msgid "PTHREAD_SETSCHEDPRIO"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedprio.3:29
msgid "pthread_setschedprio - set scheduling priority of a thread"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedprio.3:34
#, no-wrap
msgid "B<int pthread_setschedprio(pthread_t >I<thread>B<, int >I<prio>B<);>\n"
msgstr ""

#.  FIXME . nptl/pthread_setschedprio.c has the following
#.    /* If the thread should have higher priority because of some
#.       PTHREAD_PRIO_PROTECT mutexes it holds, adjust the priority. */
#.  Eventually (perhaps after writing the mutexattr pages), we
#.  may want to add something on the topic to this page.
#.  nptl/pthread_setschedparam.c has a similar case.
#. type: Plain text
#: build/C/man3/pthread_setschedprio.3:53
msgid ""
"The B<pthread_setschedprio>()  function sets the scheduling priority of the "
"thread I<thread> to the value specified in I<prio>.  (By contrast "
"B<pthread_setschedparam>(3)  changes both the scheduling policy and priority "
"of a thread.)"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedprio.3:61
msgid ""
"On success, this function returns 0; on error, it returns a nonzero error "
"number.  If B<pthread_setschedprio>()  fails, the scheduling priority of "
"I<thread> is not changed."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedprio.3:66
msgid "I<prio> is not valid for the scheduling policy of the specified thread."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedprio.3:70
msgid ""
"The caller does not have appropriate privileges to set the specified "
"priority."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedprio.3:81
msgid ""
"POSIX.1 also documents an B<ENOTSUP> (\"attempt was made to set the priority "
"to an unsupported value\") error for B<pthread_setschedparam>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedprio.3:83
msgid "This function is available in glibc since version 2.3.4."
msgstr ""

#. type: tbl table
#: build/C/man3/pthread_setschedprio.3:93
#, no-wrap
msgid "B<pthread_setschedprio>()"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedprio.3:103
msgid ""
"For a description of the permissions required to, and the effect of, "
"changing a thread's scheduling priority, and details of the permitted ranges "
"for priorities in each scheduling policy, see B<sched>(7)."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setschedprio.3:117
msgid ""
"B<getrlimit>(2), B<sched_get_priority_min>(2), B<pthread_attr_init>(3), "
"B<pthread_attr_setinheritsched>(3), B<pthread_attr_setschedparam>(3), "
"B<pthread_attr_setschedpolicy>(3), B<pthread_create>(3), B<pthread_self>(3), "
"B<pthread_setschedparam>(3), B<pthreads>(7), B<sched>(7)"
msgstr ""

#. type: TH
#: build/C/man3/pthread_sigmask.3:26
#, no-wrap
msgid "PTHREAD_SIGMASK"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:29
msgid "pthread_sigmask - examine and change mask of blocked signals"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:35
#, no-wrap
msgid ""
"B<int pthread_sigmask(int >I<how>B<, const sigset_t *>I<set>B<, sigset_t "
"*>I<oldset>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:46
msgid "B<pthread_sigmask>():"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:58
msgid ""
"The B<pthread_sigmask>()  function is just like B<sigprocmask>(2), with the "
"difference that its use in multithreaded programs is explicitly specified by "
"POSIX.1.  Other differences are noted in this page."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:61
msgid ""
"For a description of the arguments and operation of this function, see "
"B<sigprocmask>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:66
msgid ""
"On success, B<pthread_sigmask>()  returns 0; on error, it returns an error "
"number."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:69
msgid "See B<sigprocmask>(2)."
msgstr ""

#. type: tbl table
#: build/C/man3/pthread_sigmask.3:79
#, no-wrap
msgid "B<pthread_sigmask>()"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:85
msgid "A new thread inherits a copy of its creator's signal mask."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:93
msgid ""
"The glibc B<pthread_sigmask>()  function silently ignores attempts to block "
"the two real-time signals that are used internally by the NPTL threading "
"implementation.  See B<nptl>(7)  for details."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:98
msgid ""
"The program below blocks some signals in the main thread, and then creates a "
"dedicated thread to fetch those signals via B<sigwait>(3).  The following "
"shell session demonstrates its use:"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:109
#, no-wrap
msgid ""
"$B< ./a.out &>\n"
"[1] 5423\n"
"$B< kill -QUIT %1>\n"
"Signal handling thread got signal 3\n"
"$B< kill -USR1 %1>\n"
"Signal handling thread got signal 10\n"
"$B< kill -TERM %1>\n"
"[1]+  Terminated              ./a.out\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:120
#, no-wrap
msgid ""
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:122
#, no-wrap
msgid "/* Simple error handling functions */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:131
#, no-wrap
msgid ""
"static void *\n"
"sig_thread(void *arg)\n"
"{\n"
"    sigset_t *set = arg;\n"
"    int s, sig;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:139
#, no-wrap
msgid ""
"    for (;;) {\n"
"        s = sigwait(set, &sig);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"sigwait\");\n"
"        printf(\"Signal handling thread got signal %d\\en\", sig);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:146
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pthread_t thread;\n"
"    sigset_t set;\n"
"    int s;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:149
#, no-wrap
msgid ""
"    /* Block SIGQUIT and SIGUSR1; other threads created by main()\n"
"       will inherit a copy of the signal mask. */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:156
#, no-wrap
msgid ""
"    sigemptyset(&set);\n"
"    sigaddset(&set, SIGQUIT);\n"
"    sigaddset(&set, SIGUSR1);\n"
"    s = pthread_sigmask(SIG_BLOCK, &set, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_sigmask\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:160
#, no-wrap
msgid ""
"    s = pthread_create(&thread, NULL, &sig_thread, &set);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_create\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:163
#, no-wrap
msgid ""
"    /* Main thread carries on to create other threads and/or do\n"
"       other work */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:166
#, no-wrap
msgid ""
"    pause();            /* Dummy pause so we can test program */\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:177
msgid ""
"B<sigaction>(2), B<sigpending>(2), B<sigprocmask>(2), "
"B<pthread_attr_setsigmask_np>(3), B<pthread_create>(3), B<pthread_kill>(3), "
"B<sigsetops>(3), B<pthreads>(7), B<signal>(7)"
msgstr ""

#. type: TH
#: build/C/man3/pthread_sigqueue.3:25
#, no-wrap
msgid "PTHREAD_SIGQUEUE"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_sigqueue.3:28
msgid "pthread_sigqueue - queue a signal and data to a thread"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_sigqueue.3:32
#, no-wrap
msgid ""
"B<#include E<lt>signal.hE<gt>>\n"
"B<#include E<lt>pthread.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_sigqueue.3:35
#, no-wrap
msgid ""
"B<int pthread_sigqueue(pthread_t >I<thread>B<, int >I<sig>B<,>\n"
"B<                     const union sigval >I<value>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_sigqueue.3:46
msgid "B<pthread_sigqueue>(): _GNU_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_sigqueue.3:54
msgid ""
"The B<pthread_sigqueue>()  function performs a similar task to "
"B<sigqueue>(3), but, rather than sending a signal to a process, it sends a "
"signal to a thread in the same process as the calling thread."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_sigqueue.3:66
msgid ""
"The I<thread> argument is the ID of a thread in the same process as the "
"caller.  The I<sig> argument specifies the signal to be sent.  The I<value> "
"argument specifies data to accompany the signal; see B<sigqueue>(3)  for "
"details."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_sigqueue.3:71
msgid ""
"On success, B<pthread_sigqueue>()  returns 0; on error, it returns an error "
"number."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_sigqueue.3:78
msgid ""
"The limit of signals which may be queued has been reached.  (See "
"B<signal>(7)  for further information.)"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_sigqueue.3:82
msgid "I<sig> was invalid."
msgstr ""

#. type: TP
#: build/C/man3/pthread_sigqueue.3:82
#, no-wrap
msgid "B<ENOSYS>"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_sigqueue.3:86
msgid "B<pthread_sigqueue>()  is not supported on this system."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_sigqueue.3:90
msgid "I<thread> is not valid."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_sigqueue.3:94
msgid "The B<pthread_sigqueue>()  function first appeared in glibc 2.11."
msgstr ""

#. type: tbl table
#: build/C/man3/pthread_sigqueue.3:104
#, no-wrap
msgid "B<pthread_sigqueue>()"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_sigqueue.3:108
msgid "This function is a GNU extension."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_sigqueue.3:118
msgid ""
"The glibc implementation of B<pthread_sigqueue>()  gives an error "
"(B<EINVAL>)  on attempts to send either of the real-time signals used "
"internally by the NPTL threading implementation.  See B<nptl>(7)  for "
"details."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_sigqueue.3:126
msgid ""
"B<rt_tgsigqueueinfo>(2), B<sigaction>(2), B<pthread_sigmask>(3), "
"B<sigqueue>(3), B<sigwait>(3), B<pthreads>(7), B<signal>(7)"
msgstr ""

#. type: TH
#: build/C/man3/pthread_testcancel.3:26
#, no-wrap
msgid "PTHREAD_TESTCANCEL"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_testcancel.3:29
msgid "pthread_testcancel - request delivery of any pending cancellation request"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_testcancel.3:34
#, no-wrap
msgid "B<void pthread_testcancel(void);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_testcancel.3:43
msgid ""
"Calling B<pthread_testcancel>()  creates a cancellation point within the "
"calling thread, so that a thread that is otherwise executing code that "
"contains no cancellation points will respond to a cancellation request."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_testcancel.3:50
msgid ""
"If cancelability is disabled (using B<pthread_setcancelstate>(3)), or no "
"cancellation request is pending, then a call to B<pthread_testcancel>()  has "
"no effect."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_testcancel.3:54
msgid ""
"This function does not return a value.  If the calling thread is canceled as "
"a consequence of a call to this function, then the function does not return."
msgstr ""

#. type: tbl table
#: build/C/man3/pthread_testcancel.3:68
#, no-wrap
msgid "B<pthread_testcancel>()"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_testcancel.3:75
msgid "See B<pthread_cleanup_push>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_testcancel.3:80
msgid ""
"B<pthread_cancel>(3), B<pthread_cleanup_push>(3), "
"B<pthread_setcancelstate>(3), B<pthreads>(7)"
msgstr ""

#. type: TH
#: build/C/man3/pthread_tryjoin_np.3:26
#, no-wrap
msgid "PTHREAD_TRYJOIN_NP"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:30
msgid ""
"pthread_tryjoin_np, pthread_timedjoin_np - try to join with a terminated "
"thread"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:36
#, no-wrap
msgid "B<int pthread_tryjoin_np(pthread_t >I<thread>B<, void **>I<retval>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:39
#, no-wrap
msgid ""
"B<int pthread_timedjoin_np(pthread_t >I<thread>B<, void **>I<retval>B<,>\n"
"B<                         const struct timespec *>I<abstime>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:46
msgid ""
"These functions operate in the same way as B<pthread_join>(3), except for "
"the differences described on this page."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:58
msgid ""
"The B<pthread_tryjoin_np>()  function performs a nonblocking join with the "
"thread I<thread>, returning the exit status of the thread in I<*retval>.  If "
"I<thread> has not yet terminated, then instead of blocking, as is done by "
"B<pthread_join>(3), the call returns an error."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:79
msgid ""
"The B<pthread_timedjoin_np>()  function performs a join-with-timeout.  If "
"I<thread> has not yet terminated, then the call blocks until a maximum time, "
"specified in I<abstime>, measured against the B<CLOCK_REALTIME> clock.  If "
"the timeout expires before I<thread> terminates, the call returns an error.  "
"The I<abstime> argument is a structure of the following form, specifying an "
"absolute time measured since the Epoch (see B<time>(2)):"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:86
#, no-wrap
msgid ""
"struct timespec {\n"
"    time_t tv_sec;     /* seconds */\n"
"    long   tv_nsec;    /* nanoseconds */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:92
msgid "On success, these functions return 0; on error, they return an error number."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:97
msgid ""
"These functions can fail with the same errors as B<pthread_join>(3).  "
"B<pthread_tryjoin_np>()  can in addition fail with the following error:"
msgstr ""

#. type: TP
#: build/C/man3/pthread_tryjoin_np.3:97 build/C/man3/pthread_spin_lock.3:104
#, no-wrap
msgid "B<EBUSY>"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:101
msgid "I<thread> had not yet terminated at the time of the call."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:104
msgid "B<pthread_timedjoin_np>()  can in addition fail with the following errors:"
msgstr ""

#. type: TP
#: build/C/man3/pthread_tryjoin_np.3:104
#, no-wrap
msgid "B<ETIMEDOUT>"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:109
msgid "The call timed out before I<thread> terminated."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:117
msgid ""
"I<abstime> value is invalid (I<tv_sec> is less than 0 or I<tv_nsec> is "
"greater than 1e9)."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:121
msgid "B<pthread_timedjoin_np>()  never returns the error B<EINTR>."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:123
msgid "These functions first appeared in glibc in version 2.3.3."
msgstr ""

#. type: tbl table
#: build/C/man3/pthread_tryjoin_np.3:135
#, no-wrap
msgid ""
"B<pthread_tryjoin_np>(),\n"
"B<pthread_timedjoin_np>()"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:143
msgid "The following code waits to join for up to 5 seconds:"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:148
#, no-wrap
msgid ""
"struct timespec ts;\n"
"int s;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:150
#, no-wrap
msgid "\\&...\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:154
#, no-wrap
msgid ""
"if (clock_gettime(CLOCK_REALTIME, &ts) == -1) {\n"
"    /* Handle error */\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:156
#, no-wrap
msgid "ts.tv_sec += 5;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:161
#, no-wrap
msgid ""
"s = pthread_timedjoin_np(thread, NULL, &ts);\n"
"if (s != 0) {\n"
"    /* Handle error */\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:175
msgid ""
"The B<pthread_timedjoin_np>()  function measures time by internally "
"calculating a relative sleep interval that is then measured against the "
"B<CLOCK_MONOTONIC> clock instead of the B<CLOCK_REALTIME> clock.  "
"Consequently, the timeout is unaffected by discontinuous changes to the "
"B<CLOCK_REALTIME> clock."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:180
msgid "B<clock_gettime>(2), B<pthread_exit>(3), B<pthread_join>(3), B<pthreads>(7)"
msgstr ""

#. type: TH
#: build/C/man3/pthread_yield.3:25
#, no-wrap
msgid "PTHREAD_YIELD"
msgstr ""

#. type: TH
#: build/C/man3/pthread_yield.3:25
#, no-wrap
msgid "2017-11-26"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_yield.3:28
msgid "pthread_yield - yield the processor"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_yield.3:34
#, no-wrap
msgid "B<int pthread_yield(void);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_yield.3:44
msgid ""
"B<pthread_yield>()  causes the calling thread to relinquish the CPU.  The "
"thread is placed at the end of the run queue for its static priority and "
"another thread is scheduled to run.  For further details, see "
"B<sched_yield>(2)"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_yield.3:49
msgid ""
"On success, B<pthread_yield>()  returns 0; on error, it returns an error "
"number."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_yield.3:53
msgid ""
"On Linux, this call always succeeds (but portable and future-proof "
"applications should nevertheless handle a possible error return)."
msgstr ""

#. type: tbl table
#: build/C/man3/pthread_yield.3:63
#, no-wrap
msgid "B<pthread_yield>()"
msgstr ""

#.  e.g., the BSDs, Tru64, AIX, and Irix.
#. type: Plain text
#: build/C/man3/pthread_yield.3:71
msgid ""
"This call is nonstandard, but present on several other systems.  Use the "
"standardized B<sched_yield>(2)  instead."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_yield.3:74
msgid "On Linux, this function is implemented as a call to B<sched_yield>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_yield.3:85
msgid ""
"B<pthread_yield>()  is intended for use with real-time scheduling policies "
"(i.e., B<SCHED_FIFO> or B<SCHED_RR>).  Use of B<pthread_yield>()  with "
"nondeterministic scheduling policies such as B<SCHED_OTHER> is unspecified "
"and very likely means your application design is broken."
msgstr ""

#.  FIXME . .BR pthread_cond_wait (3),
#. type: Plain text
#: build/C/man3/pthread_yield.3:90
msgid "B<sched_yield>(2), B<pthreads>(7), B<sched>(7)"
msgstr ""

#. type: TH
#: build/C/man3/pthread_atfork.3:25
#, no-wrap
msgid "PTHREAD_ATFORK"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_atfork.3:28
msgid "pthread_atfork - register fork handlers"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_atfork.3:34
#, no-wrap
msgid ""
"B<int pthread_atfork(void (*>I<prepare>B<)(void), void "
"(*>I<parent>B<)(void),>\n"
"B<                   void (*>I<child>B<)(void));>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_atfork.3:37
msgid "Link with I<-pthread>."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_atfork.3:45
msgid ""
"The B<pthread_atfork>()  function registers fork handlers that are to be "
"executed when B<fork>(2)  is called by this thread.  The handlers are "
"executed in the context of the thread that calls B<fork>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_atfork.3:47
msgid "Three kinds of handler can be registered:"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_atfork.3:52
msgid ""
"I<prepare> specifies a handler that is executed before B<fork>(2)  "
"processing starts."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_atfork.3:57
msgid ""
"I<parent> specifies a handler that is executed in the parent process after "
"B<fork>(2)  processing completes."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_atfork.3:62
msgid ""
"I<child> specifies a handler that is executed in the child process after "
"B<fork>(2)  processing completes."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_atfork.3:67
msgid ""
"Any of the three arguments may be NULL if no handler is needed in the "
"corresponding phase of B<fork>(2)  processing."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_atfork.3:82
msgid ""
"On success, B<pthread_atfork>()  returns zero.  On error, it returns an "
"error number.  B<pthread_atfork>()  may be called multiple times by a "
"thread, to register multiple handlers for each phase.  The handlers for each "
"phase are called in a specified order: the I<prepare> handlers are called in "
"reverse order of registration; the I<parent> and I<child> handlers are "
"called in the order of registration."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_atfork.3:86
msgid "Could not allocate memory to record the form handler entry."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_atfork.3:108
msgid ""
"When B<fork>(2)  is called in a multithreaded process, only the calling "
"thread is duplicated in the child process.  The original intention of "
"B<pthread_atfork>()  was to allow the calling thread to be returned to a "
"consistent state.  For example, at the time of the call to B<fork>(2), other "
"threads may have locked mutexes that are visible in the user-space memory "
"duplicated in the child.  Such mutexes would never be unlocked, since the "
"threads that placed the locks are not duplicated in the child.  The intent "
"of B<pthread_atfork>()  was to provide a mechanism whereby the application "
"(or a library)  could ensure that mutexes and other process and thread state "
"would be restored to a consistent state.  In practice, this task is "
"generally too difficult to be practicable."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_atfork.3:117
msgid ""
"After a B<fork>(2)  in a multithreaded process returns in the child, the "
"child should call only async-signal-safe functions (see B<signal-safety>(7))  "
"until such time as it calls B<execve>(2)  to execute a new program."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_atfork.3:122
msgid ""
"POSIX.1 specifies that B<pthread_atfork>()  shall not fail with the error "
"B<EINTR>."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_atfork.3:126
msgid "B<fork>(2), B<atexit>(3), B<pthreads>(7)"
msgstr ""

#. type: TH
#: build/C/man3/pthread_attr_setsigmask_np.3:26
#, no-wrap
msgid "PTHREAD_ATTR_SETSIGMASK_NP"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setsigmask_np.3:30
msgid ""
"pthread_attr_setsigmask_np, pthread_attr_getsigmask_np - set/get signal mask "
"attribute in thread attributes object"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setsigmask_np.3:39
#, no-wrap
msgid ""
"B<int pthread_attr_setsigmask_np(pthread_attr_t *>I<attr>B<,>\n"
"B<                               const sigset_t *>I<sigmask>B<);>\n"
"B<int pthread_attr_getsigmask_np(const pthread_attr_t *>I<attr>B<,>\n"
"B<                               sigset_t *>I<sigmask>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setsigmask_np.3:55
msgid ""
"The B<pthread_attr_setsigmask_np>()  function sets the signal mask attribute "
"of the thread attributes object referred to by I<attr> to the value "
"specified in I<*sigmask>.  If I<sigmask> is specified as NULL, then any "
"existing signal mask attribute in I<attr> is unset."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setsigmask_np.3:67
msgid ""
"The B<pthread_attr_getsigmask_np>()  function returns the signal mask "
"attribute of the thread attributes object referred to by I<attr> in the "
"buffer pointed to by I<sigmask>.  If the signal mask attribute is currently "
"unset, then this function returns the special value "
"B<PTHREAD_ATTR_NO_SIGMASK_NP> as its result."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setsigmask_np.3:71
msgid ""
"The B<pthread_attr_setsigmask_np>()  function returns 0 on success, or a "
"nonzero error number on failure."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setsigmask_np.3:82
msgid ""
"the B<pthread_attr_getsigmask_np>()  function returns either 0 or "
"B<PTHREAD_ATTR_NO_SIGMASK_NP>.  When 0 is returned, the signal mask "
"attribute is returned via I<sigmask>.  A return value of "
"B<PTHREAD_ATTR_NO_SIGMASK_NP> indicates that the signal mask attribute is "
"not set in I<attr>."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setsigmask_np.3:84
msgid "On error, these functions return a positive error number."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setsigmask_np.3:89
msgid "(B<pthread_attr_setsigmask_np>())  Could not allocate memory."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setsigmask_np.3:91
msgid "These functions are provided by glibc since version 2.32."
msgstr ""

#. type: tbl table
#: build/C/man3/pthread_attr_setsigmask_np.3:102
#, no-wrap
msgid ""
"B<pthread_attr_setsigmask_np>(),\n"
"B<pthread_attr_getsigmask_np>()"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setsigmask_np.3:115
msgid ""
"The signal mask attribute determines the signal mask that will be assigned "
"to a thread created using the thread attributes object I<attr>.  If this "
"attribute is not set, then a thread created using I<attr> will inherit a "
"copy of the creating thread's signal mask."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setsigmask_np.3:121
msgid ""
"For more details on signal masks, see B<sigprocmask>(2).  For a description "
"of a set of macros that can be used to manipulate and inspect signals sets, "
"see B<sigsetops>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setsigmask_np.3:125
msgid ""
"In the absence of B<pthread_attr_setsigmask_np>()  it is possible to create "
"a thread with a desired signal mask as follows:"
msgstr ""

#. type: IP
#: build/C/man3/pthread_attr_setsigmask_np.3:125 build/C/man3/pthread_attr_setsigmask_np.3:129 build/C/man3/pthread_attr_setsigmask_np.3:133 build/C/man3/pthread_attr_setsigmask_np.3:136
#, no-wrap
msgid "\\(bu"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setsigmask_np.3:129
msgid ""
"The creating thread uses B<pthread_sigmask>(3)  to save its current signal "
"mask and set its mask to block all signals."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setsigmask_np.3:133
msgid ""
"The new thread is then created using B<pthread_create>(); the new thread "
"will inherit the creating thread's signal mask."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setsigmask_np.3:136
msgid ""
"The new thread sets its signal mask to the desired value using "
"B<pthread_sigmask>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setsigmask_np.3:138
msgid "The creating thread restores its signal mask to the original value."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setsigmask_np.3:142
msgid ""
"Following the above steps, there is no possibility for the new thread to "
"receive a signal before it has adjusted its signal mask to the desired "
"value."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_attr_setsigmask_np.3:148
msgid ""
"B<sigprocmask>(2), B<pthread_attr_init>(3), B<pthread_sigmask>(3), "
"B<pthreads>(7), B<signals>(7)"
msgstr ""

#. type: TH
#: build/C/man3/pthread_getattr_default_np.3:25
#, no-wrap
msgid "PTHREAD_GETATTR_DEFAULT_NP"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_default_np.3:29
msgid ""
"pthread_getattr_default_np, pthread_setattr_default_np, - get or set default "
"thread-creation attributes"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_default_np.3:36
#, no-wrap
msgid ""
"B<int pthread_getattr_default_np(pthread_attr_t *>I<attr>B<);>\n"
"B<int pthread_setattr_default_np(pthread_attr_t *>I<attr>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_default_np.3:50
msgid ""
"The B<pthread_setattr_default_np>()  function sets the default attributes "
"used for creation of a new thread\\(emthat is, the attributes that are used "
"when B<pthread_create>(3)  is called with a second argument that is NULL.  "
"The default attributes are set using the attributes supplied in I<*attr>, a "
"previously initialized thread attributes object.  Note the following details "
"about the supplied attributes object:"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_default_np.3:52
msgid "The attribute settings in the object must be valid."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_default_np.3:56
msgid "The I<stack address> attribute must not be set in the object."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_default_np.3:60
msgid ""
"Setting the I<stack size> attribute to zero means leave the default stack "
"size unchanged."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_default_np.3:66
msgid ""
"The B<pthread_getattr_default_np>()  function initializes the thread "
"attributes object referred to by I<attr> so that it contains the default "
"attributes used for thread creation."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_default_np.3:74
msgid ""
"(B<pthread_setattr_default_np>())  One of the attribute settings in I<attr> "
"is invalid, or the stack address attribute is set in I<attr>."
msgstr ""

#.  Can happen (but unlikely) while trying to allocate memory for cpuset
#. type: Plain text
#: build/C/man3/pthread_getattr_default_np.3:79
msgid "(B<pthread_setattr_default_np>())  Insufficient memory."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_default_np.3:81
msgid "These functions are available in glibc since version 2.18."
msgstr ""

#. type: tbl table
#: build/C/man3/pthread_getattr_default_np.3:93
#, no-wrap
msgid ""
"B<pthread_getattr_default_np>(),\n"
"B<pthread_setattr_default_np>()"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_default_np.3:99
msgid ""
"These functions are nonstandard GNU extensions; hence the suffix \"_np\" "
"(nonportable) in their names."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_default_np.3:105
msgid ""
"The program below uses B<pthread_getattr_default_np>()  to fetch the default "
"thread-creation attributes and then displays various settings from the "
"returned thread attributes object.  When running the program, we see the "
"following output:"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_default_np.3:115
#, no-wrap
msgid ""
"$ B<./a.out>\n"
"Stack size:          8388608\n"
"Guard size:          4096\n"
"Scheduling policy:   SCHED_OTHER\n"
"Scheduling priority: 0\n"
"Detach state:        JOINABLE\n"
"Inherit scheduler:   INHERIT\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_default_np.3:140
#, no-wrap
msgid ""
"static void\n"
"display_pthread_attr(pthread_attr_t *attr)\n"
"{\n"
"    int s;\n"
"    size_t stacksize;\n"
"    size_t guardsize;\n"
"    int policy;\n"
"    struct sched_param schedparam;\n"
"    int detachstate;\n"
"    int inheritsched;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_default_np.3:145
#, no-wrap
msgid ""
"    s = pthread_attr_getstacksize(attr, &stacksize);\n"
"    if (s != 0)\n"
"        errExitEN(s, \"pthread_attr_getstacksize\");\n"
"    printf(\"Stack size:          %zd\\en\", stacksize);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_default_np.3:150
#, no-wrap
msgid ""
"    s = pthread_attr_getguardsize(attr, &guardsize);\n"
"    if (s != 0)\n"
"        errExitEN(s, \"pthread_attr_getguardsize\");\n"
"    printf(\"Guard size:          %zd\\en\", guardsize);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_default_np.3:158
#, no-wrap
msgid ""
"    s = pthread_attr_getschedpolicy(attr, &policy);\n"
"    if (s != 0)\n"
"        errExitEN(s, \"pthread_attr_getschedpolicy\");\n"
"    printf(\"Scheduling policy:   %s\\en\",\n"
"            (policy == SCHED_FIFO) ? \"SCHED_FIFO\" :\n"
"            (policy == SCHED_RR) ? \"SCHED_RR\" :\n"
"            (policy == SCHED_OTHER) ? \"SCHED_OTHER\" : \"[unknown]\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_default_np.3:163
#, no-wrap
msgid ""
"    s = pthread_attr_getschedparam(attr, &schedparam);\n"
"    if (s != 0)\n"
"        errExitEN(s, \"pthread_attr_getschedparam\");\n"
"    printf(\"Scheduling priority: %d\\en\", schedparam.sched_priority);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_default_np.3:171
#, no-wrap
msgid ""
"    s = pthread_attr_getdetachstate(attr, &detachstate);\n"
"    if (s != 0)\n"
"        errExitEN(s, \"pthread_attr_getdetachstate\");\n"
"    printf(\"Detach state:        %s\\en\",\n"
"            (detachstate == PTHREAD_CREATE_DETACHED) ? \"DETACHED\" :\n"
"            (detachstate == PTHREAD_CREATE_JOINABLE) ? \"JOINABLE\" :\n"
"            \"???\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_default_np.3:180
#, no-wrap
msgid ""
"    s = pthread_attr_getinheritsched(attr, &inheritsched);\n"
"    if (s != 0)\n"
"        errExitEN(s, \"pthread_attr_getinheritsched\");\n"
"    printf(\"Inherit scheduler:   %s\\en\",\n"
"            (inheritsched == PTHREAD_INHERIT_SCHED) ? \"INHERIT\" :\n"
"            (inheritsched == PTHREAD_EXPLICIT_SCHED) ? \"EXPLICIT\" :\n"
"            \"???\");\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_default_np.3:186
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int s;\n"
"    pthread_attr_t attr;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_default_np.3:190
#, no-wrap
msgid ""
"    s = pthread_getattr_default_np(&attr);\n"
"    if (s != 0)\n"
"        errExitEN(s, \"pthread_getattr_default_np\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_getattr_default_np.3:192
#, no-wrap
msgid "    display_pthread_attr(&attr);\n"
msgstr ""

#. type: TH
#: build/C/man3/pthread_mutex_consistent.3:26
#, no-wrap
msgid "PTHREAD_MUTEX_CONSISTENT"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutex_consistent.3:29
msgid "pthread_mutex_consistent - make a robust mutex consistent"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutex_consistent.3:34
#, no-wrap
msgid "B<int pthread_mutex_consistent(pthread_mutex_t *>I<mutex>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutex_consistent.3:44
msgid "B<pthread_mutex_consistent>():"
msgstr ""

#.  FIXME .
#.  But see https://sourceware.org/bugzilla/show_bug.cgi?id=22125
#. type: Plain text
#: build/C/man3/pthread_mutex_consistent.3:48 build/C/man3/pthread_mutexattr_setrobust.3:55
msgid "_POSIX_C_SOURCE E<gt>= 200809L"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutex_consistent.3:59
msgid ""
"This function makes a robust mutex consistent if it is in an inconsistent "
"state.  A mutex can be left in an inconsistent state if its owner terminates "
"while holding the mutex, in which case the next owner who acquires the mutex "
"will succeed and be notified by a return value of B<EOWNERDEAD> from a call "
"to B<pthread_mutex_lock>()."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutex_consistent.3:65
msgid ""
"On success, I<pthread_mutex_consistent>()  returns 0.  Otherwise, it returns "
"a positive error number to indicate the cause of the error."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutex_consistent.3:69
msgid "The mutex is either not robust or is not in an inconsistent state."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutex_consistent.3:72
msgid "B<pthread_mutex_consistent>()  was added to glibc in version 2.12."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutex_consistent.3:74 build/C/man3/pthread_mutexattr_setrobust.3:152
msgid "POSIX.1-2008."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutex_consistent.3:82
msgid ""
"B<pthread_mutex_consistent>()  simply informs the implementation that the "
"state (shared data)  guarded by the mutex has been restored to a consistent "
"state and that normal operations can now be performed with the mutex.  It is "
"the application's responsibility to ensure that the shared data has been "
"restored to a consistent state before calling B<pthread_mutex_consistent>()."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutex_consistent.3:89
msgid ""
"Before the addition of B<pthread_mutex_consistent>()  to POSIX, glibc "
"defined the following equivalent nonstandard function if B<_GNU_SOURCE> was "
"defined:"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutex_consistent.3:92
#, no-wrap
msgid "B<int pthread_mutex_consistent(const pthread_mutex_t *>I<mutex>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutex_consistent.3:96
msgid ""
"This GNU-specific API, which first appeared in glibc 2.4, is nowadays "
"obsolete and should not be used in new programs."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutex_consistent.3:99
msgid "See B<pthread_mutexattr_setrobust>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutex_consistent.3:107
msgid ""
"B<pthread_mutex_lock>(3), B<pthread_mutexattr_init>(3), "
"B<pthread_mutexattr_getrobust>(3), B<pthread_mutexattr_setrobust>(3), "
"B<pthreads>(7)"
msgstr ""

#. type: TH
#: build/C/man3/pthread_mutexattr_getpshared.3:25
#, no-wrap
msgid "PTHREAD_MUTEXATTR_GETPSHARED"
msgstr ""

#. type: TH
#: build/C/man3/pthread_mutexattr_getpshared.3:25
#, no-wrap
msgid "2017-09-13"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_getpshared.3:29
msgid ""
"pthread_mutexattr_getpshared, pthread_mutexattr_setpshared - get/set "
"process-shared mutex attribute"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_getpshared.3:37
#, no-wrap
msgid ""
"B<int pthread_mutexattr_getpshared(const pthread_mutexattr_t *>I<attr>B<,>\n"
"B<                                 int *>I<pshared>B<);>\n"
"B<int pthread_mutexattr_setpshared(pthread_mutexattr_t *>I<attr>B<,>\n"
"B<                                 int >I<pshared>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_getpshared.3:45
msgid ""
"These functions get and set the process-shared attribute in a mutex "
"attributes object.  This attribute must be appropriately set to ensure "
"correct, efficient operation of a mutex created using this attributes "
"object."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_getpshared.3:47
msgid "The process-shared attribute can have one of the following values:"
msgstr ""

#. type: TP
#: build/C/man3/pthread_mutexattr_getpshared.3:47 build/C/man3/pthread_spin_init.3:68
#, no-wrap
msgid "B<PTHREAD_PROCESS_PRIVATE>"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_getpshared.3:52
msgid ""
"Mutexes created with this attributes object are to be shared only among "
"threads in the same process that initialized the mutex.  This is the default "
"value for the process-shared mutex attribute."
msgstr ""

#. type: TP
#: build/C/man3/pthread_mutexattr_getpshared.3:52 build/C/man3/pthread_spin_init.3:75
#, no-wrap
msgid "B<PTHREAD_PROCESS_SHARED>"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_getpshared.3:57
msgid ""
"Mutexes created with this attributes object can be shared between any "
"threads that have access to the memory containing the object, including "
"threads in different processes."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_getpshared.3:64
msgid ""
"B<pthread_mutexattr_getpshared>()  places the value of the process-shared "
"attribute of the mutex attributes object referred to by I<attr> in the "
"location pointed to by I<pshared>."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_getpshared.3:71
msgid ""
"B<pthread_mutexattr_setpshared>()  sets the value of the process-shared "
"attribute of the mutex attributes object referred to by I<attr> to the value "
"specified in B<pshared>."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_getpshared.3:76
msgid ""
"If I<attr> does not refer to an initialized mutex attributes object, the "
"behavior is undefined."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_getpshared.3:79 build/C/man3/pthread_mutexattr_init.3:59 build/C/man3/pthread_mutexattr_setrobust.3:132
msgid ""
"On success, these functions return 0.  On error, they return a positive "
"error number."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_getpshared.3:82
msgid "B<pthread_mutexattr_setpshared>()  can fail with the following errors:"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_getpshared.3:87
msgid "The value specified in I<pshared> is invalid."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_getpshared.3:92
msgid ""
"I<pshared is> B<PTHREAD_PROCESS_SHARED> but the implementation does not "
"support process-shared mutexes."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_getpshared.3:99
msgid "B<pthread_mutexattr_init>(3), B<pthreads>(7)"
msgstr ""

#. type: TH
#: build/C/man3/pthread_mutexattr_init.3:25
#, no-wrap
msgid "PTHREAD_MUTEXATTR_INIT"
msgstr ""

#. type: TH
#: build/C/man3/pthread_mutexattr_init.3:25
#, no-wrap
msgid "2019-10-10"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_init.3:29
msgid ""
"pthread_mutexattr_init, pthread_mutexattr_destroy - initialize and destroy a "
"mutex attributes object"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_init.3:35
#, no-wrap
msgid ""
"B<int pthread_mutexattr_init(pthread_mutexattr_t *>I<attr>B<);>\n"
"B<int pthread_mutexattr_destroy(pthread_mutexattr_t *>I<attr>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_init.3:44
msgid ""
"The B<pthread_mutexattr_init>()  function initializes the mutex attributes "
"object pointed to by I<attr> with default values for all attributes defined "
"by the implementation."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_init.3:47
msgid ""
"The results of initializing an already initialized mutex attributes object "
"are undefined."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_init.3:53
msgid ""
"The B<pthread_mutexattr_destroy>()  function destroys a mutex attribute "
"object (making it uninitialized).  Once a mutex attributes object has been "
"destroyed, it can be reinitialized with B<pthread_mutexattr_init>()."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_init.3:56
msgid ""
"The results of destroying an uninitialized mutex attributes object are "
"undefined."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_init.3:64
msgid ""
"Subsequent changes to a mutex attributes object do not affect mutex that "
"have already been initialized using that object."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_init.3:71
msgid ""
"B<pthread_mutex_init>(3), B<pthread_mutexattr_getpshared>(3), "
"B<pthread_mutexattr_getrobust>(3), B<pthreads>(7)"
msgstr ""

#. type: TH
#: build/C/man3/pthread_mutexattr_setrobust.3:26
#, no-wrap
msgid "PTHREAD_MUTEXATTR_SETROBUST"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:30
msgid ""
"pthread_mutexattr_getrobust, pthread_mutexattr_setrobust - get and set the "
"robustness attribute of a mutex attributes object"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:38
#, no-wrap
msgid ""
"B<int pthread_mutexattr_getrobust(const pthread_mutexattr_t *>I<attr>B<,>\n"
"B<                                int *>I<robustness>B<);>\n"
"B<int pthread_mutexattr_setrobust(const pthread_mutexattr_t *>I<attr>B<,>\n"
"B<                                int >I<robustness>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:49
msgid "B<pthread_mutexattr_getrobust>(), B<pthread_mutexattr_setrobust>():"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:72
msgid ""
"The B<pthread_mutexattr_getrobust>()  function places the value of the "
"robustness attribute of the mutex attributes object referred to by I<attr> "
"in I<*robustness>.  The B<pthread_mutexattr_setrobust>()  function sets the "
"value of the robustness attribute of the mutex attributes object referred to "
"by I<attr> to the value specified in I<*robustness>."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:77
msgid ""
"The robustness attribute specifies the behavior of the mutex when the owning "
"thread dies without unlocking the mutex.  The following values are valid for "
"I<robustness>:"
msgstr ""

#. type: TP
#: build/C/man3/pthread_mutexattr_setrobust.3:77
#, no-wrap
msgid "B<PTHREAD_MUTEX_STALLED>"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:86
msgid ""
"This is the default value for a mutex attributes object.  If a mutex is "
"initialized with the B<PTHREAD_MUTEX_STALLED> attribute and its owner dies "
"without unlocking it, the mutex remains locked afterwards and any future "
"attempts to call B<pthread_mutex_lock>(3)  on the mutex will block "
"indefinitely."
msgstr ""

#. type: TP
#: build/C/man3/pthread_mutexattr_setrobust.3:86
#, no-wrap
msgid "B<PTHREAD_MUTEX_ROBUST>"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:102
msgid ""
"If a mutex is initialized with the B<PTHREAD_MUTEX_ROBUST> attribute and its "
"owner dies without unlocking it, any future attempts to call "
"B<pthread_mutex_lock>(3)  on this mutex will succeed and return "
"B<EOWNERDEAD> to indicate that the original owner no longer exists and the "
"mutex is in an inconsistent state.  Usually after B<EOWNERDEAD> is returned, "
"the next owner should call B<pthread_mutex_consistent>(3)  on the acquired "
"mutex to make it consistent again before using it any further."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:112
msgid ""
"If the next owner unlocks the mutex using B<pthread_mutex_unlock>(3)  before "
"making it consistent, the mutex will be permanently unusable and any "
"subsequent attempts to lock it using B<pthread_mutex_lock>(3)  will fail "
"with the error B<ENOTRECOVERABLE>.  The only permitted operation on such a "
"mutex is B<pthread_mutex_destroy>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:119
msgid ""
"If the next owner terminates before calling B<pthread_mutex_consistent>(3), "
"further B<pthread_mutex_lock>(3)  operations on this mutex will still return "
"B<EOWNERDEAD>."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:129
msgid ""
"Note that the I<attr> argument of B<pthread_mutexattr_getrobust>()  and "
"B<pthread_mutexattr_setrobust>()  should refer to a mutex attributes object "
"that was initialized by B<pthread_mutexattr_init>(3), otherwise the behavior "
"is undefined."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:136
msgid ""
"In the glibc implementation, B<pthread_mutexattr_getrobust>()  always return "
"zero."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:145
msgid ""
"A value other than B<PTHREAD_MUTEX_STALLED> or B<PTHREAD_MUTEX_ROBUST> was "
"passed to B<pthread_mutexattr_setrobust>()."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:150
msgid ""
"B<pthread_mutexattr_getrobust>()  and B<pthread_mutexattr_setrobust>()  were "
"added to glibc in version 2.12."
msgstr ""

#.  E.g., Solaris, according to its manual page
#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:163
msgid ""
"In the Linux implementation, when using process-shared robust mutexes, a "
"waiting thread also receives the B<EOWNERDEAD> notification if the owner of "
"a robust mutex performs an B<execve>(2)  without first unlocking the mutex.  "
"POSIX.1 does not specify this detail, but the same behavior also occurs in "
"at least some other implementations."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:172
msgid ""
"Before the addition of B<pthread_mutexattr_getrobust>()  and "
"B<pthread_mutexattr_setrobust>()  to POSIX, glibc defined the following "
"equivalent nonstandard functions if B<_GNU_SOURCE> was defined:"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:178
#, no-wrap
msgid ""
"B<int pthread_mutexattr_getrobust_np(const pthread_mutexattr_t "
"*>I<attr>B<,>\n"
"B<                                   int *>I<robustness>B<);>\n"
"B<int pthread_mutexattr_setrobust_np(const pthread_mutexattr_t "
"*>I<attr>B<,>\n"
"B<                                   int >I<robustness>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:185
msgid ""
"Correspondingly, the constants B<PTHREAD_MUTEX_STALLED_NP> and "
"B<PTHREAD_MUTEX_ROBUST_NP> were also defined."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:188
msgid ""
"These GNU-specific APIs, which first appeared in glibc 2.4, are nowadays "
"obsolete and should not be used in new programs."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:197
msgid ""
"The program below demonstrates the use of the robustness attribute of a "
"mutex attributes object.  In this program, a thread holding the mutex dies "
"prematurely without unlocking the mutex.  The main thread subsequently "
"acquires the mutex successfully and gets the error B<EOWNERDEAD>, after "
"which it makes the mutex consistent."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:199
msgid "The following shell session shows what we see when running this program:"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:209
#, no-wrap
msgid ""
"$ B<./a.out>\n"
"[original owner] Setting lock...\n"
"[original owner] Locked. Now exiting without unlocking.\n"
"[main] Attempting to lock the robust mutex.\n"
"[main] pthread_mutex_lock() returned EOWNERDEAD\n"
"[main] Now make the mutex consistent\n"
"[main] Mutex is now consistent; unlocking\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:218
#, no-wrap
msgid ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:223
#, no-wrap
msgid "static pthread_mutex_t mtx;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:232
#, no-wrap
msgid ""
"static void *\n"
"original_owner_thread(void *ptr)\n"
"{\n"
"    printf(\"[original owner] Setting lock...\\en\");\n"
"    pthread_mutex_lock(&mtx);\n"
"    printf(\"[original owner] Locked. Now exiting without "
"unlocking.\\en\");\n"
"    pthread_exit(NULL);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:239
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pthread_t thr;\n"
"    pthread_mutexattr_t attr;\n"
"    int s;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:244
#, no-wrap
msgid ""
"    pthread_mutexattr_init(&attr);\n"
"                                /* initialize the attributes object */\n"
"    pthread_mutexattr_setrobust(&attr, PTHREAD_MUTEX_ROBUST);\n"
"                               /* set robustness */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:246
#, no-wrap
msgid "    pthread_mutex_init(&mtx, &attr);   /* initialize the mutex */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:248
#, no-wrap
msgid "    pthread_create(&thr, NULL, original_owner_thread, NULL);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:252
#, no-wrap
msgid "    /* \"original_owner_thread\" should have exited by now */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:265
#, no-wrap
msgid ""
"    printf(\"[main] Attempting to lock the robust mutex.\\en\");\n"
"    s = pthread_mutex_lock(&mtx);\n"
"    if (s == EOWNERDEAD) {\n"
"        printf(\"[main] pthread_mutex_lock() returned EOWNERDEAD\\en\");\n"
"        printf(\"[main] Now make the mutex consistent\\en\");\n"
"        s = pthread_mutex_consistent(&mtx);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_mutex_consistent\");\n"
"        printf(\"[main] Mutex is now consistent; unlocking\\en\");\n"
"        s = pthread_mutex_unlock(&mtx);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_mutex_unlock\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:275
#, no-wrap
msgid ""
"        exit(EXIT_SUCCESS);\n"
"    } else if (s == 0) {\n"
"        printf(\"[main] pthread_mutex_lock() unexpectedly "
"succeeded\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    } else {\n"
"        printf(\"[main] pthread_mutex_lock() unexpectedly failed\\en\");\n"
"        handle_error_en(s, \"pthread_mutex_lock\");\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_mutexattr_setrobust.3:285
msgid ""
"B<get_robust_list>(2), B<set_robust_list>(2), "
"B<pthread_mutex_consistent>(3), B<pthread_mutex_init>(3), "
"B<pthread_mutex_lock>(3), B<pthreads>(7)"
msgstr ""

#. type: TH
#: build/C/man3/pthread_spin_init.3:25
#, no-wrap
msgid "PTHREAD_SPIN_INIT"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_spin_init.3:28
msgid "pthread_spin_init, pthread_spin_destroy - initialize or destroy a spin lock"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_spin_init.3:34
#, no-wrap
msgid ""
"B<int pthread_spin_init(pthread_spinlock_t *>I<lock>B<, int "
">I<pshared>B<);>\n"
"B<int pthread_spin_destroy(pthread_spinlock_t *>I<lock>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_spin_init.3:45
msgid "B<pthread_spin_init>(), B<pthread_spin_destroy>():"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_spin_init.3:49 build/C/man3/pthread_spin_lock.3:51
msgid "_POSIX_C_SOURCE E<gt>= 200112L"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_spin_init.3:58
msgid ""
"I<General note>: Most programs should use mutexes instead of spin locks.  "
"Spin locks are primarily useful in conjunction with real-time scheduling "
"policies.  See NOTES."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_spin_init.3:68
msgid ""
"The B<pthread_spin_init>()  function allocates any resources required for "
"the use of the spin lock referred to by I<lock> and initializes the lock to "
"be in the unlocked state.  The I<pshared> argument must have one of the "
"following values:"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_spin_init.3:75
msgid ""
"The spin lock is to be operated on only by threads in the same process as "
"the thread that calls B<pthread_spin_init>().  (Attempting to share the spin "
"lock between processes results in undefined behavior.)"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_spin_init.3:81
msgid ""
"The spin lock may be operated on by any thread in any process that has "
"access to the memory containing the lock (i.e., the lock may be in a shared "
"memory object that is shared among multiple processes)."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_spin_init.3:86
msgid ""
"Calling B<pthread_spin_init>()  on a spin lock that has already been "
"initialized results in undefined behavior."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_spin_init.3:94
msgid ""
"The B<pthread_spin_destroy>()  function destroys a previously initialized "
"spin lock, freeing any resources that were allocated for that lock.  "
"Destroying a spin lock that has not been previously been initialized or "
"destroying a spin lock while another thread holds the lock results in "
"undefined behavior."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_spin_init.3:100
msgid ""
"Once a spin lock has been destroyed, performing any operation on the lock "
"other than once more initializing it with B<pthread_spin_init>()  results in "
"undefined behavior."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_spin_init.3:111
msgid ""
"The result of performing operations such as B<pthread_spin_lock>(3), "
"B<pthread_spin_unlock>(3), and B<pthread_spin_destroy>()  on I<copies> of "
"the object referred to by I<lock> is undefined."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_spin_init.3:117
msgid ""
"On success, there functions return zero.  On failure, they return an error "
"number.  In the event that B<pthread_spin_init>()  fails, the lock is not "
"initialized."
msgstr ""

#.  These errors don't occur on the glibc implementation
#. type: Plain text
#: build/C/man3/pthread_spin_init.3:121
msgid "B<pthread_spin_init>()  may fail with the following errors:"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_spin_init.3:125
msgid "The system has insufficient resources to initialize a new spin lock."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_spin_init.3:128
msgid "Insufficient memory to initialize the spin lock."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_spin_init.3:130 build/C/man3/pthread_spin_lock.3:109
msgid "These functions first appeared in glibc in version 2.2."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_spin_init.3:132 build/C/man3/pthread_spin_lock.3:111
msgid "POSIX.1-2001."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_spin_init.3:135
msgid ""
"Support for process-shared spin locks is a POSIX option.  The option is "
"supported in the glibc implementation."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_spin_init.3:148
msgid ""
"Spin locks should be employed in conjunction with real-time scheduling "
"policies (B<SCHED_FIFO>, or possibly B<SCHED_RR>).  Use of spin locks with "
"nondeterministic scheduling policies such as B<SCHED_OTHER> probably "
"indicates a design mistake.  The problem is that if a thread operating under "
"such a policy is scheduled off the CPU while it holds a spin lock, then "
"other threads will waste time spinning on the lock until the lock holder is "
"once more rescheduled and releases the lock."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_spin_init.3:151
msgid ""
"If threads create a deadlock situation while employing spin locks, those "
"threads will spin forever consuming CPU time."
msgstr ""

#.  FIXME . When PTHREAD_MUTEX_ADAPTIVE_NP is one day document
#.  make reference to it here
#. type: Plain text
#: build/C/man3/pthread_spin_init.3:162
msgid ""
"User-space spin locks are I<not> applicable as a general locking solution.  "
"They are, by definition, prone to priority inversion and unbounded spin "
"times.  A programmer using spin locks must be exceptionally careful not only "
"in the code, but also in terms of system configuration, thread placement, "
"and priority assignment."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_spin_init.3:170
msgid ""
"B<pthread_mutex_init>(3), B<pthread_mutex_lock>(3), B<pthread_spin_lock>(3), "
"B<pthread_spin_unlock>(3), B<pthreads>(7)"
msgstr ""

#. type: TH
#: build/C/man3/pthread_spin_lock.3:25
#, no-wrap
msgid "PTHREAD_SPIN_LOCK"
msgstr ""

#. type: TH
#: build/C/man3/pthread_spin_lock.3:25
#, no-wrap
msgid "2017-09-30"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_spin_lock.3:29
msgid ""
"pthread_spin_lock, pthread_spin_trylock, pthread_spin_unlock - lock and "
"unlock a spin lock"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_spin_lock.3:36
#, no-wrap
msgid ""
"B<int pthread_spin_lock(pthread_spinlock_t *>I<lock>B<);>\n"
"B<int pthread_spin_trylock(pthread_spinlock_t *>I<lock>B<);>\n"
"B<int pthread_spin_unlock(pthread_spinlock_t *>I<lock>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_spin_lock.3:47
msgid "B<pthread_spin_lock>(), B<pthread_spin_trylock>():"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_spin_lock.3:63
msgid ""
"The B<pthread_spin_lock>()  function locks the spin lock referred to by "
"I<lock>.  If the spin lock is currently unlocked, the calling thread "
"acquires the lock immediately.  If the spin lock is currently locked by "
"another thread, the calling thread spins, testing the lock until it becomes "
"available, at which point the calling thread acquires the lock."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_spin_lock.3:70
msgid ""
"Calling B<pthread_spin_lock>()  on a lock that is already held by the caller "
"or a lock that has not been initialized with B<pthread_spin_init>(3)  "
"results in undefined behavior."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_spin_lock.3:80
msgid ""
"The B<pthread_spin_trylock>()  function is like B<pthread_spin_lock>(), "
"except that if the spin lock referred to by I<lock> is currently locked, "
"then, instead of spinning, the call returns immediately with the error "
"B<EBUSY>."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_spin_lock.3:87
msgid ""
"The B<pthread_spin_unlock>()  function unlocks the spin lock referred to "
"I<lock>.  If any threads are spinning on the lock, one of those threads will "
"then acquire the lock."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_spin_lock.3:91
msgid ""
"Calling B<pthread_spin_unlock>()  on a lock that is not held by the caller "
"results in undefined behavior."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_spin_lock.3:94
msgid ""
"On success, these functions return zero.  On failure, they return an error "
"number."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_spin_lock.3:97
msgid "B<pthread_spin_lock>()  may fail with the following errors:"
msgstr ""

#. type: TP
#: build/C/man3/pthread_spin_lock.3:97
#, no-wrap
msgid "B<EDEADLOCK>"
msgstr ""

#.  Not detected in glibc
#. type: Plain text
#: build/C/man3/pthread_spin_lock.3:101
msgid "The system detected a deadlock condition."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_spin_lock.3:104
msgid "B<pthread_spin_trylock>()  fails with the following errors:"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_spin_lock.3:107
msgid "The spin lock is currently locked by another thread."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_spin_lock.3:114
msgid ""
"Applying any of the functions described on this page to an uninitialized "
"spin lock results in undefined behavior."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_spin_lock.3:117
msgid "Carefully read NOTES in B<pthread_spin_init>(3)."
msgstr ""

#.  FIXME . .BR pthread_mutex_lock (3),
#. type: Plain text
#: build/C/man3/pthread_spin_lock.3:124
msgid "B<pthread_spin_destroy>(3), B<pthread_spin_init>(3), B<pthreads>(7)"
msgstr ""

#. type: TH
#: build/C/man7/pthreads.7:25
#, no-wrap
msgid "PTHREADS"
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:28
msgid "pthreads - POSIX threads"
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:35
msgid ""
"POSIX.1 specifies a set of interfaces (functions, header files) for threaded "
"programming commonly known as POSIX threads, or Pthreads.  A single process "
"can contain multiple threads, all of which are executing the same program.  "
"These threads share the same global memory (data and heap segments), but "
"each thread has its own stack (automatic variables)."
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:38
msgid ""
"POSIX.1 also requires that threads share a range of other attributes (i.e., "
"these attributes are process-wide rather than per-thread):"
msgstr ""

#. type: IP
#: build/C/man7/pthreads.7:38 build/C/man7/pthreads.7:40 build/C/man7/pthreads.7:42 build/C/man7/pthreads.7:44 build/C/man7/pthreads.7:46 build/C/man7/pthreads.7:48 build/C/man7/pthreads.7:50 build/C/man7/pthreads.7:53 build/C/man7/pthreads.7:55 build/C/man7/pthreads.7:58 build/C/man7/pthreads.7:64 build/C/man7/pthreads.7:69 build/C/man7/pthreads.7:72 build/C/man7/pthreads.7:75 build/C/man7/pthreads.7:83 build/C/man7/pthreads.7:87 build/C/man7/pthreads.7:90 build/C/man7/pthreads.7:94 build/C/man7/pthreads.7:97 build/C/man7/pthreads.7:102 build/C/man7/pthreads.7:105 build/C/man7/pthreads.7:704 build/C/man7/pthreads.7:711 build/C/man7/pthreads.7:723 build/C/man7/pthreads.7:733 build/C/man7/pthreads.7:737 build/C/man7/pthreads.7:746 build/C/man7/pthreads.7:756 build/C/man7/pthreads.7:763 build/C/man7/pthreads.7:770 build/C/man7/pthreads.7:772 build/C/man7/pthreads.7:775 build/C/man7/pthreads.7:781 build/C/man7/pthreads.7:784 build/C/man7/pthreads.7:786 build/C/man7/pthreads.7:788 build/C/man7/pthreads.7:798 build/C/man7/pthreads.7:820 build/C/man7/pthreads.7:829 build/C/man7/pthreads.7:835 build/C/man7/pthreads.7:837 build/C/man7/pthreads.7:839 build/C/man7/pthreads.7:843 build/C/man7/pthreads.7:848 build/C/man7/pthreads.7:856
#, no-wrap
msgid "-"
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:40
msgid "process ID"
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:42
msgid "parent process ID"
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:44
msgid "process group ID and session ID"
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:46
msgid "controlling terminal"
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:48
msgid "user and group IDs"
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:50
msgid "open file descriptors"
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:53
msgid "record locks (see B<fcntl>(2))"
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:55
msgid "signal dispositions"
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:58
msgid "file mode creation mask (B<umask>(2))"
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:64
msgid "current directory (B<chdir>(2))  and root directory (B<chroot>(2))"
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:69
msgid "interval timers (B<setitimer>(2))  and POSIX timers (B<timer_create>(2))"
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:72
msgid "nice value (B<setpriority>(2))"
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:75
msgid "resource limits (B<setrlimit>(2))"
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:80
msgid ""
"measurements of the consumption of CPU time (B<times>(2))  and resources "
"(B<getrusage>(2))"
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:83
msgid ""
"As well as the stack, POSIX.1 specifies that various other attributes are "
"distinct for each thread, including:"
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:87
msgid "thread ID (the I<pthread_t> data type)"
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:90
msgid "signal mask (B<pthread_sigmask>(3))"
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:94
msgid "the I<errno> variable"
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:97
msgid "alternate signal stack (B<sigaltstack>(2))"
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:100
msgid "real-time scheduling policy and priority (B<sched>(7))"
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:102
msgid "The following Linux-specific features are also per-thread:"
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:105
msgid "capabilities (see B<capabilities>(7))"
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:108
msgid "CPU affinity (B<sched_setaffinity>(2))"
msgstr ""

#. type: SS
#: build/C/man7/pthreads.7:108
#, no-wrap
msgid "Pthreads function return values"
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:119
msgid ""
"Most pthreads functions return 0 on success, and an error number on "
"failure.  The error numbers that can be returned have the same meaning as "
"the error numbers returned in I<errno> by conventional system calls and C "
"library functions.  Note that the pthreads functions do not set I<errno>.  "
"For each of the pthreads functions that can return an error, POSIX.1-2001 "
"specifies that the function can never fail with the error B<EINTR>."
msgstr ""

#. type: SS
#: build/C/man7/pthreads.7:119
#, no-wrap
msgid "Thread IDs"
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:127
msgid ""
"Each of the threads in a process has a unique thread identifier (stored in "
"the type I<pthread_t>).  This identifier is returned to the caller of "
"B<pthread_create>(3), and a thread can obtain its own thread identifier "
"using B<pthread_self>(3)."
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:132
msgid ""
"Thread IDs are guaranteed to be unique only within a process.  (In all "
"pthreads functions that accept a thread ID as an argument, that ID by "
"definition refers to a thread in the same process as the caller.)"
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:137
msgid ""
"The system may reuse a thread ID after a terminated thread has been joined, "
"or a detached thread has terminated.  POSIX says: \"If an application "
"attempts to use a thread ID whose lifetime has ended, the behavior is "
"undefined.\""
msgstr ""

#. type: SS
#: build/C/man7/pthreads.7:137
#, no-wrap
msgid "Thread-safe functions"
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:141
msgid ""
"A thread-safe function is one that can be safely (i.e., it will deliver the "
"same results regardless of whether it is)  called from multiple threads at "
"the same time."
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:145
msgid ""
"POSIX.1-2001 and POSIX.1-2008 require that all functions specified in the "
"standard shall be thread-safe, except for the following functions:"
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:241
#, no-wrap
msgid ""
"asctime()\n"
"basename()\n"
"catgets()\n"
"crypt()\n"
"ctermid() if passed a non-NULL argument\n"
"ctime()\n"
"dbm_clearerr()\n"
"dbm_close()\n"
"dbm_delete()\n"
"dbm_error()\n"
"dbm_fetch()\n"
"dbm_firstkey()\n"
"dbm_nextkey()\n"
"dbm_open()\n"
"dbm_store()\n"
"dirname()\n"
"dlerror()\n"
"drand48()\n"
"ecvt() [POSIX.1-2001 only (function removed in POSIX.1-2008)]\n"
"encrypt()\n"
"endgrent()\n"
"endpwent()\n"
"endutxent()\n"
"fcvt() [POSIX.1-2001 only (function removed in POSIX.1-2008)]\n"
"ftw()\n"
"gcvt() [POSIX.1-2001 only (function removed in POSIX.1-2008)]\n"
"getc_unlocked()\n"
"getchar_unlocked()\n"
"getdate()\n"
"getenv()\n"
"getgrent()\n"
"getgrgid()\n"
"getgrnam()\n"
"gethostbyaddr() [POSIX.1-2001 only (function removed in\n"
"                 POSIX.1-2008)]\n"
"gethostbyname() [POSIX.1-2001 only (function removed in\n"
"                 POSIX.1-2008)]\n"
"gethostent()\n"
"getlogin()\n"
"getnetbyaddr()\n"
"getnetbyname()\n"
"getnetent()\n"
"getopt()\n"
"getprotobyname()\n"
"getprotobynumber()\n"
"getprotoent()\n"
"getpwent()\n"
"getpwnam()\n"
"getpwuid()\n"
"getservbyname()\n"
"getservbyport()\n"
"getservent()\n"
"getutxent()\n"
"getutxid()\n"
"getutxline()\n"
"gmtime()\n"
"hcreate()\n"
"hdestroy()\n"
"hsearch()\n"
"inet_ntoa()\n"
"l64a()\n"
"lgamma()\n"
"lgammaf()\n"
"lgammal()\n"
"localeconv()\n"
"localtime()\n"
"lrand48()\n"
"mrand48()\n"
"nftw()\n"
"nl_langinfo()\n"
"ptsname()\n"
"putc_unlocked()\n"
"putchar_unlocked()\n"
"putenv()\n"
"pututxline()\n"
"rand()\n"
"readdir()\n"
"setenv()\n"
"setgrent()\n"
"setkey()\n"
"setpwent()\n"
"setutxent()\n"
"strerror()\n"
"strsignal() [Added in POSIX.1-2008]\n"
"strtok()\n"
"system() [Added in POSIX.1-2008]\n"
"tmpnam() if passed a non-NULL argument\n"
"ttyname()\n"
"unsetenv()\n"
"wcrtomb() if its final argument is NULL\n"
"wcsrtombs() if its final argument is NULL\n"
"wcstombs()\n"
"wctomb()\n"
msgstr ""

#. type: SS
#: build/C/man7/pthreads.7:243
#, no-wrap
msgid "Async-cancel-safe functions"
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:247
msgid ""
"An async-cancel-safe function is one that can be safely called in an "
"application where asynchronous cancelability is enabled (see "
"B<pthread_setcancelstate>(3))."
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:250
msgid ""
"Only the following functions are required to be async-cancel-safe by "
"POSIX.1-2001 and POSIX.1-2008:"
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:256
#, no-wrap
msgid ""
"pthread_cancel()\n"
"pthread_setcancelstate()\n"
"pthread_setcanceltype()\n"
msgstr ""

#. type: SS
#: build/C/man7/pthreads.7:258
#, no-wrap
msgid "Cancellation points"
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:265
msgid ""
"POSIX.1 specifies that certain functions must, and certain other functions "
"may, be cancellation points.  If a thread is cancelable, its cancelability "
"type is deferred, and a cancellation request is pending for the thread, then "
"the thread is canceled when it calls a function that is a cancellation "
"point."
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:268
msgid ""
"The following functions are required to be cancellation points by "
"POSIX.1-2001 and/or POSIX.1-2008:"
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:331
#, no-wrap
msgid ""
"accept()\n"
"aio_suspend()\n"
"clock_nanosleep()\n"
"close()\n"
"connect()\n"
"creat()\n"
"fcntl() F_SETLKW\n"
"fdatasync()\n"
"fsync()\n"
"getmsg()\n"
"getpmsg()\n"
"lockf() F_LOCK\n"
"mq_receive()\n"
"mq_send()\n"
"mq_timedreceive()\n"
"mq_timedsend()\n"
"msgrcv()\n"
"msgsnd()\n"
"msync()\n"
"nanosleep()\n"
"open()\n"
"openat() [Added in POSIX.1-2008]\n"
"pause()\n"
"poll()\n"
"pread()\n"
"pselect()\n"
"pthread_cond_timedwait()\n"
"pthread_cond_wait()\n"
"pthread_join()\n"
"pthread_testcancel()\n"
"putmsg()\n"
"putpmsg()\n"
"pwrite()\n"
"read()\n"
"readv()\n"
"recv()\n"
"recvfrom()\n"
"recvmsg()\n"
"select()\n"
"sem_timedwait()\n"
"sem_wait()\n"
"send()\n"
"sendmsg()\n"
"sendto()\n"
"sigpause() [POSIX.1-2001 only (moves to \"may\" list in POSIX.1-2008)]\n"
"sigsuspend()\n"
"sigtimedwait()\n"
"sigwait()\n"
"sigwaitinfo()\n"
"sleep()\n"
"system()\n"
"tcdrain()\n"
"usleep() [POSIX.1-2001 only (function removed in POSIX.1-2008)]\n"
"wait()\n"
"waitid()\n"
"waitpid()\n"
"write()\n"
"writev()\n"
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:336
msgid ""
"The following functions may be cancellation points according to POSIX.1-2001 "
"and/or POSIX.1-2008:"
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:566
#, no-wrap
msgid ""
"access()\n"
"asctime()\n"
"asctime_r()\n"
"catclose()\n"
"catgets()\n"
"catopen()\n"
"chmod() [Added in POSIX.1-2008]\n"
"chown() [Added in POSIX.1-2008]\n"
"closedir()\n"
"closelog()\n"
"ctermid()\n"
"ctime()\n"
"ctime_r()\n"
"dbm_close()\n"
"dbm_delete()\n"
"dbm_fetch()\n"
"dbm_nextkey()\n"
"dbm_open()\n"
"dbm_store()\n"
"dlclose()\n"
"dlopen()\n"
"dprintf() [Added in POSIX.1-2008]\n"
"endgrent()\n"
"endhostent()\n"
"endnetent()\n"
"endprotoent()\n"
"endpwent()\n"
"endservent()\n"
"endutxent()\n"
"faccessat() [Added in POSIX.1-2008]\n"
"fchmod() [Added in POSIX.1-2008]\n"
"fchmodat() [Added in POSIX.1-2008]\n"
"fchown() [Added in POSIX.1-2008]\n"
"fchownat() [Added in POSIX.1-2008]\n"
"fclose()\n"
"fcntl() (for any value of cmd argument)\n"
"fflush()\n"
"fgetc()\n"
"fgetpos()\n"
"fgets()\n"
"fgetwc()\n"
"fgetws()\n"
"fmtmsg()\n"
"fopen()\n"
"fpathconf()\n"
"fprintf()\n"
"fputc()\n"
"fputs()\n"
"fputwc()\n"
"fputws()\n"
"fread()\n"
"freopen()\n"
"fscanf()\n"
"fseek()\n"
"fseeko()\n"
"fsetpos()\n"
"fstat()\n"
"fstatat() [Added in POSIX.1-2008]\n"
"ftell()\n"
"ftello()\n"
"ftw()\n"
"futimens() [Added in POSIX.1-2008]\n"
"fwprintf()\n"
"fwrite()\n"
"fwscanf()\n"
"getaddrinfo()\n"
"getc()\n"
"getc_unlocked()\n"
"getchar()\n"
"getchar_unlocked()\n"
"getcwd()\n"
"getdate()\n"
"getdelim() [Added in POSIX.1-2008]\n"
"getgrent()\n"
"getgrgid()\n"
"getgrgid_r()\n"
"getgrnam()\n"
"getgrnam_r()\n"
"gethostbyaddr() [POSIX.1-2001 only (function removed in\n"
"                 POSIX.1-2008)]\n"
"gethostbyname() [POSIX.1-2001 only (function removed in\n"
"                 POSIX.1-2008)]\n"
"gethostent()\n"
"gethostid()\n"
"gethostname()\n"
"getline() [Added in POSIX.1-2008]\n"
"getlogin()\n"
"getlogin_r()\n"
"getnameinfo()\n"
"getnetbyaddr()\n"
"getnetbyname()\n"
"getnetent()\n"
"getopt() (if opterr is nonzero)\n"
"getprotobyname()\n"
"getprotobynumber()\n"
"getprotoent()\n"
"getpwent()\n"
"getpwnam()\n"
"getpwnam_r()\n"
"getpwuid()\n"
"getpwuid_r()\n"
"gets()\n"
"getservbyname()\n"
"getservbyport()\n"
"getservent()\n"
"getutxent()\n"
"getutxid()\n"
"getutxline()\n"
"getwc()\n"
"getwchar()\n"
"getwd() [POSIX.1-2001 only (function removed in POSIX.1-2008)]\n"
"glob()\n"
"iconv_close()\n"
"iconv_open()\n"
"ioctl()\n"
"link()\n"
"linkat() [Added in POSIX.1-2008]\n"
"lio_listio() [Added in POSIX.1-2008]\n"
"localtime()\n"
"localtime_r()\n"
"lockf() [Added in POSIX.1-2008]\n"
"lseek()\n"
"lstat()\n"
"mkdir() [Added in POSIX.1-2008]\n"
"mkdirat() [Added in POSIX.1-2008]\n"
"mkdtemp() [Added in POSIX.1-2008]\n"
"mkfifo() [Added in POSIX.1-2008]\n"
"mkfifoat() [Added in POSIX.1-2008]\n"
"mknod() [Added in POSIX.1-2008]\n"
"mknodat() [Added in POSIX.1-2008]\n"
"mkstemp()\n"
"mktime()\n"
"nftw()\n"
"opendir()\n"
"openlog()\n"
"pathconf()\n"
"pclose()\n"
"perror()\n"
"popen()\n"
"posix_fadvise()\n"
"posix_fallocate()\n"
"posix_madvise()\n"
"posix_openpt()\n"
"posix_spawn()\n"
"posix_spawnp()\n"
"posix_trace_clear()\n"
"posix_trace_close()\n"
"posix_trace_create()\n"
"posix_trace_create_withlog()\n"
"posix_trace_eventtypelist_getnext_id()\n"
"posix_trace_eventtypelist_rewind()\n"
"posix_trace_flush()\n"
"posix_trace_get_attr()\n"
"posix_trace_get_filter()\n"
"posix_trace_get_status()\n"
"posix_trace_getnext_event()\n"
"posix_trace_open()\n"
"posix_trace_rewind()\n"
"posix_trace_set_filter()\n"
"posix_trace_shutdown()\n"
"posix_trace_timedgetnext_event()\n"
"posix_typed_mem_open()\n"
"printf()\n"
"psiginfo() [Added in POSIX.1-2008]\n"
"psignal() [Added in POSIX.1-2008]\n"
"pthread_rwlock_rdlock()\n"
"pthread_rwlock_timedrdlock()\n"
"pthread_rwlock_timedwrlock()\n"
"pthread_rwlock_wrlock()\n"
"putc()\n"
"putc_unlocked()\n"
"putchar()\n"
"putchar_unlocked()\n"
"puts()\n"
"pututxline()\n"
"putwc()\n"
"putwchar()\n"
"readdir()\n"
"readdir_r()\n"
"readlink() [Added in POSIX.1-2008]\n"
"readlinkat() [Added in POSIX.1-2008]\n"
"remove()\n"
"rename()\n"
"renameat() [Added in POSIX.1-2008]\n"
"rewind()\n"
"rewinddir()\n"
"scandir() [Added in POSIX.1-2008]\n"
"scanf()\n"
"seekdir()\n"
"semop()\n"
"setgrent()\n"
"sethostent()\n"
"setnetent()\n"
"setprotoent()\n"
"setpwent()\n"
"setservent()\n"
"setutxent()\n"
"sigpause() [Added in POSIX.1-2008]\n"
"stat()\n"
"strerror()\n"
"strerror_r()\n"
"strftime()\n"
"symlink()\n"
"symlinkat() [Added in POSIX.1-2008]\n"
"sync()\n"
"syslog()\n"
"tmpfile()\n"
"tmpnam()\n"
"ttyname()\n"
"ttyname_r()\n"
"tzset()\n"
"ungetc()\n"
"ungetwc()\n"
"unlink()\n"
"unlinkat() [Added in POSIX.1-2008]\n"
"utime() [Added in POSIX.1-2008]\n"
"utimensat() [Added in POSIX.1-2008]\n"
"utimes() [Added in POSIX.1-2008]\n"
"vdprintf() [Added in POSIX.1-2008]\n"
"vfprintf()\n"
"vfwprintf()\n"
"vprintf()\n"
"vwprintf()\n"
"wcsftime()\n"
"wordexp()\n"
"wprintf()\n"
"wscanf()\n"
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:574
msgid ""
"An implementation may also mark other functions not specified in the "
"standard as cancellation points.  In particular, an implementation is likely "
"to mark any nonstandard function that may block as a cancellation point.  "
"(This includes most functions that can touch files.)"
msgstr ""

#.  So, scanning "cancellation point" comments in the glibc 2.8 header
#.  files, it looks as though at least the following nonstandard
#.  functions are cancellation points:
#.  endnetgrent
#.  endspent
#.  epoll_pwait
#.  epoll_wait
#.  fcloseall
#.  fdopendir
#.  fflush_unlocked
#.  fgetc_unlocked
#.  fgetgrent
#.  fgetgrent_r
#.  fgetpwent
#.  fgetpwent_r
#.  fgets_unlocked
#.  fgetspent
#.  fgetspent_r
#.  fgetwc_unlocked
#.  fgetws_unlocked
#.  fputc_unlocked
#.  fputs_unlocked
#.  fputwc_unlocked
#.  fputws_unlocked
#.  fread_unlocked
#.  fwrite_unlocked
#.  gai_suspend
#.  getaddrinfo_a
#.  getdate_r
#.  getgrent_r
#.  getgrouplist
#.  gethostbyaddr_r
#.  gethostbyname2
#.  gethostbyname2_r
#.  gethostbyname_r
#.  gethostent_r
#.  getnetbyaddr_r
#.  getnetbyname_r
#.  getnetent_r
#.  getnetgrent
#.  getnetgrent_r
#.  getprotobyname_r
#.  getprotobynumber_r
#.  getprotoent_r
#.  getpw
#.  getpwent_r
#.  getservbyname_r
#.  getservbyport_r
#.  getservent_r
#.  getspent
#.  getspent_r
#.  getspnam
#.  getspnam_r
#.  getutmp
#.  getutmpx
#.  getw
#.  getwc_unlocked
#.  getwchar_unlocked
#.  initgroups
#.  innetgr
#.  mkostemp
#.  mkostemp64
#.  mkstemp64
#.  ppoll
#.  pthread_timedjoin_np
#.  putgrent
#.  putpwent
#.  putspent
#.  putw
#.  putwc_unlocked
#.  putwchar_unlocked
#.  rcmd
#.  rcmd_af
#.  rexec
#.  rexec_af
#.  rresvport
#.  rresvport_af
#.  ruserok
#.  ruserok_af
#.  setnetgrent
#.  setspent
#.  sgetspent
#.  sgetspent_r
#.  updwtmpx
#.  utmpxname
#.  vfscanf
#.  vfwscanf
#.  vscanf
#.  vsyslog
#.  vwscanf
#. type: Plain text
#: build/C/man7/pthreads.7:674
msgid ""
"It should be noted that even if an application is not using asynchronous "
"cancellation, that calling a function from the above list from an "
"asynchronous signal handler may cause the equivalent of asynchronous "
"cancellation.  The underlying user code may not expect asynchronous "
"cancellation and the state of the user data may become inconsistent.  "
"Therefore signals should be used with caution when entering a region of "
"deferred cancellation."
msgstr ""

#. type: SS
#: build/C/man7/pthreads.7:674
#, no-wrap
msgid "Compiling on Linux"
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:677
msgid ""
"On Linux, programs that use the Pthreads API should be compiled using I<cc "
"-pthread>."
msgstr ""

#. type: SS
#: build/C/man7/pthreads.7:677
#, no-wrap
msgid "Linux implementations of POSIX threads"
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:680
msgid ""
"Over time, two threading implementations have been provided by the GNU C "
"library on Linux:"
msgstr ""

#. type: TP
#: build/C/man7/pthreads.7:680
#, no-wrap
msgid "B<LinuxThreads>"
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:684
msgid ""
"This is the original Pthreads implementation.  Since glibc 2.4, this "
"implementation is no longer supported."
msgstr ""

#. type: TP
#: build/C/man7/pthreads.7:684
#, no-wrap
msgid "B<NPTL> (Native POSIX Threads Library)"
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:692
msgid ""
"This is the modern Pthreads implementation.  By comparison with "
"LinuxThreads, NPTL provides closer conformance to the requirements of the "
"POSIX.1 specification and better performance when creating large numbers of "
"threads.  NPTL is available since glibc 2.3.2, and requires features that "
"are present in the Linux 2.6 kernel."
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:702
msgid ""
"Both of these are so-called 1:1 implementations, meaning that each thread "
"maps to a kernel scheduling entity.  Both threading implementations employ "
"the Linux B<clone>(2)  system call.  In NPTL, thread synchronization "
"primitives (mutexes, thread joining, and so on) are implemented using the "
"Linux B<futex>(2)  system call."
msgstr ""

#. type: SS
#: build/C/man7/pthreads.7:702
#, no-wrap
msgid "LinuxThreads"
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:704
msgid "The notable features of this implementation are the following:"
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:711
msgid ""
"In addition to the main (initial) thread, and the threads that the program "
"creates using B<pthread_create>(3), the implementation creates a \"manager\" "
"thread.  This thread handles thread creation and termination.  (Problems can "
"result if this thread is inadvertently killed.)"
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:723
msgid ""
"Signals are used internally by the implementation.  On Linux 2.2 and later, "
"the first three real-time signals are used (see also B<signal>(7)).  On "
"older Linux kernels, B<SIGUSR1> and B<SIGUSR2> are used.  Applications must "
"avoid the use of whichever set of signals is employed by the implementation."
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:730
msgid ""
"Threads do not share process IDs.  (In effect, LinuxThreads threads are "
"implemented as processes which share more information than usual, but which "
"do not share a common process ID.)  LinuxThreads threads (including the "
"manager thread)  are visible as separate processes using B<ps>(1)."
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:733
msgid ""
"The LinuxThreads implementation deviates from the POSIX.1 specification in a "
"number of ways, including the following:"
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:737
msgid "Calls to B<getpid>(2)  return a different value in each thread."
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:746
msgid ""
"Calls to B<getppid>(2)  in threads other than the main thread return the "
"process ID of the manager thread; instead B<getppid>(2)  in these threads "
"should return the same value as B<getppid>(2)  in the main thread."
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:756
msgid ""
"When one thread creates a new child process using B<fork>(2), any thread "
"should be able to B<wait>(2)  on the child.  However, the implementation "
"allows only the thread that created the child to B<wait>(2)  on it."
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:763
msgid ""
"When a thread calls B<execve>(2), all other threads are terminated (as "
"required by POSIX.1).  However, the resulting process has the same PID as "
"the thread that called B<execve>(2): it should have the same PID as the main "
"thread."
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:770
msgid ""
"Threads do not share user and group IDs.  This can cause complications with "
"set-user-ID programs and can cause failures in Pthreads functions if an "
"application changes its credentials using B<seteuid>(2)  or similar."
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:772
msgid "Threads do not share a common session ID and process group ID."
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:775
msgid "Threads do not share record locks created using B<fcntl>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:781
msgid ""
"The information returned by B<times>(2)  and B<getrusage>(2)  is per-thread "
"rather than process-wide."
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:784
msgid "Threads do not share semaphore undo values (see B<semop>(2))."
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:786
msgid "Threads do not share interval timers."
msgstr ""

#.  FIXME . bug report filed for NPTL nice nonconformance
#.  http://bugzilla.kernel.org/show_bug.cgi?id=6258
#.  Sep 08: there is a patch by Denys Vlasenko to address this
#.  "make setpriority POSIX compliant; introduce PRIO_THREAD extension"
#.  Monitor this to see if it makes it into mainline.
#. type: Plain text
#: build/C/man7/pthreads.7:788 build/C/man7/pthreads.7:827
msgid "Threads do not share a common nice value."
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:798
msgid ""
"POSIX.1 distinguishes the notions of signals that are directed to the "
"process as a whole and signals that are directed to individual threads.  "
"According to POSIX.1, a process-directed signal (sent using B<kill>(2), for "
"example) should be handled by a single, arbitrarily selected thread within "
"the process.  LinuxThreads does not support the notion of process-directed "
"signals: signals may be sent only to specific threads."
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:807
msgid ""
"Threads have distinct alternate signal stack settings.  However, a new "
"thread's alternate signal stack settings are copied from the thread that "
"created it, so that the threads initially share an alternate signal stack.  "
"(A new thread should start with no alternate signal stack defined.  If two "
"threads handle signals on their shared alternate signal stack at the same "
"time, unpredictable program failures are likely to occur.)"
msgstr ""

#. type: TH
#: build/C/man7/pthreads.7:807 build/C/man7/nptl.7:26
#, no-wrap
msgid "NPTL"
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:812
msgid ""
"With NPTL, all of the threads in a process are placed in the same thread "
"group; all members of a thread group share the same PID.  NPTL does not "
"employ a manager thread."
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:818
msgid ""
"NPTL makes internal use of the first two real-time signals; these signals "
"cannot be used in applications.  See B<nptl>(7)  for further details."
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:820
msgid "NPTL still has at least one nonconformance with POSIX.1:"
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:829
msgid "Some NPTL nonconformances occur only with older kernels:"
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:835
msgid ""
"The information returned by B<times>(2)  and B<getrusage>(2)  is per-thread "
"rather than process-wide (fixed in kernel 2.6.9)."
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:837
msgid "Threads do not share resource limits (fixed in kernel 2.6.10)."
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:839
msgid "Threads do not share interval timers (fixed in kernel 2.6.12)."
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:843
msgid ""
"Only the main thread is permitted to start a new session using B<setsid>(2)  "
"(fixed in kernel 2.6.16)."
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:848
msgid ""
"Only the main thread is permitted to make the process into a process group "
"leader using B<setpgid>(2)  (fixed in kernel 2.6.16)."
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:854
msgid ""
"Threads have distinct alternate signal stack settings.  However, a new "
"thread's alternate signal stack settings are copied from the thread that "
"created it, so that the threads initially share an alternate signal stack "
"(fixed in kernel 2.6.16)."
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:856
msgid "Note the following further points about the NPTL implementation:"
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:870
msgid ""
"If the stack size soft resource limit (see the description of "
"B<RLIMIT_STACK> in B<setrlimit>(2))  is set to a value other than "
"I<unlimited>, then this value defines the default stack size for new "
"threads.  To be effective, this limit must be set before the program is "
"executed, perhaps using the I<ulimit -s> shell built-in command (I<limit "
"stacksize> in the C shell)."
msgstr ""

#. type: SS
#: build/C/man7/pthreads.7:870
#, no-wrap
msgid "Determining the threading implementation"
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:875
msgid ""
"Since glibc 2.3.2, the B<getconf>(1)  command can be used to determine the "
"system's threading implementation, for example:"
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:880
#, no-wrap
msgid ""
"bash$ getconf GNU_LIBPTHREAD_VERSION\n"
"NPTL 2.3.4\n"
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:885
msgid ""
"With older glibc versions, a command such as the following should be "
"sufficient to determine the default threading implementation:"
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:891
#, no-wrap
msgid ""
"bash$ $( ldd /bin/ls | grep libc.so | awk \\(aq{print $3}\\(aq ) | \\e\n"
"                egrep -i \\(aqthreads|nptl\\(aq\n"
"        Native POSIX Threads Library by Ulrich Drepper et al\n"
msgstr ""

#. type: SS
#: build/C/man7/pthreads.7:893
#, no-wrap
msgid "Selecting the threading implementation: LD_ASSUME_KERNEL"
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:908
msgid ""
"On systems with a glibc that supports both LinuxThreads and NPTL (i.e., "
"glibc 2.3.I<x>), the B<LD_ASSUME_KERNEL> environment variable can be used to "
"override the dynamic linker's default choice of threading implementation.  "
"This variable tells the dynamic linker to assume that it is running on top "
"of a particular kernel version.  By specifying a kernel version that does "
"not provide the support required by NPTL, we can force the use of "
"LinuxThreads.  (The most likely reason for doing this is to run a (broken) "
"application that depends on some nonconformant behavior in LinuxThreads.)  "
"For example:"
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:914
#, no-wrap
msgid ""
"bash$ $( LD_ASSUME_KERNEL=2.2.5 ldd /bin/ls | grep libc.so | \\e\n"
"                awk \\(aq{print $3}\\(aq ) | egrep -i "
"\\(aqthreads|nptl\\(aq\n"
"        linuxthreads-0.10 by Xavier Leroy\n"
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:929
msgid ""
"B<clone>(2), B<fork>(2), B<futex>(2), B<gettid>(2), B<proc>(5), "
"B<attributes>(7), B<futex>(7), B<nptl>(7), B<sigevent>(7), B<signal>(7)"
msgstr ""

#. type: Plain text
#: build/C/man7/pthreads.7:958
msgid ""
"Various Pthreads manual pages, for example: B<pthread_atfork>(3), "
"B<pthread_attr_init>(3), B<pthread_cancel>(3), B<pthread_cleanup_push>(3), "
"B<pthread_cond_signal>(3), B<pthread_cond_wait>(3), B<pthread_create>(3), "
"B<pthread_detach>(3), B<pthread_equal>(3), B<pthread_exit>(3), "
"B<pthread_key_create>(3), B<pthread_kill>(3), B<pthread_mutex_lock>(3), "
"B<pthread_mutex_unlock>(3), B<pthread_mutexattr_destroy>(3), "
"B<pthread_mutexattr_init>(3), B<pthread_once>(3), B<pthread_spin_init>(3), "
"B<pthread_spin_lock>(3), B<pthread_rwlockattr_setkind_np>(3), "
"B<pthread_setcancelstate>(3), B<pthread_setcanceltype>(3), "
"B<pthread_setspecific>(3), B<pthread_sigmask>(3), B<pthread_sigqueue>(3), "
"and B<pthread_testcancel>(3)"
msgstr ""

#. type: Plain text
#: build/C/man7/attributes.7:27
msgid "attributes - POSIX safety concepts"
msgstr ""

#. type: Plain text
#: build/C/man7/attributes.7:35
msgid ""
"I<Note>: the text of this man page is based on the material taken from the "
"\"POSIX Safety Concepts\" section of the GNU C Library manual.  Further "
"details on the topics described here can be found in that manual."
msgstr ""

#. type: Plain text
#: build/C/man7/attributes.7:39
msgid ""
"Various function manual pages include a section ATTRIBUTES that describes "
"the safety of calling the function in various contexts.  This section "
"annotates functions with the following safety markings:"
msgstr ""

#. type: TP
#: build/C/man7/attributes.7:39
#, no-wrap
msgid "I<MT-Safe>"
msgstr ""

#. type: Plain text
#: build/C/man7/attributes.7:46
msgid ""
"I<MT-Safe> or Thread-Safe functions are safe to call in the presence of "
"other threads.  MT, in MT-Safe, stands for Multi Thread."
msgstr ""

#. type: Plain text
#: build/C/man7/attributes.7:55
msgid ""
"Being MT-Safe does not imply a function is atomic, nor that it uses any of "
"the memory synchronization mechanisms POSIX exposes to users.  It is even "
"possible that calling MT-Safe functions in sequence does not yield an "
"MT-Safe combination.  For example, having a thread call two MT-Safe "
"functions one right after the other does not guarantee behavior equivalent "
"to atomic execution of a combination of both functions, since concurrent "
"calls in other threads may interfere in a destructive way."
msgstr ""

#.  .TP
#.  .I AS-Safe
#.  .I AS-Safe
#.  or Async-Signal-Safe functions are safe to call from
#.  asynchronous signal handlers.
#.  AS, in AS-Safe, stands for Asynchronous Signal.
#
#.  Many functions that are AS-Safe may set
#.  .IR errno ,
#.  or modify the floating-point environment,
#.  because their doing so does not make them
#.  unsuitable for use in signal handlers.
#.  However, programs could misbehave should asynchronous signal handlers
#.  modify this thread-local state,
#.  and the signal handling machinery cannot be counted on to
#.  preserve it.
#.  Therefore, signal handlers that call functions that may set
#.  .I errno
#.  or modify the floating-point environment
#.  .I must
#.  save their original values, and restore them before returning.
#.  .TP
#.  .I AC-Safe
#.  .I AC-Safe
#.  or Async-Cancel-Safe functions are safe to call when
#.  asynchronous cancellation is enabled.
#.  AC in AC-Safe stands for Asynchronous Cancellation.
#
#.  The POSIX standard defines only three functions to be AC-Safe, namely
#.  .BR pthread_cancel (3),
#.  .BR pthread_setcancelstate (3),
#.  and
#.  .BR pthread_setcanceltype (3).
#.  At present the GNU C Library provides no
#.  guarantees beyond these three functions,
#.  but does document which functions are presently AC-Safe.
#.  This documentation is provided for use
#.  by the GNU C Library developers.
#
#.  Just like signal handlers, cancellation cleanup routines must configure
#.  the floating point environment they require.
#.  The routines cannot assume a floating point environment,
#.  particularly when asynchronous cancellation is enabled.
#.  If the configuration of the floating point
#.  environment cannot be performed atomically then it is also possible that
#.  the environment encountered is internally inconsistent.
#. type: Plain text
#: build/C/man7/attributes.7:109
msgid ""
"Whole-program optimizations that could inline functions across library "
"interfaces may expose unsafe reordering, and so performing inlining across "
"the GNU C Library interface is not recommended.  The documented MT-Safety "
"status is not guaranteed under whole-program optimization.  However, "
"functions defined in user-visible headers are designed to be safe for "
"inlining."
msgstr ""

#.  ", " AS-Unsafe ", " AC-Unsafe
#. type: TP
#: build/C/man7/attributes.7:109
#, no-wrap
msgid "I<MT-Unsafe>"
msgstr ""

#.  ", " AS-Unsafe ", " AC-Unsafe
#.  functions are not
#.  safe to call within the safety contexts described above.
#.  Calling them
#.  within such contexts invokes undefined behavior.
#
#.  Functions not explicitly documented as safe in a safety context should
#.  be regarded as Unsafe.
#.  .TP
#.  .I Preliminary
#.  .I Preliminary
#.  safety properties are documented, indicating these
#.  properties may
#.  .I not
#.  be counted on in future releases of
#.  the GNU C Library.
#
#.  Such preliminary properties are the result of an assessment of the
#.  properties of our current implementation,
#.  rather than of what is mandated and permitted
#.  by current and future standards.
#
#.  Although we strive to abide by the standards, in some cases our
#.  implementation is safe even when the standard does not demand safety,
#.  and in other cases our implementation does not meet the standard safety
#.  requirements.
#.  The latter are most likely bugs; the former, when marked
#.  as
#.  .IR Preliminary ,
#.  should not be counted on: future standards may
#.  require changes that are not compatible with the additional safety
#.  properties afforded by the current implementation.
#
#.  Furthermore,
#.  the POSIX standard does not offer a detailed definition of safety.
#.  We assume that, by "safe to call", POSIX means that,
#.  as long as the program does not invoke undefined behavior,
#.  the "safe to call" function behaves as specified,
#.  and does not cause other functions to deviate from their specified behavior.
#.  We have chosen to use its loose
#.  definitions of safety, not because they are the best definitions to use,
#.  but because choosing them harmonizes this manual with POSIX.
#
#.  Please keep in mind that these are preliminary definitions and annotations,
#.  and certain aspects of the definitions are still under
#.  discussion and might be subject to clarification or change.
#
#.  Over time,
#.  we envision evolving the preliminary safety notes into stable commitments,
#.  as stable as those of our interfaces.
#.  As we do, we will remove the
#.  .I Preliminary
#.  keyword from safety notes.
#.  As long as the keyword remains, however,
#.  they are not to be regarded as a promise of future behavior.
#. type: Plain text
#: build/C/man7/attributes.7:167
msgid "I<MT-Unsafe> functions are not safe to call in a multithreaded programs."
msgstr ""

#
#
#.  .SS Unsafe features
#.  Functions that are unsafe to call in certain contexts are annotated with
#.  keywords that document their features that make them unsafe to call.
#.  AS-Unsafe features in this section indicate the functions are never safe
#.  to call when asynchronous signals are enabled.
#.  AC-Unsafe features
#.  indicate they are never safe to call when asynchronous cancellation is
#.  .\" enabled.
#.  There are no MT-Unsafe marks in this section.
#.  .TP
#.  .\" .I code
#.  Functions marked with
#.  .I lock
#.  as an AS-Unsafe feature may be
#.  .\" interrupted by a signal while holding a non-recursive lock.
#.  If the signal handler calls another such function that takes the same lock,
#.  the result is a deadlock.
#
#.  Functions annotated with
#.  .I lock
#.  as an AC-Unsafe feature may, if canceled asynchronously,
#.  fail to release a lock that would have been released if their execution
#.  had not been interrupted by asynchronous thread cancellation.
#.  Once a lock is left taken,
#.  attempts to take that lock will block indefinitely.
#.  .TP
#.  .I corrupt
#.  Functions marked with
#.  .\" .I corrupt
#.  as an AS-Unsafe feature may corrupt
#.  data structures and misbehave when they interrupt,
#.  or are interrupted by, another such function.
#.  Unlike functions marked with
#.  .IR lock ,
#.  these take recursive locks to avoid MT-Safety problems,
#.  but this is not enough to stop a signal handler from observing
#.  a partially-updated data structure.
#.  Further corruption may arise from the interrupted function's
#.  failure to notice updates made by signal handlers.
#
#.  Functions marked with
#.  .I corrupt
#.  as an AC-Unsafe feature may leave
#.  data structures in a corrupt, partially updated state.
#.  Subsequent uses of the data structure may misbehave.
#
#.  .\" A special case, probably not worth documenting separately, involves
#.  .\" reallocing, or even freeing pointers.  Any case involving free could
#.  .\" be easily turned into an ac-safe leak by resetting the pointer before
#.  .\" releasing it; I don't think we have any case that calls for this sort
#.  .\" of fixing.  Fixing the realloc cases would require a new interface:
#.  .\" instead of @code{ptr=realloc(ptr,size)} we'd have to introduce
#.  .\" @code{acsafe_realloc(&ptr,size)} that would modify ptr before
#.  .\" releasing the old memory.  The ac-unsafe realloc could be implemented
#.  .\" in terms of an internal interface with this semantics (say
#.  .\" __acsafe_realloc), but since realloc can be overridden, the function
#.  .\" we call to implement realloc should not be this internal interface,
#.  .\" but another internal interface that calls __acsafe_realloc if realloc
#.  .\" was not overridden, and calls the overridden realloc with async
#.  .\" cancel disabled.  --lxoliva
#.  .TP
#.  .I heap
#.  Functions marked with
#.  .I heap
#.  may call heap memory management functions from the
#.  .BR malloc (3)/ free (3)
#.  family of functions and are only as safe as those functions.
#.  This note is thus equivalent to:
#
#.      | AS-Unsafe lock | AC-Unsafe lock fd mem |
#.  .\" @sampsafety{@asunsafe{@asulock{}}@acunsafe{@aculock{} @acsfd{} @acsmem{}}}
#.  .\"
#.  .\" Check for cases that should have used plugin instead of or in
#.  .\" addition to this.  Then, after rechecking gettext, adjust i18n if
#.  .\" needed.
#.  .TP
#.  .I dlopen
#.  Functions marked with
#.  .I dlopen
#.  use the dynamic loader to load
#.  shared libraries into the current execution image.
#.  This involves opening files, mapping them into memory,
#.  allocating additional memory, resolving symbols,
#.  applying relocations and more,
#.  all of this while holding internal dynamic loader locks.
#
#.  The locks are enough for these functions to be AS-Unsafe and AC-Unsafe,
#.  but other issues may arise.
#.  At present this is a placeholder for all
#.  potential safety issues raised by
#.  .BR dlopen (3).
#
#.  .\" dlopen runs init and fini sections of the module; does this mean
#.  .\" dlopen always implies plugin?
#.  .TP
#.  .I plugin
#.  Functions annotated with
#.  .I plugin
#.  may run code from plugins that
#.  may be external to the GNU C Library.
#.  Such plugin functions are assumed to be
#.  MT-Safe, AS-Unsafe and AC-Unsafe.
#.  Examples of such plugins are stack unwinding libraries,
#.  name service switch (NSS) and character set conversion (iconv) back-ends.
#
#.  Although the plugins mentioned as examples are all brought in by means
#.  of dlopen, the
#.  .I plugin
#.  keyword does not imply any direct
#.  involvement of the dynamic loader or the
#.  .I libdl
#.  interfaces,
#.  those are covered by
#.  .IR dlopen .
#.  For example, if one function loads a module and finds the addresses
#.  of some of its functions,
#.  while another just calls those already-resolved functions,
#.  the former will be marked with
#.  .IR dlopen ,
#.  whereas the latter will get the
#.  .IR plugin .
#.  When a single function takes all of these actions, then it gets both marks.
#.  .TP
#.  .I i18n
#.  Functions marked with
#.  .I i18n
#.  may call internationalization
#.  functions of the
#.  .BR gettext (3)
#.  family and will be only as safe as those
#.  functions.
#.  This note is thus equivalent to:
#
#.      | MT-Safe env | AS-Unsafe corrupt heap dlopen | AC-Unsafe corrupt |
#
#.  .\" @sampsafety{@mtsafe{@mtsenv{}}@asunsafe{@asucorrupt{} @ascuheap{} @ascudlopen{}}@acunsafe{@acucorrupt{}}}
#.  .TP
#.  .I timer
#.  Functions marked with
#.  .I timer
#.  use the
#.  .BR alarm (3)
#.  function or
#.  similar to set a time-out for a system call or a long-running operation.
#.  In a multi-threaded program, there is a risk that the time-out signal
#.  will be delivered to a different thread,
#.  thus failing to interrupt the intended thread.
#.  Besides being MT-Unsafe, such functions are always
#.  AS-Unsafe, because calling them in signal handlers may interfere with
#.  timers set in the interrupted code, and AC-Unsafe,
#.  because there is no safe way to guarantee an earlier timer
#.  will be reset in case of asynchronous cancellation.
#. type: Plain text
#: build/C/man7/attributes.7:325
msgid ""
"Other keywords that appear in safety notes are defined in subsequent "
"sections."
msgstr ""

#. type: SS
#: build/C/man7/attributes.7:325
#, no-wrap
msgid "Conditionally safe features"
msgstr ""

#. type: Plain text
#: build/C/man7/attributes.7:337
msgid ""
"For some features that make functions unsafe to call in certain contexts, "
"there are known ways to avoid the safety problem other than refraining from "
"calling the function altogether.  The keywords that follow refer to such "
"features, and each of their definitions indicates how the whole program "
"needs to be constrained in order to remove the safety problem indicated by "
"the keyword.  Only when all the reasons that make a function unsafe are "
"observed and addressed, by applying the documented constraints, does the "
"function become safe to call in a context."
msgstr ""

#. type: TP
#: build/C/man7/attributes.7:337
#, no-wrap
msgid "I<init>"
msgstr ""

#. type: Plain text
#: build/C/man7/attributes.7:343
msgid ""
"Functions marked with I<init> as an MT-Unsafe feature perform MT-Unsafe "
"initialization when they are first called."
msgstr ""

#
#.  Functions marked with
#.  .I init
#.  as an AS-Unsafe or AC-Unsafe feature use the GNU C Library internal
#.  .I libc_once
#.  machinery or similar to initialize internal data structures.
#
#.  If a signal handler interrupts such an initializer,
#.  and calls any function that also performs
#.  .I libc_once
#.  initialization, it will deadlock if the thread library has been loaded.
#
#.  Furthermore, if an initializer is partially complete before it is canceled
#.  or interrupted by a signal whose handler requires the same initialization,
#.  some or all of the initialization may be performed more than once,
#.  leaking resources or even resulting in corrupt internal data.
#
#.  Applications that need to call functions marked with
#.  .I init
#.  as an AS-Safety or AC-Unsafe feature should ensure
#.  the initialization is performed
#.  before configuring signal handlers or enabling cancellation,
#.  so that the AS-Safety and AC-Safety issues related with
#.  .I libc_once
#.  do not arise.
#
#.  .\" We may have to extend the annotations to cover conditions in which
#.  .\" initialization may or may not occur, since an initial call in a safe
#.  .\" context is no use if the initialization doesn't take place at that
#.  .\" time: it doesn't remove the risk for later calls.
#. type: Plain text
#: build/C/man7/attributes.7:378
msgid ""
"Calling such a function at least once in single-threaded mode removes this "
"specific cause for the function to be regarded as MT-Unsafe.  If no other "
"cause for that remains, the function can then be safely called after other "
"threads are started."
msgstr ""

#. type: TP
#: build/C/man7/attributes.7:378
#, no-wrap
msgid "I<race>"
msgstr ""

#
#.  We consider access to objects passed as (indirect) arguments to
#.  functions to be data race free.
#.  The assurance of data race free objects
#.  is the caller's responsibility.
#.  We will not mark a function as MT-Unsafe or AS-Unsafe
#.  if it misbehaves when users fail to take the measures required by
#.  POSIX to avoid data races when dealing with such objects.
#.  As a general rule, if a function is documented as reading from
#.  an object passed (by reference) to it, or modifying it,
#.  users ought to use memory synchronization primitives
#.  to avoid data races just as they would should they perform
#.  the accesses themselves rather than by calling the library function.
#.  Standard I/O
#.  .RI ( "FILE *" )
#.  streams are the exception to the general rule,
#.  in that POSIX mandates the library to guard against data races
#.  in many functions that manipulate objects of this specific opaque type.
#.  We regard this as a convenience provided to users,
#.  rather than as a general requirement whose expectations
#.  should extend to other types.
#
#.  In order to remind users that guarding certain arguments is their
#.  responsibility, we will annotate functions that take objects of certain
#.  types as arguments.
#.  We draw the line for objects passed by users as follows:
#.  objects whose types are exposed to users,
#.  and that users are expected to access directly,
#.  such as memory buffers, strings,
#.  and various user-visible structured types, do
#.  .I not
#.  give reason for functions to be annotated with
#.  .IR race .
#.  It would be noisy and redundant with the general requirement,
#.  and not many would be surprised by the library's lack of internal
#.  guards when accessing objects that can be accessed directly by users.
#
#.  As for objects that are opaque or opaque-like,
#.  in that they are to be manipulated only by passing them
#.  to library functions (e.g.,
#.  .IR FILE ,
#.  .IR DIR ,
#.  .IR obstack ,
#.  .IR iconv_t ),
#.  there might be additional expectations as to internal coordination
#.  of access by the library.
#.  We will annotate, with
#.  .I race
#.  followed by a colon and the argument name,
#.  functions that take such objects but that do not take
#.  care of synchronizing access to them by default.
#.  For example,
#.  .I FILE
#.  stream
#.  .I unlocked
#.  functions
#.  .RB ( unlocked_stdio (3))
#.  will be annotated,
#.  but those that perform implicit locking on
#.  .I FILE
#.  streams by default will not,
#.  even though the implicit locking may be disabled on a per-stream basis.
#
#.  In either case, we will not regard as MT-Unsafe functions that may
#.  access user-supplied objects in unsafe ways should users fail to ensure
#.  the accesses are well defined.
#.  The notion prevails that users are expected to safeguard against
#.  data races any user-supplied objects that the library accesses
#.  on their behalf.
#
#.  .\" The above describes @mtsrace; @mtasurace is described below.
#
#.  This user responsibility does not apply, however,
#.  to objects controlled by the library itself,
#.  such as internal objects and static buffers used
#.  to return values from certain calls.
#.  When the library doesn't guard them against concurrent uses,
#.  these cases are regarded as MT-Unsafe and AS-Unsafe (although the
#.  .I race
#.  mark under AS-Unsafe will be omitted
#.  as redundant with the one under MT-Unsafe).
#.  As in the case of user-exposed objects,
#.  the mark may be followed by a colon and an identifier.
#.  The identifier groups all functions that operate on a
#.  certain unguarded object; users may avoid the MT-Safety issues related
#.  with unguarded concurrent access to such internal objects by creating a
#.  non-recursive mutex related with the identifier,
#.  and always holding the mutex when calling any function marked
#.  as racy on that identifier,
#.  as they would have to should the identifier be
#.  an object under user control.
#.  The non-recursive mutex avoids the MT-Safety issue,
#.  but it trades one AS-Safety issue for another,
#.  so use in asynchronous signals remains undefined.
#
#.  When the identifier relates to a static buffer used to hold return values,
#.  the mutex must be held for as long as the buffer remains in use
#.  by the caller.
#.  Many functions that return pointers to static buffers offer reentrant
#.  variants that store return values in caller-supplied buffers instead.
#.  In some cases, such as
#.  .BR tmpname (3),
#.  the variant is chosen not by calling an alternate entry point,
#.  but by passing a non-NULL pointer to the buffer in which the
#.  returned values are to be stored.
#.  These variants are generally preferable in multi-threaded programs,
#.  although some of them are not MT-Safe because of other internal buffers,
#.  also documented with
#.  .I race
#.  notes.
#. type: Plain text
#: build/C/man7/attributes.7:499
msgid ""
"Functions annotated with I<race> as an MT-Safety issue operate on objects in "
"ways that may cause data races or similar forms of destructive interference "
"out of concurrent execution.  In some cases, the objects are passed to the "
"functions by users; in others, they are used by the functions to return "
"values to users; in others, they are not even exposed to users."
msgstr ""

#. type: TP
#: build/C/man7/attributes.7:499
#, no-wrap
msgid "I<const>"
msgstr ""

#.  and AS-Unsafe,
#.  equally
#.  and AS-Unsafe
#.  and AS-Safe
#. type: Plain text
#: build/C/man7/attributes.7:520
msgid ""
"Functions marked with I<const> as an MT-Safety issue non-atomically modify "
"internal objects that are better regarded as constant, because a substantial "
"portion of the GNU C Library accesses them without synchronization.  Unlike "
"I<race>, which causes both readers and writers of internal objects to be "
"regarded as MT-Unsafe, this mark is applied to writers only.  Writers remain "
"MT-Unsafe to call, but the then-mandatory constness of objects they modify "
"enables readers to be regarded as MT-Safe (as long as no other reasons for "
"them to be unsafe remain), since the lack of synchronization is not a "
"problem when the objects are effectively constant."
msgstr ""

#.  The non-recursive locking removes the MT-Safety problem,
#.  but it trades one AS-Safety problem for another,
#.  so use in asynchronous signals remains undefined.
#
#.  .\" But what if, instead of marking modifiers with const:id and readers
#.  .\" with just id, we marked writers with race:id and readers with ro:id?
#.  .\" Instead of having to define each instance of 'id', we'd have a
#.  .\" general pattern governing all such 'id's, wherein race:id would
#.  .\" suggest the need for an exclusive/write lock to make the function
#.  .\" safe, whereas ro:id would indicate 'id' is expected to be read-only,
#.  .\" but if any modifiers are called (while holding an exclusive lock),
#.  .\" then ro:id-marked functions ought to be guarded with a read lock for
#.  .\" safe operation.  ro:env or ro:locale, for example, seems to convey
#.  .\" more clearly the expectations and the meaning, than just env or
#.  .\" locale.
#. type: Plain text
#: build/C/man7/attributes.7:550
msgid ""
"The identifier that follows the I<const> mark will appear by itself as a "
"safety note in readers.  Programs that wish to work around this safety "
"issue, so as to call writers, may use a non-recursive read-write lock "
"associated with the identifier, and guard I<all> calls to functions marked "
"with I<const> followed by the identifier with a write lock, and I<all> calls "
"to functions marked with the identifier by itself with a read lock."
msgstr ""

#. type: TP
#: build/C/man7/attributes.7:550
#, no-wrap
msgid "I<sig>"
msgstr ""

#.  (that implies an identical AS-Safety issue, omitted for brevity)
#. type: Plain text
#: build/C/man7/attributes.7:559
msgid ""
"Functions marked with I<sig> as a MT-Safety issue may temporarily install a "
"signal handler for internal purposes, which may interfere with other uses of "
"the signal, identified after a colon."
msgstr ""

#
#.  There is no safe way to guarantee the original signal handler is
#.  restored in case of asynchronous cancellation,
#.  therefore so-marked functions are also AC-Unsafe.
#
#.  .\" fixme: at least deferred cancellation should get it right, and would
#.  .\" obviate the restoring bit below, and the qualifier above.
#
#.  Besides the measures recommended to work around the
#.  MT-Safety and AS-Safety problem,
#.  in order to avert the cancellation problem,
#.  disabling asynchronous cancellation
#.  .I and
#.  installing a cleanup handler to restore the signal to the desired state
#.  and to release the mutex are recommended.
#. type: Plain text
#: build/C/man7/attributes.7:581
msgid ""
"This safety problem can be worked around by ensuring that no other uses of "
"the signal will take place for the duration of the call.  Holding a "
"non-recursive mutex while calling all functions that use the same temporary "
"signal; blocking that signal before the call and resetting its handler "
"afterwards is recommended."
msgstr ""

#. type: TP
#: build/C/man7/attributes.7:581
#, no-wrap
msgid "I<term>"
msgstr ""

#.  The same window enables changes made by asynchronous signals to be lost.
#.  These functions are also AS-Unsafe,
#.  but the corresponding mark is omitted as redundant.
#. type: Plain text
#: build/C/man7/attributes.7:597
msgid ""
"Functions marked with I<term> as an MT-Safety issue may change the terminal "
"settings in the recommended way, namely: call B<tcgetattr>(3), modify some "
"flags, and then call B<tcsetattr>(3), this creates a window in which changes "
"made by other threads are lost.  Thus, functions marked with I<term> are "
"MT-Unsafe."
msgstr ""

#
#.  Functions marked with
#.  .I term
#.  as an AC-Safety issue are supposed to
#.  restore terminal settings to their original state,
#.  after temporarily changing them, but they may fail to do so if canceled.
#
#.  .\" fixme: at least deferred cancellation should get it right, and would
#.  .\" obviate the restoring bit below, and the qualifier above.
#
#.  Besides the measures recommended to work around the
#.  MT-Safety and AS-Safety problem,
#.  in order to avert the cancellation problem,
#.  disabling asynchronous cancellation
#.  .I and
#.  installing a cleanup handler to
#.  restore the terminal settings to the original state and to release the
#.  mutex are recommended.
#. type: Plain text
#: build/C/man7/attributes.7:632
msgid ""
"It is thus advisable for applications using the terminal to avoid concurrent "
"and reentrant interactions with it, by not using it in signal handlers or "
"blocking signals that might use it, and holding a lock while calling these "
"functions and interacting with the terminal.  This lock should also be used "
"for mutual exclusion with functions marked with I<race:tcattr(fd)>, where "
"I<fd> is a file descriptor for the controlling terminal.  The caller may use "
"a single mutex for simplicity, or use one mutex per terminal, even if "
"referenced by different file descriptors."
msgstr ""

#. type: SS
#: build/C/man7/attributes.7:632
#, no-wrap
msgid "Other safety remarks"
msgstr ""

#. type: Plain text
#: build/C/man7/attributes.7:636
msgid ""
"Additional keywords may be attached to functions, indicating features that "
"do not make a function unsafe to call, but that may need to be taken into "
"account in certain classes of programs:"
msgstr ""

#. type: TP
#: build/C/man7/attributes.7:636
#, no-wrap
msgid "I<locale>"
msgstr ""

#. type: Plain text
#: build/C/man7/attributes.7:648
msgid ""
"Functions annotated with I<locale> as an MT-Safety issue read from the "
"locale object without any form of synchronization.  Functions annotated with "
"I<locale> called concurrently with locale changes may behave in ways that do "
"not correspond to any of the locales active during their execution, but an "
"unpredictable mix thereof."
msgstr ""

#.  or AS-Unsafe,
#.  Should the locking strategy suggested under @code{const} be used,
#.  failure to guard locale uses is not as fatal as data races in
#.  general: unguarded uses will @emph{not} follow dangling pointers or
#.  access uninitialized, unmapped or recycled memory.  Each access will
#.  read from a consistent locale object that is or was active at some
#.  point during its execution.  Without synchronization, however, it
#.  cannot even be assumed that, after a change in locale, earlier
#.  locales will no longer be used, even after the newly-chosen one is
#.  used in the thread.  Nevertheless, even though unguarded reads from
#.  the locale will not violate type safety, functions that access the
#.  locale multiple times may invoke all sorts of undefined behavior
#.  because of the unexpected locale changes.
#. type: Plain text
#: build/C/man7/attributes.7:671
msgid ""
"We do not mark these functions as MT-Unsafe, however, because functions that "
"modify the locale object are marked with I<const:locale> and regarded as "
"unsafe.  Being unsafe, the latter are not to be called when multiple threads "
"are running or asynchronous signals are enabled, and so the locale can be "
"considered effectively constant in these contexts, which makes the former "
"safe."
msgstr ""

#. type: TP
#: build/C/man7/attributes.7:671
#, no-wrap
msgid "I<env>"
msgstr ""

#. type: Plain text
#: build/C/man7/attributes.7:680
msgid ""
"Functions marked with I<env> as an MT-Safety issue access the environment "
"with B<getenv>(3)  or similar, without any guards to ensure safety in the "
"presence of concurrent modifications."
msgstr ""

#.  or AS-Unsafe,
#. type: Plain text
#: build/C/man7/attributes.7:691
msgid ""
"We do not mark these functions as MT-Unsafe, however, because functions that "
"modify the environment are all marked with I<const:env> and regarded as "
"unsafe.  Being unsafe, the latter are not to be called when multiple threads "
"are running or asynchronous signals are enabled, and so the environment can "
"be considered effectively constant in these contexts, which makes the former "
"safe."
msgstr ""

#. type: TP
#: build/C/man7/attributes.7:691
#, no-wrap
msgid "I<hostid>"
msgstr ""

#. type: Plain text
#: build/C/man7/attributes.7:710
msgid ""
"The function marked with I<hostid> as an MT-Safety issue reads from the "
"system-wide data structures that hold the \"host ID\" of the machine.  These "
"data structures cannot generally be modified atomically.  Since it is "
"expected that the \"host ID\" will not normally change, the function that "
"reads from it (B<gethostid>(3))  is regarded as safe, whereas the function "
"that modifies it (B<sethostid>(3))  is marked with I<const:hostid>, "
"indicating it may require special care if it is to be called.  In this "
"specific case, the special care amounts to system-wide (not merely "
"intra-process) coordination."
msgstr ""

#. type: TP
#: build/C/man7/attributes.7:710
#, no-wrap
msgid "I<sigintr>"
msgstr ""

#. type: Plain text
#: build/C/man7/attributes.7:719
msgid ""
"Functions marked with I<sigintr> as an MT-Safety issue access the GNU C "
"Library I<_sigintr> internal data structure without any guards to ensure "
"safety in the presence of concurrent modifications."
msgstr ""

#.  or AS-Unsafe,
#.  .TP
#.  .I fd
#.  Functions annotated with
#.  .I fd
#.  as an AC-Safety issue may leak file
#.  descriptors if asynchronous thread cancellation interrupts their
#.  execution.
#
#.  Functions that allocate or deallocate file descriptors will generally be
#.  marked as such.
#.  Even if they attempted to protect the file descriptor
#.  allocation and deallocation with cleanup regions,
#.  allocating a new descriptor and storing its number where the cleanup region
#.  could release it cannot be performed as a single atomic operation.
#.  Similarly,
#.  releasing the descriptor and taking it out of the data structure
#.  normally responsible for releasing it cannot be performed atomically.
#.  There will always be a window in which the descriptor cannot be released
#.  because it was not stored in the cleanup handler argument yet,
#.  or it was already taken out before releasing it.
#.  .\" It cannot be taken out after release:
#.  an open descriptor could mean either that the descriptor still
#.  has to be closed,
#.  or that it already did so but the descriptor was
#.  reallocated by another thread or signal handler.
#
#.  Such leaks could be internally avoided, with some performance penalty,
#.  by temporarily disabling asynchronous thread cancellation.
#.  However,
#.  since callers of allocation or deallocation functions would have to do
#.  this themselves, to avoid the same sort of leak in their own layer,
#.  it makes more sense for the library to assume they are taking care of it
#.  than to impose a performance penalty that is redundant when the problem
#.  is solved in upper layers, and insufficient when it is not.
#
#.  This remark by itself does not cause a function to be regarded as
#.  AC-Unsafe.
#.  However, cumulative effects of such leaks may pose a
#.  problem for some programs.
#.  If this is the case,
#.  suspending asynchronous cancellation for the duration of calls
#.  to such functions is recommended.
#.  .TP
#.  .I mem
#.  Functions annotated with
#.  .I mem
#.  as an AC-Safety issue may leak
#.  memory if asynchronous thread cancellation interrupts their execution.
#
#.  The problem is similar to that of file descriptors: there is no atomic
#.  interface to allocate memory and store its address in the argument to a
#.  cleanup handler,
#.  or to release it and remove its address from that argument,
#.  without at least temporarily disabling asynchronous cancellation,
#.  which these functions do not do.
#
#.  This remark does not by itself cause a function to be regarded as
#.  generally AC-Unsafe.
#.  However, cumulative effects of such leaks may be
#.  severe enough for some programs that disabling asynchronous cancellation
#.  for the duration of calls to such functions may be required.
#. type: Plain text
#: build/C/man7/attributes.7:792
msgid ""
"We do not mark these functions as MT-Unsafe, however, because functions that "
"modify this data structure are all marked with I<const:sigintr> and regarded "
"as unsafe.  Being unsafe, the latter are not to be called when multiple "
"threads are running or asynchronous signals are enabled, and so the data "
"structure can be considered effectively constant in these contexts, which "
"makes the former safe."
msgstr ""

#. type: TP
#: build/C/man7/attributes.7:792
#, no-wrap
msgid "I<cwd>"
msgstr ""

#. type: Plain text
#: build/C/man7/attributes.7:800
msgid ""
"Functions marked with I<cwd> as an MT-Safety issue may temporarily change "
"the current working directory during their execution, which may cause "
"relative pathnames to be resolved in unexpected ways in other threads or "
"within asynchronous signal or cancellation handlers."
msgstr ""

#.  or AS-Unsafe,
#.  .TP
#.  .I !posix
#.  This remark, as an MT-Safety, AS-Safety or AC-Safety
#.  note to a function,
#.  indicates the safety status of the function is known to differ
#.  from the specified status in the POSIX standard.
#.  For example, POSIX does not require a function to be Safe,
#.  but our implementation is, or vice-versa.
#
#.  For the time being, the absence of this remark does not imply the safety
#.  properties we documented are identical to those mandated by POSIX for
#.  the corresponding functions.
#. type: Plain text
#: build/C/man7/attributes.7:823
msgid ""
"This is not enough of a reason to mark so-marked functions as MT-Unsafe, but "
"when this behavior is optional (e.g., B<nftw>(3)  with B<FTW_CHDIR>), "
"avoiding the option may be a good alternative to using full pathnames or "
"file descriptor-relative (e.g., B<openat>(2))  system calls."
msgstr ""

#. type: TP
#: build/C/man7/attributes.7:823
#, no-wrap
msgid "I<:identifier>"
msgstr ""

#. type: Plain text
#: build/C/man7/attributes.7:839
msgid ""
"Annotations may sometimes be followed by identifiers, intended to group "
"several functions that, for example, access the data structures in an unsafe "
"way, as in I<race> and I<const>, or to provide more specific information, "
"such as naming a signal in a function marked with I<sig>.  It is envisioned "
"that it may be applied to I<lock> and I<corrupt> as well in the future."
msgstr ""

#. type: Plain text
#: build/C/man7/attributes.7:851
msgid ""
"In most cases, the identifier will name a set of functions, but it may name "
"global objects or function arguments, or identifiable properties or logical "
"components associated with them, with a notation such as, for example, "
"I<:buf(arg)> to denote a buffer associated with the argument I<arg>, or "
"I<:tcattr(fd)> to denote the terminal attributes of a file descriptor I<fd>."
msgstr ""

#. type: Plain text
#: build/C/man7/attributes.7:856
msgid ""
"The most common use for identifiers is to provide logical groups of "
"functions and arguments that need to be protected by the same "
"synchronization primitive in order to ensure safe operation in a given "
"context."
msgstr ""

#. type: TP
#: build/C/man7/attributes.7:856
#, no-wrap
msgid "I</condition>"
msgstr ""

#.  Such conditions as
#.  .I /hurd
#.  or
#.  .I /!linux!bsd
#.  indicate the preceding marker only
#.  applies when the underlying kernel is the HURD,
#.  or when it is neither Linux nor a BSD kernel, respectively.
#. type: Plain text
#: build/C/man7/attributes.7:877
msgid ""
"Some safety annotations may be conditional, in that they only apply if a "
"boolean expression involving arguments, global variables or even the "
"underlying kernel evaluates to true.  For example, I</!ps> and "
"I</one_per_line> indicate the preceding marker only applies when argument "
"I<ps> is NULL, or global variable I<one_per_line> is nonzero."
msgstr ""

#. type: Plain text
#: build/C/man7/attributes.7:882
msgid ""
"When all marks that render a function unsafe are adorned with such "
"conditions, and none of the named conditions hold, then the function can be "
"regarded as safe."
msgstr ""

#. type: Plain text
#: build/C/man7/attributes.7:885
msgid "B<pthreads>(7), B<signal-safety>(7)"
msgstr ""

#. type: Plain text
#: build/C/man7/nptl.7:29
msgid "nptl - Native POSIX Threads Library"
msgstr ""

#. type: Plain text
#: build/C/man7/nptl.7:34
msgid ""
"NPTL (Native POSIX Threads Library)  is the GNU C library POSIX threads "
"implementation that is used on modern Linux systems."
msgstr ""

#. type: SS
#: build/C/man7/nptl.7:34
#, no-wrap
msgid "NPTL and signals"
msgstr ""

#. type: Plain text
#: build/C/man7/nptl.7:43
msgid ""
"NPTL makes internal use of the first two real-time signals (signal numbers "
"32 and 33).  One of these signals is used to support thread cancellation and "
"POSIX timers (see B<timer_create>(2)); the other is used as part of a "
"mechanism that ensures all threads in a process always have the same UIDs "
"and GIDs, as required by POSIX.  These signals cannot be used in "
"applications."
msgstr ""

#. type: Plain text
#: build/C/man7/nptl.7:49
msgid ""
"To prevent accidental use of these signals in applications, which might "
"interfere with the operation of the NPTL implementation, various glibc "
"library functions and system call wrapper functions attempt to hide these "
"signals from applications, as follows:"
msgstr ""

#. type: Plain text
#: build/C/man7/nptl.7:52
msgid "B<SIGRTMIN> is defined with the value 34 (rather than 32)."
msgstr ""

#. type: Plain text
#: build/C/man7/nptl.7:60
msgid ""
"The B<sigwaitinfo>(2), B<sigtimedwait>(2), and B<sigwait>(3)  interfaces "
"silently ignore requests to wait for these two signals if they are specified "
"in the signal set argument of these calls."
msgstr ""

#. type: Plain text
#: build/C/man7/nptl.7:66
msgid ""
"The B<sigprocmask>(2)  and B<pthread_sigmask>(3)  interfaces silently ignore "
"attempts to block these two signals."
msgstr ""

#. type: Plain text
#: build/C/man7/nptl.7:75
msgid ""
"The B<sigaction>(2), B<pthread_kill>(3), and B<pthread_sigqueue>(3)  "
"interfaces fail with the error B<EINVAL> (indicating an invalid signal "
"number) if these signals are specified."
msgstr ""

#. type: Plain text
#: build/C/man7/nptl.7:79
msgid ""
"B<sigfillset>(3)  does not include these two signals when it creates a full "
"signal set."
msgstr ""

#. type: SS
#: build/C/man7/nptl.7:79
#, no-wrap
msgid "NPTL and process credential changes"
msgstr ""

#. type: Plain text
#: build/C/man7/nptl.7:89
msgid ""
"At the Linux kernel level, credentials (user and group IDs) are a per-thread "
"attribute.  However, POSIX requires that all of the POSIX threads in a "
"process have the same credentials.  To accommodate this requirement, the "
"NPTL implementation wraps all of the system calls that change process "
"credentials with functions that, in addition to invoking the underlying "
"system call, arrange for all other threads in the process to also change "
"their credentials."
msgstr ""

#. type: Plain text
#: build/C/man7/nptl.7:99
msgid ""
"The implementation of each of these system calls involves the use of a "
"real-time signal that is sent (using B<tgkill>(2))  to each of the other "
"threads that must change its credentials.  Before sending these signals, the "
"thread that is changing credentials saves the new credential(s) and records "
"the system call being employed in a global buffer.  A signal handler in the "
"receiving thread(s) fetches this information and then uses the same system "
"call to change its credentials."
msgstr ""

#.  FIXME .
#.  Maybe say something about vfork() not being serialized wrt set*id() APIs?
#.  https://sourceware.org/bugzilla/show_bug.cgi?id=14749
#. type: Plain text
#: build/C/man7/nptl.7:114
msgid ""
"Wrapper functions employing this technique are provided for B<setgid>(2), "
"B<setuid>(2), B<setegid>(2), B<seteuid>(2), B<setregid>(2), B<setreuid>(2), "
"B<setresgid>(2), B<setresuid>(2), and B<setgroups>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/nptl.7:117
msgid ""
"For details of the conformance of NPTL to the POSIX standard, see "
"B<pthreads>(7)."
msgstr ""

#.  See POSIX.1-2008 specification of pthread_mutexattr_init()
#.  See sysdeps/x86/bits/pthreadtypes.h
#. type: Plain text
#: build/C/man7/nptl.7:128
msgid ""
"POSIX says that any thread in any process with access to the memory "
"containing a process-shared (B<PTHREAD_PROCESS_SHARED>)  mutex can operate "
"on that mutex.  However, on 64-bit x86 systems, the mutex definition for "
"x86-64 is incompatible with the mutex definition for i386, meaning that "
"32-bit and 64-bit binaries can't share mutexes on x86-64 systems."
msgstr ""

#. type: Plain text
#: build/C/man7/nptl.7:133
msgid "B<credentials>(7), B<pthreads>(7), B<signal>(7), B<standards>(7)"
msgstr ""
