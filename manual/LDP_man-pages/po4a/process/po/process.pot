# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-03-12 14:00+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man2/acct.2:31 build/C/man5/acct.5:25
#, no-wrap
msgid "ACCT"
msgstr ""

#. type: TH
#: build/C/man2/acct.2:31
#, no-wrap
msgid "2016-03-15"
msgstr ""

#. type: TH
#: build/C/man2/acct.2:31 build/C/man5/acct.5:25 build/C/man7/capabilities.7:48 build/C/man2/capget.2:16 build/C/man7/cpuset.7:25 build/C/man7/credentials.7:27 build/C/man2/getgid.2:25 build/C/man2/getgroups.2:32 build/C/man2/getpid.2:25 build/C/man2/getpriority.2:45 build/C/man2/getresuid.2:28 build/C/man2/getrlimit.2:64 build/C/man2/getrusage.2:39 build/C/man2/getsid.2:27 build/C/man2/getuid.2:26 build/C/man2/iopl.2:33 build/C/man2/ioprio_set.2:24 build/C/man2/ipc.2:25 build/C/man2/seteuid.2:29 build/C/man2/setfsgid.2:32 build/C/man2/setfsuid.2:32 build/C/man2/setgid.2:30 build/C/man2/setpgid.2:48 build/C/man2/setresuid.2:27 build/C/man2/setreuid.2:46 build/C/man2/setsid.2:31 build/C/man2/setuid.2:31 build/C/man7/sysvipc.7:25 build/C/man3/ulimit.3:27 build/C/man2/seccomp.2:28 build/C/man7/cgroups.7:26 build/C/man2/pidfd_getfd.2:25 build/C/man2/pidfd_open.2:25 build/C/man2/pidfd_send_signal.2:25
#, no-wrap
msgid "Linux"
msgstr ""

#. type: TH
#: build/C/man2/acct.2:31 build/C/man5/acct.5:25 build/C/man7/capabilities.7:48 build/C/man2/capget.2:16 build/C/man7/cpuset.7:25 build/C/man7/credentials.7:27 build/C/man2/getgid.2:25 build/C/man2/getgroups.2:32 build/C/man2/getpid.2:25 build/C/man2/getpriority.2:45 build/C/man2/getresuid.2:28 build/C/man2/getrlimit.2:64 build/C/man2/getrusage.2:39 build/C/man2/getsid.2:27 build/C/man2/getuid.2:26 build/C/man3/group_member.3:25 build/C/man2/iopl.2:33 build/C/man2/ioprio_set.2:24 build/C/man2/ipc.2:25 build/C/man2/seteuid.2:29 build/C/man2/setfsgid.2:32 build/C/man2/setfsuid.2:32 build/C/man2/setgid.2:30 build/C/man2/setpgid.2:48 build/C/man2/setresuid.2:27 build/C/man2/setreuid.2:46 build/C/man2/setsid.2:31 build/C/man2/setuid.2:31 build/C/man7/sysvipc.7:25 build/C/man3/ulimit.3:27 build/C/man2/seccomp.2:28 build/C/man7/cgroups.7:26 build/C/man2/pidfd_getfd.2:25 build/C/man2/pidfd_open.2:25 build/C/man2/pidfd_send_signal.2:25 build/C/man3/posix_spawn.3:31
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr ""

#. type: SH
#: build/C/man2/acct.2:32 build/C/man5/acct.5:26 build/C/man7/capabilities.7:49 build/C/man2/capget.2:17 build/C/man7/cpuset.7:26 build/C/man7/credentials.7:28 build/C/man2/getgid.2:26 build/C/man2/getgroups.2:33 build/C/man2/getpid.2:26 build/C/man2/getpriority.2:46 build/C/man2/getresuid.2:29 build/C/man2/getrlimit.2:65 build/C/man2/getrusage.2:40 build/C/man2/getsid.2:28 build/C/man2/getuid.2:27 build/C/man3/group_member.3:26 build/C/man2/iopl.2:34 build/C/man2/ioprio_set.2:25 build/C/man2/ipc.2:26 build/C/man2/seteuid.2:30 build/C/man2/setfsgid.2:33 build/C/man2/setfsuid.2:33 build/C/man2/setgid.2:31 build/C/man2/setpgid.2:49 build/C/man2/setresuid.2:28 build/C/man2/setreuid.2:47 build/C/man2/setsid.2:32 build/C/man2/setuid.2:32 build/C/man7/sysvipc.7:26 build/C/man3/ulimit.3:28 build/C/man2/seccomp.2:29 build/C/man7/cgroups.7:27 build/C/man2/pidfd_getfd.2:26 build/C/man2/pidfd_open.2:26 build/C/man2/pidfd_send_signal.2:26 build/C/man3/posix_spawn.3:32
#, no-wrap
msgid "NAME"
msgstr ""

#. type: Plain text
#: build/C/man2/acct.2:34
msgid "acct - switch process accounting on or off"
msgstr ""

#. type: SH
#: build/C/man2/acct.2:34 build/C/man5/acct.5:28 build/C/man2/capget.2:19 build/C/man2/getgid.2:28 build/C/man2/getgroups.2:35 build/C/man2/getpid.2:28 build/C/man2/getpriority.2:48 build/C/man2/getresuid.2:31 build/C/man2/getrlimit.2:67 build/C/man2/getrusage.2:42 build/C/man2/getsid.2:30 build/C/man2/getuid.2:29 build/C/man3/group_member.3:28 build/C/man2/iopl.2:36 build/C/man2/ioprio_set.2:27 build/C/man2/ipc.2:28 build/C/man2/seteuid.2:32 build/C/man2/setfsgid.2:35 build/C/man2/setfsuid.2:35 build/C/man2/setgid.2:33 build/C/man2/setpgid.2:51 build/C/man2/setresuid.2:30 build/C/man2/setreuid.2:49 build/C/man2/setsid.2:34 build/C/man2/setuid.2:34 build/C/man3/ulimit.3:30 build/C/man2/seccomp.2:31 build/C/man2/pidfd_getfd.2:28 build/C/man2/pidfd_open.2:28 build/C/man2/pidfd_send_signal.2:28 build/C/man3/posix_spawn.3:34
#, no-wrap
msgid "SYNOPSIS"
msgstr ""

#. type: Plain text
#: build/C/man2/acct.2:38
#, no-wrap
msgid "B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/acct.2:40
#, no-wrap
msgid "B<int acct(const char *>I<filename>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/acct.2:46 build/C/man2/getgroups.2:49 build/C/man2/getrlimit.2:84 build/C/man2/getsid.2:40 build/C/man3/group_member.3:36 build/C/man2/seteuid.2:44 build/C/man2/setpgid.2:71 build/C/man2/setreuid.2:61
msgid "Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr ""

#. type: Plain text
#: build/C/man2/acct.2:49
msgid "B<acct>():"
msgstr ""

#. 		commit 266865c0e7b79d4196e2cc393693463f03c90bd8
#. type: Plain text
#: build/C/man2/acct.2:57
#, no-wrap
msgid ""
"    Since glibc 2.21:\n"
"        _DEFAULT_SOURCE\n"
"    In glibc 2.19 and 2.20:\n"
"        _DEFAULT_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE\\ E<lt>\\ 500)\n"
"    Up to and including glibc 2.19:\n"
"        _BSD_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE\\ E<lt>\\ 500)\n"
msgstr ""

#. type: SH
#: build/C/man2/acct.2:58 build/C/man5/acct.5:30 build/C/man7/capabilities.7:51 build/C/man2/capget.2:25 build/C/man7/cpuset.7:28 build/C/man7/credentials.7:30 build/C/man2/getgid.2:36 build/C/man2/getgroups.2:56 build/C/man2/getpid.2:36 build/C/man2/getpriority.2:56 build/C/man2/getresuid.2:39 build/C/man2/getrlimit.2:88 build/C/man2/getrusage.2:48 build/C/man2/getsid.2:52 build/C/man2/getuid.2:37 build/C/man3/group_member.3:40 build/C/man2/iopl.2:40 build/C/man2/ioprio_set.2:35 build/C/man2/ipc.2:34 build/C/man2/seteuid.2:54 build/C/man2/setfsgid.2:39 build/C/man2/setfsuid.2:39 build/C/man2/setgid.2:39 build/C/man2/setpgid.2:98 build/C/man2/setresuid.2:38 build/C/man2/setreuid.2:73 build/C/man2/setsid.2:43 build/C/man2/setuid.2:40 build/C/man7/sysvipc.7:28 build/C/man3/ulimit.3:34 build/C/man2/seccomp.2:44 build/C/man7/cgroups.7:29 build/C/man2/pidfd_getfd.2:32 build/C/man2/pidfd_open.2:34 build/C/man2/pidfd_send_signal.2:35 build/C/man3/posix_spawn.3:48
#, no-wrap
msgid "DESCRIPTION"
msgstr ""

#. type: Plain text
#: build/C/man2/acct.2:68
msgid ""
"The B<acct>()  system call enables or disables process accounting.  If "
"called with the name of an existing file as its argument, accounting is "
"turned on, and records for each terminating process are appended to "
"I<filename> as it terminates.  An argument of NULL causes accounting to be "
"turned off."
msgstr ""

#. type: SH
#: build/C/man2/acct.2:68 build/C/man2/capget.2:165 build/C/man2/getgroups.2:103 build/C/man2/getpriority.2:120 build/C/man2/getresuid.2:50 build/C/man2/getrlimit.2:507 build/C/man2/getrusage.2:186 build/C/man2/getsid.2:63 build/C/man3/group_member.3:48 build/C/man2/iopl.2:56 build/C/man2/ioprio_set.2:152 build/C/man2/seteuid.2:68 build/C/man2/setfsgid.2:63 build/C/man2/setfsuid.2:74 build/C/man2/setgid.2:56 build/C/man2/setpgid.2:193 build/C/man2/setresuid.2:64 build/C/man2/setreuid.2:96 build/C/man2/setsid.2:59 build/C/man2/setuid.2:73 build/C/man3/ulimit.3:67 build/C/man2/seccomp.2:712 build/C/man2/pidfd_getfd.2:68 build/C/man2/pidfd_open.2:47 build/C/man2/pidfd_send_signal.2:90 build/C/man3/posix_spawn.3:487
#, no-wrap
msgid "RETURN VALUE"
msgstr ""

#. type: Plain text
#: build/C/man2/acct.2:73 build/C/man2/capget.2:170 build/C/man2/getresuid.2:55 build/C/man2/getrusage.2:191 build/C/man2/iopl.2:61 build/C/man2/seteuid.2:73 build/C/man2/setgid.2:61 build/C/man2/setresuid.2:69 build/C/man2/setreuid.2:101 build/C/man2/setuid.2:78
msgid ""
"On success, zero is returned.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""

#. type: SH
#: build/C/man2/acct.2:73 build/C/man2/capget.2:184 build/C/man7/cpuset.7:1100 build/C/man2/getgid.2:42 build/C/man2/getgroups.2:117 build/C/man2/getpid.2:53 build/C/man2/getpriority.2:144 build/C/man2/getresuid.2:55 build/C/man2/getrlimit.2:512 build/C/man2/getrusage.2:191 build/C/man2/getsid.2:68 build/C/man2/getuid.2:43 build/C/man2/iopl.2:61 build/C/man2/ioprio_set.2:172 build/C/man2/seteuid.2:80 build/C/man2/setgid.2:61 build/C/man2/setpgid.2:214 build/C/man2/setresuid.2:76 build/C/man2/setreuid.2:108 build/C/man2/setsid.2:66 build/C/man2/setuid.2:85 build/C/man3/ulimit.3:74 build/C/man2/seccomp.2:728 build/C/man7/cgroups.7:1746 build/C/man2/pidfd_getfd.2:75 build/C/man2/pidfd_open.2:54 build/C/man2/pidfd_send_signal.2:97 build/C/man3/posix_spawn.3:511
#, no-wrap
msgid "ERRORS"
msgstr ""

#. type: TP
#: build/C/man2/acct.2:74 build/C/man7/cpuset.7:1116 build/C/man7/cpuset.7:1123 build/C/man7/cpuset.7:1129 build/C/man7/cpuset.7:1137 build/C/man7/cpuset.7:1144 build/C/man2/getpriority.2:164 build/C/man2/setpgid.2:215 build/C/man2/seccomp.2:731
#, no-wrap
msgid "B<EACCES>"
msgstr ""

#. type: Plain text
#: build/C/man2/acct.2:85
msgid ""
"Write permission is denied for the specified file, or search permission is "
"denied for one of the directories in the path prefix of I<filename> (see "
"also B<path_resolution>(7)), or I<filename> is not a regular file."
msgstr ""

#. type: TP
#: build/C/man2/acct.2:85 build/C/man2/capget.2:185 build/C/man7/cpuset.7:1172 build/C/man2/getgroups.2:118 build/C/man2/getresuid.2:56 build/C/man2/getrlimit.2:513 build/C/man2/getrusage.2:192 build/C/man2/seccomp.2:739
#, no-wrap
msgid "B<EFAULT>"
msgstr ""

#. type: Plain text
#: build/C/man2/acct.2:89
msgid "I<filename> points outside your accessible address space."
msgstr ""

#. type: TP
#: build/C/man2/acct.2:89 build/C/man7/cpuset.7:1238 build/C/man7/cpuset.7:1246
#, no-wrap
msgid "B<EIO>"
msgstr ""

#. type: Plain text
#: build/C/man2/acct.2:93
msgid "Error writing to the file I<filename>."
msgstr ""

#. type: TP
#: build/C/man2/acct.2:93
#, no-wrap
msgid "B<EISDIR>"
msgstr ""

#. type: Plain text
#: build/C/man2/acct.2:97
msgid "I<filename> is a directory."
msgstr ""

#. type: TP
#: build/C/man2/acct.2:97
#, no-wrap
msgid "B<ELOOP>"
msgstr ""

#. type: Plain text
#: build/C/man2/acct.2:101
msgid "Too many symbolic links were encountered in resolving I<filename>."
msgstr ""

#. type: TP
#: build/C/man2/acct.2:101 build/C/man7/cpuset.7:1251 build/C/man7/cpuset.7:1258 build/C/man7/cpuset.7:1263
#, no-wrap
msgid "B<ENAMETOOLONG>"
msgstr ""

#. type: Plain text
#: build/C/man2/acct.2:105
msgid "I<filename> was too long."
msgstr ""

#. type: TP
#: build/C/man2/acct.2:105 build/C/man2/pidfd_getfd.2:96 build/C/man2/pidfd_open.2:70
#, no-wrap
msgid "B<ENFILE>"
msgstr ""

#. type: Plain text
#: build/C/man2/acct.2:108 build/C/man2/pidfd_getfd.2:99 build/C/man2/pidfd_open.2:73
msgid "The system-wide limit on the total number of open files has been reached."
msgstr ""

#. type: TP
#: build/C/man2/acct.2:108 build/C/man7/cpuset.7:1275 build/C/man7/cpuset.7:1280
#, no-wrap
msgid "B<ENOENT>"
msgstr ""

#. type: Plain text
#: build/C/man2/acct.2:111
msgid "The specified file does not exist."
msgstr ""

#. type: TP
#: build/C/man2/acct.2:111 build/C/man7/cpuset.7:1287 build/C/man2/getgroups.2:138 build/C/man2/seccomp.2:776 build/C/man2/seccomp.2:779 build/C/man2/pidfd_open.2:76
#, no-wrap
msgid "B<ENOMEM>"
msgstr ""

#. type: Plain text
#: build/C/man2/acct.2:114 build/C/man2/getgroups.2:141 build/C/man2/seccomp.2:779
msgid "Out of memory."
msgstr ""

#. type: TP
#: build/C/man2/acct.2:114 build/C/man2/iopl.2:66 build/C/man3/posix_spawn.3:529
#, no-wrap
msgid "B<ENOSYS>"
msgstr ""

#. type: Plain text
#: build/C/man2/acct.2:120
msgid ""
"BSD process accounting has not been enabled when the operating system kernel "
"was compiled.  The kernel configuration parameter controlling this feature "
"is B<CONFIG_BSD_PROCESS_ACCT>."
msgstr ""

#. type: TP
#: build/C/man2/acct.2:120 build/C/man7/cpuset.7:1314
#, no-wrap
msgid "B<ENOTDIR>"
msgstr ""

#. type: Plain text
#: build/C/man2/acct.2:125
msgid "A component used as a directory in I<filename> is not in fact a directory."
msgstr ""

#. type: TP
#: build/C/man2/acct.2:125 build/C/man2/capget.2:196 build/C/man2/capget.2:201 build/C/man2/capget.2:213 build/C/man7/cpuset.7:1319 build/C/man2/getgroups.2:141 build/C/man2/getpriority.2:171 build/C/man2/getrlimit.2:529 build/C/man2/getrlimit.2:534 build/C/man2/getrlimit.2:542 build/C/man2/getsid.2:69 build/C/man2/iopl.2:69 build/C/man2/ioprio_set.2:182 build/C/man2/seteuid.2:84 build/C/man2/setgid.2:67 build/C/man2/setpgid.2:229 build/C/man2/setresuid.2:103 build/C/man2/setreuid.2:135 build/C/man2/setsid.2:67 build/C/man2/setuid.2:113 build/C/man3/ulimit.3:75 build/C/man2/pidfd_getfd.2:99 build/C/man2/pidfd_send_signal.2:114 build/C/man2/pidfd_send_signal.2:118
#, no-wrap
msgid "B<EPERM>"
msgstr ""

#. type: Plain text
#: build/C/man2/acct.2:131
msgid ""
"The calling process has insufficient privilege to enable process "
"accounting.  On Linux, the B<CAP_SYS_PACCT> capability is required."
msgstr ""

#. type: TP
#: build/C/man2/acct.2:131
#, no-wrap
msgid "B<EROFS>"
msgstr ""

#. type: Plain text
#: build/C/man2/acct.2:135
msgid "I<filename> refers to a file on a read-only filesystem."
msgstr ""

#. type: TP
#: build/C/man2/acct.2:135
#, no-wrap
msgid "B<EUSERS>"
msgstr ""

#. type: Plain text
#: build/C/man2/acct.2:138
msgid "There are no more free file structures or we ran out of memory."
msgstr ""

#. type: SH
#: build/C/man2/acct.2:138 build/C/man5/acct.5:153 build/C/man7/capabilities.7:1742 build/C/man2/capget.2:235 build/C/man7/credentials.7:321 build/C/man2/getgid.2:44 build/C/man2/getgroups.2:156 build/C/man2/getpid.2:55 build/C/man2/getpriority.2:179 build/C/man2/getresuid.2:67 build/C/man2/getrlimit.2:572 build/C/man2/getrusage.2:213 build/C/man2/getsid.2:84 build/C/man2/getuid.2:45 build/C/man3/group_member.3:55 build/C/man2/iopl.2:77 build/C/man2/ioprio_set.2:199 build/C/man2/ipc.2:45 build/C/man2/seteuid.2:103 build/C/man2/setfsgid.2:70 build/C/man2/setfsuid.2:81 build/C/man2/setgid.2:74 build/C/man2/setpgid.2:248 build/C/man2/setresuid.2:118 build/C/man2/setreuid.2:151 build/C/man2/setsid.2:73 build/C/man2/setuid.2:120 build/C/man3/ulimit.3:91 build/C/man2/seccomp.2:805 build/C/man2/pidfd_getfd.2:117 build/C/man2/pidfd_open.2:87 build/C/man2/pidfd_send_signal.2:132 build/C/man3/posix_spawn.3:538
#, no-wrap
msgid "CONFORMING TO"
msgstr ""

#.  SVr4 documents an EBUSY error condition, but no EISDIR or ENOSYS.
#.  Also AIX and HP-UX document EBUSY (attempt is made
#.  to enable accounting when it is already enabled), as does Solaris
#.  (attempt is made to enable accounting using the same file that is
#.  currently being used).
#. type: Plain text
#: build/C/man2/acct.2:145
msgid "SVr4, 4.3BSD (but not POSIX)."
msgstr ""

#. type: SH
#: build/C/man2/acct.2:145 build/C/man5/acct.5:157 build/C/man7/capabilities.7:1747 build/C/man2/capget.2:237 build/C/man7/cpuset.7:1341 build/C/man7/credentials.7:327 build/C/man2/getgid.2:46 build/C/man2/getgroups.2:165 build/C/man2/getpid.2:57 build/C/man2/getpriority.2:182 build/C/man2/getresuid.2:70 build/C/man2/getrlimit.2:595 build/C/man2/getrusage.2:224 build/C/man2/getsid.2:86 build/C/man2/getuid.2:47 build/C/man2/iopl.2:81 build/C/man2/ioprio_set.2:201 build/C/man2/ipc.2:49 build/C/man2/seteuid.2:105 build/C/man2/setfsgid.2:74 build/C/man2/setfsuid.2:85 build/C/man2/setgid.2:76 build/C/man2/setpgid.2:270 build/C/man2/setresuid.2:121 build/C/man2/setreuid.2:157 build/C/man2/setsid.2:75 build/C/man2/setuid.2:125 build/C/man2/seccomp.2:809 build/C/man7/cgroups.7:1755 build/C/man2/pidfd_getfd.2:120 build/C/man2/pidfd_open.2:90 build/C/man2/pidfd_send_signal.2:135 build/C/man3/posix_spawn.3:547
#, no-wrap
msgid "NOTES"
msgstr ""

#. type: Plain text
#: build/C/man2/acct.2:148
msgid ""
"No accounting is produced for programs running when a system crash occurs.  "
"In particular, nonterminating processes are never accounted for."
msgstr ""

#. type: Plain text
#: build/C/man2/acct.2:151
msgid ""
"The structure of the records written to the accounting file is described in "
"B<acct>(5)."
msgstr ""

#. type: SH
#: build/C/man2/acct.2:151 build/C/man5/acct.5:174 build/C/man7/capabilities.7:1827 build/C/man2/capget.2:245 build/C/man7/cpuset.7:1489 build/C/man7/credentials.7:348 build/C/man2/getgid.2:78 build/C/man2/getgroups.2:219 build/C/man2/getpid.2:156 build/C/man2/getpriority.2:247 build/C/man2/getresuid.2:86 build/C/man2/getrlimit.2:836 build/C/man2/getrusage.2:264 build/C/man2/getsid.2:93 build/C/man2/getuid.2:89 build/C/man3/group_member.3:57 build/C/man2/iopl.2:106 build/C/man2/ioprio_set.2:363 build/C/man2/ipc.2:57 build/C/man2/seteuid.2:145 build/C/man2/setfsgid.2:122 build/C/man2/setfsuid.2:140 build/C/man2/setgid.2:101 build/C/man2/setpgid.2:330 build/C/man2/setresuid.2:158 build/C/man2/setreuid.2:214 build/C/man2/setsid.2:110 build/C/man2/setuid.2:163 build/C/man7/sysvipc.7:101 build/C/man3/ulimit.3:96 build/C/man2/seccomp.2:1148 build/C/man7/cgroups.7:1913 build/C/man2/pidfd_getfd.2:152 build/C/man2/pidfd_open.2:263 build/C/man2/pidfd_send_signal.2:248 build/C/man3/posix_spawn.3:808
#, no-wrap
msgid "SEE ALSO"
msgstr ""

#. type: Plain text
#: build/C/man2/acct.2:153
msgid "B<acct>(5)"
msgstr ""

#. type: SH
#: build/C/man2/acct.2:153 build/C/man5/acct.5:179 build/C/man7/capabilities.7:1855 build/C/man2/capget.2:249 build/C/man7/cpuset.7:1514 build/C/man7/credentials.7:400 build/C/man2/getgid.2:83 build/C/man2/getgroups.2:227 build/C/man2/getpid.2:168 build/C/man2/getpriority.2:256 build/C/man2/getresuid.2:92 build/C/man2/getrlimit.2:856 build/C/man2/getrusage.2:271 build/C/man2/getsid.2:97 build/C/man2/getuid.2:94 build/C/man3/group_member.3:62 build/C/man2/iopl.2:110 build/C/man2/ioprio_set.2:372 build/C/man2/ipc.2:71 build/C/man2/seteuid.2:153 build/C/man2/setfsgid.2:127 build/C/man2/setfsuid.2:145 build/C/man2/setgid.2:108 build/C/man2/setpgid.2:337 build/C/man2/setresuid.2:168 build/C/man2/setreuid.2:224 build/C/man2/setsid.2:118 build/C/man2/setuid.2:171 build/C/man7/sysvipc.7:120 build/C/man3/ulimit.3:101 build/C/man2/seccomp.2:1183 build/C/man7/cgroups.7:1930 build/C/man2/pidfd_getfd.2:157 build/C/man2/pidfd_open.2:273 build/C/man2/pidfd_send_signal.2:256 build/C/man3/posix_spawn.3:846
#, no-wrap
msgid "COLOPHON"
msgstr ""

#. type: Plain text
#: build/C/man2/acct.2:161 build/C/man5/acct.5:187 build/C/man7/capabilities.7:1863 build/C/man2/capget.2:257 build/C/man7/cpuset.7:1522 build/C/man7/credentials.7:408 build/C/man2/getgid.2:91 build/C/man2/getgroups.2:235 build/C/man2/getpid.2:176 build/C/man2/getpriority.2:264 build/C/man2/getresuid.2:100 build/C/man2/getrlimit.2:864 build/C/man2/getrusage.2:279 build/C/man2/getsid.2:105 build/C/man2/getuid.2:102 build/C/man3/group_member.3:70 build/C/man2/iopl.2:118 build/C/man2/ioprio_set.2:380 build/C/man2/ipc.2:79 build/C/man2/seteuid.2:161 build/C/man2/setfsgid.2:135 build/C/man2/setfsuid.2:153 build/C/man2/setgid.2:116 build/C/man2/setpgid.2:345 build/C/man2/setresuid.2:176 build/C/man2/setreuid.2:232 build/C/man2/setsid.2:126 build/C/man2/setuid.2:179 build/C/man7/sysvipc.7:128 build/C/man3/ulimit.3:109 build/C/man2/seccomp.2:1191 build/C/man7/cgroups.7:1938 build/C/man2/pidfd_getfd.2:165 build/C/man2/pidfd_open.2:281 build/C/man2/pidfd_send_signal.2:264 build/C/man3/posix_spawn.3:854
msgid ""
"This page is part of release 5.10 of the Linux I<man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at "
"\\%https://www.kernel.org/doc/man-pages/."
msgstr ""

#. type: TH
#: build/C/man5/acct.5:25 build/C/man2/getpriority.2:45 build/C/man2/getresuid.2:28 build/C/man2/getsid.2:27 build/C/man2/seteuid.2:29 build/C/man2/setpgid.2:48 build/C/man2/setresuid.2:27 build/C/man2/setreuid.2:46 build/C/man2/setsid.2:31 build/C/man3/ulimit.3:27
#, no-wrap
msgid "2017-09-15"
msgstr ""

#. type: Plain text
#: build/C/man5/acct.5:28
msgid "acct - process accounting file"
msgstr ""

#. type: Plain text
#: build/C/man5/acct.5:30
msgid "B<#include E<lt>sys/acct.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man5/acct.5:36
msgid ""
"If the kernel is built with the process accounting option enabled "
"(B<CONFIG_BSD_PROCESS_ACCT>), then calling B<acct>(2)  starts process "
"accounting, for example:"
msgstr ""

#. type: Plain text
#: build/C/man5/acct.5:39
msgid "acct(\"/var/log/pacct\");"
msgstr ""

#. type: Plain text
#: build/C/man5/acct.5:47
msgid ""
"When process accounting is enabled, the kernel writes a record to the "
"accounting file as each process on the system terminates.  This record "
"contains information about the terminated process, and is defined in "
"I<E<lt>sys/acct.hE<gt>> as follows:"
msgstr ""

#. type: Plain text
#: build/C/man5/acct.5:51
#, no-wrap
msgid "#define ACCT_COMM 16\n"
msgstr ""

#. type: Plain text
#: build/C/man5/acct.5:53
#, no-wrap
msgid "typedef u_int16_t comp_t;\n"
msgstr ""

#. type: Plain text
#: build/C/man5/acct.5:77
#, no-wrap
msgid ""
"struct acct {\n"
"    char ac_flag;           /* Accounting flags */\n"
"    u_int16_t ac_uid;       /* Accounting user ID */\n"
"    u_int16_t ac_gid;       /* Accounting group ID */\n"
"    u_int16_t ac_tty;       /* Controlling terminal */\n"
"    u_int32_t ac_btime;     /* Process creation time\n"
"                               (seconds since the Epoch) */\n"
"    comp_t    ac_utime;     /* User CPU time */\n"
"    comp_t    ac_stime;     /* System CPU time */\n"
"    comp_t    ac_etime;     /* Elapsed time */\n"
"    comp_t    ac_mem;       /* Average memory usage (kB) */\n"
"    comp_t    ac_io;        /* Characters transferred (unused) */\n"
"    comp_t    ac_rw;        /* Blocks read or written (unused) */\n"
"    comp_t    ac_minflt;    /* Minor page faults */\n"
"    comp_t    ac_majflt;    /* Major page faults */\n"
"    comp_t    ac_swaps;     /* Number of swaps (unused) */\n"
"    u_int32_t ac_exitcode;  /* Process termination status\n"
"                               (see wait(2)) */\n"
"    char      ac_comm[ACCT_COMM+1];\n"
"                            /* Command name (basename of last\n"
"                               executed command; null-terminated) */\n"
"    char      ac_pad[I<X>];    /* padding bytes */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man5/acct.5:84
#, no-wrap
msgid ""
"enum {          /* Bits that may be set in ac_flag field */\n"
"    AFORK = 0x01,           /* Has executed fork, but no exec */\n"
"    ASU   = 0x02,           /* Used superuser privileges */\n"
"    ACORE = 0x08,           /* Dumped core */\n"
"    AXSIG = 0x10            /* Killed by a signal */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man5/acct.5:94
msgid ""
"The I<comp_t> data type is a floating-point value consisting of a 3-bit, "
"base-8 exponent, and a 13-bit mantissa.  A value, I<c>, of this type can be "
"converted to a (long) integer as follows:"
msgstr ""

#. type: Plain text
#: build/C/man5/acct.5:97
#, no-wrap
msgid "    v = (c & 0x1fff) E<lt>E<lt> (((c E<gt>E<gt> 13) & 0x7) * 3);\n"
msgstr ""

#. type: Plain text
#: build/C/man5/acct.5:107
msgid ""
"The I<ac_utime>, I<ac_stime>, and I<ac_etime> fields measure time in \"clock "
"ticks\"; divide these values by I<sysconf(_SC_CLK_TCK)> to convert them to "
"seconds."
msgstr ""

#. type: SS
#: build/C/man5/acct.5:107
#, no-wrap
msgid "Version 3 accounting file format"
msgstr ""

#. type: Plain text
#: build/C/man5/acct.5:122
msgid ""
"Since kernel 2.6.8, an optional alternative version of the accounting file "
"can be produced if the B<CONFIG_BSD_PROCESS_ACCT_V3> option is set when "
"building the kernel.  With this option is set, the records written to the "
"accounting file contain additional fields, and the width of I<c_uid> and "
"I<ac_gid> fields is widened from 16 to 32 bits (in line with the increased "
"size of UID and GIDs in Linux 2.4 and later).  The records are defined as "
"follows:"
msgstr ""

#. type: Plain text
#: build/C/man5/acct.5:147
#, no-wrap
msgid ""
"struct acct_v3 {\n"
"    char      ac_flag;      /* Flags */\n"
"    char      ac_version;   /* Always set to ACCT_VERSION (3) */\n"
"    u_int16_t ac_tty;       /* Controlling terminal */\n"
"    u_int32_t ac_exitcode;  /* Process termination status */\n"
"    u_int32_t ac_uid;       /* Real user ID */\n"
"    u_int32_t ac_gid;       /* Real group ID */\n"
"    u_int32_t ac_pid;       /* Process ID */\n"
"    u_int32_t ac_ppid;      /* Parent process ID */\n"
"    u_int32_t ac_btime;     /* Process creation time */\n"
"    float     ac_etime;     /* Elapsed time */\n"
"    comp_t    ac_utime;     /* User CPU time */\n"
"    comp_t    ac_stime;     /* System time */\n"
"    comp_t    ac_mem;       /* Average memory usage (kB) */\n"
"    comp_t    ac_io;        /* Characters transferred (unused) */\n"
"    comp_t    ac_rw;        /* Blocks read or written\n"
"                               (unused) */\n"
"    comp_t    ac_minflt;    /* Minor page faults */\n"
"    comp_t    ac_majflt;    /* Major page faults */\n"
"    comp_t    ac_swaps;     /* Number of swaps (unused) */\n"
"    char      ac_comm[ACCT_COMM]; /* Command name */\n"
"};\n"
msgstr ""

#. type: SH
#: build/C/man5/acct.5:149 build/C/man7/cpuset.7:1338 build/C/man2/getresuid.2:60 build/C/man2/getrlimit.2:552 build/C/man2/getsid.2:80 build/C/man2/ioprio_set.2:196 build/C/man2/setfsgid.2:66 build/C/man2/setfsuid.2:77 build/C/man2/setresuid.2:116 build/C/man2/seccomp.2:800 build/C/man2/pidfd_getfd.2:113 build/C/man2/pidfd_open.2:84 build/C/man2/pidfd_send_signal.2:129 build/C/man3/posix_spawn.3:532
#, no-wrap
msgid "VERSIONS"
msgstr ""

#. type: Plain text
#: build/C/man5/acct.5:153
msgid "The I<acct_v3> structure is defined in glibc since version 2.6."
msgstr ""

#. type: Plain text
#: build/C/man5/acct.5:157
msgid ""
"Process accounting originated on BSD.  Although it is present on most "
"systems, it is not standardized, and the details vary somewhat between "
"systems."
msgstr ""

#. type: Plain text
#: build/C/man5/acct.5:160
msgid ""
"Records in the accounting file are ordered by termination time of the "
"process."
msgstr ""

#. type: Plain text
#: build/C/man5/acct.5:167
msgid ""
"In kernels up to and including 2.6.9, a separate accounting record is "
"written for each thread created using the NPTL threading library; since "
"Linux 2.6.10, a single accounting record is written for the entire process "
"on termination of the last thread in the process."
msgstr ""

#. type: Plain text
#: build/C/man5/acct.5:174
msgid ""
"The I</proc/sys/kernel/acct> file, described in B<proc>(5), defines settings "
"that control the behavior of process accounting when disk space runs low."
msgstr ""

#. type: Plain text
#: build/C/man5/acct.5:179
msgid "B<lastcomm>(1), B<acct>(2), B<accton>(8), B<sa>(8)"
msgstr ""

#. type: TH
#: build/C/man7/capabilities.7:48
#, no-wrap
msgid "CAPABILITIES"
msgstr ""

#. type: TH
#: build/C/man7/capabilities.7:48 build/C/man2/iopl.2:33 build/C/man7/cgroups.7:26 build/C/man2/pidfd_open.2:25
#, no-wrap
msgid "2020-08-13"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:51
msgid "capabilities - overview of Linux capabilities"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:63
msgid ""
"For the purpose of performing permission checks, traditional UNIX "
"implementations distinguish two categories of processes: I<privileged> "
"processes (whose effective user ID is 0, referred to as superuser or root), "
"and I<unprivileged> processes (whose effective UID is nonzero).  Privileged "
"processes bypass all kernel permission checks, while unprivileged processes "
"are subject to full permission checking based on the process's credentials "
"(usually: effective UID, effective GID, and supplementary group list)."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:70
msgid ""
"Starting with kernel 2.2, Linux divides the privileges traditionally "
"associated with superuser into distinct units, known as I<capabilities>, "
"which can be independently enabled and disabled.  Capabilities are a "
"per-thread attribute."
msgstr ""

#. type: SS
#: build/C/man7/capabilities.7:70
#, no-wrap
msgid "Capabilities list"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:73
msgid ""
"The following list shows the capabilities implemented on Linux, and the "
"operations or behaviors that each capability permits:"
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:73
#, no-wrap
msgid "B<CAP_AUDIT_CONTROL> (since Linux 2.6.11)"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:77
msgid ""
"Enable and disable kernel auditing; change auditing filter rules; retrieve "
"auditing status and filtering rules."
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:77
#, no-wrap
msgid "B<CAP_AUDIT_READ> (since Linux 3.16)"
msgstr ""

#.  commit a29b694aa1739f9d76538e34ae25524f9c549d59
#.  commit 3a101b8de0d39403b2c7e5c23fd0b005668acf48
#. type: Plain text
#: build/C/man7/capabilities.7:82
msgid "Allow reading the audit log via a multicast netlink socket."
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:82
#, no-wrap
msgid "B<CAP_AUDIT_WRITE> (since Linux 2.6.11)"
msgstr ""

#.  FIXME Add FAN_ENABLE_AUDIT
#. type: Plain text
#: build/C/man7/capabilities.7:86
msgid "Write records to kernel auditing log."
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:86
#, no-wrap
msgid "B<CAP_BLOCK_SUSPEND> (since Linux 3.5)"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:92
msgid ""
"Employ features that can block system suspend (B<epoll>(7)  B<EPOLLWAKEUP>, "
"I</proc/sys/wake_lock>)."
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:92
#, no-wrap
msgid "B<CAP_BPF> (since Linux 5.8)"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:98
msgid "Employ privileged BPF operations; see B<bpf>(2)  and B<bpf-helpers>(7)."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:103
msgid ""
"This capability was added in Linux 5.8 to separate out BPF functionality "
"from the overloaded B<CAP_SYS_ADMIN> capability."
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:103
#, no-wrap
msgid "B<CAP_CHECKPOINT_RESTORE> (since Linux 5.9)"
msgstr ""

#. type: IP
#: build/C/man7/capabilities.7:108 build/C/man7/capabilities.7:113 build/C/man7/capabilities.7:121 build/C/man7/capabilities.7:144 build/C/man7/capabilities.7:147 build/C/man7/capabilities.7:150 build/C/man7/capabilities.7:161 build/C/man7/capabilities.7:171 build/C/man7/capabilities.7:175 build/C/man7/capabilities.7:177 build/C/man7/capabilities.7:179 build/C/man7/capabilities.7:183 build/C/man7/capabilities.7:196 build/C/man7/capabilities.7:199 build/C/man7/capabilities.7:258 build/C/man7/capabilities.7:260 build/C/man7/capabilities.7:262 build/C/man7/capabilities.7:264 build/C/man7/capabilities.7:266 build/C/man7/capabilities.7:268 build/C/man7/capabilities.7:270 build/C/man7/capabilities.7:272 build/C/man7/capabilities.7:274 build/C/man7/capabilities.7:300 build/C/man7/capabilities.7:302 build/C/man7/capabilities.7:311 build/C/man7/capabilities.7:315 build/C/man7/capabilities.7:330 build/C/man7/capabilities.7:332 build/C/man7/capabilities.7:334 build/C/man7/capabilities.7:367 build/C/man7/capabilities.7:373 build/C/man7/capabilities.7:375 build/C/man7/capabilities.7:390 build/C/man7/capabilities.7:401 build/C/man7/capabilities.7:407 build/C/man7/capabilities.7:412 build/C/man7/capabilities.7:417 build/C/man7/capabilities.7:422 build/C/man7/capabilities.7:427 build/C/man7/capabilities.7:433 build/C/man7/capabilities.7:437 build/C/man7/capabilities.7:444 build/C/man7/capabilities.7:447 build/C/man7/capabilities.7:455 build/C/man7/capabilities.7:457 build/C/man7/capabilities.7:466 build/C/man7/capabilities.7:475 build/C/man7/capabilities.7:479 build/C/man7/capabilities.7:487 build/C/man7/capabilities.7:490 build/C/man7/capabilities.7:497 build/C/man7/capabilities.7:502 build/C/man7/capabilities.7:508 build/C/man7/capabilities.7:512 build/C/man7/capabilities.7:516 build/C/man7/capabilities.7:520 build/C/man7/capabilities.7:524 build/C/man7/capabilities.7:531 build/C/man7/capabilities.7:537 build/C/man7/capabilities.7:539 build/C/man7/capabilities.7:544 build/C/man7/capabilities.7:551 build/C/man7/capabilities.7:553 build/C/man7/capabilities.7:570 build/C/man7/capabilities.7:573 build/C/man7/capabilities.7:582 build/C/man7/capabilities.7:588 build/C/man7/capabilities.7:597 build/C/man7/capabilities.7:602 build/C/man7/capabilities.7:608 build/C/man7/capabilities.7:611 build/C/man7/capabilities.7:614 build/C/man7/capabilities.7:625 build/C/man7/capabilities.7:629 build/C/man7/capabilities.7:646 build/C/man7/capabilities.7:649 build/C/man7/capabilities.7:653 build/C/man7/capabilities.7:658 build/C/man7/capabilities.7:667 build/C/man7/capabilities.7:672 build/C/man7/capabilities.7:675 build/C/man7/capabilities.7:680 build/C/man7/capabilities.7:683 build/C/man7/capabilities.7:686 build/C/man7/capabilities.7:689 build/C/man7/capabilities.7:692 build/C/man7/capabilities.7:697 build/C/man7/capabilities.7:699 build/C/man7/capabilities.7:705 build/C/man7/capabilities.7:713 build/C/man7/capabilities.7:715 build/C/man7/capabilities.7:719 build/C/man7/capabilities.7:721 build/C/man7/capabilities.7:724 build/C/man7/capabilities.7:728 build/C/man7/capabilities.7:730 build/C/man7/capabilities.7:732 build/C/man7/capabilities.7:734 build/C/man7/capabilities.7:743 build/C/man7/capabilities.7:750 build/C/man7/capabilities.7:757 build/C/man7/capabilities.7:762 build/C/man7/capabilities.7:770 build/C/man7/capabilities.7:775 build/C/man7/capabilities.7:800 build/C/man7/capabilities.7:807 build/C/man7/capabilities.7:846 build/C/man7/capabilities.7:851 build/C/man7/capabilities.7:859 build/C/man7/capabilities.7:867 build/C/man7/capabilities.7:885 build/C/man7/capabilities.7:1204 build/C/man7/capabilities.7:1210 build/C/man7/capabilities.7:1362 build/C/man7/capabilities.7:1370 build/C/man7/capabilities.7:1810 build/C/man7/capabilities.7:1817 build/C/man2/capget.2:205 build/C/man2/capget.2:207 build/C/man7/cpuset.7:540 build/C/man7/cpuset.7:545 build/C/man7/cpuset.7:550 build/C/man7/cpuset.7:726 build/C/man7/cpuset.7:730 build/C/man7/cpuset.7:927 build/C/man7/cpuset.7:930 build/C/man7/cpuset.7:934 build/C/man7/cpuset.7:938 build/C/man7/cpuset.7:942 build/C/man7/credentials.7:177 build/C/man7/credentials.7:183 build/C/man7/credentials.7:195 build/C/man7/credentials.7:217 build/C/man7/credentials.7:234 build/C/man7/credentials.7:264 build/C/man7/credentials.7:267 build/C/man7/credentials.7:278 build/C/man7/credentials.7:281 build/C/man2/seccomp.2:530 build/C/man2/seccomp.2:534 build/C/man2/seccomp.2:537 build/C/man2/seccomp.2:542 build/C/man2/seccomp.2:546 build/C/man2/seccomp.2:687 build/C/man2/seccomp.2:691 build/C/man2/seccomp.2:699 build/C/man2/seccomp.2:706 build/C/man2/seccomp.2:710 build/C/man2/seccomp.2:839 build/C/man2/seccomp.2:842 build/C/man2/seccomp.2:844 build/C/man2/seccomp.2:846 build/C/man2/seccomp.2:848 build/C/man2/seccomp.2:850 build/C/man2/seccomp.2:852 build/C/man2/seccomp.2:854 build/C/man2/seccomp.2:862 build/C/man2/seccomp.2:877 build/C/man2/seccomp.2:926 build/C/man2/seccomp.2:934 build/C/man2/seccomp.2:940 build/C/man7/cgroups.7:944 build/C/man7/cgroups.7:951 build/C/man7/cgroups.7:1138 build/C/man7/cgroups.7:1148 build/C/man7/cgroups.7:1175 build/C/man7/cgroups.7:1183 build/C/man7/cgroups.7:1232 build/C/man7/cgroups.7:1236 build/C/man7/cgroups.7:1246 build/C/man7/cgroups.7:1251 build/C/man7/cgroups.7:1272 build/C/man7/cgroups.7:1275 build/C/man7/cgroups.7:1302 build/C/man7/cgroups.7:1308 build/C/man7/cgroups.7:1312 build/C/man7/cgroups.7:1367 build/C/man7/cgroups.7:1380 build/C/man7/cgroups.7:1402 build/C/man7/cgroups.7:1407 build/C/man7/cgroups.7:1414 build/C/man7/cgroups.7:1458 build/C/man7/cgroups.7:1463 build/C/man7/cgroups.7:1522 build/C/man7/cgroups.7:1526 build/C/man7/cgroups.7:1532 build/C/man7/cgroups.7:1575 build/C/man7/cgroups.7:1583 build/C/man7/cgroups.7:1606 build/C/man7/cgroups.7:1618 build/C/man7/cgroups.7:1624 build/C/man7/cgroups.7:1642 build/C/man7/cgroups.7:1646 build/C/man7/cgroups.7:1671 build/C/man7/cgroups.7:1678 build/C/man7/cgroups.7:1694 build/C/man7/cgroups.7:1697 build/C/man2/pidfd_send_signal.2:63 build/C/man2/pidfd_send_signal.2:66 build/C/man2/pidfd_send_signal.2:69 build/C/man2/pidfd_send_signal.2:73 build/C/man2/pidfd_send_signal.2:76 build/C/man2/pidfd_send_signal.2:145 build/C/man2/pidfd_send_signal.2:149 build/C/man2/pidfd_send_signal.2:153 build/C/man3/posix_spawn.3:104 build/C/man3/posix_spawn.3:109 build/C/man3/posix_spawn.3:127 build/C/man3/posix_spawn.3:140 build/C/man3/posix_spawn.3:191 build/C/man3/posix_spawn.3:199 build/C/man3/posix_spawn.3:330 build/C/man3/posix_spawn.3:339
#, no-wrap
msgid "*"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:113
msgid "Update I</proc/sys/kernel/ns_last_pid> (see B<pid_namespaces>(7));"
msgstr ""

#.  FIXME There is also some use case relating to
#.  prctl_set_mm_exe_file(); in the 5.9 sources, see
#.  prctl_set_mm_map().
#. type: Plain text
#: build/C/man7/capabilities.7:121
msgid "employ the I<set_tid> feature of B<clone3>(2);"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:125
msgid ""
"read the contents of the symbolic links in I</proc/[pid]/map_files> for "
"other processes."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:132
msgid ""
"This capability was added in Linux 5.9 to separate out checkpoint/restore "
"functionality from the overloaded B<CAP_SYS_ADMIN> capability."
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:132
#, no-wrap
msgid "B<CAP_CHOWN>"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:136
msgid "Make arbitrary changes to file UIDs and GIDs (see B<chown>(2))."
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:136
#, no-wrap
msgid "B<CAP_DAC_OVERRIDE>"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:140
msgid ""
"Bypass file read, write, and execute permission checks.  (DAC is an "
"abbreviation of \"discretionary access control\".)"
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:140
#, no-wrap
msgid "B<CAP_DAC_READ_SEARCH>"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:147
msgid ""
"Bypass file read permission checks and directory read and execute permission "
"checks;"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:150
msgid "invoke B<open_by_handle_at>(2);"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:155
msgid ""
"use the B<linkat>(2)  B<AT_EMPTY_PATH> flag to create a link to a file "
"referred to by a file descriptor."
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:157
#, no-wrap
msgid "B<CAP_FOWNER>"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:171
msgid ""
"Bypass permission checks on operations that normally require the filesystem "
"UID of the process to match the UID of the file (e.g., B<chmod>(2), "
"B<utime>(2)), excluding those operations covered by B<CAP_DAC_OVERRIDE> and "
"B<CAP_DAC_READ_SEARCH>;"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:175
msgid "set inode flags (see B<ioctl_iflags>(2))  on arbitrary files;"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:177
msgid "set Access Control Lists (ACLs) on arbitrary files;"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:179
msgid "ignore directory sticky bit on file deletion;"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:183
msgid "modify I<user> extended attributes on sticky directory owned by any user;"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:190
msgid "specify B<O_NOATIME> for arbitrary files in B<open>(2)  and B<fcntl>(2)."
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:192
#, no-wrap
msgid "B<CAP_FSETID>"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:199
msgid "Don't clear set-user-ID and set-group-ID mode bits when a file is modified;"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:202
msgid ""
"set the set-group-ID bit for a file whose GID does not match the filesystem "
"or any of the supplementary GIDs of the calling process."
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:204
#, no-wrap
msgid "B<CAP_IPC_LOCK>"
msgstr ""

#.  FIXME . As at Linux 3.2, there are some strange uses of this capability
#.  in other places; they probably should be replaced with something else.
#. type: Plain text
#: build/C/man7/capabilities.7:213
msgid "Lock memory (B<mlock>(2), B<mlockall>(2), B<mmap>(2), B<shmctl>(2))."
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:213
#, no-wrap
msgid "B<CAP_IPC_OWNER>"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:216
msgid "Bypass permission checks for operations on System V IPC objects."
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:216
#, no-wrap
msgid "B<CAP_KILL>"
msgstr ""

#.  FIXME . CAP_KILL also has an effect for threads + setting child
#.        termination signal to other than SIGCHLD: without this
#.        capability, the termination signal reverts to SIGCHLD
#.        if the child does an exec().  What is the rationale
#.        for this?
#. type: Plain text
#: build/C/man7/capabilities.7:229
msgid ""
"Bypass permission checks for sending signals (see B<kill>(2)).  This "
"includes use of the B<ioctl>(2)  B<KDSIGACCEPT> operation."
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:229
#, no-wrap
msgid "B<CAP_LEASE> (since Linux 2.4)"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:233
msgid "Establish leases on arbitrary files (see B<fcntl>(2))."
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:233
#, no-wrap
msgid "B<CAP_LINUX_IMMUTABLE>"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:241
msgid ""
"Set the B<FS_APPEND_FL> and B<FS_IMMUTABLE_FL> inode flags (see "
"B<ioctl_iflags>(2))."
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:241
#, no-wrap
msgid "B<CAP_MAC_ADMIN> (since Linux 2.6.25)"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:245
msgid ""
"Allow MAC configuration or state changes.  Implemented for the Smack Linux "
"Security Module (LSM)."
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:245
#, no-wrap
msgid "B<CAP_MAC_OVERRIDE> (since Linux 2.6.25)"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:249
msgid "Override Mandatory Access Control (MAC).  Implemented for the Smack LSM."
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:249
#, no-wrap
msgid "B<CAP_MKNOD> (since Linux 2.4)"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:253
msgid "Create special files using B<mknod>(2)."
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:253
#, no-wrap
msgid "B<CAP_NET_ADMIN>"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:256
msgid "Perform various network-related operations:"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:260
msgid "interface configuration;"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:262
msgid "administration of IP firewall, masquerading, and accounting;"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:264
msgid "modify routing tables;"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:266
msgid "bind to any address for transparent proxying;"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:268
msgid "set type-of-service (TOS);"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:270
msgid "clear driver statistics;"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:272
msgid "set promiscuous mode;"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:274
msgid "enabling multicasting;"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:285
msgid ""
"use B<setsockopt>(2)  to set the following socket options: B<SO_DEBUG>, "
"B<SO_MARK>, B<SO_PRIORITY> (for a priority outside the range 0 to 6), "
"B<SO_RCVBUFFORCE>, and B<SO_SNDBUFFORCE>."
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:287
#, no-wrap
msgid "B<CAP_NET_BIND_SERVICE>"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:291
msgid ""
"Bind a socket to Internet domain privileged ports (port numbers less than "
"1024)."
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:291
#, no-wrap
msgid "B<CAP_NET_BROADCAST>"
msgstr ""

#.  FIXME Since Linux 4.2, there are use cases for netlink sockets
#.     commit 59324cf35aba5336b611074028777838a963d03b
#. type: Plain text
#: build/C/man7/capabilities.7:296
msgid "(Unused)  Make socket broadcasts, and listen to multicasts."
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:296
#, no-wrap
msgid "B<CAP_NET_RAW>"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:302
msgid "Use RAW and PACKET sockets;"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:304
msgid "bind to any address for transparent proxying."
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:307
#, no-wrap
msgid "B<CAP_PERFMON> (since Linux 5.8)"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:310
msgid "Employ various performance-monitoring mechanisms, including:"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:315
msgid "call B<perf_event_open>(2);"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:317
msgid "employ various BPF operations that have performance implications."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:326
msgid ""
"This capability was added in Linux 5.8 to separate out performance "
"monitoring functionality from the overloaded B<CAP_SYS_ADMIN> capability.  "
"See also the kernel source file "
"I<Documentation/admin-guide/perf-security.rst>."
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:326
#, no-wrap
msgid "B<CAP_SETGID>"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:332
msgid "Make arbitrary manipulations of process GIDs and supplementary GID list;"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:334
msgid "forge GID when passing socket credentials via UNIX domain sockets;"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:337
msgid "write a group ID mapping in a user namespace (see B<user_namespaces>(7))."
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:339
#, no-wrap
msgid "B<CAP_SETFCAP> (since Linux 2.6.24)"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:342
msgid "Set arbitrary capabilities on a file."
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:342
#, no-wrap
msgid "B<CAP_SETPCAP>"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:353
msgid ""
"If file capabilities are supported (i.e., since Linux 2.6.24): add any "
"capability from the calling thread's bounding set to its inheritable set; "
"drop capabilities from the bounding set (via B<prctl>(2)  "
"B<PR_CAPBSET_DROP>); make changes to the I<securebits> flags."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:363
msgid ""
"If file capabilities are not supported (i.e., kernels before Linux 2.6.24): "
"grant or remove any capability in the caller's permitted capability set to "
"or from any other process.  (This property of B<CAP_SETPCAP> is not "
"available when the kernel is configured to support file capabilities, since "
"B<CAP_SETPCAP> has entirely different semantics for such kernels.)"
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:363
#, no-wrap
msgid "B<CAP_SETUID>"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:373
msgid ""
"Make arbitrary manipulations of process UIDs (B<setuid>(2), B<setreuid>(2), "
"B<setresuid>(2), B<setfsuid>(2));"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:375
msgid "forge UID when passing socket credentials via UNIX domain sockets;"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:378
msgid "write a user ID mapping in a user namespace (see B<user_namespaces>(7))."
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:381
#, no-wrap
msgid "B<CAP_SYS_ADMIN>"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:387
msgid ""
"I<Note>: this capability is overloaded; see I<Notes to kernel developers>, "
"below."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:401
msgid ""
"Perform a range of system administration operations including: "
"B<quotactl>(2), B<mount>(2), B<umount>(2), B<pivot_root>(2), B<swapon>(2), "
"B<swapoff>(2), B<sethostname>(2), and B<setdomainname>(2);"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:407
msgid ""
"perform privileged B<syslog>(2)  operations (since Linux 2.6.37, "
"B<CAP_SYSLOG> should be used to permit such operations);"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:412
msgid "perform B<VM86_REQUEST_IRQ> B<vm86>(2)  command;"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:417
msgid ""
"access the same checkpoint/restore functionality that is governed by "
"B<CAP_CHECKPOINT_RESTORE> (but the latter, weaker capability is preferred "
"for accessing that functionality)."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:422
msgid ""
"perform the same BPF operations as are governed by B<CAP_BPF> (but the "
"latter, weaker capability is preferred for accessing that functionality)."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:427
msgid ""
"employ the same performance monitoring mechanisms as are governed by "
"B<CAP_PERFMON> (but the latter, weaker capability is preferred for accessing "
"that functionality)."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:433
msgid ""
"perform B<IPC_SET> and B<IPC_RMID> operations on arbitrary System V IPC "
"objects;"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:437 build/C/man7/capabilities.7:728
msgid "override B<RLIMIT_NPROC> resource limit;"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:444
msgid ""
"perform operations on I<trusted> and I<security> extended attributes (see "
"B<xattr>(7));"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:447
msgid "use B<lookup_dcookie>(2);"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:455
msgid ""
"use B<ioprio_set>(2)  to assign B<IOPRIO_CLASS_RT> and (before Linux 2.6.25)  "
"B<IOPRIO_CLASS_IDLE> I/O scheduling classes;"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:457
msgid "forge PID when passing socket credentials via UNIX domain sockets;"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:466
msgid ""
"exceed I</proc/sys/fs/file-max>, the system-wide limit on the number of open "
"files, in system calls that open files (e.g., B<accept>(2), B<execve>(2), "
"B<open>(2), B<pipe>(2));"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:475
msgid ""
"employ B<CLONE_*> flags that create new namespaces with B<clone>(2)  and "
"B<unshare>(2)  (but, since Linux 3.8, creating user namespaces does not "
"require any capability);"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:479
msgid "access privileged I<perf> event information;"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:487
msgid "call B<setns>(2)  (requires B<CAP_SYS_ADMIN> in the I<target> namespace);"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:490
msgid "call B<fanotify_init>(2);"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:497
msgid ""
"perform privileged B<KEYCTL_CHOWN> and B<KEYCTL_SETPERM> B<keyctl>(2)  "
"operations;"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:502
msgid "perform B<madvise>(2)  B<MADV_HWPOISON> operation;"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:508
msgid ""
"employ the B<TIOCSTI> B<ioctl>(2)  to insert characters into the input queue "
"of a terminal other than the caller's controlling terminal;"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:512
msgid "employ the obsolete B<nfsservctl>(2)  system call;"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:516
msgid "employ the obsolete B<bdflush>(2)  system call;"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:520
msgid "perform various privileged block-device B<ioctl>(2)  operations;"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:524
msgid "perform various privileged filesystem B<ioctl>(2)  operations;"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:531
msgid ""
"perform privileged B<ioctl>(2)  operations on the I</dev/random> device (see "
"B<random>(4));"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:537
msgid ""
"install a B<seccomp>(2)  filter without first having to set the "
"I<no_new_privs> thread attribute;"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:539
msgid "modify allow/deny rules for device control groups;"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:544
msgid ""
"employ the B<ptrace>(2)  B<PTRACE_SECCOMP_GET_FILTER> operation to dump "
"tracee's seccomp filters;"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:551
msgid ""
"employ the B<ptrace>(2)  B<PTRACE_SETOPTIONS> operation to suspend the "
"tracee's seccomp protections (i.e., the B<PTRACE_O_SUSPEND_SECCOMP> flag);"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:553
msgid "perform administrative operations on many device drivers;"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:558
msgid ""
"modify autogroup nice values by writing to I</proc/[pid]/autogroup> (see "
"B<sched>(7))."
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:560
#, no-wrap
msgid "B<CAP_SYS_BOOT>"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:566
msgid "Use B<reboot>(2)  and B<kexec_load>(2)."
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:566
#, no-wrap
msgid "B<CAP_SYS_CHROOT>"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:573
msgid "Use B<chroot>(2);"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:576
msgid "change mount namespaces using B<setns>(2)."
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:578
#, no-wrap
msgid "B<CAP_SYS_MODULE>"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:588
msgid ""
"Load and unload kernel modules (see B<init_module>(2)  and "
"B<delete_module>(2));"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:591
msgid ""
"in kernels before 2.6.25: drop capabilities from the system-wide capability "
"bounding set."
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:593
#, no-wrap
msgid "B<CAP_SYS_NICE>"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:602
msgid ""
"Lower the process nice value (B<nice>(2), B<setpriority>(2))  and change the "
"nice value for arbitrary processes;"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:608
msgid ""
"set real-time scheduling policies for calling process, and set scheduling "
"policies and priorities for arbitrary processes (B<sched_setscheduler>(2), "
"B<sched_setparam>(2), B<sched_setattr>(2));"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:611
msgid "set CPU affinity for arbitrary processes (B<sched_setaffinity>(2));"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:614
msgid ""
"set I/O scheduling class and priority for arbitrary processes "
"(B<ioprio_set>(2));"
msgstr ""

#.  FIXME CAP_SYS_NICE also has the following effect for
#.  migrate_pages(2):
#.      do_migrate_pages(mm, &old, &new,
#.          capable(CAP_SYS_NICE) ? MPOL_MF_MOVE_ALL : MPOL_MF_MOVE);
#
#.  Document this.
#. type: Plain text
#: build/C/man7/capabilities.7:625
msgid ""
"apply B<migrate_pages>(2)  to arbitrary processes and allow processes to be "
"migrated to arbitrary nodes;"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:629
msgid "apply B<move_pages>(2)  to arbitrary processes;"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:636
msgid "use the B<MPOL_MF_MOVE_ALL> flag with B<mbind>(2)  and B<move_pages>(2)."
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:638
#, no-wrap
msgid "B<CAP_SYS_PACCT>"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:642
msgid "Use B<acct>(2)."
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:642
#, no-wrap
msgid "B<CAP_SYS_PTRACE>"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:649
msgid "Trace arbitrary processes using B<ptrace>(2);"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:653
msgid "apply B<get_robust_list>(2)  to arbitrary processes;"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:658
msgid ""
"transfer data to or from the memory of arbitrary processes using "
"B<process_vm_readv>(2)  and B<process_vm_writev>(2);"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:661
msgid "inspect processes using B<kcmp>(2)."
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:663
#, no-wrap
msgid "B<CAP_SYS_RAWIO>"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:672
msgid "Perform I/O port operations (B<iopl>(2)  and B<ioperm>(2));"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:675
msgid "access I</proc/kcore>;"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:680
msgid "employ the B<FIBMAP> B<ioctl>(2)  operation;"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:683
msgid ""
"open devices for accessing x86 model-specific registers (MSRs, see "
"B<msr>(4));"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:686
msgid "update I</proc/sys/vm/mmap_min_addr>;"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:689
msgid ""
"create memory mappings at addresses below the value specified by "
"I</proc/sys/vm/mmap_min_addr>;"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:692
msgid "map files in I</proc/bus/pci>;"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:697
msgid "open I</dev/mem> and I</dev/kmem>;"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:699
msgid "perform various SCSI device commands;"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:705
msgid "perform certain operations on B<hpsa>(4)  and B<cciss>(4)  devices;"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:707
msgid "perform a range of device-specific operations on other devices."
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:709
#, no-wrap
msgid "B<CAP_SYS_RESOURCE>"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:715
msgid "Use reserved space on ext2 filesystems;"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:719
msgid "make B<ioctl>(2)  calls controlling ext3 journaling;"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:721
msgid "override disk quota limits;"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:724
msgid "increase resource limits (see B<setrlimit>(2));"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:730
msgid "override maximum number of consoles on console allocation;"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:732
msgid "override maximum number of keymaps;"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:734
msgid "allow more than 64hz interrupts from the real-time clock;"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:743
msgid ""
"raise I<msg_qbytes> limit for a System V message queue above the limit in "
"I</proc/sys/kernel/msgmnb> (see B<msgop>(2)  and B<msgctl>(2));"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:750
msgid ""
"allow the B<RLIMIT_NOFILE> resource limit on the number of \"in-flight\" "
"file descriptors to be bypassed when passing file descriptors to another "
"process via a UNIX domain socket (see B<unix>(7));"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:757
msgid ""
"override the I</proc/sys/fs/pipe-size-max> limit when setting the capacity "
"of a pipe using the B<F_SETPIPE_SZ> B<fcntl>(2)  command;"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:762
msgid ""
"use B<F_SETPIPE_SZ> to increase the capacity of a pipe above the limit "
"specified by I</proc/sys/fs/pipe-max-size>;"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:770
msgid ""
"override I</proc/sys/fs/mqueue/queues_max,> I</proc/sys/fs/mqueue/msg_max,> "
"and I</proc/sys/fs/mqueue/msgsize_max> limits when creating POSIX message "
"queues (see B<mq_overview>(7));"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:775
msgid "employ the B<prctl>(2)  B<PR_SET_MM> operation;"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:780
msgid ""
"set I</proc/[pid]/oom_score_adj> to a value lower than the value last set by "
"a process with B<CAP_SYS_RESOURCE>."
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:782
#, no-wrap
msgid "B<CAP_SYS_TIME>"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:789
msgid ""
"Set system clock (B<settimeofday>(2), B<stime>(2), B<adjtimex>(2)); set "
"real-time (hardware) clock."
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:789
#, no-wrap
msgid "B<CAP_SYS_TTY_CONFIG>"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:796
msgid ""
"Use B<vhangup>(2); employ various privileged B<ioctl>(2)  operations on "
"virtual terminals."
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:796
#, no-wrap
msgid "B<CAP_SYSLOG> (since Linux 2.6.37)"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:807
msgid ""
"Perform privileged B<syslog>(2)  operations.  See B<syslog>(2)  for "
"information on which operations require privilege."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:817
msgid ""
"View kernel addresses exposed via I</proc> and other interfaces when "
"I</proc/sys/kernel/kptr_restrict> has the value 1.  (See the discussion of "
"the I<kptr_restrict> in B<proc>(5).)"
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:819
#, no-wrap
msgid "B<CAP_WAKE_ALARM> (since Linux 3.0)"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:827
msgid ""
"Trigger something that will wake up the system (set B<CLOCK_REALTIME_ALARM> "
"and B<CLOCK_BOOTTIME_ALARM> timers)."
msgstr ""

#. type: SS
#: build/C/man7/capabilities.7:827
#, no-wrap
msgid "Past and current implementation"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:829
msgid "A full implementation of capabilities requires that:"
msgstr ""

#. type: IP
#: build/C/man7/capabilities.7:829 build/C/man7/capabilities.7:1288 build/C/man7/capabilities.7:1483 build/C/man7/capabilities.7:1536 build/C/man7/cgroups.7:583 build/C/man7/cgroups.7:1391 build/C/man7/cgroups.7:1447 build/C/man7/cgroups.7:1796 build/C/man7/cgroups.7:1845 build/C/man3/posix_spawn.3:238
#, no-wrap
msgid "1."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:833
msgid ""
"For all privileged operations, the kernel must check whether the thread has "
"the required capability in its effective set."
msgstr ""

#. type: IP
#: build/C/man7/capabilities.7:833 build/C/man7/capabilities.7:1295 build/C/man7/capabilities.7:1489 build/C/man7/capabilities.7:1542 build/C/man7/cgroups.7:586 build/C/man7/cgroups.7:1428 build/C/man7/cgroups.7:1471 build/C/man7/cgroups.7:1798 build/C/man7/cgroups.7:1851 build/C/man3/posix_spawn.3:244
#, no-wrap
msgid "2."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:836
msgid ""
"The kernel must provide system calls allowing a thread's capability sets to "
"be changed and retrieved."
msgstr ""

#. type: IP
#: build/C/man7/capabilities.7:836 build/C/man7/capabilities.7:1492 build/C/man7/capabilities.7:1546 build/C/man7/cgroups.7:591 build/C/man7/cgroups.7:1811 build/C/man7/cgroups.7:1856 build/C/man3/posix_spawn.3:251
#, no-wrap
msgid "3."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:839
msgid ""
"The filesystem must support attaching capabilities to an executable file, so "
"that a process gains those capabilities when the file is executed."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:843
msgid ""
"Before kernel 2.6.24, only the first two of these requirements are met; "
"since kernel 2.6.24, all three requirements are met."
msgstr ""

#. type: SS
#: build/C/man7/capabilities.7:843
#, no-wrap
msgid "Notes to kernel developers"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:846
msgid ""
"When adding a new kernel feature that should be governed by a capability, "
"consider the following points."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:851
msgid ""
"The goal of capabilities is divide the power of superuser into pieces, such "
"that if a program that has one or more capabilities is compromised, its "
"power to do damage to the system would be less than the same program running "
"with root privilege."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:859
msgid ""
"You have the choice of either creating a new capability for your new "
"feature, or associating the feature with one of the existing capabilities.  "
"In order to keep the set of capabilities to a manageable size, the latter "
"option is preferable, unless there are compelling reasons to take the former "
"option.  (There is also a technical limit: the size of capability sets is "
"currently limited to 64 bits.)"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:867
msgid ""
"To determine which existing capability might best be associated with your "
"new feature, review the list of capabilities above in order to find a "
"\"silo\" into which your new feature best fits.  One approach to take is to "
"determine if there are other features requiring capabilities that will "
"always be used along with the new feature.  If the new feature is useless "
"without these other features, you should use the same capability as the "
"other features."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:885
msgid ""
"I<Don't> choose B<CAP_SYS_ADMIN> if you can possibly avoid it! A vast "
"proportion of existing capability checks are associated with this capability "
"(see the partial list above).  It can plausibly be called \"the new root\", "
"since on the one hand, it confers a wide range of powers, and on the other "
"hand, its broad scope means that this is the capability that is required by "
"many privileged programs.  Don't make the problem worse.  The only new "
"features that should be associated with B<CAP_SYS_ADMIN> are ones that "
"I<closely> match existing uses in that silo."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:895
msgid ""
"If you have determined that it really is necessary to create a new "
"capability for your feature, don't make or name it as a \"single-use\" "
"capability.  Thus, for example, the addition of the highly specific "
"B<CAP_SYS_PACCT> was probably a mistake.  Instead, try to identify and name "
"your new capability as a broader silo into which other related future use "
"cases might fit."
msgstr ""

#. type: SS
#: build/C/man7/capabilities.7:895
#, no-wrap
msgid "Thread capability sets"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:898
msgid ""
"Each thread has the following capability sets containing zero or more of the "
"above capabilities:"
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:898
#, no-wrap
msgid "I<Permitted>"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:906
msgid ""
"This is a limiting superset for the effective capabilities that the thread "
"may assume.  It is also a limiting superset for the capabilities that may be "
"added to the inheritable set by a thread that does not have the "
"B<CAP_SETPCAP> capability in its effective set."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:912
msgid ""
"If a thread drops a capability from its permitted set, it can never "
"reacquire that capability (unless it B<execve>(2)s either a set-user-ID-root "
"program, or a program whose associated file capabilities grant that "
"capability)."
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:912
#, no-wrap
msgid "I<Inheritable>"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:919
msgid ""
"This is a set of capabilities preserved across an B<execve>(2).  Inheritable "
"capabilities remain inheritable when executing any program, and inheritable "
"capabilities are added to the permitted set when executing a program that "
"has the corresponding bits set in the file inheritable set."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:925
msgid ""
"Because inheritable capabilities are not generally preserved across "
"B<execve>(2)  when running as a non-root user, applications that wish to run "
"helper programs with elevated capabilities should consider using ambient "
"capabilities, described below."
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:925
#, no-wrap
msgid "I<Effective>"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:929
msgid ""
"This is the set of capabilities used by the kernel to perform permission "
"checks for the thread."
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:929
#, no-wrap
msgid "I<Bounding> (per-thread since Linux 2.6.25)"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:934
msgid ""
"The capability bounding set is a mechanism that can be used to limit the "
"capabilities that are gained during B<execve>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:938
msgid ""
"Since Linux 2.6.25, this is a per-thread capability set.  In older kernels, "
"the capability bounding set was a system wide attribute shared by all "
"threads on the system."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:940
msgid "For more details on the capability bounding set, see below."
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:940
#, no-wrap
msgid "I<Ambient> (since Linux 4.3)"
msgstr ""

#.  commit 58319057b7847667f0c9585b9de0e8932b0fdb08
#. type: Plain text
#: build/C/man7/capabilities.7:948
msgid ""
"This is a set of capabilities that are preserved across an B<execve>(2)  of "
"a program that is not privileged.  The ambient capability set obeys the "
"invariant that no capability can ever be ambient if it is not both permitted "
"and inheritable."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:953
msgid ""
"The ambient capability set can be directly modified using B<prctl>(2).  "
"Ambient capabilities are automatically lowered if either of the "
"corresponding permitted or inheritable capabilities is lowered."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:966
msgid ""
"Executing a program that changes UID or GID due to the set-user-ID or "
"set-group-ID bits or executing a program that has any file capabilities set "
"will clear the ambient set.  Ambient capabilities are added to the permitted "
"set and assigned to the effective set when B<execve>(2)  is called.  If "
"ambient capabilities cause a process's permitted and effective capabilities "
"to increase during an B<execve>(2), this does not trigger the "
"secure-execution mode described in B<ld.so>(8)."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:972
msgid ""
"A child created via B<fork>(2)  inherits copies of its parent's capability "
"sets.  See below for a discussion of the treatment of capabilities during "
"B<execve>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:976
msgid ""
"Using B<capset>(2), a thread may manipulate its own capability sets (see "
"below)."
msgstr ""

#.  commit 73efc0394e148d0e15583e13712637831f926720
#. type: Plain text
#: build/C/man7/capabilities.7:985
msgid ""
"Since Linux 3.2, the file I</proc/sys/kernel/cap_last_cap> exposes the "
"numerical value of the highest capability supported by the running kernel; "
"this can be used to determine the highest bit that may be set in a "
"capability set."
msgstr ""

#. type: SS
#: build/C/man7/capabilities.7:985
#, no-wrap
msgid "File capabilities"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1002
msgid ""
"Since kernel 2.6.24, the kernel supports associating capability sets with an "
"executable file using B<setcap>(8).  The file capability sets are stored in "
"an extended attribute (see B<setxattr>(2)  and B<xattr>(7))  named "
"I<security.capability>.  Writing to this extended attribute requires the "
"B<CAP_SETFCAP> capability.  The file capability sets, in conjunction with "
"the capability sets of the thread, determine the capabilities of a thread "
"after an B<execve>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1004
msgid "The three file capability sets are:"
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:1004
#, no-wrap
msgid "I<Permitted> (formerly known as I<forced>):"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1008
msgid ""
"These capabilities are automatically permitted to the thread, regardless of "
"the thread's inheritable capabilities."
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:1008
#, no-wrap
msgid "I<Inheritable> (formerly known as I<allowed>):"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1014
msgid ""
"This set is ANDed with the thread's inheritable set to determine which "
"inheritable capabilities are enabled in the permitted set of the thread "
"after the B<execve>(2)."
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:1014
#, no-wrap
msgid "I<Effective>:"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1024
msgid ""
"This is not a set, but rather just a single bit.  If this bit is set, then "
"during an B<execve>(2)  all of the new permitted capabilities for the thread "
"are also raised in the effective set.  If this bit is not set, then after an "
"B<execve>(2), none of the new permitted capabilities is in the new effective "
"set."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1040
msgid ""
"Enabling the file effective capability bit implies that any file permitted "
"or inheritable capability that causes a thread to acquire the corresponding "
"permitted capability during an B<execve>(2)  (see the transformation rules "
"described below) will also acquire that capability in its effective set.  "
"Therefore, when assigning capabilities to a file (B<setcap>(8), "
"B<cap_set_file>(3), B<cap_set_fd>(3)), if we specify the effective flag as "
"being enabled for any capability, then the effective flag must also be "
"specified as enabled for all other capabilities for which the corresponding "
"permitted or inheritable flags is enabled."
msgstr ""

#. type: SS
#: build/C/man7/capabilities.7:1040
#, no-wrap
msgid "File capability extended attribute versioning"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1048
msgid ""
"To allow extensibility, the kernel supports a scheme to encode a version "
"number inside the I<security.capability> extended attribute that is used to "
"implement file capabilities.  These version numbers are internal to the "
"implementation, and not directly visible to user-space applications.  To "
"date, the following versions are supported:"
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:1048
#, no-wrap
msgid "B<VFS_CAP_REVISION_1>"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1052
msgid ""
"This was the original file capability implementation, which supported 32-bit "
"masks for file capabilities."
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:1052
#, no-wrap
msgid "B<VFS_CAP_REVISION_2> (since Linux 2.6.25)"
msgstr ""

#.  commit e338d263a76af78fe8f38a72131188b58fceb591
#. type: Plain text
#: build/C/man7/capabilities.7:1063
msgid ""
"This version allows for file capability masks that are 64 bits in size, and "
"was necessary as the number of supported capabilities grew beyond 32.  The "
"kernel transparently continues to support the execution of files that have "
"32-bit version 1 capability masks, but when adding capabilities to files "
"that did not previously have capabilities, or modifying the capabilities of "
"existing files, it automatically uses the version 2 scheme (or possibly the "
"version 3 scheme, as described below)."
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:1063
#, no-wrap
msgid "B<VFS_CAP_REVISION_3> (since Linux 4.14)"
msgstr ""

#.  commit 8db6c34f1dbc8e06aa016a9b829b06902c3e1340
#. type: Plain text
#: build/C/man7/capabilities.7:1068
msgid ""
"Version 3 file capabilities are provided to support namespaced file "
"capabilities (described below)."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1076
msgid ""
"As with version 2 file capabilities, version 3 capability masks are 64 bits "
"in size.  But in addition, the root user ID of namespace is encoded in the "
"I<security.capability> extended attribute.  (A namespace's root user ID is "
"the value that user ID 0 inside that namespace maps to in the initial user "
"namespace.)"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1082
msgid ""
"Version 3 file capabilities are designed to coexist with version 2 "
"capabilities; that is, on a modern Linux system, there may be some files "
"with version 2 capabilities while others have version 3 capabilities."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1093
msgid ""
"Before Linux 4.14, the only kind of file capability extended attribute that "
"could be attached to a file was a B<VFS_CAP_REVISION_2> attribute.  Since "
"Linux 4.14, the version of the I<security.capability> extended attribute "
"that is attached to a file depends on the circumstances in which the "
"attribute was created."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1100
msgid ""
"Starting with Linux 4.14, a I<security.capability> extended attribute is "
"automatically created as (or converted to)  a version 3 "
"(B<VFS_CAP_REVISION_3>)  attribute if both of the following are true:"
msgstr ""

#. type: IP
#: build/C/man7/capabilities.7:1100
#, no-wrap
msgid "(1)"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1104
msgid ""
"The thread writing the attribute resides in a noninitial user namespace.  "
"(More precisely: the thread resides in a user namespace other than the one "
"from which the underlying filesystem was mounted.)"
msgstr ""

#. type: IP
#: build/C/man7/capabilities.7:1104
#, no-wrap
msgid "(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1113
msgid ""
"The thread has the B<CAP_SETFCAP> capability over the file inode, meaning "
"that (a) the thread has the B<CAP_SETFCAP> capability in its own user "
"namespace; and (b) the UID and GID of the file inode have mappings in the "
"writer's user namespace."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1119
msgid ""
"When a B<VFS_CAP_REVISION_3> I<security.capability> extended attribute is "
"created, the root user ID of the creating thread's user namespace is saved "
"in the extended attribute."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1130
msgid ""
"By contrast, creating or modifying a I<security.capability> extended "
"attribute from a privileged (B<CAP_SETFCAP>)  thread that resides in the "
"namespace where the underlying filesystem was mounted (this normally means "
"the initial user namespace)  automatically results in the creation of a "
"version 2 (B<VFS_CAP_REVISION_2>)  attribute."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1159
msgid ""
"Note that the creation of a version 3 I<security.capability> extended "
"attribute is automatic.  That is to say, when a user-space application "
"writes (B<setxattr>(2))  a I<security.capability> attribute in the version 2 "
"format, the kernel will automatically create a version 3 attribute if the "
"attribute is created in the circumstances described above.  Correspondingly, "
"when a version 3 I<security.capability> attribute is retrieved "
"(B<getxattr>(2))  by a process that resides inside a user namespace that was "
"created by the root user ID (or a descendant of that user namespace), the "
"returned attribute is (automatically)  simplified to appear as a version 2 "
"attribute (i.e., the returned value is the size of a version 2 attribute and "
"does not include the root user ID).  These automatic translations mean that "
"no changes are required to user-space tools (e.g., B<setcap>(1)  and "
"B<getcap>(1))  in order for those tools to be used to create and retrieve "
"version 3 I<security.capability> attributes."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1169
msgid ""
"Note that a file can have either a version 2 or a version 3 "
"I<security.capability> extended attribute associated with it, but not both: "
"creation or modification of the I<security.capability> extended attribute "
"will automatically modify the version according to the circumstances in "
"which the extended attribute is created or modified."
msgstr ""

#. type: SS
#: build/C/man7/capabilities.7:1169
#, no-wrap
msgid "Transformation of capabilities during execve()"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1174
msgid ""
"During an B<execve>(2), the kernel calculates the new capabilities of the "
"process using the following algorithm:"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1178
#, no-wrap
msgid "P'(ambient)     = (file is privileged) ? 0 : P(ambient)\n"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1181
#, no-wrap
msgid ""
"P'(permitted)   = (P(inheritable) & F(inheritable)) |\n"
"                  (F(permitted) & P(bounding)) | P'(ambient)\n"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1183
#, no-wrap
msgid "P'(effective)   = F(effective) ? P'(permitted) : P'(ambient)\n"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1185
#, no-wrap
msgid "P'(inheritable) = P(inheritable)    [i.e., unchanged]\n"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1187
#, no-wrap
msgid "P'(bounding)    = P(bounding)       [i.e., unchanged]\n"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1191
msgid "where:"
msgstr ""

#. type: IP
#: build/C/man7/capabilities.7:1192
#, no-wrap
msgid "P()"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1195
msgid "denotes the value of a thread capability set before the B<execve>(2)"
msgstr ""

#. type: IP
#: build/C/man7/capabilities.7:1195
#, no-wrap
msgid "P'()"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1198
msgid "denotes the value of a thread capability set after the B<execve>(2)"
msgstr ""

#. type: IP
#: build/C/man7/capabilities.7:1198
#, no-wrap
msgid "F()"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1200
msgid "denotes a file capability set"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1204
msgid ""
"Note the following details relating to the above capability transformation "
"rules:"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1210
msgid ""
"The ambient capability set is present only since Linux 4.3.  When "
"determining the transformation of the ambient set during B<execve>(2), a "
"privileged file is one that has capabilities or has the set-user-ID or "
"set-group-ID bit set."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1217
msgid ""
"Prior to Linux 2.6.25, the bounding set was a system-wide attribute shared "
"by all threads.  That system-wide value was employed to calculate the new "
"permitted set during B<execve>(2)  in the same manner as shown above for "
"I<P(bounding)>."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1226
msgid ""
"I<Note>: during the capability transitions described above, file "
"capabilities may be ignored (treated as empty) for the same reasons that the "
"set-user-ID and set-group-ID bits are ignored; see B<execve>(2).  File "
"capabilities are similarly ignored if the kernel was booted with the "
"I<no_file_caps> option."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1239
msgid ""
"I<Note>: according to the rules above, if a process with nonzero user IDs "
"performs an B<execve>(2)  then any capabilities that are present in its "
"permitted and effective sets will be cleared.  For the treatment of "
"capabilities when a process with a user ID of zero performs an B<execve>(2), "
"see below under I<Capabilities and execution of programs by root>."
msgstr ""

#. type: SS
#: build/C/man7/capabilities.7:1239
#, no-wrap
msgid "Safety checking for capability-dumb binaries"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1253
msgid ""
"A capability-dumb binary is an application that has been marked to have file "
"capabilities, but has not been converted to use the B<libcap>(3)  API to "
"manipulate its capabilities.  (In other words, this is a traditional "
"set-user-ID-root program that has been switched to use file capabilities, "
"but whose code has not been modified to understand capabilities.)  For such "
"applications, the effective capability bit is set on the file, so that the "
"file permitted capabilities are automatically enabled in the process "
"effective set when executing the file.  The kernel recognizes a file which "
"has the effective capability bit set as capability-dumb for the purpose of "
"the check described here."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1275
msgid ""
"When executing a capability-dumb binary, the kernel checks if the process "
"obtained all permitted capabilities that were specified in the file "
"permitted set, after the capability transformations described above have "
"been performed.  (The typical reason why this might I<not> occur is that the "
"capability bounding set masked out some of the capabilities in the file "
"permitted set.)  If the process did not obtain the full set of file "
"permitted capabilities, then B<execve>(2)  fails with the error B<EPERM>.  "
"This prevents possible security risks that could arise when a "
"capability-dumb application is executed with less privilege that it needs.  "
"Note that, by definition, the application could not itself recognize this "
"problem, since it does not employ the B<libcap>(3)  API."
msgstr ""

#. type: SS
#: build/C/man7/capabilities.7:1275
#, no-wrap
msgid "Capabilities and execution of programs by root"
msgstr ""

#.  See cap_bprm_set_creds(), bprm_caps_from_vfs_cap() and
#.  handle_privileged_root() in security/commoncap.c (Linux 5.0 source)
#. type: Plain text
#: build/C/man7/capabilities.7:1282
msgid ""
"In order to mirror traditional UNIX semantics, the kernel performs special "
"treatment of file capabilities when a process with UID 0 (root) executes a "
"program and when a set-user-ID-root program is executed."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1288
msgid ""
"After having performed any changes to the process effective ID that were "
"triggered by the set-user-ID mode bit of the binary\\(eme.g., switching the "
"effective user ID to 0 (root) because a set-user-ID-root program was "
"executed\\(emthe kernel calculates the file capability sets as follows:"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1295
msgid ""
"If the real or effective user ID of the process is 0 (root), then the file "
"inheritable and permitted sets are ignored; instead they are notionally "
"considered to be all ones (i.e., all capabilities enabled).  (There is one "
"exception to this behavior, described below in I<Set-user-ID-root programs "
"that have file capabilities>.)"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1299
msgid ""
"If the effective user ID of the process is 0 (root) or the file effective "
"bit is in fact enabled, then the file effective bit is notionally defined to "
"be one (enabled)."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1304
msgid ""
"These notional values for the file's capability sets are then used as "
"described above to calculate the transformation of the process's "
"capabilities during B<execve>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1312
msgid ""
"Thus, when a process with nonzero UIDs B<execve>(2)s a set-user-ID-root "
"program that does not have capabilities attached, or when a process whose "
"real and effective UIDs are zero B<execve>(2)s a program, the calculation of "
"the process's new permitted capabilities simplifies to:"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1316
#, no-wrap
msgid "P'(permitted)   = P(inheritable) | P(bounding)\n"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1318
#, no-wrap
msgid "P'(effective)   = P'(permitted)\n"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1327
msgid ""
"Consequently, the process gains all capabilities in its permitted and "
"effective capability sets, except those masked out by the capability "
"bounding set.  (In the calculation of P'(permitted), the P'(ambient) term "
"can be simplified away because it is by definition a proper subset of "
"P(inheritable).)"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1332
msgid ""
"The special treatments of user ID 0 (root) described in this subsection can "
"be disabled using the securebits mechanism described below."
msgstr ""

#. type: SS
#: build/C/man7/capabilities.7:1332
#, no-wrap
msgid "Set-user-ID-root programs that have file capabilities"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1350
msgid ""
"There is one exception to the behavior described under I<Capabilities and "
"execution of programs by root>.  If (a) the binary that is being executed "
"has capabilities attached and (b) the real user ID of the process is I<not> "
"0 (root) and (c) the effective user ID of the process I<is> 0 (root), then "
"the file capability bits are honored (i.e., they are not notionally "
"considered to be all ones).  The usual way in which this situation can arise "
"is when executing a set-UID-root program that also has file capabilities.  "
"When such a program is executed, the process gains just the capabilities "
"granted by the program (i.e., not all capabilities, as would occur when "
"executing a set-user-ID-root program that does not have any associated file "
"capabilities)."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1357
msgid ""
"Note that one can assign empty capability sets to a program file, and thus "
"it is possible to create a set-user-ID-root program that changes the "
"effective and saved set-user-ID of the process that executes the program to "
"0, but confers no capabilities to that process."
msgstr ""

#. type: SS
#: build/C/man7/capabilities.7:1357
#, no-wrap
msgid "Capability bounding set"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1362
msgid ""
"The capability bounding set is a security mechanism that can be used to "
"limit the capabilities that can be gained during an B<execve>(2).  The "
"bounding set is used in the following ways:"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1370
msgid ""
"During an B<execve>(2), the capability bounding set is ANDed with the file "
"permitted capability set, and the result of this operation is assigned to "
"the thread's permitted capability set.  The capability bounding set thus "
"places a limit on the permitted capabilities that may be granted by an "
"executable file."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1382
msgid ""
"(Since Linux 2.6.25)  The capability bounding set acts as a limiting "
"superset for the capabilities that a thread can add to its inheritable set "
"using B<capset>(2).  This means that if a capability is not in the bounding "
"set, then a thread can't add this capability to its inheritable set, even if "
"it was in its permitted capabilities, and thereby cannot have this "
"capability preserved in its permitted set when it B<execve>(2)s a file that "
"has the capability in its inheritable set."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1389
msgid ""
"Note that the bounding set masks the file permitted capabilities, but not "
"the inheritable capabilities.  If a thread maintains a capability in its "
"inheritable set that is not in its bounding set, then it can still gain that "
"capability in its permitted set by executing a file that has the capability "
"in its inheritable set."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1392
msgid ""
"Depending on the kernel version, the capability bounding set is either a "
"system-wide attribute, or a per-process attribute."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1394
msgid "B<Capability bounding set from Linux 2.6.25 onward>"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1399
msgid ""
"From Linux 2.6.25, the I<capability bounding set> is a per-thread "
"attribute.  (The system-wide capability bounding set described below no "
"longer exists.)"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1404
msgid ""
"The bounding set is inherited at B<fork>(2)  from the thread's parent, and "
"is preserved across an B<execve>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1417
msgid ""
"A thread may remove capabilities from its capability bounding set using the "
"B<prctl>(2)  B<PR_CAPBSET_DROP> operation, provided it has the "
"B<CAP_SETPCAP> capability.  Once a capability has been dropped from the "
"bounding set, it cannot be restored to that set.  A thread can determine if "
"a capability is in its bounding set using the B<prctl>(2)  "
"B<PR_CAPBSET_READ> operation."
msgstr ""

#.  commit b3a222e52e4d4be77cc4520a57af1a4a0d8222d1
#. type: Plain text
#: build/C/man7/capabilities.7:1437
msgid ""
"Removing capabilities from the bounding set is supported only if file "
"capabilities are compiled into the kernel.  In kernels before Linux 2.6.33, "
"file capabilities were an optional feature configurable via the "
"B<CONFIG_SECURITY_FILE_CAPABILITIES> option.  Since Linux 2.6.33, the "
"configuration option has been removed and file capabilities are always part "
"of the kernel.  When file capabilities are compiled into the kernel, the "
"B<init> process (the ancestor of all processes) begins with a full bounding "
"set.  If file capabilities are not compiled into the kernel, then B<init> "
"begins with a full bounding set minus B<CAP_SETPCAP>, because this "
"capability has a different meaning when there are no file capabilities."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1442
msgid ""
"Removing a capability from the bounding set does not remove it from the "
"thread's inheritable set.  However it does prevent the capability from being "
"added back into the thread's inheritable set in the future."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1444
msgid "B<Capability bounding set prior to Linux 2.6.25>"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1452
msgid ""
"In kernels before 2.6.25, the capability bounding set is a system-wide "
"attribute that affects all threads on the system.  The bounding set is "
"accessible via the file I</proc/sys/kernel/cap-bound>.  (Confusingly, this "
"bit mask parameter is expressed as a signed decimal number in "
"I</proc/sys/kernel/cap-bound>.)"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1459
msgid ""
"Only the B<init> process may set capabilities in the capability bounding "
"set; other than that, the superuser (more precisely: a process with the "
"B<CAP_SYS_MODULE> capability) may only clear capabilities from this set."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1468
msgid ""
"On a standard system the capability bounding set always masks out the "
"B<CAP_SETPCAP> capability.  To remove this restriction (dangerous!), modify "
"the definition of B<CAP_INIT_EFF_SET> in I<include/linux/capability.h> and "
"rebuild the kernel."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1474
msgid ""
"The system-wide capability bounding set feature was added to Linux starting "
"with kernel version 2.2.11."
msgstr ""

#. type: SS
#: build/C/man7/capabilities.7:1474
#, no-wrap
msgid "Effect of user ID changes on capabilities"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1483
msgid ""
"To preserve the traditional semantics for transitions between 0 and nonzero "
"user IDs, the kernel makes the following changes to a thread's capability "
"sets on changes to the thread's real, effective, saved set, and filesystem "
"user IDs (using B<setuid>(2), B<setresuid>(2), or similar):"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1489
msgid ""
"If one or more of the real, effective or saved set user IDs was previously "
"0, and as a result of the UID changes all of these IDs have a nonzero value, "
"then all capabilities are cleared from the permitted, effective, and ambient "
"capability sets."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1492
msgid ""
"If the effective user ID is changed from 0 to nonzero, then all capabilities "
"are cleared from the effective set."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1495
msgid ""
"If the effective user ID is changed from nonzero to 0, then the permitted "
"set is copied to the effective set."
msgstr ""

#. type: IP
#: build/C/man7/capabilities.7:1495 build/C/man7/capabilities.7:1550 build/C/man7/cgroups.7:596 build/C/man7/cgroups.7:1813
#, no-wrap
msgid "4."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1513
msgid ""
"If the filesystem user ID is changed from 0 to nonzero (see B<setfsuid>(2)), "
"then the following capabilities are cleared from the effective set: "
"B<CAP_CHOWN>, B<CAP_DAC_OVERRIDE>, B<CAP_DAC_READ_SEARCH>, B<CAP_FOWNER>, "
"B<CAP_FSETID>, B<CAP_LINUX_IMMUTABLE> (since Linux 2.6.30), "
"B<CAP_MAC_OVERRIDE>, and B<CAP_MKNOD> (since Linux 2.6.30).  If the "
"filesystem UID is changed from nonzero to 0, then any of these capabilities "
"that are enabled in the permitted set are enabled in the effective set."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1520
msgid ""
"If a thread that has a 0 value for one or more of its user IDs wants to "
"prevent its permitted capability set being cleared when it resets all of its "
"user IDs to nonzero values, it can do so using the B<SECBIT_KEEP_CAPS> "
"securebits flag described below."
msgstr ""

#. type: SS
#: build/C/man7/capabilities.7:1520
#, no-wrap
msgid "Programmatically adjusting capability sets"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1536
msgid ""
"A thread can retrieve and change its permitted, effective, and inheritable "
"capability sets using the B<capget>(2)  and B<capset>(2)  system calls.  "
"However, the use of B<cap_get_proc>(3)  and B<cap_set_proc>(3), both "
"provided in the I<libcap> package, is preferred for this purpose.  The "
"following rules govern changes to the thread capability sets:"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1542
msgid ""
"If the caller does not have the B<CAP_SETPCAP> capability, the new "
"inheritable set must be a subset of the combination of the existing "
"inheritable and permitted sets."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1546
msgid ""
"(Since Linux 2.6.25)  The new inheritable set must be a subset of the "
"combination of the existing inheritable set and the capability bounding set."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1550
msgid ""
"The new permitted set must be a subset of the existing permitted set (i.e., "
"it is not possible to acquire permitted capabilities that the thread does "
"not currently have)."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1552
msgid "The new effective set must be a subset of the new permitted set."
msgstr ""

#. type: SS
#: build/C/man7/capabilities.7:1552
#, no-wrap
msgid "The securebits flags: establishing a capabilities-only environment"
msgstr ""

#.  For some background:
#.        see http://lwn.net/Articles/280279/ and
#.        http://article.gmane.org/gmane.linux.kernel.lsm/5476/
#. type: Plain text
#: build/C/man7/capabilities.7:1563
msgid ""
"Starting with kernel 2.6.26, and with a kernel in which file capabilities "
"are enabled, Linux implements a set of per-thread I<securebits> flags that "
"can be used to disable special handling of capabilities for UID 0 "
"(I<root>).  These flags are as follows:"
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:1563
#, no-wrap
msgid "B<SECBIT_KEEP_CAPS>"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1572
msgid ""
"Setting this flag allows a thread that has one or more 0 UIDs to retain "
"capabilities in its permitted set when it switches all of its UIDs to "
"nonzero values.  If this flag is not set, then such a UID switch causes the "
"thread to lose all permitted capabilities.  This flag is always cleared on "
"an B<execve>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1581
msgid ""
"Note that even with the B<SECBIT_KEEP_CAPS> flag set, the effective "
"capabilities of a thread are cleared when it switches its effective UID to a "
"nonzero value.  However, if the thread has set this flag and its effective "
"UID is already nonzero, and the thread subsequently switches all other UIDs "
"to nonzero values, then the effective capabilities will not be cleared."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1588
msgid ""
"The setting of the B<SECBIT_KEEP_CAPS> flag is ignored if the "
"B<SECBIT_NO_SETUID_FIXUP> flag is set.  (The latter flag provides a superset "
"of the effect of the former flag.)"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1593
msgid ""
"This flag provides the same functionality as the older B<prctl>(2)  "
"B<PR_SET_KEEPCAPS> operation."
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:1593
#, no-wrap
msgid "B<SECBIT_NO_SETUID_FIXUP>"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1601
msgid ""
"Setting this flag stops the kernel from adjusting the process's permitted, "
"effective, and ambient capability sets when the thread's effective and "
"filesystem UIDs are switched between zero and nonzero values.  (See the "
"subsection I<Effect of user ID changes on capabilities>.)"
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:1601
#, no-wrap
msgid "B<SECBIT_NOROOT>"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1609
msgid ""
"If this bit is set, then the kernel does not grant capabilities when a "
"set-user-ID-root program is executed, or when a process with an effective or "
"real UID of 0 calls B<execve>(2).  (See the subsection I<Capabilities and "
"execution of programs by root>.)"
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:1609
#, no-wrap
msgid "B<SECBIT_NO_CAP_AMBIENT_RAISE>"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1615
msgid ""
"Setting this flag disallows raising ambient capabilities via the B<prctl>(2)  "
"B<PR_CAP_AMBIENT_RAISE> operation."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1626
msgid ""
"Each of the above \"base\" flags has a companion \"locked\" flag.  Setting "
"any of the \"locked\" flags is irreversible, and has the effect of "
"preventing further changes to the corresponding \"base\" flag.  The locked "
"flags are: B<SECBIT_KEEP_CAPS_LOCKED>, B<SECBIT_NO_SETUID_FIXUP_LOCKED>, "
"B<SECBIT_NOROOT_LOCKED>, and B<SECBIT_NO_CAP_AMBIENT_RAISE_LOCKED>."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1643
msgid ""
"The I<securebits> flags can be modified and retrieved using the B<prctl>(2)  "
"B<PR_SET_SECUREBITS> and B<PR_GET_SECUREBITS> operations.  The "
"B<CAP_SETPCAP> capability is required to modify the flags.  Note that the "
"B<SECBIT_*> constants are available only after including the "
"I<E<lt>linux/securebits.hE<gt>> header file."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1652
msgid ""
"The I<securebits> flags are inherited by child processes.  During an "
"B<execve>(2), all of the flags are preserved, except B<SECBIT_KEEP_CAPS> "
"which is always cleared."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1657
msgid ""
"An application can use the following call to lock itself, and all of its "
"descendants, into an environment where the only way of gaining capabilities "
"is by executing a program with associated file capabilities:"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1669
#, no-wrap
msgid ""
"prctl(PR_SET_SECUREBITS,\n"
"        /* SECBIT_KEEP_CAPS off */\n"
"        SECBIT_KEEP_CAPS_LOCKED |\n"
"        SECBIT_NO_SETUID_FIXUP |\n"
"        SECBIT_NO_SETUID_FIXUP_LOCKED |\n"
"        SECBIT_NOROOT |\n"
"        SECBIT_NOROOT_LOCKED);\n"
"        /* Setting/locking SECBIT_NO_CAP_AMBIENT_RAISE\n"
"           is not required */\n"
msgstr ""

#. type: SS
#: build/C/man7/capabilities.7:1673
#, no-wrap
msgid "Per-user-namespace \"set-user-ID-root\" programs"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1679
msgid ""
"A set-user-ID program whose UID matches the UID that created a user "
"namespace will confer capabilities in the process's permitted and effective "
"sets when executed by any process inside that namespace or any descendant "
"user namespace."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1690
msgid ""
"The rules about the transformation of the process's capabilities during the "
"B<execve>(2)  are exactly as described in the subsections I<Transformation "
"of capabilities during execve()> and I<Capabilities and execution of "
"programs by root>, with the difference that, in the latter subsection, "
"\"root\" is the UID of the creator of the user namespace."
msgstr ""

#. type: SS
#: build/C/man7/capabilities.7:1690
#, no-wrap
msgid "Namespaced file capabilities"
msgstr ""

#.  commit 8db6c34f1dbc8e06aa016a9b829b06902c3e1340
#. type: Plain text
#: build/C/man7/capabilities.7:1698
msgid ""
"Traditional (i.e., version 2) file capabilities associate only a set of "
"capability masks with a binary executable file.  When a process executes a "
"binary with such capabilities, it gains the associated capabilities (within "
"its user namespace)  as per the rules described above in \"Transformation of "
"capabilities during execve()\"."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1711
msgid ""
"Because version 2 file capabilities confer capabilities to the executing "
"process regardless of which user namespace it resides in, only privileged "
"processes are permitted to associate capabilities with a file.  Here, "
"\"privileged\" means a process that has the B<CAP_SETFCAP> capability in the "
"user namespace where the filesystem was mounted (normally the initial user "
"namespace).  This limitation renders file capabilities useless for certain "
"use cases.  For example, in user-namespaced containers, it can be desirable "
"to be able to create a binary that confers capabilities only to processes "
"executed inside that container, but not to processes that are executed "
"outside the container."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1725
msgid ""
"Linux 4.14 added so-called namespaced file capabilities to support such use "
"cases.  Namespaced file capabilities are recorded as version 3 (i.e., "
"B<VFS_CAP_REVISION_3>)  I<security.capability> extended attributes.  Such an "
"attribute is automatically created in the circumstances described above "
"under \"File capability extended attribute versioning\".  When a version 3 "
"I<security.capability> extended attribute is created, the kernel records not "
"just the capability masks in the extended attribute, but also the namespace "
"root user ID."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1738
msgid ""
"As with a binary that has B<VFS_CAP_REVISION_2> file capabilities, a binary "
"with B<VFS_CAP_REVISION_3> file capabilities confers capabilities to a "
"process during B<execve>().  However, capabilities are conferred only if the "
"binary is executed by a process that resides in a user namespace whose UID 0 "
"maps to the root user ID that is saved in the extended attribute, or when "
"executed by a process that resides in a descendant of such a namespace."
msgstr ""

#. type: SS
#: build/C/man7/capabilities.7:1738
#, no-wrap
msgid "Interaction with user namespaces"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1742
msgid ""
"For further information on the interaction of capabilities and user "
"namespaces, see B<user_namespaces>(7)."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1747
msgid ""
"No standards govern capabilities, but the Linux capability implementation is "
"based on the withdrawn POSIX.1e draft standard; see E<.UR "
"https://archive.org\\:/details\\:/posix_1003.1e-990310> E<.UE .>"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1755
msgid ""
"When attempting to B<strace>(1)  binaries that have capabilities (or "
"set-user-ID-root binaries), you may find the I<-u E<lt>usernameE<gt>> option "
"useful.  Something like:"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1759
#, no-wrap
msgid "$ B<sudo strace -o trace.log -u ceci ./myprivprog>\n"
msgstr ""

#.  commit 5915eb53861c5776cfec33ca4fcc1fd20d66dd27 removed
#.  CONFIG_SECURITY_CAPABILITIES
#. type: Plain text
#: build/C/man7/capabilities.7:1769
msgid ""
"From kernel 2.5.27 to kernel 2.6.26, capabilities were an optional kernel "
"component, and could be enabled/disabled via the "
"B<CONFIG_SECURITY_CAPABILITIES> kernel configuration option."
msgstr ""

#.  7b9a7ec565505699f503b4fcf61500dceb36e744
#. type: Plain text
#: build/C/man7/capabilities.7:1783
msgid ""
"The I</proc/[pid]/task/TID/status> file can be used to view the capability "
"sets of a thread.  The I</proc/[pid]/status> file shows the capability sets "
"of a process's main thread.  Before Linux 3.8, nonexistent capabilities were "
"shown as being enabled (1) in these sets.  Since Linux 3.8, all nonexistent "
"capabilities (above B<CAP_LAST_CAP>)  are shown as disabled (0)."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1798
msgid ""
"The I<libcap> package provides a suite of routines for setting and getting "
"capabilities that is more comfortable and less likely to change than the "
"interface provided by B<capset>(2)  and B<capget>(2).  This package also "
"provides the B<setcap>(8)  and B<getcap>(8)  programs.  It can be found at"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1801
msgid ""
"E<.UR "
"https://git.kernel.org\\:/pub\\:/scm\\:/libs\\:/libcap\\:/libcap.git\\:/refs/> "
"E<.UE .>"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1810
msgid ""
"Before kernel 2.6.24, and from kernel 2.6.24 to kernel 2.6.32 if file "
"capabilities are not enabled, a thread with the B<CAP_SETPCAP> capability "
"can manipulate the capabilities of threads other than itself.  However, this "
"is only theoretically possible, since no thread ever has B<CAP_SETPCAP> in "
"either of these cases:"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1817
msgid ""
"In the pre-2.6.25 implementation the system-wide capability bounding set, "
"I</proc/sys/kernel/cap-bound>, always masks out the B<CAP_SETPCAP> "
"capability, and this can not be changed without modifying the kernel source "
"and rebuilding the kernel."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1827
msgid ""
"If file capabilities are disabled (i.e., the kernel "
"B<CONFIG_SECURITY_FILE_CAPABILITIES> option is disabled), then B<init> "
"starts out with the B<CAP_SETPCAP> capability removed from its per-process "
"bounding set, and that bounding set is inherited by all other processes "
"created on the system."
msgstr ""

#.  from libcap-ng
#.  from libcap-ng
#.  from libcap-ng
#.  from libcap-ng
#. type: Plain text
#: build/C/man7/capabilities.7:1852
msgid ""
"B<capsh>(1), B<setpriv>(1), B<prctl>(2), B<setfsuid>(2), B<cap_clear>(3), "
"B<cap_copy_ext>(3), B<cap_from_text>(3), B<cap_get_file>(3), "
"B<cap_get_proc>(3), B<cap_init>(3), B<capgetp>(3), B<capsetp>(3), "
"B<libcap>(3), B<proc>(5), B<credentials>(7), B<pthreads>(7), "
"B<user_namespaces>(7), B<captest>(8), B<filecap>(8), B<getcap>(8), "
"B<getpcaps>(8), B<netcap>(8), B<pscap>(8), B<setcap>(8)"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1855
msgid "I<include/linux/capability.h> in the Linux kernel source tree"
msgstr ""

#. type: TH
#: build/C/man2/capget.2:16
#, no-wrap
msgid "CAPGET"
msgstr ""

#. type: TH
#: build/C/man2/capget.2:16
#, no-wrap
msgid "2020-02-09"
msgstr ""

#. type: Plain text
#: build/C/man2/capget.2:19
msgid "capget, capset - set/get capabilities of thread(s)"
msgstr ""

#. type: Plain text
#: build/C/man2/capget.2:21
msgid "B<#include E<lt>sys/capability.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man2/capget.2:23
msgid "B<int capget(cap_user_header_t >I<hdrp>B<, cap_user_data_t >I<datap>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/capget.2:25
msgid ""
"B<int capset(cap_user_header_t >I<hdrp>B<, const cap_user_data_t "
">I<datap>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/capget.2:34
msgid ""
"These two system calls are the raw kernel interface for getting and setting "
"thread capabilities.  Not only are these system calls specific to Linux, but "
"the kernel API is likely to change and use of these system calls (in "
"particular the format of the I<cap_user_*_t> types) is subject to extension "
"with each kernel revision, but old programs will keep working."
msgstr ""

#. type: Plain text
#: build/C/man2/capget.2:41
msgid ""
"The portable interfaces are B<cap_set_proc>(3)  and B<cap_get_proc>(3); if "
"possible, you should use those interfaces in applications."
msgstr ""

#. type: SS
#: build/C/man2/capget.2:41
#, no-wrap
msgid "Current details"
msgstr ""

#. type: Plain text
#: build/C/man2/capget.2:44
msgid ""
"Now that you have been warned, some current kernel details.  The structures "
"are defined as follows."
msgstr ""

#. type: Plain text
#: build/C/man2/capget.2:49
#, no-wrap
msgid ""
"#define _LINUX_CAPABILITY_VERSION_1  0x19980330\n"
"#define _LINUX_CAPABILITY_U32S_1     1\n"
msgstr ""

#.  commit e338d263a76af78fe8f38a72131188b58fceb591
#.  Added 64 bit capability support
#. type: Plain text
#: build/C/man2/capget.2:55
#, no-wrap
msgid ""
"        /* V2 added in Linux 2.6.25; deprecated */\n"
"#define _LINUX_CAPABILITY_VERSION_2  0x20071026\n"
"#define _LINUX_CAPABILITY_U32S_2     2\n"
msgstr ""

#.  commit ca05a99a54db1db5bca72eccb5866d2a86f8517f
#. type: Plain text
#: build/C/man2/capget.2:60
#, no-wrap
msgid ""
"        /* V3 added in Linux 2.6.26 */\n"
"#define _LINUX_CAPABILITY_VERSION_3  0x20080522\n"
"#define _LINUX_CAPABILITY_U32S_3     2\n"
msgstr ""

#. type: Plain text
#: build/C/man2/capget.2:65
#, no-wrap
msgid ""
"typedef struct __user_cap_header_struct {\n"
"   __u32 version;\n"
"   int pid;\n"
"} *cap_user_header_t;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/capget.2:71
#, no-wrap
msgid ""
"typedef struct __user_cap_data_struct {\n"
"   __u32 effective;\n"
"   __u32 permitted;\n"
"   __u32 inheritable;\n"
"} *cap_user_data_t;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/capget.2:90
msgid ""
"The I<effective>, I<permitted>, and I<inheritable> fields are bit masks of "
"the capabilities defined in B<capabilities>(7).  Note that the B<CAP_*> "
"values are bit indexes and need to be bit-shifted before ORing into the bit "
"fields.  To define the structures for passing to the system call, you have "
"to use the I<struct __user_cap_header_struct> and I<struct "
"__user_cap_data_struct> names because the typedefs are only pointers."
msgstr ""

#. type: Plain text
#: build/C/man2/capget.2:99
msgid ""
"Kernels prior to 2.6.25 prefer 32-bit capabilities with version "
"B<_LINUX_CAPABILITY_VERSION_1>.  Linux 2.6.25 added 64-bit capability sets, "
"with version B<_LINUX_CAPABILITY_VERSION_2>.  There was, however, an API "
"glitch, and Linux 2.6.26 added B<_LINUX_CAPABILITY_VERSION_3> to fix the "
"problem."
msgstr ""

#. type: Plain text
#: build/C/man2/capget.2:106
msgid ""
"Note that 64-bit capabilities use I<datap[0]> and I<datap[1]>, whereas "
"32-bit capabilities use only I<datap[0]>."
msgstr ""

#. type: Plain text
#: build/C/man2/capget.2:111
msgid ""
"On kernels that support file capabilities (VFS capabilities support), these "
"system calls behave slightly differently.  This support was added as an "
"option in Linux 2.6.24, and became fixed (nonoptional) in Linux 2.6.33."
msgstr ""

#. type: Plain text
#: build/C/man2/capget.2:118
msgid ""
"For B<capget>()  calls, one can probe the capabilities of any process by "
"specifying its process ID with the I<hdrp-E<gt>pid> field value."
msgstr ""

#. type: Plain text
#: build/C/man2/capget.2:122
msgid "For details on the data, see B<capabilities>(7)."
msgstr ""

#. type: SS
#: build/C/man2/capget.2:122
#, no-wrap
msgid "With VFS capabilities support"
msgstr ""

#. type: Plain text
#: build/C/man2/capget.2:135
msgid ""
"VFS capabilities employ a file extended attribute (see B<xattr>(7))  to "
"allow capabilities to be attached to executables.  This privilege model "
"obsoletes kernel support for one process asynchronously setting the "
"capabilities of another.  That is, on kernels that have VFS capabilities "
"support, when calling B<capset>(), the only permitted values for "
"I<hdrp-E<gt>pid> are 0 or, equivalently, the value returned by B<gettid>(2)."
msgstr ""

#. type: SS
#: build/C/man2/capget.2:135
#, no-wrap
msgid "Without VFS capabilities support"
msgstr ""

#. type: Plain text
#: build/C/man2/capget.2:165
msgid ""
"On older kernels that do not provide VFS capabilities support B<capset>()  "
"can, if the caller has the B<CAP_SETPCAP> capability, be used to change not "
"only the caller's own capabilities, but also the capabilities of other "
"threads.  The call operates on the capabilities of the thread specified by "
"the I<pid> field of I<hdrp> when that is nonzero, or on the capabilities of "
"the calling thread if I<pid> is 0.  If I<pid> refers to a single-threaded "
"process, then I<pid> can be specified as a traditional process ID; operating "
"on a thread of a multithreaded process requires a thread ID of the type "
"returned by B<gettid>(2).  For B<capset>(), I<pid> can also be: -1, meaning "
"perform the change on all threads except the caller and B<init>(1); or a "
"value less than -1, in which case the change is applied to all members of "
"the process group whose ID is -I<pid>."
msgstr ""

#. type: Plain text
#: build/C/man2/capget.2:184
msgid ""
"The calls fail with the error B<EINVAL>, and set the I<version> field of "
"I<hdrp> to the kernel preferred value of B<_LINUX_CAPABILITY_VERSION_?> when "
"an unsupported I<version> value is specified.  In this way, one can probe "
"what the current preferred capability revision is."
msgstr ""

#. type: Plain text
#: build/C/man2/capget.2:193
msgid ""
"Bad memory address.  I<hdrp> must not be NULL.  I<datap> may be NULL only "
"when the user is trying to determine the preferred capability version format "
"supported by the kernel."
msgstr ""

#. type: TP
#: build/C/man2/capget.2:193 build/C/man7/cpuset.7:1180 build/C/man7/cpuset.7:1189 build/C/man7/cpuset.7:1198 build/C/man7/cpuset.7:1208 build/C/man7/cpuset.7:1217 build/C/man7/cpuset.7:1224 build/C/man7/cpuset.7:1231 build/C/man2/getgroups.2:125 build/C/man2/getgroups.2:132 build/C/man2/getpriority.2:145 build/C/man2/getrlimit.2:517 build/C/man2/getrusage.2:196 build/C/man2/iopl.2:62 build/C/man2/ioprio_set.2:173 build/C/man2/seteuid.2:81 build/C/man2/setgid.2:62 build/C/man2/setpgid.2:223 build/C/man2/setresuid.2:99 build/C/man2/setreuid.2:131 build/C/man2/setuid.2:108 build/C/man2/seccomp.2:743 build/C/man2/seccomp.2:747 build/C/man2/seccomp.2:753 build/C/man2/seccomp.2:760 build/C/man2/seccomp.2:766 build/C/man2/pidfd_getfd.2:85 build/C/man2/pidfd_open.2:55 build/C/man2/pidfd_open.2:59 build/C/man2/pidfd_send_signal.2:102 build/C/man2/pidfd_send_signal.2:106 build/C/man2/pidfd_send_signal.2:110
#, no-wrap
msgid "B<EINVAL>"
msgstr ""

#. type: Plain text
#: build/C/man2/capget.2:196
msgid "One of the arguments was invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/capget.2:201
msgid ""
"An attempt was made to add a capability to the permitted set, or to set a "
"capability in the effective set that is not in the permitted set."
msgstr ""

#. type: Plain text
#: build/C/man2/capget.2:204
msgid "An attempt was made to add a capability to the inheritable set, and either:"
msgstr ""

#. type: Plain text
#: build/C/man2/capget.2:207
msgid "that capability was not in the caller's bounding set; or"
msgstr ""

#. type: Plain text
#: build/C/man2/capget.2:212
msgid ""
"the capability was not in the caller's permitted set and the caller lacked "
"the B<CAP_SETPCAP> capability in its effective set."
msgstr ""

#. type: Plain text
#: build/C/man2/capget.2:232
msgid ""
"The caller attempted to use B<capset>()  to modify the capabilities of a "
"thread other than itself, but lacked sufficient privilege.  For kernels "
"supporting VFS capabilities, this is never permitted.  For kernels lacking "
"VFS support, the B<CAP_SETPCAP> capability is required.  (A bug in kernels "
"before 2.6.11 meant that this error could also occur if a thread without "
"this capability tried to change its own capabilities by specifying the "
"I<pid> field as a nonzero value (i.e., the value returned by B<getpid>(2))  "
"instead of 0.)"
msgstr ""

#. type: TP
#: build/C/man2/capget.2:232 build/C/man7/cpuset.7:1330 build/C/man2/getpriority.2:153 build/C/man2/getrlimit.2:548 build/C/man2/getsid.2:75 build/C/man2/ioprio_set.2:190 build/C/man2/setpgid.2:238 build/C/man2/seccomp.2:796 build/C/man2/pidfd_getfd.2:107 build/C/man2/pidfd_open.2:79 build/C/man2/pidfd_send_signal.2:125
#, no-wrap
msgid "B<ESRCH>"
msgstr ""

#. type: Plain text
#: build/C/man2/capget.2:235
msgid "No such thread."
msgstr ""

#. type: Plain text
#: build/C/man2/capget.2:237 build/C/man2/ioprio_set.2:201
msgid "These system calls are Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man2/capget.2:242
msgid ""
"The portable interface to the capability querying and setting functions is "
"provided by the I<libcap> library and is available here:"
msgstr ""

#. type: Plain text
#: build/C/man2/capget.2:245
msgid ""
"E<.UR "
"http://git.kernel.org/cgit\\:/linux\\:/kernel\\:/git\\:/morgan\\:\\:/libcap.git> "
"E<.UE>"
msgstr ""

#. type: Plain text
#: build/C/man2/capget.2:249
msgid "B<clone>(2), B<gettid>(2), B<capabilities>(7)"
msgstr ""

#. type: TH
#: build/C/man7/cpuset.7:25
#, no-wrap
msgid "CPUSET"
msgstr ""

#. type: TH
#: build/C/man7/cpuset.7:25 build/C/man7/credentials.7:27 build/C/man2/getpid.2:25 build/C/man2/getrlimit.2:64 build/C/man2/seccomp.2:28 build/C/man3/posix_spawn.3:31
#, no-wrap
msgid "2020-11-01"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:28
msgid "cpuset - confine processes to processor and memory node subsets"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:35
msgid ""
"The cpuset filesystem is a pseudo-filesystem interface to the kernel cpuset "
"mechanism, which is used to control the processor placement and memory "
"placement of processes.  It is commonly mounted at I</dev/cpuset>."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:52
msgid ""
"On systems with kernels compiled with built in support for cpusets, all "
"processes are attached to a cpuset, and cpusets are always present.  If a "
"system supports cpusets, then it will have the entry B<nodev cpuset> in the "
"file I</proc/filesystems>.  By mounting the cpuset filesystem (see the "
"B<EXAMPLES> section below), the administrator can configure the cpusets on a "
"system to control the processor and memory placement of processes on that "
"system.  By default, if the cpuset configuration on a system is not modified "
"or if the cpuset filesystem is not even mounted, then the cpuset mechanism, "
"though present, has no effect on the system's behavior."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:54
msgid "A cpuset defines a list of CPUs and memory nodes."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:63
msgid ""
"The CPUs of a system include all the logical processing units on which a "
"process can execute, including, if present, multiple processor cores within "
"a package and Hyper-Threads within a processor core.  Memory nodes include "
"all distinct banks of main memory; small and SMP systems typically have just "
"one memory node that contains all the system's main memory, while NUMA "
"(non-uniform memory access) systems have multiple memory nodes."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:73
msgid ""
"Cpusets are represented as directories in a hierarchical pseudo-filesystem, "
"where the top directory in the hierarchy (I</dev/cpuset>)  represents the "
"entire system (all online CPUs and memory nodes)  and any cpuset that is the "
"child (descendant) of another parent cpuset contains a subset of that "
"parent's CPUs and memory nodes.  The directories and files representing "
"cpusets have normal filesystem permissions."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:84
msgid ""
"Every process in the system belongs to exactly one cpuset.  A process is "
"confined to run only on the CPUs in the cpuset it belongs to, and to "
"allocate memory only on the memory nodes in that cpuset.  When a process "
"B<fork>(2)s, the child process is placed in the same cpuset as its parent.  "
"With sufficient privilege, a process may be moved from one cpuset to another "
"and the allowed CPUs and memory nodes of an existing cpuset may be changed."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:92
msgid ""
"When the system begins booting, a single cpuset is defined that includes all "
"CPUs and memory nodes on the system, and all processes are in that cpuset.  "
"During the boot process, or later during normal system operation, other "
"cpusets may be created, as subdirectories of this top cpuset, under the "
"control of the system administrator, and processes may be placed in these "
"other cpusets."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:114
msgid ""
"Cpusets are integrated with the B<sched_setaffinity>(2)  scheduling affinity "
"mechanism and the B<mbind>(2)  and B<set_mempolicy>(2)  memory-placement "
"mechanisms in the kernel.  Neither of these mechanisms let a process make "
"use of a CPU or memory node that is not allowed by that process's cpuset.  "
"If changes to a process's cpuset placement conflict with these other "
"mechanisms, then cpuset placement is enforced even if it means overriding "
"these other mechanisms.  The kernel accomplishes this overriding by silently "
"restricting the CPUs and memory nodes requested by these other mechanisms to "
"those allowed by the invoking process's cpuset.  This can result in these "
"other calls returning an error, if for example, such a call ends up "
"requesting an empty set of CPUs or memory nodes, after that request is "
"restricted to the invoking process's cpuset."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:120
msgid ""
"Typically, a cpuset is used to manage the CPU and memory-node confinement "
"for a set of cooperating processes such as a batch scheduler job, and these "
"other mechanisms are used to manage the placement of individual processes or "
"memory regions within that set or job."
msgstr ""

#. type: SH
#: build/C/man7/cpuset.7:120
#, no-wrap
msgid "FILES"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:125
msgid ""
"Each directory below I</dev/cpuset> represents a cpuset and contains a fixed "
"set of pseudo-files describing the state of that cpuset."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:135
msgid ""
"New cpusets are created using the B<mkdir>(2)  system call or the "
"B<mkdir>(1)  command.  The properties of a cpuset, such as its flags, "
"allowed CPUs and memory nodes, and attached processes, are queried and "
"modified by reading or writing to the appropriate file in that cpuset's "
"directory, as listed below."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:141
msgid ""
"The pseudo-files in each cpuset directory are automatically created when the "
"cpuset is created, as a result of the B<mkdir>(2)  invocation.  It is not "
"possible to directly add or remove these pseudo-files."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:149
msgid ""
"A cpuset directory that contains no child cpuset directories, and has no "
"attached processes, can be removed using B<rmdir>(2)  or B<rmdir>(1).  It is "
"not necessary, or possible, to remove the pseudo-files inside the directory "
"before removing it."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:163
msgid ""
"The pseudo-files in each cpuset directory are small text files that may be "
"read and written using traditional shell utilities such as B<cat>(1), and "
"B<echo>(1), or from a program by using file I/O library functions or system "
"calls, such as B<open>(2), B<read>(2), B<write>(2), and B<close>(2)."
msgstr ""

#.  ====================== tasks ======================
#. type: Plain text
#: build/C/man7/cpuset.7:168
msgid ""
"The pseudo-files in a cpuset directory represent internal kernel state and "
"do not have any persistent image on disk.  Each of these per-cpuset files is "
"listed and described below."
msgstr ""

#. type: TP
#: build/C/man7/cpuset.7:168
#, no-wrap
msgid "I<tasks>"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:178
msgid ""
"List of the process IDs (PIDs) of the processes in that cpuset.  The list is "
"formatted as a series of ASCII decimal numbers, each followed by a newline.  "
"A process may be added to a cpuset (automatically removing it from the "
"cpuset that previously contained it) by writing its PID to that cpuset's "
"I<tasks> file (with or without a trailing newline)."
msgstr ""

#.  =================== notify_on_release ===================
#. type: Plain text
#: build/C/man7/cpuset.7:186
msgid ""
"B<Warning:> only one PID may be written to the I<tasks> file at a time.  If "
"a string is written that contains more than one PID, only the first one will "
"be used."
msgstr ""

#. type: TP
#: build/C/man7/cpuset.7:186
#, no-wrap
msgid "I<notify_on_release>"
msgstr ""

#.  ====================== cpus ======================
#. type: Plain text
#: build/C/man7/cpuset.7:195
msgid ""
"Flag (0 or 1).  If set (1), that cpuset will receive special handling after "
"it is released, that is, after all processes cease using it (i.e., terminate "
"or are moved to a different cpuset)  and all child cpuset directories have "
"been removed.  See the B<Notify On Release> section, below."
msgstr ""

#. type: TP
#: build/C/man7/cpuset.7:195
#, no-wrap
msgid "I<cpuset.cpus>"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:202
msgid ""
"List of the physical numbers of the CPUs on which processes in that cpuset "
"are allowed to execute.  See B<List Format> below for a description of the "
"format of I<cpus>."
msgstr ""

#.  ==================== cpu_exclusive ====================
#. type: Plain text
#: build/C/man7/cpuset.7:208
msgid ""
"The CPUs allowed to a cpuset may be changed by writing a new list to its "
"I<cpus> file."
msgstr ""

#. type: TP
#: build/C/man7/cpuset.7:208
#, no-wrap
msgid "I<cpuset.cpu_exclusive>"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:215
msgid ""
"Flag (0 or 1).  If set (1), the cpuset has exclusive use of its CPUs (no "
"sibling or cousin cpuset may overlap CPUs).  By default, this is off (0).  "
"Newly created cpusets also initially default this to off (0)."
msgstr ""

#.  ====================== mems ======================
#. type: Plain text
#: build/C/man7/cpuset.7:237
msgid ""
"Two cpusets are I<sibling> cpusets if they share the same parent cpuset in "
"the I</dev/cpuset> hierarchy.  Two cpusets are I<cousin> cpusets if neither "
"is the ancestor of the other.  Regardless of the I<cpu_exclusive> setting, "
"if one cpuset is the ancestor of another, and if both of these cpusets have "
"nonempty I<cpus>, then their I<cpus> must overlap, because the I<cpus> of "
"any cpuset are always a subset of the I<cpus> of its parent cpuset."
msgstr ""

#. type: TP
#: build/C/man7/cpuset.7:237
#, no-wrap
msgid "I<cpuset.mems>"
msgstr ""

#.  ==================== mem_exclusive ====================
#. type: Plain text
#: build/C/man7/cpuset.7:245
msgid ""
"List of memory nodes on which processes in this cpuset are allowed to "
"allocate memory.  See B<List Format> below for a description of the format "
"of I<mems>."
msgstr ""

#. type: TP
#: build/C/man7/cpuset.7:245
#, no-wrap
msgid "I<cpuset.mem_exclusive>"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:253
msgid ""
"Flag (0 or 1).  If set (1), the cpuset has exclusive use of its memory nodes "
"(no sibling or cousin may overlap).  Also if set (1), the cpuset is a "
"B<Hardwall> cpuset (see below).  By default, this is off (0).  Newly created "
"cpusets also initially default this to off (0)."
msgstr ""

#.  ==================== mem_hardwall ====================
#. type: Plain text
#: build/C/man7/cpuset.7:261
msgid ""
"Regardless of the I<mem_exclusive> setting, if one cpuset is the ancestor of "
"another, then their memory nodes must overlap, because the memory nodes of "
"any cpuset are always a subset of the memory nodes of that cpuset's parent "
"cpuset."
msgstr ""

#. type: TP
#: build/C/man7/cpuset.7:261
#, no-wrap
msgid "I<cpuset.mem_hardwall> (since Linux 2.6.26)"
msgstr ""

#.  ==================== memory_migrate ====================
#. type: Plain text
#: build/C/man7/cpuset.7:272
msgid ""
"Flag (0 or 1).  If set (1), the cpuset is a B<Hardwall> cpuset (see below).  "
"Unlike B<mem_exclusive>, there is no constraint on whether cpusets marked "
"B<mem_hardwall> may have overlapping memory nodes with sibling or cousin "
"cpusets.  By default, this is off (0).  Newly created cpusets also initially "
"default this to off (0)."
msgstr ""

#. type: TP
#: build/C/man7/cpuset.7:272
#, no-wrap
msgid "I<cpuset.memory_migrate> (since Linux 2.6.16)"
msgstr ""

#.  ==================== memory_pressure ====================
#. type: Plain text
#: build/C/man7/cpuset.7:279
msgid ""
"Flag (0 or 1).  If set (1), then memory migration is enabled.  By default, "
"this is off (0).  See the B<Memory Migration> section, below."
msgstr ""

#. type: TP
#: build/C/man7/cpuset.7:279
#, no-wrap
msgid "I<cpuset.memory_pressure> (since Linux 2.6.16)"
msgstr ""

#.  ================= memory_pressure_enabled =================
#. type: Plain text
#: build/C/man7/cpuset.7:292
msgid ""
"A measure of how much memory pressure the processes in this cpuset are "
"causing.  See the B<Memory Pressure> section, below.  Unless "
"I<memory_pressure_enabled> is enabled, always has value zero (0).  This file "
"is read-only.  See the B<WARNINGS> section, below."
msgstr ""

#. type: TP
#: build/C/man7/cpuset.7:292
#, no-wrap
msgid "I<cpuset.memory_pressure_enabled> (since Linux 2.6.16)"
msgstr ""

#.  ================== memory_spread_page ==================
#. type: Plain text
#: build/C/man7/cpuset.7:304
msgid ""
"Flag (0 or 1).  This file is present only in the root cpuset, normally "
"I</dev/cpuset>.  If set (1), the I<memory_pressure> calculations are enabled "
"for all cpusets in the system.  By default, this is off (0).  See the "
"B<Memory Pressure> section, below."
msgstr ""

#. type: TP
#: build/C/man7/cpuset.7:304
#, no-wrap
msgid "I<cpuset.memory_spread_page> (since Linux 2.6.17)"
msgstr ""

#.  ================== memory_spread_slab ==================
#. type: Plain text
#: build/C/man7/cpuset.7:314
msgid ""
"Flag (0 or 1).  If set (1), pages in the kernel page cache (filesystem "
"buffers) are uniformly spread across the cpuset.  By default, this is off "
"(0) in the top cpuset, and inherited from the parent cpuset in newly created "
"cpusets.  See the B<Memory Spread> section, below."
msgstr ""

#. type: TP
#: build/C/man7/cpuset.7:314
#, no-wrap
msgid "I<cpuset.memory_spread_slab> (since Linux 2.6.17)"
msgstr ""

#.  ================== sched_load_balance ==================
#. type: Plain text
#: build/C/man7/cpuset.7:325
msgid ""
"Flag (0 or 1).  If set (1), the kernel slab caches for file I/O (directory "
"and inode structures) are uniformly spread across the cpuset.  By default, "
"is off (0) in the top cpuset, and inherited from the parent cpuset in newly "
"created cpusets.  See the B<Memory Spread> section, below."
msgstr ""

#. type: TP
#: build/C/man7/cpuset.7:325
#, no-wrap
msgid "I<cpuset.sched_load_balance> (since Linux 2.6.24)"
msgstr ""

#.  ================== sched_relax_domain_level ==================
#. type: Plain text
#: build/C/man7/cpuset.7:339
msgid ""
"Flag (0 or 1).  If set (1, the default) the kernel will automatically load "
"balance processes in that cpuset over the allowed CPUs in that cpuset.  If "
"cleared (0) the kernel will avoid load balancing processes in this cpuset, "
"I<unless> some other cpuset with overlapping CPUs has its "
"I<sched_load_balance> flag set.  See B<Scheduler Load Balancing>, below, for "
"further details."
msgstr ""

#. type: TP
#: build/C/man7/cpuset.7:339
#, no-wrap
msgid "I<cpuset.sched_relax_domain_level> (since Linux 2.6.26)"
msgstr ""

#.  ================== proc cpuset ==================
#. type: Plain text
#: build/C/man7/cpuset.7:359
msgid ""
"Integer, between -1 and a small positive value.  The "
"I<sched_relax_domain_level> controls the width of the range of CPUs over "
"which the kernel scheduler performs immediate rebalancing of runnable tasks "
"across CPUs.  If I<sched_load_balance> is disabled, then the setting of "
"I<sched_relax_domain_level> does not matter, as no such load balancing is "
"done.  If I<sched_load_balance> is enabled, then the higher the value of the "
"I<sched_relax_domain_level>, the wider the range of CPUs over which "
"immediate load balancing is attempted.  See B<Scheduler Relax Domain Level>, "
"below, for further details."
msgstr ""

#.  ================== proc status ==================
#. type: Plain text
#: build/C/man7/cpuset.7:367
msgid ""
"In addition to the above pseudo-files in each directory below "
"I</dev/cpuset>, each process has a pseudo-file, "
"I</proc/E<lt>pidE<gt>/cpuset>, that displays the path of the process's "
"cpuset directory relative to the root of the cpuset filesystem."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:378
msgid ""
"Also the I</proc/E<lt>pidE<gt>/status> file for each process has four added "
"lines, displaying the process's I<Cpus_allowed> (on which CPUs it may be "
"scheduled) and I<Mems_allowed> (on which memory nodes it may obtain memory), "
"in the two formats B<Mask Format> and B<List Format> (see below)  as shown "
"in the following example:"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:385
#, no-wrap
msgid ""
"Cpus_allowed:   ffffffff,ffffffff,ffffffff,ffffffff\n"
"Cpus_allowed_list:     0-127\n"
"Mems_allowed:   ffffffff,ffffffff\n"
"Mems_allowed_list:     0-63\n"
msgstr ""

#.  ================== EXTENDED CAPABILITIES ==================
#. type: Plain text
#: build/C/man7/cpuset.7:391
msgid ""
"The \"allowed\" fields were added in Linux 2.6.24; the \"allowed_list\" "
"fields were added in Linux 2.6.26."
msgstr ""

#. type: SH
#: build/C/man7/cpuset.7:391
#, no-wrap
msgid "EXTENDED CAPABILITIES"
msgstr ""

#.  ================== Exclusive Cpusets ==================
#. type: Plain text
#: build/C/man7/cpuset.7:399
msgid ""
"In addition to controlling which I<cpus> and I<mems> a process is allowed to "
"use, cpusets provide the following extended capabilities."
msgstr ""

#. type: SS
#: build/C/man7/cpuset.7:399
#, no-wrap
msgid "Exclusive cpusets"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:406
msgid ""
"If a cpuset is marked I<cpu_exclusive> or I<mem_exclusive>, no other cpuset, "
"other than a direct ancestor or descendant, may share any of the same CPUs "
"or memory nodes."
msgstr ""

#.  ================== Hardwall ==================
#. type: Plain text
#: build/C/man7/cpuset.7:432
msgid ""
"A cpuset that is I<mem_exclusive> restricts kernel allocations for buffer "
"cache pages and other internal kernel data pages commonly shared by the "
"kernel across multiple users.  All cpusets, whether I<mem_exclusive> or not, "
"restrict allocations of memory for user space.  This enables configuring a "
"system so that several independent jobs can share common kernel data, while "
"isolating each job's user allocation in its own cpuset.  To do this, "
"construct a large I<mem_exclusive> cpuset to hold all the jobs, and "
"construct child, non-I<mem_exclusive> cpusets for each individual job.  Only "
"a small amount of kernel memory, such as requests from interrupt handlers, "
"is allowed to be placed on memory nodes outside even a I<mem_exclusive> "
"cpuset."
msgstr ""

#. type: SS
#: build/C/man7/cpuset.7:432
#, no-wrap
msgid "Hardwall"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:447
msgid ""
"A cpuset that has I<mem_exclusive> or I<mem_hardwall> set is a I<hardwall> "
"cpuset.  A I<hardwall> cpuset restricts kernel allocations for page, buffer, "
"and other data commonly shared by the kernel across multiple users.  All "
"cpusets, whether I<hardwall> or not, restrict allocations of memory for user "
"space."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:458
msgid ""
"This enables configuring a system so that several independent jobs can share "
"common kernel data, such as filesystem pages, while isolating each job's "
"user allocation in its own cpuset.  To do this, construct a large "
"I<hardwall> cpuset to hold all the jobs, and construct child cpusets for "
"each individual job which are not I<hardwall> cpusets."
msgstr ""

#.  ================== Notify On Release ==================
#. type: Plain text
#: build/C/man7/cpuset.7:464
msgid ""
"Only a small amount of kernel memory, such as requests from interrupt "
"handlers, is allowed to be taken outside even a I<hardwall> cpuset."
msgstr ""

#. type: SS
#: build/C/man7/cpuset.7:464
#, no-wrap
msgid "Notify on release"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:476
msgid ""
"If the I<notify_on_release> flag is enabled (1) in a cpuset, then whenever "
"the last process in the cpuset leaves (exits or attaches to some other "
"cpuset)  and the last child cpuset of that cpuset is removed, the kernel "
"will run the command I</sbin/cpuset_release_agent>, supplying the pathname "
"(relative to the mount point of the cpuset filesystem) of the abandoned "
"cpuset.  This enables automatic removal of abandoned cpusets."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:484
msgid ""
"The default value of I<notify_on_release> in the root cpuset at system boot "
"is disabled (0).  The default value of other cpusets at creation is the "
"current value of their parent's I<notify_on_release> setting."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:492
msgid ""
"The command I</sbin/cpuset_release_agent> is invoked, with the name "
"(I</dev/cpuset> relative path)  of the to-be-released cpuset in I<argv[1]>."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:496
msgid ""
"The usual contents of the command I</sbin/cpuset_release_agent> is simply "
"the shell script:"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:501
#, no-wrap
msgid ""
"#!/bin/sh\n"
"rmdir /dev/cpuset/$1\n"
msgstr ""

#.  ================== Memory Pressure ==================
#. type: Plain text
#: build/C/man7/cpuset.7:509
msgid ""
"As with other flag values below, this flag can be changed by writing an "
"ASCII number 0 or 1 (with optional trailing newline)  into the file, to "
"clear or set the flag, respectively."
msgstr ""

#. type: SS
#: build/C/man7/cpuset.7:509
#, no-wrap
msgid "Memory pressure"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:515
msgid ""
"The I<memory_pressure> of a cpuset provides a simple per-cpuset running "
"average of the rate that the processes in a cpuset are attempting to free up "
"in-use memory on the nodes of the cpuset to satisfy additional memory "
"requests."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:519
msgid ""
"This enables batch managers that are monitoring jobs running in dedicated "
"cpusets to efficiently detect what level of memory pressure that job is "
"causing."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:526
msgid ""
"This is useful both on tightly managed systems running a wide mix of "
"submitted jobs, which may choose to terminate or reprioritize jobs that are "
"trying to use more memory than allowed on the nodes assigned them, and with "
"tightly coupled, long-running, massively parallel scientific computing jobs "
"that will dramatically fail to meet required performance goals if they start "
"to use more memory than allowed to them."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:531
msgid ""
"This mechanism provides a very economical way for the batch manager to "
"monitor a cpuset for signs of memory pressure.  It's up to the batch manager "
"or other user code to decide what action to take if it detects signs of "
"memory pressure."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:538
msgid ""
"Unless memory pressure calculation is enabled by setting the pseudo-file "
"I</dev/cpuset/cpuset.memory_pressure_enabled>, it is not computed for any "
"cpuset, and reads from any I<memory_pressure> always return zero, as "
"represented by the ASCII string \"0\\en\".  See the B<WARNINGS> section, "
"below."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:540
msgid "A per-cpuset, running average is employed for the following reasons:"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:545
msgid ""
"Because this meter is per-cpuset rather than per-process or per virtual "
"memory region, the system load imposed by a batch scheduler monitoring this "
"metric is sharply reduced on large systems, because a scan of the tasklist "
"can be avoided on each set of queries."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:550
msgid ""
"Because this meter is a running average rather than an accumulating counter, "
"a batch scheduler can detect memory pressure with a single read, instead of "
"having to read and accumulate results for a period of time."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:556
msgid ""
"Because this meter is per-cpuset rather than per-process, the batch "
"scheduler can obtain the key information\\(emmemory pressure in a "
"cpuset\\(emwith a single read, rather than having to query and accumulate "
"results over all the (dynamically changing)  set of processes in the cpuset."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:564
msgid ""
"The I<memory_pressure> of a cpuset is calculated using a per-cpuset simple "
"digital filter that is kept within the kernel.  For each cpuset, this filter "
"tracks the recent rate at which processes attached to that cpuset enter the "
"kernel direct reclaim code."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:573
msgid ""
"The kernel direct reclaim code is entered whenever a process has to satisfy "
"a memory page request by first finding some other page to repurpose, due to "
"lack of any readily available already free pages.  Dirty filesystem pages "
"are repurposed by first writing them to disk.  Unmodified filesystem buffer "
"pages are repurposed by simply dropping them, though if that page is needed "
"again, it will have to be reread from disk."
msgstr ""

#.  ================== Memory Spread ==================
#. type: Plain text
#: build/C/man7/cpuset.7:581
msgid ""
"The I<cpuset.memory_pressure> file provides an integer number representing "
"the recent (half-life of 10 seconds) rate of entries to the direct reclaim "
"code caused by any process in the cpuset, in units of reclaims attempted per "
"second, times 1000."
msgstr ""

#. type: SS
#: build/C/man7/cpuset.7:581
#, no-wrap
msgid "Memory spread"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:589
msgid ""
"There are two Boolean flag files per cpuset that control where the kernel "
"allocates pages for the filesystem buffers and related in-kernel data "
"structures.  They are called I<cpuset.memory_spread_page> and "
"I<cpuset.memory_spread_slab>."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:596
msgid ""
"If the per-cpuset Boolean flag file I<cpuset.memory_spread_page> is set, "
"then the kernel will spread the filesystem buffers (page cache) evenly over "
"all the nodes that the faulting process is allowed to use, instead of "
"preferring to put those pages on the node where the process is running."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:604
msgid ""
"If the per-cpuset Boolean flag file I<cpuset.memory_spread_slab> is set, "
"then the kernel will spread some filesystem-related slab caches, such as "
"those for inodes and directory entries, evenly over all the nodes that the "
"faulting process is allowed to use, instead of preferring to put those pages "
"on the node where the process is running."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:609
msgid ""
"The setting of these flags does not affect the data segment (see B<brk>(2))  "
"or stack segment pages of a process."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:617
msgid ""
"By default, both kinds of memory spreading are off and the kernel prefers to "
"allocate memory pages on the node local to where the requesting process is "
"running.  If that node is not allowed by the process's NUMA memory policy or "
"cpuset configuration or if there are insufficient free memory pages on that "
"node, then the kernel looks for the nearest node that is allowed and has "
"sufficient free memory."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:620
msgid ""
"When new cpusets are created, they inherit the memory spread settings of "
"their parent."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:635
msgid ""
"Setting memory spreading causes allocations for the affected page or slab "
"caches to ignore the process's NUMA memory policy and be spread instead.  "
"However, the effect of these changes in memory placement caused by "
"cpuset-specified memory spreading is hidden from the B<mbind>(2)  or "
"B<set_mempolicy>(2)  calls.  These two NUMA memory policy calls always "
"appear to behave as if no cpuset-specified memory spreading is in effect, "
"even if it is.  If cpuset memory spreading is subsequently turned off, the "
"NUMA memory policy most recently specified by these calls is automatically "
"reapplied."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:644
msgid ""
"Both I<cpuset.memory_spread_page> and I<cpuset.memory_spread_slab> are "
"Boolean flag files.  By default, they contain \"0\", meaning that the "
"feature is off for that cpuset.  If a \"1\" is written to that file, that "
"turns the named feature on."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:647
msgid ""
"Cpuset-specified memory spreading behaves similarly to what is known (in "
"other contexts) as round-robin or interleave memory placement."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:650
msgid ""
"Cpuset-specified memory spreading can provide substantial performance "
"improvements for jobs that:"
msgstr ""

#. type: IP
#: build/C/man7/cpuset.7:650 build/C/man7/cgroups.7:1804
#, no-wrap
msgid "a)"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:654
msgid ""
"need to place thread-local data on memory nodes close to the CPUs which are "
"running the threads that most frequently access that data; but also"
msgstr ""

#. type: IP
#: build/C/man7/cpuset.7:654 build/C/man7/cgroups.7:1806
#, no-wrap
msgid "b)"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:657
msgid ""
"need to access large filesystem data sets that must to be spread across the "
"several nodes in the job's cpuset in order to fit."
msgstr ""

#.  ================== Memory Migration ==================
#. type: Plain text
#: build/C/man7/cpuset.7:664
msgid ""
"Without this policy, the memory allocation across the nodes in the job's "
"cpuset can become very uneven, especially for jobs that might have just a "
"single thread initializing or reading in the data set."
msgstr ""

#. type: SS
#: build/C/man7/cpuset.7:664
#, no-wrap
msgid "Memory migration"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:673
msgid ""
"Normally, under the default setting (disabled) of I<cpuset.memory_migrate>, "
"once a page is allocated (given a physical page of main memory), then that "
"page stays on whatever node it was allocated, so long as it remains "
"allocated, even if the cpuset's memory-placement policy I<mems> subsequently "
"changes."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:679
msgid ""
"When memory migration is enabled in a cpuset, if the I<mems> setting of the "
"cpuset is changed, then any memory page in use by any process in the cpuset "
"that is on a memory node that is no longer allowed will be migrated to a "
"memory node that is allowed."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:685
msgid ""
"Furthermore, if a process is moved into a cpuset with I<memory_migrate> "
"enabled, any memory pages it uses that were on memory nodes allowed in its "
"previous cpuset, but which are not allowed in its new cpuset, will be "
"migrated to a memory node allowed in the new cpuset."
msgstr ""

#.  ================== Scheduler Load Balancing ==================
#. type: Plain text
#: build/C/man7/cpuset.7:693
msgid ""
"The relative placement of a migrated page within the cpuset is preserved "
"during these migration operations if possible.  For example, if the page was "
"on the second valid node of the prior cpuset, then the page will be placed "
"on the second valid node of the new cpuset, if possible."
msgstr ""

#. type: SS
#: build/C/man7/cpuset.7:693
#, no-wrap
msgid "Scheduler load balancing"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:700
msgid ""
"The kernel scheduler automatically load balances processes.  If one CPU is "
"underutilized, the kernel will look for processes on other more overloaded "
"CPUs and move those processes to the underutilized CPU, within the "
"constraints of such placement mechanisms as cpusets and "
"B<sched_setaffinity>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:713
msgid ""
"The algorithmic cost of load balancing and its impact on key shared kernel "
"data structures such as the process list increases more than linearly with "
"the number of CPUs being balanced.  For example, it costs more to load "
"balance across one large set of CPUs than it does to balance across two "
"smaller sets of CPUs, each of half the size of the larger set.  (The precise "
"relationship between the number of CPUs being balanced and the cost of load "
"balancing depends on implementation details of the kernel process scheduler, "
"which is subject to change over time, as improved kernel scheduler "
"algorithms are implemented.)"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:719
msgid ""
"The per-cpuset flag I<sched_load_balance> provides a mechanism to suppress "
"this automatic scheduler load balancing in cases where it is not needed and "
"suppressing it would have worthwhile performance benefits."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:723
msgid ""
"By default, load balancing is done across all CPUs, except those marked "
"isolated using the kernel boot time \"isolcpus=\" argument.  (See "
"B<Scheduler Relax Domain Level>, below, to change this default.)"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:726
msgid ""
"This default load balancing across all CPUs is not well suited to the "
"following two situations:"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:730
msgid ""
"On large systems, load balancing across many CPUs is expensive.  If the "
"system is managed using cpusets to place independent jobs on separate sets "
"of CPUs, full load balancing is unnecessary."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:734
msgid ""
"Systems supporting real-time on some CPUs need to minimize system overhead "
"on those CPUs, including avoiding process load balancing if that is not "
"needed."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:744
msgid ""
"When the per-cpuset flag I<sched_load_balance> is enabled (the default "
"setting), it requests load balancing across all the CPUs in that cpuset's "
"allowed CPUs, ensuring that load balancing can move a process (not otherwise "
"pinned, as by B<sched_setaffinity>(2))  from any CPU in that cpuset to any "
"other."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:753
msgid ""
"When the per-cpuset flag I<sched_load_balance> is disabled, then the "
"scheduler will avoid load balancing across the CPUs in that cpuset, "
"I<except> in so far as is necessary because some overlapping cpuset has "
"I<sched_load_balance> enabled."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:761
msgid ""
"So, for example, if the top cpuset has the flag I<sched_load_balance> "
"enabled, then the scheduler will load balance across all CPUs, and the "
"setting of the I<sched_load_balance> flag in other cpusets has no effect, as "
"we're already fully load balancing."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:766
msgid ""
"Therefore in the above two situations, the flag I<sched_load_balance> should "
"be disabled in the top cpuset, and only some of the smaller, child cpusets "
"would have this flag enabled."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:774
msgid ""
"When doing this, you don't usually want to leave any unpinned processes in "
"the top cpuset that might use nontrivial amounts of CPU, as such processes "
"may be artificially constrained to some subset of CPUs, depending on the "
"particulars of this flag setting in descendant cpusets.  Even if such a "
"process could use spare CPU cycles in some other CPUs, the kernel scheduler "
"might not consider the possibility of load balancing that process to the "
"underused CPU."
msgstr ""

#.  ================== Scheduler Relax Domain Level ==================
#. type: Plain text
#: build/C/man7/cpuset.7:780
msgid ""
"Of course, processes pinned to a particular CPU can be left in a cpuset that "
"disables I<sched_load_balance> as those processes aren't going anywhere else "
"anyway."
msgstr ""

#. type: SS
#: build/C/man7/cpuset.7:780
#, no-wrap
msgid "Scheduler relax domain level"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:801
msgid ""
"The kernel scheduler performs immediate load balancing whenever a CPU "
"becomes free or another task becomes runnable.  This load balancing works to "
"ensure that as many CPUs as possible are usefully employed running tasks.  "
"The kernel also performs periodic load balancing off the software clock "
"described in B<time>(7).  The setting of I<sched_relax_domain_level> applies "
"only to immediate load balancing.  Regardless of the "
"I<sched_relax_domain_level> setting, periodic load balancing is attempted "
"over all CPUs (unless disabled by turning off I<sched_load_balance>.)  In "
"any case, of course, tasks will be scheduled to run only on CPUs allowed by "
"their cpuset, as modified by B<sched_setaffinity>(2)  system calls."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:809
msgid ""
"On small systems, such as those with just a few CPUs, immediate load "
"balancing is useful to improve system interactivity and to minimize wasteful "
"idle CPU cycles.  But on large systems, attempting immediate load balancing "
"across a large number of CPUs can be more costly than it is worth, depending "
"on the particular performance characteristics of the job mix and the "
"hardware."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:817
msgid ""
"The exact meaning of the small integer values of I<sched_relax_domain_level> "
"will depend on internal implementation details of the kernel scheduler code "
"and on the non-uniform architecture of the hardware.  Both of these will "
"evolve over time and vary by system architecture and kernel version."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:822
msgid ""
"As of this writing, when this capability was introduced in Linux 2.6.26, on "
"certain popular architectures, the positive values of "
"I<sched_relax_domain_level> have the following meanings."
msgstr ""

#. type: IP
#: build/C/man7/cpuset.7:824
#, no-wrap
msgid "B<(1)>"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:827
msgid ""
"Perform immediate load balancing across Hyper-Thread siblings on the same "
"core."
msgstr ""

#. type: IP
#: build/C/man7/cpuset.7:827
#, no-wrap
msgid "B<(2)>"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:829
msgid "Perform immediate load balancing across other cores in the same package."
msgstr ""

#. type: IP
#: build/C/man7/cpuset.7:829
#, no-wrap
msgid "B<(3)>"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:832
msgid ""
"Perform immediate load balancing across other CPUs on the same node or "
"blade."
msgstr ""

#. type: IP
#: build/C/man7/cpuset.7:832
#, no-wrap
msgid "B<(4)>"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:835
msgid ""
"Perform immediate load balancing across over several (implementation detail) "
"nodes [On NUMA systems]."
msgstr ""

#. type: IP
#: build/C/man7/cpuset.7:835
#, no-wrap
msgid "B<(5)>"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:838
msgid ""
"Perform immediate load balancing across over all CPUs in system [On NUMA "
"systems]."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:847
msgid ""
"The I<sched_relax_domain_level> value of zero (0) always means don't perform "
"immediate load balancing, hence that load balancing is done only "
"periodically, not immediately when a CPU becomes available or another task "
"becomes runnable."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:855
msgid ""
"The I<sched_relax_domain_level> value of minus one (-1)  always means use "
"the system default value.  The system default value can vary by architecture "
"and kernel version.  This system default value can be changed by kernel "
"boot-time \"relax_domain_level=\" argument."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:863
msgid ""
"In the case of multiple overlapping cpusets which have conflicting "
"I<sched_relax_domain_level> values, then the highest such value applies to "
"all CPUs in any of the overlapping cpusets.  In such cases, the value "
"B<minus one (-1)> is the lowest value, overridden by any other value, and "
"the value B<zero (0)> is the next lowest value."
msgstr ""

#. type: SH
#: build/C/man7/cpuset.7:863
#, no-wrap
msgid "FORMATS"
msgstr ""

#.  ================== Mask Format ==================
#. type: Plain text
#: build/C/man7/cpuset.7:867
msgid "The following formats are used to represent sets of CPUs and memory nodes."
msgstr ""

#. type: SS
#: build/C/man7/cpuset.7:867
#, no-wrap
msgid "Mask format"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:872
msgid ""
"The B<Mask Format> is used to represent CPU and memory-node bit masks in the "
"I</proc/E<lt>pidE<gt>/status> file."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:880
msgid ""
"This format displays each 32-bit word in hexadecimal (using ASCII characters "
"\"0\" - \"9\" and \"a\" - \"f\"); words are filled with leading zeros, if "
"required.  For masks longer than one word, a comma separator is used between "
"words.  Words are displayed in big-endian order, which has the most "
"significant bit first.  The hex digits within a word are also in big-endian "
"order."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:883
msgid ""
"The number of 32-bit words displayed is the minimum number needed to display "
"all bits of the bit mask, based on the size of the bit mask."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:885
msgid "Examples of the B<Mask Format>:"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:893
#, no-wrap
msgid ""
"00000001                        # just bit 0 set\n"
"40000000,00000000,00000000      # just bit 94 set\n"
"00000001,00000000,00000000      # just bit 64 set\n"
"000000ff,00000000               # bits 32-39 set\n"
"00000000,000e3862               # 1,5,6,11-13,17-19 set\n"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:897
msgid "A mask with bits 0, 1, 2, 4, 8, 16, 32, and 64 set displays as:"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:901
#, no-wrap
msgid "00000001,00000001,00010117\n"
msgstr ""

#.  ================== List Format ==================
#. type: Plain text
#: build/C/man7/cpuset.7:908
msgid ""
"The first \"1\" is for bit 64, the second for bit 32, the third for bit 16, "
"the fourth for bit 8, the fifth for bit 4, and the \"7\" is for bits 2, 1, "
"and 0."
msgstr ""

#. type: SS
#: build/C/man7/cpuset.7:908
#, no-wrap
msgid "List format"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:915
msgid ""
"The B<List Format> for I<cpus> and I<mems> is a comma-separated list of CPU "
"or memory-node numbers and ranges of numbers, in ASCII decimal."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:917
msgid "Examples of the B<List Format>:"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:922
#, no-wrap
msgid ""
"0-4,9           # bits 0, 1, 2, 3, 4, and 9 set\n"
"0-2,7,12-14     # bits 0, 1, 2, 7, 12, 13, and 14 set\n"
msgstr ""

#.  ================== RULES ==================
#. type: SH
#: build/C/man7/cpuset.7:925
#, no-wrap
msgid "RULES"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:927
msgid "The following rules apply to each cpuset:"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:930
msgid ""
"Its CPUs and memory nodes must be a (possibly equal)  subset of its "
"parent's."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:934
msgid "It can be marked I<cpu_exclusive> only if its parent is."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:938
msgid "It can be marked I<mem_exclusive> only if its parent is."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:942
msgid "If it is I<cpu_exclusive>, its CPUs may not overlap any sibling."
msgstr ""

#.  ================== PERMISSIONS ==================
#. type: Plain text
#: build/C/man7/cpuset.7:947
msgid "If it is I<memory_exclusive>, its memory nodes may not overlap any sibling."
msgstr ""

#. type: SH
#: build/C/man7/cpuset.7:947
#, no-wrap
msgid "PERMISSIONS"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:952
msgid ""
"The permissions of a cpuset are determined by the permissions of the "
"directories and pseudo-files in the cpuset filesystem, normally mounted at "
"I</dev/cpuset>."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:961
msgid ""
"For instance, a process can put itself in some other cpuset (than its "
"current one) if it can write the I<tasks> file for that cpuset.  This "
"requires execute permission on the encompassing directories and write "
"permission on the I<tasks> file."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:968
msgid ""
"An additional constraint is applied to requests to place some other process "
"in a cpuset.  One process may not attach another to a cpuset unless it would "
"have permission to send that process a signal (see B<kill>(2))."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:979
msgid ""
"A process may create a child cpuset if it can access and write the parent "
"cpuset directory.  It can modify the CPUs or memory nodes in a cpuset if it "
"can access that cpuset's directory (execute permissions on the each of the "
"parent directories) and write the corresponding I<cpus> or I<mems> file."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1000
msgid ""
"There is one minor difference between the manner in which these permissions "
"are evaluated and the manner in which normal filesystem operation "
"permissions are evaluated.  The kernel interprets relative pathnames "
"starting at a process's current working directory.  Even if one is operating "
"on a cpuset file, relative pathnames are interpreted relative to the "
"process's current working directory, not relative to the process's current "
"cpuset.  The only ways that cpuset paths relative to a process's current "
"cpuset can be used are if either the process's current working directory is "
"its cpuset (it first did a B<cd> or B<chdir>(2)  to its cpuset directory "
"beneath I</dev/cpuset>, which is a bit unusual)  or if some user code "
"converts the relative cpuset path to a full filesystem path."
msgstr ""

#.  ================== WARNINGS ==================
#. type: Plain text
#: build/C/man7/cpuset.7:1015
msgid ""
"In theory, this means that user code should specify cpusets using absolute "
"pathnames, which requires knowing the mount point of the cpuset filesystem "
"(usually, but not necessarily, I</dev/cpuset>).  In practice, all user level "
"code that this author is aware of simply assumes that if the cpuset "
"filesystem is mounted, then it is mounted at I</dev/cpuset>.  Furthermore, "
"it is common practice for carefully written user code to verify the presence "
"of the pseudo-file I</dev/cpuset/tasks> in order to verify that the cpuset "
"pseudo-filesystem is currently mounted."
msgstr ""

#. type: SH
#: build/C/man7/cpuset.7:1015
#, no-wrap
msgid "WARNINGS"
msgstr ""

#. type: SS
#: build/C/man7/cpuset.7:1016
#, no-wrap
msgid "Enabling memory_pressure"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1025
msgid ""
"By default, the per-cpuset file I<cpuset.memory_pressure> always contains "
"zero (0).  Unless this feature is enabled by writing \"1\" to the "
"pseudo-file I</dev/cpuset/cpuset.memory_pressure_enabled>, the kernel does "
"not compute per-cpuset I<memory_pressure>."
msgstr ""

#. type: SS
#: build/C/man7/cpuset.7:1025
#, no-wrap
msgid "Using the echo command"
msgstr ""

#.  Gack!  csh(1)'s echo does this
#. type: Plain text
#: build/C/man7/cpuset.7:1036
msgid ""
"When using the B<echo> command at the shell prompt to change the values of "
"cpuset files, beware that the built-in B<echo> command in some shells does "
"not display an error message if the B<write>(2)  system call fails.  For "
"example, if the command:"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1040
#, no-wrap
msgid "echo 19 E<gt> cpuset.mems\n"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1053
msgid ""
"failed because memory node 19 was not allowed (perhaps the current system "
"does not have a memory node 19), then the B<echo> command might not display "
"any error.  It is better to use the B</bin/echo> external command to change "
"cpuset file settings, as this command will display B<write>(2)  errors, as "
"in the example:"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1058
#, no-wrap
msgid ""
"/bin/echo 19 E<gt> cpuset.mems\n"
"/bin/echo: write error: Invalid argument\n"
msgstr ""

#.  ================== EXCEPTIONS ==================
#. type: SH
#: build/C/man7/cpuset.7:1061
#, no-wrap
msgid "EXCEPTIONS"
msgstr ""

#. type: SS
#: build/C/man7/cpuset.7:1062
#, no-wrap
msgid "Memory placement"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1065
msgid ""
"Not all allocations of system memory are constrained by cpusets, for the "
"following reasons."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1080
msgid ""
"If hot-plug functionality is used to remove all the CPUs that are currently "
"assigned to a cpuset, then the kernel will automatically update the "
"I<cpus_allowed> of all processes attached to CPUs in that cpuset to allow "
"all CPUs.  When memory hot-plug functionality for removing memory nodes is "
"available, a similar exception is expected to apply there as well.  In "
"general, the kernel prefers to violate cpuset placement, rather than "
"starving a process that has had all its allowed CPUs or memory nodes taken "
"offline.  User code should reconfigure cpusets to refer only to online CPUs "
"and memory nodes when using hot-plug to add or remove such resources."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1088
msgid ""
"A few kernel-critical, internal memory-allocation requests, marked "
"GFP_ATOMIC, must be satisfied immediately.  The kernel may drop some request "
"or malfunction if one of these allocations fail.  If such a request cannot "
"be satisfied within the current process's cpuset, then we relax the cpuset, "
"and look for memory anywhere we can find it.  It's better to violate the "
"cpuset than stress the kernel."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1092
msgid ""
"Allocations of memory requested by kernel drivers while processing an "
"interrupt lack any relevant process context, and are not confined by "
"cpusets."
msgstr ""

#. type: SS
#: build/C/man7/cpuset.7:1092
#, no-wrap
msgid "Renaming cpusets"
msgstr ""

#.  ================== ERRORS ==================
#. type: Plain text
#: build/C/man7/cpuset.7:1100
msgid ""
"You can use the B<rename>(2)  system call to rename cpusets.  Only simple "
"renaming is supported; that is, changing the name of a cpuset directory is "
"permitted, but moving a directory into a different directory is not "
"permitted."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1104
msgid ""
"The Linux kernel implementation of cpusets sets I<errno> to specify the "
"reason for a failed system call affecting cpusets."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1109
msgid ""
"The possible I<errno> settings and their meaning when set on a failed cpuset "
"call are as listed below."
msgstr ""

#. type: TP
#: build/C/man7/cpuset.7:1109
#, no-wrap
msgid "B<E2BIG>"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1116
msgid ""
"Attempted a B<write>(2)  on a special cpuset file with a length larger than "
"some kernel-determined upper limit on the length of such writes."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1123
msgid ""
"Attempted to B<write>(2)  the process ID (PID) of a process to a cpuset "
"I<tasks> file when one lacks permission to move that process."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1129
msgid ""
"Attempted to add, using B<write>(2), a CPU or memory node to a cpuset, when "
"that CPU or memory node was not already in its parent."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1137
msgid ""
"Attempted to set, using B<write>(2), I<cpuset.cpu_exclusive> or "
"I<cpuset.mem_exclusive> on a cpuset whose parent lacks the same setting."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1144
msgid "Attempted to B<write>(2)  a I<cpuset.memory_pressure> file."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1147
msgid "Attempted to create a file in a cpuset directory."
msgstr ""

#. type: TP
#: build/C/man7/cpuset.7:1147 build/C/man7/cpuset.7:1152 build/C/man7/cpuset.7:1157 build/C/man7/cgroups.7:1749
#, no-wrap
msgid "B<EBUSY>"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1152
msgid "Attempted to remove, using B<rmdir>(2), a cpuset with attached processes."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1157
msgid "Attempted to remove, using B<rmdir>(2), a cpuset with child cpusets."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1162
msgid ""
"Attempted to remove a CPU or memory node from a cpuset that is also in a "
"child of that cpuset."
msgstr ""

#. type: TP
#: build/C/man7/cpuset.7:1162 build/C/man7/cpuset.7:1167
#, no-wrap
msgid "B<EEXIST>"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1167
msgid "Attempted to create, using B<mkdir>(2), a cpuset that already exists."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1172
msgid "Attempted to B<rename>(2)  a cpuset to a name that already exists."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1180
msgid ""
"Attempted to B<read>(2)  or B<write>(2)  a cpuset file using a buffer that "
"is outside the writing processes accessible address space."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1189
msgid ""
"Attempted to change a cpuset, using B<write>(2), in a way that would violate "
"a I<cpu_exclusive> or I<mem_exclusive> attribute of that cpuset or any of "
"its siblings."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1198
msgid ""
"Attempted to B<write>(2)  an empty I<cpuset.cpus> or I<cpuset.mems> list to "
"a cpuset which has attached processes or child cpusets."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1208
msgid ""
"Attempted to B<write>(2)  a I<cpuset.cpus> or I<cpuset.mems> list which "
"included a range with the second number smaller than the first number."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1217
msgid ""
"Attempted to B<write>(2)  a I<cpuset.cpus> or I<cpuset.mems> list which "
"included an invalid character in the string."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1224
msgid ""
"Attempted to B<write>(2)  a list to a I<cpuset.cpus> file that did not "
"include any online CPUs."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1231
msgid ""
"Attempted to B<write>(2)  a list to a I<cpuset.mems> file that did not "
"include any online memory nodes."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1238
msgid ""
"Attempted to B<write>(2)  a list to a I<cpuset.mems> file that included a "
"node that held no memory."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1246
msgid ""
"Attempted to B<write>(2)  a string to a cpuset I<tasks> file that does not "
"begin with an ASCII decimal integer."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1251
msgid "Attempted to B<rename>(2)  a cpuset into a different directory."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1258
msgid ""
"Attempted to B<read>(2)  a I</proc/E<lt>pidE<gt>/cpuset> file for a cpuset "
"path that is longer than the kernel page size."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1263
msgid ""
"Attempted to create, using B<mkdir>(2), a cpuset whose base directory name "
"is longer than 255 characters."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1270
msgid ""
"Attempted to create, using B<mkdir>(2), a cpuset whose full pathname, "
"including the mount point (typically \"/dev/cpuset/\") prefix, is longer "
"than 4095 characters."
msgstr ""

#. type: TP
#: build/C/man7/cpuset.7:1270 build/C/man2/pidfd_open.2:73
#, no-wrap
msgid "B<ENODEV>"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1275
msgid ""
"The cpuset was removed by another process at the same time as a B<write>(2)  "
"was attempted on one of the pseudo-files in the cpuset directory."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1280
msgid ""
"Attempted to create, using B<mkdir>(2), a cpuset in a parent cpuset that "
"doesn't exist."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1287
msgid ""
"Attempted to B<access>(2)  or B<open>(2)  a nonexistent file in a cpuset "
"directory."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1292
msgid ""
"Insufficient memory is available within the kernel; can occur on a variety "
"of system calls affecting cpusets, but only if the system is extremely short "
"of memory."
msgstr ""

#. type: TP
#: build/C/man7/cpuset.7:1292 build/C/man7/cpuset.7:1304
#, no-wrap
msgid "B<ENOSPC>"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1304
msgid ""
"Attempted to B<write>(2)  the process ID (PID)  of a process to a cpuset "
"I<tasks> file when the cpuset had an empty I<cpuset.cpus> or empty "
"I<cpuset.mems> setting."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1314
msgid ""
"Attempted to B<write>(2)  an empty I<cpuset.cpus> or I<cpuset.mems> setting "
"to a cpuset that has tasks attached."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1319
msgid "Attempted to B<rename>(2)  a nonexistent cpuset."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1322
msgid "Attempted to remove a file from a cpuset directory."
msgstr ""

#. type: TP
#: build/C/man7/cpuset.7:1322
#, no-wrap
msgid "B<ERANGE>"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1330
msgid ""
"Specified a I<cpuset.cpus> or I<cpuset.mems> list to the kernel which "
"included a number too large for the kernel to set in its bit masks."
msgstr ""

#.  ================== VERSIONS ==================
#. type: Plain text
#: build/C/man7/cpuset.7:1338
msgid ""
"Attempted to B<write>(2)  the process ID (PID) of a nonexistent process to a "
"cpuset I<tasks> file."
msgstr ""

#.  ================== NOTES ==================
#. type: Plain text
#: build/C/man7/cpuset.7:1341
msgid "Cpusets appeared in version 2.6.12 of the Linux kernel."
msgstr ""

#.  ================== BUGS ==================
#. type: Plain text
#: build/C/man7/cpuset.7:1352
msgid ""
"Despite its name, the I<pid> parameter is actually a thread ID, and each "
"thread in a threaded group can be attached to a different cpuset.  The value "
"returned from a call to B<gettid>(2)  can be passed in the argument I<pid>."
msgstr ""

#. type: SH
#: build/C/man7/cpuset.7:1352 build/C/man2/getpriority.2:240 build/C/man2/getrlimit.2:646 build/C/man2/ioprio_set.2:354 build/C/man2/setfsgid.2:105 build/C/man2/setfsuid.2:123 build/C/man3/posix_spawn.3:587
#, no-wrap
msgid "BUGS"
msgstr ""

#.  ================== EXAMPLES ==================
#. type: Plain text
#: build/C/man7/cpuset.7:1365
msgid ""
"I<cpuset.memory_pressure> cpuset files can be opened for writing, creation, "
"or truncation, but then the B<write>(2)  fails with I<errno> set to "
"B<EACCES>, and the creation and truncation options on B<open>(2)  have no "
"effect."
msgstr ""

#. type: SH
#: build/C/man7/cpuset.7:1365 build/C/man2/getrlimit.2:779 build/C/man2/seccomp.2:947 build/C/man2/pidfd_open.2:200 build/C/man2/pidfd_send_signal.2:179 build/C/man3/posix_spawn.3:602
#, no-wrap
msgid "EXAMPLES"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1368
msgid ""
"The following examples demonstrate querying and setting cpuset options using "
"shell commands."
msgstr ""

#. type: SS
#: build/C/man7/cpuset.7:1368
#, no-wrap
msgid "Creating and attaching to a cpuset."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1371
msgid ""
"To create a new cpuset and attach the current command shell to it, the steps "
"are:"
msgstr ""

#. type: IP
#: build/C/man7/cpuset.7:1373 build/C/man7/cpuset.7:1413
#, no-wrap
msgid "1)"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1375
msgid "mkdir /dev/cpuset (if not already done)"
msgstr ""

#. type: IP
#: build/C/man7/cpuset.7:1375 build/C/man7/cpuset.7:1419
#, no-wrap
msgid "2)"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1377
msgid "mount -t cpuset none /dev/cpuset (if not already done)"
msgstr ""

#. type: IP
#: build/C/man7/cpuset.7:1377 build/C/man7/cpuset.7:1422
#, no-wrap
msgid "3)"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1380
msgid "Create the new cpuset using B<mkdir>(1)."
msgstr ""

#. type: IP
#: build/C/man7/cpuset.7:1380 build/C/man7/cpuset.7:1425
#, no-wrap
msgid "4)"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1382
msgid "Assign CPUs and memory nodes to the new cpuset."
msgstr ""

#. type: IP
#: build/C/man7/cpuset.7:1382 build/C/man7/cpuset.7:1430
#, no-wrap
msgid "5)"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1384
msgid "Attach the shell to the new cpuset."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1389
msgid ""
"For example, the following sequence of commands will set up a cpuset named "
"\"Charlie\", containing just CPUs 2 and 3, and memory node 1, and then "
"attach the current shell to that cpuset."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1403
#, no-wrap
msgid ""
"$B< mkdir /dev/cpuset>\n"
"$B< mount -t cpuset cpuset /dev/cpuset>\n"
"$B< cd /dev/cpuset>\n"
"$B< mkdir Charlie>\n"
"$B< cd Charlie>\n"
"$B< /bin/echo 2-3 E<gt> cpuset.cpus>\n"
"$B< /bin/echo 1 E<gt> cpuset.mems>\n"
"$B< /bin/echo $$ E<gt> tasks>\n"
"# The current shell is now running in cpuset Charlie\n"
"# The next line should display \\(aq/Charlie\\(aq\n"
"$B< cat /proc/self/cpuset>\n"
msgstr ""

#. type: SS
#: build/C/man7/cpuset.7:1406
#, no-wrap
msgid "Migrating a job to different memory nodes."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1411
msgid ""
"To migrate a job (the set of processes attached to a cpuset)  to different "
"CPUs and memory nodes in the system, including moving the memory pages "
"currently allocated to that job, perform the following steps."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1419
msgid ""
"Let's say we want to move the job in cpuset I<alpha> (CPUs 4\\(en7 and "
"memory nodes 2\\(en3) to a new cpuset I<beta> (CPUs 16\\(en19 and memory "
"nodes 8\\(en9)."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1422
msgid "First create the new cpuset I<beta>."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1425
msgid "Then allow CPUs 16\\(en19 and memory nodes 8\\(en9 in I<beta>."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1430
msgid "Then enable I<memory_migration> in I<beta>."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1435
msgid "Then move each process from I<alpha> to I<beta>."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1438
msgid "The following sequence of commands accomplishes this."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1448
#, no-wrap
msgid ""
"$B< cd /dev/cpuset>\n"
"$B< mkdir beta>\n"
"$B< cd beta>\n"
"$B< /bin/echo 16-19 E<gt> cpuset.cpus>\n"
"$B< /bin/echo 8-9 E<gt> cpuset.mems>\n"
"$B< /bin/echo 1 E<gt> cpuset.memory_migrate>\n"
"$B< while read i; do /bin/echo $i; done E<lt> ../alpha/tasks E<gt> tasks>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1457
msgid ""
"The above should move any processes in I<alpha> to I<beta>, and any memory "
"held by these processes on memory nodes 2\\(en3 to memory nodes 8\\(en9, "
"respectively."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1459
msgid "Notice that the last step of the above sequence did not do:"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1463
#, no-wrap
msgid "$B< cp ../alpha/tasks tasks>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1474
msgid ""
"The I<while> loop, rather than the seemingly easier use of the B<cp>(1)  "
"command, was necessary because only one process PID at a time may be written "
"to the I<tasks> file."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1482
msgid ""
"The same effect (writing one PID at a time) as the I<while> loop can be "
"accomplished more efficiently, in fewer keystrokes and in syntax that works "
"on any shell, but alas more obscurely, by using the B<-u> (unbuffered) "
"option of B<sed>(1):"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1486
#, no-wrap
msgid "$B< sed -un p E<lt> ../alpha/tasks E<gt> tasks>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1505
msgid ""
"B<taskset>(1), B<get_mempolicy>(2), B<getcpu>(2), B<mbind>(2), "
"B<sched_getaffinity>(2), B<sched_setaffinity>(2), B<sched_setscheduler>(2), "
"B<set_mempolicy>(2), B<CPU_SET>(3), B<proc>(5), B<cgroups>(7), B<numa>(7), "
"B<sched>(7), B<migratepages>(8), B<numactl>(8)"
msgstr ""

#.  commit 45ce80fb6b6f9594d1396d44dd7e7c02d596fef8
#. type: Plain text
#: build/C/man7/cpuset.7:1514
msgid ""
"I<Documentation/admin-guide/cgroup-v1/cpusets.rst> in the Linux kernel "
"source tree (or I<Documentation/cgroup-v1/cpusets.txt> before Linux 4.18, "
"and I<Documentation/cpusets.txt> before Linux 2.6.29)"
msgstr ""

#. type: TH
#: build/C/man7/credentials.7:27
#, no-wrap
msgid "CREDENTIALS"
msgstr ""

#. type: Plain text
#: build/C/man7/credentials.7:30
msgid "credentials - process identifiers"
msgstr ""

#. type: SS
#: build/C/man7/credentials.7:31
#, no-wrap
msgid "Process ID (PID)"
msgstr ""

#. type: Plain text
#: build/C/man7/credentials.7:41
msgid ""
"Each process has a unique nonnegative integer identifier that is assigned "
"when the process is created using B<fork>(2).  A process can obtain its PID "
"using B<getpid>(2).  A PID is represented using the type I<pid_t> (defined "
"in I<E<lt>sys/types.hE<gt>>)."
msgstr ""

#.  .BR sched_rr_get_interval (2),
#.  .BR sched_getaffinity (2),
#.  .BR sched_setaffinity (2),
#.  .BR sched_getparam (2),
#.  .BR sched_setparam (2),
#.  .BR sched_setscheduler (2),
#.  .BR sched_getscheduler (2),
#.  .BR getsid (2),
#.  .BR waitid (2),
#.  .BR wait4 (2),
#. type: Plain text
#: build/C/man7/credentials.7:62
msgid ""
"PIDs are used in a range of system calls to identify the process affected by "
"the call, for example: B<kill>(2), B<ptrace>(2), B<setpriority>(2)  "
"B<setpgid>(2), B<setsid>(2), B<sigqueue>(3), and B<waitpid>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/credentials.7:65
msgid "A process's PID is preserved across an B<execve>(2)."
msgstr ""

#. type: SS
#: build/C/man7/credentials.7:65
#, no-wrap
msgid "Parent process ID (PPID)"
msgstr ""

#. type: Plain text
#: build/C/man7/credentials.7:73
msgid ""
"A process's parent process ID identifies the process that created this "
"process using B<fork>(2).  A process can obtain its PPID using "
"B<getppid>(2).  A PPID is represented using the type I<pid_t>."
msgstr ""

#. type: Plain text
#: build/C/man7/credentials.7:76
msgid "A process's PPID is preserved across an B<execve>(2)."
msgstr ""

#. type: SS
#: build/C/man7/credentials.7:76
#, no-wrap
msgid "Process group ID and session ID"
msgstr ""

#. type: Plain text
#: build/C/man7/credentials.7:84
msgid ""
"Each process has a session ID and a process group ID, both represented using "
"the type I<pid_t>.  A process can obtain its session ID using B<getsid>(2), "
"and its process group ID using B<getpgrp>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/credentials.7:90
msgid ""
"A child created by B<fork>(2)  inherits its parent's session ID and process "
"group ID.  A process's session ID and process group ID are preserved across "
"an B<execve>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/credentials.7:103
msgid ""
"Sessions and process groups are abstractions devised to support shell job "
"control.  A process group (sometimes called a \"job\") is a collection of "
"processes that share the same process group ID; the shell creates a new "
"process group for the process(es) used to execute single command or pipeline "
"(e.g., the two processes created to execute the command \"ls\\ |\\ wc\" are "
"placed in the same process group).  A process's group membership can be set "
"using B<setpgid>(2).  The process whose process ID is the same as its "
"process group ID is the I<process group leader> for that group."
msgstr ""

#. type: Plain text
#: build/C/man7/credentials.7:115
msgid ""
"A session is a collection of processes that share the same session ID.  All "
"of the members of a process group also have the same session ID (i.e., all "
"of the members of a process group always belong to the same session, so that "
"sessions and process groups form a strict two-level hierarchy of processes.)  "
"A new session is created when a process calls B<setsid>(2), which creates a "
"new session whose session ID is the same as the PID of the process that "
"called B<setsid>(2).  The creator of the session is called the I<session "
"leader>."
msgstr ""

#. type: Plain text
#: build/C/man7/credentials.7:124
msgid ""
"All of the processes in a session share a I<controlling terminal>.  The "
"controlling terminal is established when the session leader first opens a "
"terminal (unless the B<O_NOCTTY> flag is specified when calling "
"B<open>(2)).  A terminal may be the controlling terminal of at most one "
"session."
msgstr ""

#. type: Plain text
#: build/C/man7/credentials.7:146
msgid ""
"At most one of the jobs in a session may be the I<foreground job>; other "
"jobs in the session are I<background jobs>.  Only the foreground job may "
"read from the terminal; when a process in the background attempts to read "
"from the terminal, its process group is sent a B<SIGTTIN> signal, which "
"suspends the job.  If the B<TOSTOP> flag has been set for the terminal (see "
"B<termios>(3)), then only the foreground job may write to the terminal; "
"writes from background job cause a B<SIGTTOU> signal to be generated, which "
"suspends the job.  When terminal keys that generate a signal (such as the "
"I<interrupt> key, normally control-C)  are pressed, the signal is sent to "
"the processes in the foreground job."
msgstr ""

#. type: Plain text
#: build/C/man7/credentials.7:167
msgid ""
"Various system calls and library functions may operate on all members of a "
"process group, including B<kill>(2), B<killpg>(3), B<getpriority>(2), "
"B<setpriority>(2), B<ioprio_get>(2), B<ioprio_set>(2), B<waitid>(2), and "
"B<waitpid>(2).  See also the discussion of the B<F_GETOWN>, B<F_GETOWN_EX>, "
"B<F_SETOWN>, and B<F_SETOWN_EX> operations in B<fcntl>(2)."
msgstr ""

#. type: SS
#: build/C/man7/credentials.7:167
#, no-wrap
msgid "User and group identifiers"
msgstr ""

#. type: Plain text
#: build/C/man7/credentials.7:175
msgid ""
"Each process has various associated user and group IDs.  These IDs are "
"integers, respectively represented using the types I<uid_t> and I<gid_t> "
"(defined in I<E<lt>sys/types.hE<gt>>)."
msgstr ""

#. type: Plain text
#: build/C/man7/credentials.7:177
msgid "On Linux, each process has the following user and group identifiers:"
msgstr ""

#. type: Plain text
#: build/C/man7/credentials.7:183
msgid ""
"Real user ID and real group ID.  These IDs determine who owns the process.  "
"A process can obtain its real user (group) ID using B<getuid>(2)  "
"(B<getgid>(2))."
msgstr ""

#. type: Plain text
#: build/C/man7/credentials.7:195
msgid ""
"Effective user ID and effective group ID.  These IDs are used by the kernel "
"to determine the permissions that the process will have when accessing "
"shared resources such as message queues, shared memory, and semaphores.  On "
"most UNIX systems, these IDs also determine the permissions when accessing "
"files.  However, Linux uses the filesystem IDs described below for this "
"task.  A process can obtain its effective user (group) ID using "
"B<geteuid>(2)  (B<getegid>(2))."
msgstr ""

#. type: Plain text
#: build/C/man7/credentials.7:217
msgid ""
"Saved set-user-ID and saved set-group-ID.  These IDs are used in set-user-ID "
"and set-group-ID programs to save a copy of the corresponding effective IDs "
"that were set when the program was executed (see B<execve>(2)).  A "
"set-user-ID program can assume and drop privileges by switching its "
"effective user ID back and forth between the values in its real user ID and "
"saved set-user-ID.  This switching is done via calls to B<seteuid>(2), "
"B<setreuid>(2), or B<setresuid>(2).  A set-group-ID program performs the "
"analogous tasks using B<setegid>(2), B<setregid>(2), or B<setresgid>(2).  A "
"process can obtain its saved set-user-ID (set-group-ID) using "
"B<getresuid>(2)  (B<getresgid>(2))."
msgstr ""

#. type: Plain text
#: build/C/man7/credentials.7:234
msgid ""
"Filesystem user ID and filesystem group ID (Linux-specific).  These IDs, in "
"conjunction with the supplementary group IDs described below, are used to "
"determine permissions for accessing files; see B<path_resolution>(7)  for "
"details.  Whenever a process's effective user (group) ID is changed, the "
"kernel also automatically changes the filesystem user (group) ID to the same "
"value.  Consequently, the filesystem IDs normally have the same values as "
"the corresponding effective ID, and the semantics for file-permission checks "
"are thus the same on Linux as on other UNIX systems.  The filesystem IDs can "
"be made to differ from the effective IDs by calling B<setfsuid>(2)  and "
"B<setfsgid>(2)."
msgstr ""

#.  Since kernel 2.6.4, the limit is visible via the read-only file
#.  /proc/sys/kernel/ngroups_max.
#.  As at 2.6.22-rc2, this file is still read-only.
#. type: Plain text
#: build/C/man7/credentials.7:251
msgid ""
"Supplementary group IDs.  This is a set of additional group IDs that are "
"used for permission checks when accessing files and other shared resources.  "
"On Linux kernels before 2.6.4, a process can be a member of up to 32 "
"supplementary groups; since kernel 2.6.4, a process can be a member of up to "
"65536 supplementary groups.  The call I<sysconf(_SC_NGROUPS_MAX)> can be "
"used to determine the number of supplementary groups of which a process may "
"be a member.  A process can obtain its set of supplementary group IDs using "
"B<getgroups>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/credentials.7:261
msgid ""
"A child process created by B<fork>(2)  inherits copies of its parent's user "
"and groups IDs.  During an B<execve>(2), a process's real user and group ID "
"and supplementary group IDs are preserved; the effective and saved set IDs "
"may be changed, as described in B<execve>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/credentials.7:264
msgid ""
"Aside from the purposes noted above, a process's user IDs are also employed "
"in a number of other contexts:"
msgstr ""

#. type: Plain text
#: build/C/man7/credentials.7:267
msgid "when determining the permissions for sending signals (see B<kill>(2));"
msgstr ""

#. type: Plain text
#: build/C/man7/credentials.7:278
msgid ""
"when determining the permissions for setting process-scheduling parameters "
"(nice value, real time scheduling policy and priority, CPU affinity, I/O "
"priority) using B<setpriority>(2), B<sched_setaffinity>(2), "
"B<sched_setscheduler>(2), B<sched_setparam>(2), B<sched_setattr>(2), and "
"B<ioprio_set>(2);"
msgstr ""

#. type: Plain text
#: build/C/man7/credentials.7:281
msgid "when checking resource limits (see B<getrlimit>(2));"
msgstr ""

#. type: Plain text
#: build/C/man7/credentials.7:286
msgid ""
"when checking the limit on the number of inotify instances that the process "
"may create (see B<inotify>(7))."
msgstr ""

#. type: SS
#: build/C/man7/credentials.7:286
#, no-wrap
msgid "Modifying process user and group IDs"
msgstr ""

#. type: Plain text
#: build/C/man7/credentials.7:290
msgid ""
"Subject to rules described in the relevant manual pages, a process can use "
"the following APIs to modify its user and group IDs:"
msgstr ""

#. type: TP
#: build/C/man7/credentials.7:290
#, no-wrap
msgid "B<setuid>(2) (B<setgid>(2))"
msgstr ""

#. type: Plain text
#: build/C/man7/credentials.7:294
msgid ""
"Modify the process's real (and possibly effective and saved-set)  user "
"(group) IDs."
msgstr ""

#. type: TP
#: build/C/man7/credentials.7:294
#, no-wrap
msgid "B<seteuid>(2) (B<setegid>(2))"
msgstr ""

#. type: Plain text
#: build/C/man7/credentials.7:297
msgid "Modify the process's effective user (group) ID."
msgstr ""

#. type: TP
#: build/C/man7/credentials.7:297
#, no-wrap
msgid "B<setfsuid>(2) (B<setfsgid>(2))"
msgstr ""

#. type: Plain text
#: build/C/man7/credentials.7:300
msgid "Modify the process's filesystem user (group) ID."
msgstr ""

#. type: TP
#: build/C/man7/credentials.7:300
#, no-wrap
msgid "B<setreuid>(2) (B<setregid>(2))"
msgstr ""

#. type: Plain text
#: build/C/man7/credentials.7:304
msgid ""
"Modify the process's real and effective (and possibly saved-set)  user "
"(group) IDs."
msgstr ""

#. type: TP
#: build/C/man7/credentials.7:304
#, no-wrap
msgid "B<setresuid>(2) (B<setresgid>(2))"
msgstr ""

#. type: Plain text
#: build/C/man7/credentials.7:307
msgid "Modify the process's real, effective, and saved-set user (group) IDs."
msgstr ""

#. type: TP
#: build/C/man7/credentials.7:307
#, no-wrap
msgid "B<setgroups>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/credentials.7:310
msgid "Modify the process's supplementary group list."
msgstr ""

#. type: Plain text
#: build/C/man7/credentials.7:317
msgid ""
"Any changes to a process's effective user (group) ID are automatically "
"carried over to the process's filesystem user (group) ID.  Changes to a "
"process's effective user or group ID can also affect the process "
"\"dumpable\" attribute, as described in B<prctl>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/credentials.7:321
msgid ""
"Changes to process user and group IDs can affect the capabilities of the "
"process, as described in B<capabilities>(7)."
msgstr ""

#. type: Plain text
#: build/C/man7/credentials.7:327
msgid ""
"Process IDs, parent process IDs, process group IDs, and session IDs are "
"specified in POSIX.1.  The real, effective, and saved set user and groups "
"IDs, and the supplementary group IDs, are specified in POSIX.1.  The "
"filesystem user and group IDs are a Linux extension."
msgstr ""

#. type: Plain text
#: build/C/man7/credentials.7:334
msgid ""
"Various fields in the I</proc/[pid]/status> file show the process "
"credentials described above.  See B<proc>(5)  for further information."
msgstr ""

#. type: Plain text
#: build/C/man7/credentials.7:348
msgid ""
"The POSIX threads specification requires that credentials are shared by all "
"of the threads in a process.  However, at the kernel level, Linux maintains "
"separate user and group credentials for each thread.  The NPTL threading "
"implementation does some work to ensure that any change to user or group "
"credentials (e.g., calls to B<setuid>(2), B<setresuid>(2))  is carried "
"through to all of the POSIX threads in a process.  See B<nptl>(7)  for "
"further details."
msgstr ""

#. type: Plain text
#: build/C/man7/credentials.7:400
msgid ""
"B<bash>(1), B<csh>(1), B<groups>(1), B<id>(1), B<newgrp>(1), B<ps>(1), "
"B<runuser>(1), B<setpriv>(1), B<sg>(1), B<su>(1), B<access>(2), "
"B<execve>(2), B<faccessat>(2), B<fork>(2), B<getgroups>(2), B<getpgrp>(2), "
"B<getpid>(2), B<getppid>(2), B<getsid>(2), B<kill>(2), B<setegid>(2), "
"B<seteuid>(2), B<setfsgid>(2), B<setfsuid>(2), B<setgid>(2), "
"B<setgroups>(2), B<setpgid>(2), B<setresgid>(2), B<setresuid>(2), "
"B<setsid>(2), B<setuid>(2), B<waitpid>(2), B<euidaccess>(3), "
"B<initgroups>(3), B<killpg>(3), B<tcgetpgrp>(3), B<tcgetsid>(3), "
"B<tcsetpgrp>(3), B<group>(5), B<passwd>(5), B<shadow>(5), "
"B<capabilities>(7), B<namespaces>(7), B<path_resolution>(7), "
"B<pid_namespaces>(7), B<pthreads>(7), B<signal>(7), B<system_data_types>(7), "
"B<unix>(7), B<user_namespaces>(7), B<sudo>(8)"
msgstr ""

#. type: TH
#: build/C/man2/getgid.2:25
#, no-wrap
msgid "GETGID"
msgstr ""

#. type: TH
#: build/C/man2/getgid.2:25 build/C/man2/getgroups.2:32 build/C/man2/getuid.2:26 build/C/man2/ioprio_set.2:24 build/C/man2/setgid.2:30 build/C/man2/setuid.2:31
#, no-wrap
msgid "2019-03-06"
msgstr ""

#. type: Plain text
#: build/C/man2/getgid.2:28
msgid "getgid, getegid - get group identity"
msgstr ""

#. type: Plain text
#: build/C/man2/getgid.2:30 build/C/man2/getgroups.2:39 build/C/man2/getpid.2:32 build/C/man2/getresuid.2:35 build/C/man2/getsid.2:34 build/C/man2/getuid.2:31 build/C/man3/group_member.3:30 build/C/man2/seteuid.2:36 build/C/man2/setgid.2:37 build/C/man2/setpgid.2:55 build/C/man2/setresuid.2:34 build/C/man2/setreuid.2:53 build/C/man2/setsid.2:39 build/C/man2/setuid.2:38
msgid "B<#include E<lt>unistd.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man2/getgid.2:32 build/C/man2/getgroups.2:37 build/C/man2/getpid.2:30 build/C/man2/getsid.2:32 build/C/man2/getuid.2:33 build/C/man2/seteuid.2:34 build/C/man2/setgid.2:35 build/C/man2/setpgid.2:53 build/C/man2/setreuid.2:51 build/C/man2/setsid.2:37 build/C/man2/setuid.2:36
msgid "B<#include E<lt>sys/types.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man2/getgid.2:34
msgid "B<gid_t getgid(void);>"
msgstr ""

#. type: Plain text
#: build/C/man2/getgid.2:36
msgid "B<gid_t getegid(void);>"
msgstr ""

#. type: Plain text
#: build/C/man2/getgid.2:39
msgid "B<getgid>()  returns the real group ID of the calling process."
msgstr ""

#. type: Plain text
#: build/C/man2/getgid.2:42
msgid "B<getegid>()  returns the effective group ID of the calling process."
msgstr ""

#. type: Plain text
#: build/C/man2/getgid.2:44 build/C/man2/getpid.2:55 build/C/man2/getuid.2:45
msgid "These functions are always successful."
msgstr ""

#. type: Plain text
#: build/C/man2/getgid.2:46 build/C/man2/getuid.2:47 build/C/man2/seteuid.2:105
msgid "POSIX.1-2001, POSIX.1-2008, 4.3BSD."
msgstr ""

#. type: Plain text
#: build/C/man2/getgid.2:62
msgid ""
"The original Linux B<getgid>()  and B<getegid>()  system calls supported "
"only 16-bit group IDs.  Subsequently, Linux 2.4 added B<getgid32>()  and "
"B<getegid32>(), supporting 32-bit IDs.  The glibc B<getgid>()  and "
"B<getegid>()  wrapper functions transparently deal with the variations "
"across kernel versions."
msgstr ""

#. type: Plain text
#: build/C/man2/getgid.2:78
msgid ""
"On Alpha, instead of a pair of B<getgid>()  and B<getegid>()  system calls, "
"a single B<getxgid>()  system call is provided, which returns a pair of real "
"and effective GIDs.  The glibc B<getgid>()  and B<getegid>()  wrapper "
"functions transparently deal with this.  See B<syscall>(2)  for details "
"regarding register mapping."
msgstr ""

#. type: Plain text
#: build/C/man2/getgid.2:83
msgid "B<getresgid>(2), B<setgid>(2), B<setregid>(2), B<credentials>(7)"
msgstr ""

#. type: TH
#: build/C/man2/getgroups.2:32
#, no-wrap
msgid "GETGROUPS"
msgstr ""

#. type: Plain text
#: build/C/man2/getgroups.2:35
msgid "getgroups, setgroups - get/set list of supplementary group IDs"
msgstr ""

#. type: Plain text
#: build/C/man2/getgroups.2:41
msgid "B<int getgroups(int >I<size>B<, gid_t >I<list>B<[]);>"
msgstr ""

#. type: Plain text
#: build/C/man2/getgroups.2:43
msgid "B<#include E<lt>grp.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man2/getgroups.2:45
msgid "B<int setgroups(size_t >I<size>B<, const gid_t *>I<list>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/getgroups.2:56
#, no-wrap
msgid ""
"B<setgroups>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man2/getgroups.2:68
msgid ""
"B<getgroups>()  returns the supplementary group IDs of the calling process "
"in I<list>.  The argument I<size> should be set to the maximum number of "
"items that can be stored in the buffer pointed to by I<list>.  If the "
"calling process is a member of more than I<size> supplementary groups, then "
"an error results."
msgstr ""

#. type: Plain text
#: build/C/man2/getgroups.2:74
msgid ""
"It is unspecified whether the effective group ID of the calling process is "
"included in the returned list.  (Thus, an application should also call "
"B<getegid>(2)  and add or remove the resulting value.)"
msgstr ""

#. type: Plain text
#: build/C/man2/getgroups.2:85
msgid ""
"If I<size> is zero, I<list> is not modified, but the total number of "
"supplementary group IDs for the process is returned.  This allows the caller "
"to determine the size of a dynamically allocated I<list> to be used in a "
"further call to B<getgroups>()."
msgstr ""

#. type: Plain text
#: build/C/man2/getgroups.2:97
msgid ""
"B<setgroups>()  sets the supplementary group IDs for the calling process.  "
"Appropriate privileges are required (see the description of the B<EPERM> "
"error, below).  The I<size> argument specifies the number of supplementary "
"group IDs in the buffer pointed to by I<list>.  A process can drop all of "
"its supplementary groups with the call:"
msgstr ""

#. type: Plain text
#: build/C/man2/getgroups.2:101
#, no-wrap
msgid "setgroups(0, NULL);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/getgroups.2:110
msgid ""
"On success, B<getgroups>()  returns the number of supplementary group IDs.  "
"On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/getgroups.2:117
msgid ""
"On success, B<setgroups>()  returns 0.  On error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/getgroups.2:122
msgid "I<list> has an invalid address."
msgstr ""

#. type: Plain text
#: build/C/man2/getgroups.2:125
msgid "B<getgroups>()  can additionally fail with the following error:"
msgstr ""

#. type: Plain text
#: build/C/man2/getgroups.2:129
msgid "I<size> is less than the number of supplementary group IDs, but is not zero."
msgstr ""

#. type: Plain text
#: build/C/man2/getgroups.2:132
msgid "B<setgroups>()  can additionally fail with the following errors:"
msgstr ""

#. type: Plain text
#: build/C/man2/getgroups.2:138
msgid ""
"I<size> is greater than B<NGROUPS_MAX> (32 before Linux 2.6.4; 65536 since "
"Linux 2.6.4)."
msgstr ""

#. type: Plain text
#: build/C/man2/getgroups.2:147
msgid ""
"The calling process has insufficient privilege (the caller does not have the "
"B<CAP_SETGID> capability in the user namespace in which it resides)."
msgstr ""

#. type: TP
#: build/C/man2/getgroups.2:147
#, no-wrap
msgid "B<EPERM> (since Linux 3.19)"
msgstr ""

#. type: Plain text
#: build/C/man2/getgroups.2:156
msgid ""
"The use of B<setgroups>()  is denied in this user namespace.  See the "
"description of I</proc/[pid]/setgroups> in B<user_namespaces>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/getgroups.2:159
msgid "B<getgroups>(): SVr4, 4.3BSD, POSIX.1-2001, POSIX.1-2008."
msgstr ""

#. type: Plain text
#: build/C/man2/getgroups.2:165
msgid ""
"B<setgroups>(): SVr4, 4.3BSD.  Since B<setgroups>()  requires privilege, it "
"is not covered by POSIX.1."
msgstr ""

#. type: Plain text
#: build/C/man2/getgroups.2:177
msgid ""
"A process can have up to B<NGROUPS_MAX> supplementary group IDs in addition "
"to the effective group ID.  The constant B<NGROUPS_MAX> is defined in "
"I<E<lt>limits.hE<gt>>.  The set of supplementary group IDs is inherited from "
"the parent process, and preserved across an B<execve>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/getgroups.2:180
msgid ""
"The maximum number of supplementary group IDs can be found at run time using "
"B<sysconf>(3):"
msgstr ""

#. type: Plain text
#: build/C/man2/getgroups.2:185
#, no-wrap
msgid ""
"long ngroups_max;\n"
"ngroups_max = sysconf(_SC_NGROUPS_MAX);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/getgroups.2:194
msgid ""
"The maximum return value of B<getgroups>()  cannot be larger than one more "
"than this value.  Since Linux 2.6.4, the maximum number of supplementary "
"group IDs is also exposed via the Linux-specific read-only file, "
"I</proc/sys/kernel/ngroups_max>."
msgstr ""

#. type: Plain text
#: build/C/man2/getgroups.2:205
msgid ""
"The original Linux B<getgroups>()  system call supported only 16-bit group "
"IDs.  Subsequently, Linux 2.4 added B<getgroups32>(), supporting 32-bit "
"IDs.  The glibc B<getgroups>()  wrapper function transparently deals with "
"the variation across kernel versions."
msgstr ""

#. type: SS
#: build/C/man2/getgroups.2:205 build/C/man2/getpid.2:75 build/C/man2/getpriority.2:225 build/C/man2/seteuid.2:136 build/C/man2/setfsgid.2:96 build/C/man2/setfsuid.2:114 build/C/man2/setgid.2:87 build/C/man2/setresuid.2:142 build/C/man2/setreuid.2:198 build/C/man2/setuid.2:149
#, no-wrap
msgid "C library/kernel differences"
msgstr ""

#. type: Plain text
#: build/C/man2/getgroups.2:219
msgid ""
"At the kernel level, user IDs and group IDs are a per-thread attribute.  "
"However, POSIX requires that all threads in a process share the same "
"credentials.  The NPTL threading implementation handles the POSIX "
"requirements by providing wrapper functions for the various system calls "
"that change process UIDs and GIDs.  These wrapper functions (including the "
"one for B<setgroups>())  employ a signal-based technique to ensure that when "
"one thread changes credentials, all of the other threads in the process also "
"change their credentials.  For details, see B<nptl>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/getgroups.2:227
msgid ""
"B<getgid>(2), B<setgid>(2), B<getgrouplist>(3), B<group_member>(3), "
"B<initgroups>(3), B<capabilities>(7), B<credentials>(7)"
msgstr ""

#. type: TH
#: build/C/man2/getpid.2:25
#, no-wrap
msgid "GETPID"
msgstr ""

#. type: Plain text
#: build/C/man2/getpid.2:28
msgid "getpid, getppid - get process identification"
msgstr ""

#. type: Plain text
#: build/C/man2/getpid.2:34
msgid "B<pid_t getpid(void);>"
msgstr ""

#. type: Plain text
#: build/C/man2/getpid.2:36
msgid "B<pid_t getppid(void);>"
msgstr ""

#. type: Plain text
#: build/C/man2/getpid.2:41
msgid ""
"B<getpid>()  returns the process ID (PID) of the calling process.  (This is "
"often used by routines that generate unique temporary filenames.)"
msgstr ""

#. type: Plain text
#: build/C/man2/getpid.2:53
msgid ""
"B<getppid>()  returns the process ID of the parent of the calling process.  "
"This will be either the ID of the process that created this process using "
"B<fork>(), or, if that process has already terminated, the ID of the process "
"to which this process has been reparented (either B<init>(1)  or a "
"\"subreaper\" process defined via the B<prctl>(2)  B<PR_SET_CHILD_SUBREAPER> "
"operation)."
msgstr ""

#. type: Plain text
#: build/C/man2/getpid.2:57
msgid "POSIX.1-2001, POSIX.1-2008, 4.3BSD, SVr4."
msgstr ""

#. type: Plain text
#: build/C/man2/getpid.2:62
msgid ""
"If the caller's parent is in a different PID namespace (see "
"B<pid_namespaces>(7)), B<getppid>()  returns 0."
msgstr ""

#. type: Plain text
#: build/C/man2/getpid.2:75
msgid ""
"From a kernel perspective, the PID (which is shared by all of the threads in "
"a multithreaded process)  is sometimes also known as the thread group ID "
"(TGID).  This contrasts with the kernel thread ID (TID), which is unique for "
"each thread.  For further details, see B<gettid>(2)  and the discussion of "
"the B<CLONE_THREAD> flag in B<clone>(2)."
msgstr ""

#.  The following program demonstrates this "feature":
#
#.  #define _GNU_SOURCE
#.  #include <sys/syscall.h>
#.  #include <sys/wait.h>
#.  #include <stdint.h>
#.  #include <stdio.h>
#.  #include <stdlib.h>
#.  #include <unistd.h>
#
#.  int
#.  main(int argc, char *argv[])
#.  {
#.     /* The following statement fills the getpid() cache */
#
#.     printf("parent PID = %ld
#. ", (intmax_t) getpid());
#
#.     if (syscall(SYS_fork) == 0) {
#.         if (getpid() != syscall(SYS_getpid))
#.             printf("child getpid() mismatch: getpid()=%jd; "
#.                     "syscall(SYS_getpid)=%ld
#. ",
#.                     (intmax_t) getpid(), (long) syscall(SYS_getpid));
#.         exit(EXIT_SUCCESS);
#.     }
#.     wait(NULL);
#. }
#. type: Plain text
#: build/C/man2/getpid.2:130
msgid ""
"From glibc version 2.3.4 up to and including version 2.24, the glibc wrapper "
"function for B<getpid>()  cached PIDs, with the goal of avoiding additional "
"system calls when a process calls B<getpid>()  repeatedly.  Normally this "
"caching was invisible, but its correct operation relied on support in the "
"wrapper functions for B<fork>(2), B<vfork>(2), and B<clone>(2): if an "
"application bypassed the glibc wrappers for these system calls by using "
"B<syscall>(2), then a call to B<getpid>()  in the child would return the "
"wrong value (to be precise: it would return the PID of the parent process).  "
"In addition, there were cases where B<getpid>()  could return the wrong "
"value even when invoking B<clone>(2)  via the glibc wrapper function.  (For "
"a discussion of one such case, see BUGS in B<clone>(2).)  Furthermore, the "
"complexity of the caching code had been the source of a few bugs within "
"glibc over the years."
msgstr ""

#.  commit c579f48edba88380635ab98cb612030e3ed8691e
#.  https://sourceware.org/glibc/wiki/Release/2.25#pid_cache_removal
#.  FIXME .
#.  Review progress of https://bugzilla.redhat.com/show_bug.cgi?id=1469757
#. type: Plain text
#: build/C/man2/getpid.2:140
msgid ""
"Because of the aforementioned problems, since glibc version 2.25, the PID "
"cache is removed: calls to B<getpid>()  always invoke the actual system "
"call, rather than returning a cached value."
msgstr ""

#. type: Plain text
#: build/C/man2/getpid.2:156
msgid ""
"On Alpha, instead of a pair of B<getpid>()  and B<getppid>()  system calls, "
"a single B<getxpid>()  system call is provided, which returns a pair of PID "
"and parent PID.  The glibc B<getpid>()  and B<getppid>()  wrapper functions "
"transparently deal with this.  See B<syscall>(2)  for details regarding "
"register mapping."
msgstr ""

#. type: Plain text
#: build/C/man2/getpid.2:168
msgid ""
"B<clone>(2), B<fork>(2), B<gettid>(2), B<kill>(2), B<exec>(3), "
"B<mkstemp>(3), B<tempnam>(3), B<tmpfile>(3), B<tmpnam>(3), "
"B<credentials>(7), B<pid_namespaces>(7)"
msgstr ""

#. type: TH
#: build/C/man2/getpriority.2:45
#, no-wrap
msgid "GETPRIORITY"
msgstr ""

#. type: Plain text
#: build/C/man2/getpriority.2:48
msgid "getpriority, setpriority - get/set program scheduling priority"
msgstr ""

#. type: Plain text
#: build/C/man2/getpriority.2:50 build/C/man2/getrlimit.2:69 build/C/man2/getrusage.2:44
msgid "B<#include E<lt>sys/time.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man2/getpriority.2:52 build/C/man2/getrlimit.2:71 build/C/man2/getrusage.2:46
msgid "B<#include E<lt>sys/resource.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man2/getpriority.2:54
msgid "B<int getpriority(int >I<which>B<, id_t >I<who>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/getpriority.2:56
msgid "B<int setpriority(int >I<which>B<, id_t >I<who>B<, int >I<prio>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/getpriority.2:70
msgid ""
"The scheduling priority of the process, process group, or user, as indicated "
"by I<which> and I<who> is obtained with the B<getpriority>()  call and set "
"with the B<setpriority>()  call.  The process attribute dealt with by these "
"system calls is the same attribute (also known as the \"nice\" value) that "
"is dealt with by B<nice>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/getpriority.2:93
msgid ""
"The value I<which> is one of B<PRIO_PROCESS>, B<PRIO_PGRP>, or B<PRIO_USER>, "
"and I<who> is interpreted relative to I<which> (a process identifier for "
"B<PRIO_PROCESS>, process group identifier for B<PRIO_PGRP>, and a user ID "
"for B<PRIO_USER>).  A zero value for I<who> denotes (respectively) the "
"calling process, the process group of the calling process, or the real user "
"ID of the calling process."
msgstr ""

#. type: Plain text
#: build/C/man2/getpriority.2:102
msgid ""
"The I<prio> argument is a value in the range -20 to 19 (but see NOTES "
"below).  with -20 being the highest priority and 19 being the lowest "
"priority.  Attempts to set a priority outside this range are silently "
"clamped to the range.  The default priority is 0; lower values give a "
"process a higher scheduling priority."
msgstr ""

#. type: Plain text
#: build/C/man2/getpriority.2:111
msgid ""
"The B<getpriority>()  call returns the highest priority (lowest numerical "
"value)  enjoyed by any of the specified processes.  The B<setpriority>()  "
"call sets the priorities of all of the specified processes to the specified "
"value."
msgstr ""

#. type: Plain text
#: build/C/man2/getpriority.2:120
msgid ""
"Traditionally, only a privileged process could lower the nice value (i.e., "
"set a higher priority).  However, since Linux 2.6.12, an unprivileged "
"process can decrease the nice value of a target process that has a suitable "
"B<RLIMIT_NICE> soft limit; see B<getrlimit>(2)  for details."
msgstr ""

#. type: Plain text
#: build/C/man2/getpriority.2:127
msgid ""
"On success, B<getpriority>()  returns the calling thread's nice value, which "
"may be a negative number.  On error, it returns -1 and sets I<errno> to "
"indicate the cause of the error."
msgstr ""

#. type: Plain text
#: build/C/man2/getpriority.2:138
msgid ""
"Since a successful call to B<getpriority>()  can legitimately return the "
"value -1, it is necessary to clear the external variable I<errno> prior to "
"the call, then check I<errno> afterward to determine if -1 is an error or a "
"legitimate value."
msgstr ""

#. type: Plain text
#: build/C/man2/getpriority.2:144
msgid ""
"B<setpriority>()  returns 0 on success.  On error, it returns -1 and sets "
"I<errno> to indicate the cause of the error."
msgstr ""

#. type: Plain text
#: build/C/man2/getpriority.2:153
msgid "I<which> was not one of B<PRIO_PROCESS>, B<PRIO_PGRP>, or B<PRIO_USER>."
msgstr ""

#. type: Plain text
#: build/C/man2/getpriority.2:160
msgid "No process was located using the I<which> and I<who> values specified."
msgstr ""

#. type: Plain text
#: build/C/man2/getpriority.2:164
msgid "In addition to the errors indicated above, B<setpriority>()  may fail if:"
msgstr ""

#. type: Plain text
#: build/C/man2/getpriority.2:171
msgid ""
"The caller attempted to set a lower nice value (i.e., a higher process "
"priority), but did not have the required privilege (on Linux: did not have "
"the B<CAP_SYS_NICE> capability)."
msgstr ""

#. type: Plain text
#: build/C/man2/getpriority.2:179
msgid ""
"A process was located, but its effective user ID did not match either the "
"effective or the real user ID of the caller, and was not privileged (on "
"Linux: did not have the B<CAP_SYS_NICE> capability).  But see NOTES below."
msgstr ""

#. type: Plain text
#: build/C/man2/getpriority.2:182
msgid ""
"POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD (these interfaces first appeared in "
"4.2BSD)."
msgstr ""

#. type: Plain text
#: build/C/man2/getpriority.2:185
msgid "For further details on the nice value, see B<sched>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/getpriority.2:191
msgid ""
"I<Note>: the addition of the \"autogroup\" feature in Linux 2.6.38 means "
"that the nice value no longer has its traditional effect in many "
"circumstances.  For details, see B<sched>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/getpriority.2:197
msgid ""
"A child created by B<fork>(2)  inherits its parent's nice value.  The nice "
"value is preserved across B<execve>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/getpriority.2:212
msgid ""
"The details on the condition for B<EPERM> depend on the system.  The above "
"description is what POSIX.1-2001 says, and seems to be followed on all "
"System\\ V-like systems.  Linux kernels before 2.6.12 required the real or "
"effective user ID of the caller to match the real user of the process I<who> "
"(instead of its effective user ID).  Linux 2.6.12 and later require the "
"effective user ID of the caller to match the real or effective user ID of "
"the process I<who>.  All BSD-like systems (SunOS 4.1.3, Ultrix 4.2, 4.3BSD, "
"FreeBSD 4.3, OpenBSD-2.5, ...) behave in the same manner as Linux 2.6.12 and "
"later."
msgstr ""

#. type: Plain text
#: build/C/man2/getpriority.2:225
msgid ""
"Including I<E<lt>sys/time.hE<gt>> is not required these days, but increases "
"portability.  (Indeed, I<E<lt>sys/resource.hE<gt>> defines the I<rusage> "
"structure with fields of type I<struct timeval> defined in "
"I<E<lt>sys/time.hE<gt>>.)"
msgstr ""

#. type: Plain text
#: build/C/man2/getpriority.2:240
msgid ""
"Within the kernel, nice values are actually represented using the range "
"40..1 (since negative numbers are error codes) and these are the values "
"employed by the B<setpriority>()  and B<getpriority>()  system calls.  The "
"glibc wrapper functions for these system calls handle the translations "
"between the user-land and kernel representations of the nice value according "
"to the formula I<unice\\ =\\ 20\\ -\\ knice>.  (Thus, the kernel's 40..1 "
"range corresponds to the range -20..19 as seen by user space.)"
msgstr ""

#. type: Plain text
#: build/C/man2/getpriority.2:247
msgid ""
"According to POSIX, the nice value is a per-process setting.  However, under "
"the current Linux/NPTL implementation of POSIX threads, the nice value is a "
"per-thread attribute: different threads in the same process can have "
"different nice values.  Portable applications should avoid relying on the "
"Linux behavior, which may be made standards conformant in the future."
msgstr ""

#. type: Plain text
#: build/C/man2/getpriority.2:253
msgid "B<nice>(1), B<renice>(1), B<fork>(2), B<capabilities>(7), B<sched>(7)"
msgstr ""

#. type: Plain text
#: build/C/man2/getpriority.2:256
msgid ""
"I<Documentation/scheduler/sched-nice-design.txt> in the Linux kernel source "
"tree (since Linux 2.6.23)"
msgstr ""

#. type: TH
#: build/C/man2/getresuid.2:28
#, no-wrap
msgid "GETRESUID"
msgstr ""

#. type: Plain text
#: build/C/man2/getresuid.2:31
msgid "getresuid, getresgid - get real, effective and saved user/group IDs"
msgstr ""

#. type: Plain text
#: build/C/man2/getresuid.2:33 build/C/man2/setresuid.2:32
msgid "B<#define _GNU_SOURCE> /* See feature_test_macros(7) */"
msgstr ""

#. type: Plain text
#: build/C/man2/getresuid.2:37
msgid "B<int getresuid(uid_t *>I<ruid>B<, uid_t *>I<euid>B<, uid_t *>I<suid>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/getresuid.2:39
msgid "B<int getresgid(gid_t *>I<rgid>B<, gid_t *>I<egid>B<, gid_t *>I<sgid>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/getresuid.2:50
msgid ""
"B<getresuid>()  returns the real UID, the effective UID, and the saved "
"set-user-ID of the calling process, in the arguments I<ruid>, I<euid>, and "
"I<suid>, respectively.  B<getresgid>()  performs the analogous task for the "
"process's group IDs."
msgstr ""

#. type: Plain text
#: build/C/man2/getresuid.2:60
msgid ""
"One of the arguments specified an address outside the calling program's "
"address space."
msgstr ""

#. type: Plain text
#: build/C/man2/getresuid.2:62
msgid "These system calls appeared on Linux starting with kernel 2.1.44."
msgstr ""

#. type: Plain text
#: build/C/man2/getresuid.2:67
msgid ""
"The prototypes are given by glibc since version 2.3.2, provided "
"B<_GNU_SOURCE> is defined."
msgstr ""

#. type: Plain text
#: build/C/man2/getresuid.2:70 build/C/man2/setresuid.2:121
msgid "These calls are nonstandard; they also appear on HP-UX and some of the BSDs."
msgstr ""

#. type: Plain text
#: build/C/man2/getresuid.2:86
msgid ""
"The original Linux B<getresuid>()  and B<getresgid>()  system calls "
"supported only 16-bit user and group IDs.  Subsequently, Linux 2.4 added "
"B<getresuid32>()  and B<getresgid32>(), supporting 32-bit IDs.  The glibc "
"B<getresuid>()  and B<getresgid>()  wrapper functions transparently deal "
"with the variations across kernel versions."
msgstr ""

#. type: Plain text
#: build/C/man2/getresuid.2:92
msgid ""
"B<getuid>(2), B<setresuid>(2), B<setreuid>(2), B<setuid>(2), "
"B<credentials>(7)"
msgstr ""

#. type: TH
#: build/C/man2/getrlimit.2:64
#, no-wrap
msgid "GETRLIMIT"
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:67
msgid "getrlimit, setrlimit, prlimit - get/set resource limits"
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:73
msgid "B<int getrlimit(int >I<resource>B<, struct rlimit *>I<rlim>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:75
msgid "B<int setrlimit(int >I<resource>B<, const struct rlimit *>I<rlim>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:78
msgid ""
"B<int prlimit(pid_t >I<pid>B<, int >I<resource>B<, const struct rlimit "
"*>I<new_limit>B<,>"
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:80
msgid "B< struct rlimit *>I<old_limit>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:88
msgid "B<prlimit>(): _GNU_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:97
msgid ""
"The B<getrlimit>()  and B<setrlimit>()  system calls get and set resource "
"limits.  Each resource has an associated soft and hard limit, as defined by "
"the I<rlimit> structure:"
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:104
#, no-wrap
msgid ""
"struct rlimit {\n"
"    rlim_t rlim_cur;  /* Soft limit */\n"
"    rlim_t rlim_max;  /* Hard limit (ceiling for rlim_cur) */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:116
msgid ""
"The soft limit is the value that the kernel enforces for the corresponding "
"resource.  The hard limit acts as a ceiling for the soft limit: an "
"unprivileged process may set only its soft limit to a value in the range "
"from 0 up to the hard limit, and (irreversibly) lower its hard limit.  A "
"privileged process (under Linux: one with the B<CAP_SYS_RESOURCE> capability "
"in the initial user namespace)  may make arbitrary changes to either limit "
"value."
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:123
msgid ""
"The value B<RLIM_INFINITY> denotes no limit on a resource (both in the "
"structure returned by B<getrlimit>()  and in the structure passed to "
"B<setrlimit>())."
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:127
msgid "The I<resource> argument must be one of:"
msgstr ""

#. type: TP
#: build/C/man2/getrlimit.2:127
#, no-wrap
msgid "B<RLIMIT_AS>"
msgstr ""

#.  since 2.0.27 / 2.1.12
#. type: Plain text
#: build/C/man2/getrlimit.2:149
msgid ""
"This is the maximum size of the process's virtual memory (address space).  "
"The limit is specified in bytes, and is rounded down to the system page "
"size.  This limit affects calls to B<brk>(2), B<mmap>(2), and B<mremap>(2), "
"which fail with the error B<ENOMEM> upon exceeding this limit.  In addition, "
"automatic stack expansion fails (and generates a B<SIGSEGV> that kills the "
"process if no alternate stack has been made available via "
"B<sigaltstack>(2)).  Since the value is a I<long>, on machines with a 32-bit "
"I<long> either this limit is at most 2\\ GiB, or this resource is unlimited."
msgstr ""

#. type: TP
#: build/C/man2/getrlimit.2:149
#, no-wrap
msgid "B<RLIMIT_CORE>"
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:158
msgid ""
"This is the maximum size of a I<core> file (see B<core>(5))  in bytes that "
"the process may dump.  When 0 no core dump files are created.  When nonzero, "
"larger dumps are truncated to this size."
msgstr ""

#. type: TP
#: build/C/man2/getrlimit.2:158
#, no-wrap
msgid "B<RLIMIT_CPU>"
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:179
msgid ""
"This is a limit, in seconds, on the amount of CPU time that the process can "
"consume.  When the process reaches the soft limit, it is sent a B<SIGXCPU> "
"signal.  The default action for this signal is to terminate the process.  "
"However, the signal can be caught, and the handler can return control to the "
"main program.  If the process continues to consume CPU time, it will be sent "
"B<SIGXCPU> once per second until the hard limit is reached, at which time it "
"is sent B<SIGKILL>.  (This latter point describes Linux behavior.  "
"Implementations vary in how they treat processes which continue to consume "
"CPU time after reaching the soft limit.  Portable applications that need to "
"catch this signal should perform an orderly termination upon first receipt "
"of B<SIGXCPU>.)"
msgstr ""

#. type: TP
#: build/C/man2/getrlimit.2:179
#, no-wrap
msgid "B<RLIMIT_DATA>"
msgstr ""

#.  commits 84638335900f1995495838fe1bd4870c43ec1f67
#.  ("mm: rework virtual memory accounting"),
#.  f4fcd55841fc9e46daac553b39361572453c2b88
#.  (mm: enable RLIMIT_DATA by default with workaround for valgrind).
#. type: Plain text
#: build/C/man2/getrlimit.2:197
msgid ""
"This is the maximum size of the process's data segment (initialized data, "
"uninitialized data, and heap).  The limit is specified in bytes, and is "
"rounded down to the system page size.  This limit affects calls to "
"B<brk>(2), B<sbrk>(2), and (since Linux 4.7)  B<mmap>(2), which fail with "
"the error B<ENOMEM> upon encountering the soft limit of this resource."
msgstr ""

#. type: TP
#: build/C/man2/getrlimit.2:197
#, no-wrap
msgid "B<RLIMIT_FSIZE>"
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:209
msgid ""
"This is the maximum size in bytes of files that the process may create.  "
"Attempts to extend a file beyond this limit result in delivery of a "
"B<SIGXFSZ> signal.  By default, this signal terminates a process, but a "
"process can catch this signal instead, in which case the relevant system "
"call (e.g., B<write>(2), B<truncate>(2))  fails with the error B<EFBIG>."
msgstr ""

#. type: TP
#: build/C/man2/getrlimit.2:209
#, no-wrap
msgid "B<RLIMIT_LOCKS> (Linux 2.4.0 to 2.4.24)"
msgstr ""

#.  to be precise: Linux 2.4.0-test9; no longer in 2.4.25 / 2.5.65
#. type: Plain text
#: build/C/man2/getrlimit.2:217
msgid ""
"This is a limit on the combined number of B<flock>(2)  locks and B<fcntl>(2)  "
"leases that this process may establish."
msgstr ""

#. type: TP
#: build/C/man2/getrlimit.2:217
#, no-wrap
msgid "B<RLIMIT_MEMLOCK>"
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:249
msgid ""
"This is the maximum number of bytes of memory that may be locked into RAM.  "
"This limit is in effect rounded down to the nearest multiple of the system "
"page size.  This limit affects B<mlock>(2), B<mlockall>(2), and the "
"B<mmap>(2)  B<MAP_LOCKED> operation.  Since Linux 2.6.9, it also affects the "
"B<shmctl>(2)  B<SHM_LOCK> operation, where it sets a maximum on the total "
"bytes in shared memory segments (see B<shmget>(2))  that may be locked by "
"the real user ID of the calling process.  The B<shmctl>(2)  B<SHM_LOCK> "
"locks are accounted for separately from the per-process memory locks "
"established by B<mlock>(2), B<mlockall>(2), and B<mmap>(2)  B<MAP_LOCKED>; a "
"process can lock bytes up to this limit in each of these two categories."
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:255
msgid ""
"In Linux kernels before 2.6.9, this limit controlled the amount of memory "
"that could be locked by a privileged process.  Since Linux 2.6.9, no limits "
"are placed on the amount of memory that a privileged process may lock, and "
"this limit instead governs the amount of memory that an unprivileged process "
"may lock."
msgstr ""

#. type: TP
#: build/C/man2/getrlimit.2:255
#, no-wrap
msgid "B<RLIMIT_MSGQUEUE> (since Linux 2.6.8)"
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:263
msgid ""
"This is a limit on the number of bytes that can be allocated for POSIX "
"message queues for the real user ID of the calling process.  This limit is "
"enforced for B<mq_open>(3).  Each message queue that the user creates counts "
"(until it is removed)  against this limit according to the formula:"
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:265
#, no-wrap
msgid "    Since Linux 3.5:\n"
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:273
#, no-wrap
msgid ""
"        bytes = attr.mq_maxmsg * sizeof(struct msg_msg) +\n"
"                min(attr.mq_maxmsg, MQ_PRIO_MAX) *\n"
"                      sizeof(struct posix_msg_tree_node)+\n"
"                                /* For overhead */\n"
"                attr.mq_maxmsg * attr.mq_msgsize;\n"
"                                /* For message data */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:276
#, no-wrap
msgid "    Linux 3.4 and earlier:\n"
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:282
#, no-wrap
msgid ""
"        bytes = attr.mq_maxmsg * sizeof(struct msg_msg *) +\n"
"                                /* For overhead */\n"
"                attr.mq_maxmsg * attr.mq_msgsize;\n"
"                                /* For message data */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:295
msgid ""
"where I<attr> is the I<mq_attr> structure specified as the fourth argument "
"to B<mq_open>(3), and the I<msg_msg> and I<posix_msg_tree_node> structures "
"are kernel-internal structures."
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:301
msgid ""
"The \"overhead\" addend in the formula accounts for overhead bytes required "
"by the implementation and ensures that the user cannot create an unlimited "
"number of zero-length messages (such messages nevertheless each consume some "
"system memory for bookkeeping overhead)."
msgstr ""

#. type: TP
#: build/C/man2/getrlimit.2:301
#, no-wrap
msgid "B<RLIMIT_NICE> (since Linux 2.6.12, but see BUGS below)"
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:320
msgid ""
"This specifies a ceiling to which the process's nice value can be raised "
"using B<setpriority>(2)  or B<nice>(2).  The actual ceiling for the nice "
"value is calculated as I<20\\ -\\ rlim_cur>.  The useful range for this "
"limit is thus from 1 (corresponding to a nice value of 19) to 40 "
"(corresponding to a nice value of -20).  This unusual choice of range was "
"necessary because negative numbers cannot be specified as resource limit "
"values, since they typically have special meanings.  For example, "
"B<RLIM_INFINITY> typically is the same as -1.  For more detail on the nice "
"value, see B<sched>(7)."
msgstr ""

#. type: TP
#: build/C/man2/getrlimit.2:320
#, no-wrap
msgid "B<RLIMIT_NOFILE>"
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:334
msgid ""
"This specifies a value one greater than the maximum file descriptor number "
"that can be opened by this process.  Attempts (B<open>(2), B<pipe>(2), "
"B<dup>(2), etc.)  to exceed this limit yield the error B<EMFILE>.  "
"(Historically, this limit was named B<RLIMIT_OFILE> on BSD.)"
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:346
msgid ""
"Since Linux 4.5, this limit also defines the maximum number of file "
"descriptors that an unprivileged process (one without the "
"B<CAP_SYS_RESOURCE> capability) may have \"in flight\" to other processes, "
"by being passed across UNIX domain sockets.  This limit applies to the "
"B<sendmsg>(2)  system call.  For further details, see B<unix>(7)."
msgstr ""

#. type: TP
#: build/C/man2/getrlimit.2:346
#, no-wrap
msgid "B<RLIMIT_NPROC>"
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:356
msgid ""
"This is a limit on the number of extant process (or, more precisely on "
"Linux, threads)  for the real user ID of the calling process.  So long as "
"the current number of processes belonging to this process's real user ID is "
"greater than or equal to this limit, B<fork>(2)  fails with the error "
"B<EAGAIN>."
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:364
msgid ""
"The B<RLIMIT_NPROC> limit is not enforced for processes that have either the "
"B<CAP_SYS_ADMIN> or the B<CAP_SYS_RESOURCE> capability."
msgstr ""

#. type: TP
#: build/C/man2/getrlimit.2:364
#, no-wrap
msgid "B<RLIMIT_RSS>"
msgstr ""

#.  As at kernel 2.6.12, this limit still does nothing in 2.6 though
#.  talk of making it do something has surfaced from time to time in LKML
#.        -- MTK, Jul 05
#. type: Plain text
#: build/C/man2/getrlimit.2:376
msgid ""
"This is a limit (in bytes) on the process's resident set (the number of "
"virtual pages resident in RAM).  This limit has effect only in Linux 2.4.x, "
"x E<lt> 30, and there affects only calls to B<madvise>(2)  specifying "
"B<MADV_WILLNEED>."
msgstr ""

#. type: TP
#: build/C/man2/getrlimit.2:376
#, no-wrap
msgid "B<RLIMIT_RTPRIO> (since Linux 2.6.12, but see BUGS)"
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:383
msgid ""
"This specifies a ceiling on the real-time priority that may be set for this "
"process using B<sched_setscheduler>(2)  and B<sched_setparam>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:386 build/C/man2/getrlimit.2:415
msgid "For further details on real-time scheduling policies, see B<sched>(7)"
msgstr ""

#. type: TP
#: build/C/man2/getrlimit.2:386
#, no-wrap
msgid "B<RLIMIT_RTTIME> (since Linux 2.6.25)"
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:398
msgid ""
"This is a limit (in microseconds)  on the amount of CPU time that a process "
"scheduled under a real-time scheduling policy may consume without making a "
"blocking system call.  For the purpose of this limit, each time a process "
"makes a blocking system call, the count of its consumed CPU time is reset to "
"zero.  The CPU time count is not reset if the process continues trying to "
"use the CPU but is preempted, its time slice expires, or it calls "
"B<sched_yield>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:409
msgid ""
"Upon reaching the soft limit, the process is sent a B<SIGXCPU> signal.  If "
"the process catches or ignores this signal and continues consuming CPU time, "
"then B<SIGXCPU> will be generated once each second until the hard limit is "
"reached, at which point the process is sent a B<SIGKILL> signal."
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:412
msgid ""
"The intended use of this limit is to stop a runaway real-time process from "
"locking up the system."
msgstr ""

#. type: TP
#: build/C/man2/getrlimit.2:415
#, no-wrap
msgid "B<RLIMIT_SIGPENDING> (since Linux 2.6.8)"
msgstr ""

#.  This replaces the /proc/sys/kernel/rtsig-max system-wide limit
#.  that was present in kernels <= 2.6.7.  MTK Dec 04
#. type: Plain text
#: build/C/man2/getrlimit.2:429
msgid ""
"This is a limit on the number of signals that may be queued for the real "
"user ID of the calling process.  Both standard and real-time signals are "
"counted for the purpose of checking this limit.  However, the limit is "
"enforced only for B<sigqueue>(3); it is always possible to use B<kill>(2)  "
"to queue one instance of any of the signals that are not already queued to "
"the process."
msgstr ""

#. type: TP
#: build/C/man2/getrlimit.2:429
#, no-wrap
msgid "B<RLIMIT_STACK>"
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:437
msgid ""
"This is the maximum size of the process stack, in bytes.  Upon reaching this "
"limit, a B<SIGSEGV> signal is generated.  To handle this signal, a process "
"must employ an alternate signal stack (B<sigaltstack>(2))."
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:442
msgid ""
"Since Linux 2.6.23, this limit also determines the amount of space used for "
"the process's command-line arguments and environment variables; for details, "
"see B<execve>(2)."
msgstr ""

#. type: SS
#: build/C/man2/getrlimit.2:442
#, no-wrap
msgid "prlimit()"
msgstr ""

#.  commit c022a0acad534fd5f5d5f17280f6d4d135e74e81
#.  Author: Jiri Slaby <jslaby@suse.cz>
#.  Date:   Tue May 4 18:03:50 2010 +0200
#
#.      rlimits: implement prlimit64 syscall
#
#.  commit 6a1d5e2c85d06da35cdfd93f1a27675bfdc3ad8c
#.  Author: Jiri Slaby <jslaby@suse.cz>
#.  Date:   Wed Mar 24 17:06:58 2010 +0100
#
#.      rlimits: add rlimit64 structure
#. type: Plain text
#: build/C/man2/getrlimit.2:462
msgid ""
"The Linux-specific B<prlimit>()  system call combines and extends the "
"functionality of B<setrlimit>()  and B<getrlimit>().  It can be used to both "
"set and get the resource limits of an arbitrary process."
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:469
msgid ""
"The I<resource> argument has the same meaning as for B<setrlimit>()  and "
"B<getrlimit>()."
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:487
msgid ""
"If the I<new_limit> argument is a not NULL, then the I<rlimit> structure to "
"which it points is used to set new values for the soft and hard limits for "
"I<resource>.  If the I<old_limit> argument is a not NULL, then a successful "
"call to B<prlimit>()  places the previous soft and hard limits for "
"I<resource> in the I<rlimit> structure pointed to by I<old_limit>."
msgstr ""

#.  FIXME . this permission check is strange
#.  Asked about this on LKML, 7 Nov 2010
#.      "Inconsistent credential checking in prlimit() syscall"
#. type: Plain text
#: build/C/man2/getrlimit.2:507
msgid ""
"The I<pid> argument specifies the ID of the process on which the call is to "
"operate.  If I<pid> is 0, then the call applies to the calling process.  To "
"set or get the resources of a process other than itself, the caller must "
"have the B<CAP_SYS_RESOURCE> capability in the user namespace of the process "
"whose resource limits are being changed, or the real, effective, and saved "
"set user IDs of the target process must match the real user ID of the caller "
"I<and> the real, effective, and saved set group IDs of the target process "
"must match the real group ID of the caller."
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:512
msgid ""
"On success, these system calls return 0.  On error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:517
msgid ""
"A pointer argument points to a location outside the accessible address "
"space."
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:529
msgid ""
"The value specified in I<resource> is not valid; or, for B<setrlimit>()  or "
"B<prlimit>(): I<rlim-E<gt>rlim_cur> was greater than I<rlim-E<gt>rlim_max>."
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:534
msgid ""
"An unprivileged process tried to raise the hard limit; the "
"B<CAP_SYS_RESOURCE> capability is required to do this."
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:542
msgid ""
"The caller tried to increase the hard B<RLIMIT_NOFILE> limit above the "
"maximum defined by I</proc/sys/fs/nr_open> (see B<proc>(5))"
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:548
msgid ""
"(B<prlimit>())  The calling process did not have permission to set limits "
"for the process specified by I<pid>."
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:552
msgid "Could not find a process with the ID specified in I<pid>."
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:557
msgid ""
"The B<prlimit>()  system call is available since Linux 2.6.36.  Library "
"support is available since glibc 2.13."
msgstr ""

#. type: SH
#: build/C/man2/getrlimit.2:557 build/C/man2/getrusage.2:200 build/C/man3/ulimit.3:78
#, no-wrap
msgid "ATTRIBUTES"
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:560 build/C/man2/getrusage.2:203 build/C/man3/ulimit.3:81
msgid "For an explanation of the terms used in this section, see B<attributes>(7)."
msgstr ""

#. type: tbl table
#: build/C/man2/getrlimit.2:564 build/C/man2/getrusage.2:207 build/C/man3/ulimit.3:85
#, no-wrap
msgid "Interface"
msgstr ""

#. type: tbl table
#: build/C/man2/getrlimit.2:564 build/C/man2/getrusage.2:207 build/C/man3/ulimit.3:85
#, no-wrap
msgid "Attribute"
msgstr ""

#. type: tbl table
#: build/C/man2/getrlimit.2:564 build/C/man2/getrusage.2:207 build/C/man3/ulimit.3:85
#, no-wrap
msgid "Value"
msgstr ""

#. type: tbl table
#: build/C/man2/getrlimit.2:569
#, no-wrap
msgid ""
"B<getrlimit>(),\n"
"B<setrlimit>(),\n"
"B<prlimit>()"
msgstr ""

#. type: tbl table
#: build/C/man2/getrlimit.2:569 build/C/man2/getrusage.2:210 build/C/man3/ulimit.3:88
#, no-wrap
msgid "Thread safety"
msgstr ""

#. type: tbl table
#: build/C/man2/getrlimit.2:569 build/C/man2/getrusage.2:210 build/C/man3/ulimit.3:88
#, no-wrap
msgid "MT-Safe"
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:576
msgid "B<getrlimit>(), B<setrlimit>(): POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD."
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:579
msgid "B<prlimit>(): Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:595
msgid ""
"B<RLIMIT_MEMLOCK> and B<RLIMIT_NPROC> derive from BSD and are not specified "
"in POSIX.1; they are present on the BSDs and Linux, but on few other "
"implementations.  B<RLIMIT_RSS> derives from BSD and is not specified in "
"POSIX.1; it is nevertheless present on most implementations.  "
"B<RLIMIT_MSGQUEUE>, B<RLIMIT_NICE>, B<RLIMIT_RTPRIO>, B<RLIMIT_RTTIME>, and "
"B<RLIMIT_SIGPENDING> are Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:601
msgid ""
"A child process created via B<fork>(2)  inherits its parent's resource "
"limits.  Resource limits are preserved across B<execve>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:604
msgid ""
"Resource limits are per-process attributes that are shared by all of the "
"threads in a process."
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:609
msgid ""
"Lowering the soft limit for a resource below the process's current "
"consumption of that resource will succeed (but will prevent the process from "
"further increasing its consumption of the resource)."
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:618
msgid ""
"One can set the resource limits of the shell using the built-in I<ulimit> "
"command (I<limit> in B<csh>(1)).  The shell's resource limits are inherited "
"by the processes that it creates to execute commands."
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:623
msgid ""
"Since Linux 2.6.24, the resource limits of any process can be inspected via "
"I</proc/[pid]/limits>; see B<proc>(5)."
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:632
msgid ""
"Ancient systems provided a B<vlimit>()  function with a similar purpose to "
"B<setrlimit>().  For backward compatibility, glibc also provides "
"B<vlimit>().  All new applications should be written using B<setrlimit>()."
msgstr ""

#. type: SS
#: build/C/man2/getrlimit.2:632
#, no-wrap
msgid "C library/kernel ABI differences"
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:641
msgid ""
"Since version 2.13, the glibc B<getrlimit>()  and B<setrlimit>()  wrapper "
"functions no longer invoke the corresponding system calls, but instead "
"employ B<prlimit>(), for the reasons described in BUGS."
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:646
msgid ""
"The name of the glibc wrapper function is B<prlimit>(); the underlying "
"system call is B<prlimit64>()."
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:655
msgid ""
"In older Linux kernels, the B<SIGXCPU> and B<SIGKILL> signals delivered when "
"a process encountered the soft and hard B<RLIMIT_CPU> limits were delivered "
"one (CPU) second later than they should have been.  This was fixed in kernel "
"2.6.8."
msgstr ""

#.  see http://marc.theaimsgroup.com/?l=linux-kernel&m=114008066530167&w=2
#. type: Plain text
#: build/C/man2/getrlimit.2:663
msgid ""
"In 2.6.x kernels before 2.6.17, a B<RLIMIT_CPU> limit of 0 is wrongly "
"treated as \"no limit\" (like B<RLIM_INFINITY>).  Since Linux 2.6.17, "
"setting a limit of 0 does have an effect, but is actually treated as a limit "
"of 1 second."
msgstr ""

#.  See https://lwn.net/Articles/145008/
#. type: Plain text
#: build/C/man2/getrlimit.2:668
msgid ""
"A kernel bug means that B<RLIMIT_RTPRIO> does not work in kernel 2.6.12; the "
"problem is fixed in kernel 2.6.13."
msgstr ""

#.  see http://marc.theaimsgroup.com/?l=linux-kernel&m=112256338703880&w=2
#. type: Plain text
#: build/C/man2/getrlimit.2:679
msgid ""
"In kernel 2.6.12, there was an off-by-one mismatch between the priority "
"ranges returned by B<getpriority>(2)  and B<RLIMIT_NICE>.  This had the "
"effect that the actual ceiling for the nice value was calculated as I<19\\ "
"-\\ rlim_cur>.  This was fixed in kernel 2.6.13."
msgstr ""

#.  The relevant patch, sent to LKML, seems to be
#.  http://thread.gmane.org/gmane.linux.kernel/273462
#.  From: Roland McGrath <roland <at> redhat.com>
#.  Subject: [PATCH 7/7] make RLIMIT_CPU/SIGXCPU per-process
#.  Date: 2005-01-23 23:27:46 GMT
#.  Tested Solaris 10, FreeBSD 9, OpenBSD 5.0
#.  FIXME . https://bugzilla.kernel.org/show_bug.cgi?id=50951
#. type: Plain text
#: build/C/man2/getrlimit.2:706
msgid ""
"Since Linux 2.6.12, if a process reaches its soft B<RLIMIT_CPU> limit and "
"has a handler installed for B<SIGXCPU>, then, in addition to invoking the "
"signal handler, the kernel increases the soft limit by one second.  This "
"behavior repeats if the process continues to consume CPU time, until the "
"hard limit is reached, at which point the process is killed.  Other "
"implementations do not change the B<RLIMIT_CPU> soft limit in this manner, "
"and the Linux behavior is probably not standards conformant; portable "
"applications should avoid relying on this Linux-specific behavior.  The "
"Linux-specific B<RLIMIT_RTTIME> limit exhibits the same behavior when the "
"soft limit is encountered."
msgstr ""

#.  d3561f78fd379a7110e46c87964ba7aa4120235c
#. type: Plain text
#: build/C/man2/getrlimit.2:716
msgid ""
"Kernels before 2.4.22 did not diagnose the error B<EINVAL> for "
"B<setrlimit>()  when I<rlim-E<gt>rlim_cur> was greater than "
"I<rlim-E<gt>rlim_max>."
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:721
msgid ""
"Linux doesn't return an error when an attempt to set B<RLIMIT_CPU> has "
"failed, for compatibility reasons."
msgstr ""

#. type: SS
#: build/C/man2/getrlimit.2:721
#, no-wrap
msgid "Representation of \"large\" resource limit values on 32-bit platforms"
msgstr ""

#.  Linux still uses long for limits internally:
#.  c022a0acad534fd5f5d5f17280f6d4d135e74e81
#.  kernel/sys.c:do_prlimit() still uses struct rlimit which
#.  uses kernel_ulong_t for its members, i.e. 32-bit  on 32-bit kernel.
#.  https://bugzilla.kernel.org/show_bug.cgi?id=5042
#.  http://sources.redhat.com/bugzilla/show_bug.cgi?id=12201
#. type: Plain text
#: build/C/man2/getrlimit.2:756
msgid ""
"The glibc B<getrlimit>()  and B<setrlimit>()  wrapper functions use a 64-bit "
"I<rlim_t> data type, even on 32-bit platforms.  However, the I<rlim_t> data "
"type used in the B<getrlimit>()  and B<setrlimit>()  system calls is a "
"(32-bit)  I<unsigned long>.  Furthermore, in Linux, the kernel represents "
"resource limits on 32-bit platforms as I<unsigned long>.  However, a 32-bit "
"data type is not wide enough.  The most pertinent limit here is "
"B<RLIMIT_FSIZE>, which specifies the maximum size to which a file can grow: "
"to be useful, this limit must be represented using a type that is as wide as "
"the type used to represent file offsets\\(emthat is, as wide as a 64-bit "
"B<off_t> (assuming a program compiled with I<_FILE_OFFSET_BITS=64>)."
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:766
msgid ""
"To work around this kernel limitation, if a program tried to set a resource "
"limit to a value larger than can be represented in a 32-bit I<unsigned "
"long>, then the glibc B<setrlimit>()  wrapper function silently converted "
"the limit value to B<RLIM_INFINITY>.  In other words, the requested resource "
"limit setting was silently ignored."
msgstr ""

#.  https://www.sourceware.org/bugzilla/show_bug.cgi?id=12201
#. type: Plain text
#: build/C/man2/getrlimit.2:779
msgid ""
"Since version 2.13, glibc works around the limitations of the B<getrlimit>()  "
"and B<setrlimit>()  system calls by implementing B<setrlimit>()  and "
"B<getrlimit>()  as wrapper functions that call B<prlimit>()."
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:782
msgid "The program below demonstrates the use of B<prlimit>()."
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:792
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#define _FILE_OFFSET_BITS 64\n"
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/resource.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:795
#, no-wrap
msgid ""
"#define errExit(msg) do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                        } while (0)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:802
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct rlimit old, new;\n"
"    struct rlimit *newp;\n"
"    pid_t pid;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:808
#, no-wrap
msgid ""
"    if (!(argc == 2 || argc == 4)) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>pidE<gt> [E<lt>new-soft-limitE<gt> "
"\"\n"
"                \"E<lt>new-hard-limitE<gt>]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:810
#, no-wrap
msgid "    pid = atoi(argv[1]);        /* PID of target process */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:817
#, no-wrap
msgid ""
"    newp = NULL;\n"
"    if (argc == 4) {\n"
"        new.rlim_cur = atoi(argv[2]);\n"
"        new.rlim_max = atoi(argv[3]);\n"
"        newp = &new;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:820
#, no-wrap
msgid ""
"    /* Set CPU time limit of target process; retrieve and display\n"
"       previous limit */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:825
#, no-wrap
msgid ""
"    if (prlimit(pid, RLIMIT_CPU, newp, &old) == -1)\n"
"        errExit(\"prlimit-1\");\n"
"    printf(\"Previous limits: soft=%jd; hard=%jd\\en\",\n"
"            (intmax_t) old.rlim_cur, (intmax_t) old.rlim_max);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:827
#, no-wrap
msgid "    /* Retrieve and display new CPU time limit */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:832
#, no-wrap
msgid ""
"    if (prlimit(pid, RLIMIT_CPU, NULL, &old) == -1)\n"
"        errExit(\"prlimit-2\");\n"
"    printf(\"New limits: soft=%jd; hard=%jd\\en\",\n"
"            (intmax_t) old.rlim_cur, (intmax_t) old.rlim_max);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:835 build/C/man2/pidfd_send_signal.2:247 build/C/man3/posix_spawn.3:807
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:856
msgid ""
"B<prlimit>(1), B<dup>(2), B<fcntl>(2), B<fork>(2), B<getrusage>(2), "
"B<mlock>(2), B<mmap>(2), B<open>(2), B<quotactl>(2), B<sbrk>(2), "
"B<shmctl>(2), B<malloc>(3), B<sigqueue>(3), B<ulimit>(3), B<core>(5), "
"B<capabilities>(7), B<cgroups>(7), B<credentials>(7), B<signal>(7)"
msgstr ""

#. type: TH
#: build/C/man2/getrusage.2:39
#, no-wrap
msgid "GETRUSAGE"
msgstr ""

#. type: TH
#: build/C/man2/getrusage.2:39
#, no-wrap
msgid "2020-12-21"
msgstr ""

#. type: Plain text
#: build/C/man2/getrusage.2:42
msgid "getrusage - get resource usage"
msgstr ""

#. type: Plain text
#: build/C/man2/getrusage.2:48
msgid "B<int getrusage(int >I<who>B<, struct rusage *>I<usage>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/getrusage.2:53
msgid ""
"B<getrusage>()  returns resource usage measures for I<who>, which can be one "
"of the following:"
msgstr ""

#. type: TP
#: build/C/man2/getrusage.2:53
#, no-wrap
msgid "B<RUSAGE_SELF>"
msgstr ""

#. type: Plain text
#: build/C/man2/getrusage.2:57
msgid ""
"Return resource usage statistics for the calling process, which is the sum "
"of resources used by all threads in the process."
msgstr ""

#. type: TP
#: build/C/man2/getrusage.2:57
#, no-wrap
msgid "B<RUSAGE_CHILDREN>"
msgstr ""

#. type: Plain text
#: build/C/man2/getrusage.2:64
msgid ""
"Return resource usage statistics for all children of the calling process "
"that have terminated and been waited for.  These statistics will include the "
"resources used by grandchildren, and further removed descendants, if all of "
"the intervening descendants waited on their terminated children."
msgstr ""

#. type: TP
#: build/C/man2/getrusage.2:64
#, no-wrap
msgid "B<RUSAGE_THREAD> (since Linux 2.6.26)"
msgstr ""

#. type: Plain text
#: build/C/man2/getrusage.2:74
msgid ""
"Return resource usage statistics for the calling thread.  The B<_GNU_SOURCE> "
"feature test macro must be defined (before including I<any> header file)  in "
"order to obtain the definition of this constant from "
"I<E<lt>sys/resource.hE<gt>>."
msgstr ""

#. type: Plain text
#: build/C/man2/getrusage.2:78
msgid ""
"The resource usages are returned in the structure pointed to by I<usage>, "
"which has the following form:"
msgstr ""

#. type: Plain text
#: build/C/man2/getrusage.2:99
#, no-wrap
msgid ""
"struct rusage {\n"
"    struct timeval ru_utime; /* user CPU time used */\n"
"    struct timeval ru_stime; /* system CPU time used */\n"
"    long   ru_maxrss;        /* maximum resident set size */\n"
"    long   ru_ixrss;         /* integral shared memory size */\n"
"    long   ru_idrss;         /* integral unshared data size */\n"
"    long   ru_isrss;         /* integral unshared stack size */\n"
"    long   ru_minflt;        /* page reclaims (soft page faults) */\n"
"    long   ru_majflt;        /* page faults (hard page faults) */\n"
"    long   ru_nswap;         /* swaps */\n"
"    long   ru_inblock;       /* block input operations */\n"
"    long   ru_oublock;       /* block output operations */\n"
"    long   ru_msgsnd;        /* IPC messages sent */\n"
"    long   ru_msgrcv;        /* IPC messages received */\n"
"    long   ru_nsignals;      /* signals received */\n"
"    long   ru_nvcsw;         /* voluntary context switches */\n"
"    long   ru_nivcsw;        /* involuntary context switches */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/getrusage.2:107
msgid ""
"Not all fields are completed; unmaintained fields are set to zero by the "
"kernel.  (The unmaintained fields are provided for compatibility with other "
"systems, and because they may one day be supported on Linux.)  The fields "
"are interpreted as follows:"
msgstr ""

#. type: TP
#: build/C/man2/getrusage.2:107
#, no-wrap
msgid "I<ru_utime>"
msgstr ""

#. type: Plain text
#: build/C/man2/getrusage.2:113
msgid ""
"This is the total amount of time spent executing in user mode, expressed in "
"a I<timeval> structure (seconds plus microseconds)."
msgstr ""

#. type: TP
#: build/C/man2/getrusage.2:113
#, no-wrap
msgid "I<ru_stime>"
msgstr ""

#. type: Plain text
#: build/C/man2/getrusage.2:119
msgid ""
"This is the total amount of time spent executing in kernel mode, expressed "
"in a I<timeval> structure (seconds plus microseconds)."
msgstr ""

#. type: TP
#: build/C/man2/getrusage.2:119
#, no-wrap
msgid "I<ru_maxrss> (since Linux 2.6.32)"
msgstr ""

#. type: Plain text
#: build/C/man2/getrusage.2:126
msgid ""
"This is the maximum resident set size used (in kilobytes).  For "
"B<RUSAGE_CHILDREN>, this is the resident set size of the largest child, not "
"the maximum resident set size of the process tree."
msgstr ""

#. type: TP
#: build/C/man2/getrusage.2:126
#, no-wrap
msgid "I<ru_ixrss> (unmaintained)"
msgstr ""

#.  On some systems, this field records the number of signals received.
#. type: Plain text
#: build/C/man2/getrusage.2:132 build/C/man2/getrusage.2:137 build/C/man2/getrusage.2:142 build/C/man2/getrusage.2:154 build/C/man2/getrusage.2:166 build/C/man2/getrusage.2:172 build/C/man2/getrusage.2:176
msgid "This field is currently unused on Linux."
msgstr ""

#. type: TP
#: build/C/man2/getrusage.2:132
#, no-wrap
msgid "I<ru_idrss> (unmaintained)"
msgstr ""

#. type: TP
#: build/C/man2/getrusage.2:137
#, no-wrap
msgid "I<ru_isrss> (unmaintained)"
msgstr ""

#. type: TP
#: build/C/man2/getrusage.2:142
#, no-wrap
msgid "I<ru_minflt>"
msgstr ""

#. type: Plain text
#: build/C/man2/getrusage.2:147
msgid ""
"The number of page faults serviced without any I/O activity; here I/O "
"activity is avoided by ``reclaiming'' a page frame from the list of pages "
"awaiting reallocation."
msgstr ""

#. type: TP
#: build/C/man2/getrusage.2:147
#, no-wrap
msgid "I<ru_majflt>"
msgstr ""

#. type: Plain text
#: build/C/man2/getrusage.2:150
msgid "The number of page faults serviced that required I/O activity."
msgstr ""

#. type: TP
#: build/C/man2/getrusage.2:150
#, no-wrap
msgid "I<ru_nswap> (unmaintained)"
msgstr ""

#. type: TP
#: build/C/man2/getrusage.2:154
#, no-wrap
msgid "I<ru_inblock> (since Linux 2.6.22)"
msgstr ""

#. type: Plain text
#: build/C/man2/getrusage.2:157
msgid "The number of times the filesystem had to perform input."
msgstr ""

#. type: TP
#: build/C/man2/getrusage.2:157
#, no-wrap
msgid "I<ru_oublock> (since Linux 2.6.22)"
msgstr ""

#. type: Plain text
#: build/C/man2/getrusage.2:160
msgid "The number of times the filesystem had to perform output."
msgstr ""

#. type: TP
#: build/C/man2/getrusage.2:160
#, no-wrap
msgid "I<ru_msgsnd> (unmaintained)"
msgstr ""

#. type: TP
#: build/C/man2/getrusage.2:166
#, no-wrap
msgid "I<ru_msgrcv> (unmaintained)"
msgstr ""

#. type: TP
#: build/C/man2/getrusage.2:172
#, no-wrap
msgid "I<ru_nsignals> (unmaintained)"
msgstr ""

#. type: TP
#: build/C/man2/getrusage.2:176
#, no-wrap
msgid "I<ru_nvcsw> (since Linux 2.6)"
msgstr ""

#. type: Plain text
#: build/C/man2/getrusage.2:181
msgid ""
"The number of times a context switch resulted due to a process voluntarily "
"giving up the processor before its time slice was completed (usually to "
"await availability of a resource)."
msgstr ""

#. type: TP
#: build/C/man2/getrusage.2:181
#, no-wrap
msgid "I<ru_nivcsw> (since Linux 2.6)"
msgstr ""

#. type: Plain text
#: build/C/man2/getrusage.2:186
msgid ""
"The number of times a context switch resulted due to a higher priority "
"process becoming runnable or because the current process exceeded its time "
"slice."
msgstr ""

#. type: Plain text
#: build/C/man2/getrusage.2:196
msgid "I<usage> points outside the accessible address space."
msgstr ""

#. type: Plain text
#: build/C/man2/getrusage.2:200
msgid "I<who> is invalid."
msgstr ""

#. type: tbl table
#: build/C/man2/getrusage.2:210
#, no-wrap
msgid "B<getrusage>()"
msgstr ""

#. type: Plain text
#: build/C/man2/getrusage.2:221
msgid ""
"POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD.  POSIX.1 specifies B<getrusage>(), "
"but specifies only the fields I<ru_utime> and I<ru_stime>."
msgstr ""

#. type: Plain text
#: build/C/man2/getrusage.2:224
msgid "B<RUSAGE_THREAD> is Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man2/getrusage.2:227
msgid "Resource usage metrics are preserved across an B<execve>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/getrusage.2:235
msgid ""
"Including I<E<lt>sys/time.hE<gt>> is not required these days, but increases "
"portability.  (Indeed, I<struct timeval> is defined in "
"I<E<lt>sys/time.hE<gt>>.)"
msgstr ""

#.  See the description of getrusage() in XSH.
#.  A similar statement was also in SUSv2.
#. type: Plain text
#: build/C/man2/getrusage.2:247
msgid ""
"In Linux kernel versions before 2.6.9, if the disposition of B<SIGCHLD> is "
"set to B<SIG_IGN> then the resource usages of child processes are "
"automatically included in the value returned by B<RUSAGE_CHILDREN>, although "
"POSIX.1-2001 explicitly prohibits this.  This nonconformance is rectified in "
"Linux 2.6.9 and later."
msgstr ""

#. type: Plain text
#: build/C/man2/getrusage.2:250
msgid ""
"The structure definition shown at the start of this page was taken from "
"4.3BSD Reno."
msgstr ""

#. type: Plain text
#: build/C/man2/getrusage.2:259
msgid ""
"Ancient systems provided a B<vtimes>()  function with a similar purpose to "
"B<getrusage>().  For backward compatibility, glibc (up until version 2.32) "
"also provides B<vtimes>().  All new applications should be written using "
"B<getrusage>()."
msgstr ""

#. type: Plain text
#: build/C/man2/getrusage.2:264
msgid "See also the description of I</proc/[pid]/stat> in B<proc>(5)."
msgstr ""

#. type: Plain text
#: build/C/man2/getrusage.2:271
msgid ""
"B<clock_gettime>(2), B<getrlimit>(2), B<times>(2), B<wait>(2), B<wait4>(2), "
"B<clock>(3)"
msgstr ""

#. type: TH
#: build/C/man2/getsid.2:27
#, no-wrap
msgid "GETSID"
msgstr ""

#. type: Plain text
#: build/C/man2/getsid.2:30
msgid "getsid - get session ID"
msgstr ""

#. type: Plain text
#: build/C/man2/getsid.2:36
msgid "B<pid_t getsid(pid_t>I< pid>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/getsid.2:45
msgid "B<getsid>():"
msgstr ""

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: build/C/man2/getsid.2:49 build/C/man2/setpgid.2:79
#, no-wrap
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* Since glibc 2.12: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L\n"
msgstr ""

#. type: Plain text
#: build/C/man2/getsid.2:63
msgid ""
"I<getsid(0)> returns the session ID of the calling process.  B<getsid>()  "
"returns the session ID of the process with process ID I<pid>.  If I<pid> is "
"0, B<getsid>()  returns the session ID of the calling process."
msgstr ""

#. type: Plain text
#: build/C/man2/getsid.2:68
msgid ""
"On success, a session ID is returned.  On error, I<(pid_t)\\ -1> will be "
"returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/getsid.2:75
msgid ""
"A process with process ID I<pid> exists, but it is not in the same session "
"as the calling process, and the implementation considers this an error."
msgstr ""

#. type: Plain text
#: build/C/man2/getsid.2:80
msgid "No process with process ID I<pid> was found."
msgstr ""

#.  Linux has this system call since Linux 1.3.44.
#.  There is libc support since libc 5.2.19.
#. type: Plain text
#: build/C/man2/getsid.2:84
msgid "This system call is available on Linux since version 2.0."
msgstr ""

#. type: Plain text
#: build/C/man2/getsid.2:86 build/C/man2/setgid.2:76 build/C/man2/setsid.2:75
msgid "POSIX.1-2001, POSIX.1-2008, SVr4."
msgstr ""

#. type: Plain text
#: build/C/man2/getsid.2:89
msgid "Linux does not return B<EPERM>."
msgstr ""

#. type: Plain text
#: build/C/man2/getsid.2:93
msgid "See B<credentials>(7)  for a description of sessions and session IDs."
msgstr ""

#. type: Plain text
#: build/C/man2/getsid.2:97
msgid "B<getpgid>(2), B<setsid>(2), B<credentials>(7)"
msgstr ""

#. type: TH
#: build/C/man2/getuid.2:26
#, no-wrap
msgid "GETUID"
msgstr ""

#. type: Plain text
#: build/C/man2/getuid.2:29
msgid "getuid, geteuid - get user identity"
msgstr ""

#. type: Plain text
#: build/C/man2/getuid.2:35
msgid "B<uid_t getuid(void);>"
msgstr ""

#. type: Plain text
#: build/C/man2/getuid.2:37
msgid "B<uid_t geteuid(void);>"
msgstr ""

#. type: Plain text
#: build/C/man2/getuid.2:40
msgid "B<getuid>()  returns the real user ID of the calling process."
msgstr ""

#. type: Plain text
#: build/C/man2/getuid.2:43
msgid "B<geteuid>()  returns the effective user ID of the calling process."
msgstr ""

#. type: SS
#: build/C/man2/getuid.2:48
#, no-wrap
msgid "History"
msgstr ""

#. type: Plain text
#: build/C/man2/getuid.2:57
msgid ""
"In UNIX\\ V6 the B<getuid>()  call returned I<(euid E<lt>E<lt> 8) + uid>.  "
"UNIX\\ V7 introduced separate calls B<getuid>()  and B<geteuid>()."
msgstr ""

#. type: Plain text
#: build/C/man2/getuid.2:73
msgid ""
"The original Linux B<getuid>()  and B<geteuid>()  system calls supported "
"only 16-bit user IDs.  Subsequently, Linux 2.4 added B<getuid32>()  and "
"B<geteuid32>(), supporting 32-bit IDs.  The glibc B<getuid>()  and "
"B<geteuid>()  wrapper functions transparently deal with the variations "
"across kernel versions."
msgstr ""

#. type: Plain text
#: build/C/man2/getuid.2:89
msgid ""
"On Alpha, instead of a pair of B<getuid>()  and B<geteuid>()  system calls, "
"a single B<getxuid>()  system call is provided, which returns a pair of real "
"and effective UIDs.  The glibc B<getuid>()  and B<geteuid>()  wrapper "
"functions transparently deal with this.  See B<syscall>(2)  for details "
"regarding register mapping."
msgstr ""

#. type: Plain text
#: build/C/man2/getuid.2:94
msgid "B<getresuid>(2), B<setreuid>(2), B<setuid>(2), B<credentials>(7)"
msgstr ""

#. type: TH
#: build/C/man3/group_member.3:25
#, no-wrap
msgid "GROUP_MEMBER"
msgstr ""

#. type: TH
#: build/C/man3/group_member.3:25
#, no-wrap
msgid "2014-03-30"
msgstr ""

#. type: TH
#: build/C/man3/group_member.3:25 build/C/man3/posix_spawn.3:31
#, no-wrap
msgid "GNU"
msgstr ""

#. type: Plain text
#: build/C/man3/group_member.3:28
msgid "group_member - test whether a process is in a group"
msgstr ""

#. type: Plain text
#: build/C/man3/group_member.3:32
msgid "B<int group_member(gid_t >I<gid>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/group_member.3:40
msgid "B<group_member>(): _GNU_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man3/group_member.3:48
msgid ""
"The B<group_member>()  function tests whether any of the caller's "
"supplementary group IDs (as returned by B<getgroups>(2))  matches I<gid>."
msgstr ""

#. type: Plain text
#: build/C/man3/group_member.3:55
msgid ""
"The B<group_member>()  function returns nonzero if any of the caller's "
"supplementary group IDs matches I<gid>, and zero otherwise."
msgstr ""

#. type: Plain text
#: build/C/man3/group_member.3:57
msgid "This function is a nonstandard GNU extension."
msgstr ""

#. type: Plain text
#: build/C/man3/group_member.3:62
msgid "B<getgid>(2), B<getgroups>(2), B<getgrouplist>(3), B<group>(5)"
msgstr ""

#. type: TH
#: build/C/man2/iopl.2:33
#, no-wrap
msgid "IOPL"
msgstr ""

#. type: Plain text
#: build/C/man2/iopl.2:36
msgid "iopl - change I/O privilege level"
msgstr ""

#. type: Plain text
#: build/C/man2/iopl.2:38
msgid "B<#include E<lt>sys/io.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man2/iopl.2:40
msgid "B<int iopl(int >I<level>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/iopl.2:45
msgid ""
"B<iopl>()  changes the I/O privilege level of the calling thread, as "
"specified by the two least significant bits in I<level>."
msgstr ""

#. type: Plain text
#: build/C/man2/iopl.2:48
msgid ""
"The I/O privilege level for a normal thread is 0.  Permissions are inherited "
"from parents to children."
msgstr ""

#. type: Plain text
#: build/C/man2/iopl.2:56
msgid ""
"This call is deprecated, is significantly slower than B<ioperm>(2), and is "
"only provided for older X servers which require access to all 65536 I/O "
"ports.  It is mostly for the i386 architecture.  On many other architectures "
"it does not exist or will always return an error."
msgstr ""

#. type: Plain text
#: build/C/man2/iopl.2:66
msgid "I<level> is greater than 3."
msgstr ""

#. type: Plain text
#: build/C/man2/iopl.2:69
msgid "This call is unimplemented."
msgstr ""

#. type: Plain text
#: build/C/man2/iopl.2:77
msgid ""
"The calling thread has insufficient privilege to call B<iopl>(); the "
"B<CAP_SYS_RAWIO> capability is required to raise the I/O privilege level "
"above its current value."
msgstr ""

#. type: Plain text
#: build/C/man2/iopl.2:81
msgid ""
"B<iopl>()  is Linux-specific and should not be used in programs that are "
"intended to be portable."
msgstr ""

#.  Libc5 treats it as a system call and has a prototype in
#.  .IR <unistd.h> .
#.  Glibc1 does not have a prototype.
#. type: Plain text
#: build/C/man2/iopl.2:90
msgid ""
"Glibc2 has a prototype both in I<E<lt>sys/io.hE<gt>> and in "
"I<E<lt>sys/perm.hE<gt>>.  Avoid the latter, it is available on i386 only."
msgstr ""

#. type: Plain text
#: build/C/man2/iopl.2:96
msgid ""
"Prior to Linux 5.5 B<iopl>()  allowed the thread to disable interrupts while "
"running at a higher I/O privilege level.  This will probably crash the "
"system, and is not recommended."
msgstr ""

#. type: Plain text
#: build/C/man2/iopl.2:106
msgid ""
"Prior to Linux 3.7, on some architectures (such as i386), permissions "
"I<were> inherited by the child produced by B<fork>(2)  and were preserved "
"across B<execve>(2).  This behavior was inadvertently changed in Linux 3.7, "
"and won't be reinstated."
msgstr ""

#. type: Plain text
#: build/C/man2/iopl.2:110
msgid "B<ioperm>(2), B<outb>(2), B<capabilities>(7)"
msgstr ""

#. type: TH
#: build/C/man2/ioprio_set.2:24
#, no-wrap
msgid "IOPRIO_SET"
msgstr ""

#. type: Plain text
#: build/C/man2/ioprio_set.2:27
msgid "ioprio_get, ioprio_set - get/set I/O scheduling class and priority"
msgstr ""

#. type: Plain text
#: build/C/man2/ioprio_set.2:31
#, no-wrap
msgid ""
"B<int ioprio_get(int >I<which>B<, int >I<who>B<);>\n"
"B<int ioprio_set(int >I<which>B<, int >I<who>B<, int >I<ioprio>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioprio_set.2:35
msgid "I<Note>: There are no glibc wrappers for these system calls; see NOTES."
msgstr ""

#. type: Plain text
#: build/C/man2/ioprio_set.2:42
msgid ""
"The B<ioprio_get>()  and B<ioprio_set>()  system calls get and set the I/O "
"scheduling class and priority of one or more threads."
msgstr ""

#. type: Plain text
#: build/C/man2/ioprio_set.2:54
msgid ""
"The I<which> and I<who> arguments identify the thread(s) on which the system "
"calls operate.  The I<which> argument determines how I<who> is interpreted, "
"and has one of the following values:"
msgstr ""

#. type: TP
#: build/C/man2/ioprio_set.2:54
#, no-wrap
msgid "B<IOPRIO_WHO_PROCESS>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioprio_set.2:61
msgid ""
"I<who> is a process ID or thread ID identifying a single process or thread.  "
"If I<who> is 0, then operate on the calling thread."
msgstr ""

#. type: TP
#: build/C/man2/ioprio_set.2:61
#, no-wrap
msgid "B<IOPRIO_WHO_PGRP>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioprio_set.2:68
msgid ""
"I<who> is a process group ID identifying all the members of a process "
"group.  If I<who> is 0, then operate on the process group of which the "
"caller is a member."
msgstr ""

#. type: TP
#: build/C/man2/ioprio_set.2:68
#, no-wrap
msgid "B<IOPRIO_WHO_USER>"
msgstr ""

#.  FIXME . Need to document the behavior when 'who" is specified as 0
#.  See http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=652443
#. type: Plain text
#: build/C/man2/ioprio_set.2:75
msgid ""
"I<who> is a user ID identifying all of the processes that have a matching "
"real UID."
msgstr ""

#. type: Plain text
#: build/C/man2/ioprio_set.2:98
msgid ""
"If I<which> is specified as B<IOPRIO_WHO_PGRP> or B<IOPRIO_WHO_USER> when "
"calling B<ioprio_get>(), and more than one process matches I<who>, then the "
"returned priority will be the highest one found among all of the matching "
"processes.  One priority is said to be higher than another one if it belongs "
"to a higher priority class (B<IOPRIO_CLASS_RT> is the highest priority "
"class; B<IOPRIO_CLASS_IDLE> is the lowest)  or if it belongs to the same "
"priority class as the other process but has a higher priority level (a lower "
"priority number means a higher priority level)."
msgstr ""

#. type: Plain text
#: build/C/man2/ioprio_set.2:108
msgid ""
"The I<ioprio> argument given to B<ioprio_set>()  is a bit mask that "
"specifies both the scheduling class and the priority to be assigned to the "
"target process(es).  The following macros are used for assembling and "
"dissecting I<ioprio> values:"
msgstr ""

#. type: TP
#: build/C/man2/ioprio_set.2:108
#, no-wrap
msgid "B<IOPRIO_PRIO_VALUE(>I<class>B<, >I<data>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioprio_set.2:117
msgid ""
"Given a scheduling I<class> and priority (I<data>), this macro combines the "
"two values to produce an I<ioprio> value, which is returned as the result of "
"the macro."
msgstr ""

#. type: TP
#: build/C/man2/ioprio_set.2:117
#, no-wrap
msgid "B<IOPRIO_PRIO_CLASS(>I<mask>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioprio_set.2:129
msgid ""
"Given I<mask> (an I<ioprio> value), this macro returns its I/O class "
"component, that is, one of the values B<IOPRIO_CLASS_RT>, "
"B<IOPRIO_CLASS_BE>, or B<IOPRIO_CLASS_IDLE>."
msgstr ""

#. type: TP
#: build/C/man2/ioprio_set.2:129
#, no-wrap
msgid "B<IOPRIO_PRIO_DATA(>I<mask>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioprio_set.2:138
msgid ""
"Given I<mask> (an I<ioprio> value), this macro returns its priority "
"(I<data>)  component."
msgstr ""

#. type: Plain text
#: build/C/man2/ioprio_set.2:144
msgid ""
"See the NOTES section for more information on scheduling classes and "
"priorities, as well as the meaning of specifying I<ioprio> as 0."
msgstr ""

#. type: Plain text
#: build/C/man2/ioprio_set.2:152
msgid ""
"I/O priorities are supported for reads and for synchronous (B<O_DIRECT>, "
"B<O_SYNC>)  writes.  I/O priorities are not supported for asynchronous "
"writes because they are issued outside the context of the program dirtying "
"the memory, and thus program-specific priorities do not apply."
msgstr ""

#. type: Plain text
#: build/C/man2/ioprio_set.2:165
msgid ""
"On success, B<ioprio_get>()  returns the I<ioprio> value of the process with "
"highest I/O priority of any of the processes that match the criteria "
"specified in I<which> and I<who>.  On error, -1 is returned, and I<errno> is "
"set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/ioprio_set.2:172
msgid ""
"On success, B<ioprio_set>()  returns 0.  On error, -1 is returned, and "
"I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/ioprio_set.2:182
msgid ""
"Invalid value for I<which> or I<ioprio>.  Refer to the NOTES section for "
"available scheduler classes and priority levels for I<ioprio>."
msgstr ""

#. type: Plain text
#: build/C/man2/ioprio_set.2:190
msgid ""
"The calling process does not have the privilege needed to assign this "
"I<ioprio> to the specified process(es).  See the NOTES section for more "
"information on required privileges for B<ioprio_set>()."
msgstr ""

#. type: Plain text
#: build/C/man2/ioprio_set.2:196
msgid ""
"No process(es) could be found that matched the specification in I<which> and "
"I<who>."
msgstr ""

#. type: Plain text
#: build/C/man2/ioprio_set.2:199
msgid "These system calls have been available on Linux since kernel 2.6.13."
msgstr ""

#. type: Plain text
#: build/C/man2/ioprio_set.2:204
msgid ""
"Glibc does not provide a wrapper for these system calls; call them using "
"B<syscall>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/ioprio_set.2:223
msgid ""
"Two or more processes or threads can share an I/O context.  This will be the "
"case when B<clone>(2)  was called with the B<CLONE_IO> flag.  However, by "
"default, the distinct threads of a process will B<not> share the same I/O "
"context.  This means that if you want to change the I/O priority of all "
"threads in a process, you may need to call B<ioprio_set>()  on each of the "
"threads.  The thread ID that you would need for this operation is the one "
"that is returned by B<gettid>(2)  or B<clone>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/ioprio_set.2:228
msgid ""
"These system calls have an effect only when used in conjunction with an I/O "
"scheduler that supports I/O priorities.  As at kernel 2.6.17 the only such "
"scheduler is the Completely Fair Queuing (CFQ) I/O scheduler."
msgstr ""

#.  commit 8ec680e4c3ec818efd1652f15199ed1c216ab550
#. type: Plain text
#: build/C/man2/ioprio_set.2:241
msgid ""
"If no I/O scheduler has been set for a thread, then by default the I/O "
"priority will follow the CPU nice value (B<setpriority>(2)).  In Linux "
"kernels before version 2.6.24, once an I/O priority had been set using "
"B<ioprio_set>(), there was no way to reset the I/O scheduling behavior to "
"the default.  Since Linux 2.6.24, specifying I<ioprio> as 0 can be used to "
"reset to the default I/O scheduling behavior."
msgstr ""

#. type: SS
#: build/C/man2/ioprio_set.2:241
#, no-wrap
msgid "Selecting an I/O scheduler"
msgstr ""

#. type: Plain text
#: build/C/man2/ioprio_set.2:245
msgid ""
"I/O schedulers are selected on a per-device basis via the special file "
"I</sys/block/E<lt>deviceE<gt>/queue/scheduler>."
msgstr ""

#. type: Plain text
#: build/C/man2/ioprio_set.2:251
msgid ""
"One can view the current I/O scheduler via the I</sys> filesystem.  For "
"example, the following command displays a list of all schedulers currently "
"loaded in the kernel:"
msgstr ""

#. type: Plain text
#: build/C/man2/ioprio_set.2:256
#, no-wrap
msgid ""
"$B< cat /sys/block/sda/queue/scheduler>\n"
"noop anticipatory deadline [cfq]\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioprio_set.2:270
msgid ""
"The scheduler surrounded by brackets is the one actually in use for the "
"device (I<sda> in the example).  Setting another scheduler is done by "
"writing the name of the new scheduler to this file.  For example, the "
"following command will set the scheduler for the I<sda> device to I<cfq>:"
msgstr ""

#. type: Plain text
#: build/C/man2/ioprio_set.2:276
#, no-wrap
msgid ""
"$B< su>\n"
"Password:\n"
"#B< echo cfq E<gt> /sys/block/sda/queue/scheduler>\n"
msgstr ""

#. type: SS
#: build/C/man2/ioprio_set.2:279
#, no-wrap
msgid "The Completely Fair Queuing (CFQ) I/O scheduler"
msgstr ""

#. type: Plain text
#: build/C/man2/ioprio_set.2:285
msgid ""
"Since version 3 (also known as CFQ Time Sliced), CFQ implements I/O nice "
"levels similar to those of CPU scheduling.  These nice levels are grouped "
"into three scheduling classes, each one containing one or more priority "
"levels:"
msgstr ""

#. type: TP
#: build/C/man2/ioprio_set.2:285
#, no-wrap
msgid "B<IOPRIO_CLASS_RT> (1)"
msgstr ""

#. type: Plain text
#: build/C/man2/ioprio_set.2:300
msgid ""
"This is the real-time I/O class.  This scheduling class is given higher "
"priority than any other class: processes from this class are given first "
"access to the disk every time.  Thus, this I/O class needs to be used with "
"some care: one I/O real-time process can starve the entire system.  Within "
"the real-time class, there are 8 levels of class data (priority) that "
"determine exactly how much time this process needs the disk for on each "
"service.  The highest real-time priority level is 0; the lowest is 7.  In "
"the future, this might change to be more directly mappable to performance, "
"by passing in a desired data rate instead."
msgstr ""

#. type: TP
#: build/C/man2/ioprio_set.2:300
#, no-wrap
msgid "B<IOPRIO_CLASS_BE> (2)"
msgstr ""

#. type: Plain text
#: build/C/man2/ioprio_set.2:313
msgid ""
"This is the best-effort scheduling class, which is the default for any "
"process that hasn't set a specific I/O priority.  The class data (priority) "
"determines how much I/O bandwidth the process will get.  Best-effort "
"priority levels are analogous to CPU nice values (see B<getpriority>(2)).  "
"The priority level determines a priority relative to other processes in the "
"best-effort scheduling class.  Priority levels range from 0 (highest) to 7 "
"(lowest)."
msgstr ""

#. type: TP
#: build/C/man2/ioprio_set.2:313
#, no-wrap
msgid "B<IOPRIO_CLASS_IDLE> (3)"
msgstr ""

#. type: Plain text
#: build/C/man2/ioprio_set.2:322
msgid ""
"This is the idle scheduling class.  Processes running at this level get I/O "
"time only when no one else needs the disk.  The idle class has no class "
"data.  Attention is required when assigning this priority class to a "
"process, since it may become starved if higher priority processes are "
"constantly accessing the disk."
msgstr ""

#. type: Plain text
#: build/C/man2/ioprio_set.2:326
msgid ""
"Refer to the kernel source file I<Documentation/block/ioprio.txt> for more "
"information on the CFQ I/O Scheduler and an example program."
msgstr ""

#. type: SS
#: build/C/man2/ioprio_set.2:326
#, no-wrap
msgid "Required permissions to set I/O priorities"
msgstr ""

#. type: Plain text
#: build/C/man2/ioprio_set.2:329
msgid ""
"Permission to change a process's priority is granted or denied based on two "
"criteria:"
msgstr ""

#. type: TP
#: build/C/man2/ioprio_set.2:329
#, no-wrap
msgid "B<Process ownership>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioprio_set.2:337
msgid ""
"An unprivileged process may set the I/O priority only for a process whose "
"real UID matches the real or effective UID of the calling process.  A "
"process which has the B<CAP_SYS_NICE> capability can change the priority of "
"any process."
msgstr ""

#. type: TP
#: build/C/man2/ioprio_set.2:337
#, no-wrap
msgid "B<What is the desired priority>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioprio_set.2:349
msgid ""
"Attempts to set very high priorities (B<IOPRIO_CLASS_RT>)  require the "
"B<CAP_SYS_ADMIN> capability.  Kernel versions up to 2.6.24 also required "
"B<CAP_SYS_ADMIN> to set a very low priority (B<IOPRIO_CLASS_IDLE>), but "
"since Linux 2.6.25, this is no longer required."
msgstr ""

#. type: Plain text
#: build/C/man2/ioprio_set.2:354
msgid ""
"A call to B<ioprio_set>()  must follow both rules, or the call will fail "
"with the error B<EPERM>."
msgstr ""

#.  6 May 07: Bug report raised:
#.  http://sources.redhat.com/bugzilla/show_bug.cgi?id=4464
#.  Ulrich Drepper replied that he wasn't going to add these
#.  to glibc.
#. type: Plain text
#: build/C/man2/ioprio_set.2:363
msgid ""
"Glibc does not yet provide a suitable header file defining the function "
"prototypes and macros described on this page.  Suitable definitions can be "
"found in I<linux/ioprio.h>."
msgstr ""

#. type: Plain text
#: build/C/man2/ioprio_set.2:369
msgid ""
"B<ionice>(1), B<getpriority>(2), B<open>(2), B<capabilities>(7), "
"B<cgroups>(7)"
msgstr ""

#. type: Plain text
#: build/C/man2/ioprio_set.2:372
msgid "I<Documentation/block/ioprio.txt> in the Linux kernel source tree"
msgstr ""

#. type: TH
#: build/C/man2/ipc.2:25
#, no-wrap
msgid "IPC"
msgstr ""

#. type: TH
#: build/C/man2/ipc.2:25
#, no-wrap
msgid "2019-08-02"
msgstr ""

#. type: Plain text
#: build/C/man2/ipc.2:28
msgid "ipc - System V IPC system calls"
msgstr ""

#. type: Plain text
#: build/C/man2/ipc.2:33
#, no-wrap
msgid ""
"B<int ipc(unsigned int >I<call>B<, int >I<first>B<, int >I<second>B<, int "
">I<third>B<,>\n"
"B<        void *>I<ptr>B<, long >I<fifth>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ipc.2:41
msgid ""
"B<ipc>()  is a common kernel entry point for the System\\ V IPC calls for "
"messages, semaphores, and shared memory.  I<call> determines which IPC "
"function to invoke; the other arguments are passed through to the "
"appropriate call."
msgstr ""

#. type: Plain text
#: build/C/man2/ipc.2:45
msgid ""
"User-space programs should call the appropriate functions by their usual "
"names.  Only standard library implementors and kernel hackers need to know "
"about B<ipc>()."
msgstr ""

#. type: Plain text
#: build/C/man2/ipc.2:49
msgid ""
"B<ipc>()  is Linux-specific, and should not be used in programs intended to "
"be portable."
msgstr ""

#. type: Plain text
#: build/C/man2/ipc.2:57
msgid ""
"On some architectures\\(emfor example x86-64 and ARM\\(emthere is no "
"B<ipc>()  system call; instead, B<msgctl>(2), B<semctl>(2), B<shmctl>(2), "
"and so on really are implemented as separate system calls."
msgstr ""

#. type: Plain text
#: build/C/man2/ipc.2:71
msgid ""
"B<msgctl>(2), B<msgget>(2), B<msgrcv>(2), B<msgsnd>(2), B<semctl>(2), "
"B<semget>(2), B<semop>(2), B<semtimedop>(2), B<shmat>(2), B<shmctl>(2), "
"B<shmdt>(2), B<shmget>(2), B<sysvipc>(7)"
msgstr ""

#. type: TH
#: build/C/man2/seteuid.2:29
#, no-wrap
msgid "SETEUID"
msgstr ""

#. type: Plain text
#: build/C/man2/seteuid.2:32
msgid "seteuid, setegid - set effective user or group ID"
msgstr ""

#. type: Plain text
#: build/C/man2/seteuid.2:38
msgid "B<int seteuid(uid_t >I<euid>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/seteuid.2:40
msgid "B<int setegid(gid_t >I<egid>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/seteuid.2:49
msgid "B<seteuid>(), B<setegid>():"
msgstr ""

#. type: Plain text
#: build/C/man2/seteuid.2:52
#, no-wrap
msgid ""
"_POSIX_C_SOURCE\\ E<gt>=\\ 200112L\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man2/seteuid.2:59
msgid ""
"B<seteuid>()  sets the effective user ID of the calling process.  "
"Unprivileged processes may only set the effective user ID to the real user "
"ID, the effective user ID or the saved set-user-ID."
msgstr ""

#.  When
#.  .I euid
#.  equals \-1, nothing is changed.
#.  (This is an artifact of the implementation in glibc of seteuid()
#.  using setresuid(2).)
#. type: Plain text
#: build/C/man2/seteuid.2:68
msgid ""
"Precisely the same holds for B<setegid>()  with \"group\" instead of "
"\"user\"."
msgstr ""

#. type: Plain text
#: build/C/man2/seteuid.2:80
msgid ""
"I<Note>: there are cases where B<seteuid>()  can fail even when the caller "
"is UID 0; it is a grave security error to omit checking for a failure return "
"from B<seteuid>()."
msgstr ""

#. type: Plain text
#: build/C/man2/seteuid.2:84
msgid "The target user or group ID is not valid in this user namespace."
msgstr ""

#. type: Plain text
#: build/C/man2/seteuid.2:94
msgid ""
"In the case of B<seteuid>(): the calling process is not privileged (does not "
"have the B<CAP_SETUID> capability in its user namespace) and I<euid> does "
"not match the current real user ID, current effective user ID, or current "
"saved set-user-ID."
msgstr ""

#. type: Plain text
#: build/C/man2/seteuid.2:103
msgid ""
"In the case of B<setegid>(): the calling process is not privileged (does not "
"have the B<CAP_SETGID> capability in its user namespace) and I<egid> does "
"not match the current real group ID, current effective group ID, or current "
"saved set-group-ID."
msgstr ""

#. type: Plain text
#: build/C/man2/seteuid.2:111
msgid ""
"Setting the effective user (group) ID to the saved set-user-ID (saved "
"set-group-ID) is possible since Linux 1.1.37 (1.1.38).  On an arbitrary "
"system one should check B<_POSIX_SAVED_IDS>."
msgstr ""

#. type: Plain text
#: build/C/man2/seteuid.2:127
msgid ""
"Under glibc 2.0, B<seteuid(>I<euid>B<)> is equivalent to B<setreuid(-1,>I< "
"euid>B<)> and hence may change the saved set-user-ID.  Under glibc 2.1 and "
"later, it is equivalent to B<setresuid(-1,>I< euid>B<, -1)> and hence does "
"not change the saved set-user-ID.  Analogous remarks hold for B<setegid>(), "
"with the difference that the change in implementation from B<setregid(-1,>I< "
"egid>B<)> to B<setresgid(-1,>I< egid>B<, -1)> occurred in glibc 2.2 or 2.3 "
"(depending on the hardware architecture)."
msgstr ""

#. type: Plain text
#: build/C/man2/seteuid.2:136
msgid ""
"According to POSIX.1, B<seteuid>()  (B<setegid>())  need not permit I<euid> "
"(I<egid>)  to be the same value as the current effective user (group) ID, "
"and some implementations do not permit this."
msgstr ""

#. type: Plain text
#: build/C/man2/seteuid.2:145
msgid ""
"On Linux, B<seteuid>()  and B<setegid>()  are implemented as library "
"functions that call, respectively, B<setreuid>(2)  and B<setregid>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/seteuid.2:153
msgid ""
"B<geteuid>(2), B<setresuid>(2), B<setreuid>(2), B<setuid>(2), "
"B<capabilities>(7), B<credentials>(7), B<user_namespaces>(7)"
msgstr ""

#. type: TH
#: build/C/man2/setfsgid.2:32
#, no-wrap
msgid "SETFSGID"
msgstr ""

#. type: TH
#: build/C/man2/setfsgid.2:32 build/C/man2/setfsuid.2:32
#, no-wrap
msgid "2019-05-09"
msgstr ""

#. type: Plain text
#: build/C/man2/setfsgid.2:35
msgid "setfsgid - set group identity used for filesystem checks"
msgstr ""

#. type: Plain text
#: build/C/man2/setfsgid.2:37 build/C/man2/setfsuid.2:37
msgid "B<#include E<lt>sys/fsuid.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man2/setfsgid.2:39
msgid "B<int setfsgid(uid_t >I<fsgid>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/setfsgid.2:46
msgid ""
"On Linux, a process has both a filesystem group ID and an effective group "
"ID.  The (Linux-specific) filesystem group ID is used for permissions "
"checking when accessing filesystem objects, while the effective group ID is "
"used for some other kinds of permissions checks (see B<credentials>(7))."
msgstr ""

#. type: Plain text
#: build/C/man2/setfsgid.2:57
msgid ""
"Normally, the value of the process's filesystem group ID is the same as the "
"value of its effective group ID.  This is so, because whenever a process's "
"effective group ID is changed, the kernel also changes the filesystem group "
"ID to be the same as the new value of the effective group ID.  A process can "
"cause the value of its filesystem group ID to diverge from its effective "
"group ID by using B<setfsgid>()  to change its filesystem group ID to the "
"value given in I<fsgid>."
msgstr ""

#. type: Plain text
#: build/C/man2/setfsgid.2:63
msgid ""
"B<setfsgid>()  will succeed only if the caller is the superuser or if "
"I<fsgid> matches either the caller's real group ID, effective group ID, "
"saved set-group-ID, or current the filesystem user ID."
msgstr ""

#. type: Plain text
#: build/C/man2/setfsgid.2:66
msgid ""
"On both success and failure, this call returns the previous filesystem group "
"ID of the caller."
msgstr ""

#.  This system call is present since Linux 1.1.44
#.  and in libc since libc 4.7.6.
#. type: Plain text
#: build/C/man2/setfsgid.2:70 build/C/man2/setfsuid.2:81
msgid "This system call is present in Linux since version 1.2."
msgstr ""

#. type: Plain text
#: build/C/man2/setfsgid.2:74
msgid ""
"B<setfsgid>()  is Linux-specific and should not be used in programs intended "
"to be portable."
msgstr ""

#. type: Plain text
#: build/C/man2/setfsgid.2:86
msgid ""
"The filesystem group ID concept and the B<setfsgid>()  system call were "
"invented for historical reasons that are no longer applicable on modern "
"Linux kernels.  See B<setfsuid>(2)  for a discussion of why the use of both "
"B<setfsuid>(2)  and B<setfsgid>()  is nowadays unneeded."
msgstr ""

#. type: Plain text
#: build/C/man2/setfsgid.2:96
msgid ""
"The original Linux B<setfsgid>()  system call supported only 16-bit group "
"IDs.  Subsequently, Linux 2.4 added B<setfsgid32>()  supporting 32-bit IDs.  "
"The glibc B<setfsgid>()  wrapper function transparently deals with the "
"variation across kernel versions."
msgstr ""

#. type: Plain text
#: build/C/man2/setfsgid.2:105
msgid ""
"In glibc 2.15 and earlier, when the wrapper for this system call determines "
"that the argument can't be passed to the kernel without integer truncation "
"(because the kernel is old and does not support 32-bit group IDs), it will "
"return -1 and set I<errno> to B<EINVAL> without attempting the system call."
msgstr ""

#. type: Plain text
#: build/C/man2/setfsgid.2:122
msgid ""
"No error indications of any kind are returned to the caller, and the fact "
"that both successful and unsuccessful calls return the same value makes it "
"impossible to directly determine whether the call succeeded or failed.  "
"Instead, the caller must resort to looking at the return value from a "
"further call such as I<setfsgid(-1)> (which will always fail), in order to "
"determine if a preceding call to B<setfsgid>()  changed the filesystem group "
"ID.  At the very least, B<EPERM> should be returned when the call fails "
"(because the caller lacks the B<CAP_SETGID> capability)."
msgstr ""

#. type: Plain text
#: build/C/man2/setfsgid.2:127
msgid "B<kill>(2), B<setfsuid>(2), B<capabilities>(7), B<credentials>(7)"
msgstr ""

#. type: TH
#: build/C/man2/setfsuid.2:32
#, no-wrap
msgid "SETFSUID"
msgstr ""

#. type: Plain text
#: build/C/man2/setfsuid.2:35
msgid "setfsuid - set user identity used for filesystem checks"
msgstr ""

#. type: Plain text
#: build/C/man2/setfsuid.2:39
msgid "B<int setfsuid(uid_t >I<fsuid>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/setfsuid.2:46
msgid ""
"On Linux, a process has both a filesystem user ID and an effective user ID.  "
"The (Linux-specific) filesystem user ID is used for permissions checking "
"when accessing filesystem objects, while the effective user ID is used for "
"various other kinds of permissions checks (see B<credentials>(7))."
msgstr ""

#. type: Plain text
#: build/C/man2/setfsuid.2:57
msgid ""
"Normally, the value of the process's filesystem user ID is the same as the "
"value of its effective user ID.  This is so, because whenever a process's "
"effective user ID is changed, the kernel also changes the filesystem user ID "
"to be the same as the new value of the effective user ID.  A process can "
"cause the value of its filesystem user ID to diverge from its effective user "
"ID by using B<setfsuid>()  to change its filesystem user ID to the value "
"given in I<fsuid>."
msgstr ""

#. type: Plain text
#: build/C/man2/setfsuid.2:68
msgid ""
"Explicit calls to B<setfsuid>()  and B<setfsgid>(2)  are (were) usually used "
"only by programs such as the Linux NFS server that need to change what user "
"and group ID is used for file access without a corresponding change in the "
"real and effective user and group IDs.  A change in the normal user IDs for "
"a program such as the NFS server is (was) a security hole that can expose it "
"to unwanted signals.  (However, this issue is historical; see below.)"
msgstr ""

#. type: Plain text
#: build/C/man2/setfsuid.2:74
msgid ""
"B<setfsuid>()  will succeed only if the caller is the superuser or if "
"I<fsuid> matches either the caller's real user ID, effective user ID, saved "
"set-user-ID, or current filesystem user ID."
msgstr ""

#. type: Plain text
#: build/C/man2/setfsuid.2:77
msgid ""
"On both success and failure, this call returns the previous filesystem user "
"ID of the caller."
msgstr ""

#. type: Plain text
#: build/C/man2/setfsuid.2:85
msgid ""
"B<setfsuid>()  is Linux-specific and should not be used in programs intended "
"to be portable."
msgstr ""

#. type: Plain text
#: build/C/man2/setfsuid.2:104
msgid ""
"At the time when this system call was introduced, one process could send a "
"signal to another process with the same effective user ID.  This meant that "
"if a privileged process changed its effective user ID for the purpose of "
"file permission checking, then it could become vulnerable to receiving "
"signals sent by another (unprivileged) process with the same user ID.  The "
"filesystem user ID attribute was thus added to allow a process to change its "
"user ID for the purposes of file permission checking without at the same "
"time becoming vulnerable to receiving unwanted signals.  Since Linux 2.0, "
"signal permission handling is different (see B<kill>(2)), with the result "
"that a process can change its effective user ID without being vulnerable to "
"receiving signals from unwanted processes.  Thus, B<setfsuid>()  is nowadays "
"unneeded and should be avoided in new applications (likewise for "
"B<setfsgid>(2))."
msgstr ""

#. type: Plain text
#: build/C/man2/setfsuid.2:114
msgid ""
"The original Linux B<setfsuid>()  system call supported only 16-bit user "
"IDs.  Subsequently, Linux 2.4 added B<setfsuid32>()  supporting 32-bit IDs.  "
"The glibc B<setfsuid>()  wrapper function transparently deals with the "
"variation across kernel versions."
msgstr ""

#. type: Plain text
#: build/C/man2/setfsuid.2:123
msgid ""
"In glibc 2.15 and earlier, when the wrapper for this system call determines "
"that the argument can't be passed to the kernel without integer truncation "
"(because the kernel is old and does not support 32-bit user IDs), it will "
"return -1 and set I<errno> to B<EINVAL> without attempting the system call."
msgstr ""

#. type: Plain text
#: build/C/man2/setfsuid.2:140
msgid ""
"No error indications of any kind are returned to the caller, and the fact "
"that both successful and unsuccessful calls return the same value makes it "
"impossible to directly determine whether the call succeeded or failed.  "
"Instead, the caller must resort to looking at the return value from a "
"further call such as I<setfsuid(-1)> (which will always fail), in order to "
"determine if a preceding call to B<setfsuid>()  changed the filesystem user "
"ID.  At the very least, B<EPERM> should be returned when the call fails "
"(because the caller lacks the B<CAP_SETUID> capability)."
msgstr ""

#. type: Plain text
#: build/C/man2/setfsuid.2:145
msgid "B<kill>(2), B<setfsgid>(2), B<capabilities>(7), B<credentials>(7)"
msgstr ""

#. type: TH
#: build/C/man2/setgid.2:30
#, no-wrap
msgid "SETGID"
msgstr ""

#. type: Plain text
#: build/C/man2/setgid.2:33
msgid "setgid - set group identity"
msgstr ""

#. type: Plain text
#: build/C/man2/setgid.2:39
msgid "B<int setgid(gid_t >I<gid>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/setgid.2:46
msgid ""
"B<setgid>()  sets the effective group ID of the calling process.  If the "
"calling process is privileged (more precisely: has the B<CAP_SETGID> "
"capability in its user namespace), the real GID and saved set-group-ID are "
"also set."
msgstr ""

#. type: Plain text
#: build/C/man2/setgid.2:56
msgid ""
"Under Linux, B<setgid>()  is implemented like the POSIX version with the "
"B<_POSIX_SAVED_IDS> feature.  This allows a set-group-ID program that is not "
"set-user-ID-root to drop all of its group privileges, do some un-privileged "
"work, and then reengage the original effective group ID in a secure manner."
msgstr ""

#. type: Plain text
#: build/C/man2/setgid.2:67
msgid "The group ID specified in I<gid> is not valid in this user namespace."
msgstr ""

#. type: Plain text
#: build/C/man2/setgid.2:74
msgid ""
"The calling process is not privileged (does not have the B<CAP_SETGID> "
"capability in its user namespace), and I<gid> does not match the real group "
"ID or saved set-group-ID of the calling process."
msgstr ""

#. type: Plain text
#: build/C/man2/setgid.2:87
msgid ""
"The original Linux B<setgid>()  system call supported only 16-bit group "
"IDs.  Subsequently, Linux 2.4 added B<setgid32>()  supporting 32-bit IDs.  "
"The glibc B<setgid>()  wrapper function transparently deals with the "
"variation across kernel versions."
msgstr ""

#. type: Plain text
#: build/C/man2/setgid.2:101
msgid ""
"At the kernel level, user IDs and group IDs are a per-thread attribute.  "
"However, POSIX requires that all threads in a process share the same "
"credentials.  The NPTL threading implementation handles the POSIX "
"requirements by providing wrapper functions for the various system calls "
"that change process UIDs and GIDs.  These wrapper functions (including the "
"one for B<setgid>())  employ a signal-based technique to ensure that when "
"one thread changes credentials, all of the other threads in the process also "
"change their credentials.  For details, see B<nptl>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/setgid.2:108
msgid ""
"B<getgid>(2), B<setegid>(2), B<setregid>(2), B<capabilities>(7), "
"B<credentials>(7), B<user_namespaces>(7)"
msgstr ""

#. type: TH
#: build/C/man2/setpgid.2:48
#, no-wrap
msgid "SETPGID"
msgstr ""

#. type: Plain text
#: build/C/man2/setpgid.2:51
msgid "setpgid, getpgid, setpgrp, getpgrp - set/get process group"
msgstr ""

#. type: Plain text
#: build/C/man2/setpgid.2:57
msgid "B<int setpgid(pid_t >I<pid>B<, pid_t >I<pgid>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/setpgid.2:59
msgid "B<pid_t getpgid(pid_t >I<pid>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/setpgid.2:61
msgid "B<pid_t getpgrp(void);> /* POSIX.1 version */"
msgstr ""

#. type: Plain text
#: build/C/man2/setpgid.2:63
msgid "B<pid_t getpgrp(pid_t >I<pid>B<);> /* BSD version */"
msgstr ""

#. type: Plain text
#: build/C/man2/setpgid.2:65
msgid "B<int setpgrp(void);> /* System V version */"
msgstr ""

#. type: Plain text
#: build/C/man2/setpgid.2:67
msgid "B<int setpgrp(pid_t >I<pid>B<, pid_t >I<pgid>B<);> /* BSD version */"
msgstr ""

#. type: Plain text
#: build/C/man2/setpgid.2:75
msgid "B<getpgid>():"
msgstr ""

#. type: Plain text
#: build/C/man2/setpgid.2:82
msgid "B<setpgrp>() (POSIX.1):"
msgstr ""

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: build/C/man2/setpgid.2:87
#, no-wrap
msgid ""
"    _XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"        || /* Since glibc 2.19: */ _DEFAULT_SOURCE\n"
"        || /* Glibc versions E<lt>= 2.19: */ _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man2/setpgid.2:91
msgid "B<setpgrp>()\\ (BSD), B<getpgrp>()\\ (BSD):"
msgstr ""

#. type: Plain text
#: build/C/man2/setpgid.2:96
#, no-wrap
msgid ""
"    [These are available only before glibc 2.19]\n"
"    _BSD_SOURCE &&\n"
"        !\\ (_POSIX_SOURCE || _POSIX_C_SOURCE || _XOPEN_SOURCE ||\n"
"            _GNU_SOURCE || _SVID_SOURCE)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/setpgid.2:107
msgid ""
"All of these interfaces are available on Linux, and are used for getting and "
"setting the process group ID (PGID) of a process.  The preferred, "
"POSIX.1-specified ways of doing this are: B<getpgrp>(void), for retrieving "
"the calling process's PGID; and B<setpgid>(), for setting a process's PGID."
msgstr ""

#. type: Plain text
#: build/C/man2/setpgid.2:132
msgid ""
"B<setpgid>()  sets the PGID of the process specified by I<pid> to I<pgid>.  "
"If I<pid> is zero, then the process ID of the calling process is used.  If "
"I<pgid> is zero, then the PGID of the process specified by I<pid> is made "
"the same as its process ID.  If B<setpgid>()  is used to move a process from "
"one process group to another (as is done by some shells when creating "
"pipelines), both process groups must be part of the same session (see "
"B<setsid>(2)  and B<credentials>(7)).  In this case, the I<pgid> specifies "
"an existing process group to be joined and the session ID of that group must "
"match the session ID of the joining process."
msgstr ""

#. type: Plain text
#: build/C/man2/setpgid.2:137
msgid ""
"The POSIX.1 version of B<getpgrp>(), which takes no arguments, returns the "
"PGID of the calling process."
msgstr ""

#. type: Plain text
#: build/C/man2/setpgid.2:148
msgid ""
"B<getpgid>()  returns the PGID of the process specified by I<pid>.  If "
"I<pid> is zero, the process ID of the calling process is used.  (Retrieving "
"the PGID of a process other than the caller is rarely necessary, and the "
"POSIX.1 B<getpgrp>()  is preferred for that task.)"
msgstr ""

#. type: Plain text
#: build/C/man2/setpgid.2:153
msgid ""
"The System\\ V-style B<setpgrp>(), which takes no arguments, is equivalent "
"to I<setpgid(0,\\ 0)>."
msgstr ""

#. type: Plain text
#: build/C/man2/setpgid.2:161
msgid ""
"The BSD-specific B<setpgrp>()  call, which takes arguments I<pid> and "
"I<pgid>, is a wrapper function that calls"
msgstr ""

#. type: Plain text
#: build/C/man2/setpgid.2:163
#, no-wrap
msgid "    setpgid(pid, pgid)\n"
msgstr ""

#.  The true BSD setpgrp() system call differs in allowing the PGID
#.  to be set to arbitrary values, rather than being restricted to
#.  PGIDs in the same session.
#. type: Plain text
#: build/C/man2/setpgid.2:174
msgid ""
"Since glibc 2.19, the BSD-specific B<setpgrp>()  function is no longer "
"exposed by I<E<lt>unistd.hE<gt>>; calls should be replaced with the "
"B<setpgid>()  call shown above."
msgstr ""

#. type: Plain text
#: build/C/man2/setpgid.2:180
msgid ""
"The BSD-specific B<getpgrp>()  call, which takes a single I<pid> argument, "
"is a wrapper function that calls"
msgstr ""

#. type: Plain text
#: build/C/man2/setpgid.2:182
#, no-wrap
msgid "    getpgid(pid)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/setpgid.2:193
msgid ""
"Since glibc 2.19, the BSD-specific B<getpgrp>()  function is no longer "
"exposed by I<E<lt>unistd.hE<gt>>; calls should be replaced with calls to the "
"POSIX.1 B<getpgrp>()  which takes no arguments (if the intent is to obtain "
"the caller's PGID), or with the B<getpgid>()  call shown above."
msgstr ""

#. type: Plain text
#: build/C/man2/setpgid.2:202
msgid ""
"On success, B<setpgid>()  and B<setpgrp>()  return zero.  On error, -1 is "
"returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/setpgid.2:206
msgid "The POSIX.1 B<getpgrp>()  always returns the PGID of the caller."
msgstr ""

#. type: Plain text
#: build/C/man2/setpgid.2:214
msgid ""
"B<getpgid>(), and the BSD-specific B<getpgrp>()  return a process group on "
"success.  On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/setpgid.2:223
msgid ""
"An attempt was made to change the process group ID of one of the children of "
"the calling process and the child had already performed an B<execve>(2)  "
"(B<setpgid>(), B<setpgrp>())."
msgstr ""

#. type: Plain text
#: build/C/man2/setpgid.2:229
msgid "I<pgid> is less than 0 (B<setpgid>(), B<setpgrp>())."
msgstr ""

#. type: Plain text
#: build/C/man2/setpgid.2:238
msgid ""
"An attempt was made to move a process into a process group in a different "
"session, or to change the process group ID of one of the children of the "
"calling process and the child was in a different session, or to change the "
"process group ID of a session leader (B<setpgid>(), B<setpgrp>())."
msgstr ""

#. type: Plain text
#: build/C/man2/setpgid.2:248
msgid ""
"For B<getpgid>(): I<pid> does not match any process.  For B<setpgid>(): "
"I<pid> is not the calling process and not a child of the calling process."
msgstr ""

#. type: Plain text
#: build/C/man2/setpgid.2:254
msgid ""
"B<setpgid>()  and the version of B<getpgrp>()  with no arguments conform to "
"POSIX.1-2001."
msgstr ""

#. type: Plain text
#: build/C/man2/setpgid.2:263
msgid ""
"POSIX.1-2001 also specifies B<getpgid>()  and the version of B<setpgrp>()  "
"that takes no arguments.  (POSIX.1-2008 marks this B<setpgrp>()  "
"specification as obsolete.)"
msgstr ""

#. type: Plain text
#: build/C/man2/setpgid.2:270
msgid ""
"The version of B<getpgrp>()  with one argument and the version of "
"B<setpgrp>()  that takes two arguments derive from 4.2BSD, and are not "
"specified by POSIX.1."
msgstr ""

#. type: Plain text
#: build/C/man2/setpgid.2:276
msgid ""
"A child created via B<fork>(2)  inherits its parent's process group ID.  The "
"PGID is preserved across an B<execve>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/setpgid.2:281
msgid ""
"Each process group is a member of a session and each process is a member of "
"the session of which its process group is a member.  (See "
"B<credentials>(7).)"
msgstr ""

#. type: Plain text
#: build/C/man2/setpgid.2:308
msgid ""
"A session can have a controlling terminal.  At any time, one (and only one) "
"of the process groups in the session can be the foreground process group for "
"the terminal; the remaining process groups are in the background.  If a "
"signal is generated from the terminal (e.g., typing the interrupt key to "
"generate B<SIGINT>), that signal is sent to the foreground process group.  "
"(See B<termios>(3)  for a description of the characters that generate "
"signals.)  Only the foreground process group may B<read>(2)  from the "
"terminal; if a background process group tries to B<read>(2)  from the "
"terminal, then the group is sent a B<SIGTTIN> signal, which suspends it.  "
"The B<tcgetpgrp>(3)  and B<tcsetpgrp>(3)  functions are used to get/set the "
"foreground process group of the controlling terminal."
msgstr ""

#. type: Plain text
#: build/C/man2/setpgid.2:316
msgid ""
"The B<setpgid>()  and B<getpgrp>()  calls are used by programs such as "
"B<bash>(1)  to create process groups in order to implement shell job "
"control."
msgstr ""

#.  exit.3 refers to the following text:
#. type: Plain text
#: build/C/man2/setpgid.2:330
msgid ""
"If the termination of a process causes a process group to become orphaned, "
"and if any member of the newly orphaned process group is stopped, then a "
"B<SIGHUP> signal followed by a B<SIGCONT> signal will be sent to each "
"process in the newly orphaned process group.  An orphaned process group is "
"one in which the parent of every member of process group is either itself "
"also a member of the process group or is a member of a process group in a "
"different session (see also B<credentials>(7))."
msgstr ""

#. type: Plain text
#: build/C/man2/setpgid.2:337
msgid ""
"B<getuid>(2), B<setsid>(2), B<tcgetpgrp>(3), B<tcsetpgrp>(3), B<termios>(3), "
"B<credentials>(7)"
msgstr ""

#. type: TH
#: build/C/man2/setresuid.2:27
#, no-wrap
msgid "SETRESUID"
msgstr ""

#. type: Plain text
#: build/C/man2/setresuid.2:30
msgid "setresuid, setresgid - set real, effective and saved user or group ID"
msgstr ""

#. type: Plain text
#: build/C/man2/setresuid.2:36
msgid "B<int setresuid(uid_t >I<ruid>B<, uid_t >I<euid>B<, uid_t >I<suid>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/setresuid.2:38
msgid "B<int setresgid(gid_t >I<rgid>B<, gid_t >I<egid>B<, gid_t >I<sgid>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/setresuid.2:42
msgid ""
"B<setresuid>()  sets the real user ID, the effective user ID, and the saved "
"set-user-ID of the calling process."
msgstr ""

#. type: Plain text
#: build/C/man2/setresuid.2:47
msgid ""
"An unprivileged process may change its real UID, effective UID, and saved "
"set-user-ID, each to one of: the current real UID, the current effective UID "
"or the current saved set-user-ID."
msgstr ""

#. type: Plain text
#: build/C/man2/setresuid.2:51
msgid ""
"A privileged process (on Linux, one having the B<CAP_SETUID> capability)  "
"may set its real UID, effective UID, and saved set-user-ID to arbitrary "
"values."
msgstr ""

#. type: Plain text
#: build/C/man2/setresuid.2:53
msgid "If one of the arguments equals -1, the corresponding value is not changed."
msgstr ""

#. type: Plain text
#: build/C/man2/setresuid.2:57
msgid ""
"Regardless of what changes are made to the real UID, effective UID, and "
"saved set-user-ID, the filesystem UID is always set to the same value as the "
"(possibly new) effective UID."
msgstr ""

#. type: Plain text
#: build/C/man2/setresuid.2:64
msgid ""
"Completely analogously, B<setresgid>()  sets the real GID, effective GID, "
"and saved set-group-ID of the calling process (and always modifies the "
"filesystem GID to be the same as the effective GID), with the same "
"restrictions for unprivileged processes."
msgstr ""

#. type: Plain text
#: build/C/man2/setresuid.2:76
msgid ""
"I<Note>: there are cases where B<setresuid>()  can fail even when the caller "
"is UID 0; it is a grave security error to omit checking for a failure return "
"from B<setresuid>()."
msgstr ""

#. type: TP
#: build/C/man2/setresuid.2:77 build/C/man2/setresuid.2:84 build/C/man2/setreuid.2:109 build/C/man2/setreuid.2:116 build/C/man2/setuid.2:86 build/C/man2/setuid.2:93
#, no-wrap
msgid "B<EAGAIN>"
msgstr ""

#. type: Plain text
#: build/C/man2/setresuid.2:84 build/C/man2/setreuid.2:116
msgid ""
"The call would change the caller's real UID (i.e., I<ruid> does not match "
"the caller's real UID), but there was a temporary failure allocating the "
"necessary kernel data structures."
msgstr ""

#. type: Plain text
#: build/C/man2/setresuid.2:99 build/C/man2/setreuid.2:131
msgid ""
"I<ruid> does not match the caller's real UID and this call would bring the "
"number of processes belonging to the real user ID I<ruid> over the caller's "
"B<RLIMIT_NPROC> resource limit.  Since Linux 3.1, this error case no longer "
"occurs (but robust applications should check for this error); see the "
"description of B<EAGAIN> in B<execve>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/setresuid.2:103 build/C/man2/setreuid.2:135
msgid ""
"One or more of the target user or group IDs is not valid in this user "
"namespace."
msgstr ""

#. type: Plain text
#: build/C/man2/setresuid.2:116
msgid ""
"The calling process is not privileged (did not have the necessary capability "
"in its user namespace)  and tried to change the IDs to values that are not "
"permitted.  For B<setresuid>(), the necessary capability is B<CAP_SETUID>; "
"for B<setresgid>(), it is B<CAP_SETGID>."
msgstr ""

#. type: Plain text
#: build/C/man2/setresuid.2:118
msgid "These calls are available under Linux since Linux 2.1.44."
msgstr ""

#. type: Plain text
#: build/C/man2/setresuid.2:125
msgid ""
"Under HP-UX and FreeBSD, the prototype is found in I<E<lt>unistd.hE<gt>>.  "
"Under Linux, the prototype is provided by glibc since version 2.3.2."
msgstr ""

#. type: Plain text
#: build/C/man2/setresuid.2:142
msgid ""
"The original Linux B<setresuid>()  and B<setresgid>()  system calls "
"supported only 16-bit user and group IDs.  Subsequently, Linux 2.4 added "
"B<setresuid32>()  and B<setresgid32>(), supporting 32-bit IDs.  The glibc "
"B<setresuid>()  and B<setresgid>()  wrapper functions transparently deal "
"with the variations across kernel versions."
msgstr ""

#. type: Plain text
#: build/C/man2/setresuid.2:158
msgid ""
"At the kernel level, user IDs and group IDs are a per-thread attribute.  "
"However, POSIX requires that all threads in a process share the same "
"credentials.  The NPTL threading implementation handles the POSIX "
"requirements by providing wrapper functions for the various system calls "
"that change process UIDs and GIDs.  These wrapper functions (including those "
"for B<setresuid>()  and B<setresgid>())  employ a signal-based technique to "
"ensure that when one thread changes credentials, all of the other threads in "
"the process also change their credentials.  For details, see B<nptl>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/setresuid.2:168
msgid ""
"B<getresuid>(2), B<getuid>(2), B<setfsgid>(2), B<setfsuid>(2), "
"B<setreuid>(2), B<setuid>(2), B<capabilities>(7), B<credentials>(7), "
"B<user_namespaces>(7)"
msgstr ""

#. type: TH
#: build/C/man2/setreuid.2:46
#, no-wrap
msgid "SETREUID"
msgstr ""

#. type: Plain text
#: build/C/man2/setreuid.2:49
msgid "setreuid, setregid - set real and/or effective user or group ID"
msgstr ""

#. type: Plain text
#: build/C/man2/setreuid.2:55
msgid "B<int setreuid(uid_t >I<ruid>B<, uid_t >I<euid>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/setreuid.2:57
msgid "B<int setregid(gid_t >I<rgid>B<, gid_t >I<egid>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/setreuid.2:65
msgid "B<setreuid>(), B<setregid>():"
msgstr ""

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: build/C/man2/setreuid.2:71
#, no-wrap
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* Since glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man2/setreuid.2:76
msgid "B<setreuid>()  sets real and effective user IDs of the calling process."
msgstr ""

#. type: Plain text
#: build/C/man2/setreuid.2:79
msgid ""
"Supplying a value of -1 for either the real or effective user ID forces the "
"system to leave that ID unchanged."
msgstr ""

#. type: Plain text
#: build/C/man2/setreuid.2:82
msgid ""
"Unprivileged processes may only set the effective user ID to the real user "
"ID, the effective user ID, or the saved set-user-ID."
msgstr ""

#. type: Plain text
#: build/C/man2/setreuid.2:85
msgid ""
"Unprivileged users may only set the real user ID to the real user ID or the "
"effective user ID."
msgstr ""

#. type: Plain text
#: build/C/man2/setreuid.2:91
msgid ""
"If the real user ID is set (i.e., I<ruid> is not -1) or the effective user "
"ID is set to a value not equal to the previous real user ID, the saved "
"set-user-ID will be set to the new effective user ID."
msgstr ""

#. type: Plain text
#: build/C/man2/setreuid.2:96
msgid ""
"Completely analogously, B<setregid>()  sets real and effective group ID's of "
"the calling process, and all of the above holds with \"group\" instead of "
"\"user\"."
msgstr ""

#. type: Plain text
#: build/C/man2/setreuid.2:108
msgid ""
"I<Note>: there are cases where B<setreuid>()  can fail even when the caller "
"is UID 0; it is a grave security error to omit checking for a failure return "
"from B<setreuid>()."
msgstr ""

#. type: Plain text
#: build/C/man2/setreuid.2:151
msgid ""
"The calling process is not privileged (on Linux, does not have the necessary "
"capability in its user namespace: B<CAP_SETUID> in the case of "
"B<setreuid>(), or B<CAP_SETGID> in the case of B<setregid>())  and a change "
"other than (i)  swapping the effective user (group) ID with the real user "
"(group) ID, or (ii) setting one to the value of the other or (iii) setting "
"the effective user (group) ID to the value of the saved set-user-ID (saved "
"set-group-ID) was specified."
msgstr ""

#. type: Plain text
#: build/C/man2/setreuid.2:157
msgid ""
"POSIX.1-2001, POSIX.1-2008, 4.3BSD (B<setreuid>()  and B<setregid>()  first "
"appeared in 4.2BSD)."
msgstr ""

#. type: Plain text
#: build/C/man2/setreuid.2:161
msgid ""
"Setting the effective user (group) ID to the saved set-user-ID (saved "
"set-group-ID) is possible since Linux 1.1.37 (1.1.38)."
msgstr ""

#. type: Plain text
#: build/C/man2/setreuid.2:178
msgid ""
"POSIX.1 does not specify all of the UID changes that Linux permits for an "
"unprivileged process.  For B<setreuid>(), the effective user ID can be made "
"the same as the real user ID or the saved set-user-ID, and it is unspecified "
"whether unprivileged processes may set the real user ID to the real user ID, "
"the effective user ID, or the saved set-user-ID.  For B<setregid>(), the "
"real group ID can be changed to the value of the saved set-group-ID, and the "
"effective group ID can be changed to the value of the real group ID or the "
"saved set-group-ID.  The precise details of what ID changes are permitted "
"vary across implementations."
msgstr ""

#. type: Plain text
#: build/C/man2/setreuid.2:181
msgid ""
"POSIX.1 makes no specification about the effect of these calls on the saved "
"set-user-ID and saved set-group-ID."
msgstr ""

#. type: Plain text
#: build/C/man2/setreuid.2:198
msgid ""
"The original Linux B<setreuid>()  and B<setregid>()  system calls supported "
"only 16-bit user and group IDs.  Subsequently, Linux 2.4 added "
"B<setreuid32>()  and B<setregid32>(), supporting 32-bit IDs.  The glibc "
"B<setreuid>()  and B<setregid>()  wrapper functions transparently deal with "
"the variations across kernel versions."
msgstr ""

#. type: Plain text
#: build/C/man2/setreuid.2:214
msgid ""
"At the kernel level, user IDs and group IDs are a per-thread attribute.  "
"However, POSIX requires that all threads in a process share the same "
"credentials.  The NPTL threading implementation handles the POSIX "
"requirements by providing wrapper functions for the various system calls "
"that change process UIDs and GIDs.  These wrapper functions (including those "
"for B<setreuid>()  and B<setregid>())  employ a signal-based technique to "
"ensure that when one thread changes credentials, all of the other threads in "
"the process also change their credentials.  For details, see B<nptl>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/setreuid.2:224
msgid ""
"B<getgid>(2), B<getuid>(2), B<seteuid>(2), B<setgid>(2), B<setresuid>(2), "
"B<setuid>(2), B<capabilities>(7), B<credentials>(7), B<user_namespaces>(7)"
msgstr ""

#. type: TH
#: build/C/man2/setsid.2:31
#, no-wrap
msgid "SETSID"
msgstr ""

#. type: Plain text
#: build/C/man2/setsid.2:34
msgid "setsid - creates a session and sets the process group ID"
msgstr ""

#. type: Plain text
#: build/C/man2/setsid.2:41
msgid "B<pid_t setsid(void);>"
msgstr ""

#. type: Plain text
#: build/C/man2/setsid.2:52
msgid ""
"B<setsid>()  creates a new session if the calling process is not a process "
"group leader.  The calling process is the leader of the new session (i.e., "
"its session ID is made the same as its process ID).  The calling process "
"also becomes the process group leader of a new process group in the session "
"(i.e., its process group ID is made the same as its process ID)."
msgstr ""

#. type: Plain text
#: build/C/man2/setsid.2:55
msgid ""
"The calling process will be the only process in the new process group and in "
"the new session."
msgstr ""

#. type: Plain text
#: build/C/man2/setsid.2:59
msgid ""
"Initially, the new session has no controlling terminal.  For details of how "
"a session acquires a controlling terminal, see B<credentials>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/setsid.2:66
msgid ""
"On success, the (new) session ID of the calling process is returned.  On "
"error, I<(pid_t)\\ -1> is returned, and I<errno> is set to indicate the "
"error."
msgstr ""

#. type: Plain text
#: build/C/man2/setsid.2:73
msgid ""
"The process group ID of any process equals the PID of the calling process.  "
"Thus, in particular, B<setsid>()  fails if the calling process is already a "
"process group leader."
msgstr ""

#. type: Plain text
#: build/C/man2/setsid.2:81
msgid ""
"A child created via B<fork>(2)  inherits its parent's session ID.  The "
"session ID is preserved across an B<execve>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/setsid.2:98
msgid ""
"A process group leader is a process whose process group ID equals its PID.  "
"Disallowing a process group leader from calling B<setsid>()  prevents the "
"possibility that a process group leader places itself in a new session while "
"other processes in the process group remain in the original session; such a "
"scenario would break the strict two-level hierarchy of sessions and process "
"groups.  In order to be sure that B<setsid>()  will succeed, call B<fork>(2)  "
"and have the parent B<_exit>(2), while the child (which by definition can't "
"be a process group leader) calls B<setsid>()."
msgstr ""

#. type: Plain text
#: build/C/man2/setsid.2:105
msgid ""
"If a session has a controlling terminal, and the B<CLOCAL> flag for that "
"terminal is not set, and a terminal hangup occurs, then the session leader "
"is sent a B<SIGHUP> signal."
msgstr ""

#. type: Plain text
#: build/C/man2/setsid.2:110
msgid ""
"If a process that is a session leader terminates, then a B<SIGHUP> signal is "
"sent to each process in the foreground process group of the controlling "
"terminal."
msgstr ""

#. type: Plain text
#: build/C/man2/setsid.2:118
msgid ""
"B<setsid>(1), B<getsid>(2), B<setpgid>(2), B<setpgrp>(2), B<tcgetsid>(3), "
"B<credentials>(7), B<sched>(7)"
msgstr ""

#. type: TH
#: build/C/man2/setuid.2:31
#, no-wrap
msgid "SETUID"
msgstr ""

#. type: Plain text
#: build/C/man2/setuid.2:34
msgid "setuid - set user identity"
msgstr ""

#. type: Plain text
#: build/C/man2/setuid.2:40
msgid "B<int setuid(uid_t >I<uid>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/setuid.2:48
msgid ""
"B<setuid>()  sets the effective user ID of the calling process.  If the "
"calling process is privileged (more precisely: if the process has the "
"B<CAP_SETUID> capability in its user namespace), the real UID and saved "
"set-user-ID are also set."
msgstr ""

#. type: Plain text
#: build/C/man2/setuid.2:57
msgid ""
"Under Linux, B<setuid>()  is implemented like the POSIX version with the "
"B<_POSIX_SAVED_IDS> feature.  This allows a set-user-ID (other than root) "
"program to drop all of its user privileges, do some un-privileged work, and "
"then reengage the original effective user ID in a secure manner."
msgstr ""

#. type: Plain text
#: build/C/man2/setuid.2:66
msgid ""
"If the user is root or the program is set-user-ID-root, special care must be "
"taken: B<setuid>()  checks the effective user ID of the caller and if it is "
"the superuser, all process-related user ID's are set to I<uid>.  After this "
"has occurred, it is impossible for the program to regain root privileges."
msgstr ""

#. type: Plain text
#: build/C/man2/setuid.2:73
msgid ""
"Thus, a set-user-ID-root program wishing to temporarily drop root "
"privileges, assume the identity of an unprivileged user, and then regain "
"root privileges afterward cannot use B<setuid>().  You can accomplish this "
"with B<seteuid>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/setuid.2:85
msgid ""
"I<Note>: there are cases where B<setuid>()  can fail even when the caller is "
"UID 0; it is a grave security error to omit checking for a failure return "
"from B<setuid>()."
msgstr ""

#. type: Plain text
#: build/C/man2/setuid.2:93
msgid ""
"The call would change the caller's real UID (i.e., I<uid> does not match the "
"caller's real UID), but there was a temporary failure allocating the "
"necessary kernel data structures."
msgstr ""

#. type: Plain text
#: build/C/man2/setuid.2:108
msgid ""
"I<uid> does not match the real user ID of the caller and this call would "
"bring the number of processes belonging to the real user ID I<uid> over the "
"caller's B<RLIMIT_NPROC> resource limit.  Since Linux 3.1, this error case "
"no longer occurs (but robust applications should check for this error); see "
"the description of B<EAGAIN> in B<execve>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/setuid.2:113
msgid "The user ID specified in I<uid> is not valid in this user namespace."
msgstr ""

#. type: Plain text
#: build/C/man2/setuid.2:120
msgid ""
"The user is not privileged (Linux: does not have the B<CAP_SETUID> "
"capability in its user namespace) and I<uid> does not match the real UID or "
"saved set-user-ID of the calling process."
msgstr ""

#.  SVr4 documents an additional EINVAL error condition.
#. type: Plain text
#: build/C/man2/setuid.2:125
msgid ""
"POSIX.1-2001, POSIX.1-2008, SVr4.  Not quite compatible with the 4.4BSD "
"call, which sets all of the real, saved, and effective user IDs."
msgstr ""

#. type: Plain text
#: build/C/man2/setuid.2:133
msgid ""
"Linux has the concept of the filesystem user ID, normally equal to the "
"effective user ID.  The B<setuid>()  call also sets the filesystem user ID "
"of the calling process.  See B<setfsuid>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/setuid.2:138
msgid ""
"If I<uid> is different from the old effective UID, the process will be "
"forbidden from leaving core dumps."
msgstr ""

#. type: Plain text
#: build/C/man2/setuid.2:149
msgid ""
"The original Linux B<setuid>()  system call supported only 16-bit user IDs.  "
"Subsequently, Linux 2.4 added B<setuid32>()  supporting 32-bit IDs.  The "
"glibc B<setuid>()  wrapper function transparently deals with the variation "
"across kernel versions."
msgstr ""

#. type: Plain text
#: build/C/man2/setuid.2:163
msgid ""
"At the kernel level, user IDs and group IDs are a per-thread attribute.  "
"However, POSIX requires that all threads in a process share the same "
"credentials.  The NPTL threading implementation handles the POSIX "
"requirements by providing wrapper functions for the various system calls "
"that change process UIDs and GIDs.  These wrapper functions (including the "
"one for B<setuid>())  employ a signal-based technique to ensure that when "
"one thread changes credentials, all of the other threads in the process also "
"change their credentials.  For details, see B<nptl>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/setuid.2:171
msgid ""
"B<getuid>(2), B<seteuid>(2), B<setfsuid>(2), B<setreuid>(2), "
"B<capabilities>(7), B<credentials>(7), B<user_namespaces>(7)"
msgstr ""

#. type: TH
#: build/C/man7/sysvipc.7:25
#, no-wrap
msgid "SVIPC"
msgstr ""

#. type: TH
#: build/C/man7/sysvipc.7:25
#, no-wrap
msgid "2020-04-11"
msgstr ""

#. type: Plain text
#: build/C/man7/sysvipc.7:28
msgid "sysvipc - System V interprocess communication mechanisms"
msgstr ""

#. type: Plain text
#: build/C/man7/sysvipc.7:33
msgid ""
"System V IPC is the name given to three interprocess communication "
"mechanisms that are widely available on UNIX systems: message queues, "
"semaphore, and shared memory."
msgstr ""

#. type: SS
#: build/C/man7/sysvipc.7:33
#, no-wrap
msgid "Message queues"
msgstr ""

#. type: Plain text
#: build/C/man7/sysvipc.7:39
msgid ""
"System V message queues allow data to be exchanged in units called "
"messages.  Each messages can have an associated priority, POSIX message "
"queues provide an alternative API for achieving the same result; see "
"B<mq_overview>(7)."
msgstr ""

#. type: Plain text
#: build/C/man7/sysvipc.7:41
msgid "The System V message queue API consists of the following system calls:"
msgstr ""

#. type: TP
#: build/C/man7/sysvipc.7:41
#, no-wrap
msgid "B<msgget>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/sysvipc.7:45
msgid ""
"Create a new message queue or obtain the ID of an existing message queue.  "
"This call returns an identifier that is used in the remaining APIs."
msgstr ""

#. type: TP
#: build/C/man7/sysvipc.7:45
#, no-wrap
msgid "B<msgsnd>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/sysvipc.7:48
msgid "Add a message to a queue."
msgstr ""

#. type: TP
#: build/C/man7/sysvipc.7:48
#, no-wrap
msgid "B<msgrcv>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/sysvipc.7:51
msgid "Remove a message from a queue."
msgstr ""

#. type: TP
#: build/C/man7/sysvipc.7:51
#, no-wrap
msgid "B<msgctl>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/sysvipc.7:55
msgid "Perform various control operations on a queue, including deletion."
msgstr ""

#. type: SS
#: build/C/man7/sysvipc.7:55
#, no-wrap
msgid "Semaphore sets"
msgstr ""

#. type: Plain text
#: build/C/man7/sysvipc.7:62
msgid ""
"System V semaphores allow processes to synchronize their actions System V "
"semaphores are allocated in groups called sets; each semaphore in a set is a "
"counting semaphore.  POSIX semaphores provide an alternative API for "
"achieving the same result; see B<sem_overview>(7)."
msgstr ""

#. type: Plain text
#: build/C/man7/sysvipc.7:64
msgid "The System V semaphore API consists of the following system calls:"
msgstr ""

#. type: TP
#: build/C/man7/sysvipc.7:64
#, no-wrap
msgid "B<semget>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/sysvipc.7:68
msgid ""
"Create a new set or obtain the ID of an existing set.  This call returns an "
"identifier that is used in the remaining APIs."
msgstr ""

#. type: TP
#: build/C/man7/sysvipc.7:68
#, no-wrap
msgid "B<semop>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/sysvipc.7:71
msgid "Perform operations on the semaphores in a set."
msgstr ""

#. type: TP
#: build/C/man7/sysvipc.7:71
#, no-wrap
msgid "B<semctl>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/sysvipc.7:75
msgid "Perform various control operations on a set, including deletion."
msgstr ""

#. type: SS
#: build/C/man7/sysvipc.7:75
#, no-wrap
msgid "Shared memory segments"
msgstr ""

#. type: Plain text
#: build/C/man7/sysvipc.7:80
msgid ""
"System V shared memory allows processes to share a region a memory (a "
"\"segment\").  POSIX shared memory is an alternative API for achieving the "
"same result; see B<shm_overview>(7)."
msgstr ""

#. type: Plain text
#: build/C/man7/sysvipc.7:82
msgid "The System V shared memory API consists of the following system calls:"
msgstr ""

#. type: TP
#: build/C/man7/sysvipc.7:82
#, no-wrap
msgid "B<shmget>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/sysvipc.7:86
msgid ""
"Create a new segment or obtain the ID of an existing segment.  This call "
"returns an identifier that is used in the remaining APIs."
msgstr ""

#. type: TP
#: build/C/man7/sysvipc.7:86
#, no-wrap
msgid "B<shmat>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/sysvipc.7:90
msgid ""
"Attach an existing shared memory object into the calling process's address "
"space."
msgstr ""

#. type: TP
#: build/C/man7/sysvipc.7:90
#, no-wrap
msgid "B<shmdt>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/sysvipc.7:93
msgid "Detach a segment from the calling process's address space."
msgstr ""

#. type: TP
#: build/C/man7/sysvipc.7:93
#, no-wrap
msgid "B<shmctl>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/sysvipc.7:97
msgid "Perform various control operations on a segment, including deletion."
msgstr ""

#. type: SS
#: build/C/man7/sysvipc.7:97
#, no-wrap
msgid "IPC namespaces"
msgstr ""

#. type: Plain text
#: build/C/man7/sysvipc.7:101
msgid ""
"For a discussion of the interaction of System V IPC objects and IPC "
"namespaces, see B<ipc_namespaces>(7)."
msgstr ""

#. type: Plain text
#: build/C/man7/sysvipc.7:120
msgid ""
"B<ipcmk>(1), B<ipcrm>(1), B<ipcs>(1), B<lsipc>(1), B<ipc>(2), B<msgctl>(2), "
"B<msgget>(2), B<msgrcv>(2), B<msgsnd>(2), B<semctl>(2), B<semget>(2), "
"B<semop>(2), B<shmat>(2), B<shmctl>(2), B<shmdt>(2), B<shmget>(2), "
"B<ftok>(3), B<ipc_namespaces>(7)"
msgstr ""

#. type: TH
#: build/C/man3/ulimit.3:27
#, no-wrap
msgid "ULIMIT"
msgstr ""

#. type: Plain text
#: build/C/man3/ulimit.3:30
msgid "ulimit - get and set user limits"
msgstr ""

#. type: Plain text
#: build/C/man3/ulimit.3:32
msgid "B<#include E<lt>ulimit.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man3/ulimit.3:34
msgid "B<long ulimit(int >I<cmd>B<, long >I<newlimit>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/ulimit.3:46
msgid ""
"Warning: this routine is obsolete.  Use B<getrlimit>(2), B<setrlimit>(2), "
"and B<sysconf>(3)  instead.  For the shell command B<ulimit>(), see "
"B<bash>(1)."
msgstr ""

#. type: Plain text
#: build/C/man3/ulimit.3:53
msgid ""
"The B<ulimit>()  call will get or set some limit for the calling process.  "
"The I<cmd> argument can have one of the following values."
msgstr ""

#. type: TP
#: build/C/man3/ulimit.3:53
#, no-wrap
msgid "B<UL_GETFSIZE>"
msgstr ""

#. type: Plain text
#: build/C/man3/ulimit.3:56
msgid "Return the limit on the size of a file, in units of 512 bytes."
msgstr ""

#. type: TP
#: build/C/man3/ulimit.3:56
#, no-wrap
msgid "B<UL_SETFSIZE>"
msgstr ""

#. type: Plain text
#: build/C/man3/ulimit.3:59
msgid "Set the limit on the size of a file."
msgstr ""

#. type: TP
#: build/C/man3/ulimit.3:59
#, no-wrap
msgid "B<3>"
msgstr ""

#. type: Plain text
#: build/C/man3/ulimit.3:63
msgid ""
"(Not implemented for Linux.)  Return the maximum possible address of the "
"data segment."
msgstr ""

#. type: TP
#: build/C/man3/ulimit.3:63
#, no-wrap
msgid "B<4>"
msgstr ""

#. type: Plain text
#: build/C/man3/ulimit.3:67
msgid ""
"(Implemented but no symbolic constant provided.)  Return the maximum number "
"of files that the calling process can open."
msgstr ""

#. type: Plain text
#: build/C/man3/ulimit.3:74
msgid ""
"On success, B<ulimit>()  returns a nonnegative value.  On error, -1 is "
"returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man3/ulimit.3:78
msgid "An unprivileged process tried to increase a limit."
msgstr ""

#. type: tbl table
#: build/C/man3/ulimit.3:88
#, no-wrap
msgid "B<ulimit>()"
msgstr ""

#. type: Plain text
#: build/C/man3/ulimit.3:96
msgid "SVr4, POSIX.1-2001.  POSIX.1-2008 marks B<ulimit>()  as obsolete."
msgstr ""

#. type: Plain text
#: build/C/man3/ulimit.3:101
msgid "B<bash>(1), B<getrlimit>(2), B<setrlimit>(2), B<sysconf>(3)"
msgstr ""

#. type: TH
#: build/C/man2/seccomp.2:28
#, no-wrap
msgid "SECCOMP"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:31
msgid "seccomp - operate on Secure Computing state of the process"
msgstr ""

#.  Kees Cook noted: Anything that uses SECCOMP_RET_TRACE returns will
#.                   need <sys/ptrace.h>
#. type: Plain text
#: build/C/man2/seccomp.2:40
#, no-wrap
msgid ""
"B<#include E<lt>linux/seccomp.hE<gt>>\n"
"B<#include E<lt>linux/filter.hE<gt>>\n"
"B<#include E<lt>linux/audit.hE<gt>>\n"
"B<#include E<lt>linux/signal.hE<gt>>\n"
"B<#include E<lt>sys/ptrace.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:43
#, no-wrap
msgid ""
"B<int seccomp(unsigned int >I<operation>B<, unsigned int >I<flags>B<, void "
"*>I<args>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:49
msgid ""
"The B<seccomp>()  system call operates on the Secure Computing (seccomp) "
"state of the calling process."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:53
msgid "Currently, Linux supports the following I<operation> values:"
msgstr ""

#. type: TP
#: build/C/man2/seccomp.2:53
#, no-wrap
msgid "B<SECCOMP_SET_MODE_STRICT>"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:69
msgid ""
"The only system calls that the calling thread is permitted to make are "
"B<read>(2), B<write>(2), B<_exit>(2)  (but not B<exit_group>(2)), and "
"B<sigreturn>(2).  Other system calls result in the delivery of a B<SIGKILL> "
"signal.  Strict secure computing mode is useful for number-crunching "
"applications that may need to execute untrusted byte code, perhaps obtained "
"by reading from a pipe or socket."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:96
msgid ""
"Note that although the calling thread can no longer call B<sigprocmask>(2), "
"it can use B<sigreturn>(2)  to block all signals apart from B<SIGKILL> and "
"B<SIGSTOP>.  This means that B<alarm>(2)  (for example) is not sufficient "
"for restricting the process's execution time.  Instead, to reliably "
"terminate the process, B<SIGKILL> must be used.  This can be done by using "
"B<timer_create>(2)  with B<SIGEV_SIGNAL> and I<sigev_signo> set to "
"B<SIGKILL>, or by using B<setrlimit>(2)  to set the hard limit for "
"B<RLIMIT_CPU>."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:100
msgid ""
"This operation is available only if the kernel is configured with "
"B<CONFIG_SECCOMP> enabled."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:106
msgid "The value of I<flags> must be 0, and I<args> must be NULL."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:108
msgid "This operation is functionally identical to the call:"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:112
#, no-wrap
msgid "prctl(PR_SET_SECCOMP, SECCOMP_MODE_STRICT);\n"
msgstr ""

#. type: TP
#: build/C/man2/seccomp.2:114
#, no-wrap
msgid "B<SECCOMP_SET_MODE_FILTER>"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:129
msgid ""
"The system calls allowed are defined by a pointer to a Berkeley Packet "
"Filter (BPF) passed via I<args>.  This argument is a pointer to a I<struct\\ "
"sock_fprog>; it can be designed to filter arbitrary system calls and system "
"call arguments.  If the filter is invalid, B<seccomp>()  fails, returning "
"B<EINVAL> in I<errno>."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:141
msgid ""
"If B<fork>(2)  or B<clone>(2)  is allowed by the filter, any child processes "
"will be constrained to the same system call filters as the parent.  If "
"B<execve>(2)  is allowed, the existing filters will be preserved across a "
"call to B<execve>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:151
msgid ""
"In order to use the B<SECCOMP_SET_MODE_FILTER> operation, either the calling "
"thread must have the B<CAP_SYS_ADMIN> capability in its user namespace, or "
"the thread must already have the I<no_new_privs> bit set.  If that bit was "
"not already set by an ancestor of this thread, the thread must make the "
"following call:"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:155
#, no-wrap
msgid "prctl(PR_SET_NO_NEW_PRIVS, 1);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:176
msgid ""
"Otherwise, the B<SECCOMP_SET_MODE_FILTER> operation fails and returns "
"B<EACCES> in I<errno>.  This requirement ensures that an unprivileged "
"process cannot apply a malicious filter and then invoke a set-user-ID or "
"other privileged program using B<execve>(2), thus potentially compromising "
"that program.  (Such a malicious filter might, for example, cause an attempt "
"to use B<setuid>(2)  to set the caller's user IDs to nonzero values to "
"instead return 0 without actually making the system call.  Thus, the program "
"might be tricked into retaining superuser privileges in circumstances where "
"it is possible to influence it to do dangerous things because it did not "
"actually drop privileges.)"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:184
msgid ""
"If B<prctl>(2)  or B<seccomp>()  is allowed by the attached filter, further "
"filters may be added.  This will increase evaluation time, but allows for "
"further reduction of the attack surface during execution of a thread."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:190
msgid ""
"The B<SECCOMP_SET_MODE_FILTER> operation is available only if the kernel is "
"configured with B<CONFIG_SECCOMP_FILTER> enabled."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:194
msgid "When I<flags> is 0, this operation is functionally identical to the call:"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:198
#, no-wrap
msgid "prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, args);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:204
msgid "The recognized I<flags> are:"
msgstr ""

#. type: TP
#: build/C/man2/seccomp.2:205
#, no-wrap
msgid "B<SECCOMP_FILTER_FLAG_TSYNC>"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:213
msgid ""
"When adding a new filter, synchronize all other threads of the calling "
"process to the same seccomp filter tree.  A \"filter tree\" is the ordered "
"list of filters attached to a thread.  (Attaching identical filters in "
"separate B<seccomp>()  calls results in different filters from this "
"perspective.)"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:221
msgid ""
"If any thread cannot synchronize to the same filter tree, the call will not "
"attach the new seccomp filter, and will fail, returning the first thread ID "
"found that cannot synchronize.  Synchronization will fail if another thread "
"in the same process is in B<SECCOMP_MODE_STRICT> or if it has attached new "
"seccomp filters to itself, diverging from the calling thread's filter tree."
msgstr ""

#. type: TP
#: build/C/man2/seccomp.2:221
#, no-wrap
msgid "B<SECCOMP_FILTER_FLAG_LOG> (since Linux 4.14)"
msgstr ""

#.  commit e66a39977985b1e69e17c4042cb290768eca9b02
#. type: Plain text
#: build/C/man2/seccomp.2:231
msgid ""
"All filter return actions except B<SECCOMP_RET_ALLOW> should be logged.  An "
"administrator may override this filter flag by preventing specific actions "
"from being logged via the I</proc/sys/kernel/seccomp/actions_logged> file."
msgstr ""

#. type: TP
#: build/C/man2/seccomp.2:231
#, no-wrap
msgid "B<SECCOMP_FILTER_FLAG_SPEC_ALLOW> (since Linux 4.17)"
msgstr ""

#.  commit 00a02d0c502a06d15e07b857f8ff921e3e402675
#. type: Plain text
#: build/C/man2/seccomp.2:235
msgid "Disable Speculative Store Bypass mitigation."
msgstr ""

#. type: TP
#: build/C/man2/seccomp.2:236
#, no-wrap
msgid "B<SECCOMP_GET_ACTION_AVAIL> (since Linux 4.14)"
msgstr ""

#.  commit d612b1fd8010d0d67b5287fe146b8b55bcbb8655
#. type: Plain text
#: build/C/man2/seccomp.2:244
msgid ""
"Test to see if an action is supported by the kernel.  This operation is "
"helpful to confirm that the kernel knows of a more recently added filter "
"return action since the kernel treats all unknown actions as "
"B<SECCOMP_RET_KILL_PROCESS>."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:250
msgid ""
"The value of I<flags> must be 0, and I<args> must be a pointer to an "
"unsigned 32-bit filter return action."
msgstr ""

#. type: SS
#: build/C/man2/seccomp.2:250
#, no-wrap
msgid "Filters"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:255
msgid ""
"When adding filters via B<SECCOMP_SET_MODE_FILTER>, I<args> points to a "
"filter program:"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:263
#, no-wrap
msgid ""
"struct sock_fprog {\n"
"    unsigned short      len;    /* Number of BPF instructions */\n"
"    struct sock_filter *filter; /* Pointer to array of\n"
"                                   BPF instructions */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:267
msgid "Each program must contain one or more BPF instructions:"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:276
#, no-wrap
msgid ""
"struct sock_filter {            /* Filter block */\n"
"    __u16 code;                 /* Actual filter code */\n"
"    __u8  jt;                   /* Jump true */\n"
"    __u8  jf;                   /* Jump false */\n"
"    __u32 k;                    /* Generic multiuse field */\n"
"};\n"
msgstr ""

#.  Quoting Kees Cook:
#.      If BPF even allows changing the data, it's not copied back to
#.      the syscall when it runs. Anything wanting to do things like
#.      that would need to use ptrace to catch the call and directly
#.      modify the registers before continuing with the call.
#. type: Plain text
#: build/C/man2/seccomp.2:289
msgid ""
"When executing the instructions, the BPF program operates on the system call "
"information made available (i.e., use the B<BPF_ABS> addressing mode) as a "
"(read-only)  buffer of the following form:"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:299
#, no-wrap
msgid ""
"struct seccomp_data {\n"
"    int   nr;                   /* System call number */\n"
"    __u32 arch;                 /* AUDIT_ARCH_* value\n"
"                                   (see E<lt>linux/audit.hE<gt>) */\n"
"    __u64 instruction_pointer;  /* CPU instruction pointer */\n"
"    __u64 args[6];              /* Up to 6 system call arguments */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:311
msgid ""
"Because numbering of system calls varies between architectures and some "
"architectures (e.g., x86-64) allow user-space code to use the calling "
"conventions of multiple architectures (and the convention being used may "
"vary over the life of a process that uses B<execve>(2)  to execute binaries "
"that employ the different conventions), it is usually necessary to verify "
"the value of the I<arch> field."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:322
msgid ""
"It is strongly recommended to use an allow-list approach whenever possible "
"because such an approach is more robust and simple.  A deny-list will have "
"to be updated whenever a potentially dangerous system call is added (or a "
"dangerous flag or option if those are deny-listed), and it is often possible "
"to alter the representation of a value without altering its meaning, leading "
"to a deny-list bypass.  See also I<Caveats> below."
msgstr ""

#.  As noted by Dave Drysdale in a note at the end of
#.  https://lwn.net/Articles/604515/
#.      One additional detail to point out for the x32 ABI case:
#.      the syscall number gets a high bit set (__X32_SYSCALL_BIT),
#.      to mark it as an x32 call.
#
#.      If x32 support is included in the kernel, then __SYSCALL_MASK
#.      will have a value that is not all-ones, and this will trigger
#.      an extra instruction in system_call to mask off the extra bit,
#.      so that the syscall table indexing still works.
#. type: Plain text
#: build/C/man2/seccomp.2:344
msgid ""
"The I<arch> field is not unique for all calling conventions.  The x86-64 ABI "
"and the x32 ABI both use B<AUDIT_ARCH_X86_64> as I<arch>, and they run on "
"the same processors.  Instead, the mask B<__X32_SYSCALL_BIT> is used on the "
"system call number to tell the two ABIs apart."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:358
msgid ""
"This means that a policy must either deny all syscalls with "
"B<__X32_SYSCALL_BIT> or it must recognize syscalls with and without "
"B<__X32_SYSCALL_BIT> set.  A list of system calls to be denied based on "
"I<nr> that does not also contain I<nr> values with B<__X32_SYSCALL_BIT> set "
"can be bypassed by a malicious program that sets B<__X32_SYSCALL_BIT>."
msgstr ""

#.  commit 6365b842aae4490ebfafadfc6bb27a6d3cc54757
#. type: Plain text
#: build/C/man2/seccomp.2:380
msgid ""
"Additionally, kernels prior to Linux 5.4 incorrectly permitted I<nr> in the "
"ranges 512-547 as well as the corresponding non-x32 syscalls ORed with "
"B<__X32_SYSCALL_BIT>.  For example, I<nr> == 521 and I<nr> == (101 | "
"B<__X32_SYSCALL_BIT>)  would result in invocations of B<ptrace>(2)  with "
"potentially confused x32-vs-x86_64 semantics in the kernel.  Policies "
"intended to work on kernels before Linux 5.4 must ensure that they deny or "
"otherwise correctly handle these system calls.  On Linux 5.4 and newer, such "
"system calls will fail with the error B<ENOSYS>, without doing anything."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:394
msgid ""
"The I<instruction_pointer> field provides the address of the "
"machine-language instruction that performed the system call.  This might be "
"useful in conjunction with the use of I</proc/[pid]/maps> to perform checks "
"based on which region (mapping) of the program made the system call.  "
"(Probably, it is wise to lock down the B<mmap>(2)  and B<mprotect>(2)  "
"system calls to prevent the program from subverting such checks.)"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:408
msgid ""
"When checking values from I<args>, keep in mind that arguments are often "
"silently truncated before being processed, but after the seccomp check.  For "
"example, this happens if the i386 ABI is used on an x86-64 kernel: although "
"the kernel will normally not look beyond the 32 lowest bits of the "
"arguments, the values of the full 64-bit registers will be present in the "
"seccomp data.  A less surprising example is that if the x86-64 ABI is used "
"to perform a system call that takes an argument of type I<int>, the "
"more-significant half of the argument register is ignored by the system "
"call, but visible in the seccomp data."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:417
msgid ""
"A seccomp filter returns a 32-bit value consisting of two parts: the most "
"significant 16 bits (corresponding to the mask defined by the constant "
"B<SECCOMP_RET_ACTION_FULL>)  contain one of the \"action\" values listed "
"below; the least significant 16-bits (defined by the constant "
"B<SECCOMP_RET_DATA>)  are \"data\" to be associated with this return value."
msgstr ""

#.  From an Aug 2015 conversation with Kees Cook where I asked why *all*
#.  filters are applied even if one of the early filters returns
#.  SECCOMP_RET_KILL:
#
#.      It's just because it would be an optimization that would only speed up
#.      the RET_KILL case, but it's the uncommon one and the one that doesn't
#.      benefit meaningfully from such a change (you need to kill the process
#.      really quickly?). We would speed up killing a program at the (albeit
#.      tiny) expense to all other filtered programs. Best to keep the filter
#.      execution logic clear, simple, and as fast as possible for all
#.      filters.
#. type: Plain text
#: build/C/man2/seccomp.2:441
msgid ""
"If multiple filters exist, they are I<all> executed, in reverse order of "
"their addition to the filter tree\\(emthat is, the most recently installed "
"filter is executed first.  (Note that all filters will be called even if one "
"of the earlier filters returns B<SECCOMP_RET_KILL>.  This is done to "
"simplify the kernel code and to provide a tiny speed-up in the execution of "
"sets of filters by avoiding a check for this uncommon case.)  The return "
"value for the evaluation of a given system call is the first-seen action "
"value of highest precedence (along with its accompanying data)  returned by "
"execution of all of the filters."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:444
msgid ""
"In decreasing order of precedence, the action values that may be returned by "
"a seccomp filter are:"
msgstr ""

#. type: TP
#: build/C/man2/seccomp.2:444
#, no-wrap
msgid "B<SECCOMP_RET_KILL_PROCESS> (since Linux 4.14)"
msgstr ""

#.  commit 4d3b0b05aae9ee9ce0970dc4cc0fb3fad5e85945
#.  commit 0466bdb99e8744bc9befa8d62a317f0fd7fd7421
#. type: Plain text
#: build/C/man2/seccomp.2:458
msgid ""
"This value results in immediate termination of the process, with a core "
"dump.  The system call is not executed.  By contrast with "
"B<SECCOMP_RET_KILL_THREAD> below, all threads in the thread group are "
"terminated.  (For a discussion of thread groups, see the description of the "
"B<CLONE_THREAD> flag in B<clone>(2).)"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:474
msgid ""
"The process terminates I<as though> killed by a B<SIGSYS> signal.  Even if a "
"signal handler has been registered for B<SIGSYS>, the handler will be "
"ignored in this case and the process always terminates.  To a parent process "
"that is waiting on this process (using B<waitpid>(2)  or similar), the "
"returned I<wstatus> will indicate that its child was terminated as though by "
"a B<SIGSYS> signal."
msgstr ""

#. type: TP
#: build/C/man2/seccomp.2:474
#, no-wrap
msgid "B<SECCOMP_RET_KILL_THREAD> (or B<SECCOMP_RET_KILL>)"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:480
msgid ""
"This value results in immediate termination of the thread that made the "
"system call.  The system call is not executed.  Other threads in the same "
"thread group will continue to execute."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:489
msgid ""
"The thread terminates I<as though> killed by a B<SIGSYS> signal.  See "
"B<SECCOMP_RET_KILL_PROCESS> above."
msgstr ""

#.  See these commits:
#.  seccomp: dump core when using SECCOMP_RET_KILL
#.     (b25e67161c295c98acda92123b2dd1e7d8642901)
#.  seccomp: Only dump core when single-threaded
#.     (d7276e321ff8a53106a59c85ca46d03e34288893)
#. type: Plain text
#: build/C/man2/seccomp.2:504
msgid ""
"Before Linux 4.11, any process terminated in this way would not trigger a "
"coredump (even though B<SIGSYS> is documented in B<signal>(7)  as having a "
"default action of termination with a core dump).  Since Linux 4.11, a "
"single-threaded process will dump core if terminated in this way."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:512
msgid ""
"With the addition of B<SECCOMP_RET_KILL_PROCESS> in Linux 4.14, "
"B<SECCOMP_RET_KILL_THREAD> was added as a synonym for B<SECCOMP_RET_KILL>, "
"in order to more clearly distinguish the two actions."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:518
msgid ""
"B<Note>: the use of B<SECCOMP_RET_KILL_THREAD> to kill a single thread in a "
"multithreaded process is likely to leave the process in a permanently "
"inconsistent and possibly corrupt state."
msgstr ""

#. type: TP
#: build/C/man2/seccomp.2:518
#, no-wrap
msgid "B<SECCOMP_RET_TRAP>"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:529
msgid ""
"This value results in the kernel sending a thread-directed B<SIGSYS> signal "
"to the triggering thread.  (The system call is not executed.)  Various "
"fields will be set in the I<siginfo_t> structure (see B<sigaction>(2))  "
"associated with signal:"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:534
msgid "I<si_signo> will contain B<SIGSYS>."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:537
msgid "I<si_call_addr> will show the address of the system call instruction."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:542
msgid "I<si_syscall> and I<si_arch> will indicate which system call was attempted."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:546
msgid "I<si_code> will contain B<SYS_SECCOMP>."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:551
msgid ""
"I<si_errno> will contain the B<SECCOMP_RET_DATA> portion of the filter "
"return value."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:560
msgid ""
"The program counter will be as though the system call happened (i.e., the "
"program counter will not point to the system call instruction).  The return "
"value register will contain an architecture-dependent value; if resuming "
"execution, set it to something appropriate for the system call.  (The "
"architecture dependency is because replacing it with B<ENOSYS> could "
"overwrite some useful information.)"
msgstr ""

#. type: TP
#: build/C/man2/seccomp.2:560
#, no-wrap
msgid "B<SECCOMP_RET_ERRNO>"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:567
msgid ""
"This value results in the B<SECCOMP_RET_DATA> portion of the filter's return "
"value being passed to user space as the I<errno> value without executing the "
"system call."
msgstr ""

#. type: TP
#: build/C/man2/seccomp.2:567
#, no-wrap
msgid "B<SECCOMP_RET_TRACE>"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:577
msgid ""
"When returned, this value will cause the kernel to attempt to notify a "
"B<ptrace>(2)-based tracer prior to executing the system call.  If there is "
"no tracer present, the system call is not executed and returns a failure "
"status with I<errno> set to B<ENOSYS>."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:588
msgid ""
"A tracer will be notified if it requests B<PTRACE_O_TRACESECCOMP> using "
"I<ptrace(PTRACE_SETOPTIONS)>.  The tracer will be notified of a "
"B<PTRACE_EVENT_SECCOMP> and the B<SECCOMP_RET_DATA> portion of the filter's "
"return value will be available to the tracer via B<PTRACE_GETEVENTMSG>."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:595
msgid ""
"The tracer can skip the system call by changing the system call number to "
"-1.  Alternatively, the tracer can change the system call requested by "
"changing the system call to a valid system call number.  If the tracer asks "
"to skip the system call, then the system call will appear to return the "
"value that the tracer puts in the return value register."
msgstr ""

#.  This was changed in ce6526e8afa4.
#.  A related hole, using PTRACE_SYSCALL instead of SECCOMP_RET_TRACE, was
#.  changed in arch-specific commits, e.g. 93e35efb8de4 for X86 and
#.  0f3912fd934c for ARM.
#. type: Plain text
#: build/C/man2/seccomp.2:609
msgid ""
"Before kernel 4.8, the seccomp check will not be run again after the tracer "
"is notified.  (This means that, on older kernels, seccomp-based sandboxes "
"B<must not> allow use of B<ptrace>(2)\\(emeven of other sandboxed "
"processes\\(emwithout extreme care; ptracers can use this mechanism to "
"escape from the seccomp sandbox.)"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:613
msgid ""
"Note that a tracer process will not be notified if another filter returns an "
"action value with a precedence greater than B<SECCOMP_RET_TRACE>."
msgstr ""

#. type: TP
#: build/C/man2/seccomp.2:613
#, no-wrap
msgid "B<SECCOMP_RET_LOG> (since Linux 4.14)"
msgstr ""

#.  commit 59f5cf44a38284eb9e76270c786fb6cc62ef8ac4
#. type: Plain text
#: build/C/man2/seccomp.2:622
msgid ""
"This value results in the system call being executed after the filter return "
"action is logged.  An administrator may override the logging of this action "
"via the I</proc/sys/kernel/seccomp/actions_logged> file."
msgstr ""

#. type: TP
#: build/C/man2/seccomp.2:622
#, no-wrap
msgid "B<SECCOMP_RET_ALLOW>"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:625
msgid "This value results in the system call being executed."
msgstr ""

#.  commit 4d3b0b05aae9ee9ce0970dc4cc0fb3fad5e85945
#. type: Plain text
#: build/C/man2/seccomp.2:635
msgid ""
"If an action value other than one of the above is specified, then the filter "
"action is treated as either B<SECCOMP_RET_KILL_PROCESS> (since Linux 4.14)  "
"or B<SECCOMP_RET_KILL_THREAD> (in Linux 4.13 and earlier)."
msgstr ""

#. type: SS
#: build/C/man2/seccomp.2:635
#, no-wrap
msgid "/proc interfaces"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:639
msgid ""
"The files in the directory I</proc/sys/kernel/seccomp> provide additional "
"seccomp information and configuration:"
msgstr ""

#. type: TP
#: build/C/man2/seccomp.2:639
#, no-wrap
msgid "I<actions_avail> (since Linux 4.14)"
msgstr ""

#.  commit 8e5f1ad116df6b0de65eac458d5e7c318d1c05af
#. type: Plain text
#: build/C/man2/seccomp.2:646
msgid ""
"A read-only ordered list of seccomp filter return actions in string form.  "
"The ordering, from left-to-right, is in decreasing order of precedence.  The "
"list represents the set of seccomp filter return actions supported by the "
"kernel."
msgstr ""

#. type: TP
#: build/C/man2/seccomp.2:646
#, no-wrap
msgid "I<actions_logged> (since Linux 4.14)"
msgstr ""

#.  commit 0ddec0fc8900201c0897b87b762b7c420436662f
#. type: Plain text
#: build/C/man2/seccomp.2:655
msgid ""
"A read-write ordered list of seccomp filter return actions that are allowed "
"to be logged.  Writes to the file do not need to be in ordered form but "
"reads from the file will be ordered in the same way as the I<actions_avail> "
"file."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:666
msgid ""
"It is important to note that the value of I<actions_logged> does not prevent "
"certain filter return actions from being logged when the audit subsystem is "
"configured to audit a task.  If the action is not found in the "
"I<actions_logged> file, the final decision on whether to audit the action "
"for that task is ultimately left up to the audit subsystem to decide for all "
"filter return actions other than B<SECCOMP_RET_ALLOW>."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:675
msgid ""
"The \"allow\" string is not accepted in the I<actions_logged> file as it is "
"not possible to log B<SECCOMP_RET_ALLOW> actions.  Attempting to write "
"\"allow\" to the file will fail with the error B<EINVAL>."
msgstr ""

#. type: SS
#: build/C/man2/seccomp.2:675
#, no-wrap
msgid "Audit logging of seccomp actions"
msgstr ""

#.  commit 59f5cf44a38284eb9e76270c786fb6cc62ef8ac4
#.  or auditing could be enabled via the netlink API (AUDIT_SET)
#. type: Plain text
#: build/C/man2/seccomp.2:687
msgid ""
"Since Linux 4.14, the kernel provides the facility to log the actions "
"returned by seccomp filters in the audit log.  The kernel makes the decision "
"to log an action based on the action type, whether or not the action is "
"present in the I<actions_logged> file, and whether kernel auditing is "
"enabled (e.g., via the kernel boot option I<audit=1>).  The rules are as "
"follows:"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:691
msgid "If the action is B<SECCOMP_RET_ALLOW>, the action is not logged."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:699
msgid ""
"Otherwise, if the action is either B<SECCOMP_RET_KILL_PROCESS> or "
"B<SECCOMP_RET_KILL_THREAD>, and that action appears in the I<actions_logged> "
"file, the action is logged."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:706
msgid ""
"Otherwise, if the filter has requested logging (the "
"B<SECCOMP_FILTER_FLAG_LOG> flag)  and the action appears in the "
"I<actions_logged> file, the action is logged."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:710
msgid ""
"Otherwise, if kernel auditing is enabled and the process is being audited "
"(B<autrace>(8)), the action is logged."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:712
msgid "Otherwise, the action is not logged."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:728
msgid ""
"On success, B<seccomp>()  returns 0.  On error, if "
"B<SECCOMP_FILTER_FLAG_TSYNC> was used, the return value is the ID of the "
"thread that caused the synchronization failure.  (This ID is a kernel thread "
"ID of the type returned by B<clone>(2)  and B<gettid>(2).)  On other errors, "
"-1 is returned, and I<errno> is set to indicate the cause of the error."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:731
msgid "B<seccomp>()  can fail for the following reasons:"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:739
msgid ""
"The caller did not have the B<CAP_SYS_ADMIN> capability in its user "
"namespace, or had not set I<no_new_privs> before using "
"B<SECCOMP_SET_MODE_FILTER>."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:743
msgid "I<args> was not a valid address."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:747
msgid ""
"I<operation> is unknown or is not supported by this kernel version or "
"configuration."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:753
msgid "The specified I<flags> are invalid for the given I<operation>."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:760
msgid ""
"I<operation> included B<BPF_ABS>, but the specified offset was not aligned "
"to a 32-bit boundary or exceeded I<sizeof(struct\\ seccomp_data)>."
msgstr ""

#.  See kernel/seccomp.c::seccomp_may_assign_mode() in 3.18 sources
#. type: Plain text
#: build/C/man2/seccomp.2:766
msgid ""
"A secure computing mode has already been set, and I<operation> differs from "
"the existing setting."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:776
msgid ""
"I<operation> specified B<SECCOMP_SET_MODE_FILTER>, but the filter program "
"pointed to by I<args> was not valid or the length of the filter program was "
"zero or exceeded B<BPF_MAXINSNS> (4096) instructions."
msgstr ""

#.  ENOMEM in kernel/seccomp.c::seccomp_attach_filter() in 3.18 sources
#. type: Plain text
#: build/C/man2/seccomp.2:789
msgid ""
"The total length of all filter programs attached to the calling thread would "
"exceed B<MAX_INSNS_PER_PATH> (32768) instructions.  Note that for the "
"purposes of calculating this limit, each already existing filter program "
"incurs an overhead penalty of 4 instructions."
msgstr ""

#. type: TP
#: build/C/man2/seccomp.2:789
#, no-wrap
msgid "B<EOPNOTSUPP>"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:796
msgid ""
"I<operation> specified B<SECCOMP_GET_ACTION_AVAIL>, but the kernel does not "
"support the filter return action specified by I<args>."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:800
msgid ""
"Another thread caused a failure during thread sync, but its ID could not be "
"determined."
msgstr ""

#.  FIXME . Add glibc version
#. type: Plain text
#: build/C/man2/seccomp.2:805
msgid "The B<seccomp>()  system call first appeared in Linux 3.17."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:809
msgid "The B<seccomp>()  system call is a nonstandard Linux extension."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:814
msgid ""
"Rather than hand-coding seccomp filters as shown in the example below, you "
"may prefer to employ the I<libseccomp> library, which provides a front-end "
"for generating seccomp filters."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:821
msgid ""
"The I<Seccomp> field of the I</proc/[pid]/status> file provides a method of "
"viewing the seccomp mode of a process; see B<proc>(5)."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:828
msgid ""
"B<seccomp>()  provides a superset of the functionality provided by the "
"B<prctl>(2)  B<PR_SET_SECCOMP> operation (which does not support I<flags>)."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:834
msgid ""
"Since Linux 4.4, the B<ptrace>(2)  B<PTRACE_SECCOMP_GET_FILTER> operation "
"can be used to dump a process's seccomp filters."
msgstr ""

#. type: SS
#: build/C/man2/seccomp.2:834
#, no-wrap
msgid "Architecture support for seccomp BPF"
msgstr ""

#.  Check by grepping for HAVE_ARCH_SECCOMP_FILTER in Kconfig files in
#.  kernel source. Last checked in Linux 4.16-rc source.
#. type: Plain text
#: build/C/man2/seccomp.2:839
msgid ""
"Architecture support for seccomp BPF filtering is available on the following "
"architectures:"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:841
msgid "x86-64, i386, x32 (since Linux 3.5)"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:844
msgid "ARM (since Linux 3.8)"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:846
msgid "s390 (since Linux 3.8)"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:848
msgid "MIPS (since Linux 3.16)"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:850
msgid "ARM-64 (since Linux 3.19)"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:852
msgid "PowerPC (since Linux 4.3)"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:854
msgid "Tile (since Linux 4.3)"
msgstr ""

#.  User mode Linux since Linux 4.6
#. type: Plain text
#: build/C/man2/seccomp.2:857
msgid "PA-RISC (since Linux 4.6)"
msgstr ""

#. type: SS
#: build/C/man2/seccomp.2:859
#, no-wrap
msgid "Caveats"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:862
msgid ""
"There are various subtleties to consider when applying seccomp filters to a "
"program, including the following:"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:877
msgid ""
"Some traditional system calls have user-space implementations in the "
"B<vdso>(7)  on many architectures.  Notable examples include "
"B<clock_gettime>(2), B<gettimeofday>(2), and B<time>(2).  On such "
"architectures, seccomp filtering for these system calls will have no "
"effect.  (However, there are cases where the B<vdso>(7)  implementations may "
"fall back to invoking the true system call, in which case seccomp filters "
"would see the system call.)"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:883
msgid ""
"Seccomp filtering is based on system call numbers.  However, applications "
"typically do not directly invoke system calls, but instead call wrapper "
"functions in the C library which in turn invoke the system calls.  "
"Consequently, one must be aware of the following:"
msgstr ""

#. type: IP
#: build/C/man2/seccomp.2:884 build/C/man2/seccomp.2:895 build/C/man2/seccomp.2:900 build/C/man7/cgroups.7:1590 build/C/man7/cgroups.7:1597 build/C/man7/cgroups.7:1602 build/C/man2/pidfd_getfd.2:134 build/C/man2/pidfd_getfd.2:139 build/C/man2/pidfd_getfd.2:146 build/C/man2/pidfd_open.2:114 build/C/man2/pidfd_open.2:121 build/C/man2/pidfd_open.2:131 build/C/man2/pidfd_open.2:153 build/C/man2/pidfd_open.2:158 build/C/man2/pidfd_open.2:171 build/C/man2/pidfd_open.2:175 build/C/man2/pidfd_open.2:180
#, no-wrap
msgid "\\(bu"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:895
msgid ""
"The glibc wrappers for some traditional system calls may actually employ "
"system calls with different names in the kernel.  For example, the "
"B<exit>(2)  wrapper function actually employs the B<exit_group>(2)  system "
"call, and the B<fork>(2)  wrapper function actually calls B<clone>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:900
msgid ""
"The behavior of wrapper functions may vary across architectures, according "
"to the range of system calls provided on those architectures.  In other "
"words, the same wrapper function may invoke different system calls on "
"different architectures."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:908
msgid ""
"Finally, the behavior of wrapper functions can change across glibc "
"versions.  For example, in older versions, the glibc wrapper function for "
"B<open>(2)  invoked the system call of the same name, but starting in glibc "
"2.26, the implementation switched to calling B<openat>(2)  on all "
"architectures."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:916
msgid ""
"The consequence of the above points is that it may be necessary to filter "
"for a system call other than might be expected.  Various manual pages in "
"Section 2 provide helpful details about the differences between wrapper "
"functions and the underlying system calls in subsections entitled I<C "
"library/kernel differences>."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:924
msgid ""
"Furthermore, note that the application of seccomp filters even risks causing "
"bugs in an application, when the filters cause unexpected failures for "
"legitimate operations that the application might need to perform.  Such bugs "
"may not easily be discovered when testing the seccomp filters if the bugs "
"occur in rarely used application code paths."
msgstr ""

#. type: SS
#: build/C/man2/seccomp.2:924
#, no-wrap
msgid "Seccomp-specific BPF details"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:926
msgid "Note the following BPF details specific to seccomp filters:"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:934
msgid ""
"The B<BPF_H> and B<BPF_B> size modifiers are not supported: all operations "
"must load and store (4-byte) words (B<BPF_W>)."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:940
msgid ""
"To access the contents of the I<seccomp_data> buffer, use the B<BPF_ABS> "
"addressing mode modifier."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:947
msgid ""
"The B<BPF_LEN> addressing mode modifier yields an immediate mode operand "
"whose value is the size of the I<seccomp_data> buffer."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:953
msgid ""
"The program below accepts four or more arguments.  The first three arguments "
"are a system call number, a numeric architecture identifier, and an error "
"number.  The program uses these values to construct a BPF filter that is "
"used at run time to perform the following checks:"
msgstr ""

#. type: IP
#: build/C/man2/seccomp.2:953
#, no-wrap
msgid "[1]"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:957
msgid ""
"If the program is not running on the specified architecture, the BPF filter "
"causes system calls to fail with the error B<ENOSYS>."
msgstr ""

#. type: IP
#: build/C/man2/seccomp.2:957
#, no-wrap
msgid "[2]"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:962
msgid ""
"If the program attempts to execute the system call with the specified "
"number, the BPF filter causes the system call to fail, with I<errno> being "
"set to the specified error number."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:971
msgid ""
"The remaining command-line arguments specify the pathname and additional "
"arguments of a program that the example program should attempt to execute "
"using B<execv>(3)  (a library function that employs the B<execve>(2)  system "
"call).  Some example runs of the program are shown below."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:975
msgid ""
"First, we display the architecture that we are running on (x86-64)  and then "
"construct a shell function that looks up system call numbers on this "
"architecture:"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:984
#, no-wrap
msgid ""
"$ B<uname -m>\n"
"x86_64\n"
"$ B<syscall_nr() {\n"
"    cat /usr/src/linux/arch/x86/syscalls/syscall_64.tbl | \\e\n"
"    awk \\(aq$2 != \"x32\" && $3 == \"\\(aq$1\\(aq\" { print $1 }\\(aq\n"
"}>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:991
msgid ""
"When the BPF filter rejects a system call (case [2] above), it causes the "
"system call to fail with the error number specified on the command line.  In "
"the experiments shown here, we'll use error number 99:"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:996
#, no-wrap
msgid ""
"$ B<errno 99>\n"
"EADDRNOTAVAIL 99 Cannot assign requested address\n"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:1004
msgid ""
"In the following example, we attempt to run the command B<whoami>(1), but "
"the BPF filter rejects the B<execve>(2)  system call, so that the command is "
"not even executed:"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:1015
#, no-wrap
msgid ""
"$ B<syscall_nr execve>\n"
"59\n"
"$ B<./a.out>\n"
"Usage: ./a.out E<lt>syscall_nrE<gt> E<lt>archE<gt> E<lt>errnoE<gt> "
"E<lt>progE<gt> [E<lt>argsE<gt>]\n"
"Hint for E<lt>archE<gt>: AUDIT_ARCH_I386: 0x40000003\n"
"                 AUDIT_ARCH_X86_64: 0xC000003E\n"
"$ B<./a.out 59 0xC000003E 99 /bin/whoami>\n"
"execv: Cannot assign requested address\n"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:1023
msgid ""
"In the next example, the BPF filter rejects the B<write>(2)  system call, so "
"that, although it is successfully started, the B<whoami>(1)  command is not "
"able to write output:"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:1029
#, no-wrap
msgid ""
"$ B<syscall_nr write>\n"
"1\n"
"$ B<./a.out 1 0xC000003E 99 /bin/whoami>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:1036
msgid ""
"In the final example, the BPF filter rejects a system call that is not used "
"by the B<whoami>(1)  command, so it is able to successfully execute and "
"produce output:"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:1043
#, no-wrap
msgid ""
"$ B<syscall_nr preadv>\n"
"295\n"
"$ B<./a.out 295 0xC000003E 99 /bin/whoami>\n"
"cecilia\n"
msgstr ""

#. type: SS
#: build/C/man2/seccomp.2:1045 build/C/man2/pidfd_open.2:209 build/C/man3/posix_spawn.3:681
#, no-wrap
msgid "Program source"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:1056
#, no-wrap
msgid ""
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>stddef.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>linux/audit.hE<gt>\n"
"#include E<lt>linux/filter.hE<gt>\n"
"#include E<lt>linux/seccomp.hE<gt>\n"
"#include E<lt>sys/prctl.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:1059
#, no-wrap
msgid ""
"#define X32_SYSCALL_BIT 0x40000000\n"
"#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))\n"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:1064
#, no-wrap
msgid ""
"static int\n"
"install_filter(int syscall_nr, int t_arch, int f_errno)\n"
"{\n"
"    unsigned int upper_nr_limit = 0xffffffff;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:1070
#, no-wrap
msgid ""
"    /* Assume that AUDIT_ARCH_X86_64 means the normal x86-64 ABI\n"
"       (in the x32 ABI, all system calls have bit 30 set in the\n"
"       \\(aqnr\\(aq field, meaning the numbers are E<gt>= X32_SYSCALL_BIT) "
"*/\n"
"    if (t_arch == AUDIT_ARCH_X86_64)\n"
"        upper_nr_limit = X32_SYSCALL_BIT - 1;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:1076
#, no-wrap
msgid ""
"    struct sock_filter filter[] = {\n"
"        /* [0] Load architecture from \\(aqseccomp_data\\(aq buffer into\n"
"               accumulator */\n"
"        BPF_STMT(BPF_LD | BPF_W | BPF_ABS,\n"
"                 (offsetof(struct seccomp_data, arch))),\n"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:1080
#, no-wrap
msgid ""
"        /* [1] Jump forward 5 instructions if architecture does not\n"
"               match \\(aqt_arch\\(aq */\n"
"        BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, t_arch, 0, 5),\n"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:1085
#, no-wrap
msgid ""
"        /* [2] Load system call number from \\(aqseccomp_data\\(aq buffer "
"into\n"
"               accumulator */\n"
"        BPF_STMT(BPF_LD | BPF_W | BPF_ABS,\n"
"                 (offsetof(struct seccomp_data, nr))),\n"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:1090
#, no-wrap
msgid ""
"        /* [3] Check ABI - only needed for x86-64 in deny-list use\n"
"               cases.  Use BPF_JGT instead of checking against the bit\n"
"               mask to avoid having to reload the syscall number. */\n"
"        BPF_JUMP(BPF_JMP | BPF_JGT | BPF_K, upper_nr_limit, 3, 0),\n"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:1094
#, no-wrap
msgid ""
"        /* [4] Jump forward 1 instruction if system call number\n"
"               does not match \\(aqsyscall_nr\\(aq */\n"
"        BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, syscall_nr, 0, 1),\n"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:1099
#, no-wrap
msgid ""
"        /* [5] Matching architecture and system call: don\\(aqt execute\n"
"           the system call, and return \\(aqf_errno\\(aq in \\(aqerrno\\(aq "
"*/\n"
"        BPF_STMT(BPF_RET | BPF_K,\n"
"                 SECCOMP_RET_ERRNO | (f_errno & SECCOMP_RET_DATA)),\n"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:1103
#, no-wrap
msgid ""
"        /* [6] Destination of system call number mismatch: allow other\n"
"               system calls */\n"
"        BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_ALLOW),\n"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:1107
#, no-wrap
msgid ""
"        /* [7] Destination of architecture mismatch: kill process */\n"
"        BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_KILL_PROCESS),\n"
"    };\n"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:1112
#, no-wrap
msgid ""
"    struct sock_fprog prog = {\n"
"        .len = ARRAY_SIZE(filter),\n"
"        .filter = filter,\n"
"    };\n"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:1117
#, no-wrap
msgid ""
"    if (seccomp(SECCOMP_SET_MODE_FILTER, 0, &prog)) {\n"
"        perror(\"seccomp\");\n"
"        return 1;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:1120
#, no-wrap
msgid ""
"    return 0;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:1132
#, no-wrap
msgid ""
"int\n"
"main(int argc, char **argv)\n"
"{\n"
"    if (argc E<lt> 5) {\n"
"        fprintf(stderr, \"Usage: \"\n"
"                \"%s E<lt>syscall_nrE<gt> E<lt>archE<gt> E<lt>errnoE<gt> "
"E<lt>progE<gt> [E<lt>argsE<gt>]\\en\"\n"
"                \"Hint for E<lt>archE<gt>: AUDIT_ARCH_I386: 0x%X\\en\"\n"
"                \"                 AUDIT_ARCH_X86_64: 0x%X\\en\"\n"
"                \"\\en\", argv[0], AUDIT_ARCH_I386, AUDIT_ARCH_X86_64);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:1137
#, no-wrap
msgid ""
"    if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {\n"
"        perror(\"prctl\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:1142
#, no-wrap
msgid ""
"    if (install_filter(strtol(argv[1], NULL, 0),\n"
"                       strtol(argv[2], NULL, 0),\n"
"                       strtol(argv[3], NULL, 0)))\n"
"        exit(EXIT_FAILURE);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:1147
#, no-wrap
msgid ""
"    execv(argv[4], &argv[4]);\n"
"    perror(\"execv\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:1158
msgid ""
"B<bpfc>(1), B<strace>(1), B<bpf>(2), B<prctl>(2), B<ptrace>(2), "
"B<sigaction>(2), B<proc>(5), B<signal>(7), B<socket>(7)"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:1168
msgid ""
"Various pages from the I<libseccomp> library, including: "
"B<scmp_sys_resolver>(1), B<seccomp_export_bpf>(3), B<seccomp_init>(3), "
"B<seccomp_load>(3), and B<seccomp_rule_add>(3)."
msgstr ""

#.  commit c061f33f35be0ccc80f4b8e0aea5dfd2ed7e01a3
#. type: Plain text
#: build/C/man2/seccomp.2:1177
msgid ""
"The kernel source files I<Documentation/networking/filter.txt> and "
"I<Documentation/userspace-api/seccomp_filter.rst> (or "
"I<Documentation/prctl/seccomp_filter.txt> before Linux 4.13)."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:1183
msgid ""
"McCanne, S.\\& and Jacobson, V.\\& (1992)  I<The BSD Packet Filter: A New "
"Architecture for User-level Packet Capture>, Proceedings of the USENIX "
"Winter 1993 Conference E<.UR http://www.tcpdump.org/papers/bpf-usenix93.pdf> "
"E<.UE>"
msgstr ""

#. type: TH
#: build/C/man7/cgroups.7:26
#, no-wrap
msgid "CGROUPS"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:29
msgid "cgroups - Linux control groups"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:40
msgid ""
"Control groups, usually referred to as cgroups, are a Linux kernel feature "
"which allow processes to be organized into hierarchical groups whose usage "
"of various types of resources can then be limited and monitored.  The "
"kernel's cgroup interface is provided through a pseudo-filesystem called "
"cgroupfs.  Grouping is implemented in the core cgroup kernel code, while "
"resource tracking and limits are implemented in a set of per-resource-type "
"subsystems (memory, CPU, and so on)."
msgstr ""

#. type: SS
#: build/C/man7/cgroups.7:40
#, no-wrap
msgid "Terminology"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:45
msgid ""
"A I<cgroup> is a collection of processes that are bound to a set of limits "
"or parameters defined via the cgroup filesystem."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:57
msgid ""
"A I<subsystem> is a kernel component that modifies the behavior of the "
"processes in a cgroup.  Various subsystems have been implemented, making it "
"possible to do things such as limiting the amount of CPU time and memory "
"available to a cgroup, accounting for the CPU time used by a cgroup, and "
"freezing and resuming execution of the processes in a cgroup.  Subsystems "
"are sometimes also known as I<resource controllers> (or simply, "
"controllers)."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:70
msgid ""
"The cgroups for a controller are arranged in a I<hierarchy>.  This hierarchy "
"is defined by creating, removing, and renaming subdirectories within the "
"cgroup filesystem.  At each level of the hierarchy, attributes (e.g., "
"limits) can be defined.  The limits, control, and accounting provided by "
"cgroups generally have effect throughout the subhierarchy underneath the "
"cgroup where the attributes are defined.  Thus, for example, the limits "
"placed on a cgroup at a higher level in the hierarchy cannot be exceeded by "
"descendant cgroups."
msgstr ""

#. type: SS
#: build/C/man7/cgroups.7:70
#, no-wrap
msgid "Cgroups version 1 and version 2"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:83
msgid ""
"The initial release of the cgroups implementation was in Linux 2.6.24.  Over "
"time, various cgroup controllers have been added to allow the management of "
"various types of resources.  However, the development of these controllers "
"was largely uncoordinated, with the result that many inconsistencies arose "
"between controllers and management of the cgroup hierarchies became rather "
"complex.  A longer description of these problems can be found in the kernel "
"source file I<Documentation/admin-guide/cgroup-v2.rst> (or "
"I<Documentation/cgroup-v2.txt> in Linux 4.17 and earlier)."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:97
msgid ""
"Because of the problems with the initial cgroups implementation (cgroups "
"version 1), starting in Linux 3.10, work began on a new, orthogonal "
"implementation to remedy these problems.  Initially marked experimental, and "
"hidden behind the I<-o\\ __DEVEL__sane_behavior> mount option, the new "
"version (cgroups version 2)  was eventually made official with the release "
"of Linux 4.5.  Differences between the two versions are described in the "
"text below.  The file I<cgroup.sane_behavior>, present in cgroups v1, is a "
"relic of this mount option. The file always reports \"0\" and is only "
"retained for backward compatibility."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:112
msgid ""
"Although cgroups v2 is intended as a replacement for cgroups v1, the older "
"system continues to exist (and for compatibility reasons is unlikely to be "
"removed).  Currently, cgroups v2 implements only a subset of the controllers "
"available in cgroups v1.  The two systems are implemented so that both v1 "
"controllers and v2 controllers can be mounted on the same system.  Thus, for "
"example, it is possible to use those controllers that are supported under "
"version 2, while also using version 1 controllers where version 2 does not "
"yet support those controllers.  The only restriction here is that a "
"controller can't be simultaneously employed in both a cgroups v1 hierarchy "
"and in the cgroups v2 hierarchy."
msgstr ""

#. type: SH
#: build/C/man7/cgroups.7:112
#, no-wrap
msgid "CGROUPS VERSION 1"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:119
msgid ""
"Under cgroups v1, each controller may be mounted against a separate cgroup "
"filesystem that provides its own hierarchical organization of the processes "
"on the system.  It is also possible to comount multiple (or even all) "
"cgroups v1 controllers against the same cgroup filesystem, meaning that the "
"comounted controllers manage the same hierarchical organization of "
"processes."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:136
msgid ""
"For each mounted hierarchy, the directory tree mirrors the control group "
"hierarchy.  Each control group is represented by a directory, with each of "
"its child control cgroups represented as a child directory.  For instance, "
"I</user/joe/1.session> represents control group I<1.session>, which is a "
"child of cgroup I<joe>, which is a child of I</user>.  Under each cgroup "
"directory is a set of files which can be read or written to, reflecting "
"resource limits and a few general cgroup properties."
msgstr ""

#. type: SS
#: build/C/man7/cgroups.7:136
#, no-wrap
msgid "Tasks (threads) versus processes"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:146
msgid ""
"In cgroups v1, a distinction is drawn between I<processes> and I<tasks>.  In "
"this view, a process can consist of multiple tasks (more commonly called "
"threads, from a user-space perspective, and called such in the remainder of "
"this man page).  In cgroups v1, it is possible to independently manipulate "
"the cgroup memberships of the threads in a process."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:159
msgid ""
"The cgroups v1 ability to split threads across different cgroups caused "
"problems in some cases.  For example, it made no sense for the I<memory> "
"controller, since all of the threads of a process share a single address "
"space.  Because of these problems, the ability to independently manipulate "
"the cgroup memberships of the threads in a process was removed in the "
"initial cgroups v2 implementation, and subsequently restored in a more "
"limited form (see the discussion of \"thread mode\" below)."
msgstr ""

#. type: SS
#: build/C/man7/cgroups.7:159
#, no-wrap
msgid "Mounting v1 controllers"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:165
msgid ""
"The use of cgroups requires a kernel built with the B<CONFIG_CGROUP> "
"option.  In addition, each of the v1 controllers has an associated "
"configuration option that must be set in order to employ that controller."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:175
msgid ""
"In order to use a v1 controller, it must be mounted against a cgroup "
"filesystem.  The usual place for such mounts is under a B<tmpfs>(5)  "
"filesystem mounted at I</sys/fs/cgroup>.  Thus, one might mount the I<cpu> "
"controller as follows:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:179
#, no-wrap
msgid "mount -t cgroup -o cpu none /sys/fs/cgroup/cpu\n"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:188
msgid ""
"It is possible to comount multiple controllers against the same hierarchy.  "
"For example, here the I<cpu> and I<cpuacct> controllers are comounted "
"against a single hierarchy:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:192
#, no-wrap
msgid "mount -t cgroup -o cpu,cpuacct none /sys/fs/cgroup/cpu,cpuacct\n"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:203
msgid ""
"Comounting controllers has the effect that a process is in the same cgroup "
"for all of the comounted controllers.  Separately mounting controllers "
"allows a process to be in cgroup I</foo1> for one controller while being in "
"I</foo2/foo3> for another."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:205
msgid "It is possible to comount all v1 controllers against the same hierarchy:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:209
#, no-wrap
msgid "mount -t cgroup -o all cgroup /sys/fs/cgroup\n"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:215
msgid ""
"(One can achieve the same result by omitting I<-o all>, since it is the "
"default if no controllers are explicitly specified.)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:229
msgid ""
"It is not possible to mount the same controller against multiple cgroup "
"hierarchies.  For example, it is not possible to mount both the I<cpu> and "
"I<cpuacct> controllers against one hierarchy, and to mount the I<cpu> "
"controller alone against another hierarchy.  It is possible to create "
"multiple mount points with exactly the same set of comounted controllers.  "
"However, in this case all that results is multiple mount points providing a "
"view of the same hierarchy."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:236
msgid ""
"Note that on many systems, the v1 controllers are automatically mounted "
"under I</sys/fs/cgroup>; in particular, B<systemd>(1)  automatically creates "
"such mount points."
msgstr ""

#. type: SS
#: build/C/man7/cgroups.7:236
#, no-wrap
msgid "Unmounting v1 controllers"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:240
msgid ""
"A mounted cgroup filesystem can be unmounted using the B<umount>(8)  "
"command, as in the following example:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:244
#, no-wrap
msgid "umount /sys/fs/cgroup/pids\n"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:258
msgid ""
"I<But note well>: a cgroup filesystem is unmounted only if it is not busy, "
"that is, it has no child cgroups.  If this is not the case, then the only "
"effect of the B<umount>(8)  is to make the mount invisible.  Thus, to ensure "
"that the mount point is really removed, one must first remove all child "
"cgroups, which in turn can be done only after all member processes have been "
"moved from those cgroups to the root cgroup."
msgstr ""

#. type: SS
#: build/C/man7/cgroups.7:258
#, no-wrap
msgid "Cgroups version 1 controllers"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:264
msgid ""
"Each of the cgroups version 1 controllers is governed by a kernel "
"configuration option (listed below).  Additionally, the availability of the "
"cgroups feature is governed by the B<CONFIG_CGROUPS> kernel configuration "
"option."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:264
#, no-wrap
msgid "I<cpu> (since Linux 2.6.24; B<CONFIG_CGROUP_SCHED>)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:274
msgid ""
"Cgroups can be guaranteed a minimum number of \"CPU shares\" when a system "
"is busy.  This does not limit a cgroup's CPU usage if the CPUs are not "
"busy.  For further information, see "
"I<Documentation/scheduler/sched-design-CFS.rst> (or "
"I<Documentation/scheduler/sched-design-CFS.txt> in Linux 5.2 and earlier)."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:288
msgid ""
"In Linux 3.2, this controller was extended to provide CPU \"bandwidth\" "
"control.  If the kernel is configured with B<CONFIG_CFS_BANDWIDTH>, then "
"within each scheduling period (defined via a file in the cgroup directory), "
"it is possible to define an upper limit on the CPU time allocated to the "
"processes in a cgroup.  This upper limit applies even if there is no other "
"competition for the CPU.  Further information can be found in the kernel "
"source file I<Documentation/scheduler/sched-bwc.rst> (or "
"I<Documentation/scheduler/sched-bwc.txt> in Linux 5.2 and earlier)."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:288
#, no-wrap
msgid "I<cpuacct> (since Linux 2.6.24; B<CONFIG_CGROUP_CPUACCT>)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:291
msgid "This provides accounting for CPU usage by groups of processes."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:297
msgid ""
"Further information can be found in the kernel source file "
"I<Documentation/admin-guide/cgroup-v1/cpuacct.rst> (or "
"I<Documentation/cgroup-v1/cpuacct.txt> in Linux 5.2 and earlier)."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:297
#, no-wrap
msgid "I<cpuset> (since Linux 2.6.24; B<CONFIG_CPUSETS>)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:301
msgid ""
"This cgroup can be used to bind the processes in a cgroup to a specified set "
"of CPUs and NUMA nodes."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:307
msgid ""
"Further information can be found in the kernel source file "
"I<Documentation/admin-guide/cgroup-v1/cpusets.rst> (or "
"I<Documentation/cgroup-v1/cpusets.txt> in Linux 5.2 and earlier)."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:308
#, no-wrap
msgid "I<memory> (since Linux 2.6.25; B<CONFIG_MEMCG>)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:312
msgid ""
"The memory controller supports reporting and limiting of process memory, "
"kernel memory, and swap used by cgroups."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:318
msgid ""
"Further information can be found in the kernel source file "
"I<Documentation/admin-guide/cgroup-v1/memory.rst> (or "
"I<Documentation/cgroup-v1/memory.txt> in Linux 5.2 and earlier)."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:318
#, no-wrap
msgid "I<devices> (since Linux 2.6.26; B<CONFIG_CGROUP_DEVICE>)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:325
msgid ""
"This supports controlling which processes may create (mknod) devices as well "
"as open them for reading or writing.  The policies may be specified as "
"allow-lists and deny-lists.  Hierarchy is enforced, so new rules must not "
"violate existing rules for the target or ancestor cgroups."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:331
msgid ""
"Further information can be found in the kernel source file "
"I<Documentation/admin-guide/cgroup-v1/devices.rst> (or "
"I<Documentation/cgroup-v1/devices.txt> in Linux 5.2 and earlier)."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:331
#, no-wrap
msgid "I<freezer> (since Linux 2.6.28; B<CONFIG_CGROUP_FREEZER>)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:341
msgid ""
"The I<freezer> cgroup can suspend and restore (resume) all processes in a "
"cgroup.  Freezing a cgroup I</A> also causes its children, for example, "
"processes in I</A/B>, to be frozen."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:347
msgid ""
"Further information can be found in the kernel source file "
"I<Documentation/admin-guide/cgroup-v1/freezer-subsystem.rst> (or "
"I<Documentation/cgroup-v1/freezer-subsystem.txt> in Linux 5.2 and earlier)."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:347
#, no-wrap
msgid "I<net_cls> (since Linux 2.6.29; B<CONFIG_CGROUP_NET_CLASSID>)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:356
msgid ""
"This places a classid, specified for the cgroup, on network packets created "
"by a cgroup.  These classids can then be used in firewall rules, as well as "
"used to shape traffic using B<tc>(8).  This applies only to packets leaving "
"the cgroup, not to traffic arriving at the cgroup."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:362
msgid ""
"Further information can be found in the kernel source file "
"I<Documentation/admin-guide/cgroup-v1/net_cls.rst> (or "
"I<Documentation/cgroup-v1/net_cls.txt> in Linux 5.2 and earlier)."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:362
#, no-wrap
msgid "I<blkio> (since Linux 2.6.33; B<CONFIG_BLK_CGROUP>)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:369
msgid ""
"The I<blkio> cgroup controls and limits access to specified block devices by "
"applying IO control in the form of throttling and upper limits against leaf "
"nodes and intermediate nodes in the storage hierarchy."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:376
msgid ""
"Two policies are available.  The first is a proportional-weight time-based "
"division of disk implemented with CFQ.  This is in effect for leaf nodes "
"using CFQ.  The second is a throttling policy which specifies upper I/O rate "
"limits on a device."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:382
msgid ""
"Further information can be found in the kernel source file "
"I<Documentation/admin-guide/cgroup-v1/blkio-controller.rst> (or "
"I<Documentation/cgroup-v1/blkio-controller.txt> in Linux 5.2 and earlier)."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:382
#, no-wrap
msgid "I<perf_event> (since Linux 2.6.39; B<CONFIG_CGROUP_PERF>)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:387
msgid ""
"This controller allows I<perf> monitoring of the set of processes grouped in "
"a cgroup."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:389
msgid "Further information can be found in the kernel source files"
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:389
#, no-wrap
msgid "I<net_prio> (since Linux 3.3; B<CONFIG_CGROUP_NET_PRIO>)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:392
msgid "This allows priorities to be specified, per network interface, for cgroups."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:398
msgid ""
"Further information can be found in the kernel source file "
"I<Documentation/admin-guide/cgroup-v1/net_prio.rst> (or "
"I<Documentation/cgroup-v1/net_prio.txt> in Linux 5.2 and earlier)."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:398
#, no-wrap
msgid "I<hugetlb> (since Linux 3.5; B<CONFIG_CGROUP_HUGETLB>)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:401
msgid "This supports limiting the use of huge pages by cgroups."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:407
msgid ""
"Further information can be found in the kernel source file "
"I<Documentation/admin-guide/cgroup-v1/hugetlb.rst> (or "
"I<Documentation/cgroup-v1/hugetlb.txt> in Linux 5.2 and earlier)."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:407
#, no-wrap
msgid "I<pids> (since Linux 4.3; B<CONFIG_CGROUP_PIDS>)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:411
msgid ""
"This controller permits limiting the number of process that may be created "
"in a cgroup (and its descendants)."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:417
msgid ""
"Further information can be found in the kernel source file "
"I<Documentation/admin-guide/cgroup-v1/pids.rst> (or "
"I<Documentation/cgroup-v1/pids.txt> in Linux 5.2 and earlier)."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:417
#, no-wrap
msgid "I<rdma> (since Linux 4.11; B<CONFIG_CGROUP_RDMA>)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:421
msgid ""
"The RDMA controller permits limiting the use of RDMA/IB-specific resources "
"per cgroup."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:428
msgid ""
"Further information can be found in the kernel source file "
"I<Documentation/admin-guide/cgroup-v1/rdma.rst> (or "
"I<Documentation/cgroup-v1/rdma.txt> in Linux 5.2 and earlier)."
msgstr ""

#. type: SS
#: build/C/man7/cgroups.7:428
#, no-wrap
msgid "Creating cgroups and moving processes"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:432
msgid ""
"A cgroup filesystem initially contains a single root cgroup, '/', which all "
"processes belong to.  A new cgroup is created by creating a directory in the "
"cgroup filesystem:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:436
#, no-wrap
msgid "mkdir /sys/fs/cgroup/cpu/cg1\n"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:440
msgid "This creates a new empty cgroup."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:444
msgid ""
"A process may be moved to this cgroup by writing its PID into the cgroup's "
"I<cgroup.procs> file:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:448
#, no-wrap
msgid "echo $$ E<gt> /sys/fs/cgroup/cpu/cg1/cgroup.procs\n"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:452
msgid "Only one PID at a time should be written to this file."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:456
msgid ""
"Writing the value 0 to a I<cgroup.procs> file causes the writing process to "
"be moved to the corresponding cgroup."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:460
msgid ""
"When writing a PID into the I<cgroup.procs>, all threads in the process are "
"moved into the new cgroup at once."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:466
msgid ""
"Within a hierarchy, a process can be a member of exactly one cgroup.  "
"Writing a process's PID to a I<cgroup.procs> file automatically removes it "
"from the cgroup of which it was previously a member."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:474
msgid ""
"The I<cgroup.procs> file can be read to obtain a list of the processes that "
"are members of a cgroup.  The returned list of PIDs is not guaranteed to be "
"in order.  Nor is it guaranteed to be free of duplicates.  (For example, a "
"PID may be recycled while reading from the list.)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:487
msgid ""
"In cgroups v1, an individual thread can be moved to another cgroup by "
"writing its thread ID (i.e., the kernel thread ID returned by B<clone>(2)  "
"and B<gettid>(2))  to the I<tasks> file in a cgroup directory.  This file "
"can be read to discover the set of threads that are members of the cgroup."
msgstr ""

#. type: SS
#: build/C/man7/cgroups.7:487
#, no-wrap
msgid "Removing cgroups"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:495
msgid ""
"To remove a cgroup, it must first have no child cgroups and contain no "
"(nonzombie) processes.  So long as that is the case, one can simply remove "
"the corresponding directory pathname.  Note that files in a cgroup directory "
"cannot and need not be removed."
msgstr ""

#. type: SS
#: build/C/man7/cgroups.7:495
#, no-wrap
msgid "Cgroups v1 release notification"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:500
msgid ""
"Two files can be used to determine whether the kernel provides notifications "
"when a cgroup becomes empty.  A cgroup is considered to be empty when it "
"contains no child cgroups and no member processes."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:513
msgid ""
"A special file in the root directory of each cgroup hierarchy, "
"I<release_agent>, can be used to register the pathname of a program that may "
"be invoked when a cgroup in the hierarchy becomes empty.  The pathname of "
"the newly empty cgroup (relative to the cgroup mount point)  is provided as "
"the sole command-line argument when the I<release_agent> program is "
"invoked.  The I<release_agent> program might remove the cgroup directory, or "
"perhaps repopulate it with a process."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:517
msgid ""
"The default value of the I<release_agent> file is empty, meaning that no "
"release agent is invoked."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:522
msgid ""
"The content of the I<release_agent> file can also be specified via a mount "
"option when the cgroup filesystem is mounted:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:526
#, no-wrap
msgid "mount -o release_agent=pathname ...\n"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:546
msgid ""
"Whether or not the I<release_agent> program is invoked when a particular "
"cgroup becomes empty is determined by the value in the I<notify_on_release> "
"file in the corresponding cgroup directory.  If this file contains the value "
"0, then the I<release_agent> program is not invoked.  If it contains the "
"value 1, the I<release_agent> program is invoked.  The default value for "
"this file in the root cgroup is 0.  At the time when a new cgroup is "
"created, the value in this file is inherited from the corresponding file in "
"the parent cgroup."
msgstr ""

#. type: SS
#: build/C/man7/cgroups.7:546
#, no-wrap
msgid "Cgroup v1 named hierarchies"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:549
msgid ""
"In cgroups v1, it is possible to mount a cgroup hierarchy that has no "
"attached controllers:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:553
#, no-wrap
msgid "mount -t cgroup -o none,name=somename none /some/mount/point\n"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:565
msgid ""
"Multiple instances of such hierarchies can be mounted; each hierarchy must "
"have a unique name.  The only purpose of such hierarchies is to track "
"processes.  (See the discussion of release notification below.)  An example "
"of this is the I<name=systemd> cgroup hierarchy that is used by "
"B<systemd>(1)  to track services and user sessions."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:571
msgid ""
"Since Linux 5.0, the I<cgroup_no_v1> kernel boot option (described below) "
"can be used to disable cgroup v1 named hierarchies, by specifying "
"I<cgroup_no_v1=named>."
msgstr ""

#. type: SH
#: build/C/man7/cgroups.7:573
#, no-wrap
msgid "CGROUPS VERSION 2"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:580
msgid ""
"In cgroups v2, all mounted controllers reside in a single unified "
"hierarchy.  While (different) controllers may be simultaneously mounted "
"under the v1 and v2 hierarchies, it is not possible to mount the same "
"controller simultaneously under both the v1 and the v2 hierarchies."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:583
msgid ""
"The new behaviors in cgroups v2 are summarized here, and in some cases "
"elaborated in the following subsections."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:586
msgid ""
"Cgroups v2 provides a unified hierarchy against which all controllers are "
"mounted."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:591
msgid ""
"\"Internal\" processes are not permitted.  With the exception of the root "
"cgroup, processes may reside only in leaf nodes (cgroups that do not "
"themselves contain child cgroups).  The details are somewhat more subtle "
"than this, and are described below."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:596
msgid ""
"Active cgroups must be specified via the files I<cgroup.controllers> and "
"I<cgroup.subtree_control>."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:605
msgid ""
"The I<tasks> file has been removed.  In addition, the "
"I<cgroup.clone_children> file that is employed by the I<cpuset> controller "
"has been removed."
msgstr ""

#. type: IP
#: build/C/man7/cgroups.7:605
#, no-wrap
msgid "5."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:609
msgid ""
"An improved mechanism for notification of empty cgroups is provided by the "
"I<cgroup.events> file."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:616
msgid ""
"For more changes, see the I<Documentation/admin-guide/cgroup-v2.rst> file in "
"the kernel source (or I<Documentation/cgroup-v2.txt> in Linux 4.17 and "
"earlier)."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:621
msgid ""
"Some of the new behaviors listed above saw subsequent modification with the "
"addition in Linux 4.14 of \"thread mode\" (described below)."
msgstr ""

#. type: SS
#: build/C/man7/cgroups.7:621
#, no-wrap
msgid "Cgroups v2 unified hierarchy"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:633
msgid ""
"In cgroups v1, the ability to mount different controllers against different "
"hierarchies was intended to allow great flexibility for application design.  "
"In practice, though, the flexibility turned out to be less useful than "
"expected, and in many cases added complexity.  Therefore, in cgroups v2, all "
"available controllers are mounted against a single hierarchy.  The available "
"controllers are automatically mounted, meaning that it is not necessary (or "
"possible) to specify the controllers when mounting the cgroup v2 filesystem "
"using a command such as the following:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:637
#, no-wrap
msgid "mount -t cgroup2 none /mnt/cgroup2\n"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:662
msgid ""
"A cgroup v2 controller is available only if it is not currently in use via a "
"mount against a cgroup v1 hierarchy.  Or, to put things another way, it is "
"not possible to employ the same controller against both a v1 hierarchy and "
"the unified v2 hierarchy.  This means that it may be necessary first to "
"unmount a v1 controller (as described above) before that controller is "
"available in v2.  Since B<systemd>(1)  makes heavy use of some v1 "
"controllers by default, it can in some cases be simpler to boot the system "
"with selected v1 controllers disabled.  To do this, specify the "
"I<cgroup_no_v1=list> option on the kernel boot command line; I<list> is a "
"comma-separated list of the names of the controllers to disable, or the word "
"I<all> to disable all v1 controllers.  (This situation is correctly handled "
"by B<systemd>(1), which falls back to operating without the specified "
"controllers.)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:671
msgid ""
"Note that on many modern systems, B<systemd>(1)  automatically mounts the "
"I<cgroup2> filesystem at I</sys/fs/cgroup/unified> during the boot process."
msgstr ""

#. type: SS
#: build/C/man7/cgroups.7:671
#, no-wrap
msgid "Cgroups v2 mount options"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:675
msgid ""
"The following options (I<mount -o>)  can be specified when mounting the "
"group v2 filesystem:"
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:675 build/C/man7/cgroups.7:1907
#, no-wrap
msgid "I<nsdelegate> (since Linux 4.15)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:679
msgid "Treat cgroup namespaces as delegation boundaries.  For details, see below."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:679 build/C/man7/cgroups.7:1902
#, no-wrap
msgid "I<memory_localevents> (since Linux 5.2)"
msgstr ""

#.  commit 9852ae3fe5293264f01c49f2571ef7688f7823ce
#. type: Plain text
#: build/C/man7/cgroups.7:695
msgid ""
"The I<memory.events> should show statistics only for the cgroup itself, and "
"not for any descendant cgroups.  This was the behavior before Linux 5.2.  "
"Starting in Linux 5.2, the default behavior is to include statistics for "
"descendant cgroups in I<memory.events>, and this mount option can be used to "
"revert to the legacy behavior.  This option is system wide and can be set on "
"mount or modified through remount only from the initial mount namespace; it "
"is silently ignored in noninitial namespaces."
msgstr ""

#. type: SS
#: build/C/man7/cgroups.7:695
#, no-wrap
msgid "Cgroups v2 controllers"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:702
msgid ""
"The following controllers, documented in the kernel source file "
"I<Documentation/admin-guide/cgroup-v2.rst> (or "
"I<Documentation/cgroup-v2.txt> in Linux 4.17 and earlier), are supported in "
"cgroups version 2:"
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:702
#, no-wrap
msgid "I<cpu> (since Linux 4.15)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:709
msgid "This is the successor to the version 1 I<cpu> and I<cpuacct> controllers."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:709
#, no-wrap
msgid "I<cpuset> (since Linux 5.0)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:714
msgid "This is the successor of the version 1 I<cpuset> controller."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:714
#, no-wrap
msgid "I<freezer> (since Linux 5.2)"
msgstr ""

#.  commit 76f969e8948d82e78e1bc4beb6b9465908e74873
#. type: Plain text
#: build/C/man7/cgroups.7:720
msgid "This is the successor of the version 1 I<freezer> controller."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:720
#, no-wrap
msgid "I<hugetlb> (since Linux 5.6)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:725
msgid "This is the successor of the version 1 I<hugetlb> controller."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:725
#, no-wrap
msgid "I<io> (since Linux 4.5)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:730
msgid "This is the successor of the version 1 I<blkio> controller."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:730
#, no-wrap
msgid "I<memory> (since Linux 4.5)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:735
msgid "This is the successor of the version 1 I<memory> controller."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:735
#, no-wrap
msgid "I<perf_event> (since Linux 4.11)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:740
msgid "This is the same as the version 1 I<perf_event> controller."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:740
#, no-wrap
msgid "I<pids> (since Linux 4.5)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:745
msgid "This is the same as the version 1 I<pids> controller."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:745
#, no-wrap
msgid "I<rdma> (since Linux 4.11)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:750
msgid "This is the same as the version 1 I<rdma> controller."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:760
msgid ""
"There is no direct equivalent of the I<net_cls> and I<net_prio> controllers "
"from cgroups version 1.  Instead, support has been added to B<iptables>(8)  "
"to allow eBPF filters that hook on cgroup v2 pathnames to make decisions "
"about network traffic on a per-cgroup basis."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:768
msgid ""
"The v2 I<devices> controller provides no interface files; instead, device "
"control is gated by attaching an eBPF (B<BPF_CGROUP_DEVICE>)  program to a "
"v2 cgroup."
msgstr ""

#. type: SS
#: build/C/man7/cgroups.7:768
#, no-wrap
msgid "Cgroups v2 subtree control"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:770
msgid "Each cgroup in the v2 hierarchy contains the following two files:"
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:770
#, no-wrap
msgid "I<cgroup.controllers>"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:778
msgid ""
"This read-only file exposes a list of the controllers that are I<available> "
"in this cgroup.  The contents of this file match the contents of the "
"I<cgroup.subtree_control> file in the parent cgroup."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:778
#, no-wrap
msgid "I<cgroup.subtree_control>"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:791
msgid ""
"This is a list of controllers that are I<active> (I<enabled>)  in the "
"cgroup.  The set of controllers in this file is a subset of the set in the "
"I<cgroup.controllers> of this cgroup.  The set of active controllers is "
"modified by writing strings to this file containing space-delimited "
"controller names, each preceded by '+' (to enable a controller)  or '-' (to "
"disable a controller), as in the following example:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:795
#, no-wrap
msgid "echo \\(aq+pids -memory\\(aq E<gt> x/y/cgroup.subtree_control\n"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:806
msgid ""
"An attempt to enable a controller that is not present in "
"I<cgroup.controllers> leads to an B<ENOENT> error when writing to the "
"I<cgroup.subtree_control> file."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:813
msgid ""
"Because the list of controllers in I<cgroup.subtree_control> is a subset of "
"those I<cgroup.controllers>, a controller that has been disabled in one "
"cgroup in the hierarchy can never be re-enabled in the subtree below that "
"cgroup."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:829
msgid ""
"A cgroup's I<cgroup.subtree_control> file determines the set of controllers "
"that are exercised in the I<child> cgroups.  When a controller (e.g., "
"I<pids>)  is present in the I<cgroup.subtree_control> file of a parent "
"cgroup, then the corresponding controller-interface files (e.g., "
"I<pids.max>)  are automatically created in the children of that cgroup and "
"can be used to exert resource control in the child cgroups."
msgstr ""

#. type: SS
#: build/C/man7/cgroups.7:829
#, no-wrap
msgid "Cgroups v2 \"no internal processes\" rule"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:836
msgid ""
"Cgroups v2 enforces a so-called \"no internal processes\" rule.  Roughly "
"speaking, this rule means that, with the exception of the root cgroup, "
"processes may reside only in leaf nodes (cgroups that do not themselves "
"contain child cgroups).  This avoids the need to decide how to partition "
"resources between processes which are members of cgroup A and processes in "
"child cgroups of A."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:860
msgid ""
"For instance, if cgroup I</cg1/cg2> exists, then a process may reside in "
"I</cg1/cg2>, but not in I</cg1>.  This is to avoid an ambiguity in cgroups "
"v1 with respect to the delegation of resources between processes in I</cg1> "
"and its child cgroups.  The recommended approach in cgroups v2 is to create "
"a subdirectory called I<leaf> for any nonleaf cgroup which should contain "
"processes, but no child cgroups.  Thus, processes which previously would "
"have gone into I</cg1> would now go into I</cg1/leaf>.  This has the "
"advantage of making explicit the relationship between processes in "
"I</cg1/leaf> and I</cg1>'s other children."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:873
msgid ""
"The \"no internal processes\" rule is in fact more subtle than stated "
"above.  More precisely, the rule is that a (nonroot) cgroup can't both (1) "
"have member processes, and (2) distribute resources into child "
"cgroups\\(emthat is, have a nonempty I<cgroup.subtree_control> file.  Thus, "
"it I<is> possible for a cgroup to have both member processes and child "
"cgroups, but before controllers can be enabled for that cgroup, the member "
"processes must be moved out of the cgroup (e.g., perhaps into the child "
"cgroups)."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:877
msgid ""
"With the Linux 4.14 addition of \"thread mode\" (described below), the \"no "
"internal processes\" rule has been relaxed in some cases."
msgstr ""

#. type: SS
#: build/C/man7/cgroups.7:877
#, no-wrap
msgid "Cgroups v2 cgroup.events file"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:883
msgid ""
"Each nonroot cgroup in the v2 hierarchy contains a read-only file, "
"I<cgroup.events>, whose contents are key-value pairs (delimited by newline "
"characters, with the key and value separated by spaces)  providing state "
"information about the cgroup:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:889
#, no-wrap
msgid ""
"$ B<cat mygrp/cgroup.events>\n"
"populated 1\n"
"frozen 0\n"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:893
msgid "The following keys may appear in this file:"
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:893
#, no-wrap
msgid "I<populated>"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:898
msgid ""
"The value of this key is either 1, if this cgroup or any of its descendants "
"has member processes, or otherwise 0."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:898
#, no-wrap
msgid "I<frozen> (since Linux 5.2)"
msgstr ""

#.  commit 76f969e8948d82e78e1bc4beb6b9465908e7487
#. type: Plain text
#: build/C/man7/cgroups.7:903
msgid ""
"The value of this key is 1 if this cgroup is currently frozen, or 0 if it is "
"not."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:922
msgid ""
"The I<cgroup.events> file can be monitored, in order to receive notification "
"when the value of one of its keys changes.  Such monitoring can be done "
"using B<inotify>(7), which notifies changes as B<IN_MODIFY> events, or "
"B<poll>(2), which notifies changes by returning the B<POLLPRI> and "
"B<POLLERR> bits in the I<revents> field."
msgstr ""

#. type: SS
#: build/C/man7/cgroups.7:922
#, no-wrap
msgid "Cgroup v2 release notification"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:939
msgid ""
"Cgroups v2 provides a new mechanism for obtaining notification when a cgroup "
"becomes empty.  The cgroups v1 I<release_agent> and I<notify_on_release> "
"files are removed, and replaced by the I<populated> key in the "
"I<cgroup.events> file.  This key either has the value 0, meaning that the "
"cgroup (and its descendants)  contain no (nonzombie) member processes, or 1, "
"meaning that the cgroup (or one of its descendants)  contains member "
"processes."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:944
msgid ""
"The cgroups v2 release-notification mechanism offers the following "
"advantages over the cgroups v1 I<release_agent> mechanism:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:951
msgid ""
"It allows for cheaper notification, since a single process can monitor "
"multiple I<cgroup.events> files (using the techniques described earlier).  "
"By contrast, the cgroups v1 mechanism requires the expense of creating a "
"process for each notification."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:957
msgid ""
"Notification for different cgroup subhierarchies can be delegated to "
"different processes.  By contrast, the cgroups v1 mechanism allows only one "
"release agent for an entire hierarchy."
msgstr ""

#. type: SS
#: build/C/man7/cgroups.7:957
#, no-wrap
msgid "Cgroups v2 cgroup.stat file"
msgstr ""

#.  commit ec39225cca42c05ac36853d11d28f877fde5c42e
#. type: Plain text
#: build/C/man7/cgroups.7:964
msgid ""
"Each cgroup in the v2 hierarchy contains a read-only I<cgroup.stat> file "
"(first introduced in Linux 4.14)  that consists of lines containing "
"key-value pairs.  The following keys currently appear in this file:"
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:964
#, no-wrap
msgid "I<nr_descendants>"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:968
msgid ""
"This is the total number of visible (i.e., living) descendant cgroups "
"underneath this cgroup."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:968
#, no-wrap
msgid "I<nr_dying_descendants>"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:978
msgid ""
"This is the total number of dying descendant cgroups underneath this "
"cgroup.  A cgroup enters the dying state after being deleted.  It remains in "
"that state for an undefined period (which will depend on system load)  while "
"resources are freed before the cgroup is destroyed.  Note that the presence "
"of some cgroups in the dying state is normal, and is not indicative of any "
"problem."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:982
msgid ""
"A process can't be made a member of a dying cgroup, and a dying cgroup can't "
"be brought back to life."
msgstr ""

#. type: SS
#: build/C/man7/cgroups.7:982
#, no-wrap
msgid "Limiting the number of descendant cgroups"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:986
msgid ""
"Each cgroup in the v2 hierarchy contains the following files, which can be "
"used to view and set limits on the number of descendant cgroups under that "
"cgroup:"
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:986
#, no-wrap
msgid "I<cgroup.max.depth> (since Linux 4.14)"
msgstr ""

#.  commit 1a926e0bbab83bae8207d05a533173425e0496d1
#. type: Plain text
#: build/C/man7/cgroups.7:996
msgid ""
"This file defines a limit on the depth of nesting of descendant cgroups.  A "
"value of 0 in this file means that no descendant cgroups can be created.  An "
"attempt to create a descendant whose nesting level exceeds the limit fails "
"(I<mkdir>(2)  fails with the error B<EAGAIN>)."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1002 build/C/man7/cgroups.7:1018
msgid ""
"Writing the string I<\"max\"> to this file means that no limit is imposed.  "
"The default value in this file is I<\"max\">."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:1002
#, no-wrap
msgid "I<cgroup.max.descendants> (since Linux 4.14)"
msgstr ""

#.  commit 1a926e0bbab83bae8207d05a533173425e0496d1
#. type: Plain text
#: build/C/man7/cgroups.7:1011
msgid ""
"This file defines a limit on the number of live descendant cgroups that this "
"cgroup may have.  An attempt to create more descendants than allowed by the "
"limit fails (I<mkdir>(2)  fails with the error B<EAGAIN>)."
msgstr ""

#. type: SH
#: build/C/man7/cgroups.7:1018
#, no-wrap
msgid "CGROUPS DELEGATION: DELEGATING A HIERARCHY TO A LESS PRIVILEGED USER"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1028
msgid ""
"In the context of cgroups, delegation means passing management of some "
"subtree of the cgroup hierarchy to a nonprivileged user.  Cgroups v1 "
"provides support for delegation based on file permissions in the cgroup "
"hierarchy but with less strict containment rules than v2 (as noted below).  "
"Cgroups v2 supports delegation with containment by explicit design.  The "
"focus of the discussion in this section is on delegation in cgroups v2, with "
"some differences for cgroups v1 noted along the way."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1039
msgid ""
"Some terminology is required in order to describe delegation.  A "
"I<delegater> is a privileged user (i.e., root) who owns a parent cgroup.  A "
"I<delegatee> is a nonprivileged user who will be granted the permissions "
"needed to manage some subhierarchy under that parent cgroup, known as the "
"I<delegated subtree>."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1048
msgid ""
"To perform delegation, the delegater makes certain directories and files "
"writable by the delegatee, typically by changing the ownership of the "
"objects to be the user ID of the delegatee.  Assuming that we want to "
"delegate the hierarchy rooted at (say)  I</dlgt_grp> and that there are not "
"yet any child cgroups under that cgroup, the ownership of the following is "
"changed to the user ID of the delegatee:"
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:1048
#, no-wrap
msgid "I</dlgt_grp>"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1053
msgid ""
"Changing the ownership of the root of the subtree means that any new cgroups "
"created under the subtree (and the files they contain)  will also be owned "
"by the delegatee."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:1053
#, no-wrap
msgid "I</dlgt_grp/cgroup.procs>"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1057
msgid ""
"Changing the ownership of this file means that the delegatee can move "
"processes into the root of the delegated subtree."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:1057
#, no-wrap
msgid "I</dlgt_grp/cgroup.subtree_control> (cgroups v2 only)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1065
msgid ""
"Changing the ownership of this file means that the delegatee can enable "
"controllers (that are present in I</dlgt_grp/cgroup.controllers>)  in order "
"to further redistribute resources at lower levels in the subtree.  (As an "
"alternative to changing the ownership of this file, the delegater might "
"instead add selected controllers to this file.)"
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:1065
#, no-wrap
msgid "I</dlgt_grp/cgroup.threads> (cgroups v2 only)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1076
msgid ""
"Changing the ownership of this file is necessary if a threaded subtree is "
"being delegated (see the description of \"thread mode\", below).  This "
"permits the delegatee to write thread IDs to the file.  (The ownership of "
"this file can also be changed when delegating a domain subtree, but "
"currently this serves no purpose, since, as described below, it is not "
"possible to move a thread between domain cgroups by writing its thread ID to "
"the I<cgroup.threads> file.)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1080
msgid ""
"In cgroups v1, the corresponding file that should instead be delegated is "
"the I<tasks> file."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1092
msgid ""
"The delegater should I<not> change the ownership of any of the controller "
"interfaces files (e.g., I<pids.max>, I<memory.high>)  in I<dlgt_grp>.  Those "
"files are used from the next level above the delegated subtree in order to "
"distribute resources into the subtree, and the delegatee should not have "
"permission to change the resources that are distributed into the delegated "
"subtree."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1096
msgid ""
"See also the discussion of the I</sys/kernel/cgroup/delegate> file in NOTES "
"for information about further delegatable files in cgroups v2."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1108
msgid ""
"After the aforementioned steps have been performed, the delegatee can create "
"child cgroups within the delegated subtree (the cgroup subdirectories and "
"the files they contain will be owned by the delegatee)  and move processes "
"between cgroups in the subtree.  If some controllers are present in "
"I<dlgt_grp/cgroup.subtree_control>, or the ownership of that file was passed "
"to the delegatee, the delegatee can also control the further redistribution "
"of the corresponding resources into the delegated subtree."
msgstr ""

#. type: SS
#: build/C/man7/cgroups.7:1108
#, no-wrap
msgid "Cgroups v2 delegation: nsdelegate and cgroup namespaces"
msgstr ""

#.  commit 5136f6365ce3eace5a926e10f16ed2a233db5ba9
#. type: Plain text
#: build/C/man7/cgroups.7:1119
msgid ""
"Starting with Linux 4.13, there is a second way to perform cgroup delegation "
"in the cgroups v2 hierarchy.  This is done by mounting or remounting the "
"cgroup v2 filesystem with the I<nsdelegate> mount option.  For example, if "
"the cgroup v2 filesystem has already been mounted, we can remount it with "
"the I<nsdelegate> option as follows:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1124
#, no-wrap
msgid ""
"mount -t cgroup2 -o remount,nsdelegate \\e\n"
"                 none /sys/fs/cgroup/unified\n"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1138
msgid ""
"The effect of this mount option is to cause cgroup namespaces to "
"automatically become delegation boundaries.  More specifically, the "
"following restrictions apply for processes inside the cgroup namespace:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1148
msgid ""
"Writes to controller interface files in the root directory of the namespace "
"will fail with the error B<EPERM>.  Processes inside the cgroup namespace "
"can still write to delegatable files in the root directory of the cgroup "
"namespace such as I<cgroup.procs> and I<cgroup.subtree_control>, and can "
"create subhierarchy underneath the root directory."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1157
msgid ""
"Attempts to migrate processes across the namespace boundary are denied (with "
"the error B<ENOENT>).  Processes inside the cgroup namespace can still "
"(subject to the containment rules described below)  move processes between "
"cgroups I<within> the subhierarchy under the namespace root."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1175
msgid ""
"The ability to define cgroup namespaces as delegation boundaries makes "
"cgroup namespaces more useful.  To understand why, suppose that we already "
"have one cgroup hierarchy that has been delegated to a nonprivileged user, "
"I<cecilia>, using the older delegation technique described above.  Suppose "
"further that I<cecilia> wanted to further delegate a subhierarchy under the "
"existing delegated hierarchy.  (For example, the delegated hierarchy might "
"be associated with an unprivileged container run by I<cecilia>.)  Even if a "
"cgroup namespace was employed, because both hierarchies are owned by the "
"unprivileged user I<cecilia>, the following illegitimate actions could be "
"performed:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1183
msgid ""
"A process in the inferior hierarchy could change the resource controller "
"settings in the root directory of that hierarchy.  (These resource "
"controller settings are intended to allow control to be exercised from the "
"I<parent> cgroup; a process inside the child cgroup should not be allowed to "
"modify them.)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1187
msgid ""
"A process inside the inferior hierarchy could move processes into and out of "
"the inferior hierarchy if the cgroups in the superior hierarchy were somehow "
"visible."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1191
msgid ""
"Employing the I<nsdelegate> mount option prevents both of these "
"possibilities."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1197
msgid ""
"The I<nsdelegate> mount option only has an effect when performed in the "
"initial mount namespace; in other mount namespaces, the option is silently "
"ignored."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1206
msgid ""
"I<Note>: On some systems, B<systemd>(1)  automatically mounts the cgroup v2 "
"filesystem.  In order to experiment with the I<nsdelegate> operation, it may "
"be useful to boot the kernel with the following command-line options:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1210
#, no-wrap
msgid "cgroup_no_v1=all systemd.legacy_systemd_cgroup_controller\n"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1221
msgid ""
"These options cause the kernel to boot with the cgroups v1 controllers "
"disabled (meaning that the controllers are available in the v2 hierarchy), "
"and tells B<systemd>(1)  not to mount and use the cgroup v2 hierarchy, so "
"that the v2 hierarchy can be manually mounted with the desired options after "
"boot-up."
msgstr ""

#. type: SS
#: build/C/man7/cgroups.7:1221
#, no-wrap
msgid "Cgroup delegation containment rules"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1232
msgid ""
"Some delegation I<containment rules> ensure that the delegatee can move "
"processes between cgroups within the delegated subtree, but can't move "
"processes from outside the delegated subtree into the subtree or vice "
"versa.  A nonprivileged process (i.e., the delegatee) can write the PID of a "
"\"target\" process into a I<cgroup.procs> file only if all of the following "
"are true:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1236
msgid ""
"The writer has write permission on the I<cgroup.procs> file in the "
"destination cgroup."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1246
msgid ""
"The writer has write permission on the I<cgroup.procs> file in the nearest "
"common ancestor of the source and destination cgroups.  Note that in some "
"cases, the nearest common ancestor may be the source or destination cgroup "
"itself.  This requirement is not enforced for cgroups v1 hierarchies, with "
"the consequence that containment in v1 is less strict than in v2.  (For "
"example, in cgroups v1 the user that owns two distinct delegated "
"subhierarchies can move a process between the hierarchies.)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1251
msgid ""
"If the cgroup v2 filesystem was mounted with the I<nsdelegate> option, the "
"writer must be able to see the source and destination cgroups from its "
"cgroup namespace."
msgstr ""

#.  commit 576dd464505fc53d501bb94569db76f220104d28
#. type: Plain text
#: build/C/man7/cgroups.7:1261
msgid ""
"In cgroups v1: the effective UID of the writer (i.e., the delegatee) matches "
"the real user ID or the saved set-user-ID of the target process.  Before "
"Linux 4.11, this requirement also applied in cgroups v2 (This was a "
"historical requirement inherited from cgroups v1 that was later deemed "
"unnecessary, since the other rules suffice for containment in cgroups v2.)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1269
msgid ""
"I<Note>: one consequence of these delegation containment rules is that the "
"unprivileged delegatee can't place the first process into the delegated "
"subtree; instead, the delegater must place the first process (a process "
"owned by the delegatee) into the delegated subtree."
msgstr ""

#. type: SH
#: build/C/man7/cgroups.7:1269
#, no-wrap
msgid "CGROUPS VERSION 2 THREAD MODE"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1272
msgid ""
"Among the restrictions imposed by cgroups v2 that were not present in "
"cgroups v1 are the following:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1275
msgid ""
"I<No thread-granularity control>: all of the threads of a process must be in "
"the same cgroup."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1279
msgid ""
"I<No internal processes>: a cgroup can't both have member processes and "
"exercise controllers on child cgroups."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1291
msgid ""
"Both of these restrictions were added because the lack of these restrictions "
"had caused problems in cgroups v1.  In particular, the cgroups v1 ability to "
"allow thread-level granularity for cgroup membership made no sense for some "
"controllers.  (A notable example was the I<memory> controller: since threads "
"share an address space, it made no sense to split threads across different "
"I<memory> cgroups.)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1300
msgid ""
"Notwithstanding the initial design decision in cgroups v2, there were use "
"cases for certain controllers, notably the I<cpu> controller, for which "
"thread-level granularity of control was meaningful and useful.  To "
"accommodate such use cases, Linux 4.14 added I<thread mode> for cgroups v2."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1302
msgid "Thread mode allows the following:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1308
msgid ""
"The creation of I<threaded subtrees> in which the threads of a process may "
"be spread across cgroups inside the tree.  (A threaded subtree may contain "
"multiple multithreaded processes.)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1312
msgid ""
"The concept of I<threaded controllers>, which can distribute resources "
"across the cgroups in a threaded subtree."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1317
msgid ""
"A relaxation of the \"no internal processes rule\", so that, within a "
"threaded subtree, a cgroup can both contain member threads and exercise "
"resource control over child cgroups."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1324
msgid ""
"With the addition of thread mode, each nonroot cgroup now contains a new "
"file, I<cgroup.type>, that exposes, and in some circumstances can be used to "
"change, the \"type\" of a cgroup.  This file contains one of the following "
"type values:"
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:1324
#, no-wrap
msgid "I<domain>"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1332
msgid ""
"This is a normal v2 cgroup that provides process-granularity control.  If a "
"process is a member of this cgroup, then all threads of the process are (by "
"definition) in the same cgroup.  This is the default cgroup type, and "
"provides the same behavior that was provided for cgroups in the initial "
"cgroups v2 implementation."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:1332
#, no-wrap
msgid "I<threaded>"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1337
msgid ""
"This cgroup is a member of a threaded subtree.  Threads can be added to this "
"cgroup, and controllers can be enabled for the cgroup."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:1337
#, no-wrap
msgid "I<domain threaded>"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1341
msgid ""
"This is a domain cgroup that serves as the root of a threaded subtree.  This "
"cgroup type is also known as \"threaded root\"."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:1341
#, no-wrap
msgid "I<domain invalid>"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1355
msgid ""
"This is a cgroup inside a threaded subtree that is in an \"invalid\" state.  "
"Processes can't be added to the cgroup, and controllers can't be enabled for "
"the cgroup.  The only thing that can be done with this cgroup (other than "
"deleting it)  is to convert it to a I<threaded> cgroup by writing the string "
"I<\"threaded\"> to the I<cgroup.type> file."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1364
msgid ""
"The rationale for the existence of this \"interim\" type during the creation "
"of a threaded subtree (rather than the kernel simply immediately converting "
"all cgroups under the threaded root to the type I<threaded>)  is to allow "
"for possible future extensions to the thread mode model"
msgstr ""

#. type: SS
#: build/C/man7/cgroups.7:1364
#, no-wrap
msgid "Threaded versus domain controllers"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1367
msgid ""
"With the addition of threads mode, cgroups v2 now distinguishes two types of "
"resource controllers:"
msgstr ""

#.  In the kernel source, look for ".threaded[ \t]*= true" in
#.  initializations of struct cgroup_subsys
#. type: Plain text
#: build/C/man7/cgroups.7:1380
msgid ""
"I<Threaded> controllers: these controllers support thread-granularity for "
"resource control and can be enabled inside threaded subtrees, with the "
"result that the corresponding controller-interface files appear inside the "
"cgroups in the threaded subtree.  As at Linux 4.19, the following "
"controllers are threaded: I<cpu>, I<perf_event>, and I<pids>."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1388
msgid ""
"I<Domain> controllers: these controllers support only process granularity "
"for resource control.  From the perspective of a domain controller, all "
"threads of a process are always in the same cgroup.  Domain controllers "
"can't be enabled inside a threaded subtree."
msgstr ""

#. type: SS
#: build/C/man7/cgroups.7:1388
#, no-wrap
msgid "Creating a threaded subtree"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1391
msgid ""
"There are two pathways that lead to the creation of a threaded subtree.  The "
"first pathway proceeds as follows:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1401
msgid ""
"We write the string I<\"threaded\"> to the I<cgroup.type> file of a cgroup "
"I<y/z> that currently has the type I<domain>.  This has the following "
"effects:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1407
msgid "The type of the cgroup I<y/z> becomes I<threaded>."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1414
msgid ""
"The type of the parent cgroup, I<y>, becomes I<domain threaded>.  The parent "
"cgroup is the root of a threaded subtree (also known as the \"threaded "
"root\")."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1427
msgid ""
"All other cgroups under I<y> that were not already of type I<threaded> "
"(because they were inside already existing threaded subtrees under the new "
"threaded root)  are converted to type I<domain invalid>.  Any subsequently "
"created cgroups under I<y> will also have the type I<domain invalid>."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1445
msgid ""
"We write the string I<\"threaded\"> to each of the I<domain invalid> cgroups "
"under I<y>, in order to convert them to the type I<threaded>.  As a "
"consequence of this step, all threads under the threaded root now have the "
"type I<threaded> and the threaded subtree is now fully usable.  The "
"requirement to write I<\"threaded\"> to each of these cgroups is somewhat "
"cumbersome, but allows for possible future extensions to the thread-mode "
"model."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1447
msgid "The second way of creating a threaded subtree is as follows:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1457
msgid ""
"In an existing cgroup, I<z>, that currently has the type I<domain>, we (1) "
"enable one or more threaded controllers and (2) make a process a member of "
"I<z>.  (These two steps can be done in either order.)  This has the "
"following consequences:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1463
msgid "The type of I<z> becomes I<domain threaded>."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1470
msgid ""
"All of the descendant cgroups of I<x> that were not already of type "
"I<threaded> are converted to type I<domain invalid>."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1480
msgid ""
"As before, we make the threaded subtree usable by writing the string "
"I<\"threaded\"> to each of the I<domain invalid> cgroups under I<y>, in "
"order to convert them to the type I<threaded>."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1496
msgid ""
"One of the consequences of the above pathways to creating a threaded subtree "
"is that the threaded root cgroup can be a parent only to I<threaded> (and "
"I<domain invalid>)  cgroups.  The threaded root cgroup can't be a parent of "
"a I<domain> cgroups, and a I<threaded> cgroup can't have a sibling that is a "
"I<domain> cgroup."
msgstr ""

#. type: SS
#: build/C/man7/cgroups.7:1496
#, no-wrap
msgid "Using a threaded subtree"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1502
msgid ""
"Within a threaded subtree, threaded controllers can be enabled in each "
"subgroup whose type has been changed to I<threaded>; upon doing so, the "
"corresponding controller interface files appear in the children of that "
"cgroup."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1516
msgid ""
"A process can be moved into a threaded subtree by writing its PID to the "
"I<cgroup.procs> file in one of the cgroups inside the tree.  This has the "
"effect of making all of the threads in the process members of the "
"corresponding cgroup and makes the process a member of the threaded "
"subtree.  The threads of the process can then be spread across the threaded "
"subtree by writing their thread IDs (see B<gettid>(2))  to the "
"I<cgroup.threads> files in different cgroups inside the subtree.  The "
"threads of a process must all reside in the same threaded subtree."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1522
msgid ""
"As with writing to I<cgroup.procs>, some containment rules apply when "
"writing to the I<cgroup.threads> file:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1526
msgid ""
"The writer must have write permission on the cgroup.threads file in the "
"destination cgroup."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1532
msgid ""
"The writer must have write permission on the I<cgroup.procs> file in the "
"common ancestor of the source and destination cgroups.  (In some cases, the "
"common ancestor may be the source or destination cgroup itself.)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1541
msgid ""
"The source and destination cgroups must be in the same threaded subtree.  "
"(Outside a threaded subtree, an attempt to move a thread by writing its "
"thread ID to the I<cgroup.threads> file in a different I<domain> cgroup "
"fails with the error B<EOPNOTSUPP>.)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1550
msgid ""
"The I<cgroup.threads> file is present in each cgroup (including I<domain> "
"cgroups) and can be read in order to discover the set of threads that is "
"present in the cgroup.  The set of thread IDs obtained when reading this "
"file is not guaranteed to be ordered or free of duplicates."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1558
msgid ""
"The I<cgroup.procs> file in the threaded root shows the PIDs of all "
"processes that are members of the threaded subtree.  The I<cgroup.procs> "
"files in the other cgroups in the subtree are not readable."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1566
msgid ""
"Domain controllers can't be enabled in a threaded subtree; no "
"controller-interface files appear inside the cgroups underneath the threaded "
"root.  From the point of view of a domain controller, threaded subtrees are "
"invisible: a multithreaded process inside a threaded subtree appears to a "
"domain controller as a process that resides in the threaded root cgroup."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1571
msgid ""
"Within a threaded subtree, the \"no internal processes\" rule does not "
"apply: a cgroup can both contain member processes (or thread)  and exercise "
"controllers on child cgroups."
msgstr ""

#. type: SS
#: build/C/man7/cgroups.7:1571
#, no-wrap
msgid "Rules for writing to cgroup.type and creating threaded subtrees"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1575
msgid "A number of rules apply when writing to the I<cgroup.type> file:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1583
msgid ""
"Only the string I<\"threaded\"> may be written.  In other words, the only "
"explicit transition that is possible is to convert a I<domain> cgroup to "
"type I<threaded>."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1589
msgid ""
"The effect of writing I<\"threaded\"> depends on the current value in "
"I<cgroup.type>, as follows:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1597
msgid ""
"I<domain> or I<domain threaded>: start the creation of a threaded subtree "
"(whose root is the parent of this cgroup) via the first of the pathways "
"described above;"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1602
msgid ""
"I<domain\\ invalid>: convert this cgroup (which is inside a threaded "
"subtree) to a usable (i.e., I<threaded>)  state;"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1605
msgid "I<threaded>: no effect (a \"no-op\")."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1614
msgid ""
"We can't write to a I<cgroup.type> file if the parent's type is I<domain "
"invalid>.  In other words, the cgroups of a threaded subtree must be "
"converted to the I<threaded> state in a top-down manner."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1618
msgid ""
"There are also some constraints that must be satisfied in order to create a "
"threaded subtree rooted at the cgroup I<x>:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1624
msgid ""
"There can be no member processes in the descendant cgroups of I<x>.  (The "
"cgroup I<x> can itself have member processes.)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1629
msgid ""
"No domain controllers may be enabled in I<x>'s I<cgroup.subtree_control> "
"file."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1637
msgid ""
"If any of the above constraints is violated, then an attempt to write "
"I<\"threaded\"> to a I<cgroup.type> file fails with the error B<ENOTSUP>."
msgstr ""

#. type: SS
#: build/C/man7/cgroups.7:1637
#, no-wrap
msgid "The \"domain threaded\" cgroup type"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1642
msgid ""
"According to the pathways described above, the type of a cgroup can change "
"to I<domain threaded> in either of the following cases:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1646
msgid "The string I<\"threaded\"> is written to a child cgroup."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1649
msgid ""
"A threaded controller is enabled inside the cgroup and a process is made a "
"member of the cgroup."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1664
msgid ""
"A I<domain threaded> cgroup, I<x>, can revert to the type I<domain> if the "
"above conditions no longer hold true\\(emthat is, if all I<threaded> child "
"cgroups of I<x> are removed and either I<x> no longer has threaded "
"controllers enabled or no longer has member processes."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1671
msgid "When a I<domain threaded> cgroup I<x> reverts to the type I<domain>:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1678
msgid ""
"All I<domain invalid> descendants of I<x> that are not in lower-level "
"threaded subtrees revert to the type I<domain>."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1682
msgid ""
"The root cgroups in any lower-level threaded subtrees revert to the type "
"I<domain threaded>."
msgstr ""

#. type: SS
#: build/C/man7/cgroups.7:1682
#, no-wrap
msgid "Exceptions for the root cgroup"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1694
msgid ""
"The root cgroup of the v2 hierarchy is treated exceptionally: it can be the "
"parent of both I<domain> and I<threaded> cgroups.  If the string "
"I<\"threaded\"> is written to the I<cgroup.type> file of one of the children "
"of the root cgroup, then"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1697
msgid "The type of that cgroup becomes I<threaded>."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1701
msgid ""
"The type of any descendants of that cgroup that are not part of lower-level "
"threaded subtrees changes to I<domain invalid>."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1707
msgid ""
"Note that in this case, there is no cgroup whose type becomes I<domain "
"threaded>.  (Notionally, the root cgroup can be considered as the threaded "
"root for the cgroup whose type was changed to I<threaded>.)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1714
msgid ""
"The aim of this exceptional treatment for the root cgroup is to allow a "
"threaded cgroup that employs the I<cpu> controller to be placed as high as "
"possible in the hierarchy, so as to minimize the (small) cost of traversing "
"the cgroup hierarchy."
msgstr ""

#. type: SS
#: build/C/man7/cgroups.7:1714
#, no-wrap
msgid "The cgroups v2 \"cpu\" controller and realtime threads"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1737
msgid ""
"As at Linux 4.19, the cgroups v2 I<cpu> controller does not support control "
"of realtime threads (specifically threads scheduled under any of the "
"policies B<SCHED_FIFO>, B<SCHED_RR>, described B<SCHED_DEADLINE>; see "
"B<sched>(7)).  Therefore, the I<cpu> controller can be enabled in the root "
"cgroup only if all realtime threads are in the root cgroup.  (If there are "
"realtime threads in nonroot cgroups, then a B<write>(2)  of the string "
"I<\"+cpu\"> to the I<cgroup.subtree_control> file fails with the error "
"B<EINVAL>.)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1746
msgid ""
"On some systems, B<systemd>(1)  places certain realtime threads in nonroot "
"cgroups in the v2 hierarchy.  On such systems, these threads must first be "
"moved to the root cgroup before the I<cpu> controller can be enabled."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1749
msgid "The following errors can occur for B<mount>(2):"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1755
msgid ""
"An attempt to mount a cgroup version 1 filesystem specified neither the "
"I<name=> option (to mount a named hierarchy) nor a controller name (or "
"I<all>)."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1761
msgid ""
"A child process created via B<fork>(2)  inherits its parent's cgroup "
"memberships.  A process's cgroup memberships are preserved across "
"B<execve>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1768
msgid ""
"The B<clone3>(2)  B<CLONE_INTO_CGROUP> flag can be used to create a child "
"process that begins its life in a different version 2 cgroup from the parent "
"process."
msgstr ""

#. type: SS
#: build/C/man7/cgroups.7:1768
#, no-wrap
msgid "/proc files"
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:1769
#, no-wrap
msgid "I</proc/cgroups> (since Linux 2.6.24)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1775
msgid ""
"This file contains information about the controllers that are compiled into "
"the kernel.  An example of the contents of this file (reformatted for "
"readability)  is the following:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1791
#, no-wrap
msgid ""
"#subsys_name    hierarchy      num_cgroups    enabled\n"
"cpuset          4              1              1\n"
"cpu             8              1              1\n"
"cpuacct         8              1              1\n"
"blkio           6              1              1\n"
"memory          3              1              1\n"
"devices         10             84             1\n"
"freezer         7              1              1\n"
"net_cls         9              1              1\n"
"perf_event      5              1              1\n"
"net_prio        9              1              1\n"
"hugetlb         0              1              0\n"
"pids            2              1              1\n"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1795
msgid "The fields in this file are, from left to right:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1798
msgid "The name of the controller."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1803
msgid ""
"The unique ID of the cgroup hierarchy on which this controller is mounted.  "
"If multiple cgroups v1 controllers are bound to the same hierarchy, then "
"each will show the same hierarchy ID in this field.  The value in this field "
"will be 0 if:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1806
msgid "the controller is not mounted on a cgroups v1 hierarchy;"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1808
msgid "the controller is bound to the cgroups v2 single unified hierarchy; or"
msgstr ""

#. type: IP
#: build/C/man7/cgroups.7:1808
#, no-wrap
msgid "c)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1810
msgid "the controller is disabled (see below)."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1813
msgid "The number of control groups in this hierarchy using this controller."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1818
msgid ""
"This field contains the value 1 if this controller is enabled, or 0 if it "
"has been disabled (via the I<cgroup_disable> kernel command-line boot "
"parameter)."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:1819
#, no-wrap
msgid "I</proc/[pid]/cgroup> (since Linux 2.6.24)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1825
msgid ""
"This file describes control groups to which the process with the "
"corresponding PID belongs.  The displayed information differs for cgroups "
"version 1 and version 2 hierarchies."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1828
msgid ""
"For each cgroup hierarchy of which the process is a member, there is one "
"entry containing three colon-separated fields:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1832
#, no-wrap
msgid "hierarchy-ID:controller-list:cgroup-path\n"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1836
msgid "For example:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1840
#, no-wrap
msgid "5:cpuacct,cpu,cpuset:/daemons\n"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1844
msgid "The colon-separated fields are, from left to right:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1851
msgid ""
"For cgroups version 1 hierarchies, this field contains a unique hierarchy ID "
"number that can be matched to a hierarchy ID in I</proc/cgroups>.  For the "
"cgroups version 2 hierarchy, this field contains the value 0."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1856
msgid ""
"For cgroups version 1 hierarchies, this field contains a comma-separated "
"list of the controllers bound to the hierarchy.  For the cgroups version 2 "
"hierarchy, this field is empty."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1860
msgid ""
"This field contains the pathname of the control group in the hierarchy to "
"which the process belongs.  This pathname is relative to the mount point of "
"the hierarchy."
msgstr ""

#. type: SS
#: build/C/man7/cgroups.7:1862
#, no-wrap
msgid "/sys/kernel/cgroup files"
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:1863
#, no-wrap
msgid "I</sys/kernel/cgroup/delegate> (since Linux 4.15)"
msgstr ""

#.  commit 01ee6cfb1483fe57c9cbd8e73817dfbf9bacffd3
#. type: Plain text
#: build/C/man7/cgroups.7:1873
msgid ""
"This file exports a list of the cgroups v2 files (one per line) that are "
"delegatable (i.e., whose ownership should be changed to the user ID of the "
"delegatee).  In the future, the set of delegatable files may change or grow, "
"and this file provides a way for the kernel to inform user-space "
"applications of which files must be delegated.  As at Linux 4.15, one sees "
"the following when inspecting this file:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1880
#, no-wrap
msgid ""
"$ B<cat /sys/kernel/cgroup/delegate>\n"
"cgroup.procs\n"
"cgroup.subtree_control\n"
"cgroup.threads\n"
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:1882
#, no-wrap
msgid "I</sys/kernel/cgroup/features> (since Linux 4.15)"
msgstr ""

#.  commit 5f2e673405b742be64e7c3604ed4ed3ac14f35ce
#. type: Plain text
#: build/C/man7/cgroups.7:1891
msgid ""
"Over time, the set of cgroups v2 features that are provided by the kernel "
"may change or grow, or some features may not be enabled by default.  This "
"file provides a way for user-space applications to discover what features "
"the running kernel supports and has enabled.  Features are listed one per "
"line:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1897
#, no-wrap
msgid ""
"$ B<cat /sys/kernel/cgroup/features>\n"
"nsdelegate\n"
"memory_localevents\n"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1901
msgid "The entries that can appear in this file are:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1907
msgid "The kernel supports the I<memory_localevents> mount option."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1912
msgid "The kernel supports the I<nsdelegate> mount option."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1927
msgid ""
"B<prlimit>(1), B<systemd>(1), B<systemd-cgls>(1), B<systemd-cgtop>(1), "
"B<clone>(2), B<ioprio_set>(2), B<perf_event_open>(2), B<setrlimit>(2), "
"B<cgroup_namespaces>(7), B<cpuset>(7), B<namespaces>(7), B<sched>(7), "
"B<user_namespaces>(7)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1930
msgid "The kernel source file I<Documentation/admin-guide/cgroup-v2.rst>."
msgstr ""

#. type: TH
#: build/C/man2/pidfd_getfd.2:25
#, no-wrap
msgid "PIDFD_GETFD"
msgstr ""

#. type: TH
#: build/C/man2/pidfd_getfd.2:25
#, no-wrap
msgid "2020-03-31"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_getfd.2:28
msgid "pidfd_getfd - obtain a duplicate of another process's file descriptor"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_getfd.2:31
#, no-wrap
msgid ""
"B<int pidfd_getfd(int >I<pidfd>B<, int >I<targetfd>B<, unsigned int "
">I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_getfd.2:40
msgid ""
"The B<pidfd_getfd>()  system call allocates a new file descriptor in the "
"calling process.  This new file descriptor is a duplicate of an existing "
"file descriptor, I<targetfd>, in the process referred to by the PID file "
"descriptor I<pidfd>."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_getfd.2:50
msgid ""
"The duplicate file descriptor refers to the same open file description (see "
"B<open>(2))  as the original file descriptor in the process referred to by "
"I<pidfd>.  The two file descriptors thus share file status flags and file "
"offset.  Furthermore, operations on the underlying file object (for example, "
"assigning an address to a socket object using B<bind>(2))  can equally be "
"performed via the duplicate file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_getfd.2:57
msgid ""
"The close-on-exec flag (B<FD_CLOEXEC>; see B<fcntl>(2))  is set on the file "
"descriptor returned by B<pidfd_getfd>()."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_getfd.2:62
msgid ""
"The I<flags> argument is reserved for future use.  Currently, it must be "
"specified as 0."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_getfd.2:68
msgid ""
"Permission to duplicate another process's file descriptor is governed by a "
"ptrace access mode B<PTRACE_MODE_ATTACH_REALCREDS> check (see B<ptrace>(2))."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_getfd.2:75
msgid ""
"On success, B<pidfd_getfd>()  returns a file descriptor (a nonnegative "
"integer).  On error, -1 is returned and I<errno> is set to indicate the "
"cause of the error."
msgstr ""

#. type: TP
#: build/C/man2/pidfd_getfd.2:76 build/C/man2/pidfd_getfd.2:80 build/C/man2/pidfd_send_signal.2:98
#, no-wrap
msgid "B<EBADF>"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_getfd.2:80 build/C/man2/pidfd_send_signal.2:102
msgid "I<pidfd> is not a valid PID file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_getfd.2:85
msgid ""
"I<targetfd> is not an open file descriptor in the process referred to by "
"I<pidfd>."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_getfd.2:89 build/C/man2/pidfd_open.2:59 build/C/man2/pidfd_send_signal.2:114
msgid "I<flags> is not 0."
msgstr ""

#. type: TP
#: build/C/man2/pidfd_getfd.2:89 build/C/man2/pidfd_open.2:63
#, no-wrap
msgid "B<EMFILE>"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_getfd.2:96 build/C/man2/pidfd_open.2:70
msgid ""
"The per-process limit on the number of open file descriptors has been "
"reached (see the description of B<RLIMIT_NOFILE> in B<getrlimit>(2))."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_getfd.2:107
msgid ""
"The calling process did not have B<PTRACE_MODE_ATTACH_REALCREDS> permissions "
"(see B<ptrace>(2))  over the process referred to by I<pidfd>."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_getfd.2:113
msgid ""
"The process referred to by I<pidfd> does not exist (i.e., it has terminated "
"and been waited on)."
msgstr ""

#.  commit 8649c322f75c96e7ced2fec201e123b2b073bf09
#. type: Plain text
#: build/C/man2/pidfd_getfd.2:117
msgid "B<pidfd_getfd>()  first appeared in Linux 5.6."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_getfd.2:120
msgid "B<pidfd_getfd>()  is Linux specific."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_getfd.2:123 build/C/man2/pidfd_open.2:93 build/C/man2/pidfd_send_signal.2:139
msgid ""
"Currently, there is no glibc wrapper for this system call; call it using "
"B<syscall>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_getfd.2:126
msgid "For a description of PID file descriptors, see B<pidfd_open>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_getfd.2:134
msgid ""
"The effect of B<pidfd_getfd>()  is similar to the use of B<SCM_RIGHTS> "
"messages described in B<unix>(7), but differs in the following respects:"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_getfd.2:139
msgid ""
"In order to pass a file descriptor using an B<SCM_RIGHTS> message, the two "
"processes must first establish a UNIX domain socket connection."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_getfd.2:146
msgid ""
"The use of B<SCM_RIGHTS> requires cooperation on the part of the process "
"whose file descriptor is being copied.  By contrast, no such cooperation is "
"necessary when using B<pidfd_getfd>()."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_getfd.2:152
msgid ""
"The ability to use B<pidfd_getfd>()  is restricted by a "
"B<PTRACE_MODE_ATTACH_REALCREDS> ptrace access mode check."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_getfd.2:157
msgid "B<clone3>(2), B<dup>(2), B<kcmp>(2), B<pidfd_open>(2)"
msgstr ""

#. type: TH
#: build/C/man2/pidfd_open.2:25
#, no-wrap
msgid "PIDFD_OPEN"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_open.2:28
msgid "pidfd_open - obtain a file descriptor that refers to a process"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_open.2:31
#, no-wrap
msgid "B<#include E<lt>sys/types.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_open.2:33
#, no-wrap
msgid "B<int pidfd_open(pid_t >I<pid>B<, unsigned int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_open.2:42
msgid ""
"The B<pidfd_open>()  system call creates a file descriptor that refers to "
"the process whose PID is specified in I<pid>.  The file descriptor is "
"returned as the function result; the close-on-exec flag is set on the file "
"descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_open.2:47 build/C/man2/pidfd_send_signal.2:90
msgid ""
"The I<flags> argument is reserved for future use; currently, this argument "
"must be specified as 0."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_open.2:54
msgid ""
"On success, B<pidfd_open>()  returns a file descriptor (a nonnegative "
"integer).  On error, -1 is returned and I<errno> is set to indicate the "
"cause of the error."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_open.2:63
msgid "I<pid> is not valid."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_open.2:76
msgid "The anonymous inode filesystem is not available in this kernel."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_open.2:79
msgid "Insufficient kernel memory was available."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_open.2:84
msgid "The process specified by I<pid> does not exist."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_open.2:87
msgid "B<pidfd_open>()  first appeared in Linux 5.3."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_open.2:90
msgid "B<pidfd_open>()  is Linux specific."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_open.2:97
msgid ""
"The following code sequence can be used to obtain a file descriptor for the "
"child of B<fork>(2):"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_open.2:105
#, no-wrap
msgid ""
"pid = fork();\n"
"if (pid E<gt> 0) {     /* If parent */\n"
"    pidfd = pidfd_open(pid, 0);\n"
"    ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_open.2:114
msgid ""
"Even if the child has already terminated by the time of the B<pidfd_open>()  "
"call, its PID will not have been recycled and the returned file descriptor "
"will refer to the resulting zombie process.  Note, however, that this is "
"guaranteed only if the following conditions hold true:"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_open.2:121
msgid ""
"the disposition of B<SIGCHLD> has not been explicitly set to B<SIG_IGN> (see "
"B<sigaction>(2));"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_open.2:131
msgid ""
"the B<SA_NOCLDWAIT> flag was not specified while establishing a handler for "
"B<SIGCHLD> or while setting the disposition of that signal to B<SIG_DFL> "
"(see B<sigaction>(2)); and"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_open.2:136
msgid ""
"the zombie process was not reaped elsewhere in the program (e.g., either by "
"an asynchronously executed signal handler or by B<wait>(2)  or similar in "
"another thread)."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_open.2:145
msgid ""
"If any of these conditions does not hold, then the child process (along with "
"a PID file descriptor that refers to it)  should instead be created using "
"B<clone>(2)  with the B<CLONE_PIDFD> flag."
msgstr ""

#. type: SS
#: build/C/man2/pidfd_open.2:145
#, no-wrap
msgid "Use cases for PID file descriptors"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_open.2:153
msgid ""
"A PID file descriptor returned by B<pidfd_open>()  (or by B<clone>(2)  with "
"the B<CLONE_PID> flag) can be used for the following purposes:"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_open.2:158
msgid ""
"The B<pidfd_send_signal>(2)  system call can be used to send a signal to the "
"process referred to by a PID file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_open.2:171
msgid ""
"A PID file descriptor can be monitored using B<poll>(2), B<select>(2), and "
"B<epoll>(7).  When the process that it refers to terminates, these "
"interfaces indicate the file descriptor as readable.  Note, however, that in "
"the current implementation, nothing can be read from the file descriptor "
"(B<read>(2)  on the file descriptor fails with the error B<EINVAL>)."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_open.2:175
msgid ""
"If the PID file descriptor refers to a child of the calling process, then it "
"can be waited on using B<waitid>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_open.2:180
msgid ""
"The B<pidfd_getfd>(2)  system call can be used to obtain a duplicate of a "
"file descriptor of another process referred to by a PID file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_open.2:185
msgid ""
"A PID file descriptor can be used as the argument of B<setns>(2)  in order "
"to move into one or more of the same namespaces as the process referred to "
"by the file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_open.2:200
msgid ""
"The B<pidfd_open>()  system call is the preferred way of obtaining a PID "
"file descriptor for an already existing process.  The alternative is to "
"obtain a file descriptor by opening a I</proc/[pid]> directory.  However, "
"the latter technique is possible only if the B<proc>(5)  filesystem is "
"mounted; furthermore, the file descriptor obtained in this way is I<not> "
"pollable and can't be waited on with B<waitid>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_open.2:209
msgid ""
"The program below opens a PID file descriptor for the process whose PID is "
"specified as its command-line argument.  It then uses B<poll>(2)  to monitor "
"the file descriptor for process exit, as indicated by an B<EPOLLIN> event."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_open.2:219
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/syscall.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>poll.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_open.2:223
#, no-wrap
msgid ""
"#ifndef __NR_pidfd_open\n"
"#define __NR_pidfd_open 434   /* System call # on most architectures */\n"
"#endif\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_open.2:229
#, no-wrap
msgid ""
"static int\n"
"pidfd_open(pid_t pid, unsigned int flags)\n"
"{\n"
"    return syscall(__NR_pidfd_open, pid, flags);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_open.2:235
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct pollfd pollfd;\n"
"    int pidfd, ready;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_open.2:240
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>pidE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_SUCCESS);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_open.2:246
#, no-wrap
msgid ""
"    pidfd = pidfd_open(atoi(argv[1]), 0);\n"
"    if (pidfd == -1) {\n"
"        perror(\"pidfd_open\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_open.2:249
#, no-wrap
msgid ""
"    pollfd.fd = pidfd;\n"
"    pollfd.events = POLLIN;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_open.2:255
#, no-wrap
msgid ""
"    ready = poll(&pollfd, 1, -1);\n"
"    if (ready == -1) {\n"
"        perror(\"poll\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_open.2:258
#, no-wrap
msgid ""
"    printf(\"Events (%#x): POLLIN is %sset\\en\", pollfd.revents,\n"
"            (pollfd.revents & POLLIN) ? \"\" : \"not \");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_open.2:262
#, no-wrap
msgid ""
"    close(pidfd);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_open.2:273
msgid ""
"B<clone>(2), B<kill>(2), B<pidfd_getfd>(2), B<pidfd_send_signal>(2), "
"B<poll>(2), B<select>(2), B<setns>(2), B<waitid>(2), B<epoll>(7)"
msgstr ""

#. type: TH
#: build/C/man2/pidfd_send_signal.2:25
#, no-wrap
msgid "PIDFD_SEND_SIGNAL"
msgstr ""

#. type: TH
#: build/C/man2/pidfd_send_signal.2:25
#, no-wrap
msgid "2020-06-09"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:28
msgid ""
"pidfd_send_signal - send a signal to a process specified by a file "
"descriptor"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:31
#, no-wrap
msgid "B<#include E<lt>signal.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:34
#, no-wrap
msgid ""
"B<int pidfd_send_signal(int >I<pidfd>B<, int >I<sig>B<, siginfo_t "
"*>I<info>B<,>\n"
"B<                      unsigned int >I<flags>B<);>\n"
msgstr ""

#.  See the very detailed commit message for kernel commit
#.  3eb39f47934f9d5a3027fe00d906a45fe3a15fad
#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:45
msgid ""
"The B<pidfd_send_signal>()  system call sends the signal I<sig> to the "
"target process referred to by I<pidfd>, a PID file descriptor that refers to "
"a process."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:52
msgid ""
"If the I<info> argument points to a I<siginfo_t> buffer, that buffer should "
"be populated as described in B<rt_sigqueueinfo>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:61
msgid ""
"If the I<info> argument is a NULL pointer, this is equivalent to specifying "
"a pointer to a I<siginfo_t> buffer whose fields match the values that are "
"implicitly supplied when a signal is sent using B<kill>(2):"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:66
msgid "I<si_signo> is set to the signal number;"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:69
msgid "I<si_errno> is set to 0;"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:73
msgid "I<si_code> is set to B<SI_USER>;"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:76
msgid "I<si_pid> is set to the caller's PID; and"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:79
msgid "I<si_uid> is set to the caller's real user ID."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:85
msgid ""
"The calling process must either be in the same PID namespace as the process "
"referred to by I<pidfd>, or be in an ancestor of that namespace."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:97
msgid ""
"On success, B<pidfd_send_signal>()  returns 0.  On error, -1 is returned and "
"I<errno> is set to indicate the cause of the error."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:106
msgid "I<sig> is not a valid signal."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:110
msgid ""
"The calling process is not in a PID namespace from which it can send a "
"signal to the target process."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:118
msgid ""
"The calling process does not have permission to send the signal to the "
"target process."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:125
msgid ""
"I<pidfd> doesn't refer to the calling process, and I<info.si_code> is "
"invalid (see B<rt_sigqueueinfo>(2))."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:129
msgid ""
"The target process does not exist (i.e., it has terminated and been waited "
"on)."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:132
msgid "B<pidfd_send_signal>()  first appeared in Linux 5.1."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:135
msgid "B<pidfd_send_signal>()  is Linux specific."
msgstr ""

#. type: SS
#: build/C/man2/pidfd_send_signal.2:139
#, no-wrap
msgid "PID file descriptors"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:145
msgid ""
"The I<pidfd> argument is a PID file descriptor, a file descriptor that "
"refers to process.  Such a file descriptor can be obtained in any of the "
"following ways:"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:149
msgid "by opening a I</proc/[pid]> directory;"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:153
msgid "using B<pidfd_open>(2); or"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:161
msgid ""
"via the PID file descriptor that is returned by a call to B<clone>(2)  or "
"B<clone3>(2)  that specifies the B<CLONE_PIDFD> flag."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:179
msgid ""
"The B<pidfd_send_signal>()  system call allows the avoidance of race "
"conditions that occur when using traditional interfaces (such as B<kill>(2))  "
"to signal a process.  The problem is that the traditional interfaces specify "
"the target process via a process ID (PID), with the result that the sender "
"may accidentally send a signal to the wrong process if the originally "
"intended target process has terminated and its PID has been recycled for "
"another process.  By contrast, a PID file descriptor is a stable reference "
"to a specific process; if that process terminates, B<pidfd_send_signal>()  "
"fails with the error B<ESRCH>."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:190
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>limits.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/syscall.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:194
#, no-wrap
msgid ""
"#ifndef __NR_pidfd_send_signal\n"
"#define __NR_pidfd_send_signal 424\n"
"#endif\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:201
#, no-wrap
msgid ""
"static int\n"
"pidfd_send_signal(int pidfd, int sig, siginfo_t *info,\n"
"        unsigned int flags)\n"
"{\n"
"    return syscall(__NR_pidfd_send_signal, pidfd, sig, info, flags);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:208
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    siginfo_t info;\n"
"    char path[PATH_MAX];\n"
"    int pidfd, sig;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:213
#, no-wrap
msgid ""
"    if (argc != 3) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>pidE<gt> E<lt>signalE<gt>\\en\", "
"argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:215
#, no-wrap
msgid "    sig = atoi(argv[2]);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:218
#, no-wrap
msgid ""
"    /* Obtain a PID file descriptor by opening the /proc/PID directory\n"
"       of the target process */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:220
#, no-wrap
msgid "    snprintf(path, sizeof(path), \"/proc/%s\", argv[1]);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:226
#, no-wrap
msgid ""
"    pidfd = open(path, O_RDONLY);\n"
"    if (pidfd == -1) {\n"
"        perror(\"open\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:229
#, no-wrap
msgid ""
"    /* Populate a \\(aqsiginfo_t\\(aq structure for use with\n"
"       pidfd_send_signal() */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:237
#, no-wrap
msgid ""
"    memset(&info, 0, sizeof(info));\n"
"    info.si_code = SI_QUEUE;\n"
"    info.si_signo = sig;\n"
"    info.si_errno = 0;\n"
"    info.si_uid = getuid();\n"
"    info.si_pid = getpid();\n"
"    info.si_value.sival_int = 1234;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:239
#, no-wrap
msgid "    /* Send the signal */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:244
#, no-wrap
msgid ""
"    if (pidfd_send_signal(pidfd, sig, &info, 0) == -1) {\n"
"        perror(\"pidfd_send_signal\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:256
msgid ""
"B<clone>(2), B<kill>(2), B<pidfd_open>(2), B<rt_sigqueueinfo>(2), "
"B<sigaction>(2), B<pid_namespaces>(7), B<signal>(7)"
msgstr ""

#. type: TH
#: build/C/man3/posix_spawn.3:31
#, no-wrap
msgid "POSIX_SPAWN"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:34
msgid "posix_spawn, posix_spawnp - spawn a process"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:37
#, no-wrap
msgid "B<#include E<lt>spawn.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:42
#, no-wrap
msgid ""
"B<int posix_spawn(pid_t *>I<pid>B<, const char *>I<path>B<,>\n"
"B<                const posix_spawn_file_actions_t *>I<file_actions>B<,>\n"
"B<                const posix_spawnattr_t *>I<attrp>B<,>\n"
"B<                char *const >I<argv[]>B<, char *const >I<envp[]>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:47
#, no-wrap
msgid ""
"B<int posix_spawnp(pid_t *>I<pid>B<, const char *>I<file>B<,>\n"
"B<                 const posix_spawn_file_actions_t *>I<file_actions>B<,>\n"
"B<                 const posix_spawnattr_t *>I<attrp>B<,>\n"
"B<                 char *const >I<argv[]>B<, char *const >I<envp[]>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:61
msgid ""
"The B<posix_spawn>()  and B<posix_spawnp>()  functions are used to create a "
"new child process that executes a specified file.  These functions were "
"specified by POSIX to provide a standardized method of creating new "
"processes on machines that lack the capability to support the B<fork>(2)  "
"system call.  These machines are generally small, embedded systems lacking "
"MMU support."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:79
msgid ""
"The B<posix_spawn>()  and B<posix_spawnp>()  functions provide the "
"functionality of a combined B<fork>(2)  and B<exec>(3), with some optional "
"housekeeping steps in the child process before the B<exec>(3).  These "
"functions are not meant to replace the B<fork>(2)  and B<execve>(2)  system "
"calls.  In fact, they provide only a subset of the functionality that can be "
"achieved by using the system calls."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:102
msgid ""
"The only difference between B<posix_spawn>()  and B<posix_spawnp>()  is the "
"manner in which they specify the file to be executed by the child process.  "
"With B<posix_spawn>(), the executable file is specified as a pathname (which "
"can be absolute or relative).  With B<posix_spawnp>(), the executable file "
"is specified as a simple filename; the system searches for this file in the "
"list of directories specified by B<PATH> (in the same way as for "
"B<execvp>(3)).  For the remainder of this page, the discussion is phrased in "
"terms of B<posix_spawn>(), with the understanding that B<posix_spawnp>()  "
"differs only on the point just described."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:104
msgid "The remaining arguments to these two functions are as follows:"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:109
msgid ""
"The I<pid> argument points to a buffer that is used to return the process ID "
"of the new child process."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:127
msgid ""
"The I<file_actions> argument points to a I<spawn file actions object> that "
"specifies file-related actions to be performed in the child between the "
"B<fork>(2)  and B<exec>(3)  steps.  This object is initialized and populated "
"before the B<posix_spawn>()  call using B<posix_spawn_file_actions_init>(3)  "
"and the B<posix_spawn_file_actions_*>()  functions."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:140
msgid ""
"The I<attrp> argument points to an I<attributes objects> that specifies "
"various attributes of the created child process.  This object is initialized "
"and populated before the B<posix_spawn>()  call using "
"B<posix_spawnattr_init>(3)  and the B<posix_spawnattr_*>()  functions."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:148
msgid ""
"The I<argv> and I<envp> arguments specify the argument list and environment "
"for the program that is executed in the child process, as for B<execve>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:157
msgid ""
"Below, the functions are described in terms of a three-step process: the "
"B<fork>()  step, the pre-B<exec>()  step (executed in the child), and the "
"B<exec>()  step (executed in the child)."
msgstr ""

#. type: SS
#: build/C/man3/posix_spawn.3:157
#, no-wrap
msgid "fork() step"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:172
msgid ""
"Since glibc 2.24, the B<posix_spawn>()  function commences by calling "
"B<clone>(2)  with B<CLONE_VM> and B<CLONE_VFORK> flags.  Older "
"implementations use B<fork>(2), or possibly B<vfork>(2)  (see below)."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:178
msgid ""
"The PID of the new child process is placed in I<*pid>.  The B<posix_spawn>()  "
"function then returns control to the parent process."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:185
msgid ""
"Subsequently, the parent can use one of the system calls described in "
"B<wait>(2)  to check the status of the child process.  If the child fails in "
"any of the housekeeping steps described below, or fails to execute the "
"desired file, it exits with a status of 127."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:191
msgid ""
"Before glibc 2.24, the child process is created using B<vfork>(2)  instead "
"of B<fork>(2)  when either of the following is true:"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:199
msgid ""
"the I<spawn-flags> element of the attributes object pointed to by I<attrp> "
"contains the GNU-specific flag B<POSIX_SPAWN_USEVFORK>; or"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:213
msgid ""
"I<file_actions> is NULL and the I<spawn-flags> element of the attributes "
"object pointed to by I<attrp> does I<not> contain B<POSIX_SPAWN_SETSIGMASK>, "
"B<POSIX_SPAWN_SETSIGDEF>, B<POSIX_SPAWN_SETSCHEDPARAM>, "
"B<POSIX_SPAWN_SETSCHEDULER>, B<POSIX_SPAWN_SETPGROUP>, or "
"B<POSIX_SPAWN_RESETIDS>."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:220
msgid ""
"In other words, B<vfork>(2)  is used if the caller requests it, or if there "
"is no cleanup expected in the child before it B<exec>(3)s the requested "
"file."
msgstr ""

#. type: SS
#: build/C/man3/posix_spawn.3:221
#, no-wrap
msgid "pre-exec() step: housekeeping"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:238
msgid ""
"In between the B<fork()> and the B<exec()> steps, a child process may need "
"to perform a set of housekeeping actions.  The B<posix_spawn>()  and "
"B<posix_spawnp>()  functions support a small, well-defined set of system "
"tasks that the child process can accomplish before it executes the "
"executable file.  These operations are controlled by the attributes object "
"pointed to by I<attrp> and the file actions object pointed to by "
"I<file_actions>.  In the child, processing is done in the following "
"sequence:"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:244
msgid ""
"Process attribute actions: signal mask, signal default handlers, scheduling "
"algorithm and parameters, process group, and effective user and group IDs "
"are changed as specified by the attributes object pointed to by I<attrp>."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:251
msgid ""
"File actions, as specified in the I<file_actions> argument, are performed in "
"the order that they were specified using calls to the "
"B<posix_spawn_file_actions_add*>()  functions."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:255
msgid "File descriptors with the B<FD_CLOEXEC> flag set are closed."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:266
msgid ""
"All process attributes in the child, other than those affected by attributes "
"specified in the object pointed to by I<attrp> and the file actions in the "
"object pointed to by I<file_actions>, will be affected as though the child "
"was created with B<fork>(2)  and it executed the program with B<execve>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:277
msgid ""
"The process attributes actions are defined by the attributes object pointed "
"to by I<attrp>.  The I<spawn-flags> attribute (set using "
"B<posix_spawnattr_setflags>(3))  controls the general actions that occur, "
"and other attributes in the object specify values to be used during those "
"actions."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:281
msgid ""
"The effects of the flags that may be specified in I<spawn-flags> are as "
"follows:"
msgstr ""

#. type: TP
#: build/C/man3/posix_spawn.3:281
#, no-wrap
msgid "B<POSIX_SPAWN_SETSIGMASK>"
msgstr ""

#.  FIXME .
#.  (see
#.  .BR posix_spawnattr_setsigmask (3))
#. type: Plain text
#: build/C/man3/posix_spawn.3:294
msgid ""
"Set the signal mask to the signal set specified in the I<spawn-sigmask> "
"attribute of the object pointed to by I<attrp>.  If the "
"B<POSIX_SPAWN_SETSIGMASK> flag is not set, then the child inherits the "
"parent's signal mask."
msgstr ""

#. type: TP
#: build/C/man3/posix_spawn.3:294
#, no-wrap
msgid "B<POSIX_SPAWN_SETSIGDEF>"
msgstr ""

#.  FIXME .
#.  (see
#.  .BR posix_spawnattr_setsigdefault (3))
#. type: Plain text
#: build/C/man3/posix_spawn.3:311
msgid ""
"Reset the disposition of all signals in the set specified in the "
"I<spawn-sigdefault> attribute of the object pointed to by I<attrp> to the "
"default.  For the treatment of the dispositions of signals not specified in "
"the I<spawn-sigdefault> attribute, or the treatment when "
"B<POSIX_SPAWN_SETSIGDEF> is not specified, see B<execve>(2)."
msgstr ""

#. type: TP
#: build/C/man3/posix_spawn.3:311
#, no-wrap
msgid "B<POSIX_SPAWN_SETSCHEDPARAM>"
msgstr ""

#.  (POSIX_PRIORITY_SCHEDULING only)
#.  FIXME .
#.  (see
#.  .BR posix_spawnattr_setschedparam (3))
#. type: Plain text
#: build/C/man3/posix_spawn.3:325
msgid ""
"If this flag is set, and the B<POSIX_SPAWN_SETSCHEDULER> flag is not set, "
"then set the scheduling parameters to the parameters specified in the "
"I<spawn-schedparam> attribute of the object pointed to by I<attrp>."
msgstr ""

#. type: TP
#: build/C/man3/posix_spawn.3:325
#, no-wrap
msgid "B<POSIX_SPAWN_SETSCHEDULER>"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:329
msgid "Set the scheduling policy algorithm and parameters of the child, as follows:"
msgstr ""

#.  FIXME .
#.  (see
#.  .BR posix_spawnattr_setpolicy (3))
#. type: Plain text
#: build/C/man3/posix_spawn.3:339
msgid ""
"The scheduling policy is set to the value specified in the "
"I<spawn-schedpolicy> attribute of the object pointed to by I<attrp>."
msgstr ""

#.  FIXME .
#.  (see
#.  .BR posix_spawnattr_setschedparam (3))
#. type: Plain text
#: build/C/man3/posix_spawn.3:349
msgid ""
"The scheduling parameters are set to the value specified in the "
"I<spawn-schedparam> attribute of the object pointed to by I<attrp> (but see "
"BUGS)."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:356
msgid ""
"If the B<POSIX_SPAWN_SETSCHEDPARAM> and B<POSIX_SPAWN_SETSCHEDPOLICY> flags "
"are not specified, the child inherits the corresponding scheduling "
"attributes from the parent."
msgstr ""

#. type: TP
#: build/C/man3/posix_spawn.3:357
#, no-wrap
msgid "B<POSIX_SPAWN_RESETIDS>"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:368
msgid ""
"If this flag is set, reset the effective UID and GID to the real UID and GID "
"of the parent process.  If this flag is not set, then the child retains the "
"effective UID and GID of the parent.  In either case, if the set-user-ID and "
"set-group-ID permission bits are enabled on the executable file, their "
"effect will override the setting of the effective UID and GID (se "
"B<execve>(2))."
msgstr ""

#. type: TP
#: build/C/man3/posix_spawn.3:368
#, no-wrap
msgid "B<POSIX_SPAWN_SETPGROUP>"
msgstr ""

#.  FIXME .
#.  (see
#.  .BR posix_spawnattr_setpgroup (3))
#. type: Plain text
#: build/C/man3/posix_spawn.3:385
msgid ""
"Set the process group to the value specified in the I<spawn-pgroup> "
"attribute of the object pointed to by I<attrp>.  If the I<spawn-pgroup> "
"attribute has the value 0, the child's process group ID is made the same as "
"its process ID.  If the B<POSIX_SPAWN_SETPGROUP> flag is not set, the child "
"inherits the parent's process group ID."
msgstr ""

#. type: TP
#: build/C/man3/posix_spawn.3:385
#, no-wrap
msgid "B<POSIX_SPAWN_USEVFORK>"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:397
msgid ""
"Since glibc 2.24, this flag has no effect.  On older implementations, "
"setting this flag forces the B<fork()> step to use B<vfork>(2)  instead of "
"B<fork>(2).  The B<_GNU_SOURCE> feature test macro must be defined to obtain "
"the definition of this constant."
msgstr ""

#. type: TP
#: build/C/man3/posix_spawn.3:397
#, no-wrap
msgid "B<POSIX_SPAWN_SETSID> (since glibc 2.26)"
msgstr ""

#.  This flag has been accepted in POSIX, see:
#.  http://austingroupbugs.net/view.php?id=1044
#.  and has been implemented in glibc since version 2.26
#.  commit daeb1fa2e1b33323e719015f5f546988bd4cc73b
#. type: Plain text
#: build/C/man3/posix_spawn.3:411
msgid ""
"If this flag is set, the child process shall create a new session and become "
"the session leader.  The child process shall also become the process group "
"leader of the new process group in the session (see B<setsid>(2)).  The "
"B<_GNU_SOURCE> feature test macro must be defined to obtain the definition "
"of this constant."
msgstr ""

#.  mtk: I think we probably don't want to say the following, since it
#.       could lead people to do the wrong thing
#.  The POSIX standard tells you to call
#.  this function to de-initialize the attributes object pointed to by
#.  .I attrp
#.  when you are done with it;
#.  however, on Linux systems this operation is a no-op.
#. type: Plain text
#: build/C/man3/posix_spawn.3:422
msgid ""
"If I<attrp> is NULL, then the default behaviors described above for each "
"flag apply."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:439
msgid ""
"The I<file_actions> argument specifies a sequence of file operations that "
"are performed in the child process after the general processing described "
"above, and before it performs the B<exec>(3).  If I<file_actions> is NULL, "
"then no special action is taken, and standard B<exec>(3)  semantics "
"apply\\(emfile descriptors open before the exec remain open in the new "
"process, except those for which the B<FD_CLOEXEC> flag has been set.  File "
"locks remain in place."
msgstr ""

#.  FIXME . I think the following is best placed in the
#.  posix_spawn_file_actions_adddup2(3) page, and a similar statement is
#.  also needed in posix_spawn_file_actions_addclose(3)
#.  Note that you can specify file descriptors in
#.  .I posix_spawn_file_actions_adddup2 (3)
#.  which would not be usable if you called
#.  .BR dup2 (2)
#.  at that time--i.e., file descriptors that are opened or
#.  closed by the earlier operations
#.  added to
#.  .I file_actions .
#. type: Plain text
#: build/C/man3/posix_spawn.3:468
msgid ""
"If I<file_actions> is not NULL, then it contains an ordered set of requests "
"to B<open>(2), B<close>(2), and B<dup2>(2)  files.  These requests are added "
"to the I<file_actions> by B<posix_spawn_file_actions_addopen>(3), "
"B<posix_spawn_file_actions_addclose>(3), and "
"B<posix_spawn_file_actions_adddup2>(3).  The requested operations are "
"performed in the order they were added to I<file_actions>."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:474
msgid ""
"If any of the housekeeping actions fails (due to bogus values being passed "
"or other reasons why signal handling, process scheduling, process group ID "
"functions, and file descriptor operations might fail), the child process "
"exits with exit value 127."
msgstr ""

#. type: SS
#: build/C/man3/posix_spawn.3:474
#, no-wrap
msgid "exec() step"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:478
msgid ""
"Once the child has successfully forked and performed all requested pre-exec "
"steps, the child runs the requested executable."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:487
msgid ""
"The child process takes its environment from the I<envp> argument, which is "
"interpreted as if it had been passed to B<execve>(2).  The arguments to the "
"created process come from the I<argv> argument, which is processed as for "
"B<execve>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:503
msgid ""
"Upon successful completion, B<posix_spawn>()  and B<posix_spawnp>()  place "
"the PID of the child process in I<pid>, and return 0.  If there is an error "
"during the B<fork()> step, then no child is created, the contents of I<*pid> "
"are unspecified, and these functions return an error number as described "
"below."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:511
msgid ""
"Even when these functions return a success status, the child process may "
"still fail for a plethora of reasons related to its pre-B<exec>() "
"initialization.  In addition, the B<exec>(3)  may fail.  In all of these "
"cases, the child process will exit with the exit value of 127."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:527
msgid ""
"The B<posix_spawn>()  and B<posix_spawnp>()  functions fail only in the case "
"where the underlying B<fork>(2), B<vfork>(2)  or B<clone>(2)  call fails; in "
"these cases, these functions return an error number, which will be one of "
"the errors described for B<fork>(2), B<vfork>(2)  or B<clone>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:529
msgid "In addition, these functions fail if:"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:532
msgid "Function not supported on this system."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:538
msgid ""
"The B<posix_spawn>()  and B<posix_spawnp>()  functions are available since "
"glibc 2.2."
msgstr ""

#.  FIXME . This piece belongs in spawnattr_setflags(3)
#.  The
#.  .B POSIX_SPAWN_USEVFORK
#.  flag is a GNU extension; the
#.  .B _GNU_SOURCE
#.  feature test macro must be defined (before including any header files)
#.  to obtain the definition of this constant.
#. type: Plain text
#: build/C/man3/posix_spawn.3:547
msgid "POSIX.1-2001, POSIX.1-2008."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:564
msgid ""
"The housekeeping activities in the child are controlled by the objects "
"pointed to by I<attrp> (for non-file actions) and I<file_actions> In POSIX "
"parlance, the I<posix_spawnattr_t> and I<posix_spawn_file_actions_t> data "
"types are referred to as objects, and their elements are not specified by "
"name.  Portable programs should initialize these objects using only the "
"POSIX-specified functions.  (In other words, although these objects may be "
"implemented as structures containing fields, portable programs must avoid "
"dependence on such implementation details.)"
msgstr ""

#.  Tested on glibc 2.12
#. type: Plain text
#: build/C/man3/posix_spawn.3:575
msgid ""
"According to POSIX, it is unspecified whether fork handlers established with "
"B<pthread_atfork>(3)  are called when B<posix_spawn>()  is invoked.  Since "
"glibc 2.24, the fork handlers are not executed in any case.  On older "
"implementations, fork handlers are called only if the child is created using "
"B<fork>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:587
msgid ""
"There is no \"posix_fspawn\" function (i.e., a function that is to "
"B<posix_spawn>()  as B<fexecve>(3)  is to B<execve>(2)).  However, this "
"functionality can be obtained by specifying the I<path> argument as one of "
"the files in the caller's I</proc/self/fd> directory."
msgstr ""

#.  http://sourceware.org/bugzilla/show_bug.cgi?id=12052
#. type: Plain text
#: build/C/man3/posix_spawn.3:602
msgid ""
"POSIX.1 says that when B<POSIX_SPAWN_SETSCHEDULER> is specified in "
"I<spawn-flags>, then the B<POSIX_SPAWN_SETSCHEDPARAM> (if present) is "
"ignored.  However, before glibc 2.14, calls to B<posix_spawn>()  failed with "
"an error if B<POSIX_SPAWN_SETSCHEDULER> was specified without also "
"specifying B<POSIX_SPAWN_SETSCHEDPARAM>."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:609
msgid ""
"The program below demonstrates the use of various functions in the POSIX "
"spawn API.  The program accepts command-line attributes that can be used to "
"create file actions and attributes objects.  The remaining command-line "
"arguments are used as the executable name and command-line arguments of the "
"program that is executed in the child."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:615
msgid ""
"In the first run, the B<date>(1)  command is executed in the child, and the "
"B<posix_spawn>()  call employs no file actions or attributes objects."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:622
#, no-wrap
msgid ""
"$ B<./a.out date>\n"
"PID of child: 7634\n"
"Tue Feb  1 19:47:50 CEST 2011\n"
"Child status: exited, status=0\n"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:632
msgid ""
"In the next run, the I<-c> command-line option is used to create a file "
"actions object that closes standard output in the child.  Consequently, "
"B<date>(1)  fails when trying to perform output and exits with a status of "
"1."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:639
#, no-wrap
msgid ""
"$ B<./a.out -c date>\n"
"PID of child: 7636\n"
"date: write error: Bad file descriptor\n"
"Child status: exited, status=1\n"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:656
msgid ""
"In the next run, the I<-s> command-line option is used to create an "
"attributes object that specifies that all (blockable) signals in the child "
"should be blocked.  Consequently, trying to kill child with the default "
"signal sent by B<kill>(1)  (i.e., B<SIGTERM>)  fails, because that signal is "
"blocked.  Therefore, to kill the child, B<SIGKILL> is necessary (B<SIGKILL> "
"can't be blocked)."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:662
#, no-wrap
msgid ""
"$ B<./a.out -s sleep 60 &>\n"
"[1] 7637\n"
"$ PID of child: 7638\n"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:667
#, no-wrap
msgid ""
"$ B<kill 7638>\n"
"$ B<kill -KILL 7638>\n"
"$ Child status: killed by signal 9\n"
"[1]+  Done                    ./a.out -s sleep 60\n"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:673
msgid ""
"When we try to execute a nonexistent command in the child, the B<exec>(3)  "
"fails and the child exits with a status of 127."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:679
#, no-wrap
msgid ""
"$ B<./a.out xxxxx\n"
"PID of child: 10190\n"
"Child status: exited, status=127>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:692
#, no-wrap
msgid ""
"#include E<lt>spawn.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>wait.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:695
#, no-wrap
msgid ""
"#define errExit(msg)    do { perror(msg); \\e\n"
"                             exit(EXIT_FAILURE); } while (0)\n"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:699
#, no-wrap
msgid ""
"#define errExitEN(en, msg) \\e\n"
"                        do { errno = en; perror(msg); \\e\n"
"                             exit(EXIT_FAILURE); } while (0)\n"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:701
#, no-wrap
msgid "char **environ;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:712
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pid_t child_pid;\n"
"    int s, opt, status;\n"
"    sigset_t mask;\n"
"    posix_spawnattr_t attr;\n"
"    posix_spawnattr_t *attrp;\n"
"    posix_spawn_file_actions_t file_actions;\n"
"    posix_spawn_file_actions_t *file_actionsp;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:715
#, no-wrap
msgid ""
"    /* Parse command-line options, which can be used to specify an\n"
"       attributes object and file actions object for the child. */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:718
#, no-wrap
msgid ""
"    attrp = NULL;\n"
"    file_actionsp = NULL;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:722
#, no-wrap
msgid ""
"    while ((opt = getopt(argc, argv, \"sc\")) != -1) {\n"
"        switch (opt) {\n"
"        case \\(aqc\\(aq:       /* -c: close standard output in child */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:725
#, no-wrap
msgid ""
"            /* Create a file actions object and add a \"close\"\n"
"               action to it */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:729
#, no-wrap
msgid ""
"            s = posix_spawn_file_actions_init(&file_actions);\n"
"            if (s != 0)\n"
"                errExitEN(s, \"posix_spawn_file_actions_init\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:734
#, no-wrap
msgid ""
"            s = posix_spawn_file_actions_addclose(&file_actions,\n"
"                                                  STDOUT_FILENO);\n"
"            if (s != 0)\n"
"                errExitEN(s, \"posix_spawn_file_actions_addclose\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:737
#, no-wrap
msgid ""
"            file_actionsp = &file_actions;\n"
"            break;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:739
#, no-wrap
msgid "        case \\(aqs\\(aq:       /* -s: block all signals in child */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:742
#, no-wrap
msgid ""
"            /* Create an attributes object and add a \"set signal mask\"\n"
"               action to it */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:749
#, no-wrap
msgid ""
"            s = posix_spawnattr_init(&attr);\n"
"            if (s != 0)\n"
"                errExitEN(s, \"posix_spawnattr_init\");\n"
"            s = posix_spawnattr_setflags(&attr, POSIX_SPAWN_SETSIGMASK);\n"
"            if (s != 0)\n"
"                errExitEN(s, \"posix_spawnattr_setflags\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:754
#, no-wrap
msgid ""
"            sigfillset(&mask);\n"
"            s = posix_spawnattr_setsigmask(&attr, &mask);\n"
"            if (s != 0)\n"
"                errExitEN(s, \"posix_spawnattr_setsigmask\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:759
#, no-wrap
msgid ""
"            attrp = &attr;\n"
"            break;\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:764
#, no-wrap
msgid ""
"    /* Spawn the child. The name of the program to execute and the\n"
"       command-line arguments are taken from the command-line arguments\n"
"       of this program. The environment of the program execed in the\n"
"       child is made the same as the parent\\(aqs environment. */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:769
#, no-wrap
msgid ""
"    s = posix_spawnp(&child_pid, argv[optind], file_actionsp, attrp,\n"
"                     &argv[optind], environ);\n"
"    if (s != 0)\n"
"        errExitEN(s, \"posix_spawn\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:771
#, no-wrap
msgid "    /* Destroy any objects that we created earlier */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:777
#, no-wrap
msgid ""
"    if (attrp != NULL) {\n"
"        s = posix_spawnattr_destroy(attrp);\n"
"        if (s != 0)\n"
"            errExitEN(s, \"posix_spawnattr_destroy\");\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:783
#, no-wrap
msgid ""
"    if (file_actionsp != NULL) {\n"
"        s = posix_spawn_file_actions_destroy(file_actionsp);\n"
"        if (s != 0)\n"
"            errExitEN(s, \"posix_spawn_file_actions_destroy\");\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:785
#, no-wrap
msgid "    printf(\"PID of child: %jd\\en\", (intmax_t) child_pid);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:787
#, no-wrap
msgid "    /* Monitor status of the child until it terminates */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:792
#, no-wrap
msgid ""
"    do {\n"
"        s = waitpid(child_pid, &status, WUNTRACED | WCONTINUED);\n"
"        if (s == -1)\n"
"            errExit(\"waitpid\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:804
#, no-wrap
msgid ""
"        printf(\"Child status: \");\n"
"        if (WIFEXITED(status)) {\n"
"            printf(\"exited, status=%d\\en\", WEXITSTATUS(status));\n"
"        } else if (WIFSIGNALED(status)) {\n"
"            printf(\"killed by signal %d\\en\", WTERMSIG(status));\n"
"        } else if (WIFSTOPPED(status)) {\n"
"            printf(\"stopped by signal %d\\en\", WSTOPSIG(status));\n"
"        } else if (WIFCONTINUED(status)) {\n"
"            printf(\"continued\\en\");\n"
"        }\n"
"    } while (!WIFEXITED(status) && !WIFSIGNALED(status));\n"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:846
msgid ""
"B<close>(2), B<dup2>(2), B<execl>(2), B<execlp>(2), B<fork>(2), B<open>(2), "
"B<sched_setparam>(2), B<sched_setscheduler>(2), B<setpgid>(2), B<setuid>(2), "
"B<sigaction>(2), B<sigprocmask>(2), B<posix_spawn_file_actions_addclose>(3), "
"B<posix_spawn_file_actions_adddup2>(3), "
"B<posix_spawn_file_actions_addopen>(3), "
"B<posix_spawn_file_actions_destroy>(3), B<posix_spawn_file_actions_init>(3), "
"B<posix_spawnattr_destroy>(3), B<posix_spawnattr_getflags>(3), "
"B<posix_spawnattr_getpgroup>(3), B<posix_spawnattr_getschedparam>(3), "
"B<posix_spawnattr_getschedpolicy>(3), B<posix_spawnattr_getsigdefault>(3), "
"B<posix_spawnattr_getsigmask>(3), B<posix_spawnattr_init>(3), "
"B<posix_spawnattr_setflags>(3), B<posix_spawnattr_setpgroup>(3), "
"B<posix_spawnattr_setschedparam>(3), B<posix_spawnattr_setschedpolicy>(3), "
"B<posix_spawnattr_setsigdefault>(3), B<posix_spawnattr_setsigmask>(3), "
"B<pthread_atfork>(3), I<E<lt>spawn.hE<gt>>, Base Definitions volume of "
"POSIX.1-2001, I<http://www.opengroup.org/unix/online.html>"
msgstr ""
