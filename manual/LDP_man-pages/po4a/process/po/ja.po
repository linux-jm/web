# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-03-12 14:00+0900\n"
"PO-Revision-Date: 2021-07-19 09:27+0900\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man2/acct.2:31 build/C/man5/acct.5:25
#, no-wrap
msgid "ACCT"
msgstr "ACCT"

#. type: TH
#: build/C/man2/acct.2:31
#, no-wrap
msgid "2016-03-15"
msgstr "2016-03-15"

#. type: TH
#: build/C/man2/acct.2:31 build/C/man5/acct.5:25 build/C/man7/capabilities.7:48
#: build/C/man2/capget.2:16 build/C/man7/cpuset.7:25
#: build/C/man7/credentials.7:27 build/C/man2/getgid.2:25
#: build/C/man2/getgroups.2:32 build/C/man2/getpid.2:25
#: build/C/man2/getpriority.2:45 build/C/man2/getresuid.2:28
#: build/C/man2/getrlimit.2:64 build/C/man2/getrusage.2:39
#: build/C/man2/getsid.2:27 build/C/man2/getuid.2:26 build/C/man2/iopl.2:33
#: build/C/man2/ioprio_set.2:24 build/C/man2/ipc.2:25 build/C/man2/seteuid.2:29
#: build/C/man2/setfsgid.2:32 build/C/man2/setfsuid.2:32
#: build/C/man2/setgid.2:30 build/C/man2/setpgid.2:48
#: build/C/man2/setresuid.2:27 build/C/man2/setreuid.2:46
#: build/C/man2/setsid.2:31 build/C/man2/setuid.2:31 build/C/man7/sysvipc.7:25
#: build/C/man3/ulimit.3:27 build/C/man2/seccomp.2:28 build/C/man7/cgroups.7:26
#: build/C/man2/pidfd_getfd.2:25 build/C/man2/pidfd_open.2:25
#: build/C/man2/pidfd_send_signal.2:25
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#: build/C/man2/acct.2:31 build/C/man5/acct.5:25 build/C/man7/capabilities.7:48
#: build/C/man2/capget.2:16 build/C/man7/cpuset.7:25
#: build/C/man7/credentials.7:27 build/C/man2/getgid.2:25
#: build/C/man2/getgroups.2:32 build/C/man2/getpid.2:25
#: build/C/man2/getpriority.2:45 build/C/man2/getresuid.2:28
#: build/C/man2/getrlimit.2:64 build/C/man2/getrusage.2:39
#: build/C/man2/getsid.2:27 build/C/man2/getuid.2:26
#: build/C/man3/group_member.3:25 build/C/man2/iopl.2:33
#: build/C/man2/ioprio_set.2:24 build/C/man2/ipc.2:25 build/C/man2/seteuid.2:29
#: build/C/man2/setfsgid.2:32 build/C/man2/setfsuid.2:32
#: build/C/man2/setgid.2:30 build/C/man2/setpgid.2:48
#: build/C/man2/setresuid.2:27 build/C/man2/setreuid.2:46
#: build/C/man2/setsid.2:31 build/C/man2/setuid.2:31 build/C/man7/sysvipc.7:25
#: build/C/man3/ulimit.3:27 build/C/man2/seccomp.2:28 build/C/man7/cgroups.7:26
#: build/C/man2/pidfd_getfd.2:25 build/C/man2/pidfd_open.2:25
#: build/C/man2/pidfd_send_signal.2:25 build/C/man3/posix_spawn.3:31
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux Programmer's Manual"

#. type: SH
#: build/C/man2/acct.2:32 build/C/man5/acct.5:26 build/C/man7/capabilities.7:49
#: build/C/man2/capget.2:17 build/C/man7/cpuset.7:26
#: build/C/man7/credentials.7:28 build/C/man2/getgid.2:26
#: build/C/man2/getgroups.2:33 build/C/man2/getpid.2:26
#: build/C/man2/getpriority.2:46 build/C/man2/getresuid.2:29
#: build/C/man2/getrlimit.2:65 build/C/man2/getrusage.2:40
#: build/C/man2/getsid.2:28 build/C/man2/getuid.2:27
#: build/C/man3/group_member.3:26 build/C/man2/iopl.2:34
#: build/C/man2/ioprio_set.2:25 build/C/man2/ipc.2:26 build/C/man2/seteuid.2:30
#: build/C/man2/setfsgid.2:33 build/C/man2/setfsuid.2:33
#: build/C/man2/setgid.2:31 build/C/man2/setpgid.2:49
#: build/C/man2/setresuid.2:28 build/C/man2/setreuid.2:47
#: build/C/man2/setsid.2:32 build/C/man2/setuid.2:32 build/C/man7/sysvipc.7:26
#: build/C/man3/ulimit.3:28 build/C/man2/seccomp.2:29 build/C/man7/cgroups.7:27
#: build/C/man2/pidfd_getfd.2:26 build/C/man2/pidfd_open.2:26
#: build/C/man2/pidfd_send_signal.2:26 build/C/man3/posix_spawn.3:32
#, no-wrap
msgid "NAME"
msgstr "名前"

#. type: Plain text
#: build/C/man2/acct.2:34
msgid "acct - switch process accounting on or off"
msgstr "acct - プロセスアカウントのオンとオフを切り換える"

#. type: SH
#: build/C/man2/acct.2:34 build/C/man5/acct.5:28 build/C/man2/capget.2:19
#: build/C/man2/getgid.2:28 build/C/man2/getgroups.2:35
#: build/C/man2/getpid.2:28 build/C/man2/getpriority.2:48
#: build/C/man2/getresuid.2:31 build/C/man2/getrlimit.2:67
#: build/C/man2/getrusage.2:42 build/C/man2/getsid.2:30
#: build/C/man2/getuid.2:29 build/C/man3/group_member.3:28
#: build/C/man2/iopl.2:36 build/C/man2/ioprio_set.2:27 build/C/man2/ipc.2:28
#: build/C/man2/seteuid.2:32 build/C/man2/setfsgid.2:35
#: build/C/man2/setfsuid.2:35 build/C/man2/setgid.2:33
#: build/C/man2/setpgid.2:51 build/C/man2/setresuid.2:30
#: build/C/man2/setreuid.2:49 build/C/man2/setsid.2:34 build/C/man2/setuid.2:34
#: build/C/man3/ulimit.3:30 build/C/man2/seccomp.2:31
#: build/C/man2/pidfd_getfd.2:28 build/C/man2/pidfd_open.2:28
#: build/C/man2/pidfd_send_signal.2:28 build/C/man3/posix_spawn.3:34
#, no-wrap
msgid "SYNOPSIS"
msgstr "書式"

#. type: Plain text
#: build/C/man2/acct.2:38
#, no-wrap
msgid "B<#include E<lt>unistd.hE<gt>>\n"
msgstr "B<#include E<lt>unistd.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/acct.2:40
#, no-wrap
msgid "B<int acct(const char *>I<filename>B<);>\n"
msgstr "B<int acct(const char *>I<filename>B<);>\n"

#. type: Plain text
#: build/C/man2/acct.2:46 build/C/man2/getgroups.2:49
#: build/C/man2/getrlimit.2:84 build/C/man2/getsid.2:40
#: build/C/man3/group_member.3:36 build/C/man2/seteuid.2:44
#: build/C/man2/setpgid.2:71 build/C/man2/setreuid.2:61
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr "glibc 向けの機能検査マクロの要件 (B<feature_test_macros>(7)  参照):"

#. type: Plain text
#: build/C/man2/acct.2:49
msgid "B<acct>():"
msgstr "B<acct>():"

#. 		commit 266865c0e7b79d4196e2cc393693463f03c90bd8
#. type: Plain text
#: build/C/man2/acct.2:57
#, no-wrap
msgid ""
"    Since glibc 2.21:\n"
"        _DEFAULT_SOURCE\n"
"    In glibc 2.19 and 2.20:\n"
"        _DEFAULT_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE\\ E<lt>\\ 500)\n"
"    Up to and including glibc 2.19:\n"
"        _BSD_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE\\ E<lt>\\ 500)\n"
msgstr ""

#. type: SH
#: build/C/man2/acct.2:58 build/C/man5/acct.5:30 build/C/man7/capabilities.7:51
#: build/C/man2/capget.2:25 build/C/man7/cpuset.7:28
#: build/C/man7/credentials.7:30 build/C/man2/getgid.2:36
#: build/C/man2/getgroups.2:56 build/C/man2/getpid.2:36
#: build/C/man2/getpriority.2:56 build/C/man2/getresuid.2:39
#: build/C/man2/getrlimit.2:88 build/C/man2/getrusage.2:48
#: build/C/man2/getsid.2:52 build/C/man2/getuid.2:37
#: build/C/man3/group_member.3:40 build/C/man2/iopl.2:40
#: build/C/man2/ioprio_set.2:35 build/C/man2/ipc.2:34 build/C/man2/seteuid.2:54
#: build/C/man2/setfsgid.2:39 build/C/man2/setfsuid.2:39
#: build/C/man2/setgid.2:39 build/C/man2/setpgid.2:98
#: build/C/man2/setresuid.2:38 build/C/man2/setreuid.2:73
#: build/C/man2/setsid.2:43 build/C/man2/setuid.2:40 build/C/man7/sysvipc.7:28
#: build/C/man3/ulimit.3:34 build/C/man2/seccomp.2:44 build/C/man7/cgroups.7:29
#: build/C/man2/pidfd_getfd.2:32 build/C/man2/pidfd_open.2:34
#: build/C/man2/pidfd_send_signal.2:35 build/C/man3/posix_spawn.3:48
#, no-wrap
msgid "DESCRIPTION"
msgstr "説明"

#. type: Plain text
#: build/C/man2/acct.2:68
msgid ""
"The B<acct>()  system call enables or disables process accounting.  If "
"called with the name of an existing file as its argument, accounting is "
"turned on, and records for each terminating process are appended to "
"I<filename> as it terminates.  An argument of NULL causes accounting to be "
"turned off."
msgstr ""
"B<acct>()  システムコールは、プロセスアカウントの有効・無効を切り替える。 既"
"存のファイルの名前を引数に指定して呼び出されたら、 アカウント (account) が"
"有効になり、 終了したプロセスの記録が I<filename> に追記される。 NULL を引"
"数として呼び出されたらアカウントをオフにする。"

#. type: SH
#: build/C/man2/acct.2:68 build/C/man2/capget.2:165
#: build/C/man2/getgroups.2:103 build/C/man2/getpriority.2:120
#: build/C/man2/getresuid.2:50 build/C/man2/getrlimit.2:507
#: build/C/man2/getrusage.2:186 build/C/man2/getsid.2:63
#: build/C/man3/group_member.3:48 build/C/man2/iopl.2:56
#: build/C/man2/ioprio_set.2:152 build/C/man2/seteuid.2:68
#: build/C/man2/setfsgid.2:63 build/C/man2/setfsuid.2:74
#: build/C/man2/setgid.2:56 build/C/man2/setpgid.2:193
#: build/C/man2/setresuid.2:64 build/C/man2/setreuid.2:96
#: build/C/man2/setsid.2:59 build/C/man2/setuid.2:73 build/C/man3/ulimit.3:67
#: build/C/man2/seccomp.2:712 build/C/man2/pidfd_getfd.2:68
#: build/C/man2/pidfd_open.2:47 build/C/man2/pidfd_send_signal.2:90
#: build/C/man3/posix_spawn.3:487
#, no-wrap
msgid "RETURN VALUE"
msgstr "返り値"

#. type: Plain text
#: build/C/man2/acct.2:73 build/C/man2/capget.2:170 build/C/man2/getresuid.2:55
#: build/C/man2/getrusage.2:191 build/C/man2/iopl.2:61
#: build/C/man2/seteuid.2:73 build/C/man2/setgid.2:61
#: build/C/man2/setresuid.2:69 build/C/man2/setreuid.2:101
#: build/C/man2/setuid.2:78
msgid ""
"On success, zero is returned.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""
"成功した場合は 0 が返される。エラーの場合は -1 が返され、 I<errno> が適切に設"
"定される。"

#. type: SH
#: build/C/man2/acct.2:73 build/C/man2/capget.2:184 build/C/man7/cpuset.7:1100
#: build/C/man2/getgid.2:42 build/C/man2/getgroups.2:117
#: build/C/man2/getpid.2:53 build/C/man2/getpriority.2:144
#: build/C/man2/getresuid.2:55 build/C/man2/getrlimit.2:512
#: build/C/man2/getrusage.2:191 build/C/man2/getsid.2:68
#: build/C/man2/getuid.2:43 build/C/man2/iopl.2:61
#: build/C/man2/ioprio_set.2:172 build/C/man2/seteuid.2:80
#: build/C/man2/setgid.2:61 build/C/man2/setpgid.2:214
#: build/C/man2/setresuid.2:76 build/C/man2/setreuid.2:108
#: build/C/man2/setsid.2:66 build/C/man2/setuid.2:85 build/C/man3/ulimit.3:74
#: build/C/man2/seccomp.2:728 build/C/man7/cgroups.7:1746
#: build/C/man2/pidfd_getfd.2:75 build/C/man2/pidfd_open.2:54
#: build/C/man2/pidfd_send_signal.2:97 build/C/man3/posix_spawn.3:511
#, no-wrap
msgid "ERRORS"
msgstr "エラー"

#. type: TP
#: build/C/man2/acct.2:74 build/C/man7/cpuset.7:1116 build/C/man7/cpuset.7:1123
#: build/C/man7/cpuset.7:1129 build/C/man7/cpuset.7:1137
#: build/C/man7/cpuset.7:1144 build/C/man2/getpriority.2:164
#: build/C/man2/setpgid.2:215 build/C/man2/seccomp.2:731
#, no-wrap
msgid "B<EACCES>"
msgstr "B<EACCES>"

#. type: Plain text
#: build/C/man2/acct.2:85
msgid ""
"Write permission is denied for the specified file, or search permission is "
"denied for one of the directories in the path prefix of I<filename> (see "
"also B<path_resolution>(7)), or I<filename> is not a regular file."
msgstr ""
"指定したファイルへの書き込み許可がなく、書き込みが拒否された。 または "
"I<filename> のディレクトリ部分の何れかのディレクトリに検索許可がなく拒否され"
"た (B<path_resolution>(7)  も参照すること)。 または I<filename> が通常 "
"(regular) のファイルでない。"

#. type: TP
#: build/C/man2/acct.2:85 build/C/man2/capget.2:185 build/C/man7/cpuset.7:1172
#: build/C/man2/getgroups.2:118 build/C/man2/getresuid.2:56
#: build/C/man2/getrlimit.2:513 build/C/man2/getrusage.2:192
#: build/C/man2/seccomp.2:739
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
#: build/C/man2/acct.2:89
msgid "I<filename> points outside your accessible address space."
msgstr "アクセスできるアドレス空間の外を I<filename> が指している。"

#. type: TP
#: build/C/man2/acct.2:89 build/C/man7/cpuset.7:1238 build/C/man7/cpuset.7:1246
#, no-wrap
msgid "B<EIO>"
msgstr "B<EIO>"

#. type: Plain text
#: build/C/man2/acct.2:93
msgid "Error writing to the file I<filename>."
msgstr "I<filename> への書き込みにエラーが発生した。"

#. type: TP
#: build/C/man2/acct.2:93
#, no-wrap
msgid "B<EISDIR>"
msgstr "B<EISDIR>"

#. type: Plain text
#: build/C/man2/acct.2:97
msgid "I<filename> is a directory."
msgstr "I<filename> がディレクトリである。"

#. type: TP
#: build/C/man2/acct.2:97
#, no-wrap
msgid "B<ELOOP>"
msgstr "B<ELOOP>"

#. type: Plain text
#: build/C/man2/acct.2:101
msgid "Too many symbolic links were encountered in resolving I<filename>."
msgstr "I<filename> の実体にたどり着くまでのシンボリックリンクの数が多すぎる。"

#. type: TP
#: build/C/man2/acct.2:101 build/C/man7/cpuset.7:1251
#: build/C/man7/cpuset.7:1258 build/C/man7/cpuset.7:1263
#, no-wrap
msgid "B<ENAMETOOLONG>"
msgstr "B<ENAMETOOLONG>"

#. type: Plain text
#: build/C/man2/acct.2:105
msgid "I<filename> was too long."
msgstr "I<filename> が長すぎる。"

#. type: TP
#: build/C/man2/acct.2:105 build/C/man2/pidfd_getfd.2:96
#: build/C/man2/pidfd_open.2:70
#, no-wrap
msgid "B<ENFILE>"
msgstr "B<ENFILE>"

#. type: Plain text
#: build/C/man2/acct.2:108 build/C/man2/pidfd_getfd.2:99
#: build/C/man2/pidfd_open.2:73
msgid ""
"The system-wide limit on the total number of open files has been reached."
msgstr "オープンされたファイルの総数がシステム全体の制限に達した。"

#. type: TP
#: build/C/man2/acct.2:108 build/C/man7/cpuset.7:1275
#: build/C/man7/cpuset.7:1280
#, no-wrap
msgid "B<ENOENT>"
msgstr "B<ENOENT>"

#. type: Plain text
#: build/C/man2/acct.2:111
msgid "The specified file does not exist."
msgstr "指定されたファイルが存在しない。"

#. type: TP
#: build/C/man2/acct.2:111 build/C/man7/cpuset.7:1287
#: build/C/man2/getgroups.2:138 build/C/man2/seccomp.2:776
#: build/C/man2/seccomp.2:779 build/C/man2/pidfd_open.2:76
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
#: build/C/man2/acct.2:114 build/C/man2/getgroups.2:141
#: build/C/man2/seccomp.2:779
msgid "Out of memory."
msgstr "メモリー不足。"

#. type: TP
#: build/C/man2/acct.2:114 build/C/man2/iopl.2:66
#: build/C/man3/posix_spawn.3:529
#, no-wrap
msgid "B<ENOSYS>"
msgstr "B<ENOSYS>"

#. type: Plain text
#: build/C/man2/acct.2:120
msgid ""
"BSD process accounting has not been enabled when the operating system kernel "
"was compiled.  The kernel configuration parameter controlling this feature "
"is B<CONFIG_BSD_PROCESS_ACCT>."
msgstr ""
"カーネルをコンパイルした時に BSD プロセスアカウントが有効になっていない。 こ"
"の機能はカーネルのコンフィグの B<CONFIG_BSD_PROCESS_ACCT> パラメーターによっ"
"て制御される。"

#. type: TP
#: build/C/man2/acct.2:120 build/C/man7/cpuset.7:1314
#, no-wrap
msgid "B<ENOTDIR>"
msgstr "B<ENOTDIR>"

#. type: Plain text
#: build/C/man2/acct.2:125
msgid ""
"A component used as a directory in I<filename> is not in fact a directory."
msgstr ""
"I<filename> の中でディレクトリして扱われている要素が、 実際はディレクトリでな"
"い。"

#. type: TP
#: build/C/man2/acct.2:125 build/C/man2/capget.2:196 build/C/man2/capget.2:201
#: build/C/man2/capget.2:213 build/C/man7/cpuset.7:1319
#: build/C/man2/getgroups.2:141 build/C/man2/getpriority.2:171
#: build/C/man2/getrlimit.2:529 build/C/man2/getrlimit.2:534
#: build/C/man2/getrlimit.2:542 build/C/man2/getsid.2:69 build/C/man2/iopl.2:69
#: build/C/man2/ioprio_set.2:182 build/C/man2/seteuid.2:84
#: build/C/man2/setgid.2:67 build/C/man2/setpgid.2:229
#: build/C/man2/setresuid.2:103 build/C/man2/setreuid.2:135
#: build/C/man2/setsid.2:67 build/C/man2/setuid.2:113 build/C/man3/ulimit.3:75
#: build/C/man2/pidfd_getfd.2:99 build/C/man2/pidfd_send_signal.2:114
#: build/C/man2/pidfd_send_signal.2:118
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#. type: Plain text
#: build/C/man2/acct.2:131
msgid ""
"The calling process has insufficient privilege to enable process "
"accounting.  On Linux, the B<CAP_SYS_PACCT> capability is required."
msgstr ""
"呼び出したプロセスにはプロセスアカウントを有効にするのに十分な特権がない。 "
"Linux では B<CAP_SYS_PACCT> ケーパビリティ (capability) が必要である。"

#. type: TP
#: build/C/man2/acct.2:131
#, no-wrap
msgid "B<EROFS>"
msgstr "B<EROFS>"

#. type: Plain text
#: build/C/man2/acct.2:135
msgid "I<filename> refers to a file on a read-only filesystem."
msgstr ""
"読み込みだけのファイルシステム上のファイルを I<filename> が参照している。"

#. type: TP
#: build/C/man2/acct.2:135
#, no-wrap
msgid "B<EUSERS>"
msgstr "B<EUSERS>"

#. type: Plain text
#: build/C/man2/acct.2:138
msgid "There are no more free file structures or we ran out of memory."
msgstr "使用可能なファイル構造体がないか、メモリーが足りない。"

#. type: SH
#: build/C/man2/acct.2:138 build/C/man5/acct.5:153
#: build/C/man7/capabilities.7:1742 build/C/man2/capget.2:235
#: build/C/man7/credentials.7:321 build/C/man2/getgid.2:44
#: build/C/man2/getgroups.2:156 build/C/man2/getpid.2:55
#: build/C/man2/getpriority.2:179 build/C/man2/getresuid.2:67
#: build/C/man2/getrlimit.2:572 build/C/man2/getrusage.2:213
#: build/C/man2/getsid.2:84 build/C/man2/getuid.2:45
#: build/C/man3/group_member.3:55 build/C/man2/iopl.2:77
#: build/C/man2/ioprio_set.2:199 build/C/man2/ipc.2:45
#: build/C/man2/seteuid.2:103 build/C/man2/setfsgid.2:70
#: build/C/man2/setfsuid.2:81 build/C/man2/setgid.2:74
#: build/C/man2/setpgid.2:248 build/C/man2/setresuid.2:118
#: build/C/man2/setreuid.2:151 build/C/man2/setsid.2:73
#: build/C/man2/setuid.2:120 build/C/man3/ulimit.3:91
#: build/C/man2/seccomp.2:805 build/C/man2/pidfd_getfd.2:117
#: build/C/man2/pidfd_open.2:87 build/C/man2/pidfd_send_signal.2:132
#: build/C/man3/posix_spawn.3:538
#, no-wrap
msgid "CONFORMING TO"
msgstr "準拠"

#.  SVr4 documents an EBUSY error condition, but no EISDIR or ENOSYS.
#.  Also AIX and HP-UX document EBUSY (attempt is made
#.  to enable accounting when it is already enabled), as does Solaris
#.  (attempt is made to enable accounting using the same file that is
#.  currently being used).
#. type: Plain text
#: build/C/man2/acct.2:145
msgid "SVr4, 4.3BSD (but not POSIX)."
msgstr "SVr4, 4.3BSD (POSIX ではない)。"

#. type: SH
#: build/C/man2/acct.2:145 build/C/man5/acct.5:157
#: build/C/man7/capabilities.7:1747 build/C/man2/capget.2:237
#: build/C/man7/cpuset.7:1341 build/C/man7/credentials.7:327
#: build/C/man2/getgid.2:46 build/C/man2/getgroups.2:165
#: build/C/man2/getpid.2:57 build/C/man2/getpriority.2:182
#: build/C/man2/getresuid.2:70 build/C/man2/getrlimit.2:595
#: build/C/man2/getrusage.2:224 build/C/man2/getsid.2:86
#: build/C/man2/getuid.2:47 build/C/man2/iopl.2:81
#: build/C/man2/ioprio_set.2:201 build/C/man2/ipc.2:49
#: build/C/man2/seteuid.2:105 build/C/man2/setfsgid.2:74
#: build/C/man2/setfsuid.2:85 build/C/man2/setgid.2:76
#: build/C/man2/setpgid.2:270 build/C/man2/setresuid.2:121
#: build/C/man2/setreuid.2:157 build/C/man2/setsid.2:75
#: build/C/man2/setuid.2:125 build/C/man2/seccomp.2:809
#: build/C/man7/cgroups.7:1755 build/C/man2/pidfd_getfd.2:120
#: build/C/man2/pidfd_open.2:90 build/C/man2/pidfd_send_signal.2:135
#: build/C/man3/posix_spawn.3:547
#, no-wrap
msgid "NOTES"
msgstr "注意"

#. type: Plain text
#: build/C/man2/acct.2:148
msgid ""
"No accounting is produced for programs running when a system crash occurs.  "
"In particular, nonterminating processes are never accounted for."
msgstr ""
"システムがクラッシュした時に実行中だったプログラムのアカウントは生成されな"
"い。 特に、終了しないプログラムがアカウントされることはない。"

#. type: Plain text
#: build/C/man2/acct.2:151
msgid ""
"The structure of the records written to the accounting file is described in "
"B<acct>(5)."
msgstr ""
"アカウント用ファイルに書き込まれるレコードの構造体については B<acct>(5)  に説"
"明がある。"

#. type: SH
#: build/C/man2/acct.2:151 build/C/man5/acct.5:174
#: build/C/man7/capabilities.7:1827 build/C/man2/capget.2:245
#: build/C/man7/cpuset.7:1489 build/C/man7/credentials.7:348
#: build/C/man2/getgid.2:78 build/C/man2/getgroups.2:219
#: build/C/man2/getpid.2:156 build/C/man2/getpriority.2:247
#: build/C/man2/getresuid.2:86 build/C/man2/getrlimit.2:836
#: build/C/man2/getrusage.2:264 build/C/man2/getsid.2:93
#: build/C/man2/getuid.2:89 build/C/man3/group_member.3:57
#: build/C/man2/iopl.2:106 build/C/man2/ioprio_set.2:363 build/C/man2/ipc.2:57
#: build/C/man2/seteuid.2:145 build/C/man2/setfsgid.2:122
#: build/C/man2/setfsuid.2:140 build/C/man2/setgid.2:101
#: build/C/man2/setpgid.2:330 build/C/man2/setresuid.2:158
#: build/C/man2/setreuid.2:214 build/C/man2/setsid.2:110
#: build/C/man2/setuid.2:163 build/C/man7/sysvipc.7:101
#: build/C/man3/ulimit.3:96 build/C/man2/seccomp.2:1148
#: build/C/man7/cgroups.7:1913 build/C/man2/pidfd_getfd.2:152
#: build/C/man2/pidfd_open.2:263 build/C/man2/pidfd_send_signal.2:248
#: build/C/man3/posix_spawn.3:808
#, no-wrap
msgid "SEE ALSO"
msgstr "関連項目"

#. type: Plain text
#: build/C/man2/acct.2:153
msgid "B<acct>(5)"
msgstr "B<acct>(5)"

#. type: SH
#: build/C/man2/acct.2:153 build/C/man5/acct.5:179
#: build/C/man7/capabilities.7:1855 build/C/man2/capget.2:249
#: build/C/man7/cpuset.7:1514 build/C/man7/credentials.7:400
#: build/C/man2/getgid.2:83 build/C/man2/getgroups.2:227
#: build/C/man2/getpid.2:168 build/C/man2/getpriority.2:256
#: build/C/man2/getresuid.2:92 build/C/man2/getrlimit.2:856
#: build/C/man2/getrusage.2:271 build/C/man2/getsid.2:97
#: build/C/man2/getuid.2:94 build/C/man3/group_member.3:62
#: build/C/man2/iopl.2:110 build/C/man2/ioprio_set.2:372 build/C/man2/ipc.2:71
#: build/C/man2/seteuid.2:153 build/C/man2/setfsgid.2:127
#: build/C/man2/setfsuid.2:145 build/C/man2/setgid.2:108
#: build/C/man2/setpgid.2:337 build/C/man2/setresuid.2:168
#: build/C/man2/setreuid.2:224 build/C/man2/setsid.2:118
#: build/C/man2/setuid.2:171 build/C/man7/sysvipc.7:120
#: build/C/man3/ulimit.3:101 build/C/man2/seccomp.2:1183
#: build/C/man7/cgroups.7:1930 build/C/man2/pidfd_getfd.2:157
#: build/C/man2/pidfd_open.2:273 build/C/man2/pidfd_send_signal.2:256
#: build/C/man3/posix_spawn.3:846
#, no-wrap
msgid "COLOPHON"
msgstr "この文書について"

#. type: Plain text
#: build/C/man2/acct.2:161 build/C/man5/acct.5:187
#: build/C/man7/capabilities.7:1863 build/C/man2/capget.2:257
#: build/C/man7/cpuset.7:1522 build/C/man7/credentials.7:408
#: build/C/man2/getgid.2:91 build/C/man2/getgroups.2:235
#: build/C/man2/getpid.2:176 build/C/man2/getpriority.2:264
#: build/C/man2/getresuid.2:100 build/C/man2/getrlimit.2:864
#: build/C/man2/getrusage.2:279 build/C/man2/getsid.2:105
#: build/C/man2/getuid.2:102 build/C/man3/group_member.3:70
#: build/C/man2/iopl.2:118 build/C/man2/ioprio_set.2:380 build/C/man2/ipc.2:79
#: build/C/man2/seteuid.2:161 build/C/man2/setfsgid.2:135
#: build/C/man2/setfsuid.2:153 build/C/man2/setgid.2:116
#: build/C/man2/setpgid.2:345 build/C/man2/setresuid.2:176
#: build/C/man2/setreuid.2:232 build/C/man2/setsid.2:126
#: build/C/man2/setuid.2:179 build/C/man7/sysvipc.7:128
#: build/C/man3/ulimit.3:109 build/C/man2/seccomp.2:1191
#: build/C/man7/cgroups.7:1938 build/C/man2/pidfd_getfd.2:165
#: build/C/man2/pidfd_open.2:281 build/C/man2/pidfd_send_signal.2:264
#: build/C/man3/posix_spawn.3:854
msgid ""
"This page is part of release 5.10 of the Linux I<man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at \\%https://www.kernel.org/doc/man-"
"pages/."
msgstr "この man ページは Linux I<man-pages> プロジェクトのリリース 5.10 の一部である。プロジェクトの説明とバグ報告に関する情報は \\%https://www.kernel.org/doc/man-pages/ に書かれている。"

#. type: TH
#: build/C/man5/acct.5:25 build/C/man2/getpriority.2:45
#: build/C/man2/getresuid.2:28 build/C/man2/getsid.2:27
#: build/C/man2/seteuid.2:29 build/C/man2/setpgid.2:48
#: build/C/man2/setresuid.2:27 build/C/man2/setreuid.2:46
#: build/C/man2/setsid.2:31 build/C/man3/ulimit.3:27
#, no-wrap
msgid "2017-09-15"
msgstr "2017-09-15"

#. type: Plain text
#: build/C/man5/acct.5:28
msgid "acct - process accounting file"
msgstr "acct - プロセスアカウンティングファイル"

#. type: Plain text
#: build/C/man5/acct.5:30
msgid "B<#include E<lt>sys/acct.hE<gt>>"
msgstr "B<#include E<lt>sys/acct.hE<gt>>"

#. type: Plain text
#: build/C/man5/acct.5:36
msgid ""
"If the kernel is built with the process accounting option enabled "
"(B<CONFIG_BSD_PROCESS_ACCT>), then calling B<acct>(2)  starts process "
"accounting, for example:"
msgstr ""
"カーネルがプロセスアカウンティングのオプション (B<CONFIG_BSD_PROCESS_ACCT>)  "
"を有効にして作成されていると、以下のように B<acct>(2)  を呼び出すとプロセスア"
"カウンティングが開始される。"

#. type: Plain text
#: build/C/man5/acct.5:39
msgid "acct(\"/var/log/pacct\");"
msgstr "acct(\"/var/log/pacct\");"

#. type: Plain text
#: build/C/man5/acct.5:47
msgid ""
"When process accounting is enabled, the kernel writes a record to the "
"accounting file as each process on the system terminates.  This record "
"contains information about the terminated process, and is defined in "
"I<E<lt>sys/acct.hE<gt>> as follows:"
msgstr ""
"プロセスアカウンティングが有効になっていると、カーネルは システム上の各プロセ"
"スが終了するたびにアカウンティングファイルに レコードを書き込む。 このレコー"
"ドは、終了したプロセスに関する情報を保持するもので、 I<E<lt>sys/acct.hE<gt>> "
"で以下のように定義されている。"

#. type: Plain text
#: build/C/man5/acct.5:51
#, no-wrap
msgid "#define ACCT_COMM 16\n"
msgstr "#define ACCT_COMM 16\n"

#. type: Plain text
#: build/C/man5/acct.5:53
#, no-wrap
msgid "typedef u_int16_t comp_t;\n"
msgstr "typedef u_int16_t comp_t;\n"

#. type: Plain text
#: build/C/man5/acct.5:77
#, no-wrap
msgid ""
"struct acct {\n"
"    char ac_flag;           /* Accounting flags */\n"
"    u_int16_t ac_uid;       /* Accounting user ID */\n"
"    u_int16_t ac_gid;       /* Accounting group ID */\n"
"    u_int16_t ac_tty;       /* Controlling terminal */\n"
"    u_int32_t ac_btime;     /* Process creation time\n"
"                               (seconds since the Epoch) */\n"
"    comp_t    ac_utime;     /* User CPU time */\n"
"    comp_t    ac_stime;     /* System CPU time */\n"
"    comp_t    ac_etime;     /* Elapsed time */\n"
"    comp_t    ac_mem;       /* Average memory usage (kB) */\n"
"    comp_t    ac_io;        /* Characters transferred (unused) */\n"
"    comp_t    ac_rw;        /* Blocks read or written (unused) */\n"
"    comp_t    ac_minflt;    /* Minor page faults */\n"
"    comp_t    ac_majflt;    /* Major page faults */\n"
"    comp_t    ac_swaps;     /* Number of swaps (unused) */\n"
"    u_int32_t ac_exitcode;  /* Process termination status\n"
"                               (see wait(2)) */\n"
"    char      ac_comm[ACCT_COMM+1];\n"
"                            /* Command name (basename of last\n"
"                               executed command; null-terminated) */\n"
"    char      ac_pad[I<X>];    /* padding bytes */\n"
"};\n"
msgstr ""
"struct acct {\n"
"    char ac_flag;           /* Accounting flags */\n"
"    u_int16_t ac_uid;       /* Accounting user ID */\n"
"    u_int16_t ac_gid;       /* Accounting group ID */\n"
"    u_int16_t ac_tty;       /* Controlling terminal */\n"
"    u_int32_t ac_btime;     /* Process creation time\n"
"                               (seconds since the Epoch) */\n"
"    comp_t    ac_utime;     /* User CPU time */\n"
"    comp_t    ac_stime;     /* System CPU time */\n"
"    comp_t    ac_etime;     /* Elapsed time */\n"
"    comp_t    ac_mem;       /* Average memory usage (kB) */\n"
"    comp_t    ac_io;        /* Characters transferred (unused) */\n"
"    comp_t    ac_rw;        /* Blocks read or written (unused) */\n"
"    comp_t    ac_minflt;    /* Minor page faults */\n"
"    comp_t    ac_majflt;    /* Major page faults */\n"
"    comp_t    ac_swaps;     /* Number of swaps (unused) */\n"
"    u_int32_t ac_exitcode;  /* Process termination status\n"
"                               (see wait(2)) */\n"
"    char      ac_comm[ACCT_COMM+1];\n"
"                            /* Command name (basename of last\n"
"                               executed command; null-terminated) */\n"
"    char      ac_pad[I<X>];    /* padding bytes */\n"
"};\n"

#. type: Plain text
#: build/C/man5/acct.5:84
#, no-wrap
msgid ""
"enum {          /* Bits that may be set in ac_flag field */\n"
"    AFORK = 0x01,           /* Has executed fork, but no exec */\n"
"    ASU   = 0x02,           /* Used superuser privileges */\n"
"    ACORE = 0x08,           /* Dumped core */\n"
"    AXSIG = 0x10            /* Killed by a signal */\n"
"};\n"
msgstr ""
"enum {          /* Bits that may be set in ac_flag field */\n"
"    AFORK = 0x01,           /* Has executed fork, but no exec */\n"
"    ASU   = 0x02,           /* Used superuser privileges */\n"
"    ACORE = 0x08,           /* Dumped core */\n"
"    AXSIG = 0x10            /* Killed by a signal */\n"
"};\n"

#. type: Plain text
#: build/C/man5/acct.5:94
msgid ""
"The I<comp_t> data type is a floating-point value consisting of a 3-bit, "
"base-8 exponent, and a 13-bit mantissa.  A value, I<c>, of this type can be "
"converted to a (long) integer as follows:"
msgstr ""
"データ型 I<comp_t> は浮動小数点値で、3 ビット幅の基数が 8 の指数部と 13 ビッ"
"ト幅の仮数部から 構成される。 I<comp_t> 型の値 I<c> は以下のようにして (long "
"型の) 整数に変換できる。"

#. type: Plain text
#: build/C/man5/acct.5:97
#, no-wrap
msgid "    v = (c & 0x1fff) E<lt>E<lt> (((c E<gt>E<gt> 13) & 0x7) * 3);\n"
msgstr "    v = (c & 0x1fff) E<lt>E<lt> (((c E<gt>E<gt> 13) & 0x7) * 3);\n"

#. type: Plain text
#: build/C/man5/acct.5:107
msgid ""
"The I<ac_utime>, I<ac_stime>, and I<ac_etime> fields measure time in \"clock "
"ticks\"; divide these values by I<sysconf(_SC_CLK_TCK)> to convert them to "
"seconds."
msgstr ""
"フィールド I<ac_utime>, I<ac_stime>, I<ac_etime> は \"clock ticks\" 単位で計"
"測した時間である。 これらの値を I<sysconf(_SC_CLK_TCK)> で割ると、秒に変換で"
"きる。"

#. type: SS
#: build/C/man5/acct.5:107
#, no-wrap
msgid "Version 3 accounting file format"
msgstr "バージョン 3 のアカウンティングファイルのフォーマット"

#. type: Plain text
#: build/C/man5/acct.5:122
msgid ""
"Since kernel 2.6.8, an optional alternative version of the accounting file "
"can be produced if the B<CONFIG_BSD_PROCESS_ACCT_V3> option is set when "
"building the kernel.  With this option is set, the records written to the "
"accounting file contain additional fields, and the width of I<c_uid> and "
"I<ac_gid> fields is widened from 16 to 32 bits (in line with the increased "
"size of UID and GIDs in Linux 2.4 and later).  The records are defined as "
"follows:"
msgstr ""
"カーネル 2.6.8 以降では、 別のバージョンのアカウンティングファイルを生成する"
"ことができ、 これを使うにはカーネル構築時に B<CONFIG_BSD_PROCESS_ACCT_V3> オ"
"プションが有効になっている必要がある。 このオプションが設定されると、アカウン"
"ティングファイルに書き込まれる レコードにフィールドが追加される。 また、"
"フィールド I<c_uid> と I<ac_gid> の幅が 16 ビットから 32 ビットに拡張される "
"(これは Linux 2.4 以降で UID と GID のサイズが増えているのに 対応したものであ"
"る)。 このレコードは以下のように定義されている。"

#. type: Plain text
#: build/C/man5/acct.5:147
#, no-wrap
msgid ""
"struct acct_v3 {\n"
"    char      ac_flag;      /* Flags */\n"
"    char      ac_version;   /* Always set to ACCT_VERSION (3) */\n"
"    u_int16_t ac_tty;       /* Controlling terminal */\n"
"    u_int32_t ac_exitcode;  /* Process termination status */\n"
"    u_int32_t ac_uid;       /* Real user ID */\n"
"    u_int32_t ac_gid;       /* Real group ID */\n"
"    u_int32_t ac_pid;       /* Process ID */\n"
"    u_int32_t ac_ppid;      /* Parent process ID */\n"
"    u_int32_t ac_btime;     /* Process creation time */\n"
"    float     ac_etime;     /* Elapsed time */\n"
"    comp_t    ac_utime;     /* User CPU time */\n"
"    comp_t    ac_stime;     /* System time */\n"
"    comp_t    ac_mem;       /* Average memory usage (kB) */\n"
"    comp_t    ac_io;        /* Characters transferred (unused) */\n"
"    comp_t    ac_rw;        /* Blocks read or written\n"
"                               (unused) */\n"
"    comp_t    ac_minflt;    /* Minor page faults */\n"
"    comp_t    ac_majflt;    /* Major page faults */\n"
"    comp_t    ac_swaps;     /* Number of swaps (unused) */\n"
"    char      ac_comm[ACCT_COMM]; /* Command name */\n"
"};\n"
msgstr ""
"struct acct_v3 {\n"
"    char      ac_flag;      /* Flags */\n"
"    char      ac_version;   /* Always set to ACCT_VERSION (3) */\n"
"    u_int16_t ac_tty;       /* Controlling terminal */\n"
"    u_int32_t ac_exitcode;  /* Process termination status */\n"
"    u_int32_t ac_uid;       /* Real user ID */\n"
"    u_int32_t ac_gid;       /* Real group ID */\n"
"    u_int32_t ac_pid;       /* Process ID */\n"
"    u_int32_t ac_ppid;      /* Parent process ID */\n"
"    u_int32_t ac_btime;     /* Process creation time */\n"
"    float     ac_etime;     /* Elapsed time */\n"
"    comp_t    ac_utime;     /* User CPU time */\n"
"    comp_t    ac_stime;     /* System time */\n"
"    comp_t    ac_mem;       /* Average memory usage (kB) */\n"
"    comp_t    ac_io;        /* Characters transferred (unused) */\n"
"    comp_t    ac_rw;        /* Blocks read or written\n"
"                               (unused) */\n"
"    comp_t    ac_minflt;    /* Minor page faults */\n"
"    comp_t    ac_majflt;    /* Major page faults */\n"
"    comp_t    ac_swaps;     /* Number of swaps (unused) */\n"
"    char      ac_comm[ACCT_COMM]; /* Command name */\n"
"};\n"

#. type: SH
#: build/C/man5/acct.5:149 build/C/man7/cpuset.7:1338
#: build/C/man2/getresuid.2:60 build/C/man2/getrlimit.2:552
#: build/C/man2/getsid.2:80 build/C/man2/ioprio_set.2:196
#: build/C/man2/setfsgid.2:66 build/C/man2/setfsuid.2:77
#: build/C/man2/setresuid.2:116 build/C/man2/seccomp.2:800
#: build/C/man2/pidfd_getfd.2:113 build/C/man2/pidfd_open.2:84
#: build/C/man2/pidfd_send_signal.2:129 build/C/man3/posix_spawn.3:532
#, no-wrap
msgid "VERSIONS"
msgstr "バージョン"

#. type: Plain text
#: build/C/man5/acct.5:153
msgid "The I<acct_v3> structure is defined in glibc since version 2.6."
msgstr "I<acct_v3> 構造体はバージョン 2.6 以降の glibc で定義されている。"

#. type: Plain text
#: build/C/man5/acct.5:157
msgid ""
"Process accounting originated on BSD.  Although it is present on most "
"systems, it is not standardized, and the details vary somewhat between "
"systems."
msgstr ""
"プロセスアカウンティングは BSD 由来である。 この機能はほとんどのシステムに存"
"在するが、標準化されておらず、 その詳細はシステムによりいくらか異なる。"

#. type: Plain text
#: build/C/man5/acct.5:160
msgid ""
"Records in the accounting file are ordered by termination time of the "
"process."
msgstr "アカウンティングファイルのレコードは、プロセスの終了時刻の順序となる。"

#. type: Plain text
#: build/C/man5/acct.5:167
msgid ""
"In kernels up to and including 2.6.9, a separate accounting record is "
"written for each thread created using the NPTL threading library; since "
"Linux 2.6.10, a single accounting record is written for the entire process "
"on termination of the last thread in the process."
msgstr ""
"バージョン 2.6.9 以前のカーネルでは、 NPTL スレッドライブラリを使って作成され"
"たスレッドでは スレッド毎に別々のアカウンティングレコードが書き込まれてい"
"た。 Linux 2.6.10 以降では、プロセス内の最後のスレッドが終了すると、 プロセス"
"全体についてのアカウンティングレコードが一つだけ書き込まれる。"

#. type: Plain text
#: build/C/man5/acct.5:174
msgid ""
"The I</proc/sys/kernel/acct> file, described in B<proc>(5), defines settings "
"that control the behavior of process accounting when disk space runs low."
msgstr "I</proc/sys/kernel/acct> ファイル (B<proc>(5)  で説明されている) は、ディスク容量の残りが少なくなった際の プロセスアカウンティングの動作を制御する設定を保持している。"

#. type: Plain text
#: build/C/man5/acct.5:179
msgid "B<lastcomm>(1), B<acct>(2), B<accton>(8), B<sa>(8)"
msgstr "B<lastcomm>(1), B<acct>(2), B<accton>(8), B<sa>(8)"

#. type: TH
#: build/C/man7/capabilities.7:48
#, no-wrap
msgid "CAPABILITIES"
msgstr "CAPABILITIES"

#. type: TH
#: build/C/man7/capabilities.7:48 build/C/man2/iopl.2:33
#: build/C/man7/cgroups.7:26 build/C/man2/pidfd_open.2:25
#, no-wrap
msgid "2020-08-13"
msgstr "2020-08-13"

#. type: Plain text
#: build/C/man7/capabilities.7:51
msgid "capabilities - overview of Linux capabilities"
msgstr "capabilities - Linux のケーパビリティ (capability) の概要"

#. type: Plain text
#: build/C/man7/capabilities.7:63
msgid ""
"For the purpose of performing permission checks, traditional UNIX "
"implementations distinguish two categories of processes: I<privileged> "
"processes (whose effective user ID is 0, referred to as superuser or root), "
"and I<unprivileged> processes (whose effective UID is nonzero).  Privileged "
"processes bypass all kernel permission checks, while unprivileged processes "
"are subject to full permission checking based on the process's credentials "
"(usually: effective UID, effective GID, and supplementary group list)."
msgstr ""
"権限のチェックを行う観点から見ると、伝統的な UNIX の実装では プロセスは二つの"
"カテゴリーに分類できる: I<特権> プロセス (実効ユーザーID が 0 のプロセス。"
"ユーザーID 0 は スーパーユーザーや root と呼ばれる) と I<非特権> プロセス (実"
"効ユーザーID が 0 以外のプロセス) である。 非特権プロセスでは、プロセスの資格"
"情報 (通常は、実効UID 、実効GID と追加のグループリスト) に基づく権限チェック"
"が行われるのに対し、 特権プロセスでは全てのカーネルの権限チェックがバイパスさ"
"れる。"

#. type: Plain text
#: build/C/man7/capabilities.7:70
msgid ""
"Starting with kernel 2.2, Linux divides the privileges traditionally "
"associated with superuser into distinct units, known as I<capabilities>, "
"which can be independently enabled and disabled.  Capabilities are a per-"
"thread attribute."
msgstr ""
"バージョン 2.2 以降の Linux では、 これまでスーパーユーザーに結び付けられてき"
"た権限を、 いくつかのグループに分割している。これらのグループは I<ケーパビリ"
"ティ>(capability)  と呼ばれ、グループ毎に独立に有効、無効を設定できる。 ケー"
"パビリティはスレッド単位の属性である。"

#. type: SS
#: build/C/man7/capabilities.7:70
#, no-wrap
msgid "Capabilities list"
msgstr "ケーパビリティのリスト"

#. type: Plain text
#: build/C/man7/capabilities.7:73
msgid ""
"The following list shows the capabilities implemented on Linux, and the "
"operations or behaviors that each capability permits:"
msgstr ""
"以下のリストは、 Linux で実装されているケーパビリティと 各ケーパビリティが許"
"可する操作と動作をまとめたものである。"

#. type: TP
#: build/C/man7/capabilities.7:73
#, no-wrap
msgid "B<CAP_AUDIT_CONTROL> (since Linux 2.6.11)"
msgstr "B<CAP_AUDIT_CONTROL> (Linux 2.6.11 以降)"

#. type: Plain text
#: build/C/man7/capabilities.7:77
msgid ""
"Enable and disable kernel auditing; change auditing filter rules; retrieve "
"auditing status and filtering rules."
msgstr ""
"カーネル監査 (audit) の有効無効の切り替え、 監査のフィルタルールの変更、 監査"
"の状況やフィルタルールの取得ができる。"

#. type: TP
#: build/C/man7/capabilities.7:77
#, no-wrap
msgid "B<CAP_AUDIT_READ> (since Linux 3.16)"
msgstr "B<CAP_AUDIT_READ> (Linux 3.16 以降)"

#.  commit a29b694aa1739f9d76538e34ae25524f9c549d59
#.  commit 3a101b8de0d39403b2c7e5c23fd0b005668acf48
#. type: Plain text
#: build/C/man7/capabilities.7:82
msgid "Allow reading the audit log via a multicast netlink socket."
msgstr "マルチキャスト netlink ソケット経由で監査ログの読み出しができる。"

#. type: TP
#: build/C/man7/capabilities.7:82
#, no-wrap
msgid "B<CAP_AUDIT_WRITE> (since Linux 2.6.11)"
msgstr "B<CAP_AUDIT_WRITE> (Linux 2.6.11 以降)"

#.  FIXME Add FAN_ENABLE_AUDIT
#. type: Plain text
#: build/C/man7/capabilities.7:86
msgid "Write records to kernel auditing log."
msgstr "カーネル監査のログにレコードを書き込む。"

#. type: TP
#: build/C/man7/capabilities.7:86
#, no-wrap
msgid "B<CAP_BLOCK_SUSPEND> (since Linux 3.5)"
msgstr "B<CAP_BLOCK_SUSPEND> (Linux 3.5 以降)"

#. type: Plain text
#: build/C/man7/capabilities.7:92
msgid ""
"Employ features that can block system suspend (B<epoll>(7)  B<EPOLLWAKEUP>, "
"I</proc/sys/wake_lock>)."
msgstr ""
"システムのサスペンドをブロックできる機能を使用する (B<epoll>(7)  "
"B<EPOLLWAKEUP>, I</proc/sys/wake_lock>)。"

#. type: TP
#: build/C/man7/capabilities.7:92
#, no-wrap
msgid "B<CAP_BPF> (since Linux 5.8)"
msgstr "B<CAP_BPF> (Linux 5.8 以降)"

#. type: Plain text
#: build/C/man7/capabilities.7:98
msgid "Employ privileged BPF operations; see B<bpf>(2)  and B<bpf-helpers>(7)."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:103
msgid ""
"This capability was added in Linux 5.8 to separate out BPF functionality "
"from the overloaded B<CAP_SYS_ADMIN> capability."
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:103
#, no-wrap
msgid "B<CAP_CHECKPOINT_RESTORE> (since Linux 5.9)"
msgstr "B<CAP_CHECKPOINT_RESTORE> (Linux 5.9 以降)"

#. type: IP
#: build/C/man7/capabilities.7:108 build/C/man7/capabilities.7:113
#: build/C/man7/capabilities.7:121 build/C/man7/capabilities.7:144
#: build/C/man7/capabilities.7:147 build/C/man7/capabilities.7:150
#: build/C/man7/capabilities.7:161 build/C/man7/capabilities.7:171
#: build/C/man7/capabilities.7:175 build/C/man7/capabilities.7:177
#: build/C/man7/capabilities.7:179 build/C/man7/capabilities.7:183
#: build/C/man7/capabilities.7:196 build/C/man7/capabilities.7:199
#: build/C/man7/capabilities.7:258 build/C/man7/capabilities.7:260
#: build/C/man7/capabilities.7:262 build/C/man7/capabilities.7:264
#: build/C/man7/capabilities.7:266 build/C/man7/capabilities.7:268
#: build/C/man7/capabilities.7:270 build/C/man7/capabilities.7:272
#: build/C/man7/capabilities.7:274 build/C/man7/capabilities.7:300
#: build/C/man7/capabilities.7:302 build/C/man7/capabilities.7:311
#: build/C/man7/capabilities.7:315 build/C/man7/capabilities.7:330
#: build/C/man7/capabilities.7:332 build/C/man7/capabilities.7:334
#: build/C/man7/capabilities.7:367 build/C/man7/capabilities.7:373
#: build/C/man7/capabilities.7:375 build/C/man7/capabilities.7:390
#: build/C/man7/capabilities.7:401 build/C/man7/capabilities.7:407
#: build/C/man7/capabilities.7:412 build/C/man7/capabilities.7:417
#: build/C/man7/capabilities.7:422 build/C/man7/capabilities.7:427
#: build/C/man7/capabilities.7:433 build/C/man7/capabilities.7:437
#: build/C/man7/capabilities.7:444 build/C/man7/capabilities.7:447
#: build/C/man7/capabilities.7:455 build/C/man7/capabilities.7:457
#: build/C/man7/capabilities.7:466 build/C/man7/capabilities.7:475
#: build/C/man7/capabilities.7:479 build/C/man7/capabilities.7:487
#: build/C/man7/capabilities.7:490 build/C/man7/capabilities.7:497
#: build/C/man7/capabilities.7:502 build/C/man7/capabilities.7:508
#: build/C/man7/capabilities.7:512 build/C/man7/capabilities.7:516
#: build/C/man7/capabilities.7:520 build/C/man7/capabilities.7:524
#: build/C/man7/capabilities.7:531 build/C/man7/capabilities.7:537
#: build/C/man7/capabilities.7:539 build/C/man7/capabilities.7:544
#: build/C/man7/capabilities.7:551 build/C/man7/capabilities.7:553
#: build/C/man7/capabilities.7:570 build/C/man7/capabilities.7:573
#: build/C/man7/capabilities.7:582 build/C/man7/capabilities.7:588
#: build/C/man7/capabilities.7:597 build/C/man7/capabilities.7:602
#: build/C/man7/capabilities.7:608 build/C/man7/capabilities.7:611
#: build/C/man7/capabilities.7:614 build/C/man7/capabilities.7:625
#: build/C/man7/capabilities.7:629 build/C/man7/capabilities.7:646
#: build/C/man7/capabilities.7:649 build/C/man7/capabilities.7:653
#: build/C/man7/capabilities.7:658 build/C/man7/capabilities.7:667
#: build/C/man7/capabilities.7:672 build/C/man7/capabilities.7:675
#: build/C/man7/capabilities.7:680 build/C/man7/capabilities.7:683
#: build/C/man7/capabilities.7:686 build/C/man7/capabilities.7:689
#: build/C/man7/capabilities.7:692 build/C/man7/capabilities.7:697
#: build/C/man7/capabilities.7:699 build/C/man7/capabilities.7:705
#: build/C/man7/capabilities.7:713 build/C/man7/capabilities.7:715
#: build/C/man7/capabilities.7:719 build/C/man7/capabilities.7:721
#: build/C/man7/capabilities.7:724 build/C/man7/capabilities.7:728
#: build/C/man7/capabilities.7:730 build/C/man7/capabilities.7:732
#: build/C/man7/capabilities.7:734 build/C/man7/capabilities.7:743
#: build/C/man7/capabilities.7:750 build/C/man7/capabilities.7:757
#: build/C/man7/capabilities.7:762 build/C/man7/capabilities.7:770
#: build/C/man7/capabilities.7:775 build/C/man7/capabilities.7:800
#: build/C/man7/capabilities.7:807 build/C/man7/capabilities.7:846
#: build/C/man7/capabilities.7:851 build/C/man7/capabilities.7:859
#: build/C/man7/capabilities.7:867 build/C/man7/capabilities.7:885
#: build/C/man7/capabilities.7:1204 build/C/man7/capabilities.7:1210
#: build/C/man7/capabilities.7:1362 build/C/man7/capabilities.7:1370
#: build/C/man7/capabilities.7:1810 build/C/man7/capabilities.7:1817
#: build/C/man2/capget.2:205 build/C/man2/capget.2:207
#: build/C/man7/cpuset.7:540 build/C/man7/cpuset.7:545
#: build/C/man7/cpuset.7:550 build/C/man7/cpuset.7:726
#: build/C/man7/cpuset.7:730 build/C/man7/cpuset.7:927
#: build/C/man7/cpuset.7:930 build/C/man7/cpuset.7:934
#: build/C/man7/cpuset.7:938 build/C/man7/cpuset.7:942
#: build/C/man7/credentials.7:177 build/C/man7/credentials.7:183
#: build/C/man7/credentials.7:195 build/C/man7/credentials.7:217
#: build/C/man7/credentials.7:234 build/C/man7/credentials.7:264
#: build/C/man7/credentials.7:267 build/C/man7/credentials.7:278
#: build/C/man7/credentials.7:281 build/C/man2/seccomp.2:530
#: build/C/man2/seccomp.2:534 build/C/man2/seccomp.2:537
#: build/C/man2/seccomp.2:542 build/C/man2/seccomp.2:546
#: build/C/man2/seccomp.2:687 build/C/man2/seccomp.2:691
#: build/C/man2/seccomp.2:699 build/C/man2/seccomp.2:706
#: build/C/man2/seccomp.2:710 build/C/man2/seccomp.2:839
#: build/C/man2/seccomp.2:842 build/C/man2/seccomp.2:844
#: build/C/man2/seccomp.2:846 build/C/man2/seccomp.2:848
#: build/C/man2/seccomp.2:850 build/C/man2/seccomp.2:852
#: build/C/man2/seccomp.2:854 build/C/man2/seccomp.2:862
#: build/C/man2/seccomp.2:877 build/C/man2/seccomp.2:926
#: build/C/man2/seccomp.2:934 build/C/man2/seccomp.2:940
#: build/C/man7/cgroups.7:944 build/C/man7/cgroups.7:951
#: build/C/man7/cgroups.7:1138 build/C/man7/cgroups.7:1148
#: build/C/man7/cgroups.7:1175 build/C/man7/cgroups.7:1183
#: build/C/man7/cgroups.7:1232 build/C/man7/cgroups.7:1236
#: build/C/man7/cgroups.7:1246 build/C/man7/cgroups.7:1251
#: build/C/man7/cgroups.7:1272 build/C/man7/cgroups.7:1275
#: build/C/man7/cgroups.7:1302 build/C/man7/cgroups.7:1308
#: build/C/man7/cgroups.7:1312 build/C/man7/cgroups.7:1367
#: build/C/man7/cgroups.7:1380 build/C/man7/cgroups.7:1402
#: build/C/man7/cgroups.7:1407 build/C/man7/cgroups.7:1414
#: build/C/man7/cgroups.7:1458 build/C/man7/cgroups.7:1463
#: build/C/man7/cgroups.7:1522 build/C/man7/cgroups.7:1526
#: build/C/man7/cgroups.7:1532 build/C/man7/cgroups.7:1575
#: build/C/man7/cgroups.7:1583 build/C/man7/cgroups.7:1606
#: build/C/man7/cgroups.7:1618 build/C/man7/cgroups.7:1624
#: build/C/man7/cgroups.7:1642 build/C/man7/cgroups.7:1646
#: build/C/man7/cgroups.7:1671 build/C/man7/cgroups.7:1678
#: build/C/man7/cgroups.7:1694 build/C/man7/cgroups.7:1697
#: build/C/man2/pidfd_send_signal.2:63 build/C/man2/pidfd_send_signal.2:66
#: build/C/man2/pidfd_send_signal.2:69 build/C/man2/pidfd_send_signal.2:73
#: build/C/man2/pidfd_send_signal.2:76 build/C/man2/pidfd_send_signal.2:145
#: build/C/man2/pidfd_send_signal.2:149 build/C/man2/pidfd_send_signal.2:153
#: build/C/man3/posix_spawn.3:104 build/C/man3/posix_spawn.3:109
#: build/C/man3/posix_spawn.3:127 build/C/man3/posix_spawn.3:140
#: build/C/man3/posix_spawn.3:191 build/C/man3/posix_spawn.3:199
#: build/C/man3/posix_spawn.3:330 build/C/man3/posix_spawn.3:339
#, no-wrap
msgid "*"
msgstr "*"

#. type: Plain text
#: build/C/man7/capabilities.7:113
msgid "Update I</proc/sys/kernel/ns_last_pid> (see B<pid_namespaces>(7));"
msgstr ""

#.  FIXME There is also some use case relating to
#.  prctl_set_mm_exe_file(); in the 5.9 sources, see
#.  prctl_set_mm_map().
#. type: Plain text
#: build/C/man7/capabilities.7:121
msgid "employ the I<set_tid> feature of B<clone3>(2);"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:125
msgid ""
"read the contents of the symbolic links in I</proc/[pid]/map_files> for "
"other processes."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:132
msgid ""
"This capability was added in Linux 5.9 to separate out checkpoint/restore "
"functionality from the overloaded B<CAP_SYS_ADMIN> capability."
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:132
#, no-wrap
msgid "B<CAP_CHOWN>"
msgstr "B<CAP_CHOWN>"

#. type: Plain text
#: build/C/man7/capabilities.7:136
msgid "Make arbitrary changes to file UIDs and GIDs (see B<chown>(2))."
msgstr "ファイルの UID とGID を任意に変更する (B<chown>(2)  参照)。"

#. type: TP
#: build/C/man7/capabilities.7:136
#, no-wrap
msgid "B<CAP_DAC_OVERRIDE>"
msgstr "B<CAP_DAC_OVERRIDE>"

#. type: Plain text
#: build/C/man7/capabilities.7:140
msgid ""
"Bypass file read, write, and execute permission checks.  (DAC is an "
"abbreviation of \"discretionary access control\".)"
msgstr ""
"ファイルの読み出し、書き込み、実行の権限チェックをバイパスする (DAC は "
"\"discretionary access control (任意のアクセス制御)\" の略である)。"

#. type: TP
#: build/C/man7/capabilities.7:140
#, no-wrap
msgid "B<CAP_DAC_READ_SEARCH>"
msgstr "B<CAP_DAC_READ_SEARCH>"

#. type: Plain text
#: build/C/man7/capabilities.7:147
msgid ""
"Bypass file read permission checks and directory read and execute permission "
"checks;"
msgstr ""
"ファイルの読み出し権限のチェックとディレクトリの読み出しと実行 の権限チェック"
"をバイパスする。"

#. type: Plain text
#: build/C/man7/capabilities.7:150
msgid "invoke B<open_by_handle_at>(2);"
msgstr "B<open_by_handle_at>(2) を起動する。"

#. type: Plain text
#: build/C/man7/capabilities.7:155
msgid ""
"use the B<linkat>(2)  B<AT_EMPTY_PATH> flag to create a link to a file "
"referred to by a file descriptor."
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:157
#, no-wrap
msgid "B<CAP_FOWNER>"
msgstr "B<CAP_FOWNER>"

#. type: Plain text
#: build/C/man7/capabilities.7:171
msgid ""
"Bypass permission checks on operations that normally require the filesystem "
"UID of the process to match the UID of the file (e.g., B<chmod>(2), "
"B<utime>(2)), excluding those operations covered by B<CAP_DAC_OVERRIDE> and "
"B<CAP_DAC_READ_SEARCH>;"
msgstr ""
"通常、プロセスのファイルシステム UID がファイルの UID に一致することが 要求さ"
"れる操作 (例えば B<chmod>(2), B<utime>(2))  における権限チェックをバイパスす"
"る。 但し、 B<CAP_DAC_OVERRIDE> か B<CAP_DAC_READ_SEARCH> によりチェックが行"
"われる操作は除く。"

#. type: Plain text
#: build/C/man7/capabilities.7:175
msgid "set inode flags (see B<ioctl_iflags>(2))  on arbitrary files;"
msgstr "任意のファイルに対して inode フラグを設定する (B<ioctl_iflags>(2) 参照)。"

#. type: Plain text
#: build/C/man7/capabilities.7:177
msgid "set Access Control Lists (ACLs) on arbitrary files;"
msgstr "任意のファイルに対してアクセス制御リスト (ACL) を設定する。"

#. type: Plain text
#: build/C/man7/capabilities.7:179
msgid "ignore directory sticky bit on file deletion;"
msgstr "ファイルの削除の際にディレクトリのスティッキービットを無視する。"

#. type: Plain text
#: build/C/man7/capabilities.7:183
msgid ""
"modify I<user> extended attributes on sticky directory owned by any user;"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:190
msgid ""
"specify B<O_NOATIME> for arbitrary files in B<open>(2)  and B<fcntl>(2)."
msgstr ""
"B<open>(2)  や B<fcntl>(2)  で任意のファイルに対して B<O_NOATIME> を指定す"
"る。"

#. type: TP
#: build/C/man7/capabilities.7:192
#, no-wrap
msgid "B<CAP_FSETID>"
msgstr "B<CAP_FSETID>"

#. type: Plain text
#: build/C/man7/capabilities.7:199
msgid ""
"Don't clear set-user-ID and set-group-ID mode bits when a file is modified;"
msgstr "ファイルが変更されたときに set-user-ID とset-group-ID のモードビットをクリアしない。"

#. type: Plain text
#: build/C/man7/capabilities.7:202
msgid ""
"set the set-group-ID bit for a file whose GID does not match the filesystem "
"or any of the supplementary GIDs of the calling process."
msgstr "呼び出し元プロセスのファイルシステム GID と追加の GID のいずれとも GID が一致しないファイルに対して set-group-ID ビットを設定する。"

#. type: TP
#: build/C/man7/capabilities.7:204
#, no-wrap
msgid "B<CAP_IPC_LOCK>"
msgstr "B<CAP_IPC_LOCK>"

#.  FIXME . As at Linux 3.2, there are some strange uses of this capability
#.  in other places; they probably should be replaced with something else.
#. type: Plain text
#: build/C/man7/capabilities.7:213
msgid "Lock memory (B<mlock>(2), B<mlockall>(2), B<mmap>(2), B<shmctl>(2))."
msgstr ""
"メモリーのロック (B<mlock>(2), B<mlockall>(2), B<mmap>(2), B<shmctl>(2))  を"
"行う。"

#. type: TP
#: build/C/man7/capabilities.7:213
#, no-wrap
msgid "B<CAP_IPC_OWNER>"
msgstr "B<CAP_IPC_OWNER>"

#. type: Plain text
#: build/C/man7/capabilities.7:216
msgid "Bypass permission checks for operations on System V IPC objects."
msgstr ""
"System V IPC オブジェクトに対する操作に関して権限チェックをバイパスする。"

#. type: TP
#: build/C/man7/capabilities.7:216
#, no-wrap
msgid "B<CAP_KILL>"
msgstr "B<CAP_KILL>"

#.  FIXME . CAP_KILL also has an effect for threads + setting child
#.        termination signal to other than SIGCHLD: without this
#.        capability, the termination signal reverts to SIGCHLD
#.        if the child does an exec().  What is the rationale
#.        for this?
#. type: Plain text
#: build/C/man7/capabilities.7:229
msgid ""
"Bypass permission checks for sending signals (see B<kill>(2)).  This "
"includes use of the B<ioctl>(2)  B<KDSIGACCEPT> operation."
msgstr ""
"シグナルを送信する際に権限チェックをバイパスする (B<kill>(2)  参照)。これに"
"は B<ioctl>(2)  の B<KDSIGACCEPT> 操作の使用も含まれる。"

#. type: TP
#: build/C/man7/capabilities.7:229
#, no-wrap
msgid "B<CAP_LEASE> (since Linux 2.4)"
msgstr "B<CAP_LEASE> (Linux 2.4 以降)"

#. type: Plain text
#: build/C/man7/capabilities.7:233
msgid "Establish leases on arbitrary files (see B<fcntl>(2))."
msgstr "任意のファイルに対して ファイルリースを設定する (B<fcntl>(2)  参照)。"

#. type: TP
#: build/C/man7/capabilities.7:233
#, no-wrap
msgid "B<CAP_LINUX_IMMUTABLE>"
msgstr "B<CAP_LINUX_IMMUTABLE>"

#. type: Plain text
#: build/C/man7/capabilities.7:241
msgid ""
"Set the B<FS_APPEND_FL> and B<FS_IMMUTABLE_FL> inode flags (see "
"B<ioctl_iflags>(2))."
msgstr "inode フラグ B<FS_APPEND_FL> と B<FS_IMMUTABLE_FL> を設定する (B<ioctl_iflags>(2) 参照)。"

#. type: TP
#: build/C/man7/capabilities.7:241
#, no-wrap
msgid "B<CAP_MAC_ADMIN> (since Linux 2.6.25)"
msgstr "B<CAP_MAC_ADMIN> (Linux 2.6.25 以降)"

#. type: Plain text
#: build/C/man7/capabilities.7:245
msgid ""
"Allow MAC configuration or state changes.  Implemented for the Smack Linux "
"Security Module (LSM)."
msgstr "MAC の設定や状態を変更する。 Smack Linux Security Module (LSM) 用に実装されている。"

#. type: TP
#: build/C/man7/capabilities.7:245
#, no-wrap
msgid "B<CAP_MAC_OVERRIDE> (since Linux 2.6.25)"
msgstr "B<CAP_MAC_OVERRIDE> (Linux 2.6.25 以降)"

#. type: Plain text
#: build/C/man7/capabilities.7:249
msgid ""
"Override Mandatory Access Control (MAC).  Implemented for the Smack LSM."
msgstr "強制アクセス制御 (MAC) を上書きする。 Smack LSM 用に実装されている。"

#. type: TP
#: build/C/man7/capabilities.7:249
#, no-wrap
msgid "B<CAP_MKNOD> (since Linux 2.4)"
msgstr "B<CAP_MKNOD> (Linux 2.4 以降)"

#. type: Plain text
#: build/C/man7/capabilities.7:253
msgid "Create special files using B<mknod>(2)."
msgstr ""
"(Linux 2.4 以降)  B<mknod>(2)  を使用してスペシャルファイルを作成する。"

#. type: TP
#: build/C/man7/capabilities.7:253
#, no-wrap
msgid "B<CAP_NET_ADMIN>"
msgstr "B<CAP_NET_ADMIN>"

#. type: Plain text
#: build/C/man7/capabilities.7:256
msgid "Perform various network-related operations:"
msgstr "各種のネットワーク関係の操作を実行する:"

#. type: Plain text
#: build/C/man7/capabilities.7:260
msgid "interface configuration;"
msgstr "インターフェースの設定"

#. type: Plain text
#: build/C/man7/capabilities.7:262
msgid "administration of IP firewall, masquerading, and accounting;"
msgstr "IP のファイアウォール、マスカレード、アカウンティング"

#. type: Plain text
#: build/C/man7/capabilities.7:264
msgid "modify routing tables;"
msgstr "ルーティングテーブルの変更"

#. type: Plain text
#: build/C/man7/capabilities.7:266
msgid "bind to any address for transparent proxying;"
msgstr "透過的プロキシでの任意のアドレスの割り当て (bind)"

#. type: Plain text
#: build/C/man7/capabilities.7:268
msgid "set type-of-service (TOS);"
msgstr "サービス種別 (type-of-service; TOS) のセット"

#. type: Plain text
#: build/C/man7/capabilities.7:270
msgid "clear driver statistics;"
msgstr "ドライバの統計情報のクリア"

#. type: Plain text
#: build/C/man7/capabilities.7:272
msgid "set promiscuous mode;"
msgstr "promiscuous モードをセットする"

#. type: Plain text
#: build/C/man7/capabilities.7:274
msgid "enabling multicasting;"
msgstr "マルチキャストを有効にする"

#. type: Plain text
#: build/C/man7/capabilities.7:285
msgid ""
"use B<setsockopt>(2)  to set the following socket options: B<SO_DEBUG>, "
"B<SO_MARK>, B<SO_PRIORITY> (for a priority outside the range 0 to 6), "
"B<SO_RCVBUFFORCE>, and B<SO_SNDBUFFORCE>."
msgstr ""
"B<setsockopt>(2) を使って以下のソケットオプションを設定する:\n"
"B<SO_DEBUG>, B<SO_MARK>, \n"
"B<SO_PRIORITY> (優先度を 0 から 6 以外に設定する場合),\n"
"B<SO_RCVBUFFORCE>, and B<SO_SNDBUFFORCE>"

#. type: TP
#: build/C/man7/capabilities.7:287
#, no-wrap
msgid "B<CAP_NET_BIND_SERVICE>"
msgstr "B<CAP_NET_BIND_SERVICE>"

#. type: Plain text
#: build/C/man7/capabilities.7:291
msgid ""
"Bind a socket to Internet domain privileged ports (port numbers less than "
"1024)."
msgstr ""
"インターネットドメインの特権ポート (ポート番号が 1024 番未満)  をバインドでき"
"る。"

#. type: TP
#: build/C/man7/capabilities.7:291
#, no-wrap
msgid "B<CAP_NET_BROADCAST>"
msgstr "B<CAP_NET_BROADCAST>"

#.  FIXME Since Linux 4.2, there are use cases for netlink sockets
#.     commit 59324cf35aba5336b611074028777838a963d03b
#. type: Plain text
#: build/C/man7/capabilities.7:296
msgid "(Unused)  Make socket broadcasts, and listen to multicasts."
msgstr ""
"(未使用) ソケットのブロードキャストと、マルチキャストの待ち受けを行う。"

#. type: TP
#: build/C/man7/capabilities.7:296
#, no-wrap
msgid "B<CAP_NET_RAW>"
msgstr "B<CAP_NET_RAW>"

#. type: Plain text
#: build/C/man7/capabilities.7:302
msgid "Use RAW and PACKET sockets;"
msgstr "RAW ソケットと PACKET ソケットを使用する。"

#. type: Plain text
#: build/C/man7/capabilities.7:304
msgid "bind to any address for transparent proxying."
msgstr "透過的プロキシでの任意のアドレスの割り当て (bind)"

#. type: TP
#: build/C/man7/capabilities.7:307
#, no-wrap
msgid "B<CAP_PERFMON> (since Linux 5.8)"
msgstr "B<CAP_PERFMON> (Linux 5.8 以降)"

#. type: Plain text
#: build/C/man7/capabilities.7:310
msgid "Employ various performance-monitoring mechanisms, including:"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:315
msgid "call B<perf_event_open>(2);"
msgstr "B<perf_event_open>(2) を呼び出す。"

#. type: Plain text
#: build/C/man7/capabilities.7:317
msgid "employ various BPF operations that have performance implications."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:326
msgid ""
"This capability was added in Linux 5.8 to separate out performance "
"monitoring functionality from the overloaded B<CAP_SYS_ADMIN> capability.  "
"See also the kernel source file I<Documentation/admin-guide/perf-security."
"rst>."
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:326
#, no-wrap
msgid "B<CAP_SETGID>"
msgstr "B<CAP_SETGID>"

#. type: Plain text
#: build/C/man7/capabilities.7:332
msgid ""
"Make arbitrary manipulations of process GIDs and supplementary GID list;"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:334
msgid "forge GID when passing socket credentials via UNIX domain sockets;"
msgstr "UNIX ドメインソケットでソケットの資格情報 (credential) を渡す際に偽の GID を渡す。"

#. type: Plain text
#: build/C/man7/capabilities.7:337
#, fuzzy
#| msgid ""
#| "For a discussion of the interaction of capabilities and user namespaces, "
#| "see B<user_namespaces>(7)."
msgid ""
"write a group ID mapping in a user namespace (see B<user_namespaces>(7))."
msgstr ""
"ケーパリビティとユーザー名前空間の相互の影響に関する議論は "
"B<user_namespaces>(7) を参照。"

#. type: TP
#: build/C/man7/capabilities.7:339
#, no-wrap
msgid "B<CAP_SETFCAP> (since Linux 2.6.24)"
msgstr "B<CAP_SETFCAP> (Linux 2.6.24 以降)"

#. type: Plain text
#: build/C/man7/capabilities.7:342
msgid "Set arbitrary capabilities on a file."
msgstr "ファイルに任意のケーパビリティを設定する。"

#. type: TP
#: build/C/man7/capabilities.7:342
#, no-wrap
msgid "B<CAP_SETPCAP>"
msgstr "B<CAP_SETPCAP>"

#. type: Plain text
#: build/C/man7/capabilities.7:353
msgid ""
"If file capabilities are supported (i.e., since Linux 2.6.24): add any "
"capability from the calling thread's bounding set to its inheritable set; "
"drop capabilities from the bounding set (via B<prctl>(2)  "
"B<PR_CAPBSET_DROP>); make changes to the I<securebits> flags."
msgstr "ファイルケーパビリティがサポートされている場合 (すなわち Linux 2.6.24 以降): 呼び出し元スレッドのバウンディングセットの任意のケーパビリティを 自身の継承可能ケーパビリティセットに追加できる。 (B<prctl>(2)  B<PR_CAPBSET_DROP> を使って)  バウンディングセットからケーパビリティを削除できる。 I<securebits> フラグを変更できる。"

#. type: Plain text
#: build/C/man7/capabilities.7:363
msgid ""
"If file capabilities are not supported (i.e., kernels before Linux 2.6.24): "
"grant or remove any capability in the caller's permitted capability set to "
"or from any other process.  (This property of B<CAP_SETPCAP> is not "
"available when the kernel is configured to support file capabilities, since "
"B<CAP_SETPCAP> has entirely different semantics for such kernels.)"
msgstr "ファイルケーパビリティがサポートされていない場合 (すなわち Linux 2.6.24 以降): 呼び出し元が許可されているケーパビリティセットに含まれる任意のケーパビリティを、 他のプロセスに付与したり、削除したりできる。 (カーネルがファイルケーパビリティをサポートしている場合、 B<CAP_SETPCAP> はこの役割を持たない。 なぜなら、ファイルケーパビリティをサポートしているカーネルでは B<CAP_SETPCAP> は全く別の意味を持つからである。)"

#. type: TP
#: build/C/man7/capabilities.7:363
#, no-wrap
msgid "B<CAP_SETUID>"
msgstr "B<CAP_SETUID>"

#. type: Plain text
#: build/C/man7/capabilities.7:373
msgid ""
"Make arbitrary manipulations of process UIDs (B<setuid>(2), B<setreuid>(2), "
"B<setresuid>(2), B<setfsuid>(2));"
msgstr "Make arbitrary manipulations of process UIDs (B<setuid>(2), B<setreuid>(2), B<setresuid>(2), B<setfsuid>(2));"

#. type: Plain text
#: build/C/man7/capabilities.7:375
#, fuzzy
#| msgid "forge PID when passing socket credentials via UNIX domain sockets;"
msgid "forge UID when passing socket credentials via UNIX domain sockets;"
msgstr ""
"UNIX ドメインソケットでソケットの資格情報 (credential) を渡す際に偽の UID を"
"渡す。"

#. type: Plain text
#: build/C/man7/capabilities.7:378
#, fuzzy
#| msgid ""
#| "For a discussion of the interaction of capabilities and user namespaces, "
#| "see B<user_namespaces>(7)."
msgid ""
"write a user ID mapping in a user namespace (see B<user_namespaces>(7))."
msgstr ""
"ケーパリビティとユーザー名前空間の相互の影響に関する議論は "
"B<user_namespaces>(7) を参照。"

#. type: TP
#: build/C/man7/capabilities.7:381
#, no-wrap
msgid "B<CAP_SYS_ADMIN>"
msgstr "B<CAP_SYS_ADMIN>"

#. type: Plain text
#: build/C/man7/capabilities.7:387
msgid ""
"I<Note>: this capability is overloaded; see I<Notes to kernel developers>, "
"below."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:401
msgid ""
"Perform a range of system administration operations including: "
"B<quotactl>(2), B<mount>(2), B<umount>(2), B<pivot_root>(2), B<swapon>(2), "
"B<swapoff>(2), B<sethostname>(2), and B<setdomainname>(2);"
msgstr "Perform a range of system administration operations including: B<quotactl>(2), B<mount>(2), B<umount>(2), B<pivot_root>(2), B<swapon>(2), B<swapoff>(2), B<sethostname>(2), and B<setdomainname>(2);"

#. type: Plain text
#: build/C/man7/capabilities.7:407
msgid ""
"perform privileged B<syslog>(2)  operations (since Linux 2.6.37, "
"B<CAP_SYSLOG> should be used to permit such operations);"
msgstr ""
"特権が必要な B<syslog>(2) の操作を実行する\n"
"(Linux 2.6.37 以降では、このような操作を許可するには\n"
"B<CAP_SYSLOG> を使うべきである)"

#. type: Plain text
#: build/C/man7/capabilities.7:412
msgid "perform B<VM86_REQUEST_IRQ> B<vm86>(2)  command;"
msgstr "B<VM86_REQUEST_IRQ> B<vm86>(2) コマンドを実行する。"

#. type: Plain text
#: build/C/man7/capabilities.7:417
msgid ""
"access the same checkpoint/restore functionality that is governed by "
"B<CAP_CHECKPOINT_RESTORE> (but the latter, weaker capability is preferred "
"for accessing that functionality)."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:422
msgid ""
"perform the same BPF operations as are governed by B<CAP_BPF> (but the "
"latter, weaker capability is preferred for accessing that functionality)."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:427
msgid ""
"employ the same performance monitoring mechanisms as are governed by "
"B<CAP_PERFMON> (but the latter, weaker capability is preferred for accessing "
"that functionality)."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:433
msgid ""
"perform B<IPC_SET> and B<IPC_RMID> operations on arbitrary System V IPC "
"objects;"
msgstr ""
"任意の System V IPC オブジェクトに対する B<IPC_SET> と B<IPC_RMID> 操作を実行"
"する。"

#. type: Plain text
#: build/C/man7/capabilities.7:437 build/C/man7/capabilities.7:728
msgid "override B<RLIMIT_NPROC> resource limit;"
msgstr "B<RLIMIT_NPROC> リソース制限を上書きする。"

#. type: Plain text
#: build/C/man7/capabilities.7:444
msgid ""
"perform operations on I<trusted> and I<security> extended attributes (see "
"B<xattr>(7));"
msgstr "拡張属性 I<trusted> と I<security> に対する操作を実行する (B<xattr>(7) 参照)。"

#. type: Plain text
#: build/C/man7/capabilities.7:447
msgid "use B<lookup_dcookie>(2);"
msgstr "B<lookup_dcookie>(2)  を呼び出す。"

#. type: Plain text
#: build/C/man7/capabilities.7:455
msgid ""
"use B<ioprio_set>(2)  to assign B<IOPRIO_CLASS_RT> and (before Linux "
"2.6.25)  B<IOPRIO_CLASS_IDLE> I/O scheduling classes;"
msgstr ""
"B<ioprio_set>(2)  を使って I/O スケジューリングクラス B<IOPRIO_CLASS_RT>, "
"B<IOPRIO_CLASS_IDLE> を割り当てる (B<IOPRIO_CLASS_IDLE> は Linux 2.6.25 より"
"前のバージョンのみ)。"

#. type: Plain text
#: build/C/man7/capabilities.7:457
msgid "forge PID when passing socket credentials via UNIX domain sockets;"
msgstr ""
"UNIX ドメインソケットでソケットの資格情報 (credential) を渡す際に偽の UID を"
"渡す。"

#. type: Plain text
#: build/C/man7/capabilities.7:466
msgid ""
"exceed I</proc/sys/fs/file-max>, the system-wide limit on the number of open "
"files, in system calls that open files (e.g., B<accept>(2), B<execve>(2), "
"B<open>(2), B<pipe>(2));"
msgstr ""
"ファイルをオープンするシステムコール (例えば B<accept>(2), B<execve>(2), "
"B<open>(2), B<pipe>(2))  でシステム全体でオープンできるファイル数の上限 I</"
"proc/sys/fs/file-max> を超過する。"

#. type: Plain text
#: build/C/man7/capabilities.7:475
msgid ""
"employ B<CLONE_*> flags that create new namespaces with B<clone>(2)  and "
"B<unshare>(2)  (but, since Linux 3.8, creating user namespaces does not "
"require any capability);"
msgstr ""
"B<clone>(2) と B<unshare>(2) で新しい名前空間を作成する B<CLONE_*> フラグを利"
"用する (ただし、 Linux 3.8 以降では、ユーザー名前空間の作成にどのケーパビリ"
"ティも必要としない)。"

#. type: Plain text
#: build/C/man7/capabilities.7:479
msgid "access privileged I<perf> event information;"
msgstr "特権が必要な I<perf> イベントの情報にアクセスする。"

#. type: Plain text
#: build/C/man7/capabilities.7:487
msgid ""
"call B<setns>(2)  (requires B<CAP_SYS_ADMIN> in the I<target> namespace);"
msgstr ""
"B<setns>(2) を呼び出す (I<target> 名前空間での B<CAP_SYS_ADMIN> が必要)。"

#. type: Plain text
#: build/C/man7/capabilities.7:490
msgid "call B<fanotify_init>(2);"
msgstr "B<fanotify_init>(2) を呼び出す。"

#. type: Plain text
#: build/C/man7/capabilities.7:497
#, fuzzy
#| msgid ""
#| "perform B<KEYCTL_CHOWN> and B<KEYCTL_SETPERM> B<keyctl>(2)  operations;"
msgid ""
"perform privileged B<KEYCTL_CHOWN> and B<KEYCTL_SETPERM> B<keyctl>(2)  "
"operations;"
msgstr "B<keyctl>(2)  の B<KEYCTL_CHOWN> と B<KEYCTL_SETPERM> 操作を実行する。"

#. type: Plain text
#: build/C/man7/capabilities.7:502
msgid "perform B<madvise>(2)  B<MADV_HWPOISON> operation;"
msgstr "B<madvise>(2)  の B<MADV_HWPOISON> 操作を実行する。"

#. type: Plain text
#: build/C/man7/capabilities.7:508
msgid ""
"employ the B<TIOCSTI> B<ioctl>(2)  to insert characters into the input queue "
"of a terminal other than the caller's controlling terminal;"
msgstr ""
"B<TIOCSTI> B<ioctl>(2) を使って、\n"
"呼び出し元の制御端末以外の端末の入力キューに文字を挿入する。"

#. type: Plain text
#: build/C/man7/capabilities.7:512
msgid "employ the obsolete B<nfsservctl>(2)  system call;"
msgstr "廃止予定の B<nfsservctl>(2) システムコールを使用する。"

#. type: Plain text
#: build/C/man7/capabilities.7:516
msgid "employ the obsolete B<bdflush>(2)  system call;"
msgstr "廃止予定の B<bdflush>(2) システムコールを使用する。"

#. type: Plain text
#: build/C/man7/capabilities.7:520
msgid "perform various privileged block-device B<ioctl>(2)  operations;"
msgstr ""
"特権が必要なブロックデバイスに対する各種の B<ioctl>(2) 操作を\n"
"実行する。"

#. type: Plain text
#: build/C/man7/capabilities.7:524
msgid "perform various privileged filesystem B<ioctl>(2)  operations;"
msgstr ""
"特権が必要なファイルシステムに対する各種の B<ioctl>(2) 操作を\n"
"実行する。"

#. type: Plain text
#: build/C/man7/capabilities.7:531
msgid ""
"perform privileged B<ioctl>(2)  operations on the I</dev/random> device (see "
"B<random>(4));"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:537
msgid ""
"install a B<seccomp>(2)  filter without first having to set the "
"I<no_new_privs> thread attribute;"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:539
msgid "modify allow/deny rules for device control groups;"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:544
msgid ""
"employ the B<ptrace>(2)  B<PTRACE_SECCOMP_GET_FILTER> operation to dump "
"tracee's seccomp filters;"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:551
msgid ""
"employ the B<ptrace>(2)  B<PTRACE_SETOPTIONS> operation to suspend the "
"tracee's seccomp protections (i.e., the B<PTRACE_O_SUSPEND_SECCOMP> flag);"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:553
msgid "perform administrative operations on many device drivers;"
msgstr "多くのデバイスドライバに対する管理命令を実行する。"

#. type: Plain text
#: build/C/man7/capabilities.7:558
msgid ""
"modify autogroup nice values by writing to I</proc/[pid]/autogroup> (see "
"B<sched>(7))."
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:560
#, no-wrap
msgid "B<CAP_SYS_BOOT>"
msgstr "B<CAP_SYS_BOOT>"

#. type: Plain text
#: build/C/man7/capabilities.7:566
msgid "Use B<reboot>(2)  and B<kexec_load>(2)."
msgstr "B<reboot>(2)  と B<kexec_load>(2)  を呼び出す。"

#. type: TP
#: build/C/man7/capabilities.7:566
#, no-wrap
msgid "B<CAP_SYS_CHROOT>"
msgstr "B<CAP_SYS_CHROOT>"

#. type: Plain text
#: build/C/man7/capabilities.7:573
msgid "Use B<chroot>(2);"
msgstr "B<chroot>(2) を使用する。"

#. type: Plain text
#: build/C/man7/capabilities.7:576
msgid "change mount namespaces using B<setns>(2)."
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:578
#, no-wrap
msgid "B<CAP_SYS_MODULE>"
msgstr "B<CAP_SYS_MODULE>"

#. type: Plain text
#: build/C/man7/capabilities.7:588
msgid ""
"Load and unload kernel modules (see B<init_module>(2)  and "
"B<delete_module>(2));"
msgstr "カーネルモジュールのロード、アンロードを行う (B<init_module>(2)  と B<delete_module>(2)  を参照のこと)。"

#. type: Plain text
#: build/C/man7/capabilities.7:591
msgid ""
"in kernels before 2.6.25: drop capabilities from the system-wide capability "
"bounding set."
msgstr "バージョン 2.6.25 より前のカーネルで、 システム全体のケーパビリティバウンディングセット (capability bounding set)  からケーパビリティを外す。"

#. type: TP
#: build/C/man7/capabilities.7:593
#, no-wrap
msgid "B<CAP_SYS_NICE>"
msgstr "B<CAP_SYS_NICE>"

#. type: Plain text
#: build/C/man7/capabilities.7:602
msgid ""
"Lower the process nice value (B<nice>(2), B<setpriority>(2))  and change the "
"nice value for arbitrary processes;"
msgstr "プロセスの nice 値の引き下げ (B<nice>(2), B<setpriority>(2))  や、任意のプロセスの nice 値の変更を行う。"

#. type: Plain text
#: build/C/man7/capabilities.7:608
msgid ""
"set real-time scheduling policies for calling process, and set scheduling "
"policies and priorities for arbitrary processes (B<sched_setscheduler>(2), "
"B<sched_setparam>(2), B<sched_setattr>(2));"
msgstr "呼び出し元プロセスに対するリアルタイムスケジューリングポリシーと、 任意のプロセスに対するスケジューリングポリシーと優先度を設定する (B<sched_setscheduler>(2), B<sched_setparam>(2), B<sched_setattr>(2))。"

#. type: Plain text
#: build/C/man7/capabilities.7:611
msgid "set CPU affinity for arbitrary processes (B<sched_setaffinity>(2));"
msgstr ""
"任意のプロセスに対する CPU affinity を設定できる (B<sched_setaffinity>(2))。"

#. type: Plain text
#: build/C/man7/capabilities.7:614
msgid ""
"set I/O scheduling class and priority for arbitrary processes "
"(B<ioprio_set>(2));"
msgstr ""
"任意のプロセスに対して I/O スケジューリングクラスと優先度を設定できる "
"(B<ioprio_set>(2))。"

#.  FIXME CAP_SYS_NICE also has the following effect for
#.  migrate_pages(2):
#.      do_migrate_pages(mm, &old, &new,
#.          capable(CAP_SYS_NICE) ? MPOL_MF_MOVE_ALL : MPOL_MF_MOVE);
#.  Document this.
#. type: Plain text
#: build/C/man7/capabilities.7:625
msgid ""
"apply B<migrate_pages>(2)  to arbitrary processes and allow processes to be "
"migrated to arbitrary nodes;"
msgstr ""
"B<migrate_pages>(2)  を任意のプロセスに適用し、プロセスを任意のノードに移動す"
"る。"

#. type: Plain text
#: build/C/man7/capabilities.7:629
msgid "apply B<move_pages>(2)  to arbitrary processes;"
msgstr "B<move_pages>(2)  を任意のプロセスに対して行う。"

#. type: Plain text
#: build/C/man7/capabilities.7:636
msgid ""
"use the B<MPOL_MF_MOVE_ALL> flag with B<mbind>(2)  and B<move_pages>(2)."
msgstr ""
"B<mbind>(2)  と B<move_pages>(2)  で B<MPOL_MF_MOVE_ALL> フラグを使用する。"

#. type: TP
#: build/C/man7/capabilities.7:638
#, no-wrap
msgid "B<CAP_SYS_PACCT>"
msgstr "B<CAP_SYS_PACCT>"

#. type: Plain text
#: build/C/man7/capabilities.7:642
msgid "Use B<acct>(2)."
msgstr "B<acct>(2)  を呼び出す。"

#. type: TP
#: build/C/man7/capabilities.7:642
#, no-wrap
msgid "B<CAP_SYS_PTRACE>"
msgstr "B<CAP_SYS_PTRACE>"

#. type: Plain text
#: build/C/man7/capabilities.7:649
msgid "Trace arbitrary processes using B<ptrace>(2);"
msgstr "B<ptrace>(2)  を使って任意のプロセスをトレースする。"

#. type: Plain text
#: build/C/man7/capabilities.7:653
msgid "apply B<get_robust_list>(2)  to arbitrary processes;"
msgstr "B<get_robust_list>(2)  を任意のプロセスに対して行う。"

#. type: Plain text
#: build/C/man7/capabilities.7:658
msgid ""
"transfer data to or from the memory of arbitrary processes using "
"B<process_vm_readv>(2)  and B<process_vm_writev>(2);"
msgstr ""
"B<process_vm_readv>(2) と B<process_vm_writev>(2) を使って任意のプロセスのメ"
"モリーとの間でデータの送受信を行う。"

#. type: Plain text
#: build/C/man7/capabilities.7:661
msgid "inspect processes using B<kcmp>(2)."
msgstr "B<kcmp>(2) を使ってプロセス内部を調査する。"

#. type: TP
#: build/C/man7/capabilities.7:663
#, no-wrap
msgid "B<CAP_SYS_RAWIO>"
msgstr "B<CAP_SYS_RAWIO>"

#. type: Plain text
#: build/C/man7/capabilities.7:672
msgid "Perform I/O port operations (B<iopl>(2)  and B<ioperm>(2));"
msgstr "I/O ポート操作を実行する (B<iopl>(2)、 B<ioperm>(2))。"

#. type: Plain text
#: build/C/man7/capabilities.7:675
msgid "access I</proc/kcore>;"
msgstr "I</proc/kcore> にアクセスする。"

#. type: Plain text
#: build/C/man7/capabilities.7:680
msgid "employ the B<FIBMAP> B<ioctl>(2)  operation;"
msgstr "B<FIBMAP> B<ioctl>(2) 操作を使用する。"

#. type: Plain text
#: build/C/man7/capabilities.7:683
msgid ""
"open devices for accessing x86 model-specific registers (MSRs, see "
"B<msr>(4));"
msgstr ""
"x86 モデルに固有のレジスター (MSR レジスター群、 B<msr>(4) 参照) にアクセスす"
"るためのデバイスをオープンする。"

#. type: Plain text
#: build/C/man7/capabilities.7:686
msgid "update I</proc/sys/vm/mmap_min_addr>;"
msgstr "I</proc/sys/vm/mmap_min_addr> を更新する。"

#. type: Plain text
#: build/C/man7/capabilities.7:689
msgid ""
"create memory mappings at addresses below the value specified by I</proc/sys/"
"vm/mmap_min_addr>;"
msgstr ""
"I</proc/sys/vm/mmap_min_addr> で指定された値よりも小さなアドレスにメモリー"
"マッピングを作成する。"

#. type: Plain text
#: build/C/man7/capabilities.7:692
msgid "map files in I</proc/bus/pci>;"
msgstr "I</proc/bus/pci> にあるファイルをマップする。"

#. type: Plain text
#: build/C/man7/capabilities.7:697
msgid "open I</dev/mem> and I</dev/kmem>;"
msgstr "I</dev/mem> や I</dev/kmem> をオープンする。"

#. type: Plain text
#: build/C/man7/capabilities.7:699
msgid "perform various SCSI device commands;"
msgstr "各種の SCSI デバイスコマンドを実行する。"

#. type: Plain text
#: build/C/man7/capabilities.7:705
msgid "perform certain operations on B<hpsa>(4)  and B<cciss>(4)  devices;"
msgstr "B<hpsa>(4) デバイスや B<cciss>(4) デバイスの特定の操作を実行する。"

#. type: Plain text
#: build/C/man7/capabilities.7:707
msgid "perform a range of device-specific operations on other devices."
msgstr "他のデバイスに対して各種のデバイス固有命令を実行する。"

#. type: TP
#: build/C/man7/capabilities.7:709
#, no-wrap
msgid "B<CAP_SYS_RESOURCE>"
msgstr "B<CAP_SYS_RESOURCE>"

#. type: Plain text
#: build/C/man7/capabilities.7:715
msgid "Use reserved space on ext2 filesystems;"
msgstr "ext2 ファイルシステム上の予約されている領域を使用する。"

#. type: Plain text
#: build/C/man7/capabilities.7:719
msgid "make B<ioctl>(2)  calls controlling ext3 journaling;"
msgstr "ext3 のジャーナル機能を制御する B<ioctl>(2)  を使用する。"

#. type: Plain text
#: build/C/man7/capabilities.7:721
msgid "override disk quota limits;"
msgstr "ディスク quota の上限を上書きする。"

#. type: Plain text
#: build/C/man7/capabilities.7:724
msgid "increase resource limits (see B<setrlimit>(2));"
msgstr "リソース上限を増やす (B<setrlimit>(2))。"

#. type: Plain text
#: build/C/man7/capabilities.7:730
msgid "override maximum number of consoles on console allocation;"
msgstr "コンソール割り当てにおいてコンソールの最大数を上書きする。"

#. type: Plain text
#: build/C/man7/capabilities.7:732
msgid "override maximum number of keymaps;"
msgstr "キーマップの最大数を上書きする。"

#. type: Plain text
#: build/C/man7/capabilities.7:734
msgid "allow more than 64hz interrupts from the real-time clock;"
msgstr "リアルタイムクロックから秒間 64 回を越える回数の割り当てが許可する。"

#. type: Plain text
#: build/C/man7/capabilities.7:743
msgid ""
"raise I<msg_qbytes> limit for a System V message queue above the limit in I</"
"proc/sys/kernel/msgmnb> (see B<msgop>(2)  and B<msgctl>(2));"
msgstr ""
"メッセージキューに関する上限 I<msg_qbytes> を \n"
"I</proc/sys/kernel/msgmnb> に指定されている上限よりも大きく設定する\n"
"(B<msgop>(2) と B<msgctl>(2) 参照)。"

#. type: Plain text
#: build/C/man7/capabilities.7:750
msgid ""
"allow the B<RLIMIT_NOFILE> resource limit on the number of \"in-flight\" "
"file descriptors to be bypassed when passing file descriptors to another "
"process via a UNIX domain socket (see B<unix>(7));"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:757
msgid ""
"override the I</proc/sys/fs/pipe-size-max> limit when setting the capacity "
"of a pipe using the B<F_SETPIPE_SZ> B<fcntl>(2)  command;"
msgstr ""
"B<F_SETPIPE_SZ> B<fcntl>(2) を使ってパイプの容量を設定する際に\n"
"上限 I</proc/sys/fs/pipe-size-max> を上書きする。"

#. type: Plain text
#: build/C/man7/capabilities.7:762
msgid ""
"use B<F_SETPIPE_SZ> to increase the capacity of a pipe above the limit "
"specified by I</proc/sys/fs/pipe-max-size>;"
msgstr ""
"I</proc/sys/fs/pipe-max-size> に指定されている上限を超えてパイプの容量\n"
"を増やすのに B<F_SETPIPE_SZ> を使用する。"

#. type: Plain text
#: build/C/man7/capabilities.7:770
msgid ""
"override I</proc/sys/fs/mqueue/queues_max,> I</proc/sys/fs/mqueue/msg_max,> "
"and I</proc/sys/fs/mqueue/msgsize_max> limits when creating POSIX message "
"queues (see B<mq_overview>(7));"
msgstr "POSIX メッセージキューを作成する際に、上限 I</proc/sys/fs/mqueue/queues_max>, I</proc/sys/fs/mqueue/msg_max>, I</proc/sys/fs/mqueue/msgsize_max> を上書きする (B<mq_overview>(7) 参照)。"

#. type: Plain text
#: build/C/man7/capabilities.7:775
msgid "employ the B<prctl>(2)  B<PR_SET_MM> operation;"
msgstr "B<prctl>(2) B<PR_SET_MM> 操作を使用する。"

#. type: Plain text
#: build/C/man7/capabilities.7:780
msgid ""
"set I</proc/[pid]/oom_score_adj> to a value lower than the value last set by "
"a process with B<CAP_SYS_RESOURCE>."
msgstr "B<CAP_SYS_RESOURCE> を持ったプロセスによって最後に設定された値よりも小さな値を I</proc/[pid]/oom_score_adj> に設定する。"

#. type: TP
#: build/C/man7/capabilities.7:782
#, no-wrap
msgid "B<CAP_SYS_TIME>"
msgstr "B<CAP_SYS_TIME>"

#. type: Plain text
#: build/C/man7/capabilities.7:789
msgid ""
"Set system clock (B<settimeofday>(2), B<stime>(2), B<adjtimex>(2)); set real-"
"time (hardware) clock."
msgstr ""
"システムクロックを変更する (B<settimeofday>(2), B<stime>(2), "
"B<adjtimex>(2))。 リアルタイム (ハードウェア) クロックを変更する。"

#. type: TP
#: build/C/man7/capabilities.7:789
#, no-wrap
msgid "B<CAP_SYS_TTY_CONFIG>"
msgstr "B<CAP_SYS_TTY_CONFIG>"

#. type: Plain text
#: build/C/man7/capabilities.7:796
msgid ""
"Use B<vhangup>(2); employ various privileged B<ioctl>(2)  operations on "
"virtual terminals."
msgstr ""
"B<vhangup>(2) を使用する。\n"
"特権が必要な仮想端末に関する各種の B<ioctl>(2) 操作を利用できる。"

#. type: TP
#: build/C/man7/capabilities.7:796
#, no-wrap
msgid "B<CAP_SYSLOG> (since Linux 2.6.37)"
msgstr "B<CAP_SYSLOG> (Linux 2.6.37 以降)"

#. type: Plain text
#: build/C/man7/capabilities.7:807
msgid ""
"Perform privileged B<syslog>(2)  operations.  See B<syslog>(2)  for "
"information on which operations require privilege."
msgstr ""
"特権が必要な B<syslog>(2) 操作を実行できる。\n"
"どの操作が特権が必要かについての情報は B<syslog>(2) を参照。"

#. type: Plain text
#: build/C/man7/capabilities.7:817
msgid ""
"View kernel addresses exposed via I</proc> and other interfaces when I</proc/"
"sys/kernel/kptr_restrict> has the value 1.  (See the discussion of the "
"I<kptr_restrict> in B<proc>(5).)"
msgstr ""
"I</proc/sys/kernel/kptr_restrict> の値が 1 の場合、 I</proc> や他のインター"
"フェース経由で公開されているカーネルアドレスを参照する (B<proc>(5) の "
"I<kptr_restrict> の議論を参照)。"

#. type: TP
#: build/C/man7/capabilities.7:819
#, no-wrap
msgid "B<CAP_WAKE_ALARM> (since Linux 3.0)"
msgstr "B<CAP_WAKE_ALARM> (Linux 3.0 以降)"

#. type: Plain text
#: build/C/man7/capabilities.7:827
msgid ""
"Trigger something that will wake up the system (set B<CLOCK_REALTIME_ALARM> "
"and B<CLOCK_BOOTTIME_ALARM> timers)."
msgstr ""
"システムを起こすトリガーを有効にする (タイマー B<CLOCK_REALTIME_ALARM>\n"
"や B<CLOCK_BOOTTIME_ALARM> を設定する)。"

#. type: SS
#: build/C/man7/capabilities.7:827
#, no-wrap
msgid "Past and current implementation"
msgstr "過去と現在の実装"

#. type: Plain text
#: build/C/man7/capabilities.7:829
msgid "A full implementation of capabilities requires that:"
msgstr "完全な形のケーパビリティを実装するには、以下の要件を満たす必要がある："

#. type: IP
#: build/C/man7/capabilities.7:829 build/C/man7/capabilities.7:1288
#: build/C/man7/capabilities.7:1483 build/C/man7/capabilities.7:1536
#: build/C/man7/cgroups.7:583 build/C/man7/cgroups.7:1391
#: build/C/man7/cgroups.7:1447 build/C/man7/cgroups.7:1796
#: build/C/man7/cgroups.7:1845 build/C/man3/posix_spawn.3:238
#, no-wrap
msgid "1."
msgstr "1."

#. type: Plain text
#: build/C/man7/capabilities.7:833
msgid ""
"For all privileged operations, the kernel must check whether the thread has "
"the required capability in its effective set."
msgstr ""
"全ての特権操作について、カーネルはそのスレッドの実効ケーパビリティセットに 必"
"要なケーパビリティがあるかを確認する。"

#. type: IP
#: build/C/man7/capabilities.7:833 build/C/man7/capabilities.7:1295
#: build/C/man7/capabilities.7:1489 build/C/man7/capabilities.7:1542
#: build/C/man7/cgroups.7:586 build/C/man7/cgroups.7:1428
#: build/C/man7/cgroups.7:1471 build/C/man7/cgroups.7:1798
#: build/C/man7/cgroups.7:1851 build/C/man3/posix_spawn.3:244
#, no-wrap
msgid "2."
msgstr "2."

#. type: Plain text
#: build/C/man7/capabilities.7:836
msgid ""
"The kernel must provide system calls allowing a thread's capability sets to "
"be changed and retrieved."
msgstr ""
"カーネルで、あるスレッドのケーパビリティセットを変更したり、 取得したりできる"
"システムコールが提供される。"

#. type: IP
#: build/C/man7/capabilities.7:836 build/C/man7/capabilities.7:1492
#: build/C/man7/capabilities.7:1546 build/C/man7/cgroups.7:591
#: build/C/man7/cgroups.7:1811 build/C/man7/cgroups.7:1856
#: build/C/man3/posix_spawn.3:251
#, no-wrap
msgid "3."
msgstr "3."

#. type: Plain text
#: build/C/man7/capabilities.7:839
msgid ""
"The filesystem must support attaching capabilities to an executable file, so "
"that a process gains those capabilities when the file is executed."
msgstr ""
"ファイルシステムが、実行可能ファイルにケーパビリティを付与でき、ファイル 実行"
"時にそのケーパビリティをプロセスが取得できるような機能をサポートする。"

#. type: Plain text
#: build/C/man7/capabilities.7:843
msgid ""
"Before kernel 2.6.24, only the first two of these requirements are met; "
"since kernel 2.6.24, all three requirements are met."
msgstr ""
"カーネル 2.6.24 より前では、最初の 2つの要件のみが満たされている。 カーネル "
"2.6.24 以降では、3つの要件すべてが満たされている。"

#. type: SS
#: build/C/man7/capabilities.7:843
#, no-wrap
msgid "Notes to kernel developers"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:846
msgid ""
"When adding a new kernel feature that should be governed by a capability, "
"consider the following points."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:851
msgid ""
"The goal of capabilities is divide the power of superuser into pieces, such "
"that if a program that has one or more capabilities is compromised, its "
"power to do damage to the system would be less than the same program running "
"with root privilege."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:859
msgid ""
"You have the choice of either creating a new capability for your new "
"feature, or associating the feature with one of the existing capabilities.  "
"In order to keep the set of capabilities to a manageable size, the latter "
"option is preferable, unless there are compelling reasons to take the former "
"option.  (There is also a technical limit: the size of capability sets is "
"currently limited to 64 bits.)"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:867
msgid ""
"To determine which existing capability might best be associated with your "
"new feature, review the list of capabilities above in order to find a \"silo"
"\" into which your new feature best fits.  One approach to take is to "
"determine if there are other features requiring capabilities that will "
"always be used along with the new feature.  If the new feature is useless "
"without these other features, you should use the same capability as the "
"other features."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:885
msgid ""
"I<Don't> choose B<CAP_SYS_ADMIN> if you can possibly avoid it! A vast "
"proportion of existing capability checks are associated with this capability "
"(see the partial list above).  It can plausibly be called \"the new root\", "
"since on the one hand, it confers a wide range of powers, and on the other "
"hand, its broad scope means that this is the capability that is required by "
"many privileged programs.  Don't make the problem worse.  The only new "
"features that should be associated with B<CAP_SYS_ADMIN> are ones that "
"I<closely> match existing uses in that silo."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:895
msgid ""
"If you have determined that it really is necessary to create a new "
"capability for your feature, don't make or name it as a \"single-use\" "
"capability.  Thus, for example, the addition of the highly specific "
"B<CAP_SYS_PACCT> was probably a mistake.  Instead, try to identify and name "
"your new capability as a broader silo into which other related future use "
"cases might fit."
msgstr ""

#. type: SS
#: build/C/man7/capabilities.7:895
#, no-wrap
msgid "Thread capability sets"
msgstr "スレッドケーパビリティセット"

#. type: Plain text
#: build/C/man7/capabilities.7:898
msgid ""
"Each thread has the following capability sets containing zero or more of the "
"above capabilities:"
msgstr "各スレッドは以下のケーパビリティセットを持つ。各々のケーパビリティセットは 上記のケーパビリティの組み合わせである (全てのケーパビリティが無効でもよい)。"

#. type: TP
#: build/C/man7/capabilities.7:898
#, fuzzy, no-wrap
#| msgid "I<Permitted>:"
msgid "I<Permitted>"
msgstr "I<許可 (permitted)>:"

#. type: Plain text
#: build/C/man7/capabilities.7:906
msgid ""
"This is a limiting superset for the effective capabilities that the thread "
"may assume.  It is also a limiting superset for the capabilities that may be "
"added to the inheritable set by a thread that does not have the "
"B<CAP_SETPCAP> capability in its effective set."
msgstr ""
"そのスレッドが持つことになっている実効ケーパビリティの 限定的なスーパーセット"
"である。 これは、実効ケーパビリティセットに B<CAP_SETPCAP> ケーパビリティを"
"持っていないスレッドが継承可能ケーパビリティセットに 追加可能なケーパビリティ"
"の限定的なスーパーセットでもある。"

#. type: Plain text
#: build/C/man7/capabilities.7:912
msgid ""
"If a thread drops a capability from its permitted set, it can never "
"reacquire that capability (unless it B<execve>(2)s either a set-user-ID-root "
"program, or a program whose associated file capabilities grant that "
"capability)."
msgstr ""
"許可ケーパビリティセットから削除してしまったケーパビリティは、 (set-user-ID-"
"root プログラムか、 そのケーパビリティをファイルケーパビリティで許可している"
"プログラムを B<execve>(2)  しない限りは) もう一度獲得することはできない。"

#. type: TP
#: build/C/man7/capabilities.7:912
#, fuzzy, no-wrap
#| msgid "I<Inheritable>:"
msgid "I<Inheritable>"
msgstr "I<継承可能 (inheritable)>:"

#. type: Plain text
#: build/C/man7/capabilities.7:919
#, fuzzy
#| msgid ""
#| "This is a set of capabilities preserved across an B<execve>(2).  It "
#| "provides a mechanism for a process to assign capabilities to the "
#| "permitted set of the new program during an B<execve>(2)."
msgid ""
"This is a set of capabilities preserved across an B<execve>(2).  Inheritable "
"capabilities remain inheritable when executing any program, and inheritable "
"capabilities are added to the permitted set when executing a program that "
"has the corresponding bits set in the file inheritable set."
msgstr ""
"B<execve>(2)  を前後で保持されるケーパビリティセットである。 この仕組みを使う"
"ことで、あるプロセスが B<execve>(2)  を行う際に新しいプログラムの許可ケーパビ"
"リティセットとして 割り当てるケーパビリティを指定することができる。"

#. type: Plain text
#: build/C/man7/capabilities.7:925
msgid ""
"Because inheritable capabilities are not generally preserved across "
"B<execve>(2)  when running as a non-root user, applications that wish to run "
"helper programs with elevated capabilities should consider using ambient "
"capabilities, described below."
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:925
#, fuzzy, no-wrap
#| msgid "I<Effective>:"
msgid "I<Effective>"
msgstr "I<実効 (effective)>:"

#. type: Plain text
#: build/C/man7/capabilities.7:929
msgid ""
"This is the set of capabilities used by the kernel to perform permission "
"checks for the thread."
msgstr ""
"カーネルがスレッドの権限 (permission) をチェックするときに 使用するケーパビリ"
"ティセットである。"

#. type: TP
#: build/C/man7/capabilities.7:929
#, fuzzy, no-wrap
#| msgid "I<ru_inblock> (since Linux 2.6.22)"
msgid "I<Bounding> (per-thread since Linux 2.6.25)"
msgstr "I<ru_inblock> (Linux 2.6.22 以降)"

#. type: Plain text
#: build/C/man7/capabilities.7:934
msgid ""
"The capability bounding set is a mechanism that can be used to limit the "
"capabilities that are gained during B<execve>(2)."
msgstr "ケーパビリティバウンディングセット (capability bounding set) は、 B<execve>(2) 時に獲得するケーパビリティを制限するために使われる機構である。"

#. type: Plain text
#: build/C/man7/capabilities.7:938
msgid ""
"Since Linux 2.6.25, this is a per-thread capability set.  In older kernels, "
"the capability bounding set was a system wide attribute shared by all "
"threads on the system."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:940
msgid "For more details on the capability bounding set, see below."
msgstr "ケーパビリティバウンディングセットの詳細は、下記を参照。"

#. type: TP
#: build/C/man7/capabilities.7:940
#, fuzzy, no-wrap
#| msgid "I<ru_nvcsw> (since Linux 2.6)"
msgid "I<Ambient> (since Linux 4.3)"
msgstr "I<ru_nvcsw> (Linux 2.6 以降)"

#.  commit 58319057b7847667f0c9585b9de0e8932b0fdb08
#. type: Plain text
#: build/C/man7/capabilities.7:948
#, fuzzy
#| msgid ""
#| "This is a set of capabilities preserved across an B<execve>(2).  It "
#| "provides a mechanism for a process to assign capabilities to the "
#| "permitted set of the new program during an B<execve>(2)."
msgid ""
"This is a set of capabilities that are preserved across an B<execve>(2)  of "
"a program that is not privileged.  The ambient capability set obeys the "
"invariant that no capability can ever be ambient if it is not both permitted "
"and inheritable."
msgstr ""
"B<execve>(2)  を前後で保持されるケーパビリティセットである。 この仕組みを使う"
"ことで、あるプロセスが B<execve>(2)  を行う際に新しいプログラムの許可ケーパビ"
"リティセットとして 割り当てるケーパビリティを指定することができる。"

#. type: Plain text
#: build/C/man7/capabilities.7:953
msgid ""
"The ambient capability set can be directly modified using B<prctl>(2).  "
"Ambient capabilities are automatically lowered if either of the "
"corresponding permitted or inheritable capabilities is lowered."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:966
msgid ""
"Executing a program that changes UID or GID due to the set-user-ID or set-"
"group-ID bits or executing a program that has any file capabilities set will "
"clear the ambient set.  Ambient capabilities are added to the permitted set "
"and assigned to the effective set when B<execve>(2)  is called.  If ambient "
"capabilities cause a process's permitted and effective capabilities to "
"increase during an B<execve>(2), this does not trigger the secure-execution "
"mode described in B<ld.so>(8)."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:972
msgid ""
"A child created via B<fork>(2)  inherits copies of its parent's capability "
"sets.  See below for a discussion of the treatment of capabilities during "
"B<execve>(2)."
msgstr ""
"B<fork>(2)  で作成される子プロセスは、親のケーパビリティセットのコピーを継承"
"する。 B<execve>(2)  中のケーパビリティの扱いについては下記を参照のこと。"

#. type: Plain text
#: build/C/man7/capabilities.7:976
msgid ""
"Using B<capset>(2), a thread may manipulate its own capability sets (see "
"below)."
msgstr ""
"B<capset>(2)  を使うと、プロセスは自分自身のケーパビリティセット を操作するこ"
"とができる (下記参照)。"

#.  commit 73efc0394e148d0e15583e13712637831f926720
#. type: Plain text
#: build/C/man7/capabilities.7:985
msgid ""
"Since Linux 3.2, the file I</proc/sys/kernel/cap_last_cap> exposes the "
"numerical value of the highest capability supported by the running kernel; "
"this can be used to determine the highest bit that may be set in a "
"capability set."
msgstr ""
"Linux 3.2 以降では、 ファイル I</proc/sys/kernel/cap_last_cap> で、 実行中の"
"カーネルでサポートされているケーパビリティの最大値を参照できる。 この情報を"
"使って、 ケーパビリティセットに設定される可能性がある最上位ビットを判定するこ"
"とができる。"

#. type: SS
#: build/C/man7/capabilities.7:985
#, no-wrap
msgid "File capabilities"
msgstr "ファイルケーパビリティ"

#. type: Plain text
#: build/C/man7/capabilities.7:1002
msgid ""
"Since kernel 2.6.24, the kernel supports associating capability sets with an "
"executable file using B<setcap>(8).  The file capability sets are stored in "
"an extended attribute (see B<setxattr>(2)  and B<xattr>(7))  named "
"I<security.capability>.  Writing to this extended attribute requires the "
"B<CAP_SETFCAP> capability.  The file capability sets, in conjunction with "
"the capability sets of the thread, determine the capabilities of a thread "
"after an B<execve>(2)."
msgstr "カーネル 2.6.24 以降では、 B<setcap>(8)  を使って実行ファイルにケーパビリティセットを対応付けることができる。 ファイルケーパビリティセットは I<security.capability> という名前の拡張属性に保存される (B<setxattr>(2) と B<xattr>(7) 参照)。この拡張属性への書き込みには B<CAP_SETFCAP> ケーパビリティが必要である。 ファイルケーパビリティセットとスレッドのケーパビリティセットの両方が 考慮され、 B<execve>(2)  後のスレッドのケーパビリティセットが決定される。"

#. type: Plain text
#: build/C/man7/capabilities.7:1004
msgid "The three file capability sets are:"
msgstr "3 つのファイルケーパビリティセットが定義されている。"

#. type: TP
#: build/C/man7/capabilities.7:1004
#, no-wrap
msgid "I<Permitted> (formerly known as I<forced>):"
msgstr "I<許可 (Permitted)> (以前のI<強制 (Forced)>):"

#. type: Plain text
#: build/C/man7/capabilities.7:1008
msgid ""
"These capabilities are automatically permitted to the thread, regardless of "
"the thread's inheritable capabilities."
msgstr ""
"スレッドの継承可能ケーパビリティに関わらず、そのスレッドに自動的に 認められる"
"ケーパビリティ。"

#. type: TP
#: build/C/man7/capabilities.7:1008
#, no-wrap
msgid "I<Inheritable> (formerly known as I<allowed>):"
msgstr "I<継承可能 (Inheritable)> (以前の I<許容 (Allowed)>):"

#. type: Plain text
#: build/C/man7/capabilities.7:1014
msgid ""
"This set is ANDed with the thread's inheritable set to determine which "
"inheritable capabilities are enabled in the permitted set of the thread "
"after the B<execve>(2)."
msgstr ""
"このセットと、スレッドの継承可能ケーパビリティセットとの 論理積 (AND) がとら"
"れ、 B<execve>(2)  の後にそのスレッドの許可ケーパビリティセットで有効となる "
"継承可能ケーパビリティが決定される。"

#. type: TP
#: build/C/man7/capabilities.7:1014
#, no-wrap
msgid "I<Effective>:"
msgstr "I<実効 (effective)>:"

#. type: Plain text
#: build/C/man7/capabilities.7:1024
msgid ""
"This is not a set, but rather just a single bit.  If this bit is set, then "
"during an B<execve>(2)  all of the new permitted capabilities for the thread "
"are also raised in the effective set.  If this bit is not set, then after an "
"B<execve>(2), none of the new permitted capabilities is in the new effective "
"set."
msgstr ""
"これは集合ではなく、1 ビットの情報である。 このビットがセットされていると、 "
"B<execve>(2)  実行中に、そのスレッドの新しい許可ケーパビリティが全て 実効ケー"
"パビリティ集合においてもセットされる。 このビットがセットされていない場合、 "
"B<execve>(2)  後には新しい許可ケーパビリティのどれも新しい実効ケーパビリティ"
"集合 にセットされない。"

#. type: Plain text
#: build/C/man7/capabilities.7:1040
msgid ""
"Enabling the file effective capability bit implies that any file permitted "
"or inheritable capability that causes a thread to acquire the corresponding "
"permitted capability during an B<execve>(2)  (see the transformation rules "
"described below) will also acquire that capability in its effective set.  "
"Therefore, when assigning capabilities to a file (B<setcap>(8), "
"B<cap_set_file>(3), B<cap_set_fd>(3)), if we specify the effective flag as "
"being enabled for any capability, then the effective flag must also be "
"specified as enabled for all other capabilities for which the corresponding "
"permitted or inheritable flags is enabled."
msgstr ""
"ファイルの実効ケーパビリティビットを有効にするというのは、 B<execve>(2)  実行"
"時に、ファイルの許可ケーパビリティと継承ケーパビリティに対応するものが スレッ"
"ドの許可ケーパビリティセットとしてセットされるが、 これが実効ケーパビリティ"
"セットにもセットされるということである (ケーパビリティの変換ルールは下記参"
"照)。 したがって、ファイルにケーパビリティを割り当てる際 (B<setcap>(8), "
"B<cap_set_file>(3), B<cap_set_fd>(3))、 いずれかのケーパビリティに対して実効"
"フラグを有効と指定する場合、 許可フラグや継承可能フラグを有効にした他の全ての"
"ケーパビリティ についても実効フラグを有効と指定しなければならない。"

#. type: SS
#: build/C/man7/capabilities.7:1040
#, no-wrap
msgid "File capability extended attribute versioning"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1048
msgid ""
"To allow extensibility, the kernel supports a scheme to encode a version "
"number inside the I<security.capability> extended attribute that is used to "
"implement file capabilities.  These version numbers are internal to the "
"implementation, and not directly visible to user-space applications.  To "
"date, the following versions are supported:"
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:1048
#, no-wrap
msgid "B<VFS_CAP_REVISION_1>"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1052
msgid ""
"This was the original file capability implementation, which supported 32-bit "
"masks for file capabilities."
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:1052
#, no-wrap
msgid "B<VFS_CAP_REVISION_2> (since Linux 2.6.25)"
msgstr "B<VFS_CAP_REVISION_2> (Linux 2.6.25 以降)"

#.  commit e338d263a76af78fe8f38a72131188b58fceb591
#. type: Plain text
#: build/C/man7/capabilities.7:1063
msgid ""
"This version allows for file capability masks that are 64 bits in size, and "
"was necessary as the number of supported capabilities grew beyond 32.  The "
"kernel transparently continues to support the execution of files that have "
"32-bit version 1 capability masks, but when adding capabilities to files "
"that did not previously have capabilities, or modifying the capabilities of "
"existing files, it automatically uses the version 2 scheme (or possibly the "
"version 3 scheme, as described below)."
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:1063
#, no-wrap
msgid "B<VFS_CAP_REVISION_3> (since Linux 4.14)"
msgstr "B<VFS_CAP_REVISION_3> (Linux 4.14 以降)"

#.  commit 8db6c34f1dbc8e06aa016a9b829b06902c3e1340
#. type: Plain text
#: build/C/man7/capabilities.7:1068
msgid ""
"Version 3 file capabilities are provided to support namespaced file "
"capabilities (described below)."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1076
msgid ""
"As with version 2 file capabilities, version 3 capability masks are 64 bits "
"in size.  But in addition, the root user ID of namespace is encoded in the "
"I<security.capability> extended attribute.  (A namespace's root user ID is "
"the value that user ID 0 inside that namespace maps to in the initial user "
"namespace.)"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1082
msgid ""
"Version 3 file capabilities are designed to coexist with version 2 "
"capabilities; that is, on a modern Linux system, there may be some files "
"with version 2 capabilities while others have version 3 capabilities."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1093
msgid ""
"Before Linux 4.14, the only kind of file capability extended attribute that "
"could be attached to a file was a B<VFS_CAP_REVISION_2> attribute.  Since "
"Linux 4.14, the version of the I<security.capability> extended attribute "
"that is attached to a file depends on the circumstances in which the "
"attribute was created."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1100
msgid ""
"Starting with Linux 4.14, a I<security.capability> extended attribute is "
"automatically created as (or converted to)  a version 3 "
"(B<VFS_CAP_REVISION_3>)  attribute if both of the following are true:"
msgstr ""

#. type: IP
#: build/C/man7/capabilities.7:1100
#, no-wrap
msgid "(1)"
msgstr "(1)"

#. type: Plain text
#: build/C/man7/capabilities.7:1104
msgid ""
"The thread writing the attribute resides in a noninitial user namespace.  "
"(More precisely: the thread resides in a user namespace other than the one "
"from which the underlying filesystem was mounted.)"
msgstr ""

#. type: IP
#: build/C/man7/capabilities.7:1104
#, no-wrap
msgid "(2)"
msgstr "(2)"

#. type: Plain text
#: build/C/man7/capabilities.7:1113
msgid ""
"The thread has the B<CAP_SETFCAP> capability over the file inode, meaning "
"that (a) the thread has the B<CAP_SETFCAP> capability in its own user "
"namespace; and (b) the UID and GID of the file inode have mappings in the "
"writer's user namespace."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1119
msgid ""
"When a B<VFS_CAP_REVISION_3> I<security.capability> extended attribute is "
"created, the root user ID of the creating thread's user namespace is saved "
"in the extended attribute."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1130
msgid ""
"By contrast, creating or modifying a I<security.capability> extended "
"attribute from a privileged (B<CAP_SETFCAP>)  thread that resides in the "
"namespace where the underlying filesystem was mounted (this normally means "
"the initial user namespace)  automatically results in the creation of a "
"version 2 (B<VFS_CAP_REVISION_2>)  attribute."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1159
msgid ""
"Note that the creation of a version 3 I<security.capability> extended "
"attribute is automatic.  That is to say, when a user-space application "
"writes (B<setxattr>(2))  a I<security.capability> attribute in the version 2 "
"format, the kernel will automatically create a version 3 attribute if the "
"attribute is created in the circumstances described above.  Correspondingly, "
"when a version 3 I<security.capability> attribute is retrieved "
"(B<getxattr>(2))  by a process that resides inside a user namespace that was "
"created by the root user ID (or a descendant of that user namespace), the "
"returned attribute is (automatically)  simplified to appear as a version 2 "
"attribute (i.e., the returned value is the size of a version 2 attribute and "
"does not include the root user ID).  These automatic translations mean that "
"no changes are required to user-space tools (e.g., B<setcap>(1)  and "
"B<getcap>(1))  in order for those tools to be used to create and retrieve "
"version 3 I<security.capability> attributes."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1169
msgid ""
"Note that a file can have either a version 2 or a version 3 I<security."
"capability> extended attribute associated with it, but not both: creation or "
"modification of the I<security.capability> extended attribute will "
"automatically modify the version according to the circumstances in which the "
"extended attribute is created or modified."
msgstr ""

#. type: SS
#: build/C/man7/capabilities.7:1169
#, no-wrap
msgid "Transformation of capabilities during execve()"
msgstr "execve() 中のケーパビリティの変換"

#. type: Plain text
#: build/C/man7/capabilities.7:1174
msgid ""
"During an B<execve>(2), the kernel calculates the new capabilities of the "
"process using the following algorithm:"
msgstr ""
"B<execve>(2)  実行時に、カーネルはプロセスの新しいケーパビリティを次の アルゴ"
"リズムを用いて計算する："

#. type: Plain text
#: build/C/man7/capabilities.7:1178
#, no-wrap
msgid "P'(ambient)     = (file is privileged) ? 0 : P(ambient)\n"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1181
#, no-wrap
msgid ""
"P'(permitted)   = (P(inheritable) & F(inheritable)) |\n"
"                  (F(permitted) & P(bounding)) | P'(ambient)\n"
msgstr ""
"P'(permitted)   = (P(inheritable) & F(inheritable)) |\n"
"                  (F(permitted) & P(bounding)) | P'(ambient)\n"

#. type: Plain text
#: build/C/man7/capabilities.7:1183
#, no-wrap
msgid "P'(effective)   = F(effective) ? P'(permitted) : P'(ambient)\n"
msgstr "P'(effective)   = F(effective) ? P'(permitted) : P'(ambient)\n"

#. type: Plain text
#: build/C/man7/capabilities.7:1185
#, no-wrap
msgid "P'(inheritable) = P(inheritable)    [i.e., unchanged]\n"
msgstr "P'(inheritable) = P(inheritable)    [つまり、変更されない]\n"

#. type: Plain text
#: build/C/man7/capabilities.7:1187
#, no-wrap
msgid "P'(bounding)    = P(bounding)       [i.e., unchanged]\n"
msgstr "P'(bounding)    = P(bounding)       [つまり、変更されない]\n"

#. type: Plain text
#: build/C/man7/capabilities.7:1191
msgid "where:"
msgstr "各変数の意味は以下の通り:"

#. type: IP
#: build/C/man7/capabilities.7:1192
#, no-wrap
msgid "P()"
msgstr "P()"

#. type: Plain text
#: build/C/man7/capabilities.7:1195
msgid "denotes the value of a thread capability set before the B<execve>(2)"
msgstr "B<execve>(2)  前のスレッドのケーパビリティセットの値"

#. type: IP
#: build/C/man7/capabilities.7:1195
#, no-wrap
msgid "P'()"
msgstr "P'()"

#. type: Plain text
#: build/C/man7/capabilities.7:1198
msgid "denotes the value of a thread capability set after the B<execve>(2)"
msgstr "B<execve>(2) 後のスレッドのケーパビリティセットの値"

#. type: IP
#: build/C/man7/capabilities.7:1198
#, no-wrap
msgid "F()"
msgstr "F()"

#. type: Plain text
#: build/C/man7/capabilities.7:1200
msgid "denotes a file capability set"
msgstr "ファイルケーパビリティセットの値"

#. type: Plain text
#: build/C/man7/capabilities.7:1204
msgid ""
"Note the following details relating to the above capability transformation "
"rules:"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1210
msgid ""
"The ambient capability set is present only since Linux 4.3.  When "
"determining the transformation of the ambient set during B<execve>(2), a "
"privileged file is one that has capabilities or has the set-user-ID or set-"
"group-ID bit set."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1217
msgid ""
"Prior to Linux 2.6.25, the bounding set was a system-wide attribute shared "
"by all threads.  That system-wide value was employed to calculate the new "
"permitted set during B<execve>(2)  in the same manner as shown above for "
"I<P(bounding)>."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1226
msgid ""
"I<Note>: during the capability transitions described above, file "
"capabilities may be ignored (treated as empty) for the same reasons that the "
"set-user-ID and set-group-ID bits are ignored; see B<execve>(2).  File "
"capabilities are similarly ignored if the kernel was booted with the "
"I<no_file_caps> option."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1239
msgid ""
"I<Note>: according to the rules above, if a process with nonzero user IDs "
"performs an B<execve>(2)  then any capabilities that are present in its "
"permitted and effective sets will be cleared.  For the treatment of "
"capabilities when a process with a user ID of zero performs an B<execve>(2), "
"see below under I<Capabilities and execution of programs by root>."
msgstr ""

#. type: SS
#: build/C/man7/capabilities.7:1239
#, no-wrap
msgid "Safety checking for capability-dumb binaries"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1253
msgid ""
"A capability-dumb binary is an application that has been marked to have file "
"capabilities, but has not been converted to use the B<libcap>(3)  API to "
"manipulate its capabilities.  (In other words, this is a traditional set-"
"user-ID-root program that has been switched to use file capabilities, but "
"whose code has not been modified to understand capabilities.)  For such "
"applications, the effective capability bit is set on the file, so that the "
"file permitted capabilities are automatically enabled in the process "
"effective set when executing the file.  The kernel recognizes a file which "
"has the effective capability bit set as capability-dumb for the purpose of "
"the check described here."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1275
msgid ""
"When executing a capability-dumb binary, the kernel checks if the process "
"obtained all permitted capabilities that were specified in the file "
"permitted set, after the capability transformations described above have "
"been performed.  (The typical reason why this might I<not> occur is that the "
"capability bounding set masked out some of the capabilities in the file "
"permitted set.)  If the process did not obtain the full set of file "
"permitted capabilities, then B<execve>(2)  fails with the error B<EPERM>.  "
"This prevents possible security risks that could arise when a capability-"
"dumb application is executed with less privilege that it needs.  Note that, "
"by definition, the application could not itself recognize this problem, "
"since it does not employ the B<libcap>(3)  API."
msgstr ""

#. type: SS
#: build/C/man7/capabilities.7:1275
#, no-wrap
msgid "Capabilities and execution of programs by root"
msgstr "ケーパビリティと、ルートによるプログラムの実行"

#.  See cap_bprm_set_creds(), bprm_caps_from_vfs_cap() and
#.  handle_privileged_root() in security/commoncap.c (Linux 5.0 source)
#. type: Plain text
#: build/C/man7/capabilities.7:1282
msgid ""
"In order to mirror traditional UNIX semantics, the kernel performs special "
"treatment of file capabilities when a process with UID 0 (root) executes a "
"program and when a set-user-ID-root program is executed."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1288
msgid ""
"After having performed any changes to the process effective ID that were "
"triggered by the set-user-ID mode bit of the binary\\(eme.g., switching the "
"effective user ID to 0 (root) because a set-user-ID-root program was executed"
"\\(emthe kernel calculates the file capability sets as follows:"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1295
msgid ""
"If the real or effective user ID of the process is 0 (root), then the file "
"inheritable and permitted sets are ignored; instead they are notionally "
"considered to be all ones (i.e., all capabilities enabled).  (There is one "
"exception to this behavior, described below in I<Set-user-ID-root programs "
"that have file capabilities>.)"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1299
#, fuzzy
#| msgid ""
#| "If a set-user-ID-root program is being executed, then the file effective "
#| "bit is defined to be one (enabled)."
msgid ""
"If the effective user ID of the process is 0 (root) or the file effective "
"bit is in fact enabled, then the file effective bit is notionally defined to "
"be one (enabled)."
msgstr ""
"set-user-ID-root プログラムが実行される場合、 ファイルの実効ケーパビリティ"
"ビットを 1 (enabled) に定義する。"

#. type: Plain text
#: build/C/man7/capabilities.7:1304
msgid ""
"These notional values for the file's capability sets are then used as "
"described above to calculate the transformation of the process's "
"capabilities during B<execve>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1312
msgid ""
"Thus, when a process with nonzero UIDs B<execve>(2)s a set-user-ID-root "
"program that does not have capabilities attached, or when a process whose "
"real and effective UIDs are zero B<execve>(2)s a program, the calculation of "
"the process's new permitted capabilities simplifies to:"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1316
#, no-wrap
msgid "P'(permitted)   = P(inheritable) | P(bounding)\n"
msgstr "P'(permitted)   = P(inheritable) | P(bounding)\n"

#. type: Plain text
#: build/C/man7/capabilities.7:1318
#, no-wrap
msgid "P'(effective)   = P'(permitted)\n"
msgstr "P'(effective)   = P'(permitted)\n"

#. type: Plain text
#: build/C/man7/capabilities.7:1327
msgid ""
"Consequently, the process gains all capabilities in its permitted and "
"effective capability sets, except those masked out by the capability "
"bounding set.  (In the calculation of P'(permitted), the P'(ambient) term "
"can be simplified away because it is by definition a proper subset of "
"P(inheritable).)"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1332
msgid ""
"The special treatments of user ID 0 (root) described in this subsection can "
"be disabled using the securebits mechanism described below."
msgstr ""

#. type: SS
#: build/C/man7/capabilities.7:1332
#, no-wrap
msgid "Set-user-ID-root programs that have file capabilities"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1350
msgid ""
"There is one exception to the behavior described under I<Capabilities and "
"execution of programs by root>.  If (a) the binary that is being executed "
"has capabilities attached and (b) the real user ID of the process is I<not> "
"0 (root) and (c) the effective user ID of the process I<is> 0 (root), then "
"the file capability bits are honored (i.e., they are not notionally "
"considered to be all ones).  The usual way in which this situation can arise "
"is when executing a set-UID-root program that also has file capabilities.  "
"When such a program is executed, the process gains just the capabilities "
"granted by the program (i.e., not all capabilities, as would occur when "
"executing a set-user-ID-root program that does not have any associated file "
"capabilities)."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1357
msgid ""
"Note that one can assign empty capability sets to a program file, and thus "
"it is possible to create a set-user-ID-root program that changes the "
"effective and saved set-user-ID of the process that executes the program to "
"0, but confers no capabilities to that process."
msgstr ""

#. type: SS
#: build/C/man7/capabilities.7:1357
#, no-wrap
msgid "Capability bounding set"
msgstr "ケーパビリティバウンディングセット"

#. type: Plain text
#: build/C/man7/capabilities.7:1362
msgid ""
"The capability bounding set is a security mechanism that can be used to "
"limit the capabilities that can be gained during an B<execve>(2).  The "
"bounding set is used in the following ways:"
msgstr ""
"ケーパビリティバウンディングセット (capability bounding set) は、 "
"B<execve>(2)  時に獲得できるケーパビリティを制限するために使われる セキュリ"
"ティ機構である。 バウンディングセットは以下のように使用される。"

#. type: Plain text
#: build/C/man7/capabilities.7:1370
msgid ""
"During an B<execve>(2), the capability bounding set is ANDed with the file "
"permitted capability set, and the result of this operation is assigned to "
"the thread's permitted capability set.  The capability bounding set thus "
"places a limit on the permitted capabilities that may be granted by an "
"executable file."
msgstr "B<execve>(2) 実行時に、ケーパビリティバウンディングセットとファイルの許可ケーパビリティセットの論理積 (AND) を取ったものが、 そのスレッドの許可ケーパビリティセットに割り当てられる。 つまり、ケーパビリティバウンディングセットは、 実行ファイルが認めている許可ケーパビリティに対して制限を課す働きをする。"

#. type: Plain text
#: build/C/man7/capabilities.7:1382
msgid ""
"(Since Linux 2.6.25)  The capability bounding set acts as a limiting "
"superset for the capabilities that a thread can add to its inheritable set "
"using B<capset>(2).  This means that if a capability is not in the bounding "
"set, then a thread can't add this capability to its inheritable set, even if "
"it was in its permitted capabilities, and thereby cannot have this "
"capability preserved in its permitted set when it B<execve>(2)s a file that "
"has the capability in its inheritable set."
msgstr ""
"(Linux 2.6.25 以降)  ケーパビリティバウンディングセットは、スレッドが "
"B<capset>(2)  により自身の継承可能セットに追加可能なケーパビリティの母集団を "
"制限する役割を持つ。 スレッドに許可されたケーパビリティであっても、バウンディ"
"ングセットに 含まれていなければ、スレッドはそのケーパビリティは自身の継承可能"
"セットに 追加できず、その結果、継承可能セットにそのケーパビリティを含むファイ"
"ルを B<execve>(2)  する場合、そのケーパビリティを許可セットに持ち続けることが"
"できない、 ということである。"

#. type: Plain text
#: build/C/man7/capabilities.7:1389
#, fuzzy
#| msgid ""
#| "Note that the bounding set masks the file permitted capabilities, but not "
#| "the inherited capabilities.  If a thread maintains a capability in its "
#| "inherited set that is not in its bounding set, then it can still gain "
#| "that capability in its permitted set by executing a file that has the "
#| "capability in its inherited set."
msgid ""
"Note that the bounding set masks the file permitted capabilities, but not "
"the inheritable capabilities.  If a thread maintains a capability in its "
"inheritable set that is not in its bounding set, then it can still gain that "
"capability in its permitted set by executing a file that has the capability "
"in its inheritable set."
msgstr ""
"バウンディングセットがマスクを行うのは、継承可能ケーパビリティではなく、 ファ"
"イルの許可ケーパビリティのマスクを行う点に注意すること。 あるスレッドの継承可"
"能セットにそのスレッドのバウンディングセットに 存在しないケーパビリティが含ま"
"れている場合、そのスレッドは、 継承可能セットに含まれるケーパビリティを持つ"
"ファイルを実行することにより、 許可セットに含まれるケーパビリティも獲得できる"
"ということである。"

#. type: Plain text
#: build/C/man7/capabilities.7:1392
msgid ""
"Depending on the kernel version, the capability bounding set is either a "
"system-wide attribute, or a per-process attribute."
msgstr ""
"カーネルのバージョンにより、ケーパビリティバウンディングセットは システム共通"
"の属性の場合と、プロセス単位の属性の場合がある。"

#. type: Plain text
#: build/C/man7/capabilities.7:1394
msgid "B<Capability bounding set from Linux 2.6.25 onward>"
msgstr "B<Linux 2.6.25 以降のケーパビリティバウンディングセット>"

#. type: Plain text
#: build/C/man7/capabilities.7:1399
msgid ""
"From Linux 2.6.25, the I<capability bounding set> is a per-thread "
"attribute.  (The system-wide capability bounding set described below no "
"longer exists.)"
msgstr "Linux 2.6.25 以降では、 「ケーパビリティバウンディングセット」はスレッド単位の属性である (以下に説明があるシステム全体のケーパビリティバウンディングセットはもはや存在しない)。"

#. type: Plain text
#: build/C/man7/capabilities.7:1404
msgid ""
"The bounding set is inherited at B<fork>(2)  from the thread's parent, and "
"is preserved across an B<execve>(2)."
msgstr ""
"バウンディングセットは B<fork>(2)  時にはスレッドの親プロセスから継承され、 "
"B<execve>(2)  の前後では保持される。"

#. type: Plain text
#: build/C/man7/capabilities.7:1417
msgid ""
"A thread may remove capabilities from its capability bounding set using the "
"B<prctl>(2)  B<PR_CAPBSET_DROP> operation, provided it has the "
"B<CAP_SETPCAP> capability.  Once a capability has been dropped from the "
"bounding set, it cannot be restored to that set.  A thread can determine if "
"a capability is in its bounding set using the B<prctl>(2)  "
"B<PR_CAPBSET_READ> operation."
msgstr ""
"スレッドが B<CAP_SETPCAP> ケーパビリティを持っている場合、そのスレッドは "
"B<prctl>(2)  の B<PR_CAPBSET_DROP> 操作を使って自身のケーパビリティバウンディ"
"ングセットから ケーパビリティを削除することができる。 いったんケーパビリティ"
"をバウンディングセットから削除してしまうと、 スレッドはそのケーパビリティを再"
"度セットすることはできない。 B<prctl>(2)  の B<PR_CAPBSET_READ> 操作を使うこ"
"とで、スレッドがあるケーパビリティが自身のバウンディングセット に含まれている"
"かを知ることができる。"

#.  commit b3a222e52e4d4be77cc4520a57af1a4a0d8222d1
#. type: Plain text
#: build/C/man7/capabilities.7:1437
msgid ""
"Removing capabilities from the bounding set is supported only if file "
"capabilities are compiled into the kernel.  In kernels before Linux 2.6.33, "
"file capabilities were an optional feature configurable via the "
"B<CONFIG_SECURITY_FILE_CAPABILITIES> option.  Since Linux 2.6.33, the "
"configuration option has been removed and file capabilities are always part "
"of the kernel.  When file capabilities are compiled into the kernel, the "
"B<init> process (the ancestor of all processes) begins with a full bounding "
"set.  If file capabilities are not compiled into the kernel, then B<init> "
"begins with a full bounding set minus B<CAP_SETPCAP>, because this "
"capability has a different meaning when there are no file capabilities."
msgstr ""
"バウンディングセットからのケーパビリティの削除がサポートされるのは、\n"
"カーネルのコンパイル時にファイルケーパビリティが有効になっている場合\n"
"だけである。Linux 2.6.33 より前のカーネルでは、ファイルケーパビリティは\n"
"設定オプション B<CONFIG_SECURITY_FILE_CAPABILITIES> で切り替えられる追加の\n"
"機能であった。Linux 2.6.33 以降では、この設定オプションは削除され、\n"
"ファイルケーパビリティは常にカーネルに組込まれるようになった。\n"
"ファイルケーパビリティがカーネルにコンパイル時に組み込まれている場合、\n"
"(全てのプロセスの先祖である) I<init> プロセスはバウンディングセットで\n"
"全てのケーパビリティが セットされた状態で開始する。ファイルケーパビリティ\n"
"が有効になっていない場合には、 I<init> はバウンディングセットで\n"
"B<CAP_SETPCAP> 以外の全てのケーパビリティがセットされた状態で開始する。\n"
"このようになっているのは、 B<CAP_SETPCAP> ケーパビリティがファイルケー\n"
"パビリティがサポートされていない場合には 違った意味を持つからである。"

#. type: Plain text
#: build/C/man7/capabilities.7:1442
#, fuzzy
#| msgid ""
#| "Removing a capability from the bounding set does not remove it from the "
#| "thread's inherited set.  However it does prevent the capability from "
#| "being added back into the thread's inherited set in the future."
msgid ""
"Removing a capability from the bounding set does not remove it from the "
"thread's inheritable set.  However it does prevent the capability from being "
"added back into the thread's inheritable set in the future."
msgstr ""
"バウンディングセットからケーパビリティを削除しても、 スレッドの継承可能セット"
"からはそのケーパビリティは削除されない。 しかしながら、バウンディングセットか"
"らの削除により、 この先そのケーパビリティをスレッドの継承可能セットに追加する"
"こと はできなくなる。"

#. type: Plain text
#: build/C/man7/capabilities.7:1444
msgid "B<Capability bounding set prior to Linux 2.6.25>"
msgstr "B<Linux 2.6.25 より前のケーパビリティバウンディングセット>"

#. type: Plain text
#: build/C/man7/capabilities.7:1452
msgid ""
"In kernels before 2.6.25, the capability bounding set is a system-wide "
"attribute that affects all threads on the system.  The bounding set is "
"accessible via the file I</proc/sys/kernel/cap-bound>.  (Confusingly, this "
"bit mask parameter is expressed as a signed decimal number in I</proc/sys/"
"kernel/cap-bound>.)"
msgstr ""
"2.6.25 より前のカーネルでは、ケーパビリティバウンディングセットは システム共"
"通の属性で、システム上の全てのスレッドに適用される。 バウンディングセットは "
"I</proc/sys/kernel/cap-bound> ファイル経由で参照できる。 (間違えやすいが、こ"
"のビットマスク形式のパラメーターは、 I</proc/sys/kernel/cap-bound> では符号付"
"きの十進数で表現される。)"

#. type: Plain text
#: build/C/man7/capabilities.7:1459
#, fuzzy
#| msgid ""
#| "Only the B<init> process may set capabilities in the capability bounding "
#| "set; other than that, the superuser (more precisely: programs with the "
#| "B<CAP_SYS_MODULE> capability) may only clear capabilities from this set."
msgid ""
"Only the B<init> process may set capabilities in the capability bounding "
"set; other than that, the superuser (more precisely: a process with the "
"B<CAP_SYS_MODULE> capability) may only clear capabilities from this set."
msgstr ""
"B<init> プロセスだけがケーパビリティバウンディングセットで ケーパビリティを"
"セットすることができる。 それ以外では、スーパーユーザー (より正確には、 "
"B<CAP_SYS_MODULE> ケーパビリティを持ったプログラム) が、 ケーパビリティバウン"
"ディングセットのケーパビリティのクリアが できるだけである。"

#. type: Plain text
#: build/C/man7/capabilities.7:1468
msgid ""
"On a standard system the capability bounding set always masks out the "
"B<CAP_SETPCAP> capability.  To remove this restriction (dangerous!), modify "
"the definition of B<CAP_INIT_EFF_SET> in I<include/linux/capability.h> and "
"rebuild the kernel."
msgstr ""
"通常のシステムでは、ケーパビリティバウンディングセットは、 B<CAP_SETPCAP> が"
"無効になっている。 この制限を取り去るには (取り去るのは危険!)、 I<include/"
"linux/capability.h> 内の B<CAP_INIT_EFF_SET> の定義を修正し、カーネルを再構築"
"する必要がある。"

#. type: Plain text
#: build/C/man7/capabilities.7:1474
msgid ""
"The system-wide capability bounding set feature was added to Linux starting "
"with kernel version 2.2.11."
msgstr ""
"システム共通のケーパビリティバウンディングセット機能は、 カーネル 2.2.11 以降"
"で Linux に追加された。"

#. type: SS
#: build/C/man7/capabilities.7:1474
#, no-wrap
msgid "Effect of user ID changes on capabilities"
msgstr "ユーザー ID 変更のケーパビリティへの影響"

#. type: Plain text
#: build/C/man7/capabilities.7:1483
msgid ""
"To preserve the traditional semantics for transitions between 0 and nonzero "
"user IDs, the kernel makes the following changes to a thread's capability "
"sets on changes to the thread's real, effective, saved set, and filesystem "
"user IDs (using B<setuid>(2), B<setresuid>(2), or similar):"
msgstr ""
"ユーザー ID が 0 と 0 以外の間で変化する際の振る舞いを従来と同じにするため、 "
"スレッドの実 UID、実効 UID、保存 set-user-ID、ファイルシステム UID が "
"(B<setuid>(2), B<setresuid>(2)  などを使って) 変更された際に、カーネルはその"
"スレッドのケーパビリティセットに 以下の変更を行う:"

#. type: Plain text
#: build/C/man7/capabilities.7:1489
#, fuzzy
#| msgid ""
#| "If one or more of the real, effective or saved set user IDs was "
#| "previously 0, and as a result of the UID changes all of these IDs have a "
#| "nonzero value, then all capabilities are cleared from the permitted and "
#| "effective capability sets."
msgid ""
"If one or more of the real, effective or saved set user IDs was previously "
"0, and as a result of the UID changes all of these IDs have a nonzero value, "
"then all capabilities are cleared from the permitted, effective, and ambient "
"capability sets."
msgstr ""
"UID の変更前には実 UID、実効 UID、保存 set-user-ID のうち 少なくとも一つが 0 "
"で、変更後に実 UID、実効 UID、保存 set-user-ID が すべて 0 以外の値になった場"
"合、許可と実効のケーパビリティセットの 全ケーパビリティをクリアする。"

#. type: Plain text
#: build/C/man7/capabilities.7:1492
msgid ""
"If the effective user ID is changed from 0 to nonzero, then all capabilities "
"are cleared from the effective set."
msgstr ""
"実効 UID が 0 から 0 以外に変更された場合、 実効ケーパビリティセットの全ケー"
"パビリティをクリアする。"

#. type: Plain text
#: build/C/man7/capabilities.7:1495
msgid ""
"If the effective user ID is changed from nonzero to 0, then the permitted "
"set is copied to the effective set."
msgstr ""
"実効 UID が 0 以外から 0 に変更された場合、 許可ケーパビリティセットの内容を"
"実効ケーパビリティセットにコピーする。"

#. type: IP
#: build/C/man7/capabilities.7:1495 build/C/man7/capabilities.7:1550
#: build/C/man7/cgroups.7:596 build/C/man7/cgroups.7:1813
#, no-wrap
msgid "4."
msgstr "4."

#. type: Plain text
#: build/C/man7/capabilities.7:1513
msgid ""
"If the filesystem user ID is changed from 0 to nonzero (see B<setfsuid>(2)), "
"then the following capabilities are cleared from the effective set: "
"B<CAP_CHOWN>, B<CAP_DAC_OVERRIDE>, B<CAP_DAC_READ_SEARCH>, B<CAP_FOWNER>, "
"B<CAP_FSETID>, B<CAP_LINUX_IMMUTABLE> (since Linux 2.6.30), "
"B<CAP_MAC_OVERRIDE>, and B<CAP_MKNOD> (since Linux 2.6.30).  If the "
"filesystem UID is changed from nonzero to 0, then any of these capabilities "
"that are enabled in the permitted set are enabled in the effective set."
msgstr ""
"ファイルシステム UID が 0 から 0 以外に変更された場合 (B<setfsuid>(2)  参"
"照)、実効ケーパビリティセットの以下のケーパビリティがクリアされる: "
"B<CAP_CHOWN>, B<CAP_DAC_OVERRIDE>, B<CAP_DAC_READ_SEARCH>, B<CAP_FOWNER>, "
"B<CAP_FSETID>, B<CAP_LINUX_IMMUTABLE> (Linux 2.6.30 以降), "
"B<CAP_MAC_OVERRIDE>, B<CAP_MKNOD> (Linux 2.6.30 以降)。 ファイルシステム UID "
"が 0 以外から 0 に変更された場合、 上記のケーパビリティのうち許可ケーパビリ"
"ティセットで有効になっているものが 実効ケーパビリティセットで有効にされる。"

#. type: Plain text
#: build/C/man7/capabilities.7:1520
#, fuzzy
#| msgid ""
#| "If a thread that has a 0 value for one or more of its user IDs wants to "
#| "prevent its permitted capability set being cleared when it resets all of "
#| "its user IDs to nonzero values, it can do so using the B<prctl>(2)  "
#| "B<PR_SET_KEEPCAPS> operation."
msgid ""
"If a thread that has a 0 value for one or more of its user IDs wants to "
"prevent its permitted capability set being cleared when it resets all of its "
"user IDs to nonzero values, it can do so using the B<SECBIT_KEEP_CAPS> "
"securebits flag described below."
msgstr ""
"各種 UID のうち少なくとも一つが 0 であるスレッドが、 その UID の全てが 0 以外"
"になったときに許可ケーパビリティセットが クリアされないようにしたい場合に"
"は、 B<prctl>(2)  の B<PR_SET_KEEPCAPS> 操作を使えばよい。"

#. type: SS
#: build/C/man7/capabilities.7:1520
#, no-wrap
msgid "Programmatically adjusting capability sets"
msgstr "プログラムでケーパビリティセットを調整する"

#. type: Plain text
#: build/C/man7/capabilities.7:1536
#, fuzzy
#| msgid ""
#| "A thread can retrieve and change its capability sets using the "
#| "B<capget>(2)  and B<capset>(2)  system calls.  However, the use of "
#| "B<cap_get_proc>(3)  and B<cap_set_proc>(3), both provided in the "
#| "I<libcap> package, is preferred for this purpose.  The following rules "
#| "govern changes to the thread capability sets:"
msgid ""
"A thread can retrieve and change its permitted, effective, and inheritable "
"capability sets using the B<capget>(2)  and B<capset>(2)  system calls.  "
"However, the use of B<cap_get_proc>(3)  and B<cap_set_proc>(3), both "
"provided in the I<libcap> package, is preferred for this purpose.  The "
"following rules govern changes to the thread capability sets:"
msgstr ""
"各スレッドは、 B<capget>(2)  や B<capset>(2)  を使って、自身のケーパビリティ"
"セットを取得したり変更したりできる。 ただし、これを行うには、 I<libcap> パッ"
"ケージで提供されている B<cap_get_proc>(3)  や B<cap_set_proc>(3)  を使うのが"
"望ましい。 スレッドのケーパビリティセットの変更には以下のルールが適用される。"

#. type: Plain text
#: build/C/man7/capabilities.7:1542
msgid ""
"If the caller does not have the B<CAP_SETPCAP> capability, the new "
"inheritable set must be a subset of the combination of the existing "
"inheritable and permitted sets."
msgstr ""
"呼び出し側が B<CAP_SETPCAP> ケーパビリティを持っていない場合、新しい継承可能"
"セットは、 既存の継承可能セットと許可セットの積集合 (AND) の部分集合で なけれ"
"ばならない。"

#. type: Plain text
#: build/C/man7/capabilities.7:1546
msgid ""
"(Since Linux 2.6.25)  The new inheritable set must be a subset of the "
"combination of the existing inheritable set and the capability bounding set."
msgstr ""
"(Linux 2.6.25 以降)  新しい継承可能セットは、既存の継承可能セットとケーパビリ"
"ティ バウンディングセットの積集合 (AND) の部分集合でなければならない。"

#. type: Plain text
#: build/C/man7/capabilities.7:1550
msgid ""
"The new permitted set must be a subset of the existing permitted set (i.e., "
"it is not possible to acquire permitted capabilities that the thread does "
"not currently have)."
msgstr ""
"新しい許可セットは、既存の許可セットの部分集合でなければならない (つまり、そ"
"のスレッドが現在持っていない許可ケーパビリティを 獲得することはできない)。"

#. type: Plain text
#: build/C/man7/capabilities.7:1552
msgid "The new effective set must be a subset of the new permitted set."
msgstr ""
"新しい実効ケーパビリティセットは新しい許可ケーパビリティセットの 部分集合に"
"なっていなければならない。"

#. type: SS
#: build/C/man7/capabilities.7:1552
#, no-wrap
msgid "The securebits flags: establishing a capabilities-only environment"
msgstr "securebits フラグ: ケーパビリティだけの環境を構築する"

#.  For some background:
#.        see http://lwn.net/Articles/280279/ and
#.        http://article.gmane.org/gmane.linux.kernel.lsm/5476/
#. type: Plain text
#: build/C/man7/capabilities.7:1563
msgid ""
"Starting with kernel 2.6.26, and with a kernel in which file capabilities "
"are enabled, Linux implements a set of per-thread I<securebits> flags that "
"can be used to disable special handling of capabilities for UID 0 "
"(I<root>).  These flags are as follows:"
msgstr ""
"カーネル 2.6.26 以降で、 ファイルケーパビリティが有効になったカーネルでは、 "
"スレッド単位の I<securebits> フラグが実装されており、このフラグを使うと UID "
"0 (I<root>)  に対するケーパビリティの特別扱いを無効することができる。 以下の"
"ようなフラグがある。"

#. type: TP
#: build/C/man7/capabilities.7:1563
#, no-wrap
msgid "B<SECBIT_KEEP_CAPS>"
msgstr "B<SECBIT_KEEP_CAPS>"

#. type: Plain text
#: build/C/man7/capabilities.7:1572
#, fuzzy
#| msgid ""
#| "Setting this flag allows a thread that has one or more 0 UIDs to retain "
#| "its capabilities when it switches all of its UIDs to a nonzero value.  If "
#| "this flag is not set, then such a UID switch causes the thread to lose "
#| "all capabilities.  This flag is always cleared on an B<execve>(2).  (This "
#| "flag provides the same functionality as the older B<prctl>(2)  "
#| "B<PR_SET_KEEPCAPS> operation.)"
msgid ""
"Setting this flag allows a thread that has one or more 0 UIDs to retain "
"capabilities in its permitted set when it switches all of its UIDs to "
"nonzero values.  If this flag is not set, then such a UID switch causes the "
"thread to lose all permitted capabilities.  This flag is always cleared on "
"an B<execve>(2)."
msgstr ""
"このフラグをセットされている場合、UID が 0 のスレッドの UID が 0 以外の値に "
"切り替わる際に、そのスレッドはケーパビリティを維持することができる。 このフラ"
"グがセットされていない場合には、UID が 0 から 0 以外の値に 切り替わると、その"
"スレッドは全てのケーパビリティを失う。 このフラグは B<execve>(2)  時には全て"
"クリアされる (このフラグは、以前の B<prctl>(2)  の B<PR_SET_KEEPCAPS> 操作と"
"同じ機能を提供するものである)。"

#. type: Plain text
#: build/C/man7/capabilities.7:1581
msgid ""
"Note that even with the B<SECBIT_KEEP_CAPS> flag set, the effective "
"capabilities of a thread are cleared when it switches its effective UID to a "
"nonzero value.  However, if the thread has set this flag and its effective "
"UID is already nonzero, and the thread subsequently switches all other UIDs "
"to nonzero values, then the effective capabilities will not be cleared."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1588
msgid ""
"The setting of the B<SECBIT_KEEP_CAPS> flag is ignored if the "
"B<SECBIT_NO_SETUID_FIXUP> flag is set.  (The latter flag provides a superset "
"of the effect of the former flag.)"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1593
msgid ""
"This flag provides the same functionality as the older B<prctl>(2)  "
"B<PR_SET_KEEPCAPS> operation."
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:1593
#, no-wrap
msgid "B<SECBIT_NO_SETUID_FIXUP>"
msgstr "B<SECBIT_NO_SETUID_FIXUP>"

#. type: Plain text
#: build/C/man7/capabilities.7:1601
#, fuzzy
#| msgid ""
#| "Setting this flag stops the kernel from adjusting capability sets when "
#| "the threads's effective and filesystem UIDs are switched between zero and "
#| "nonzero values.  (See the subsection I<Effect of User ID Changes on "
#| "Capabilities>.)"
msgid ""
"Setting this flag stops the kernel from adjusting the process's permitted, "
"effective, and ambient capability sets when the thread's effective and "
"filesystem UIDs are switched between zero and nonzero values.  (See the "
"subsection I<Effect of user ID changes on capabilities>.)"
msgstr ""
"このフラグをセットすると、スレッドの実効 UID とファイルシステム UID が 0 と "
"0 以外の間で切り替わった場合に、 カーネルはケーパビリティセットの調整を行わな"
"くなる (「ユーザー ID 変更のケーパビリティへの影響」の節を参照)。"

#. type: TP
#: build/C/man7/capabilities.7:1601
#, no-wrap
msgid "B<SECBIT_NOROOT>"
msgstr "B<SECBIT_NOROOT>"

#. type: Plain text
#: build/C/man7/capabilities.7:1609
msgid ""
"If this bit is set, then the kernel does not grant capabilities when a set-"
"user-ID-root program is executed, or when a process with an effective or "
"real UID of 0 calls B<execve>(2).  (See the subsection I<Capabilities and "
"execution of programs by root>.)"
msgstr ""
"このビットがセットされている場合、 set-user-ID-root プログラムの実行時や、 実"
"効 UID か 実 UID が 0 のプロセスが B<execve>(2)  を呼び出した時に、カーネルは"
"ケーパビリティを許可しない (「ケーパビリティと、ルートによるプログラムの実"
"行」の節を参照)。"

#. type: TP
#: build/C/man7/capabilities.7:1609
#, no-wrap
msgid "B<SECBIT_NO_CAP_AMBIENT_RAISE>"
msgstr "B<SECBIT_NO_CAP_AMBIENT_RAISE>"

#. type: Plain text
#: build/C/man7/capabilities.7:1615
msgid ""
"Setting this flag disallows raising ambient capabilities via the "
"B<prctl>(2)  B<PR_CAP_AMBIENT_RAISE> operation."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1626
#, fuzzy
#| msgid ""
#| "Each of the above \"base\" flags has a companion \"locked\" flag.  "
#| "Setting any of the \"locked\" flags is irreversible, and has the effect "
#| "of preventing further changes to the corresponding \"base\" flag.  The "
#| "locked flags are: B<SECBIT_KEEP_CAPS_LOCKED>, "
#| "B<SECBIT_NO_SETUID_FIXUP_LOCKED>, and B<SECBIT_NOROOT_LOCKED>."
msgid ""
"Each of the above \"base\" flags has a companion \"locked\" flag.  Setting "
"any of the \"locked\" flags is irreversible, and has the effect of "
"preventing further changes to the corresponding \"base\" flag.  The locked "
"flags are: B<SECBIT_KEEP_CAPS_LOCKED>, B<SECBIT_NO_SETUID_FIXUP_LOCKED>, "
"B<SECBIT_NOROOT_LOCKED>, and B<SECBIT_NO_CAP_AMBIENT_RAISE_LOCKED>."
msgstr ""
"上記の \"base\" フラグの各々には対応する \"locked\" フラグが存在する。 いずれ"
"の \"locked\" フラグも一度セットされると戻すことはできず、 それ以降は対応す"
"る \"base\" フラグを変更することができなくなる。 \"locked\" フラグは "
"B<SECBIT_KEEP_CAPS_LOCKED>, B<SECBIT_NO_SETUID_FIXUP_LOCKED>, "
"B<SECBIT_NOROOT_LOCKED> という名前である。"

#. type: Plain text
#: build/C/man7/capabilities.7:1643
#, fuzzy
#| msgid ""
#| "The I<securebits> flags can be modified and retrieved using the "
#| "B<prctl>(2)  B<PR_SET_SECUREBITS> and B<PR_GET_SECUREBITS> operations.  "
#| "The B<CAP_SETPCAP> capability is required to modify the flags."
msgid ""
"The I<securebits> flags can be modified and retrieved using the B<prctl>(2)  "
"B<PR_SET_SECUREBITS> and B<PR_GET_SECUREBITS> operations.  The "
"B<CAP_SETPCAP> capability is required to modify the flags.  Note that the "
"B<SECBIT_*> constants are available only after including the I<E<lt>linux/"
"securebits.hE<gt>> header file."
msgstr ""
"I<securebits> フラグは、 B<prctl>(2)  の操作 B<PR_SET_SECUREBITS> や "
"B<PR_GET_SECUREBITS> を使うことで変更したり取得したりできる。 フラグを変更す"
"るには B<CAP_SETPCAP> ケーパビリティが必要である。"

#. type: Plain text
#: build/C/man7/capabilities.7:1652
msgid ""
"The I<securebits> flags are inherited by child processes.  During an "
"B<execve>(2), all of the flags are preserved, except B<SECBIT_KEEP_CAPS> "
"which is always cleared."
msgstr ""
"I<securebits> フラグは子プロセスに継承される。 B<execve>(2) においては、\n"
"B<SECBIT_KEEP_CAPS> が常にクリアされる以外は、全てのフラグが保持される。"

#. type: Plain text
#: build/C/man7/capabilities.7:1657
msgid ""
"An application can use the following call to lock itself, and all of its "
"descendants, into an environment where the only way of gaining capabilities "
"is by executing a program with associated file capabilities:"
msgstr ""
"アプリケーションは、以下の呼び出しを行うことにより、 自分自身および子孫となる"
"プロセス全てに対して、 必要なファイルケーパビリティを持ったプログラムを実行し"
"ない限り、 対応するケーパビリティを獲得できないような状況に閉じこめることがで"
"きる。"

#. type: Plain text
#: build/C/man7/capabilities.7:1669
#, no-wrap
msgid ""
"prctl(PR_SET_SECUREBITS,\n"
"        /* SECBIT_KEEP_CAPS off */\n"
"        SECBIT_KEEP_CAPS_LOCKED |\n"
"        SECBIT_NO_SETUID_FIXUP |\n"
"        SECBIT_NO_SETUID_FIXUP_LOCKED |\n"
"        SECBIT_NOROOT |\n"
"        SECBIT_NOROOT_LOCKED);\n"
"        /* Setting/locking SECBIT_NO_CAP_AMBIENT_RAISE\n"
"           is not required */\n"
msgstr ""
"prctl(PR_SET_SECUREBITS,\n"
"        /* SECBIT_KEEP_CAPS off */\n"
"        SECBIT_KEEP_CAPS_LOCKED |\n"
"        SECBIT_NO_SETUID_FIXUP |\n"
"        SECBIT_NO_SETUID_FIXUP_LOCKED |\n"
"        SECBIT_NOROOT |\n"
"        SECBIT_NOROOT_LOCKED);\n"
"        /* Setting/locking SECBIT_NO_CAP_AMBIENT_RAISE\n"
"           is not required */\n"

#. type: SS
#: build/C/man7/capabilities.7:1673
#, fuzzy, no-wrap
#| msgid "Set-user-ID and set-group-ID programs"
msgid "Per-user-namespace \"set-user-ID-root\" programs"
msgstr "set-user-ID や set-group-ID されたプログラム"

#. type: Plain text
#: build/C/man7/capabilities.7:1679
msgid ""
"A set-user-ID program whose UID matches the UID that created a user "
"namespace will confer capabilities in the process's permitted and effective "
"sets when executed by any process inside that namespace or any descendant "
"user namespace."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1690
msgid ""
"The rules about the transformation of the process's capabilities during the "
"B<execve>(2)  are exactly as described in the subsections I<Transformation "
"of capabilities during execve()> and I<Capabilities and execution of "
"programs by root>, with the difference that, in the latter subsection, \"root"
"\" is the UID of the creator of the user namespace."
msgstr ""

#. type: SS
#: build/C/man7/capabilities.7:1690
#, fuzzy, no-wrap
#| msgid "Set file capabilities."
msgid "Namespaced file capabilities"
msgstr "ファイルケーパビリティを設定する。"

#.  commit 8db6c34f1dbc8e06aa016a9b829b06902c3e1340
#. type: Plain text
#: build/C/man7/capabilities.7:1698
msgid ""
"Traditional (i.e., version 2) file capabilities associate only a set of "
"capability masks with a binary executable file.  When a process executes a "
"binary with such capabilities, it gains the associated capabilities (within "
"its user namespace)  as per the rules described above in \"Transformation of "
"capabilities during execve()\"."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1711
msgid ""
"Because version 2 file capabilities confer capabilities to the executing "
"process regardless of which user namespace it resides in, only privileged "
"processes are permitted to associate capabilities with a file.  Here, "
"\"privileged\" means a process that has the B<CAP_SETFCAP> capability in the "
"user namespace where the filesystem was mounted (normally the initial user "
"namespace).  This limitation renders file capabilities useless for certain "
"use cases.  For example, in user-namespaced containers, it can be desirable "
"to be able to create a binary that confers capabilities only to processes "
"executed inside that container, but not to processes that are executed "
"outside the container."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1725
msgid ""
"Linux 4.14 added so-called namespaced file capabilities to support such use "
"cases.  Namespaced file capabilities are recorded as version 3 (i.e., "
"B<VFS_CAP_REVISION_3>)  I<security.capability> extended attributes.  Such an "
"attribute is automatically created in the circumstances described above "
"under \"File capability extended attribute versioning\".  When a version 3 "
"I<security.capability> extended attribute is created, the kernel records not "
"just the capability masks in the extended attribute, but also the namespace "
"root user ID."
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1738
msgid ""
"As with a binary that has B<VFS_CAP_REVISION_2> file capabilities, a binary "
"with B<VFS_CAP_REVISION_3> file capabilities confers capabilities to a "
"process during B<execve>().  However, capabilities are conferred only if the "
"binary is executed by a process that resides in a user namespace whose UID 0 "
"maps to the root user ID that is saved in the extended attribute, or when "
"executed by a process that resides in a descendant of such a namespace."
msgstr ""

#. type: SS
#: build/C/man7/capabilities.7:1738
#, no-wrap
msgid "Interaction with user namespaces"
msgstr "ユーザー名前空間との相互作用"

#. type: Plain text
#: build/C/man7/capabilities.7:1742
#, fuzzy
#| msgid ""
#| "For a discussion of the interaction of capabilities and user namespaces, "
#| "see B<user_namespaces>(7)."
msgid ""
"For further information on the interaction of capabilities and user "
"namespaces, see B<user_namespaces>(7)."
msgstr ""
"ケーパリビティとユーザー名前空間の相互の影響に関する議論は "
"B<user_namespaces>(7) を参照。"

#. type: Plain text
#: build/C/man7/capabilities.7:1747
#, fuzzy
#| msgid ""
#| "No standards govern capabilities, but the Linux capability implementation "
#| "is based on the withdrawn POSIX.1e draft standard; see E<.UR http://wt."
#| "tuxomania.net\\:/publications\\:/posix.1e/> E<.UE .>"
msgid ""
"No standards govern capabilities, but the Linux capability implementation is "
"based on the withdrawn POSIX.1e draft standard; see E<.UR https://archive.org"
"\\:/details\\:/posix_1003.1e-990310> E<.UE .>"
msgstr ""
"ケーパビリティに関する標準はないが、 Linux のケーパビリティは廃案になった "
"POSIX.1e 草案に基づいて実装されている。 E<.UR http://wt.xpilot.org\\:/"
"publications\\:/posix.1e/> E<.UE> を参照。"

#. type: Plain text
#: build/C/man7/capabilities.7:1755
msgid ""
"When attempting to B<strace>(1)  binaries that have capabilities (or set-"
"user-ID-root binaries), you may find the I<-u E<lt>usernameE<gt>> option "
"useful.  Something like:"
msgstr ""

#. type: Plain text
#: build/C/man7/capabilities.7:1759
#, no-wrap
msgid "$ B<sudo strace -o trace.log -u ceci ./myprivprog>\n"
msgstr ""

#.  commit 5915eb53861c5776cfec33ca4fcc1fd20d66dd27 removed
#.  CONFIG_SECURITY_CAPABILITIES
#. type: Plain text
#: build/C/man7/capabilities.7:1769
#, fuzzy
#| msgid ""
#| "Since kernel 2.5.27, capabilities are an optional kernel component, and "
#| "can be enabled/disabled via the B<CONFIG_SECURITY_CAPABILITIES> kernel "
#| "configuration option."
msgid ""
"From kernel 2.5.27 to kernel 2.6.26, capabilities were an optional kernel "
"component, and could be enabled/disabled via the "
"B<CONFIG_SECURITY_CAPABILITIES> kernel configuration option."
msgstr ""
"カーネル 2.5.27 以降、ケーパビリティは選択式のカーネルコンポーネント となって"
"おり、カーネル設定オプション B<CONFIG_SECURITY_CAPABILITIES> により有効/無効"
"を切り替えることができる。"

#.  7b9a7ec565505699f503b4fcf61500dceb36e744
#. type: Plain text
#: build/C/man7/capabilities.7:1783
#, fuzzy
#| msgid ""
#| "The I</proc/PID/task/TID/status> file can be used to view the capability "
#| "sets of a thread.  The I</proc/PID/status> file shows the capability sets "
#| "of a process's main thread.  Before Linux 3.8, nonexistent capabilities "
#| "were shown as being enabled (1) in these sets.  Since Linux 3.8, all "
#| "nonexistent capabilities (above B<CAP_LAST_CAP>)  are shown as disabled "
#| "(0)."
msgid ""
"The I</proc/[pid]/task/TID/status> file can be used to view the capability "
"sets of a thread.  The I</proc/[pid]/status> file shows the capability sets "
"of a process's main thread.  Before Linux 3.8, nonexistent capabilities were "
"shown as being enabled (1) in these sets.  Since Linux 3.8, all nonexistent "
"capabilities (above B<CAP_LAST_CAP>)  are shown as disabled (0)."
msgstr ""
"I</proc/PID/task/TID/status> ファイルを使うと、スレッドのケーパビリティセット"
"を見ることができる。 I</proc/PID/status> ファイルには、プロセスのメインスレッ"
"ドのケーパビリティセットが表示される。 Linux 3.8 より前では、 これらのケーパ"
"ビリティセットの表示で、 存在しないケーパビリティはすべて有効 (1) として表示"
"される。 Linux 3.8 以降では、 存在しないケーパビリティはすべて無効 (0) として"
"表示される。 (B<CAP_LAST_CAP> より大きい値を持つケーパビリティが存在しない"
"ケーパビリティである)。"

#. type: Plain text
#: build/C/man7/capabilities.7:1798
msgid ""
"The I<libcap> package provides a suite of routines for setting and getting "
"capabilities that is more comfortable and less likely to change than the "
"interface provided by B<capset>(2)  and B<capget>(2).  This package also "
"provides the B<setcap>(8)  and B<getcap>(8)  programs.  It can be found at"
msgstr ""
"I<libcap> パッケージは、ケーパビリティを設定・取得するための ルーチン群を提供"
"している。これらのインターフェースは、 B<capset>(2)  と B<capget>(2)  が提供"
"するインターフェースと比べて、より使いやすく、変更される可能性が少ない。 この"
"パッケージでは、 B<setcap>(8), B<getcap>(8)  というプログラムも提供されてい"
"る。 パッケージは以下で入手できる。"

#. type: Plain text
#: build/C/man7/capabilities.7:1801
msgid ""
"E<.UR https://git.kernel.org\\:/pub\\:/scm\\:/libs\\:/libcap\\:/libcap.git"
"\\:/refs/> E<.UE .>"
msgstr "E<.UR https://git.kernel.org\\:/pub\\:/scm\\:/libs\\:/libcap\\:/libcap.git\\:/refs/> E<.UE .>"

#. type: Plain text
#: build/C/man7/capabilities.7:1810
#, fuzzy
#| msgid ""
#| "Before kernel 2.6.24, and since kernel 2.6.24 if file capabilities are "
#| "not enabled, a thread with the B<CAP_SETPCAP> capability can manipulate "
#| "the capabilities of threads other than itself.  However, this is only "
#| "theoretically possible, since no thread ever has B<CAP_SETPCAP> in either "
#| "of these cases:"
msgid ""
"Before kernel 2.6.24, and from kernel 2.6.24 to kernel 2.6.32 if file "
"capabilities are not enabled, a thread with the B<CAP_SETPCAP> capability "
"can manipulate the capabilities of threads other than itself.  However, this "
"is only theoretically possible, since no thread ever has B<CAP_SETPCAP> in "
"either of these cases:"
msgstr ""
"バージョン 2.6.24 より前、およびファイルケーパビリティが 有効になっていない"
"2.6.24 以降のカーネルでは、 B<CAP_SETPCAP> ケーパビリティを持ったスレッドは自"
"分以外のスレッドの ケーパビリティを操作できる。 しかしながら、これは理論的に"
"可能というだけである。 以下のいずれかの場合においても、どのスレッドも "
"B<CAP_SETPCAP> ケーパビリティを持つことはないからである。"

#. type: Plain text
#: build/C/man7/capabilities.7:1817
#, fuzzy
#| msgid ""
#| "In the pre-2.6.25 implementation the system-wide capability bounding set, "
#| "I</proc/sys/kernel/cap-bound>, always masks out this capability, and this "
#| "can not be changed without modifying the kernel source and rebuilding."
msgid ""
"In the pre-2.6.25 implementation the system-wide capability bounding set, I</"
"proc/sys/kernel/cap-bound>, always masks out the B<CAP_SETPCAP> capability, "
"and this can not be changed without modifying the kernel source and "
"rebuilding the kernel."
msgstr ""
"2.6.25 より前の実装では、システム共通のケーパビリティバウンディングセット I</"
"proc/sys/kernel/cap-bound> ではこのケーパビリティは常に無効になっており、 "
"ソースを変更してカーネルを再コンパイルしない限り、 これを変更することはできな"
"い。"

#. type: Plain text
#: build/C/man7/capabilities.7:1827
#, fuzzy
#| msgid ""
#| "If file capabilities are disabled in the current implementation, then "
#| "B<init> starts out with this capability removed from its per-process "
#| "bounding set, and that bounding set is inherited by all other processes "
#| "created on the system."
msgid ""
"If file capabilities are disabled (i.e., the kernel "
"B<CONFIG_SECURITY_FILE_CAPABILITIES> option is disabled), then B<init> "
"starts out with the B<CAP_SETPCAP> capability removed from its per-process "
"bounding set, and that bounding set is inherited by all other processes "
"created on the system."
msgstr ""
"現在の実装ではファイルケーパビリティが無効になっている場合、 プロセス毎のバウ"
"ンディングセットからこのケーパビリティを抜いて B<init> は開始され、 システム"
"上で生成される他の全てのプロセスでこのバウンディングセットが 継承される。"

#.  from libcap-ng
#.  from libcap-ng
#.  from libcap-ng
#.  from libcap-ng
#. type: Plain text
#: build/C/man7/capabilities.7:1852
msgid ""
"B<capsh>(1), B<setpriv>(1), B<prctl>(2), B<setfsuid>(2), B<cap_clear>(3), "
"B<cap_copy_ext>(3), B<cap_from_text>(3), B<cap_get_file>(3), "
"B<cap_get_proc>(3), B<cap_init>(3), B<capgetp>(3), B<capsetp>(3), "
"B<libcap>(3), B<proc>(5), B<credentials>(7), B<pthreads>(7), "
"B<user_namespaces>(7), B<captest>(8), B<filecap>(8), B<getcap>(8), "
"B<getpcaps>(8), B<netcap>(8), B<pscap>(8), B<setcap>(8)"
msgstr "B<capsh>(1), B<setpriv>(1), B<prctl>(2), B<setfsuid>(2), B<cap_clear>(3), B<cap_copy_ext>(3), B<cap_from_text>(3), B<cap_get_file>(3), B<cap_get_proc>(3), B<cap_init>(3), B<capgetp>(3), B<capsetp>(3), B<libcap>(3), B<proc>(5), B<credentials>(7), B<pthreads>(7), B<user_namespaces>(7), B<captest>(8), B<filecap>(8), B<getcap>(8), B<getpcaps>(8), B<netcap>(8), B<pscap>(8), B<setcap>(8)"

#. type: Plain text
#: build/C/man7/capabilities.7:1855
msgid "I<include/linux/capability.h> in the Linux kernel source tree"
msgstr "Linux カーネルソース内の I<include/linux/capability.h>"

#. type: TH
#: build/C/man2/capget.2:16
#, no-wrap
msgid "CAPGET"
msgstr "CAPGET"

#. type: TH
#: build/C/man2/capget.2:16
#, no-wrap
msgid "2020-02-09"
msgstr "2020-02-09"

#. type: Plain text
#: build/C/man2/capget.2:19
msgid "capget, capset - set/get capabilities of thread(s)"
msgstr "capget, capset - スレッドのケーパビリティを設定/取得する"

#. type: Plain text
#: build/C/man2/capget.2:21
msgid "B<#include E<lt>sys/capability.hE<gt>>"
msgstr "B<#include E<lt>sys/capability.hE<gt>>"

#. type: Plain text
#: build/C/man2/capget.2:23
msgid ""
"B<int capget(cap_user_header_t >I<hdrp>B<, cap_user_data_t >I<datap>B<);>"
msgstr ""
"B<int capget(cap_user_header_t >I<hdrp>B<, cap_user_data_t >I<datap>B<);>"

#. type: Plain text
#: build/C/man2/capget.2:25
msgid ""
"B<int capset(cap_user_header_t >I<hdrp>B<, const cap_user_data_t "
">I<datap>B<);>"
msgstr ""
"B<int capset(cap_user_header_t >I<hdrp>B<, const cap_user_data_t "
">I<datap>B<);>"

#. type: Plain text
#: build/C/man2/capget.2:34
msgid ""
"These two system calls are the raw kernel interface for getting and setting "
"thread capabilities.  Not only are these system calls specific to Linux, but "
"the kernel API is likely to change and use of these system calls (in "
"particular the format of the I<cap_user_*_t> types) is subject to extension "
"with each kernel revision, but old programs will keep working."
msgstr ""
"この二つのシステムコールはスレッドのケーパビリティを取得したり設定したりする"
"ための 生のカーネルインターフェースである。 これらのシステムコールは Linux 特"
"有であるというだけでなく、 カーネル API は変更されるかもしれず、これらのシス"
"テムコールの使用法 (特に I<cap_user_*_t> 型という書式) はカーネルのリビジョン"
"毎に拡張されるかもしれないが、 以前のプログラムはそのまま動作する。"

#. type: Plain text
#: build/C/man2/capget.2:41
msgid ""
"The portable interfaces are B<cap_set_proc>(3)  and B<cap_get_proc>(3); if "
"possible, you should use those interfaces in applications."
msgstr "移植性のあるインターフェースは B<cap_set_proc>(3)  と B<cap_get_proc>(3)  である。 可能ならばアプリケーションはこれらの関数を使用すべきである。"

#. type: SS
#: build/C/man2/capget.2:41
#, no-wrap
msgid "Current details"
msgstr "現在の詳細"

#. type: Plain text
#: build/C/man2/capget.2:44
msgid ""
"Now that you have been warned, some current kernel details.  The structures "
"are defined as follows."
msgstr ""
"現在のカーネルの詳細について注意を述べておく。 構造体は以下のように定義され"
"る。"

#. type: Plain text
#: build/C/man2/capget.2:49
#, no-wrap
msgid ""
"#define _LINUX_CAPABILITY_VERSION_1  0x19980330\n"
"#define _LINUX_CAPABILITY_U32S_1     1\n"
msgstr ""
"#define _LINUX_CAPABILITY_VERSION_1  0x19980330\n"
"#define _LINUX_CAPABILITY_U32S_1     1\n"

#.  commit e338d263a76af78fe8f38a72131188b58fceb591
#.  Added 64 bit capability support
#. type: Plain text
#: build/C/man2/capget.2:55
#, no-wrap
msgid ""
"        /* V2 added in Linux 2.6.25; deprecated */\n"
"#define _LINUX_CAPABILITY_VERSION_2  0x20071026\n"
"#define _LINUX_CAPABILITY_U32S_2     2\n"
msgstr ""
"        /* V2 added in Linux 2.6.25; deprecated */\n"
"#define _LINUX_CAPABILITY_VERSION_2  0x20071026\n"
"#define _LINUX_CAPABILITY_U32S_2     2\n"

#.  commit ca05a99a54db1db5bca72eccb5866d2a86f8517f
#. type: Plain text
#: build/C/man2/capget.2:60
#, no-wrap
msgid ""
"        /* V3 added in Linux 2.6.26 */\n"
"#define _LINUX_CAPABILITY_VERSION_3  0x20080522\n"
"#define _LINUX_CAPABILITY_U32S_3     2\n"
msgstr ""
"        /* V3 added in Linux 2.6.26 */\n"
"#define _LINUX_CAPABILITY_VERSION_3  0x20080522\n"
"#define _LINUX_CAPABILITY_U32S_3     2\n"

#. type: Plain text
#: build/C/man2/capget.2:65
#, no-wrap
msgid ""
"typedef struct __user_cap_header_struct {\n"
"   __u32 version;\n"
"   int pid;\n"
"} *cap_user_header_t;\n"
msgstr ""
"typedef struct __user_cap_header_struct {\n"
"   __u32 version;\n"
"   int pid;\n"
"} *cap_user_header_t;\n"

#. type: Plain text
#: build/C/man2/capget.2:71
#, no-wrap
msgid ""
"typedef struct __user_cap_data_struct {\n"
"   __u32 effective;\n"
"   __u32 permitted;\n"
"   __u32 inheritable;\n"
"} *cap_user_data_t;\n"
msgstr ""
"typedef struct __user_cap_data_struct {\n"
"   __u32 effective;\n"
"   __u32 permitted;\n"
"   __u32 inheritable;\n"
"} *cap_user_data_t;\n"

#. type: Plain text
#: build/C/man2/capget.2:90
msgid ""
"The I<effective>, I<permitted>, and I<inheritable> fields are bit masks of "
"the capabilities defined in B<capabilities>(7).  Note that the B<CAP_*> "
"values are bit indexes and need to be bit-shifted before ORing into the bit "
"fields.  To define the structures for passing to the system call, you have "
"to use the I<struct __user_cap_header_struct> and I<struct "
"__user_cap_data_struct> names because the typedefs are only pointers."
msgstr ""
"フィールド I<effective>, I<permitted>, I<inheritable> は、 "
"B<capabilities>(7)  で定義されるケーパビリティのビットマスクである。 "
"I<CAP_*> はビット番号を表すインデックス値であり、 ビットフィールドに OR を行"
"う前に I<CAP_*> の値の分だけビットシフトを行う必要がある。 typedef の方はポイ"
"ンターなので、 このシステムコールに渡す構造体を定義するには、 I<struct "
"__user_cap_header_struct> と I<struct __user_cap_data_struct> という名前を使"
"用しなければならない。"

#. type: Plain text
#: build/C/man2/capget.2:99
#, fuzzy
#| msgid ""
#| "Kernels prior to 2.6.25 prefer 32-bit capabilities with version "
#| "B<_LINUX_CAPABILITY_VERSION_1>, and kernels 2.6.25+ prefer 64-bit "
#| "capabilities with version B<_LINUX_CAPABILITY_VERSION_2>.  Note, 64-bit "
#| "capabilities use I<datap>[0] and I<datap>[1], whereas 32-bit capabilities "
#| "use only I<datap>[0]."
msgid ""
"Kernels prior to 2.6.25 prefer 32-bit capabilities with version "
"B<_LINUX_CAPABILITY_VERSION_1>.  Linux 2.6.25 added 64-bit capability sets, "
"with version B<_LINUX_CAPABILITY_VERSION_2>.  There was, however, an API "
"glitch, and Linux 2.6.26 added B<_LINUX_CAPABILITY_VERSION_3> to fix the "
"problem."
msgstr ""
"カーネル 2.6.25 より前では、バージョン B<_LINUX_CAPABILITY_VERSION_1> の 32 "
"ビットケーパビリティが推奨である。 カーネル 2.6.25 以降では、バージョン "
"B<_LINUX_CAPABILITY_VERSION_2> の 64 ビットケーパビリティが推奨である。 64 "
"ビットケーパビリティでは I<datap>[0] と I<datap>[1] が使用されるのに対し、 "
"32 ビットケーパビリティでは I<datap>[0] だけが使用される。"

#. type: Plain text
#: build/C/man2/capget.2:106
msgid ""
"Note that 64-bit capabilities use I<datap[0]> and I<datap[1]>, whereas 32-"
"bit capabilities use only I<datap[0]>."
msgstr ""

#. type: Plain text
#: build/C/man2/capget.2:111
msgid ""
"On kernels that support file capabilities (VFS capabilities support), these "
"system calls behave slightly differently.  This support was added as an "
"option in Linux 2.6.24, and became fixed (nonoptional) in Linux 2.6.33."
msgstr ""

#. type: Plain text
#: build/C/man2/capget.2:118
msgid ""
"For B<capget>()  calls, one can probe the capabilities of any process by "
"specifying its process ID with the I<hdrp-E<gt>pid> field value."
msgstr ""
"B<capget>()  では、 I<hdrp-E<gt>pid> のフィールド値にケーパビリティを知りたい"
"プロセスのプロセス ID を 指定することで、任意のプロセスのケーパビリティを調べ"
"ることができる。"

#. type: Plain text
#: build/C/man2/capget.2:122
msgid "For details on the data, see B<capabilities>(7)."
msgstr "このデータの詳細は B<capabilities>(7)  を参照すること。"

#. type: SS
#: build/C/man2/capget.2:122
#, no-wrap
msgid "With VFS capabilities support"
msgstr "VFS ケーパビリティがサポートされている場合"

#. type: Plain text
#: build/C/man2/capget.2:135
#, fuzzy
#| msgid ""
#| "VFS Capability support creates a file-attribute method for adding "
#| "capabilities to privileged executables.  This privilege model obsoletes "
#| "kernel support for one process asynchronously setting the capabilities of "
#| "another.  That is, with VFS support, for B<capset>()  calls the only "
#| "permitted values for I<hdrp-E<gt>pid> are 0 or B<getpid>(2), which are "
#| "equivalent."
msgid ""
"VFS capabilities employ a file extended attribute (see B<xattr>(7))  to "
"allow capabilities to be attached to executables.  This privilege model "
"obsoletes kernel support for one process asynchronously setting the "
"capabilities of another.  That is, on kernels that have VFS capabilities "
"support, when calling B<capset>(), the only permitted values for I<hdrp-"
"E<gt>pid> are 0 or, equivalently, the value returned by B<gettid>(2)."
msgstr ""
"VFS ケーパビリティのサポートでは、特権実行ファイルにケーパビリティを 追加する"
"ためのファイル属性メソッドが作成された。 この特権モデルの導入により、あるプロ"
"セスにより別のプロセスのケーパビリティ を非同期に設定する機能のカーネルによる"
"サポートは廃止される。 つまり、VFS サポートでは、 B<capset>()  を呼び出す際"
"に I<hdrp-E<gt>pid> の値として許されるのは 0 と B<getpid>(2)  が返す値だけと"
"なる (どちらの値でも等価である)。"

#. type: SS
#: build/C/man2/capget.2:135
#, no-wrap
msgid "Without VFS capabilities support"
msgstr "VFS ケーパビリティがサポートされていない場合"

#. type: Plain text
#: build/C/man2/capget.2:165
#, fuzzy
#| msgid ""
#| "When the kernel does not support VFS capabilities, B<capset>()  calls can "
#| "operate on the capabilities of the thread specified by the I<pid> field "
#| "of I<hdrp> when that is nonzero, or on the capabilities of the calling "
#| "thread if I<pid> is 0.  If I<pid> refers to a single-threaded process, "
#| "then I<pid> can be specified as a traditional process ID; operating on a "
#| "thread of a multithreaded process requires a thread ID of the type "
#| "returned by B<gettid>(2).  For B<capset>(), I<pid> can also be: -1, "
#| "meaning perform the change on all threads except the caller and "
#| "B<init>(1); or a value less than -1, in which case the change is applied "
#| "to all members of the process group whose ID is -I<pid>."
msgid ""
"On older kernels that do not provide VFS capabilities support B<capset>()  "
"can, if the caller has the B<CAP_SETPCAP> capability, be used to change not "
"only the caller's own capabilities, but also the capabilities of other "
"threads.  The call operates on the capabilities of the thread specified by "
"the I<pid> field of I<hdrp> when that is nonzero, or on the capabilities of "
"the calling thread if I<pid> is 0.  If I<pid> refers to a single-threaded "
"process, then I<pid> can be specified as a traditional process ID; operating "
"on a thread of a multithreaded process requires a thread ID of the type "
"returned by B<gettid>(2).  For B<capset>(), I<pid> can also be: -1, meaning "
"perform the change on all threads except the caller and B<init>(1); or a "
"value less than -1, in which case the change is applied to all members of "
"the process group whose ID is -I<pid>."
msgstr ""
"カーネルが VFS ケーパビリティをサポートしていない場合、 I<hdrp> の I<pid> "
"フィールドが 0 以外であれば、 B<capset>()  の操作対象は I<pid> で指定されたス"
"レッドのケーパビリティになる。 I<pid> が 0 の場合は呼び出し元のスレッドのケー"
"パビリティが操作対象となる。 I<pid> がシングルスレッドプロセスを参照している"
"場合、 I<pid> は以前から使われているプロセスID を使って指定できる。 マルチス"
"レッドプロセス内のあるスレッドを対象にする場合は、 B<gettid>(2)  が返すスレッ"
"ドID を用いて指定する必要がある。 また、 B<capset>()  では -1 や -1 より小さ"
"な値を指定することもできる。 -1 は呼び出し元と B<init>(1)  を除く全てのスレッ"
"ドを対象として変更を行うことを、 -1 より小さな値は ID が -I<pid> のプロセスグ"
"ループの全メンバ を対象として変更を行うことを意味する。"

#. type: Plain text
#: build/C/man2/capget.2:184
msgid ""
"The calls fail with the error B<EINVAL>, and set the I<version> field of "
"I<hdrp> to the kernel preferred value of B<_LINUX_CAPABILITY_VERSION_?> when "
"an unsupported I<version> value is specified.  In this way, one can probe "
"what the current preferred capability revision is."
msgstr ""
"I<hdrp> のフィールド I<version> にサポートされていない値が指定された場合、 呼"
"び出しはエラー B<EINVAL> で失敗し、 I<version> にカーネル推奨の "
"B<_LINUX_CAPABILITY_VERSION_?> を設定する。 このようにして、現在の推奨ケーパ"
"ビリティリビジョンが何かを 調べることができる。"

#. type: Plain text
#: build/C/man2/capget.2:193
msgid ""
"Bad memory address.  I<hdrp> must not be NULL.  I<datap> may be NULL only "
"when the user is trying to determine the preferred capability version format "
"supported by the kernel."
msgstr ""
"不正なメモリーアドレス。 I<hdrp> は NULL であってはならない。 I<datap> に "
"NULL を指定してよいのは、ユーザーがカーネルがサポートしている 推奨のケーパビ"
"リティバージョンを判定しようとしているときだけである。"

#. type: TP
#: build/C/man2/capget.2:193 build/C/man7/cpuset.7:1180
#: build/C/man7/cpuset.7:1189 build/C/man7/cpuset.7:1198
#: build/C/man7/cpuset.7:1208 build/C/man7/cpuset.7:1217
#: build/C/man7/cpuset.7:1224 build/C/man7/cpuset.7:1231
#: build/C/man2/getgroups.2:125 build/C/man2/getgroups.2:132
#: build/C/man2/getpriority.2:145 build/C/man2/getrlimit.2:517
#: build/C/man2/getrusage.2:196 build/C/man2/iopl.2:62
#: build/C/man2/ioprio_set.2:173 build/C/man2/seteuid.2:81
#: build/C/man2/setgid.2:62 build/C/man2/setpgid.2:223
#: build/C/man2/setresuid.2:99 build/C/man2/setreuid.2:131
#: build/C/man2/setuid.2:108 build/C/man2/seccomp.2:743
#: build/C/man2/seccomp.2:747 build/C/man2/seccomp.2:753
#: build/C/man2/seccomp.2:760 build/C/man2/seccomp.2:766
#: build/C/man2/pidfd_getfd.2:85 build/C/man2/pidfd_open.2:55
#: build/C/man2/pidfd_open.2:59 build/C/man2/pidfd_send_signal.2:102
#: build/C/man2/pidfd_send_signal.2:106 build/C/man2/pidfd_send_signal.2:110
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#: build/C/man2/capget.2:196
msgid "One of the arguments was invalid."
msgstr "引数のどれかが無効である。"

#. type: Plain text
#: build/C/man2/capget.2:201
#, fuzzy
#| msgid ""
#| "An attempt was made to add a capability to the Permitted set, or to set a "
#| "capability in the Effective or Inheritable sets that is not in the "
#| "Permitted set."
msgid ""
"An attempt was made to add a capability to the permitted set, or to set a "
"capability in the effective set that is not in the permitted set."
msgstr ""
"「許可ケーパビリティセット」にケーパビリティを追加しようとしているか、 もしく"
"は「許可ケーパビリティセット」に含まれないケーパビリティを 「実効ケーパビリ"
"ティセット」や「継承可能ケーパビリティセット」に セットしようとしている。"

#. type: Plain text
#: build/C/man2/capget.2:204
#, fuzzy
#| msgid ""
#| "An attempt was made to add a capability to the Permitted set, or to set a "
#| "capability in the Effective or Inheritable sets that is not in the "
#| "Permitted set."
msgid ""
"An attempt was made to add a capability to the inheritable set, and either:"
msgstr ""
"「許可ケーパビリティセット」にケーパビリティを追加しようとしているか、 もしく"
"は「許可ケーパビリティセット」に含まれないケーパビリティを 「実効ケーパビリ"
"ティセット」や「継承可能ケーパビリティセット」に セットしようとしている。"

#. type: Plain text
#: build/C/man2/capget.2:207
msgid "that capability was not in the caller's bounding set; or"
msgstr ""

#. type: Plain text
#: build/C/man2/capget.2:212
msgid ""
"the capability was not in the caller's permitted set and the caller lacked "
"the B<CAP_SETPCAP> capability in its effective set."
msgstr ""

#. type: Plain text
#: build/C/man2/capget.2:232
msgid ""
"The caller attempted to use B<capset>()  to modify the capabilities of a "
"thread other than itself, but lacked sufficient privilege.  For kernels "
"supporting VFS capabilities, this is never permitted.  For kernels lacking "
"VFS support, the B<CAP_SETPCAP> capability is required.  (A bug in kernels "
"before 2.6.11 meant that this error could also occur if a thread without "
"this capability tried to change its own capabilities by specifying the "
"I<pid> field as a nonzero value (i.e., the value returned by B<getpid>(2))  "
"instead of 0.)"
msgstr ""
"呼び出し元が自分以外のスレッドのケーパビリティを B<capset>()  を使って修正し"
"ようとしたが、十分な特権がなかった。 VFS ケーパビリティをサポートしているカー"
"ネルでは、 この操作が許可されることは決してない。 VFS ケーパビリティをサポー"
"トしていないカーネルでは、 B<CAP_SETPCAP> ケーパビリティが必要である。 (バー"
"ジョン 2.6.11 より前のカーネルには、 このケーパビリティを持たないスレッドが "
"I<pid> フィールドに 0 でない値 (つまり、0 の代わりに B<getpid>(2)  が返す値) "
"を指定して自分自身のケーパビリティを変更しようとした場合にも、 このエラーが発"
"生するというバグがあった。)"

#. type: TP
#: build/C/man2/capget.2:232 build/C/man7/cpuset.7:1330
#: build/C/man2/getpriority.2:153 build/C/man2/getrlimit.2:548
#: build/C/man2/getsid.2:75 build/C/man2/ioprio_set.2:190
#: build/C/man2/setpgid.2:238 build/C/man2/seccomp.2:796
#: build/C/man2/pidfd_getfd.2:107 build/C/man2/pidfd_open.2:79
#: build/C/man2/pidfd_send_signal.2:125
#, no-wrap
msgid "B<ESRCH>"
msgstr "B<ESRCH>"

#. type: Plain text
#: build/C/man2/capget.2:235
msgid "No such thread."
msgstr "そのようなスレッドが存在しない。"

#. type: Plain text
#: build/C/man2/capget.2:237 build/C/man2/ioprio_set.2:201
msgid "These system calls are Linux-specific."
msgstr "これらのシステムコールは Linux 独自である。"

#. type: Plain text
#: build/C/man2/capget.2:242
msgid ""
"The portable interface to the capability querying and setting functions is "
"provided by the I<libcap> library and is available here:"
msgstr ""
"ケーパビリティを設定したり取得したりする機能のための移植性ある インターフェー"
"スは I<libcap> ライブラリによって提供される。 このライブラリは以下から入手で"
"きる:"

#. type: Plain text
#: build/C/man2/capget.2:245
msgid ""
"E<.UR http://git.kernel.org/cgit\\:/linux\\:/kernel\\:/git\\:/morgan\\:\\:/"
"libcap.git> E<.UE>"
msgstr ""
"E<.UR http://git.kernel.org/cgit\\:/linux\\:/kernel\\:/git\\:/morgan\\:\\:/"
"libcap.git> E<.UE>"

#. type: Plain text
#: build/C/man2/capget.2:249
msgid "B<clone>(2), B<gettid>(2), B<capabilities>(7)"
msgstr "B<clone>(2), B<gettid>(2), B<capabilities>(7)"

#. type: TH
#: build/C/man7/cpuset.7:25
#, no-wrap
msgid "CPUSET"
msgstr "CPUSET"

#. type: TH
#: build/C/man7/cpuset.7:25 build/C/man7/credentials.7:27
#: build/C/man2/getpid.2:25 build/C/man2/getrlimit.2:64
#: build/C/man2/seccomp.2:28 build/C/man3/posix_spawn.3:31
#, no-wrap
msgid "2020-11-01"
msgstr "2020-11-01"

#. type: Plain text
#: build/C/man7/cpuset.7:28
msgid "cpuset - confine processes to processor and memory node subsets"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:35
msgid ""
"The cpuset filesystem is a pseudo-filesystem interface to the kernel cpuset "
"mechanism, which is used to control the processor placement and memory "
"placement of processes.  It is commonly mounted at I</dev/cpuset>."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:52
msgid ""
"On systems with kernels compiled with built in support for cpusets, all "
"processes are attached to a cpuset, and cpusets are always present.  If a "
"system supports cpusets, then it will have the entry B<nodev cpuset> in the "
"file I</proc/filesystems>.  By mounting the cpuset filesystem (see the "
"B<EXAMPLES> section below), the administrator can configure the cpusets on a "
"system to control the processor and memory placement of processes on that "
"system.  By default, if the cpuset configuration on a system is not modified "
"or if the cpuset filesystem is not even mounted, then the cpuset mechanism, "
"though present, has no effect on the system's behavior."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:54
msgid "A cpuset defines a list of CPUs and memory nodes."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:63
msgid ""
"The CPUs of a system include all the logical processing units on which a "
"process can execute, including, if present, multiple processor cores within "
"a package and Hyper-Threads within a processor core.  Memory nodes include "
"all distinct banks of main memory; small and SMP systems typically have just "
"one memory node that contains all the system's main memory, while NUMA (non-"
"uniform memory access) systems have multiple memory nodes."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:73
msgid ""
"Cpusets are represented as directories in a hierarchical pseudo-filesystem, "
"where the top directory in the hierarchy (I</dev/cpuset>)  represents the "
"entire system (all online CPUs and memory nodes)  and any cpuset that is the "
"child (descendant) of another parent cpuset contains a subset of that "
"parent's CPUs and memory nodes.  The directories and files representing "
"cpusets have normal filesystem permissions."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:84
msgid ""
"Every process in the system belongs to exactly one cpuset.  A process is "
"confined to run only on the CPUs in the cpuset it belongs to, and to "
"allocate memory only on the memory nodes in that cpuset.  When a process "
"B<fork>(2)s, the child process is placed in the same cpuset as its parent.  "
"With sufficient privilege, a process may be moved from one cpuset to another "
"and the allowed CPUs and memory nodes of an existing cpuset may be changed."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:92
msgid ""
"When the system begins booting, a single cpuset is defined that includes all "
"CPUs and memory nodes on the system, and all processes are in that cpuset.  "
"During the boot process, or later during normal system operation, other "
"cpusets may be created, as subdirectories of this top cpuset, under the "
"control of the system administrator, and processes may be placed in these "
"other cpusets."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:114
msgid ""
"Cpusets are integrated with the B<sched_setaffinity>(2)  scheduling affinity "
"mechanism and the B<mbind>(2)  and B<set_mempolicy>(2)  memory-placement "
"mechanisms in the kernel.  Neither of these mechanisms let a process make "
"use of a CPU or memory node that is not allowed by that process's cpuset.  "
"If changes to a process's cpuset placement conflict with these other "
"mechanisms, then cpuset placement is enforced even if it means overriding "
"these other mechanisms.  The kernel accomplishes this overriding by silently "
"restricting the CPUs and memory nodes requested by these other mechanisms to "
"those allowed by the invoking process's cpuset.  This can result in these "
"other calls returning an error, if for example, such a call ends up "
"requesting an empty set of CPUs or memory nodes, after that request is "
"restricted to the invoking process's cpuset."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:120
msgid ""
"Typically, a cpuset is used to manage the CPU and memory-node confinement "
"for a set of cooperating processes such as a batch scheduler job, and these "
"other mechanisms are used to manage the placement of individual processes or "
"memory regions within that set or job."
msgstr ""

#. type: SH
#: build/C/man7/cpuset.7:120
#, no-wrap
msgid "FILES"
msgstr "ファイル"

#. type: Plain text
#: build/C/man7/cpuset.7:125
msgid ""
"Each directory below I</dev/cpuset> represents a cpuset and contains a fixed "
"set of pseudo-files describing the state of that cpuset."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:135
msgid ""
"New cpusets are created using the B<mkdir>(2)  system call or the "
"B<mkdir>(1)  command.  The properties of a cpuset, such as its flags, "
"allowed CPUs and memory nodes, and attached processes, are queried and "
"modified by reading or writing to the appropriate file in that cpuset's "
"directory, as listed below."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:141
msgid ""
"The pseudo-files in each cpuset directory are automatically created when the "
"cpuset is created, as a result of the B<mkdir>(2)  invocation.  It is not "
"possible to directly add or remove these pseudo-files."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:149
msgid ""
"A cpuset directory that contains no child cpuset directories, and has no "
"attached processes, can be removed using B<rmdir>(2)  or B<rmdir>(1).  It is "
"not necessary, or possible, to remove the pseudo-files inside the directory "
"before removing it."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:163
msgid ""
"The pseudo-files in each cpuset directory are small text files that may be "
"read and written using traditional shell utilities such as B<cat>(1), and "
"B<echo>(1), or from a program by using file I/O library functions or system "
"calls, such as B<open>(2), B<read>(2), B<write>(2), and B<close>(2)."
msgstr ""

#.  ====================== tasks ======================
#. type: Plain text
#: build/C/man7/cpuset.7:168
msgid ""
"The pseudo-files in a cpuset directory represent internal kernel state and "
"do not have any persistent image on disk.  Each of these per-cpuset files is "
"listed and described below."
msgstr ""

#. type: TP
#: build/C/man7/cpuset.7:168
#, no-wrap
msgid "I<tasks>"
msgstr "I<tasks>"

#. type: Plain text
#: build/C/man7/cpuset.7:178
msgid ""
"List of the process IDs (PIDs) of the processes in that cpuset.  The list is "
"formatted as a series of ASCII decimal numbers, each followed by a newline.  "
"A process may be added to a cpuset (automatically removing it from the "
"cpuset that previously contained it) by writing its PID to that cpuset's "
"I<tasks> file (with or without a trailing newline)."
msgstr ""

#.  =================== notify_on_release ===================
#. type: Plain text
#: build/C/man7/cpuset.7:186
msgid ""
"B<Warning:> only one PID may be written to the I<tasks> file at a time.  If "
"a string is written that contains more than one PID, only the first one will "
"be used."
msgstr ""

#. type: TP
#: build/C/man7/cpuset.7:186
#, no-wrap
msgid "I<notify_on_release>"
msgstr "I<notify_on_release>"

#.  ====================== cpus ======================
#. type: Plain text
#: build/C/man7/cpuset.7:195
msgid ""
"Flag (0 or 1).  If set (1), that cpuset will receive special handling after "
"it is released, that is, after all processes cease using it (i.e., terminate "
"or are moved to a different cpuset)  and all child cpuset directories have "
"been removed.  See the B<Notify On Release> section, below."
msgstr ""

#. type: TP
#: build/C/man7/cpuset.7:195
#, no-wrap
msgid "I<cpuset.cpus>"
msgstr "I<cpuset.cpus>"

#. type: Plain text
#: build/C/man7/cpuset.7:202
msgid ""
"List of the physical numbers of the CPUs on which processes in that cpuset "
"are allowed to execute.  See B<List Format> below for a description of the "
"format of I<cpus>."
msgstr ""

#.  ==================== cpu_exclusive ====================
#. type: Plain text
#: build/C/man7/cpuset.7:208
msgid ""
"The CPUs allowed to a cpuset may be changed by writing a new list to its "
"I<cpus> file."
msgstr ""

#. type: TP
#: build/C/man7/cpuset.7:208
#, no-wrap
msgid "I<cpuset.cpu_exclusive>"
msgstr "I<cpuset.cpu_exclusive>"

#. type: Plain text
#: build/C/man7/cpuset.7:215
msgid ""
"Flag (0 or 1).  If set (1), the cpuset has exclusive use of its CPUs (no "
"sibling or cousin cpuset may overlap CPUs).  By default, this is off (0).  "
"Newly created cpusets also initially default this to off (0)."
msgstr ""

#.  ====================== mems ======================
#. type: Plain text
#: build/C/man7/cpuset.7:237
msgid ""
"Two cpusets are I<sibling> cpusets if they share the same parent cpuset in "
"the I</dev/cpuset> hierarchy.  Two cpusets are I<cousin> cpusets if neither "
"is the ancestor of the other.  Regardless of the I<cpu_exclusive> setting, "
"if one cpuset is the ancestor of another, and if both of these cpusets have "
"nonempty I<cpus>, then their I<cpus> must overlap, because the I<cpus> of "
"any cpuset are always a subset of the I<cpus> of its parent cpuset."
msgstr ""

#. type: TP
#: build/C/man7/cpuset.7:237
#, no-wrap
msgid "I<cpuset.mems>"
msgstr "I<cpuset.mems>"

#.  ==================== mem_exclusive ====================
#. type: Plain text
#: build/C/man7/cpuset.7:245
msgid ""
"List of memory nodes on which processes in this cpuset are allowed to "
"allocate memory.  See B<List Format> below for a description of the format "
"of I<mems>."
msgstr ""

#. type: TP
#: build/C/man7/cpuset.7:245
#, no-wrap
msgid "I<cpuset.mem_exclusive>"
msgstr "I<cpuset.mem_exclusive>"

#. type: Plain text
#: build/C/man7/cpuset.7:253
msgid ""
"Flag (0 or 1).  If set (1), the cpuset has exclusive use of its memory nodes "
"(no sibling or cousin may overlap).  Also if set (1), the cpuset is a "
"B<Hardwall> cpuset (see below).  By default, this is off (0).  Newly created "
"cpusets also initially default this to off (0)."
msgstr ""

#.  ==================== mem_hardwall ====================
#. type: Plain text
#: build/C/man7/cpuset.7:261
msgid ""
"Regardless of the I<mem_exclusive> setting, if one cpuset is the ancestor of "
"another, then their memory nodes must overlap, because the memory nodes of "
"any cpuset are always a subset of the memory nodes of that cpuset's parent "
"cpuset."
msgstr ""

#. type: TP
#: build/C/man7/cpuset.7:261
#, no-wrap
msgid "I<cpuset.mem_hardwall> (since Linux 2.6.26)"
msgstr "I<cpuset.mem_hardwall> (Linux 2.6.26 以降)"

#.  ==================== memory_migrate ====================
#. type: Plain text
#: build/C/man7/cpuset.7:272
msgid ""
"Flag (0 or 1).  If set (1), the cpuset is a B<Hardwall> cpuset (see below).  "
"Unlike B<mem_exclusive>, there is no constraint on whether cpusets marked "
"B<mem_hardwall> may have overlapping memory nodes with sibling or cousin "
"cpusets.  By default, this is off (0).  Newly created cpusets also initially "
"default this to off (0)."
msgstr ""

#. type: TP
#: build/C/man7/cpuset.7:272
#, no-wrap
msgid "I<cpuset.memory_migrate> (since Linux 2.6.16)"
msgstr "I<cpuset.memory_migrate> (Linux 2.6.16 以降)"

#.  ==================== memory_pressure ====================
#. type: Plain text
#: build/C/man7/cpuset.7:279
msgid ""
"Flag (0 or 1).  If set (1), then memory migration is enabled.  By default, "
"this is off (0).  See the B<Memory Migration> section, below."
msgstr ""

#. type: TP
#: build/C/man7/cpuset.7:279
#, no-wrap
msgid "I<cpuset.memory_pressure> (since Linux 2.6.16)"
msgstr "I<cpuset.memory_pressure> (Linux 2.6.16 以降)"

#.  ================= memory_pressure_enabled =================
#. type: Plain text
#: build/C/man7/cpuset.7:292
msgid ""
"A measure of how much memory pressure the processes in this cpuset are "
"causing.  See the B<Memory Pressure> section, below.  Unless "
"I<memory_pressure_enabled> is enabled, always has value zero (0).  This file "
"is read-only.  See the B<WARNINGS> section, below."
msgstr ""

#. type: TP
#: build/C/man7/cpuset.7:292
#, no-wrap
msgid "I<cpuset.memory_pressure_enabled> (since Linux 2.6.16)"
msgstr "I<cpuset.memory_pressure_enabled> (Linux 2.6.16 以降)"

#.  ================== memory_spread_page ==================
#. type: Plain text
#: build/C/man7/cpuset.7:304
msgid ""
"Flag (0 or 1).  This file is present only in the root cpuset, normally I</"
"dev/cpuset>.  If set (1), the I<memory_pressure> calculations are enabled "
"for all cpusets in the system.  By default, this is off (0).  See the "
"B<Memory Pressure> section, below."
msgstr ""

#. type: TP
#: build/C/man7/cpuset.7:304
#, no-wrap
msgid "I<cpuset.memory_spread_page> (since Linux 2.6.17)"
msgstr "I<cpuset.memory_spread_page> (Linux 2.6.17 以降)"

#.  ================== memory_spread_slab ==================
#. type: Plain text
#: build/C/man7/cpuset.7:314
msgid ""
"Flag (0 or 1).  If set (1), pages in the kernel page cache (filesystem "
"buffers) are uniformly spread across the cpuset.  By default, this is off "
"(0) in the top cpuset, and inherited from the parent cpuset in newly created "
"cpusets.  See the B<Memory Spread> section, below."
msgstr ""

#. type: TP
#: build/C/man7/cpuset.7:314
#, no-wrap
msgid "I<cpuset.memory_spread_slab> (since Linux 2.6.17)"
msgstr "I<cpuset.memory_spread_slab> (Linux 2.6.17 以降)"

#.  ================== sched_load_balance ==================
#. type: Plain text
#: build/C/man7/cpuset.7:325
msgid ""
"Flag (0 or 1).  If set (1), the kernel slab caches for file I/O (directory "
"and inode structures) are uniformly spread across the cpuset.  By default, "
"is off (0) in the top cpuset, and inherited from the parent cpuset in newly "
"created cpusets.  See the B<Memory Spread> section, below."
msgstr ""

#. type: TP
#: build/C/man7/cpuset.7:325
#, no-wrap
msgid "I<cpuset.sched_load_balance> (since Linux 2.6.24)"
msgstr "I<cpuset.sched_load_balance> (Linux 2.6.24 以降)"

#.  ================== sched_relax_domain_level ==================
#. type: Plain text
#: build/C/man7/cpuset.7:339
msgid ""
"Flag (0 or 1).  If set (1, the default) the kernel will automatically load "
"balance processes in that cpuset over the allowed CPUs in that cpuset.  If "
"cleared (0) the kernel will avoid load balancing processes in this cpuset, "
"I<unless> some other cpuset with overlapping CPUs has its "
"I<sched_load_balance> flag set.  See B<Scheduler Load Balancing>, below, for "
"further details."
msgstr ""

#. type: TP
#: build/C/man7/cpuset.7:339
#, no-wrap
msgid "I<cpuset.sched_relax_domain_level> (since Linux 2.6.26)"
msgstr "I<cpuset.sched_relax_domain_level> (Linux 2.6.26 以降)"

#.  ================== proc cpuset ==================
#. type: Plain text
#: build/C/man7/cpuset.7:359
msgid ""
"Integer, between -1 and a small positive value.  The "
"I<sched_relax_domain_level> controls the width of the range of CPUs over "
"which the kernel scheduler performs immediate rebalancing of runnable tasks "
"across CPUs.  If I<sched_load_balance> is disabled, then the setting of "
"I<sched_relax_domain_level> does not matter, as no such load balancing is "
"done.  If I<sched_load_balance> is enabled, then the higher the value of the "
"I<sched_relax_domain_level>, the wider the range of CPUs over which "
"immediate load balancing is attempted.  See B<Scheduler Relax Domain Level>, "
"below, for further details."
msgstr ""

#.  ================== proc status ==================
#. type: Plain text
#: build/C/man7/cpuset.7:367
msgid ""
"In addition to the above pseudo-files in each directory below I</dev/"
"cpuset>, each process has a pseudo-file, I</proc/E<lt>pidE<gt>/cpuset>, that "
"displays the path of the process's cpuset directory relative to the root of "
"the cpuset filesystem."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:378
msgid ""
"Also the I</proc/E<lt>pidE<gt>/status> file for each process has four added "
"lines, displaying the process's I<Cpus_allowed> (on which CPUs it may be "
"scheduled) and I<Mems_allowed> (on which memory nodes it may obtain memory), "
"in the two formats B<Mask Format> and B<List Format> (see below)  as shown "
"in the following example:"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:385
#, no-wrap
msgid ""
"Cpus_allowed:   ffffffff,ffffffff,ffffffff,ffffffff\n"
"Cpus_allowed_list:     0-127\n"
"Mems_allowed:   ffffffff,ffffffff\n"
"Mems_allowed_list:     0-63\n"
msgstr ""
"Cpus_allowed:   ffffffff,ffffffff,ffffffff,ffffffff\n"
"Cpus_allowed_list:     0-127\n"
"Mems_allowed:   ffffffff,ffffffff\n"
"Mems_allowed_list:     0-63\n"

#.  ================== EXTENDED CAPABILITIES ==================
#. type: Plain text
#: build/C/man7/cpuset.7:391
msgid ""
"The \"allowed\" fields were added in Linux 2.6.24; the \"allowed_list\" "
"fields were added in Linux 2.6.26."
msgstr ""

#. type: SH
#: build/C/man7/cpuset.7:391
#, no-wrap
msgid "EXTENDED CAPABILITIES"
msgstr "拡張ケーパビリティ"

#.  ================== Exclusive Cpusets ==================
#. type: Plain text
#: build/C/man7/cpuset.7:399
msgid ""
"In addition to controlling which I<cpus> and I<mems> a process is allowed to "
"use, cpusets provide the following extended capabilities."
msgstr ""

#. type: SS
#: build/C/man7/cpuset.7:399
#, no-wrap
msgid "Exclusive cpusets"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:406
msgid ""
"If a cpuset is marked I<cpu_exclusive> or I<mem_exclusive>, no other cpuset, "
"other than a direct ancestor or descendant, may share any of the same CPUs "
"or memory nodes."
msgstr ""

#.  ================== Hardwall ==================
#. type: Plain text
#: build/C/man7/cpuset.7:432
msgid ""
"A cpuset that is I<mem_exclusive> restricts kernel allocations for buffer "
"cache pages and other internal kernel data pages commonly shared by the "
"kernel across multiple users.  All cpusets, whether I<mem_exclusive> or not, "
"restrict allocations of memory for user space.  This enables configuring a "
"system so that several independent jobs can share common kernel data, while "
"isolating each job's user allocation in its own cpuset.  To do this, "
"construct a large I<mem_exclusive> cpuset to hold all the jobs, and "
"construct child, non-I<mem_exclusive> cpusets for each individual job.  Only "
"a small amount of kernel memory, such as requests from interrupt handlers, "
"is allowed to be placed on memory nodes outside even a I<mem_exclusive> "
"cpuset."
msgstr ""

#. type: SS
#: build/C/man7/cpuset.7:432
#, no-wrap
msgid "Hardwall"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:447
msgid ""
"A cpuset that has I<mem_exclusive> or I<mem_hardwall> set is a I<hardwall> "
"cpuset.  A I<hardwall> cpuset restricts kernel allocations for page, buffer, "
"and other data commonly shared by the kernel across multiple users.  All "
"cpusets, whether I<hardwall> or not, restrict allocations of memory for user "
"space."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:458
msgid ""
"This enables configuring a system so that several independent jobs can share "
"common kernel data, such as filesystem pages, while isolating each job's "
"user allocation in its own cpuset.  To do this, construct a large "
"I<hardwall> cpuset to hold all the jobs, and construct child cpusets for "
"each individual job which are not I<hardwall> cpusets."
msgstr ""

#.  ================== Notify On Release ==================
#. type: Plain text
#: build/C/man7/cpuset.7:464
msgid ""
"Only a small amount of kernel memory, such as requests from interrupt "
"handlers, is allowed to be taken outside even a I<hardwall> cpuset."
msgstr ""

#. type: SS
#: build/C/man7/cpuset.7:464
#, no-wrap
msgid "Notify on release"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:476
msgid ""
"If the I<notify_on_release> flag is enabled (1) in a cpuset, then whenever "
"the last process in the cpuset leaves (exits or attaches to some other "
"cpuset)  and the last child cpuset of that cpuset is removed, the kernel "
"will run the command I</sbin/cpuset_release_agent>, supplying the pathname "
"(relative to the mount point of the cpuset filesystem) of the abandoned "
"cpuset.  This enables automatic removal of abandoned cpusets."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:484
msgid ""
"The default value of I<notify_on_release> in the root cpuset at system boot "
"is disabled (0).  The default value of other cpusets at creation is the "
"current value of their parent's I<notify_on_release> setting."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:492
msgid ""
"The command I</sbin/cpuset_release_agent> is invoked, with the name (I</dev/"
"cpuset> relative path)  of the to-be-released cpuset in I<argv[1]>."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:496
msgid ""
"The usual contents of the command I</sbin/cpuset_release_agent> is simply "
"the shell script:"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:501
#, no-wrap
msgid ""
"#!/bin/sh\n"
"rmdir /dev/cpuset/$1\n"
msgstr ""
"#!/bin/sh\n"
"rmdir /dev/cpuset/$1\n"

#.  ================== Memory Pressure ==================
#. type: Plain text
#: build/C/man7/cpuset.7:509
msgid ""
"As with other flag values below, this flag can be changed by writing an "
"ASCII number 0 or 1 (with optional trailing newline)  into the file, to "
"clear or set the flag, respectively."
msgstr ""

#. type: SS
#: build/C/man7/cpuset.7:509
#, no-wrap
msgid "Memory pressure"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:515
msgid ""
"The I<memory_pressure> of a cpuset provides a simple per-cpuset running "
"average of the rate that the processes in a cpuset are attempting to free up "
"in-use memory on the nodes of the cpuset to satisfy additional memory "
"requests."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:519
msgid ""
"This enables batch managers that are monitoring jobs running in dedicated "
"cpusets to efficiently detect what level of memory pressure that job is "
"causing."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:526
msgid ""
"This is useful both on tightly managed systems running a wide mix of "
"submitted jobs, which may choose to terminate or reprioritize jobs that are "
"trying to use more memory than allowed on the nodes assigned them, and with "
"tightly coupled, long-running, massively parallel scientific computing jobs "
"that will dramatically fail to meet required performance goals if they start "
"to use more memory than allowed to them."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:531
msgid ""
"This mechanism provides a very economical way for the batch manager to "
"monitor a cpuset for signs of memory pressure.  It's up to the batch manager "
"or other user code to decide what action to take if it detects signs of "
"memory pressure."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:538
msgid ""
"Unless memory pressure calculation is enabled by setting the pseudo-file I</"
"dev/cpuset/cpuset.memory_pressure_enabled>, it is not computed for any "
"cpuset, and reads from any I<memory_pressure> always return zero, as "
"represented by the ASCII string \"0\\en\".  See the B<WARNINGS> section, "
"below."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:540
msgid "A per-cpuset, running average is employed for the following reasons:"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:545
msgid ""
"Because this meter is per-cpuset rather than per-process or per virtual "
"memory region, the system load imposed by a batch scheduler monitoring this "
"metric is sharply reduced on large systems, because a scan of the tasklist "
"can be avoided on each set of queries."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:550
msgid ""
"Because this meter is a running average rather than an accumulating counter, "
"a batch scheduler can detect memory pressure with a single read, instead of "
"having to read and accumulate results for a period of time."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:556
msgid ""
"Because this meter is per-cpuset rather than per-process, the batch "
"scheduler can obtain the key information\\(emmemory pressure in a cpuset"
"\\(emwith a single read, rather than having to query and accumulate results "
"over all the (dynamically changing)  set of processes in the cpuset."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:564
msgid ""
"The I<memory_pressure> of a cpuset is calculated using a per-cpuset simple "
"digital filter that is kept within the kernel.  For each cpuset, this filter "
"tracks the recent rate at which processes attached to that cpuset enter the "
"kernel direct reclaim code."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:573
msgid ""
"The kernel direct reclaim code is entered whenever a process has to satisfy "
"a memory page request by first finding some other page to repurpose, due to "
"lack of any readily available already free pages.  Dirty filesystem pages "
"are repurposed by first writing them to disk.  Unmodified filesystem buffer "
"pages are repurposed by simply dropping them, though if that page is needed "
"again, it will have to be reread from disk."
msgstr ""

#.  ================== Memory Spread ==================
#. type: Plain text
#: build/C/man7/cpuset.7:581
msgid ""
"The I<cpuset.memory_pressure> file provides an integer number representing "
"the recent (half-life of 10 seconds) rate of entries to the direct reclaim "
"code caused by any process in the cpuset, in units of reclaims attempted per "
"second, times 1000."
msgstr ""

#. type: SS
#: build/C/man7/cpuset.7:581
#, no-wrap
msgid "Memory spread"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:589
msgid ""
"There are two Boolean flag files per cpuset that control where the kernel "
"allocates pages for the filesystem buffers and related in-kernel data "
"structures.  They are called I<cpuset.memory_spread_page> and I<cpuset."
"memory_spread_slab>."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:596
msgid ""
"If the per-cpuset Boolean flag file I<cpuset.memory_spread_page> is set, "
"then the kernel will spread the filesystem buffers (page cache) evenly over "
"all the nodes that the faulting process is allowed to use, instead of "
"preferring to put those pages on the node where the process is running."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:604
msgid ""
"If the per-cpuset Boolean flag file I<cpuset.memory_spread_slab> is set, "
"then the kernel will spread some filesystem-related slab caches, such as "
"those for inodes and directory entries, evenly over all the nodes that the "
"faulting process is allowed to use, instead of preferring to put those pages "
"on the node where the process is running."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:609
msgid ""
"The setting of these flags does not affect the data segment (see B<brk>(2))  "
"or stack segment pages of a process."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:617
msgid ""
"By default, both kinds of memory spreading are off and the kernel prefers to "
"allocate memory pages on the node local to where the requesting process is "
"running.  If that node is not allowed by the process's NUMA memory policy or "
"cpuset configuration or if there are insufficient free memory pages on that "
"node, then the kernel looks for the nearest node that is allowed and has "
"sufficient free memory."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:620
msgid ""
"When new cpusets are created, they inherit the memory spread settings of "
"their parent."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:635
msgid ""
"Setting memory spreading causes allocations for the affected page or slab "
"caches to ignore the process's NUMA memory policy and be spread instead.  "
"However, the effect of these changes in memory placement caused by cpuset-"
"specified memory spreading is hidden from the B<mbind>(2)  or "
"B<set_mempolicy>(2)  calls.  These two NUMA memory policy calls always "
"appear to behave as if no cpuset-specified memory spreading is in effect, "
"even if it is.  If cpuset memory spreading is subsequently turned off, the "
"NUMA memory policy most recently specified by these calls is automatically "
"reapplied."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:644
msgid ""
"Both I<cpuset.memory_spread_page> and I<cpuset.memory_spread_slab> are "
"Boolean flag files.  By default, they contain \"0\", meaning that the "
"feature is off for that cpuset.  If a \"1\" is written to that file, that "
"turns the named feature on."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:647
msgid ""
"Cpuset-specified memory spreading behaves similarly to what is known (in "
"other contexts) as round-robin or interleave memory placement."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:650
msgid ""
"Cpuset-specified memory spreading can provide substantial performance "
"improvements for jobs that:"
msgstr ""

#. type: IP
#: build/C/man7/cpuset.7:650 build/C/man7/cgroups.7:1804
#, no-wrap
msgid "a)"
msgstr "a)"

#. type: Plain text
#: build/C/man7/cpuset.7:654
msgid ""
"need to place thread-local data on memory nodes close to the CPUs which are "
"running the threads that most frequently access that data; but also"
msgstr ""

#. type: IP
#: build/C/man7/cpuset.7:654 build/C/man7/cgroups.7:1806
#, no-wrap
msgid "b)"
msgstr "b)"

#. type: Plain text
#: build/C/man7/cpuset.7:657
msgid ""
"need to access large filesystem data sets that must to be spread across the "
"several nodes in the job's cpuset in order to fit."
msgstr ""

#.  ================== Memory Migration ==================
#. type: Plain text
#: build/C/man7/cpuset.7:664
msgid ""
"Without this policy, the memory allocation across the nodes in the job's "
"cpuset can become very uneven, especially for jobs that might have just a "
"single thread initializing or reading in the data set."
msgstr ""

#. type: SS
#: build/C/man7/cpuset.7:664
#, no-wrap
msgid "Memory migration"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:673
msgid ""
"Normally, under the default setting (disabled) of I<cpuset.memory_migrate>, "
"once a page is allocated (given a physical page of main memory), then that "
"page stays on whatever node it was allocated, so long as it remains "
"allocated, even if the cpuset's memory-placement policy I<mems> subsequently "
"changes."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:679
msgid ""
"When memory migration is enabled in a cpuset, if the I<mems> setting of the "
"cpuset is changed, then any memory page in use by any process in the cpuset "
"that is on a memory node that is no longer allowed will be migrated to a "
"memory node that is allowed."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:685
msgid ""
"Furthermore, if a process is moved into a cpuset with I<memory_migrate> "
"enabled, any memory pages it uses that were on memory nodes allowed in its "
"previous cpuset, but which are not allowed in its new cpuset, will be "
"migrated to a memory node allowed in the new cpuset."
msgstr ""

#.  ================== Scheduler Load Balancing ==================
#. type: Plain text
#: build/C/man7/cpuset.7:693
msgid ""
"The relative placement of a migrated page within the cpuset is preserved "
"during these migration operations if possible.  For example, if the page was "
"on the second valid node of the prior cpuset, then the page will be placed "
"on the second valid node of the new cpuset, if possible."
msgstr ""

#. type: SS
#: build/C/man7/cpuset.7:693
#, no-wrap
msgid "Scheduler load balancing"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:700
msgid ""
"The kernel scheduler automatically load balances processes.  If one CPU is "
"underutilized, the kernel will look for processes on other more overloaded "
"CPUs and move those processes to the underutilized CPU, within the "
"constraints of such placement mechanisms as cpusets and "
"B<sched_setaffinity>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:713
msgid ""
"The algorithmic cost of load balancing and its impact on key shared kernel "
"data structures such as the process list increases more than linearly with "
"the number of CPUs being balanced.  For example, it costs more to load "
"balance across one large set of CPUs than it does to balance across two "
"smaller sets of CPUs, each of half the size of the larger set.  (The precise "
"relationship between the number of CPUs being balanced and the cost of load "
"balancing depends on implementation details of the kernel process scheduler, "
"which is subject to change over time, as improved kernel scheduler "
"algorithms are implemented.)"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:719
msgid ""
"The per-cpuset flag I<sched_load_balance> provides a mechanism to suppress "
"this automatic scheduler load balancing in cases where it is not needed and "
"suppressing it would have worthwhile performance benefits."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:723
msgid ""
"By default, load balancing is done across all CPUs, except those marked "
"isolated using the kernel boot time \"isolcpus=\" argument.  (See "
"B<Scheduler Relax Domain Level>, below, to change this default.)"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:726
msgid ""
"This default load balancing across all CPUs is not well suited to the "
"following two situations:"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:730
msgid ""
"On large systems, load balancing across many CPUs is expensive.  If the "
"system is managed using cpusets to place independent jobs on separate sets "
"of CPUs, full load balancing is unnecessary."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:734
msgid ""
"Systems supporting real-time on some CPUs need to minimize system overhead "
"on those CPUs, including avoiding process load balancing if that is not "
"needed."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:744
msgid ""
"When the per-cpuset flag I<sched_load_balance> is enabled (the default "
"setting), it requests load balancing across all the CPUs in that cpuset's "
"allowed CPUs, ensuring that load balancing can move a process (not otherwise "
"pinned, as by B<sched_setaffinity>(2))  from any CPU in that cpuset to any "
"other."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:753
msgid ""
"When the per-cpuset flag I<sched_load_balance> is disabled, then the "
"scheduler will avoid load balancing across the CPUs in that cpuset, "
"I<except> in so far as is necessary because some overlapping cpuset has "
"I<sched_load_balance> enabled."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:761
msgid ""
"So, for example, if the top cpuset has the flag I<sched_load_balance> "
"enabled, then the scheduler will load balance across all CPUs, and the "
"setting of the I<sched_load_balance> flag in other cpusets has no effect, as "
"we're already fully load balancing."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:766
msgid ""
"Therefore in the above two situations, the flag I<sched_load_balance> should "
"be disabled in the top cpuset, and only some of the smaller, child cpusets "
"would have this flag enabled."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:774
msgid ""
"When doing this, you don't usually want to leave any unpinned processes in "
"the top cpuset that might use nontrivial amounts of CPU, as such processes "
"may be artificially constrained to some subset of CPUs, depending on the "
"particulars of this flag setting in descendant cpusets.  Even if such a "
"process could use spare CPU cycles in some other CPUs, the kernel scheduler "
"might not consider the possibility of load balancing that process to the "
"underused CPU."
msgstr ""

#.  ================== Scheduler Relax Domain Level ==================
#. type: Plain text
#: build/C/man7/cpuset.7:780
msgid ""
"Of course, processes pinned to a particular CPU can be left in a cpuset that "
"disables I<sched_load_balance> as those processes aren't going anywhere else "
"anyway."
msgstr ""

#. type: SS
#: build/C/man7/cpuset.7:780
#, no-wrap
msgid "Scheduler relax domain level"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:801
msgid ""
"The kernel scheduler performs immediate load balancing whenever a CPU "
"becomes free or another task becomes runnable.  This load balancing works to "
"ensure that as many CPUs as possible are usefully employed running tasks.  "
"The kernel also performs periodic load balancing off the software clock "
"described in B<time>(7).  The setting of I<sched_relax_domain_level> applies "
"only to immediate load balancing.  Regardless of the "
"I<sched_relax_domain_level> setting, periodic load balancing is attempted "
"over all CPUs (unless disabled by turning off I<sched_load_balance>.)  In "
"any case, of course, tasks will be scheduled to run only on CPUs allowed by "
"their cpuset, as modified by B<sched_setaffinity>(2)  system calls."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:809
msgid ""
"On small systems, such as those with just a few CPUs, immediate load "
"balancing is useful to improve system interactivity and to minimize wasteful "
"idle CPU cycles.  But on large systems, attempting immediate load balancing "
"across a large number of CPUs can be more costly than it is worth, depending "
"on the particular performance characteristics of the job mix and the "
"hardware."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:817
msgid ""
"The exact meaning of the small integer values of I<sched_relax_domain_level> "
"will depend on internal implementation details of the kernel scheduler code "
"and on the non-uniform architecture of the hardware.  Both of these will "
"evolve over time and vary by system architecture and kernel version."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:822
msgid ""
"As of this writing, when this capability was introduced in Linux 2.6.26, on "
"certain popular architectures, the positive values of "
"I<sched_relax_domain_level> have the following meanings."
msgstr ""

#. type: IP
#: build/C/man7/cpuset.7:824
#, no-wrap
msgid "B<(1)>"
msgstr "B<(1)>"

#. type: Plain text
#: build/C/man7/cpuset.7:827
msgid ""
"Perform immediate load balancing across Hyper-Thread siblings on the same "
"core."
msgstr ""

#. type: IP
#: build/C/man7/cpuset.7:827
#, no-wrap
msgid "B<(2)>"
msgstr "B<(2)>"

#. type: Plain text
#: build/C/man7/cpuset.7:829
msgid ""
"Perform immediate load balancing across other cores in the same package."
msgstr ""

#. type: IP
#: build/C/man7/cpuset.7:829
#, no-wrap
msgid "B<(3)>"
msgstr "B<(3)>"

#. type: Plain text
#: build/C/man7/cpuset.7:832
msgid ""
"Perform immediate load balancing across other CPUs on the same node or blade."
msgstr ""

#. type: IP
#: build/C/man7/cpuset.7:832
#, no-wrap
msgid "B<(4)>"
msgstr "B<(4)>"

#. type: Plain text
#: build/C/man7/cpuset.7:835
msgid ""
"Perform immediate load balancing across over several (implementation detail) "
"nodes [On NUMA systems]."
msgstr ""

#. type: IP
#: build/C/man7/cpuset.7:835
#, no-wrap
msgid "B<(5)>"
msgstr "B<(5)>"

#. type: Plain text
#: build/C/man7/cpuset.7:838
msgid ""
"Perform immediate load balancing across over all CPUs in system [On NUMA "
"systems]."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:847
msgid ""
"The I<sched_relax_domain_level> value of zero (0) always means don't perform "
"immediate load balancing, hence that load balancing is done only "
"periodically, not immediately when a CPU becomes available or another task "
"becomes runnable."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:855
msgid ""
"The I<sched_relax_domain_level> value of minus one (-1)  always means use "
"the system default value.  The system default value can vary by architecture "
"and kernel version.  This system default value can be changed by kernel boot-"
"time \"relax_domain_level=\" argument."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:863
msgid ""
"In the case of multiple overlapping cpusets which have conflicting "
"I<sched_relax_domain_level> values, then the highest such value applies to "
"all CPUs in any of the overlapping cpusets.  In such cases, the value "
"B<minus one (-1)> is the lowest value, overridden by any other value, and "
"the value B<zero (0)> is the next lowest value."
msgstr ""

#. type: SH
#: build/C/man7/cpuset.7:863
#, no-wrap
msgid "FORMATS"
msgstr ""

#.  ================== Mask Format ==================
#. type: Plain text
#: build/C/man7/cpuset.7:867
msgid ""
"The following formats are used to represent sets of CPUs and memory nodes."
msgstr ""

#. type: SS
#: build/C/man7/cpuset.7:867
#, no-wrap
msgid "Mask format"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:872
msgid ""
"The B<Mask Format> is used to represent CPU and memory-node bit masks in the "
"I</proc/E<lt>pidE<gt>/status> file."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:880
msgid ""
"This format displays each 32-bit word in hexadecimal (using ASCII characters "
"\"0\" - \"9\" and \"a\" - \"f\"); words are filled with leading zeros, if "
"required.  For masks longer than one word, a comma separator is used between "
"words.  Words are displayed in big-endian order, which has the most "
"significant bit first.  The hex digits within a word are also in big-endian "
"order."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:883
msgid ""
"The number of 32-bit words displayed is the minimum number needed to display "
"all bits of the bit mask, based on the size of the bit mask."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:885
msgid "Examples of the B<Mask Format>:"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:893
#, no-wrap
msgid ""
"00000001                        # just bit 0 set\n"
"40000000,00000000,00000000      # just bit 94 set\n"
"00000001,00000000,00000000      # just bit 64 set\n"
"000000ff,00000000               # bits 32-39 set\n"
"00000000,000e3862               # 1,5,6,11-13,17-19 set\n"
msgstr ""
"00000001                        # just bit 0 set\n"
"40000000,00000000,00000000      # just bit 94 set\n"
"00000001,00000000,00000000      # just bit 64 set\n"
"000000ff,00000000               # bits 32-39 set\n"
"00000000,000e3862               # 1,5,6,11-13,17-19 set\n"

#. type: Plain text
#: build/C/man7/cpuset.7:897
msgid "A mask with bits 0, 1, 2, 4, 8, 16, 32, and 64 set displays as:"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:901
#, no-wrap
msgid "00000001,00000001,00010117\n"
msgstr "00000001,00000001,00010117\n"

#.  ================== List Format ==================
#. type: Plain text
#: build/C/man7/cpuset.7:908
msgid ""
"The first \"1\" is for bit 64, the second for bit 32, the third for bit 16, "
"the fourth for bit 8, the fifth for bit 4, and the \"7\" is for bits 2, 1, "
"and 0."
msgstr ""

#. type: SS
#: build/C/man7/cpuset.7:908
#, no-wrap
msgid "List format"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:915
msgid ""
"The B<List Format> for I<cpus> and I<mems> is a comma-separated list of CPU "
"or memory-node numbers and ranges of numbers, in ASCII decimal."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:917
msgid "Examples of the B<List Format>:"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:922
#, no-wrap
msgid ""
"0-4,9           # bits 0, 1, 2, 3, 4, and 9 set\n"
"0-2,7,12-14     # bits 0, 1, 2, 7, 12, 13, and 14 set\n"
msgstr ""
"0-4,9           # bits 0, 1, 2, 3, 4, and 9 set\n"
"0-2,7,12-14     # bits 0, 1, 2, 7, 12, 13, and 14 set\n"

#.  ================== RULES ==================
#. type: SH
#: build/C/man7/cpuset.7:925
#, no-wrap
msgid "RULES"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:927
msgid "The following rules apply to each cpuset:"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:930
msgid ""
"Its CPUs and memory nodes must be a (possibly equal)  subset of its parent's."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:934
msgid "It can be marked I<cpu_exclusive> only if its parent is."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:938
msgid "It can be marked I<mem_exclusive> only if its parent is."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:942
msgid "If it is I<cpu_exclusive>, its CPUs may not overlap any sibling."
msgstr ""

#.  ================== PERMISSIONS ==================
#. type: Plain text
#: build/C/man7/cpuset.7:947
msgid ""
"If it is I<memory_exclusive>, its memory nodes may not overlap any sibling."
msgstr ""

#. type: SH
#: build/C/man7/cpuset.7:947
#, no-wrap
msgid "PERMISSIONS"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:952
msgid ""
"The permissions of a cpuset are determined by the permissions of the "
"directories and pseudo-files in the cpuset filesystem, normally mounted at "
"I</dev/cpuset>."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:961
msgid ""
"For instance, a process can put itself in some other cpuset (than its "
"current one) if it can write the I<tasks> file for that cpuset.  This "
"requires execute permission on the encompassing directories and write "
"permission on the I<tasks> file."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:968
msgid ""
"An additional constraint is applied to requests to place some other process "
"in a cpuset.  One process may not attach another to a cpuset unless it would "
"have permission to send that process a signal (see B<kill>(2))."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:979
msgid ""
"A process may create a child cpuset if it can access and write the parent "
"cpuset directory.  It can modify the CPUs or memory nodes in a cpuset if it "
"can access that cpuset's directory (execute permissions on the each of the "
"parent directories) and write the corresponding I<cpus> or I<mems> file."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1000
msgid ""
"There is one minor difference between the manner in which these permissions "
"are evaluated and the manner in which normal filesystem operation "
"permissions are evaluated.  The kernel interprets relative pathnames "
"starting at a process's current working directory.  Even if one is operating "
"on a cpuset file, relative pathnames are interpreted relative to the "
"process's current working directory, not relative to the process's current "
"cpuset.  The only ways that cpuset paths relative to a process's current "
"cpuset can be used are if either the process's current working directory is "
"its cpuset (it first did a B<cd> or B<chdir>(2)  to its cpuset directory "
"beneath I</dev/cpuset>, which is a bit unusual)  or if some user code "
"converts the relative cpuset path to a full filesystem path."
msgstr ""

#.  ================== WARNINGS ==================
#. type: Plain text
#: build/C/man7/cpuset.7:1015
msgid ""
"In theory, this means that user code should specify cpusets using absolute "
"pathnames, which requires knowing the mount point of the cpuset filesystem "
"(usually, but not necessarily, I</dev/cpuset>).  In practice, all user level "
"code that this author is aware of simply assumes that if the cpuset "
"filesystem is mounted, then it is mounted at I</dev/cpuset>.  Furthermore, "
"it is common practice for carefully written user code to verify the presence "
"of the pseudo-file I</dev/cpuset/tasks> in order to verify that the cpuset "
"pseudo-filesystem is currently mounted."
msgstr ""

#. type: SH
#: build/C/man7/cpuset.7:1015
#, no-wrap
msgid "WARNINGS"
msgstr ""

#. type: SS
#: build/C/man7/cpuset.7:1016
#, no-wrap
msgid "Enabling memory_pressure"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1025
msgid ""
"By default, the per-cpuset file I<cpuset.memory_pressure> always contains "
"zero (0).  Unless this feature is enabled by writing \"1\" to the pseudo-"
"file I</dev/cpuset/cpuset.memory_pressure_enabled>, the kernel does not "
"compute per-cpuset I<memory_pressure>."
msgstr ""

#. type: SS
#: build/C/man7/cpuset.7:1025
#, no-wrap
msgid "Using the echo command"
msgstr ""

#.  Gack!  csh(1)'s echo does this
#. type: Plain text
#: build/C/man7/cpuset.7:1036
msgid ""
"When using the B<echo> command at the shell prompt to change the values of "
"cpuset files, beware that the built-in B<echo> command in some shells does "
"not display an error message if the B<write>(2)  system call fails.  For "
"example, if the command:"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1040
#, no-wrap
msgid "echo 19 E<gt> cpuset.mems\n"
msgstr "echo 19 E<gt> cpuset.mems\n"

#. type: Plain text
#: build/C/man7/cpuset.7:1053
msgid ""
"failed because memory node 19 was not allowed (perhaps the current system "
"does not have a memory node 19), then the B<echo> command might not display "
"any error.  It is better to use the B</bin/echo> external command to change "
"cpuset file settings, as this command will display B<write>(2)  errors, as "
"in the example:"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1058
#, no-wrap
msgid ""
"/bin/echo 19 E<gt> cpuset.mems\n"
"/bin/echo: write error: Invalid argument\n"
msgstr ""
"/bin/echo 19 E<gt> cpuset.mems\n"
"/bin/echo: write error: Invalid argument\n"

#.  ================== EXCEPTIONS ==================
#. type: SH
#: build/C/man7/cpuset.7:1061
#, no-wrap
msgid "EXCEPTIONS"
msgstr ""

#. type: SS
#: build/C/man7/cpuset.7:1062
#, no-wrap
msgid "Memory placement"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1065
msgid ""
"Not all allocations of system memory are constrained by cpusets, for the "
"following reasons."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1080
msgid ""
"If hot-plug functionality is used to remove all the CPUs that are currently "
"assigned to a cpuset, then the kernel will automatically update the "
"I<cpus_allowed> of all processes attached to CPUs in that cpuset to allow "
"all CPUs.  When memory hot-plug functionality for removing memory nodes is "
"available, a similar exception is expected to apply there as well.  In "
"general, the kernel prefers to violate cpuset placement, rather than "
"starving a process that has had all its allowed CPUs or memory nodes taken "
"offline.  User code should reconfigure cpusets to refer only to online CPUs "
"and memory nodes when using hot-plug to add or remove such resources."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1088
msgid ""
"A few kernel-critical, internal memory-allocation requests, marked "
"GFP_ATOMIC, must be satisfied immediately.  The kernel may drop some request "
"or malfunction if one of these allocations fail.  If such a request cannot "
"be satisfied within the current process's cpuset, then we relax the cpuset, "
"and look for memory anywhere we can find it.  It's better to violate the "
"cpuset than stress the kernel."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1092
msgid ""
"Allocations of memory requested by kernel drivers while processing an "
"interrupt lack any relevant process context, and are not confined by cpusets."
msgstr ""

#. type: SS
#: build/C/man7/cpuset.7:1092
#, no-wrap
msgid "Renaming cpusets"
msgstr ""

#.  ================== ERRORS ==================
#. type: Plain text
#: build/C/man7/cpuset.7:1100
msgid ""
"You can use the B<rename>(2)  system call to rename cpusets.  Only simple "
"renaming is supported; that is, changing the name of a cpuset directory is "
"permitted, but moving a directory into a different directory is not "
"permitted."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1104
msgid ""
"The Linux kernel implementation of cpusets sets I<errno> to specify the "
"reason for a failed system call affecting cpusets."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1109
msgid ""
"The possible I<errno> settings and their meaning when set on a failed cpuset "
"call are as listed below."
msgstr ""

#. type: TP
#: build/C/man7/cpuset.7:1109
#, no-wrap
msgid "B<E2BIG>"
msgstr "B<E2BIG>"

#. type: Plain text
#: build/C/man7/cpuset.7:1116
msgid ""
"Attempted a B<write>(2)  on a special cpuset file with a length larger than "
"some kernel-determined upper limit on the length of such writes."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1123
msgid ""
"Attempted to B<write>(2)  the process ID (PID) of a process to a cpuset "
"I<tasks> file when one lacks permission to move that process."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1129
msgid ""
"Attempted to add, using B<write>(2), a CPU or memory node to a cpuset, when "
"that CPU or memory node was not already in its parent."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1137
msgid ""
"Attempted to set, using B<write>(2), I<cpuset.cpu_exclusive> or I<cpuset."
"mem_exclusive> on a cpuset whose parent lacks the same setting."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1144
msgid "Attempted to B<write>(2)  a I<cpuset.memory_pressure> file."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1147
msgid "Attempted to create a file in a cpuset directory."
msgstr ""

#. type: TP
#: build/C/man7/cpuset.7:1147 build/C/man7/cpuset.7:1152
#: build/C/man7/cpuset.7:1157 build/C/man7/cgroups.7:1749
#, no-wrap
msgid "B<EBUSY>"
msgstr "B<EBUSY>"

#. type: Plain text
#: build/C/man7/cpuset.7:1152
msgid ""
"Attempted to remove, using B<rmdir>(2), a cpuset with attached processes."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1157
msgid "Attempted to remove, using B<rmdir>(2), a cpuset with child cpusets."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1162
msgid ""
"Attempted to remove a CPU or memory node from a cpuset that is also in a "
"child of that cpuset."
msgstr ""

#. type: TP
#: build/C/man7/cpuset.7:1162 build/C/man7/cpuset.7:1167
#, no-wrap
msgid "B<EEXIST>"
msgstr "B<EEXIST>"

#. type: Plain text
#: build/C/man7/cpuset.7:1167
msgid "Attempted to create, using B<mkdir>(2), a cpuset that already exists."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1172
msgid "Attempted to B<rename>(2)  a cpuset to a name that already exists."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1180
msgid ""
"Attempted to B<read>(2)  or B<write>(2)  a cpuset file using a buffer that "
"is outside the writing processes accessible address space."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1189
msgid ""
"Attempted to change a cpuset, using B<write>(2), in a way that would violate "
"a I<cpu_exclusive> or I<mem_exclusive> attribute of that cpuset or any of "
"its siblings."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1198
msgid ""
"Attempted to B<write>(2)  an empty I<cpuset.cpus> or I<cpuset.mems> list to "
"a cpuset which has attached processes or child cpusets."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1208
msgid ""
"Attempted to B<write>(2)  a I<cpuset.cpus> or I<cpuset.mems> list which "
"included a range with the second number smaller than the first number."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1217
msgid ""
"Attempted to B<write>(2)  a I<cpuset.cpus> or I<cpuset.mems> list which "
"included an invalid character in the string."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1224
msgid ""
"Attempted to B<write>(2)  a list to a I<cpuset.cpus> file that did not "
"include any online CPUs."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1231
msgid ""
"Attempted to B<write>(2)  a list to a I<cpuset.mems> file that did not "
"include any online memory nodes."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1238
msgid ""
"Attempted to B<write>(2)  a list to a I<cpuset.mems> file that included a "
"node that held no memory."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1246
msgid ""
"Attempted to B<write>(2)  a string to a cpuset I<tasks> file that does not "
"begin with an ASCII decimal integer."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1251
msgid "Attempted to B<rename>(2)  a cpuset into a different directory."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1258
msgid ""
"Attempted to B<read>(2)  a I</proc/E<lt>pidE<gt>/cpuset> file for a cpuset "
"path that is longer than the kernel page size."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1263
msgid ""
"Attempted to create, using B<mkdir>(2), a cpuset whose base directory name "
"is longer than 255 characters."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1270
msgid ""
"Attempted to create, using B<mkdir>(2), a cpuset whose full pathname, "
"including the mount point (typically \"/dev/cpuset/\") prefix, is longer "
"than 4095 characters."
msgstr ""

#. type: TP
#: build/C/man7/cpuset.7:1270 build/C/man2/pidfd_open.2:73
#, no-wrap
msgid "B<ENODEV>"
msgstr "B<ENODEV>"

#. type: Plain text
#: build/C/man7/cpuset.7:1275
msgid ""
"The cpuset was removed by another process at the same time as a B<write>(2)  "
"was attempted on one of the pseudo-files in the cpuset directory."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1280
msgid ""
"Attempted to create, using B<mkdir>(2), a cpuset in a parent cpuset that "
"doesn't exist."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1287
msgid ""
"Attempted to B<access>(2)  or B<open>(2)  a nonexistent file in a cpuset "
"directory."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1292
msgid ""
"Insufficient memory is available within the kernel; can occur on a variety "
"of system calls affecting cpusets, but only if the system is extremely short "
"of memory."
msgstr ""

#. type: TP
#: build/C/man7/cpuset.7:1292 build/C/man7/cpuset.7:1304
#, no-wrap
msgid "B<ENOSPC>"
msgstr "B<ENOSPC>"

#. type: Plain text
#: build/C/man7/cpuset.7:1304
msgid ""
"Attempted to B<write>(2)  the process ID (PID)  of a process to a cpuset "
"I<tasks> file when the cpuset had an empty I<cpuset.cpus> or empty I<cpuset."
"mems> setting."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1314
msgid ""
"Attempted to B<write>(2)  an empty I<cpuset.cpus> or I<cpuset.mems> setting "
"to a cpuset that has tasks attached."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1319
msgid "Attempted to B<rename>(2)  a nonexistent cpuset."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1322
msgid "Attempted to remove a file from a cpuset directory."
msgstr ""

#. type: TP
#: build/C/man7/cpuset.7:1322
#, no-wrap
msgid "B<ERANGE>"
msgstr "B<ERANGE>"

#. type: Plain text
#: build/C/man7/cpuset.7:1330
msgid ""
"Specified a I<cpuset.cpus> or I<cpuset.mems> list to the kernel which "
"included a number too large for the kernel to set in its bit masks."
msgstr ""

#.  ================== VERSIONS ==================
#. type: Plain text
#: build/C/man7/cpuset.7:1338
msgid ""
"Attempted to B<write>(2)  the process ID (PID) of a nonexistent process to a "
"cpuset I<tasks> file."
msgstr ""

#.  ================== NOTES ==================
#. type: Plain text
#: build/C/man7/cpuset.7:1341
msgid "Cpusets appeared in version 2.6.12 of the Linux kernel."
msgstr ""

#.  ================== BUGS ==================
#. type: Plain text
#: build/C/man7/cpuset.7:1352
msgid ""
"Despite its name, the I<pid> parameter is actually a thread ID, and each "
"thread in a threaded group can be attached to a different cpuset.  The value "
"returned from a call to B<gettid>(2)  can be passed in the argument I<pid>."
msgstr ""

#. type: SH
#: build/C/man7/cpuset.7:1352 build/C/man2/getpriority.2:240
#: build/C/man2/getrlimit.2:646 build/C/man2/ioprio_set.2:354
#: build/C/man2/setfsgid.2:105 build/C/man2/setfsuid.2:123
#: build/C/man3/posix_spawn.3:587
#, no-wrap
msgid "BUGS"
msgstr "バグ"

#.  ================== EXAMPLES ==================
#. type: Plain text
#: build/C/man7/cpuset.7:1365
msgid ""
"I<cpuset.memory_pressure> cpuset files can be opened for writing, creation, "
"or truncation, but then the B<write>(2)  fails with I<errno> set to "
"B<EACCES>, and the creation and truncation options on B<open>(2)  have no "
"effect."
msgstr ""

#. type: SH
#: build/C/man7/cpuset.7:1365 build/C/man2/getrlimit.2:779
#: build/C/man2/seccomp.2:947 build/C/man2/pidfd_open.2:200
#: build/C/man2/pidfd_send_signal.2:179 build/C/man3/posix_spawn.3:602
#, no-wrap
msgid "EXAMPLES"
msgstr "例"

#. type: Plain text
#: build/C/man7/cpuset.7:1368
msgid ""
"The following examples demonstrate querying and setting cpuset options using "
"shell commands."
msgstr ""

#. type: SS
#: build/C/man7/cpuset.7:1368
#, no-wrap
msgid "Creating and attaching to a cpuset."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1371
msgid ""
"To create a new cpuset and attach the current command shell to it, the steps "
"are:"
msgstr ""

#. type: IP
#: build/C/man7/cpuset.7:1373 build/C/man7/cpuset.7:1413
#, no-wrap
msgid "1)"
msgstr "1)"

#. type: Plain text
#: build/C/man7/cpuset.7:1375
msgid "mkdir /dev/cpuset (if not already done)"
msgstr ""

#. type: IP
#: build/C/man7/cpuset.7:1375 build/C/man7/cpuset.7:1419
#, no-wrap
msgid "2)"
msgstr "2)"

#. type: Plain text
#: build/C/man7/cpuset.7:1377
msgid "mount -t cpuset none /dev/cpuset (if not already done)"
msgstr ""

#. type: IP
#: build/C/man7/cpuset.7:1377 build/C/man7/cpuset.7:1422
#, no-wrap
msgid "3)"
msgstr "3)"

#. type: Plain text
#: build/C/man7/cpuset.7:1380
msgid "Create the new cpuset using B<mkdir>(1)."
msgstr ""

#. type: IP
#: build/C/man7/cpuset.7:1380 build/C/man7/cpuset.7:1425
#, no-wrap
msgid "4)"
msgstr "4)"

#. type: Plain text
#: build/C/man7/cpuset.7:1382
msgid "Assign CPUs and memory nodes to the new cpuset."
msgstr ""

#. type: IP
#: build/C/man7/cpuset.7:1382 build/C/man7/cpuset.7:1430
#, no-wrap
msgid "5)"
msgstr "5)"

#. type: Plain text
#: build/C/man7/cpuset.7:1384
msgid "Attach the shell to the new cpuset."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1389
msgid ""
"For example, the following sequence of commands will set up a cpuset named "
"\"Charlie\", containing just CPUs 2 and 3, and memory node 1, and then "
"attach the current shell to that cpuset."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1403
#, no-wrap
msgid ""
"$B< mkdir /dev/cpuset>\n"
"$B< mount -t cpuset cpuset /dev/cpuset>\n"
"$B< cd /dev/cpuset>\n"
"$B< mkdir Charlie>\n"
"$B< cd Charlie>\n"
"$B< /bin/echo 2-3 E<gt> cpuset.cpus>\n"
"$B< /bin/echo 1 E<gt> cpuset.mems>\n"
"$B< /bin/echo $$ E<gt> tasks>\n"
"# The current shell is now running in cpuset Charlie\n"
"# The next line should display \\(aq/Charlie\\(aq\n"
"$B< cat /proc/self/cpuset>\n"
msgstr ""
"$B< mkdir /dev/cpuset>\n"
"$B< mount -t cpuset cpuset /dev/cpuset>\n"
"$B< cd /dev/cpuset>\n"
"$B< mkdir Charlie>\n"
"$B< cd Charlie>\n"
"$B< /bin/echo 2-3 E<gt> cpuset.cpus>\n"
"$B< /bin/echo 1 E<gt> cpuset.mems>\n"
"$B< /bin/echo $$ E<gt> tasks>\n"
"# The current shell is now running in cpuset Charlie\n"
"# The next line should display \\(aq/Charlie\\(aq\n"
"$B< cat /proc/self/cpuset>\n"

#. type: SS
#: build/C/man7/cpuset.7:1406
#, no-wrap
msgid "Migrating a job to different memory nodes."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1411
msgid ""
"To migrate a job (the set of processes attached to a cpuset)  to different "
"CPUs and memory nodes in the system, including moving the memory pages "
"currently allocated to that job, perform the following steps."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1419
msgid ""
"Let's say we want to move the job in cpuset I<alpha> (CPUs 4\\(en7 and "
"memory nodes 2\\(en3) to a new cpuset I<beta> (CPUs 16\\(en19 and memory "
"nodes 8\\(en9)."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1422
msgid "First create the new cpuset I<beta>."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1425
msgid "Then allow CPUs 16\\(en19 and memory nodes 8\\(en9 in I<beta>."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1430
msgid "Then enable I<memory_migration> in I<beta>."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1435
msgid "Then move each process from I<alpha> to I<beta>."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1438
msgid "The following sequence of commands accomplishes this."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1448
#, no-wrap
msgid ""
"$B< cd /dev/cpuset>\n"
"$B< mkdir beta>\n"
"$B< cd beta>\n"
"$B< /bin/echo 16-19 E<gt> cpuset.cpus>\n"
"$B< /bin/echo 8-9 E<gt> cpuset.mems>\n"
"$B< /bin/echo 1 E<gt> cpuset.memory_migrate>\n"
"$B< while read i; do /bin/echo $i; done E<lt> ../alpha/tasks E<gt> tasks>\n"
msgstr ""
"$B< cd /dev/cpuset>\n"
"$B< mkdir beta>\n"
"$B< cd beta>\n"
"$B< /bin/echo 16-19 E<gt> cpuset.cpus>\n"
"$B< /bin/echo 8-9 E<gt> cpuset.mems>\n"
"$B< /bin/echo 1 E<gt> cpuset.memory_migrate>\n"
"$B< while read i; do /bin/echo $i; done E<lt> ../alpha/tasks E<gt> tasks>\n"

#. type: Plain text
#: build/C/man7/cpuset.7:1457
msgid ""
"The above should move any processes in I<alpha> to I<beta>, and any memory "
"held by these processes on memory nodes 2\\(en3 to memory nodes 8\\(en9, "
"respectively."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1459
msgid "Notice that the last step of the above sequence did not do:"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1463
#, no-wrap
msgid "$B< cp ../alpha/tasks tasks>\n"
msgstr "$B< cp ../alpha/tasks tasks>\n"

#. type: Plain text
#: build/C/man7/cpuset.7:1474
msgid ""
"The I<while> loop, rather than the seemingly easier use of the B<cp>(1)  "
"command, was necessary because only one process PID at a time may be written "
"to the I<tasks> file."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1482
msgid ""
"The same effect (writing one PID at a time) as the I<while> loop can be "
"accomplished more efficiently, in fewer keystrokes and in syntax that works "
"on any shell, but alas more obscurely, by using the B<-u> (unbuffered) "
"option of B<sed>(1):"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1486
#, no-wrap
msgid "$B< sed -un p E<lt> ../alpha/tasks E<gt> tasks>\n"
msgstr "$B< sed -un p E<lt> ../alpha/tasks E<gt> tasks>\n"

#. type: Plain text
#: build/C/man7/cpuset.7:1505
msgid ""
"B<taskset>(1), B<get_mempolicy>(2), B<getcpu>(2), B<mbind>(2), "
"B<sched_getaffinity>(2), B<sched_setaffinity>(2), B<sched_setscheduler>(2), "
"B<set_mempolicy>(2), B<CPU_SET>(3), B<proc>(5), B<cgroups>(7), B<numa>(7), "
"B<sched>(7), B<migratepages>(8), B<numactl>(8)"
msgstr "B<taskset>(1), B<get_mempolicy>(2), B<getcpu>(2), B<mbind>(2), B<sched_getaffinity>(2), B<sched_setaffinity>(2), B<sched_setscheduler>(2), B<set_mempolicy>(2), B<CPU_SET>(3), B<proc>(5), B<cgroups>(7), B<numa>(7), B<sched>(7), B<migratepages>(8), B<numactl>(8)"

#.  commit 45ce80fb6b6f9594d1396d44dd7e7c02d596fef8
#. type: Plain text
#: build/C/man7/cpuset.7:1514
msgid ""
"I<Documentation/admin-guide/cgroup-v1/cpusets.rst> in the Linux kernel "
"source tree (or I<Documentation/cgroup-v1/cpusets.txt> before Linux 4.18, "
"and I<Documentation/cpusets.txt> before Linux 2.6.29)"
msgstr ""

#. type: TH
#: build/C/man7/credentials.7:27
#, no-wrap
msgid "CREDENTIALS"
msgstr "CREDENTIALS"

#. type: Plain text
#: build/C/man7/credentials.7:30
msgid "credentials - process identifiers"
msgstr "credentials - 認証に用いられるプロセスの識別子"

#. type: SS
#: build/C/man7/credentials.7:31
#, no-wrap
msgid "Process ID (PID)"
msgstr "プロセスID (PID)"

#. type: Plain text
#: build/C/man7/credentials.7:41
msgid ""
"Each process has a unique nonnegative integer identifier that is assigned "
"when the process is created using B<fork>(2).  A process can obtain its PID "
"using B<getpid>(2).  A PID is represented using the type I<pid_t> (defined "
"in I<E<lt>sys/types.hE<gt>>)."
msgstr ""
"各プロセスは、負でない整数の一意な識別子を持つ。 この識別子は B<fork>(2)  を"
"使ってプロセスが生成される際に割り当てられる。 プロセスは B<getpid>(2)  を"
"使って自分の PID を取得できる。 PID は I<pid_t> 型で表現される (I<pid_t> は "
"I<E<lt>sys/types.hE<gt>> で定義されている)。"

#.  .BR sched_rr_get_interval (2),
#.  .BR sched_getaffinity (2),
#.  .BR sched_setaffinity (2),
#.  .BR sched_getparam (2),
#.  .BR sched_setparam (2),
#.  .BR sched_setscheduler (2),
#.  .BR sched_getscheduler (2),
#.  .BR getsid (2),
#.  .BR waitid (2),
#.  .BR wait4 (2),
#. type: Plain text
#: build/C/man7/credentials.7:62
msgid ""
"PIDs are used in a range of system calls to identify the process affected by "
"the call, for example: B<kill>(2), B<ptrace>(2), B<setpriority>(2)  "
"B<setpgid>(2), B<setsid>(2), B<sigqueue>(3), and B<waitpid>(2)."
msgstr ""
"PID は各種のシステムコールでそのシステムコールが作用するプロセスを 特定するた"
"めに使用される。以下に例を挙げる: B<kill>(2), B<ptrace>(2), "
"B<setpriority>(2), B<setpgid>(2), B<setsid>(2), B<sigqueue>(3), "
"B<waitpid>(2)."

#. type: Plain text
#: build/C/man7/credentials.7:65
msgid "A process's PID is preserved across an B<execve>(2)."
msgstr "プロセスの PID は B<execve>(2)  の前後で不変である。"

#. type: SS
#: build/C/man7/credentials.7:65
#, no-wrap
msgid "Parent process ID (PPID)"
msgstr "親プロセス ID (PPID)"

#. type: Plain text
#: build/C/man7/credentials.7:73
msgid ""
"A process's parent process ID identifies the process that created this "
"process using B<fork>(2).  A process can obtain its PPID using "
"B<getppid>(2).  A PPID is represented using the type I<pid_t>."
msgstr ""
"プロセスの親プロセスの ID は、 B<fork>(2)  を使ってそのプロセスを生成したプロ"
"セスを示す。 プロセスは B<getppid>(2)  を使って自分の PPID を取得できる。 "
"PPID は I<pid_t> 型で表現される。"

#. type: Plain text
#: build/C/man7/credentials.7:76
msgid "A process's PPID is preserved across an B<execve>(2)."
msgstr "プロセスの PPID は B<execve>(2)  の前後で不変である。"

#. type: SS
#: build/C/man7/credentials.7:76
#, no-wrap
msgid "Process group ID and session ID"
msgstr "プロセスグループ ID とセッション ID"

#. type: Plain text
#: build/C/man7/credentials.7:84
msgid ""
"Each process has a session ID and a process group ID, both represented using "
"the type I<pid_t>.  A process can obtain its session ID using B<getsid>(2), "
"and its process group ID using B<getpgrp>(2)."
msgstr ""
"各プロセスはセッション ID とプロセスグループ ID を持つ。 これらの ID はどちら"
"も I<pid_t> 型で表現される。 プロセスは、それぞれ B<getsid>(2), "
"B<getpgrp>(2)  を使って自分のセッション ID、プロセスグループ ID を取得でき"
"る。"

#. type: Plain text
#: build/C/man7/credentials.7:90
msgid ""
"A child created by B<fork>(2)  inherits its parent's session ID and process "
"group ID.  A process's session ID and process group ID are preserved across "
"an B<execve>(2)."
msgstr ""
"B<fork>(2)  で生成された子プロセスは親プロセスのセッション ID とプロセスグ"
"ループ ID を継承する。プロセスのセッション ID とプロセスグループ ID は "
"B<execve>(2)  の前後で不変である。"

#. type: Plain text
#: build/C/man7/credentials.7:103
msgid ""
"Sessions and process groups are abstractions devised to support shell job "
"control.  A process group (sometimes called a \"job\") is a collection of "
"processes that share the same process group ID; the shell creates a new "
"process group for the process(es) used to execute single command or pipeline "
"(e.g., the two processes created to execute the command \"ls\\ |\\ wc\" are "
"placed in the same process group).  A process's group membership can be set "
"using B<setpgid>(2).  The process whose process ID is the same as its "
"process group ID is the I<process group leader> for that group."
msgstr ""
"セッションとプロセスグループの概念は、シェルのジョブ制御を行うために 考案され"
"たものである。 プロセスグループ (時には「ジョブ」と呼ばれることもある) は、 "
"同じプロセスグループ ID を共有するプロセスの集まりである。 シェルは、一つのコ"
"マンドもしくはパイプラインの実行に使われるプロセス群に 対して一つのプロセスグ"
"ループを生成する (例えば、コマンド \"ls\\ |\\ wc\" を実行するために生成される"
"二つのプロセスは 同じプロセスグループに置かれる)。 所属するプロセスグループ"
"は B<setpgid>(2)  を使って設定できる。 自身のプロセス ID がプロセスグループ "
"ID と同じプロセスは、 そのグループの「プロセスグループリーダー」である。"

#. type: Plain text
#: build/C/man7/credentials.7:115
msgid ""
"A session is a collection of processes that share the same session ID.  All "
"of the members of a process group also have the same session ID (i.e., all "
"of the members of a process group always belong to the same session, so that "
"sessions and process groups form a strict two-level hierarchy of "
"processes.)  A new session is created when a process calls B<setsid>(2), "
"which creates a new session whose session ID is the same as the PID of the "
"process that called B<setsid>(2).  The creator of the session is called the "
"I<session leader>."
msgstr ""
"セッションは、同じセッション ID を共有するプロセスの集まりである。 ある一つの"
"プロセスグループの全メンバーは同じセッション ID を持つ (つまり、一つのプロセ"
"スグループのメンバーは全て同じセッションに所属し、 これにより、セッションとプ"
"ロセスグループで二階層のプロセス階層が形成できる)。 新たなセッションの生成は"
"プロセスが B<setsid>(2)  を呼び出すことで行う。 B<setsid>(2)  は、 "
"B<setsid>(2)  を呼び出したプロセスの PID と同じ値のセッション ID を持つ 新た"
"なセッションを生成する。 セッションの生成者は「セッションリーダー」と呼ばれ"
"る。"

#. type: Plain text
#: build/C/man7/credentials.7:124
msgid ""
"All of the processes in a session share a I<controlling terminal>.  The "
"controlling terminal is established when the session leader first opens a "
"terminal (unless the B<O_NOCTTY> flag is specified when calling "
"B<open>(2)).  A terminal may be the controlling terminal of at most one "
"session."
msgstr ""
"あるセッションの全プロセスは一つの I<制御端末> を共有する。 セッションリー"
"ダーが最初に端末をオープンした際に制御端末は設定される (B<open>(2) の呼び出し"
"で B<O_NOCTTY> フラグが指定された場合を除く)。 一つの端末は、最大でも一つの"
"セッションの制御端末にしかなれない。"

#. type: Plain text
#: build/C/man7/credentials.7:146
msgid ""
"At most one of the jobs in a session may be the I<foreground job>; other "
"jobs in the session are I<background jobs>.  Only the foreground job may "
"read from the terminal; when a process in the background attempts to read "
"from the terminal, its process group is sent a B<SIGTTIN> signal, which "
"suspends the job.  If the B<TOSTOP> flag has been set for the terminal (see "
"B<termios>(3)), then only the foreground job may write to the terminal; "
"writes from background job cause a B<SIGTTOU> signal to be generated, which "
"suspends the job.  When terminal keys that generate a signal (such as the "
"I<interrupt> key, normally control-C)  are pressed, the signal is sent to "
"the processes in the foreground job."
msgstr ""
"一つのセッションのジョブの中で、I<フォアグラウンドジョブ>になれるのは最大でも"
"一つで、そのセッションの他のジョブはI<バックグラウンドジョブ>である。 フォア"
"グラウンドジョブだけが端末からの読み込みを行える。 バックグラウンドのプロセス"
"が端末から読み込みを行おうとした場合、 フォアグラウンドジョブを停止させるシグ"
"ナルである B<SIGTTIN> が所属するプロセスグループに対して送信される。 端末に "
"B<TOSTOP> フラグがセットされていた場合 (B<termios>(3) 参照)、 フォアグラウン"
"ドジョブだけが端末への書き込みを行える。 バックグラウンドのプロセスが端末への"
"書き込みを行おうとした場合、 フォアグラウンドジョブを停止させるシグナルであ"
"る B<SIGTTOU> が生成される。 シグナルを生成する端末キー (例えば I<中断>キー、"
"通常は control-C) が押された場合、 そのシグナルはフォアグラウンドジョブのプロ"
"セスに送信される。"

#. type: Plain text
#: build/C/man7/credentials.7:167
msgid ""
"Various system calls and library functions may operate on all members of a "
"process group, including B<kill>(2), B<killpg>(3), B<getpriority>(2), "
"B<setpriority>(2), B<ioprio_get>(2), B<ioprio_set>(2), B<waitid>(2), and "
"B<waitpid>(2).  See also the discussion of the B<F_GETOWN>, B<F_GETOWN_EX>, "
"B<F_SETOWN>, and B<F_SETOWN_EX> operations in B<fcntl>(2)."
msgstr "様々なシステムコールやライブラリ関数で、プロセスグループの全メンバーに対して操作を行うことができる。 例えば、 B<kill>(2), B<killpg>(3), B<getpriority>(2), B<setpriority>(2), B<ioprio_get>(2), B<ioprio_set>(2), B<waitid>(2), B<waitpid>(2) など。 B<fcntl>(2) の操作 B<F_GETOWN>, B<F_GETOWN_EX>, B<F_SETOWN>, B<F_SETOWN_EX> の議論も参照。"

#. type: SS
#: build/C/man7/credentials.7:167
#, no-wrap
msgid "User and group identifiers"
msgstr "ユーザー ID とグループ ID"

#. type: Plain text
#: build/C/man7/credentials.7:175
msgid ""
"Each process has various associated user and group IDs.  These IDs are "
"integers, respectively represented using the types I<uid_t> and I<gid_t> "
"(defined in I<E<lt>sys/types.hE<gt>>)."
msgstr ""
"各プロセスは、数種類のユーザー ID とグループ ID を持つ。 ユーザー ID、グルー"
"プ ID は整数で、それぞれ I<uid_t>, I<gid_t> 型で表現される (これらは "
"I<E<lt>sys/types.hE<gt>> で定義されている)。"

#. type: Plain text
#: build/C/man7/credentials.7:177
msgid "On Linux, each process has the following user and group identifiers:"
msgstr ""
"Linux では、各プロセスは以下のような種類のユーザー ID とグループ ID を持つ。"

#. type: Plain text
#: build/C/man7/credentials.7:183
msgid ""
"Real user ID and real group ID.  These IDs determine who owns the process.  "
"A process can obtain its real user (group) ID using B<getuid>(2)  "
"(B<getgid>(2))."
msgstr ""
"実ユーザー ID と実グループ ID。 これらの ID によりプロセスの所有者が決定され"
"る。 プロセスが自分の実ユーザー ID、実グループ ID を取得するには、それぞれ "
"B<getuid>(2), B<getgid>(2)  を使用する。"

#. type: Plain text
#: build/C/man7/credentials.7:195
msgid ""
"Effective user ID and effective group ID.  These IDs are used by the kernel "
"to determine the permissions that the process will have when accessing "
"shared resources such as message queues, shared memory, and semaphores.  On "
"most UNIX systems, these IDs also determine the permissions when accessing "
"files.  However, Linux uses the filesystem IDs described below for this "
"task.  A process can obtain its effective user (group) ID using "
"B<geteuid>(2)  (B<getegid>(2))."
msgstr ""
"実効ユーザー ID と実効グループ ID。 これらの ID は、メッセージキュー、共有メ"
"モリー、セマフォなどの 共有リソースにアクセスしようとした際にそのプロセスがア"
"クセス許可を 持っているかをカーネルが判定するのに使用される。 ほとんどの "
"UNIX システムでは、これらの ID はファイルへのアクセス時の アクセス許可の判定"
"にも使用される。 しかしながら、Linux ではファイルへのアクセス許可の判定には "
"後述のファイルシステム ID が使用される。 プロセスが自分の実効ユーザー ID、実"
"効グループ ID を取得するには、それぞれ B<geteuid>(2), B<getegid>(2)  を使用す"
"る。"

#. type: Plain text
#: build/C/man7/credentials.7:217
msgid ""
"Saved set-user-ID and saved set-group-ID.  These IDs are used in set-user-ID "
"and set-group-ID programs to save a copy of the corresponding effective IDs "
"that were set when the program was executed (see B<execve>(2)).  A set-user-"
"ID program can assume and drop privileges by switching its effective user ID "
"back and forth between the values in its real user ID and saved set-user-"
"ID.  This switching is done via calls to B<seteuid>(2), B<setreuid>(2), or "
"B<setresuid>(2).  A set-group-ID program performs the analogous tasks using "
"B<setegid>(2), B<setregid>(2), or B<setresgid>(2).  A process can obtain its "
"saved set-user-ID (set-group-ID) using B<getresuid>(2)  (B<getresgid>(2))."
msgstr ""
"保存 (saved) set-user-ID と保存 set-group-ID。 これらの ID は、set-user-ID "
"や set-group-ID されたプログラムにおいて、 プログラムの実行時に設定された実"
"効 ID のコピーを保存するために 使用される (B<execve>(2)  参照)。 set-user-ID "
"プログラムは、実効ユーザー ID を実ユーザーID と保存 set-user-ID の間で行った"
"り来たり切り替えることで、特権を得たり落としたりできる。 この切り替えは "
"B<seteuid>(2), B<setreuid>(2), B<setresuid>(2)  を呼び出すことで実行できる。 "
"set-group-ID プログラムは、 B<setegid>(2), B<setregid>(2), B<setresgid>(2)  "
"を使って同様のことができる。 プロセスが自分の保存 set-user-ID、保存 set-"
"group-ID を取得するには、 B<getresuid(2),> B<getresgids>(2)  をそれぞれ使用す"
"る。"

#. type: Plain text
#: build/C/man7/credentials.7:234
msgid ""
"Filesystem user ID and filesystem group ID (Linux-specific).  These IDs, in "
"conjunction with the supplementary group IDs described below, are used to "
"determine permissions for accessing files; see B<path_resolution>(7)  for "
"details.  Whenever a process's effective user (group) ID is changed, the "
"kernel also automatically changes the filesystem user (group) ID to the same "
"value.  Consequently, the filesystem IDs normally have the same values as "
"the corresponding effective ID, and the semantics for file-permission checks "
"are thus the same on Linux as on other UNIX systems.  The filesystem IDs can "
"be made to differ from the effective IDs by calling B<setfsuid>(2)  and "
"B<setfsgid>(2)."
msgstr ""
"ファイルシステムユーザー ID とファイルシステムグループ ID (Linux 固有)。 これ"
"らの ID は、後述の補助グループ ID と組み合わせて使用され、 ファイルへのアクセ"
"ス権の決定に利用される。詳細は B<path_resolution>(7)  を参照。 プロセスの実"
"効 ID (ユーザー ID や グループ ID) が変更されるたびに、 カーネルは自動的に対"
"応するファイルシステム ID を同じ値に変更する。 その結果、ファイルシステム ID "
"は通常は対応する実効 ID と同じ値となり、 ファイルのアクセス権のチェック方法"
"は Linux と他の UNIX システムで同じである。 ファイルシステム ID は実効 ID と"
"は異なる値にすることができ、 変更は B<setfsuid>(2)  と B<setfsgid>(2)  を呼び"
"出して行う。"

#.  Since kernel 2.6.4, the limit is visible via the read-only file
#.  /proc/sys/kernel/ngroups_max.
#.  As at 2.6.22-rc2, this file is still read-only.
#. type: Plain text
#: build/C/man7/credentials.7:251
msgid ""
"Supplementary group IDs.  This is a set of additional group IDs that are "
"used for permission checks when accessing files and other shared resources.  "
"On Linux kernels before 2.6.4, a process can be a member of up to 32 "
"supplementary groups; since kernel 2.6.4, a process can be a member of up to "
"65536 supplementary groups.  The call I<sysconf(_SC_NGROUPS_MAX)> can be "
"used to determine the number of supplementary groups of which a process may "
"be a member.  A process can obtain its set of supplementary group IDs using "
"B<getgroups>(2)."
msgstr "補助グループ ID。 この ID は、ファイルや他の共有リソースへのアクセス時にアクセス許可の チェックに使用される、追加のグループ ID の集合である。 カーネル 2.6.4 より前の Linux では、一つのプロセスあたりの 補助グループのメンバー数は最大で 32 である。 カーネル 2.6.4 以降では、一つのプロセスあたりの 補助グループのメンバー数は最大で 65536 である。 I<sysconf(_SC_NGROUPS_MAX)> を呼び出すことで、あるプロセスがメンバーとなることができる可能性のある 補助グループ数を知ることができる。 プロセスは、自分の補助グループ ID の集合を B<getgroups>(2) で取得できる。"

#. type: Plain text
#: build/C/man7/credentials.7:261
msgid ""
"A child process created by B<fork>(2)  inherits copies of its parent's user "
"and groups IDs.  During an B<execve>(2), a process's real user and group ID "
"and supplementary group IDs are preserved; the effective and saved set IDs "
"may be changed, as described in B<execve>(2)."
msgstr ""
"B<fork>(2)  で生成された子プロセスは親プロセスのユーザー ID とグループ ID を"
"継承する。 B<execve>(2)  の間、プロセスの実ユーザー/グループ ID と補助グルー"
"プ ID 集合は不変である。 実効 ID と保存セット ID は変更される可能性がある "
"(B<execve>(2)  で説明されている)。"

#. type: Plain text
#: build/C/man7/credentials.7:264
msgid ""
"Aside from the purposes noted above, a process's user IDs are also employed "
"in a number of other contexts:"
msgstr ""
"上記の目的以外にも、プロセスのユーザー ID は他の様々な場面で利用される。"

#. type: Plain text
#: build/C/man7/credentials.7:267
msgid "when determining the permissions for sending signals (see B<kill>(2));"
msgstr "シグナルを送る許可の判定時 (B<kill>(2)  参照)"

#. type: Plain text
#: build/C/man7/credentials.7:278
msgid ""
"when determining the permissions for setting process-scheduling parameters "
"(nice value, real time scheduling policy and priority, CPU affinity, I/O "
"priority) using B<setpriority>(2), B<sched_setaffinity>(2), "
"B<sched_setscheduler>(2), B<sched_setparam>(2), B<sched_setattr>(2), and "
"B<ioprio_set>(2);"
msgstr ""
"プロセスのスケジューリング関連のパラメーター (nice 値、 リアルタイムスケ"
"ジューリングポリシーや優先度、CPU affinity、 入出力優先度) の設定許可の判定"
"時。 スケジューリング関連のパラメーター設定には B<setpriority>(2), "
"B<sched_setaffinity>(2), B<sched_setscheduler>(2), B<sched_setparam>(2), "
"B<sched_setattr>(2), B<ioprio_set>(2)  が使用される。"

#. type: Plain text
#: build/C/man7/credentials.7:281
msgid "when checking resource limits (see B<getrlimit>(2));"
msgstr "リソース上限のチェック時 (B<getrlimit>(2)  参照)"

#. type: Plain text
#: build/C/man7/credentials.7:286
msgid ""
"when checking the limit on the number of inotify instances that the process "
"may create (see B<inotify>(7))."
msgstr ""
"プロセスが生成できる inotify インスタンス数の上限のチェック時 (B<inotify>(7) "
"参照)"

#. type: SS
#: build/C/man7/credentials.7:286
#, fuzzy, no-wrap
#| msgid "Unmapped user and group IDs"
msgid "Modifying process user and group IDs"
msgstr "マッピングされていないユーザー ID とグループ ID"

#. type: Plain text
#: build/C/man7/credentials.7:290
msgid ""
"Subject to rules described in the relevant manual pages, a process can use "
"the following APIs to modify its user and group IDs:"
msgstr ""

#. type: TP
#: build/C/man7/credentials.7:290
#, no-wrap
msgid "B<setuid>(2) (B<setgid>(2))"
msgstr "B<setuid>(2) (B<setgid>(2))"

#. type: Plain text
#: build/C/man7/credentials.7:294
#, fuzzy
#| msgid ""
#| "setresuid, setresgid - set real, effective and saved user or group ID"
msgid ""
"Modify the process's real (and possibly effective and saved-set)  user "
"(group) IDs."
msgstr ""
"setresuid, setresgid - ユーザーやグループの 実、実効、保存 ID を設定する"

#. type: TP
#: build/C/man7/credentials.7:294
#, no-wrap
msgid "B<seteuid>(2) (B<setegid>(2))"
msgstr "B<seteuid>(2) (B<setegid>(2))"

#. type: Plain text
#: build/C/man7/credentials.7:297
#, fuzzy
#| msgid "seteuid, setegid - set effective user or group ID"
msgid "Modify the process's effective user (group) ID."
msgstr "seteuid, setegid - 実効ユーザー ID や 実効グループ ID を設定する"

#. type: TP
#: build/C/man7/credentials.7:297
#, no-wrap
msgid "B<setfsuid>(2) (B<setfsgid>(2))"
msgstr "B<setfsuid>(2) (B<setfsgid>(2))"

#. type: Plain text
#: build/C/man7/credentials.7:300
msgid "Modify the process's filesystem user (group) ID."
msgstr ""

#. type: TP
#: build/C/man7/credentials.7:300
#, no-wrap
msgid "B<setreuid>(2) (B<setregid>(2))"
msgstr "B<setreuid>(2) (B<setregid>(2))"

#. type: Plain text
#: build/C/man7/credentials.7:304
#, fuzzy
#| msgid ""
#| "setresuid, setresgid - set real, effective and saved user or group ID"
msgid ""
"Modify the process's real and effective (and possibly saved-set)  user "
"(group) IDs."
msgstr ""
"setresuid, setresgid - ユーザーやグループの 実、実効、保存 ID を設定する"

#. type: TP
#: build/C/man7/credentials.7:304
#, no-wrap
msgid "B<setresuid>(2) (B<setresgid>(2))"
msgstr "B<setresuid>(2) (B<setresgid>(2))"

#. type: Plain text
#: build/C/man7/credentials.7:307
#, fuzzy
#| msgid ""
#| "setresuid, setresgid - set real, effective and saved user or group ID"
msgid "Modify the process's real, effective, and saved-set user (group) IDs."
msgstr ""
"setresuid, setresgid - ユーザーやグループの 実、実効、保存 ID を設定する"

#. type: TP
#: build/C/man7/credentials.7:307
#, no-wrap
msgid "B<setgroups>(2)"
msgstr "B<setgroups>(2)"

#. type: Plain text
#: build/C/man7/credentials.7:310
msgid "Modify the process's supplementary group list."
msgstr ""

#. type: Plain text
#: build/C/man7/credentials.7:317
msgid ""
"Any changes to a process's effective user (group) ID are automatically "
"carried over to the process's filesystem user (group) ID.  Changes to a "
"process's effective user or group ID can also affect the process \"dumpable"
"\" attribute, as described in B<prctl>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/credentials.7:321
msgid ""
"Changes to process user and group IDs can affect the capabilities of the "
"process, as described in B<capabilities>(7)."
msgstr ""

#. type: Plain text
#: build/C/man7/credentials.7:327
msgid ""
"Process IDs, parent process IDs, process group IDs, and session IDs are "
"specified in POSIX.1.  The real, effective, and saved set user and groups "
"IDs, and the supplementary group IDs, are specified in POSIX.1.  The "
"filesystem user and group IDs are a Linux extension."
msgstr "プロセス ID、親プロセス ID、プロセスグループ ID、セッション ID は POSIX.1 で規定されている。 実 ID、実効 ID、保存セット ID のユーザー ID / グループ ID および 補助グループ ID は POSIX.1 で規定されている。 ファイルシステムユーザー ID / グループ ID は Linux による拡張である。"

#. type: Plain text
#: build/C/man7/credentials.7:334
msgid ""
"Various fields in the I</proc/[pid]/status> file show the process "
"credentials described above.  See B<proc>(5)  for further information."
msgstr ""

#. type: Plain text
#: build/C/man7/credentials.7:348
msgid ""
"The POSIX threads specification requires that credentials are shared by all "
"of the threads in a process.  However, at the kernel level, Linux maintains "
"separate user and group credentials for each thread.  The NPTL threading "
"implementation does some work to ensure that any change to user or group "
"credentials (e.g., calls to B<setuid>(2), B<setresuid>(2))  is carried "
"through to all of the POSIX threads in a process.  See B<nptl>(7)  for "
"further details."
msgstr "POSIX のスレッド仕様では、これらの識別子がプロセス内の全スレッドで 共有されることを求めている。 しかしながら、カーネルのレベルでは、Linux はスレッド毎に別々の ユーザーとグループに関する識別子を管理している。 NPTL スレッド実装が、(例えば B<setuid>(2), B<setresuid>(2)  などの呼び出しによる) ユーザーやグループに関する識別子に対する変更が プロセス内の全ての POSIX スレッドに対して反映されることを保証する ための処理を行っている。詳細は B<nptl>(7) を参照。"

#. type: Plain text
#: build/C/man7/credentials.7:400
msgid ""
"B<bash>(1), B<csh>(1), B<groups>(1), B<id>(1), B<newgrp>(1), B<ps>(1), "
"B<runuser>(1), B<setpriv>(1), B<sg>(1), B<su>(1), B<access>(2), "
"B<execve>(2), B<faccessat>(2), B<fork>(2), B<getgroups>(2), B<getpgrp>(2), "
"B<getpid>(2), B<getppid>(2), B<getsid>(2), B<kill>(2), B<setegid>(2), "
"B<seteuid>(2), B<setfsgid>(2), B<setfsuid>(2), B<setgid>(2), "
"B<setgroups>(2), B<setpgid>(2), B<setresgid>(2), B<setresuid>(2), "
"B<setsid>(2), B<setuid>(2), B<waitpid>(2), B<euidaccess>(3), "
"B<initgroups>(3), B<killpg>(3), B<tcgetpgrp>(3), B<tcgetsid>(3), "
"B<tcsetpgrp>(3), B<group>(5), B<passwd>(5), B<shadow>(5), "
"B<capabilities>(7), B<namespaces>(7), B<path_resolution>(7), "
"B<pid_namespaces>(7), B<pthreads>(7), B<signal>(7), B<system_data_types>(7), "
"B<unix>(7), B<user_namespaces>(7), B<sudo>(8)"
msgstr "B<bash>(1), B<csh>(1), B<groups>(1), B<id>(1), B<newgrp>(1), B<ps>(1), B<runuser>(1), B<setpriv>(1), B<sg>(1), B<su>(1), B<access>(2), B<execve>(2), B<faccessat>(2), B<fork>(2), B<getgroups>(2), B<getpgrp>(2), B<getpid>(2), B<getppid>(2), B<getsid>(2), B<kill>(2), B<setegid>(2), B<seteuid>(2), B<setfsgid>(2), B<setfsuid>(2), B<setgid>(2), B<setgroups>(2), B<setpgid>(2), B<setresgid>(2), B<setresuid>(2), B<setsid>(2), B<setuid>(2), B<waitpid>(2), B<euidaccess>(3), B<initgroups>(3), B<killpg>(3), B<tcgetpgrp>(3), B<tcgetsid>(3), B<tcsetpgrp>(3), B<group>(5), B<passwd>(5), B<shadow>(5), B<capabilities>(7), B<namespaces>(7), B<path_resolution>(7), B<pid_namespaces>(7), B<pthreads>(7), B<signal>(7), B<system_data_types>(7), B<unix>(7), B<user_namespaces>(7), B<sudo>(8)"

#. type: TH
#: build/C/man2/getgid.2:25
#, no-wrap
msgid "GETGID"
msgstr "GETGID"

#. type: TH
#: build/C/man2/getgid.2:25 build/C/man2/getgroups.2:32
#: build/C/man2/getuid.2:26 build/C/man2/ioprio_set.2:24
#: build/C/man2/setgid.2:30 build/C/man2/setuid.2:31
#, no-wrap
msgid "2019-03-06"
msgstr "2019-03-06"

#. type: Plain text
#: build/C/man2/getgid.2:28
msgid "getgid, getegid - get group identity"
msgstr "getgid, getegid - グループ ID を得る"

#. type: Plain text
#: build/C/man2/getgid.2:30 build/C/man2/getgroups.2:39
#: build/C/man2/getpid.2:32 build/C/man2/getresuid.2:35
#: build/C/man2/getsid.2:34 build/C/man2/getuid.2:31
#: build/C/man3/group_member.3:30 build/C/man2/seteuid.2:36
#: build/C/man2/setgid.2:37 build/C/man2/setpgid.2:55
#: build/C/man2/setresuid.2:34 build/C/man2/setreuid.2:53
#: build/C/man2/setsid.2:39 build/C/man2/setuid.2:38
msgid "B<#include E<lt>unistd.hE<gt>>"
msgstr "B<#include E<lt>unistd.hE<gt>>"

#. type: Plain text
#: build/C/man2/getgid.2:32 build/C/man2/getgroups.2:37
#: build/C/man2/getpid.2:30 build/C/man2/getsid.2:32 build/C/man2/getuid.2:33
#: build/C/man2/seteuid.2:34 build/C/man2/setgid.2:35 build/C/man2/setpgid.2:53
#: build/C/man2/setreuid.2:51 build/C/man2/setsid.2:37 build/C/man2/setuid.2:36
msgid "B<#include E<lt>sys/types.hE<gt>>"
msgstr "B<#include E<lt>sys/types.hE<gt>>"

#. type: Plain text
#: build/C/man2/getgid.2:34
msgid "B<gid_t getgid(void);>"
msgstr "B<gid_t getgid(void);>"

#. type: Plain text
#: build/C/man2/getgid.2:36
msgid "B<gid_t getegid(void);>"
msgstr "B<gid_t getegid(void);>"

#. type: Plain text
#: build/C/man2/getgid.2:39
msgid "B<getgid>()  returns the real group ID of the calling process."
msgstr "B<getgid>()  は呼び出し元のプロセスの実グループ ID を返す。"

#. type: Plain text
#: build/C/man2/getgid.2:42
msgid "B<getegid>()  returns the effective group ID of the calling process."
msgstr "B<getegid>()  は呼び出し元のプロセスの実効グループ ID を返す。"

#. type: Plain text
#: build/C/man2/getgid.2:44 build/C/man2/getpid.2:55 build/C/man2/getuid.2:45
msgid "These functions are always successful."
msgstr "これらの関数は常に成功する。"

#. type: Plain text
#: build/C/man2/getgid.2:46 build/C/man2/getuid.2:47 build/C/man2/seteuid.2:105
msgid "POSIX.1-2001, POSIX.1-2008, 4.3BSD."
msgstr "POSIX.1-2001, POSIX.1-2008, 4.3BSD."

#. type: Plain text
#: build/C/man2/getgid.2:62
msgid ""
"The original Linux B<getgid>()  and B<getegid>()  system calls supported "
"only 16-bit group IDs.  Subsequently, Linux 2.4 added B<getgid32>()  and "
"B<getegid32>(), supporting 32-bit IDs.  The glibc B<getgid>()  and "
"B<getegid>()  wrapper functions transparently deal with the variations "
"across kernel versions."
msgstr ""
"元々の Linux の B<getgid>() と B<getegid>() システムコールは\n"
"16 ビットのグループ ID だけに対応していた。\n"
"その後、Linux 2.4 で、32 ビットの ID に対応した\n"
"B<getgid32>() と B<getegid32>() が追加された。\n"
"glibc の B<getgid>() と B<getegid>() のラッパー関数は\n"
"カーネルバージョンによるこの違いを吸収している。"

#. type: Plain text
#: build/C/man2/getgid.2:78
#, fuzzy
#| msgid ""
#| "The original Linux B<getgid>()  and B<getegid>()  system calls supported "
#| "only 16-bit group IDs.  Subsequently, Linux 2.4 added B<getgid32>()  and "
#| "B<getegid32>(), supporting 32-bit IDs.  The glibc B<getgid>()  and "
#| "B<getegid>()  wrapper functions transparently deal with the variations "
#| "across kernel versions."
msgid ""
"On Alpha, instead of a pair of B<getgid>()  and B<getegid>()  system calls, "
"a single B<getxgid>()  system call is provided, which returns a pair of real "
"and effective GIDs.  The glibc B<getgid>()  and B<getegid>()  wrapper "
"functions transparently deal with this.  See B<syscall>(2)  for details "
"regarding register mapping."
msgstr ""
"元々の Linux の B<getgid>() と B<getegid>() システムコールは\n"
"16 ビットのグループ ID だけに対応していた。\n"
"その後、Linux 2.4 で、32 ビットの ID に対応した\n"
"B<getgid32>() と B<getegid32>() が追加された。\n"
"glibc の B<getgid>() と B<getegid>() のラッパー関数は\n"
"カーネルバージョンによるこの違いを吸収している。"

#. type: Plain text
#: build/C/man2/getgid.2:83
msgid "B<getresgid>(2), B<setgid>(2), B<setregid>(2), B<credentials>(7)"
msgstr "B<getresgid>(2), B<setgid>(2), B<setregid>(2), B<credentials>(7)"

#. type: TH
#: build/C/man2/getgroups.2:32
#, no-wrap
msgid "GETGROUPS"
msgstr "GETGROUPS"

#. type: Plain text
#: build/C/man2/getgroups.2:35
msgid "getgroups, setgroups - get/set list of supplementary group IDs"
msgstr "getgroups, setgroups - 補助グループ ID のリストを取得/設定する"

#. type: Plain text
#: build/C/man2/getgroups.2:41
msgid "B<int getgroups(int >I<size>B<, gid_t >I<list>B<[]);>"
msgstr "B<int getgroups(int >I<size>B<, gid_t >I<list>B<[]);>"

#. type: Plain text
#: build/C/man2/getgroups.2:43
msgid "B<#include E<lt>grp.hE<gt>>"
msgstr "B<#include E<lt>grp.hE<gt>>"

#. type: Plain text
#: build/C/man2/getgroups.2:45
msgid "B<int setgroups(size_t >I<size>B<, const gid_t *>I<list>B<);>"
msgstr "B<int setgroups(size_t >I<size>B<, const gid_t *>I<list>B<);>"

#. type: Plain text
#: build/C/man2/getgroups.2:56
#, no-wrap
msgid ""
"B<setgroups>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man2/getgroups.2:68
msgid ""
"B<getgroups>()  returns the supplementary group IDs of the calling process "
"in I<list>.  The argument I<size> should be set to the maximum number of "
"items that can be stored in the buffer pointed to by I<list>.  If the "
"calling process is a member of more than I<size> supplementary groups, then "
"an error results."
msgstr "B<getgroups>()  は呼び出し元プロセスの補助グループ (supplementary group) ID を I<list> に返す。 I<size> 引数には、 I<list> により参照されるバッファーに格納できる要素の最大数を設定すべきである。 呼び出し元プロセスが I<size> 個より多くの補助グループのメンバの場合には、エラーとなる。"

#. type: Plain text
#: build/C/man2/getgroups.2:74
msgid ""
"It is unspecified whether the effective group ID of the calling process is "
"included in the returned list.  (Thus, an application should also call "
"B<getegid>(2)  and add or remove the resulting value.)"
msgstr "この関数を呼び出したプロセスの実効グループ ID が、 返されるリストに含まれるかどうかは規定されていない (したがって、アプリケーションは B<getegid>(2) を呼び出し、その結果の値を追加・削除すべきである)。"

#. type: Plain text
#: build/C/man2/getgroups.2:85
msgid ""
"If I<size> is zero, I<list> is not modified, but the total number of "
"supplementary group IDs for the process is returned.  This allows the caller "
"to determine the size of a dynamically allocated I<list> to be used in a "
"further call to B<getgroups>()."
msgstr ""
"I<size> が 0 ならば、 I<list> は修正されないが、そのプロセスの補助グループ "
"ID の合計数が返される。 これを使うことで、それ以降の B<getgroups>()  の呼び出"
"しで必要となる動的割り当てバッファー I<list> のサイズを、呼び出し元が決定する"
"ことができる。"

#. type: Plain text
#: build/C/man2/getgroups.2:97
#, fuzzy
#| msgid ""
#| "B<setgroups>()  sets the supplementary group IDs for the calling "
#| "process.  Appropriate privileges (Linux: the B<CAP_SETGID> capability) "
#| "are required.  The I<size> argument specifies the number of supplementary "
#| "group IDs in the buffer pointed to by I<list>."
msgid ""
"B<setgroups>()  sets the supplementary group IDs for the calling process.  "
"Appropriate privileges are required (see the description of the B<EPERM> "
"error, below).  The I<size> argument specifies the number of supplementary "
"group IDs in the buffer pointed to by I<list>.  A process can drop all of "
"its supplementary groups with the call:"
msgstr ""
"B<setgroups>()  は、呼び出し元プロセスの補助グループ ID を設定する。 適切な特"
"権 (Linux では B<CAP_SETGID> ケーパビリティ (capability)) が必要である。 "
"I<size> 引数には、 I<list> により参照されるバッファーに格納された補助グルー"
"プ ID の数を指定する。"

#. type: Plain text
#: build/C/man2/getgroups.2:101
#, no-wrap
msgid "setgroups(0, NULL);\n"
msgstr "setgroups(0, NULL);\n"

#. type: Plain text
#: build/C/man2/getgroups.2:110
msgid ""
"On success, B<getgroups>()  returns the number of supplementary group IDs.  "
"On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""
"B<getgroups>()  は、成功すると補助グループ ID の数を返す。 エラーの場合 -1 を"
"返し、 I<errno> を適切に設定する。"

#. type: Plain text
#: build/C/man2/getgroups.2:117
msgid ""
"On success, B<setgroups>()  returns 0.  On error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""
"B<setgroups>()  は、成功すると 0 を返す。 エラーの場合 -1 を返し、 I<errno> "
"を適切に設定する。"

#. type: Plain text
#: build/C/man2/getgroups.2:122
msgid "I<list> has an invalid address."
msgstr "I<list> が不正なアドレスである。"

#. type: Plain text
#: build/C/man2/getgroups.2:125
msgid "B<getgroups>()  can additionally fail with the following error:"
msgstr "B<getgroups>()  は、上記に加えて以下のエラーで失敗する可能性がある。"

#. type: Plain text
#: build/C/man2/getgroups.2:129
msgid ""
"I<size> is less than the number of supplementary group IDs, but is not zero."
msgstr "I<size> が補助グループ ID の数より小さいが 0 でない。"

#. type: Plain text
#: build/C/man2/getgroups.2:132
msgid "B<setgroups>()  can additionally fail with the following errors:"
msgstr "B<setgroups>()  は、上記に加えて以下のエラーで失敗する可能性がある。"

#. type: Plain text
#: build/C/man2/getgroups.2:138
msgid ""
"I<size> is greater than B<NGROUPS_MAX> (32 before Linux 2.6.4; 65536 since "
"Linux 2.6.4)."
msgstr ""
"I<size> が B<NGROUPS_MAX> より大きい (B<NGROUPS_MAX> は Linux 2.6.4 より前で"
"は 32、Linux 2.6.4 以降では 65536)。"

#. type: Plain text
#: build/C/man2/getgroups.2:147
#, fuzzy
#| msgid ""
#| "The calling process has insufficient privilege to enable process "
#| "accounting.  On Linux the B<CAP_SYS_PACCT> capability is required."
msgid ""
"The calling process has insufficient privilege (the caller does not have the "
"B<CAP_SETGID> capability in the user namespace in which it resides)."
msgstr ""
"呼び出したプロセスにはプロセスアカウントを有効にするのに十分な特権がない。 "
"Linux では B<CAP_SYS_PACCT> ケーパビリティ (capability) が必要である。"

#. type: TP
#: build/C/man2/getgroups.2:147
#, no-wrap
msgid "B<EPERM> (since Linux 3.19)"
msgstr "B<EPERM> (Linux 3.19 以降)"

#. type: Plain text
#: build/C/man2/getgroups.2:156
msgid ""
"The use of B<setgroups>()  is denied in this user namespace.  See the "
"description of I</proc/[pid]/setgroups> in B<user_namespaces>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/getgroups.2:159
msgid "B<getgroups>(): SVr4, 4.3BSD, POSIX.1-2001, POSIX.1-2008."
msgstr "B<getgroups>(): SVr4, 4.3BSD, POSIX.1-2001, POSIX.1-2008."

#. type: Plain text
#: build/C/man2/getgroups.2:165
#, fuzzy
#| msgid ""
#| "SVr4, 4.3BSD.  The B<getgroups>()  function is in POSIX.1-2001.  Since "
#| "B<setgroups>()  requires privilege, it is not covered by POSIX.1-2001."
msgid ""
"B<setgroups>(): SVr4, 4.3BSD.  Since B<setgroups>()  requires privilege, it "
"is not covered by POSIX.1."
msgstr ""
"SVr4, 4.3BSD.  B<getgroups>()  関数は POSIX.1-2001 に準拠している。 "
"B<setgroups>()  は特権を必要とするため、POSIX.1-2001 に従っていない。"

#. type: Plain text
#: build/C/man2/getgroups.2:177
msgid ""
"A process can have up to B<NGROUPS_MAX> supplementary group IDs in addition "
"to the effective group ID.  The constant B<NGROUPS_MAX> is defined in "
"I<E<lt>limits.hE<gt>>.  The set of supplementary group IDs is inherited from "
"the parent process, and preserved across an B<execve>(2)."
msgstr ""
"プロセスは、実効グループ ID に加え、最大 B<NGROUPS_MAX> までの補助グループ "
"ID を持つことができる。 定数 B<NGROUPS_MAX> は I<E<lt>limits.hE<gt>> で定義さ"
"れている。 補助グループ ID の集合は親プロセスから継承され、 B<execve>(2)  の"
"前後で保持される。"

#. type: Plain text
#: build/C/man2/getgroups.2:180
msgid ""
"The maximum number of supplementary group IDs can be found at run time using "
"B<sysconf>(3):"
msgstr ""
"補助グループ ID の最大数は、実行時に B<sysconf>(3)  を使って以下のようにして"
"調べることができる:"

#. type: Plain text
#: build/C/man2/getgroups.2:185
#, no-wrap
msgid ""
"long ngroups_max;\n"
"ngroups_max = sysconf(_SC_NGROUPS_MAX);\n"
msgstr ""
"long ngroups_max;\n"
"ngroups_max = sysconf(_SC_NGROUPS_MAX);\n"

#. type: Plain text
#: build/C/man2/getgroups.2:194
msgid ""
"The maximum return value of B<getgroups>()  cannot be larger than one more "
"than this value.  Since Linux 2.6.4, the maximum number of supplementary "
"group IDs is also exposed via the Linux-specific read-only file, I</proc/sys/"
"kernel/ngroups_max>."
msgstr ""
"B<getgroups>() の返り値の最大値は、この値より大きくなることはない。 Linux "
"2.6.4 以降では、補助グループ ID の最大数も Linux 固有の読み込み専用のファイ"
"ル I</proc/sys/kernel/ngroups_max> 経由で公開されている。"

#. type: Plain text
#: build/C/man2/getgroups.2:205
msgid ""
"The original Linux B<getgroups>()  system call supported only 16-bit group "
"IDs.  Subsequently, Linux 2.4 added B<getgroups32>(), supporting 32-bit "
"IDs.  The glibc B<getgroups>()  wrapper function transparently deals with "
"the variation across kernel versions."
msgstr ""
"元々の Linux の B<getgroups>() システムコールは 16 ビットのグループ ID だけ\n"
"に対応していた。その後、Linux 2.4 で、32 ビットの ID に対応した\n"
"B<getgroups>() が追加された。glibc の B<getgroups> のラッパー関数はカーネル\n"
"バージョンによるこの違いを吸収している。"

#. type: SS
#: build/C/man2/getgroups.2:205 build/C/man2/getpid.2:75
#: build/C/man2/getpriority.2:225 build/C/man2/seteuid.2:136
#: build/C/man2/setfsgid.2:96 build/C/man2/setfsuid.2:114
#: build/C/man2/setgid.2:87 build/C/man2/setresuid.2:142
#: build/C/man2/setreuid.2:198 build/C/man2/setuid.2:149
#, no-wrap
msgid "C library/kernel differences"
msgstr "C ライブラリとカーネルの違い"

#. type: Plain text
#: build/C/man2/getgroups.2:219
msgid ""
"At the kernel level, user IDs and group IDs are a per-thread attribute.  "
"However, POSIX requires that all threads in a process share the same "
"credentials.  The NPTL threading implementation handles the POSIX "
"requirements by providing wrapper functions for the various system calls "
"that change process UIDs and GIDs.  These wrapper functions (including the "
"one for B<setgroups>())  employ a signal-based technique to ensure that when "
"one thread changes credentials, all of the other threads in the process also "
"change their credentials.  For details, see B<nptl>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/getgroups.2:227
msgid ""
"B<getgid>(2), B<setgid>(2), B<getgrouplist>(3), B<group_member>(3), "
"B<initgroups>(3), B<capabilities>(7), B<credentials>(7)"
msgstr ""
"B<getgid>(2), B<setgid>(2), B<getgrouplist>(3), B<group_member>(3), "
"B<initgroups>(3), B<capabilities>(7), B<credentials>(7)"

#. type: TH
#: build/C/man2/getpid.2:25
#, no-wrap
msgid "GETPID"
msgstr "GETPID"

#. type: Plain text
#: build/C/man2/getpid.2:28
msgid "getpid, getppid - get process identification"
msgstr "getpid, getppid - プロセス ID を得る"

#. type: Plain text
#: build/C/man2/getpid.2:34
msgid "B<pid_t getpid(void);>"
msgstr "B<pid_t getpid(void);>"

#. type: Plain text
#: build/C/man2/getpid.2:36
msgid "B<pid_t getppid(void);>"
msgstr "B<pid_t getppid(void);>"

#. type: Plain text
#: build/C/man2/getpid.2:41
msgid ""
"B<getpid>()  returns the process ID (PID) of the calling process.  (This is "
"often used by routines that generate unique temporary filenames.)"
msgstr "B<getpid>()  は呼び出し元のプロセスのプロセス ID (PID) を返す。(テンポラリ用のファイル名として 他と重ならない名前を生成するルーチンでしばしば使用される。)"

#. type: Plain text
#: build/C/man2/getpid.2:53
msgid ""
"B<getppid>()  returns the process ID of the parent of the calling process.  "
"This will be either the ID of the process that created this process using "
"B<fork>(), or, if that process has already terminated, the ID of the process "
"to which this process has been reparented (either B<init>(1)  or a "
"\"subreaper\" process defined via the B<prctl>(2)  B<PR_SET_CHILD_SUBREAPER> "
"operation)."
msgstr ""

#. type: Plain text
#: build/C/man2/getpid.2:57
msgid "POSIX.1-2001, POSIX.1-2008, 4.3BSD, SVr4."
msgstr "POSIX.1-2001, POSIX.1-2008, 4.3BSD, SVr4."

#. type: Plain text
#: build/C/man2/getpid.2:62
msgid ""
"If the caller's parent is in a different PID namespace (see "
"B<pid_namespaces>(7)), B<getppid>()  returns 0."
msgstr ""

#. type: Plain text
#: build/C/man2/getpid.2:75
msgid ""
"From a kernel perspective, the PID (which is shared by all of the threads in "
"a multithreaded process)  is sometimes also known as the thread group ID "
"(TGID).  This contrasts with the kernel thread ID (TID), which is unique for "
"each thread.  For further details, see B<gettid>(2)  and the discussion of "
"the B<CLONE_THREAD> flag in B<clone>(2)."
msgstr ""

#.  The following program demonstrates this "feature":
#.  #define _GNU_SOURCE
#.  #include <sys/syscall.h>
#.  #include <sys/wait.h>
#.  #include <stdint.h>
#.  #include <stdio.h>
#.  #include <stdlib.h>
#.  #include <unistd.h>
#.  int
#.  main(int argc, char *argv[])
#.  {
#.     /* The following statement fills the getpid() cache */
#.     printf("parent PID = %ld
#. ", (intmax_t) getpid());
#.     if (syscall(SYS_fork) == 0) {
#.         if (getpid() != syscall(SYS_getpid))
#.             printf("child getpid() mismatch: getpid()=%jd; "
#.                     "syscall(SYS_getpid)=%ld
#. ",
#.                     (intmax_t) getpid(), (long) syscall(SYS_getpid));
#.         exit(EXIT_SUCCESS);
#.     }
#.     wait(NULL);
#. }
#. type: Plain text
#: build/C/man2/getpid.2:130
#, fuzzy
#| msgid ""
#| "Since glibc version 2.3.4, the glibc wrapper function for B<getpid>()  "
#| "caches PIDs, so as to avoid additional system calls when a process calls "
#| "B<getpid>()  repeatedly.  Normally this caching is invisible, but its "
#| "correct operation relies on support in the wrapper functions for "
#| "B<fork>(2), B<vfork>(2), and B<clone>(2): if an application bypasses the "
#| "glibc wrappers for these system calls by using B<syscall>(2), then a call "
#| "to B<getpid>()  in the child will return the wrong value (to be precise: "
#| "it will return the PID of the parent process).  See also B<clone>(2)  for "
#| "discussion of a case where B<getpid>()  may return the wrong value even "
#| "when invoking B<clone>(2)  via the glibc wrapper function."
msgid ""
"From glibc version 2.3.4 up to and including version 2.24, the glibc wrapper "
"function for B<getpid>()  cached PIDs, with the goal of avoiding additional "
"system calls when a process calls B<getpid>()  repeatedly.  Normally this "
"caching was invisible, but its correct operation relied on support in the "
"wrapper functions for B<fork>(2), B<vfork>(2), and B<clone>(2): if an "
"application bypassed the glibc wrappers for these system calls by using "
"B<syscall>(2), then a call to B<getpid>()  in the child would return the "
"wrong value (to be precise: it would return the PID of the parent process).  "
"In addition, there were cases where B<getpid>()  could return the wrong "
"value even when invoking B<clone>(2)  via the glibc wrapper function.  (For "
"a discussion of one such case, see BUGS in B<clone>(2).)  Furthermore, the "
"complexity of the caching code had been the source of a few bugs within "
"glibc over the years."
msgstr ""
"glibc バージョン 2.3.4 以降では、 glibc の B<getpid>()  のラッパー関数は PID "
"をキャッシュする。 これは、プロセスが繰り返し B<getpid>()  を呼び出した場合に"
"その都度システムコールを呼ぶのを避けるためである。 通常は、このキャッシュ処理"
"が見えることはないが、 キャッシュ処理が正しく働くためには B<fork>(2), "
"B<vfork>(2), B<clone>(2)  のラッパー関数でのサポートが必要である。 アプリケー"
"ションがこれらのシステムコールを呼び出す際に、 glibc のラッパー関数を経由せず"
"に B<syscall>(2)  を使った場合には、子プロセスで B<getpid>()  を呼び出すと間"
"違った値が返ることだろう (正確にいうと、親プロセスの PID が返される)。 "
"B<clone>(2)  を glibc のラッパー関数経由で起動した際にも B<getpid>()  が間"
"違った値を返す場合があり、これに関する議論は B<clone>(2)  も参照してほしい。"

#.  commit c579f48edba88380635ab98cb612030e3ed8691e
#.  https://sourceware.org/glibc/wiki/Release/2.25#pid_cache_removal
#.  FIXME .
#.  Review progress of https://bugzilla.redhat.com/show_bug.cgi?id=1469757
#. type: Plain text
#: build/C/man2/getpid.2:140
msgid ""
"Because of the aforementioned problems, since glibc version 2.25, the PID "
"cache is removed: calls to B<getpid>()  always invoke the actual system "
"call, rather than returning a cached value."
msgstr ""

#. type: Plain text
#: build/C/man2/getpid.2:156
#, fuzzy
#| msgid ""
#| "The original Linux B<getuid>()  and B<geteuid>()  system calls supported "
#| "only 16-bit user IDs.  Subsequently, Linux 2.4 added B<getuid32>()  and "
#| "B<geteuid32>(), supporting 32-bit IDs.  The glibc B<getuid>()  and "
#| "B<geteuid>()  wrapper functions transparently deal with the variations "
#| "across kernel versions."
msgid ""
"On Alpha, instead of a pair of B<getpid>()  and B<getppid>()  system calls, "
"a single B<getxpid>()  system call is provided, which returns a pair of PID "
"and parent PID.  The glibc B<getpid>()  and B<getppid>()  wrapper functions "
"transparently deal with this.  See B<syscall>(2)  for details regarding "
"register mapping."
msgstr ""
"元々の Linux の B<getuid>() と B<geteuid>() システムコールは\n"
"16 ビットのグループ ID だけに対応していた。\n"
"その後、Linux 2.4 で、32 ビットの ID に対応した\n"
"B<getuid32>() と B<geteuid32>() が追加された。\n"
"glibc の B<getuid>() と B<geteuid>() のラッパー関数は\n"
"カーネルバージョンによるこの違いを吸収している。"

#. type: Plain text
#: build/C/man2/getpid.2:168
msgid ""
"B<clone>(2), B<fork>(2), B<gettid>(2), B<kill>(2), B<exec>(3), "
"B<mkstemp>(3), B<tempnam>(3), B<tmpfile>(3), B<tmpnam>(3), "
"B<credentials>(7), B<pid_namespaces>(7)"
msgstr "B<clone>(2), B<fork>(2), B<gettid>(2), B<kill>(2), B<exec>(3), B<mkstemp>(3), B<tempnam>(3), B<tmpfile>(3), B<tmpnam>(3), B<credentials>(7), B<pid_namespaces>(7)"

#. type: TH
#: build/C/man2/getpriority.2:45
#, no-wrap
msgid "GETPRIORITY"
msgstr "GETPRIORITY"

#. type: Plain text
#: build/C/man2/getpriority.2:48
msgid "getpriority, setpriority - get/set program scheduling priority"
msgstr ""
"getpriority, setpriority - プログラムのスケジューリングの優先度を取得/設定す"
"る"

#. type: Plain text
#: build/C/man2/getpriority.2:50 build/C/man2/getrlimit.2:69
#: build/C/man2/getrusage.2:44
msgid "B<#include E<lt>sys/time.hE<gt>>"
msgstr "B<#include E<lt>sys/time.hE<gt>>"

#. type: Plain text
#: build/C/man2/getpriority.2:52 build/C/man2/getrlimit.2:71
#: build/C/man2/getrusage.2:46
msgid "B<#include E<lt>sys/resource.hE<gt>>"
msgstr "B<#include E<lt>sys/resource.hE<gt>>"

#. type: Plain text
#: build/C/man2/getpriority.2:54
msgid "B<int getpriority(int >I<which>B<, id_t >I<who>B<);>"
msgstr "B<int getpriority(int >I<which>B<, id_t >I<who>B<);>"

#. type: Plain text
#: build/C/man2/getpriority.2:56
msgid "B<int setpriority(int >I<which>B<, id_t >I<who>B<, int >I<prio>B<);>"
msgstr "B<int setpriority(int >I<which>B<, id_t >I<who>B<, int >I<prio>B<);>"

#. type: Plain text
#: build/C/man2/getpriority.2:70
#, fuzzy
#| msgid ""
#| "The scheduling priority of the process, process group, or user, as "
#| "indicated by I<which> and I<who> is obtained with the B<getpriority>()  "
#| "call and set with the B<setpriority>()  call."
msgid ""
"The scheduling priority of the process, process group, or user, as indicated "
"by I<which> and I<who> is obtained with the B<getpriority>()  call and set "
"with the B<setpriority>()  call.  The process attribute dealt with by these "
"system calls is the same attribute (also known as the \"nice\" value) that "
"is dealt with by B<nice>(2)."
msgstr ""
"システムコール B<getpriority>()  や B<setpriority>()  は、 I<which> と "
"I<who> で指定されたプロセス、プロセスグループ、ユーザーの スケジューリング優"
"先度 (scheduling priority) の 取得や設定をそれぞれ行う。"

#. type: Plain text
#: build/C/man2/getpriority.2:93
msgid ""
"The value I<which> is one of B<PRIO_PROCESS>, B<PRIO_PGRP>, or B<PRIO_USER>, "
"and I<who> is interpreted relative to I<which> (a process identifier for "
"B<PRIO_PROCESS>, process group identifier for B<PRIO_PGRP>, and a user ID "
"for B<PRIO_USER>).  A zero value for I<who> denotes (respectively) the "
"calling process, the process group of the calling process, or the real user "
"ID of the calling process."
msgstr "I<which> の値は B<PRIO_PROCESS>, B<PRIO_PGRP>, B<PRIO_USER>, のどれか一つで、 I<who> は I<which> に応じて解釈される (B<PRIO_PROCESS> だとプロセス識別子、 B<PRIO_PGRP> だとプロセスグループ識別子、 B<PRIO_USER> だと UID (ユーザーID) と解釈される)。 I<who> がゼロならば、(それぞれ)呼び出したプロセス、 呼び出したプロセスのプロセスグループ、 呼び出したプロセスの実UID を意味する。"

#. type: Plain text
#: build/C/man2/getpriority.2:102
msgid ""
"The I<prio> argument is a value in the range -20 to 19 (but see NOTES "
"below).  with -20 being the highest priority and 19 being the lowest "
"priority.  Attempts to set a priority outside this range are silently "
"clamped to the range.  The default priority is 0; lower values give a "
"process a higher scheduling priority."
msgstr "I<prio> 引数は -20 から 19 の範囲の値で (但し以下の「注意」を参照)、 -20 が最高優先度で、 19 が最低優先度である。優先度をこの範囲外に設定しようとした場合は、値は黙ってこの範囲となる。デフォルトの優先度は 0 である; 小さな数字ほど、プロセスのスケジューリング優先度が高くなる。"

#. type: Plain text
#: build/C/man2/getpriority.2:111
msgid ""
"The B<getpriority>()  call returns the highest priority (lowest numerical "
"value)  enjoyed by any of the specified processes.  The B<setpriority>()  "
"call sets the priorities of all of the specified processes to the specified "
"value."
msgstr "B<getpriority>()  コールは指定したプロセスの中の最も高い優先度 (数値的には最小の値) を返す。 B<setpriority>()  コールは指定したプロセス全ての優先度を指定した値に設定する。"

#. type: Plain text
#: build/C/man2/getpriority.2:120
msgid ""
"Traditionally, only a privileged process could lower the nice value (i.e., "
"set a higher priority).  However, since Linux 2.6.12, an unprivileged "
"process can decrease the nice value of a target process that has a suitable "
"B<RLIMIT_NICE> soft limit; see B<getrlimit>(2)  for details."
msgstr ""

#. type: Plain text
#: build/C/man2/getpriority.2:127
#, fuzzy
#| msgid ""
#| "On success, B<ioprio_set>()  returns 0.  On error, -1 is returned, and "
#| "I<errno> is set to indicate the error."
msgid ""
"On success, B<getpriority>()  returns the calling thread's nice value, which "
"may be a negative number.  On error, it returns -1 and sets I<errno> to "
"indicate the cause of the error."
msgstr ""
"成功すると、 B<ioprio_set>()  は 0 を返す。 エラーの場合、-1 を返し、 "
"I<errno> にエラーを示す値を設定する。"

#. type: Plain text
#: build/C/man2/getpriority.2:138
msgid ""
"Since a successful call to B<getpriority>()  can legitimately return the "
"value -1, it is necessary to clear the external variable I<errno> prior to "
"the call, then check I<errno> afterward to determine if -1 is an error or a "
"legitimate value."
msgstr "B<getpriority>()  は成功した場合にも -1 の値を返す可能性があるので、 呼び出しの前に外部変数の I<errno> をクリアし、呼び出しの後に返り値の -1 が正当な値か エラーかを判別する必要がある。"

#. type: Plain text
#: build/C/man2/getpriority.2:144
msgid ""
"B<setpriority>()  returns 0 on success.  On error, it returns -1 and sets "
"I<errno> to indicate the cause of the error."
msgstr "成功すると、 B<setpriority>() は 0 を返す。 エラーの場合、-1 を返し、 I<errno> にエラーの原因を示す値を設定する。"

#. type: Plain text
#: build/C/man2/getpriority.2:153
msgid "I<which> was not one of B<PRIO_PROCESS>, B<PRIO_PGRP>, or B<PRIO_USER>."
msgstr ""
"I<which> が B<PRIO_PROCESS>, B<PRIO_PGRP>, B<PRIO_USER> のいずれでもない。"

#. type: Plain text
#: build/C/man2/getpriority.2:160
msgid "No process was located using the I<which> and I<who> values specified."
msgstr "I<which> と I<who> で指定されたプロセスが存在しない。"

#. type: Plain text
#: build/C/man2/getpriority.2:164
msgid ""
"In addition to the errors indicated above, B<setpriority>()  may fail if:"
msgstr "上記のものに加えて B<setpriority>()  では以下のエラーがある:"

#. type: Plain text
#: build/C/man2/getpriority.2:171
msgid ""
"The caller attempted to set a lower nice value (i.e., a higher process "
"priority), but did not have the required privilege (on Linux: did not have "
"the B<CAP_SYS_NICE> capability)."
msgstr ""

#. type: Plain text
#: build/C/man2/getpriority.2:179
msgid ""
"A process was located, but its effective user ID did not match either the "
"effective or the real user ID of the caller, and was not privileged (on "
"Linux: did not have the B<CAP_SYS_NICE> capability).  But see NOTES below."
msgstr ""
"プロセスは見つかったが、そのプロセスの実効 (effective) UID が 呼び出し元の実"
"効UID にも実 (real) UID にも一致せず、 呼び出し元が特権も持っていなかった "
"(Linux の場合、 B<CAP_SYS_NICE> ケーパビリティがなかった)。 以下の「注意」も"
"参照のこと。"

#. type: Plain text
#: build/C/man2/getpriority.2:182
msgid ""
"POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD (these interfaces first appeared in "
"4.2BSD)."
msgstr "POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD (これらのインターフェースは 4.2BSD で初めて登場した)"

#. type: Plain text
#: build/C/man2/getpriority.2:185
msgid "For further details on the nice value, see B<sched>(7)."
msgstr "nice 値の詳細は B<sched>(7) を参照のこと。"

#. type: Plain text
#: build/C/man2/getpriority.2:191
msgid ""
"I<Note>: the addition of the \"autogroup\" feature in Linux 2.6.38 means "
"that the nice value no longer has its traditional effect in many "
"circumstances.  For details, see B<sched>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/getpriority.2:197
msgid ""
"A child created by B<fork>(2)  inherits its parent's nice value.  The nice "
"value is preserved across B<execve>(2)."
msgstr ""
"B<fork>(2)  で作成された子プロセスは、 親プロセスの nice 値を継承する。 "
"B<execve>(2)  の前後で nice 値は保存される。"

#. type: Plain text
#: build/C/man2/getpriority.2:212
msgid ""
"The details on the condition for B<EPERM> depend on the system.  The above "
"description is what POSIX.1-2001 says, and seems to be followed on all System"
"\\ V-like systems.  Linux kernels before 2.6.12 required the real or "
"effective user ID of the caller to match the real user of the process I<who> "
"(instead of its effective user ID).  Linux 2.6.12 and later require the "
"effective user ID of the caller to match the real or effective user ID of "
"the process I<who>.  All BSD-like systems (SunOS 4.1.3, Ultrix 4.2, 4.3BSD, "
"FreeBSD 4.3, OpenBSD-2.5, ...) behave in the same manner as Linux 2.6.12 and "
"later."
msgstr ""
"B<EPERM> が発生する条件の詳細はシステムに依存する。 上記の説明は "
"POSIX.1-2001 のものであり、全ての System\\ V 風システムは これに従っているよ"
"うである。 2.6.12 より前の Linux カーネルでは、呼び出し元の実 UID または 実"
"効 UID がプロセス I<who> の (実効 UID でなく)  実 UID に一致する必要がある。 "
"Linux 2.6.12 以降では、呼び出し元の実行 UID がプロセス I<who> の実 UID か実"
"効 UID のいずれかと一致する必要がある。 全ての BSD 風システム (SunOS 4.1.3, "
"Ultrix 4.2, 4.3BSD, FreeBSD 4.3, OpenBSD-2.5等) は、 Linux 2.6.12 以降と同じ"
"動作をする。"

#. type: Plain text
#: build/C/man2/getpriority.2:225
msgid ""
"Including I<E<lt>sys/time.hE<gt>> is not required these days, but increases "
"portability.  (Indeed, I<E<lt>sys/resource.hE<gt>> defines the I<rusage> "
"structure with fields of type I<struct timeval> defined in I<E<lt>sys/time."
"hE<gt>>.)"
msgstr ""
"現在では I<E<lt>sys/time.hE<gt>> をインクルードする必要はないが、インクルード"
"すれば移植性を高めることができる (実際には I<E<lt>sys/resource.hE<gt>> で "
"I<rusage> 構造体が定義されているが、そのフィールドで使用されている I<struct "
"timeval> 型は I<E<lt>sys/time.hE<gt>> で定義されている)。"

#. type: Plain text
#: build/C/man2/getpriority.2:240
msgid ""
"Within the kernel, nice values are actually represented using the range "
"40..1 (since negative numbers are error codes) and these are the values "
"employed by the B<setpriority>()  and B<getpriority>()  system calls.  The "
"glibc wrapper functions for these system calls handle the translations "
"between the user-land and kernel representations of the nice value according "
"to the formula I<unice\\ =\\ 20\\ -\\ knice>.  (Thus, the kernel's 40..1 "
"range corresponds to the range -20..19 as seen by user space.)"
msgstr ""
"カーネル内部では、nice 値は実際には 40 〜 1 の範囲を使って 表現されており (負"
"の値はエラーコードとなるため)、こちらの値が システムコール B<setpriority>()  "
"と B<getpriority>()  で使用されている。 glibc のこれらのシステムコールのラッ"
"パー関数において、nice 値の ユーザー領域 (user-land) とカーネル表現の間の変換"
"が行われる。 変換式は I<unice\\ =\\ 20\\ -\\ knice> となる。 (したがって、"
"カーネルの 40..1 の範囲はユーザー空間で見える -20..19 の範囲に対応する。)"

#. type: Plain text
#: build/C/man2/getpriority.2:247
msgid ""
"According to POSIX, the nice value is a per-process setting.  However, under "
"the current Linux/NPTL implementation of POSIX threads, the nice value is a "
"per-thread attribute: different threads in the same process can have "
"different nice values.  Portable applications should avoid relying on the "
"Linux behavior, which may be made standards conformant in the future."
msgstr ""
"POSIX では nice 値はプロセス単位の設定となっている。 一方、 現在の POSIX ス"
"レッドの Linux/NPTL 実装では、 nice 値はスレッド単位の属性である。 同じプロセ"
"スの別々のスレッドが異なる nice 値を持つ場合がある。 移植性が必要なアプリケー"
"ションではこの Linux の動作を前提するのは避けるべきである。 Linux の動作は将"
"来標準に準拠した動作になるかもしれない。"

#. type: Plain text
#: build/C/man2/getpriority.2:253
msgid "B<nice>(1), B<renice>(1), B<fork>(2), B<capabilities>(7), B<sched>(7)"
msgstr "B<nice>(1), B<renice>(1), B<fork>(2), B<capabilities>(7), B<sched>(7)"

#. type: Plain text
#: build/C/man2/getpriority.2:256
msgid ""
"I<Documentation/scheduler/sched-nice-design.txt> in the Linux kernel source "
"tree (since Linux 2.6.23)"
msgstr ""
"Linux カーネルのソースツリー内の I<Documentation/scheduler/sched-nice-design."
"txt> (Linux 2.6.23 以降)"

#. type: TH
#: build/C/man2/getresuid.2:28
#, no-wrap
msgid "GETRESUID"
msgstr "GETRESUID"

#. type: Plain text
#: build/C/man2/getresuid.2:31
msgid "getresuid, getresgid - get real, effective and saved user/group IDs"
msgstr ""
"getresuid, getresgid - 実、実効、保存、ユーザー ID / グループ ID を取得する"

#. type: Plain text
#: build/C/man2/getresuid.2:33 build/C/man2/setresuid.2:32
msgid "B<#define _GNU_SOURCE> /* See feature_test_macros(7) */"
msgstr "B<#define _GNU_SOURCE> /* feature_test_macros(7) 参照 */"

#. type: Plain text
#: build/C/man2/getresuid.2:37
msgid ""
"B<int getresuid(uid_t *>I<ruid>B<, uid_t *>I<euid>B<, uid_t *>I<suid>B<);>"
msgstr ""
"B<int getresuid(uid_t *>I<ruid>B<, uid_t *>I<euid>B<, uid_t *>I<suid>B<);>"

#. type: Plain text
#: build/C/man2/getresuid.2:39
msgid ""
"B<int getresgid(gid_t *>I<rgid>B<, gid_t *>I<egid>B<, gid_t *>I<sgid>B<);>"
msgstr ""
"B<int getresgid(gid_t *>I<rgid>B<, gid_t *>I<egid>B<, gid_t *>I<sgid>B<);>"

#. type: Plain text
#: build/C/man2/getresuid.2:50
msgid ""
"B<getresuid>()  returns the real UID, the effective UID, and the saved set-"
"user-ID of the calling process, in the arguments I<ruid>, I<euid>, and "
"I<suid>, respectively.  B<getresgid>()  performs the analogous task for the "
"process's group IDs."
msgstr ""
"B<getresuid>()  は、呼び出したプロセスの実 (real) UID、実効 (effective) "
"UID、 保存 (saved) set-user-ID (B<getresgid> の場合はグループ ID) を、 それぞ"
"れ引数 I<ruid>, I<euid>, I<suid> に格納して返す。 B<getresgid>()  は、呼び"
"出したプロセスのグループ ID について同様の処理を行う。"

#. type: Plain text
#: build/C/man2/getresuid.2:60
msgid ""
"One of the arguments specified an address outside the calling program's "
"address space."
msgstr ""
"指定した引数のどれかが、呼び出したプログラムのアドレス空間の外の アドレスで"
"ある。"

#. type: Plain text
#: build/C/man2/getresuid.2:62
msgid "These system calls appeared on Linux starting with kernel 2.1.44."
msgstr "これらのシステムコールはカーネル 2.1.44 から Linux に登場した。"

#. type: Plain text
#: build/C/man2/getresuid.2:67
msgid ""
"The prototypes are given by glibc since version 2.3.2, provided "
"B<_GNU_SOURCE> is defined."
msgstr ""
"プロトタイプ宣言は 2.3.2 以降の glibc では B<_GNU_SOURCE> を定義していると得"
"られる。"

#. type: Plain text
#: build/C/man2/getresuid.2:70 build/C/man2/setresuid.2:121
msgid ""
"These calls are nonstandard; they also appear on HP-UX and some of the BSDs."
msgstr "これらのコールは非標準である。 HP-UX や BSD 系のいくつかにも存在する。"

#. type: Plain text
#: build/C/man2/getresuid.2:86
msgid ""
"The original Linux B<getresuid>()  and B<getresgid>()  system calls "
"supported only 16-bit user and group IDs.  Subsequently, Linux 2.4 added "
"B<getresuid32>()  and B<getresgid32>(), supporting 32-bit IDs.  The glibc "
"B<getresuid>()  and B<getresgid>()  wrapper functions transparently deal "
"with the variations across kernel versions."
msgstr ""
"元々の Linux の B<getresuid>() と B<getresgid>() システムコールは\n"
"16 ビットのグループ ID だけに対応していた。\n"
"その後、Linux 2.4 で、32 ビットの ID に対応した\n"
"B<getresuid32>() と B<getresgid32>() が追加された。\n"
"glibc の B<getresuid>() と B<getresgid>() のラッパー関数は\n"
"カーネルバージョンによるこの違いを吸収している。"

#. type: Plain text
#: build/C/man2/getresuid.2:92
msgid ""
"B<getuid>(2), B<setresuid>(2), B<setreuid>(2), B<setuid>(2), "
"B<credentials>(7)"
msgstr ""
"B<getuid>(2), B<setresuid>(2), B<setreuid>(2), B<setuid>(2), "
"B<credentials>(7)"

#. type: TH
#: build/C/man2/getrlimit.2:64
#, no-wrap
msgid "GETRLIMIT"
msgstr "GETRLIMIT"

#. type: Plain text
#: build/C/man2/getrlimit.2:67
msgid "getrlimit, setrlimit, prlimit - get/set resource limits"
msgstr "getrlimit, setrlimit, prlimit - 資源の制限を取得/設定する"

#. type: Plain text
#: build/C/man2/getrlimit.2:73
msgid "B<int getrlimit(int >I<resource>B<, struct rlimit *>I<rlim>B<);>"
msgstr "B<int getrlimit(int >I<resource>B<, struct rlimit *>I<rlim>B<);>"

#. type: Plain text
#: build/C/man2/getrlimit.2:75
msgid "B<int setrlimit(int >I<resource>B<, const struct rlimit *>I<rlim>B<);>"
msgstr "B<int setrlimit(int >I<resource>B<, const struct rlimit *>I<rlim>B<);>"

#. type: Plain text
#: build/C/man2/getrlimit.2:78
msgid ""
"B<int prlimit(pid_t >I<pid>B<, int >I<resource>B<, const struct rlimit "
"*>I<new_limit>B<,>"
msgstr ""
"B<int prlimit(pid_t >I<pid>B<, int >I<resource>B<, const struct rlimit "
"*>I<new_limit>B<,>"

#. type: Plain text
#: build/C/man2/getrlimit.2:80
msgid "B< struct rlimit *>I<old_limit>B<);>"
msgstr "B< struct rlimit *>I<old_limit>B<);>"

#. type: Plain text
#: build/C/man2/getrlimit.2:88
msgid "B<prlimit>(): _GNU_SOURCE"
msgstr "B<prlimit>(): _GNU_SOURCE"

#. type: Plain text
#: build/C/man2/getrlimit.2:97
msgid ""
"The B<getrlimit>()  and B<setrlimit>()  system calls get and set resource "
"limits.  Each resource has an associated soft and hard limit, as defined by "
"the I<rlimit> structure:"
msgstr "B<getrlimit>() と B<setrlimit>() は、資源 (resource) の制限 (limit) の設定と取得を行う。 各リソースには、それに対応するソフトリミットとハードリミットがあり、 I<rlimit> 構造体で定義される:"

#. type: Plain text
#: build/C/man2/getrlimit.2:104
#, no-wrap
msgid ""
"struct rlimit {\n"
"    rlim_t rlim_cur;  /* Soft limit */\n"
"    rlim_t rlim_max;  /* Hard limit (ceiling for rlim_cur) */\n"
"};\n"
msgstr ""
"struct rlimit {\n"
"    rlim_t rlim_cur;  /* ソフトリミット */\n"
"    rlim_t rlim_max;  /* ハードリミット\n"
"                         (rlim_cur より小さくない) */\n"
"};\n"

#. type: Plain text
#: build/C/man2/getrlimit.2:116
msgid ""
"The soft limit is the value that the kernel enforces for the corresponding "
"resource.  The hard limit acts as a ceiling for the soft limit: an "
"unprivileged process may set only its soft limit to a value in the range "
"from 0 up to the hard limit, and (irreversibly) lower its hard limit.  A "
"privileged process (under Linux: one with the B<CAP_SYS_RESOURCE> capability "
"in the initial user namespace)  may make arbitrary changes to either limit "
"value."
msgstr "ソフトリミットは、カーネルが対応するリソースに対して課す制限値である。 ハードリミットはソフトリミットの上限として働く。 特権を持たないプロセスは、ソフトリミットの値を 0 からハードリミットの範囲に設定することと、 ハードリミットを下げることのみができる (一度下げたハードリミットは上げられない)。 特権プロセス (Linux では初期ユーザー名前空間で B<CAP_SYS_RESOURCE> ケーパビリティ (capability) を持つプロセス) は ソフトリミットとハードリミットを自由に変更できる。"

#. type: Plain text
#: build/C/man2/getrlimit.2:123
msgid ""
"The value B<RLIM_INFINITY> denotes no limit on a resource (both in the "
"structure returned by B<getrlimit>()  and in the structure passed to "
"B<setrlimit>())."
msgstr ""
"値 B<RLIM_INFINITY> はリソースに制限がないことを表す (この値は "
"B<getrlimit>()  が返す構造体と B<setrlimit>()  に渡す構造体の両方で使用され"
"る)。"

#. type: Plain text
#: build/C/man2/getrlimit.2:127
msgid "The I<resource> argument must be one of:"
msgstr "I<resource> 引数は次のいずれか 1 つである。"

#. type: TP
#: build/C/man2/getrlimit.2:127
#, no-wrap
msgid "B<RLIMIT_AS>"
msgstr "B<RLIMIT_AS>"

#.  since 2.0.27 / 2.1.12
#. type: Plain text
#: build/C/man2/getrlimit.2:149
#, fuzzy
#| msgid ""
#| "The maximum size of the process's virtual memory (address space) in "
#| "bytes.  This limit affects calls to B<brk>(2), B<mmap>(2), and "
#| "B<mremap>(2), which fail with the error B<ENOMEM> upon exceeding this "
#| "limit.  Also automatic stack expansion will fail (and generate a "
#| "B<SIGSEGV> that kills the process if no alternate stack has been made "
#| "available via B<sigaltstack>(2)).  Since the value is a I<long>, on "
#| "machines with a 32-bit I<long> either this limit is at most 2 GiB, or "
#| "this resource is unlimited."
msgid ""
"This is the maximum size of the process's virtual memory (address space).  "
"The limit is specified in bytes, and is rounded down to the system page "
"size.  This limit affects calls to B<brk>(2), B<mmap>(2), and B<mremap>(2), "
"which fail with the error B<ENOMEM> upon exceeding this limit.  In addition, "
"automatic stack expansion fails (and generates a B<SIGSEGV> that kills the "
"process if no alternate stack has been made available via "
"B<sigaltstack>(2)).  Since the value is a I<long>, on machines with a 32-bit "
"I<long> either this limit is at most 2\\ GiB, or this resource is unlimited."
msgstr ""
"プロセスの仮想メモリー (アドレス空間) の最大サイズ (バイト単位)。 この制限は "
"B<brk>(2), B<mmap>(2), B<mremap>(2)  の呼び出しに影響し、この制限を超えた場合"
"は エラー B<ENOMEM> で失敗する。 また自動的なスタック拡張にも失敗する (さら"
"に B<sigaltstack>(2)  を使った代替スタックを利用可能にしていなかった場合に"
"は、 B<SIGSEGV> を生成してそのプロセスを kill する)。 この値は I<long> 型なの"
"で、32 ビットの I<long> 型を持つマシンでは、 この制限は最大で 2 GiB になる"
"か、この資源が無制限になる。"

#. type: TP
#: build/C/man2/getrlimit.2:149
#, no-wrap
msgid "B<RLIMIT_CORE>"
msgstr "B<RLIMIT_CORE>"

#. type: Plain text
#: build/C/man2/getrlimit.2:158
#, fuzzy
#| msgid ""
#| "Maximum size of a I<core> file (see B<core>(5)).  When 0 no core dump "
#| "files are created.  When nonzero, larger dumps are truncated to this size."
msgid ""
"This is the maximum size of a I<core> file (see B<core>(5))  in bytes that "
"the process may dump.  When 0 no core dump files are created.  When nonzero, "
"larger dumps are truncated to this size."
msgstr ""
"I<core> ファイルの最大サイズ (B<core>(5) 参照)。 0 の場合、core ファイルは生"
"成されない。 0 以外の場合、このサイズより大きいダンプは切り詰められる。"

#. type: TP
#: build/C/man2/getrlimit.2:158
#, no-wrap
msgid "B<RLIMIT_CPU>"
msgstr "B<RLIMIT_CPU>"

#. type: Plain text
#: build/C/man2/getrlimit.2:179
#, fuzzy
#| msgid ""
#| "CPU time limit in seconds.  When the process reaches the soft limit, it "
#| "is sent a B<SIGXCPU> signal.  The default action for this signal is to "
#| "terminate the process.  However, the signal can be caught, and the "
#| "handler can return control to the main program.  If the process continues "
#| "to consume CPU time, it will be sent B<SIGXCPU> once per second until the "
#| "hard limit is reached, at which time it is sent B<SIGKILL>.  (This latter "
#| "point describes Linux behavior.  Implementations vary in how they treat "
#| "processes which continue to consume CPU time after reaching the soft "
#| "limit.  Portable applications that need to catch this signal should "
#| "perform an orderly termination upon first receipt of B<SIGXCPU>.)"
msgid ""
"This is a limit, in seconds, on the amount of CPU time that the process can "
"consume.  When the process reaches the soft limit, it is sent a B<SIGXCPU> "
"signal.  The default action for this signal is to terminate the process.  "
"However, the signal can be caught, and the handler can return control to the "
"main program.  If the process continues to consume CPU time, it will be sent "
"B<SIGXCPU> once per second until the hard limit is reached, at which time it "
"is sent B<SIGKILL>.  (This latter point describes Linux behavior.  "
"Implementations vary in how they treat processes which continue to consume "
"CPU time after reaching the soft limit.  Portable applications that need to "
"catch this signal should perform an orderly termination upon first receipt "
"of B<SIGXCPU>.)"
msgstr ""
"CPU 時間の上限 (秒数)。プロセスがソフトリミットに達した場合に、\n"
"B<SIGXCPU> シグナルを送る。このシグナルに対するデフォルトの動作は、\n"
"プロセスの終了である。ただし、シグナルをキャッチして、ハンドラーがメイン\n"
"プログラムに制御を返すこともできる。プロセスが CPU 時間を使い続けた\n"
"場合は、ハードリミットに達するまで 1 秒毎にプロセスに B<SIGXCPU> を送り、\n"
"ハードリミットに達すると B<SIGKILL> を送る。\n"
"(ソフトリミットを超過したときの動作は、 Linux における動作である。ソフ\n"
"トリミットを超えて CPU 時間を使い続けるプロセスの扱い方についての実装は\n"
"変化してきている。 このシグナルをキャッチする必要のある 移植性を考えた\n"
"アプリケーションでは、 最初に B<SIGXCPU> を受け取った時点で正しく終了\n"
"すべきである。)"

#. type: TP
#: build/C/man2/getrlimit.2:179
#, no-wrap
msgid "B<RLIMIT_DATA>"
msgstr "B<RLIMIT_DATA>"

#.  commits 84638335900f1995495838fe1bd4870c43ec1f67
#.  ("mm: rework virtual memory accounting"),
#.  f4fcd55841fc9e46daac553b39361572453c2b88
#.  (mm: enable RLIMIT_DATA by default with workaround for valgrind).
#. type: Plain text
#: build/C/man2/getrlimit.2:197
#, fuzzy
#| msgid ""
#| "The maximum size of the process's data segment (initialized data, "
#| "uninitialized data, and heap).  This limit affects calls to B<brk>(2)  "
#| "and B<sbrk>(2), which fail with the error B<ENOMEM> upon encountering the "
#| "soft limit of this resource."
msgid ""
"This is the maximum size of the process's data segment (initialized data, "
"uninitialized data, and heap).  The limit is specified in bytes, and is "
"rounded down to the system page size.  This limit affects calls to "
"B<brk>(2), B<sbrk>(2), and (since Linux 4.7)  B<mmap>(2), which fail with "
"the error B<ENOMEM> upon encountering the soft limit of this resource."
msgstr ""
"プロセスのデータセグメント (初期化されたデータ・初期化されていないデータ・"
"ヒープ) の最大値。 このリミットは B<brk>(2)  と B<sbrk>(2)  の呼び出しに影響"
"する。 これらの関数は、このリソースのソフトリミットに達すると、 エラー "
"B<ENOMEM> で失敗する。"

#. type: TP
#: build/C/man2/getrlimit.2:197
#, no-wrap
msgid "B<RLIMIT_FSIZE>"
msgstr "B<RLIMIT_FSIZE>"

#. type: Plain text
#: build/C/man2/getrlimit.2:209
msgid ""
"This is the maximum size in bytes of files that the process may create.  "
"Attempts to extend a file beyond this limit result in delivery of a "
"B<SIGXFSZ> signal.  By default, this signal terminates a process, but a "
"process can catch this signal instead, in which case the relevant system "
"call (e.g., B<write>(2), B<truncate>(2))  fails with the error B<EFBIG>."
msgstr "これはプロセスが作成できるファイルサイズの最大値 (バイト単位) である。 このサイズを超えてファイルを拡張すると、 B<SIGXFSZ> シグナルを送る。 デフォルトでは、このシグナルはプロセスを終了する。 プロセスをキャッチすることもできるが、 関連するシステムコール (B<write>(2), B<truncate>(2)  など) はエラー B<EFBIG> で失敗する。"

#. type: TP
#: build/C/man2/getrlimit.2:209
#, no-wrap
msgid "B<RLIMIT_LOCKS> (Linux 2.4.0 to 2.4.24)"
msgstr "B<RLIMIT_LOCKS> (Linux 2.4.0 から 2.4.24 まで)"

#.  to be precise: Linux 2.4.0-test9; no longer in 2.4.25 / 2.5.65
#. type: Plain text
#: build/C/man2/getrlimit.2:217
msgid ""
"This is a limit on the combined number of B<flock>(2)  locks and "
"B<fcntl>(2)  leases that this process may establish."
msgstr "このプロセスが実行できる B<flock>(2)  ロック数と B<fcntl>(2)  リース数の合計値の上限である。"

#. type: TP
#: build/C/man2/getrlimit.2:217
#, no-wrap
msgid "B<RLIMIT_MEMLOCK>"
msgstr "B<RLIMIT_MEMLOCK>"

#. type: Plain text
#: build/C/man2/getrlimit.2:249
#, fuzzy
#| msgid ""
#| "The maximum number of bytes of memory that may be locked into RAM.  In "
#| "effect this limit is rounded down to the nearest multiple of the system "
#| "page size.  This limit affects B<mlock>(2)  and B<mlockall>(2)  and the "
#| "B<mmap>(2)  B<MAP_LOCKED> operation.  Since Linux 2.6.9 it also affects "
#| "the B<shmctl>(2)  B<SHM_LOCK> operation, where it sets a maximum on the "
#| "total bytes in shared memory segments (see B<shmget>(2))  that may be "
#| "locked by the real user ID of the calling process.  The B<shmctl>(2)  "
#| "B<SHM_LOCK> locks are accounted for separately from the per-process "
#| "memory locks established by B<mlock>(2), B<mlockall>(2), and B<mmap>(2)  "
#| "B<MAP_LOCKED>; a process can lock bytes up to this limit in each of these "
#| "two categories.  In Linux kernels before 2.6.9, this limit controlled the "
#| "amount of memory that could be locked by a privileged process.  Since "
#| "Linux 2.6.9, no limits are placed on the amount of memory that a "
#| "privileged process may lock, and this limit instead governs the amount of "
#| "memory that an unprivileged process may lock."
msgid ""
"This is the maximum number of bytes of memory that may be locked into RAM.  "
"This limit is in effect rounded down to the nearest multiple of the system "
"page size.  This limit affects B<mlock>(2), B<mlockall>(2), and the "
"B<mmap>(2)  B<MAP_LOCKED> operation.  Since Linux 2.6.9, it also affects the "
"B<shmctl>(2)  B<SHM_LOCK> operation, where it sets a maximum on the total "
"bytes in shared memory segments (see B<shmget>(2))  that may be locked by "
"the real user ID of the calling process.  The B<shmctl>(2)  B<SHM_LOCK> "
"locks are accounted for separately from the per-process memory locks "
"established by B<mlock>(2), B<mlockall>(2), and B<mmap>(2)  B<MAP_LOCKED>; a "
"process can lock bytes up to this limit in each of these two categories."
msgstr ""
"RAM 内にロックできるメモリーの最大バイト数。 実際には、この制限はシステムペー"
"ジサイズの最も近い倍数に 切り捨てて丸められる。 この制限は B<mlock>(2), "
"B<mlockall>(2), B<mmap>(2)  の B<MAP_LOCKED> 操作に影響する。 Linux 2.6.9 以"
"降では B<shmctl>(2)  B<SHM_LOCK> 操作にも影響する。 この操作は呼び出し元プロ"
"セスの実 (real) ユーザー ID にロックされる 共有メモリーセグメント "
"(B<shmget>(2)  を参照) の合計バイト数の最大値を設定する。 B<shmctl>(2)  "
"B<SHM_LOCK> によるロックは、 B<mlock>(2), B<mlockall>(2), B<mmap>(2)  の "
"B<MAP_LOCKED> によって確立されるプロセス毎のメモリーロックとは分けて数える。 "
"1 つのプロセスはこの制限までのバイトをロックできる。 この制限には 2 つの種類"
"がある。 2.6.9 より前の Linux カーネル では、 この制限は特権プロセスによって"
"ロックされるメモリーの合計を制御していた。 Linux 2.6.9 以降では、特権プロセス"
"がロックするメモリーの合計に制限はなく、 代わりにこの制限は非特権プロセスが"
"ロックするメモリーの合計に 適用されるようになった。"

#. type: Plain text
#: build/C/man2/getrlimit.2:255
msgid ""
"In Linux kernels before 2.6.9, this limit controlled the amount of memory "
"that could be locked by a privileged process.  Since Linux 2.6.9, no limits "
"are placed on the amount of memory that a privileged process may lock, and "
"this limit instead governs the amount of memory that an unprivileged process "
"may lock."
msgstr ""

#. type: TP
#: build/C/man2/getrlimit.2:255
#, no-wrap
msgid "B<RLIMIT_MSGQUEUE> (since Linux 2.6.8)"
msgstr "B<RLIMIT_MSGQUEUE> (Linux 2.6.8 以降)"

#. type: Plain text
#: build/C/man2/getrlimit.2:263
#, fuzzy
#| msgid ""
#| "Specifies the limit on the number of bytes that can be allocated for "
#| "POSIX message queues for the real user ID of the calling process.  This "
#| "limit is enforced for B<mq_open>(3).  Each message queue that the user "
#| "creates counts (until it is removed)  against this limit according to the "
#| "formula:"
msgid ""
"This is a limit on the number of bytes that can be allocated for POSIX "
"message queues for the real user ID of the calling process.  This limit is "
"enforced for B<mq_open>(3).  Each message queue that the user creates counts "
"(until it is removed)  against this limit according to the formula:"
msgstr ""
"呼び出し元プロセスの実ユーザー ID に対して、 POSIX メッセージキューのために確"
"保できるバイト数の制限を指定する。 この制限は B<mq_open>(3)  に対して適用され"
"る。 ユーザーが作成した各々のメッセージキューのバイト数は 以下の式により計算"
"され、(そのキューが削除されるまでの間)  この制限の計算対象に含められる。"

#. type: Plain text
#: build/C/man2/getrlimit.2:265
#, no-wrap
msgid "    Since Linux 3.5:\n"
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:273
#, no-wrap
msgid ""
"        bytes = attr.mq_maxmsg * sizeof(struct msg_msg) +\n"
"                min(attr.mq_maxmsg, MQ_PRIO_MAX) *\n"
"                      sizeof(struct posix_msg_tree_node)+\n"
"                                /* For overhead */\n"
"                attr.mq_maxmsg * attr.mq_msgsize;\n"
"                                /* For message data */\n"
msgstr ""
"        bytes = attr.mq_maxmsg * sizeof(struct msg_msg) +\n"
"                min(attr.mq_maxmsg, MQ_PRIO_MAX) *\n"
"                      sizeof(struct posix_msg_tree_node)+\n"
"                                /* オーバーヘッド分 */\n"
"                attr.mq_maxmsg * attr.mq_msgsize;\n"
"                                /* メッセージデータ分 */\n"

#. type: Plain text
#: build/C/man2/getrlimit.2:276
#, no-wrap
msgid "    Linux 3.4 and earlier:\n"
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:282
#, no-wrap
msgid ""
"        bytes = attr.mq_maxmsg * sizeof(struct msg_msg *) +\n"
"                                /* For overhead */\n"
"                attr.mq_maxmsg * attr.mq_msgsize;\n"
"                                /* For message data */\n"
msgstr ""
"        bytes = attr.mq_maxmsg * sizeof(struct msg_msg *) +\n"
"                                /* オーバーヘッド分 */\n"
"                attr.mq_maxmsg * attr.mq_msgsize;\n"
"                                /* メッセージデータ分 */\n"

#. type: Plain text
#: build/C/man2/getrlimit.2:295
msgid ""
"where I<attr> is the I<mq_attr> structure specified as the fourth argument "
"to B<mq_open>(3), and the I<msg_msg> and I<posix_msg_tree_node> structures "
"are kernel-internal structures."
msgstr ""
"ここで I<attr> は I<mq_attr> 構造体であり、 B<mq_open>(3)  の第 4 引数とし"
"て指定される。 また、構造体 I<msg_msg> と I<posix_msg_tree_node> はカーネル内"
"部の構造体である。"

#. type: Plain text
#: build/C/man2/getrlimit.2:301
msgid ""
"The \"overhead\" addend in the formula accounts for overhead bytes required "
"by the implementation and ensures that the user cannot create an unlimited "
"number of zero-length messages (such messages nevertheless each consume some "
"system memory for bookkeeping overhead)."
msgstr ""
"上記の式での「オーバーヘッド」加算分は、実装において必要となるオーバーヘッド"
"を考慮したものである。 また、これにより、ユーザーが長さ 0 のメッセージを無制"
"限に作れないことが保証される (このようなメッセージであっても、 記録のための"
"オーバーヘッドでシステムメモリーを消費する)。"

#. type: TP
#: build/C/man2/getrlimit.2:301
#, no-wrap
msgid "B<RLIMIT_NICE> (since Linux 2.6.12, but see BUGS below)"
msgstr "B<RLIMIT_NICE> (Linux 2.6.12 以降, 下記の「バグ」の節も参照)"

#. type: Plain text
#: build/C/man2/getrlimit.2:320
#, fuzzy
#| msgid ""
#| "Specifies a ceiling to which the process's nice value can be raised using "
#| "B<setpriority>(2)  or B<nice>(2).  The actual ceiling for the nice value "
#| "is calculated as I<20\\ -\\ rlim_cur>.  (This strangeness occurs because "
#| "negative numbers cannot be specified as resource limit values, since they "
#| "typically have special meanings.  For example, B<RLIM_INFINITY> typically "
#| "is the same as -1.)"
msgid ""
"This specifies a ceiling to which the process's nice value can be raised "
"using B<setpriority>(2)  or B<nice>(2).  The actual ceiling for the nice "
"value is calculated as I<20\\ -\\ rlim_cur>.  The useful range for this "
"limit is thus from 1 (corresponding to a nice value of 19) to 40 "
"(corresponding to a nice value of -20).  This unusual choice of range was "
"necessary because negative numbers cannot be specified as resource limit "
"values, since they typically have special meanings.  For example, "
"B<RLIM_INFINITY> typically is the same as -1.  For more detail on the nice "
"value, see B<sched>(7)."
msgstr ""
"B<setpriority>(2)  や B<nice>(2)  を使って引き上げられるプロセスの nice 値の"
"上限を指定する。 nice 値の実際の上限は I<20\\ -\\ rlim_cur> で計算される (こ"
"のような変な状況は、リソース制限値として負の数を指定できないため 発生する。通"
"常、負の値は特別な意味を持っているからである。 例えば、通常は "
"B<RLIM_INFINITY> の値は -1 である)。"

#. type: TP
#: build/C/man2/getrlimit.2:320
#, no-wrap
msgid "B<RLIMIT_NOFILE>"
msgstr "B<RLIMIT_NOFILE>"

#. type: Plain text
#: build/C/man2/getrlimit.2:334
msgid ""
"This specifies a value one greater than the maximum file descriptor number "
"that can be opened by this process.  Attempts (B<open>(2), B<pipe>(2), "
"B<dup>(2), etc.)  to exceed this limit yield the error B<EMFILE>.  "
"(Historically, this limit was named B<RLIMIT_OFILE> on BSD.)"
msgstr ""
"このプロセスがオープンできるファイルディスクリプター数の最大値より 1 大きい値"
"を指定する。 (B<open>(2), B<pipe>(2), B<dup>(2)  などにより) この上限を超えよ"
"うとした場合、エラー B<EMFILE> が発生する (歴史的に、BSD ではこの上限は "
"B<RLIMIT_OFILE> という名前となっている)。"

#. type: Plain text
#: build/C/man2/getrlimit.2:346
msgid ""
"Since Linux 4.5, this limit also defines the maximum number of file "
"descriptors that an unprivileged process (one without the "
"B<CAP_SYS_RESOURCE> capability) may have \"in flight\" to other processes, "
"by being passed across UNIX domain sockets.  This limit applies to the "
"B<sendmsg>(2)  system call.  For further details, see B<unix>(7)."
msgstr ""

#. type: TP
#: build/C/man2/getrlimit.2:346
#, no-wrap
msgid "B<RLIMIT_NPROC>"
msgstr "B<RLIMIT_NPROC>"

#. type: Plain text
#: build/C/man2/getrlimit.2:356
msgid ""
"This is a limit on the number of extant process (or, more precisely on "
"Linux, threads)  for the real user ID of the calling process.  So long as "
"the current number of processes belonging to this process's real user ID is "
"greater than or equal to this limit, B<fork>(2)  fails with the error "
"B<EAGAIN>."
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:364
msgid ""
"The B<RLIMIT_NPROC> limit is not enforced for processes that have either the "
"B<CAP_SYS_ADMIN> or the B<CAP_SYS_RESOURCE> capability."
msgstr ""

#. type: TP
#: build/C/man2/getrlimit.2:364
#, no-wrap
msgid "B<RLIMIT_RSS>"
msgstr "B<RLIMIT_RSS>"

#.  As at kernel 2.6.12, this limit still does nothing in 2.6 though
#.  talk of making it do something has surfaced from time to time in LKML
#.        -- MTK, Jul 05
#. type: Plain text
#: build/C/man2/getrlimit.2:376
msgid ""
"This is a limit (in bytes) on the process's resident set (the number of "
"virtual pages resident in RAM).  This limit has effect only in Linux 2.4.x, "
"x E<lt> 30, and there affects only calls to B<madvise>(2)  specifying "
"B<MADV_WILLNEED>."
msgstr "プロセスの resident set (RAM 上に存在する仮想ページの数) の 上限である (バイト単位)。 この制限は 2.4.30 より前でしか影響がなく、 B<madvise>(2)  に B<MADV_WILLNEED> を指定した関数コールにしか影響しない。"

#. type: TP
#: build/C/man2/getrlimit.2:376
#, no-wrap
msgid "B<RLIMIT_RTPRIO> (since Linux 2.6.12, but see BUGS)"
msgstr "B<RLIMIT_RTPRIO> (Linux 2.6.12 以降, バグの節も参照)"

#. type: Plain text
#: build/C/man2/getrlimit.2:383
msgid ""
"This specifies a ceiling on the real-time priority that may be set for this "
"process using B<sched_setscheduler>(2)  and B<sched_setparam>(2)."
msgstr ""
"B<sched_setscheduler>(2)  や B<sched_setparam>(2)  を使って設定できる、そのプ"
"ロセスのリアルタイム優先度の上限を指定する。"

#. type: Plain text
#: build/C/man2/getrlimit.2:386 build/C/man2/getrlimit.2:415
msgid "For further details on real-time scheduling policies, see B<sched>(7)"
msgstr ""

#. type: TP
#: build/C/man2/getrlimit.2:386
#, no-wrap
msgid "B<RLIMIT_RTTIME> (since Linux 2.6.25)"
msgstr "B<RLIMIT_RTTIME> (Linux 2.6.25 以降)"

#. type: Plain text
#: build/C/man2/getrlimit.2:398
msgid ""
"This is a limit (in microseconds)  on the amount of CPU time that a process "
"scheduled under a real-time scheduling policy may consume without making a "
"blocking system call.  For the purpose of this limit, each time a process "
"makes a blocking system call, the count of its consumed CPU time is reset to "
"zero.  The CPU time count is not reset if the process continues trying to "
"use the CPU but is preempted, its time slice expires, or it calls "
"B<sched_yield>(2)."
msgstr ""
"リアルタイムスケジューリング方針でスケジューリングされるプロセスが ブロッキン"
"グ型のシステムコールを呼び出さずに消費することのできる CPU 時間の合計について"
"の上限を (マイクロ秒単位で) 指定する。 この上限の目的のため、プロセスがブロッ"
"キング型のシステムコールを 呼び出す度に、消費された CPU 時間のカウントは 0 に"
"リセットされる。 プロセスが CPU を使い続けようとしたが他のプロセスに置き換え"
"られた (preempted) 場合や、そのプロセスのタイムスライスが満了した場合、 その"
"プロセスが B<sched_yield>(2)  を呼び出した場合は、CPU 時間のカウントはリセッ"
"トされない。"

#. type: Plain text
#: build/C/man2/getrlimit.2:409
msgid ""
"Upon reaching the soft limit, the process is sent a B<SIGXCPU> signal.  If "
"the process catches or ignores this signal and continues consuming CPU time, "
"then B<SIGXCPU> will be generated once each second until the hard limit is "
"reached, at which point the process is sent a B<SIGKILL> signal."
msgstr ""
"ソフトリミットに達すると、そのプロセスに B<SIGXCPU> シグナルが送られる。その"
"プロセスがこのシグナルを捕捉するか 無視して、CPU 時間を消費し続けた場合に"
"は、 ハードリミットに達するまで 1 秒に 1 回 B<SIGXCPU> が生成され続けることに"
"なる。 ハードリミットに達した時点で、そのプロセスには B<SIGKILL> シグナルが送"
"られる。"

#. type: Plain text
#: build/C/man2/getrlimit.2:412
msgid ""
"The intended use of this limit is to stop a runaway real-time process from "
"locking up the system."
msgstr ""
"この上限を意図的に使用するのは、暴走したリアルタイムプロセスを 停止して、シス"
"テムが動かなくなるのを避ける場合である。"

#. type: TP
#: build/C/man2/getrlimit.2:415
#, no-wrap
msgid "B<RLIMIT_SIGPENDING> (since Linux 2.6.8)"
msgstr "B<RLIMIT_SIGPENDING> (Linux 2.6.8 以降)"

#.  This replaces the /proc/sys/kernel/rtsig-max system-wide limit
#.  that was present in kernels <= 2.6.7.  MTK Dec 04
#. type: Plain text
#: build/C/man2/getrlimit.2:429
msgid ""
"This is a limit on the number of signals that may be queued for the real "
"user ID of the calling process.  Both standard and real-time signals are "
"counted for the purpose of checking this limit.  However, the limit is "
"enforced only for B<sigqueue>(3); it is always possible to use B<kill>(2)  "
"to queue one instance of any of the signals that are not already queued to "
"the process."
msgstr ""
"呼び出し元プロセスの実ユーザー ID に対して キューに入れられるシグナルの\n"
"数の制限を指定する。この制限をチェックするため、標準シグナルとリアルタ\n"
"イムシグナルの両方がカウントされる。しかし、この制限は B<sigqueue>(3)\n"
"に対してのみ適用され、 B<kill>(2) 使うことで、そのプロセスに対してま\n"
"だキューに入れられていない シグナルのインスタンスをキューに入れることが\n"
"できる。"

#. type: TP
#: build/C/man2/getrlimit.2:429
#, no-wrap
msgid "B<RLIMIT_STACK>"
msgstr "B<RLIMIT_STACK>"

#. type: Plain text
#: build/C/man2/getrlimit.2:437
msgid ""
"This is the maximum size of the process stack, in bytes.  Upon reaching this "
"limit, a B<SIGSEGV> signal is generated.  To handle this signal, a process "
"must employ an alternate signal stack (B<sigaltstack>(2))."
msgstr ""
"プロセススタックの最大サイズをバイト単位で指定する。 この上限に達すると、 "
"B<SIGSEGV> シグナルが生成される。 このシグナルを扱うためには、 プロセスは代り"
"のシグナルスタック (B<sigaltstack>(2))  を使用しなければならない。"

#. type: Plain text
#: build/C/man2/getrlimit.2:442
msgid ""
"Since Linux 2.6.23, this limit also determines the amount of space used for "
"the process's command-line arguments and environment variables; for details, "
"see B<execve>(2)."
msgstr ""
"Linux 2.6.23 以降では、この制限はプロセスのコマンドライン引数と環境変数 に"
"使用される空間の合計サイズの上限の決定にも使用される。詳細については "
"B<execve>(2)  を参照。"

#. type: SS
#: build/C/man2/getrlimit.2:442
#, no-wrap
msgid "prlimit()"
msgstr "prlimit()"

#.  commit c022a0acad534fd5f5d5f17280f6d4d135e74e81
#.  Author: Jiri Slaby <jslaby@suse.cz>
#.  Date:   Tue May 4 18:03:50 2010 +0200
#.      rlimits: implement prlimit64 syscall
#.  commit 6a1d5e2c85d06da35cdfd93f1a27675bfdc3ad8c
#.  Author: Jiri Slaby <jslaby@suse.cz>
#.  Date:   Wed Mar 24 17:06:58 2010 +0100
#.      rlimits: add rlimit64 structure
#. type: Plain text
#: build/C/man2/getrlimit.2:462
msgid ""
"The Linux-specific B<prlimit>()  system call combines and extends the "
"functionality of B<setrlimit>()  and B<getrlimit>().  It can be used to both "
"set and get the resource limits of an arbitrary process."
msgstr ""
"Linux 固有の B<prlimit>() システムコールは、 B<setrlimit>() と B<getrlimit> "
"の機能を合わせて拡張したものである。 このシステムコールを使って、任意のプロセ"
"スのリソース上限の設定と取得を行うことができる。"

#. type: Plain text
#: build/C/man2/getrlimit.2:469
msgid ""
"The I<resource> argument has the same meaning as for B<setrlimit>()  and "
"B<getrlimit>()."
msgstr ""
"I<resource> 引数は B<setrlimit>() や B<getrlimit>() と同じ意味である。"

#. type: Plain text
#: build/C/man2/getrlimit.2:487
msgid ""
"If the I<new_limit> argument is a not NULL, then the I<rlimit> structure to "
"which it points is used to set new values for the soft and hard limits for "
"I<resource>.  If the I<old_limit> argument is a not NULL, then a successful "
"call to B<prlimit>()  places the previous soft and hard limits for "
"I<resource> in the I<rlimit> structure pointed to by I<old_limit>."
msgstr ""
"I<new_limit> 引数が NULL 以外の場合、 I<new_limit> が指す I<rlimit> 構造体"
"を使って I<resource> のソフトリミットとハードリミットの新しい値が設定され"
"る。 I<old_limit> 引数が NULL 以外の場合、 B<prlimit>() の呼び出しが成功す"
"ると、 I<resource> の直前のソフトリミットとハードリミットが I<old_limit> が指"
"す I<rlimit> 構造体に格納される。"

#.  FIXME . this permission check is strange
#.  Asked about this on LKML, 7 Nov 2010
#.      "Inconsistent credential checking in prlimit() syscall"
#. type: Plain text
#: build/C/man2/getrlimit.2:507
#, fuzzy
#| msgid ""
#| "The I<pid> argument specifies the ID of the process on which the call is "
#| "to operate.  If I<pid> is 0, then the call applies to the calling "
#| "process.  To set or get the resources of a process other than itself, the "
#| "caller must have the B<CAP_SYS_RESOURCE> capability, or the real, "
#| "effective, and saved set user IDs of the target process must match the "
#| "real user ID of the caller I<and> the real, effective, and saved set "
#| "group IDs of the target process must match the real group ID of the "
#| "caller."
msgid ""
"The I<pid> argument specifies the ID of the process on which the call is to "
"operate.  If I<pid> is 0, then the call applies to the calling process.  To "
"set or get the resources of a process other than itself, the caller must "
"have the B<CAP_SYS_RESOURCE> capability in the user namespace of the process "
"whose resource limits are being changed, or the real, effective, and saved "
"set user IDs of the target process must match the real user ID of the caller "
"I<and> the real, effective, and saved set group IDs of the target process "
"must match the real group ID of the caller."
msgstr ""
"I<pid> 引数は呼び出しの操作対象となるプロセス ID を指定する。 I<pid> が 0 "
"の場合、呼び出しは呼び出し元プロセスに対して適用される。 自分以外のプロセスの"
"リソースの設定と取得を行うためには、 呼び出し元プロセスが "
"B<CAP_SYS_RESOURCE> ケーパビリティを持っているか、 対象となるプロセスの実ユー"
"ザー ID、 実効ユーザー ID、 保存 set-user-ID が呼び出し元プロセスの実ユー"
"ザー ID と一致し、 かつ、 対象となるプロセスの実グループ ID、 実効グループ "
"ID、 保存 set-group-ID が呼び出し元プロセスの実グループ ID と一致していなけれ"
"ばならない。"

#. type: Plain text
#: build/C/man2/getrlimit.2:512
msgid ""
"On success, these system calls return 0.  On error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""
"成功した場合、これらのシステムコールは 0 を返す。\n"
"エラーの場合は -1 が返され、 I<errno> が適切に設定される。"

#. type: Plain text
#: build/C/man2/getrlimit.2:517
msgid ""
"A pointer argument points to a location outside the accessible address space."
msgstr "場所を指すポインター引数がアクセス可能なアドレス空間外を指している。"

#. type: Plain text
#: build/C/man2/getrlimit.2:529
msgid ""
"The value specified in I<resource> is not valid; or, for B<setrlimit>()  or "
"B<prlimit>(): I<rlim-E<gt>rlim_cur> was greater than I<rlim-E<gt>rlim_max>."
msgstr ""
"I<resource> で指定された値が有効でない。\n"
"または、 B<setrlimit>() や B<prlimit>() で、\n"
"I<rlim-E<gt>rlim_cur> が I<rlim-E<gt>rlim_max> よりも大きかった。"

#. type: Plain text
#: build/C/man2/getrlimit.2:534
msgid ""
"An unprivileged process tried to raise the hard limit; the "
"B<CAP_SYS_RESOURCE> capability is required to do this."
msgstr ""
"非特権プロセスがハードリミットを増やそうとした。 この操作には "
"B<CAP_SYS_RESOURCE> ケーパビリティが必要である。"

#. type: Plain text
#: build/C/man2/getrlimit.2:542
msgid ""
"The caller tried to increase the hard B<RLIMIT_NOFILE> limit above the "
"maximum defined by I</proc/sys/fs/nr_open> (see B<proc>(5))"
msgstr ""
"呼び出し元がハードリミット B<RLIMIT_NOFILE> を I</proc/sys/fs/nr_open> "
"(B<proc>(5) 参照) で定義される最大値より大きな値に増やそうとした。"

#. type: Plain text
#: build/C/man2/getrlimit.2:548
msgid ""
"(B<prlimit>())  The calling process did not have permission to set limits "
"for the process specified by I<pid>."
msgstr ""
"(B<prlimit>()) 呼び出し元のプロセスが I<pid> で指定されたプロセスの上限を設定"
"する許可を持っていなかった。"

#. type: Plain text
#: build/C/man2/getrlimit.2:552
msgid "Could not find a process with the ID specified in I<pid>."
msgstr "I<pid> で指定された ID のプロセスが見つからなかった。"

#. type: Plain text
#: build/C/man2/getrlimit.2:557
msgid ""
"The B<prlimit>()  system call is available since Linux 2.6.36.  Library "
"support is available since glibc 2.13."
msgstr ""
"B<prlimit>() システムコールは Linux 2.6.36 以降で利用できる。 ライブラリのサ"
"ポートは glibc 2.13 以降で利用できる。"

#. type: SH
#: build/C/man2/getrlimit.2:557 build/C/man2/getrusage.2:200
#: build/C/man3/ulimit.3:78
#, no-wrap
msgid "ATTRIBUTES"
msgstr "属性"

#. type: Plain text
#: build/C/man2/getrlimit.2:560 build/C/man2/getrusage.2:203
#: build/C/man3/ulimit.3:81
msgid ""
"For an explanation of the terms used in this section, see B<attributes>(7)."
msgstr "この節で使用されている用語の説明については、 B<attributes>(7) を参照。"

#. type: tbl table
#: build/C/man2/getrlimit.2:564 build/C/man2/getrusage.2:207
#: build/C/man3/ulimit.3:85
#, no-wrap
msgid "Interface"
msgstr "インターフェース"

#. type: tbl table
#: build/C/man2/getrlimit.2:564 build/C/man2/getrusage.2:207
#: build/C/man3/ulimit.3:85
#, no-wrap
msgid "Attribute"
msgstr "属性"

#. type: tbl table
#: build/C/man2/getrlimit.2:564 build/C/man2/getrusage.2:207
#: build/C/man3/ulimit.3:85
#, no-wrap
msgid "Value"
msgstr "値"

#. type: tbl table
#: build/C/man2/getrlimit.2:569
#, no-wrap
msgid ""
"B<getrlimit>(),\n"
"B<setrlimit>(),\n"
"B<prlimit>()"
msgstr ""
"B<getrlimit>(),\n"
"B<setrlimit>(),\n"
"B<prlimit>()"

#. type: tbl table
#: build/C/man2/getrlimit.2:569 build/C/man2/getrusage.2:210
#: build/C/man3/ulimit.3:88
#, no-wrap
msgid "Thread safety"
msgstr "Thread safety"

#. type: tbl table
#: build/C/man2/getrlimit.2:569 build/C/man2/getrusage.2:210
#: build/C/man3/ulimit.3:88
#, no-wrap
msgid "MT-Safe"
msgstr "MT-Safe"

#. type: Plain text
#: build/C/man2/getrlimit.2:576
msgid ""
"B<getrlimit>(), B<setrlimit>(): POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD."
msgstr "B<getrlimit>(), B<setrlimit>(): POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD."

#. type: Plain text
#: build/C/man2/getrlimit.2:579
msgid "B<prlimit>(): Linux-specific."
msgstr "B<prlimit>(): Linux 固有。"

#. type: Plain text
#: build/C/man2/getrlimit.2:595
msgid ""
"B<RLIMIT_MEMLOCK> and B<RLIMIT_NPROC> derive from BSD and are not specified "
"in POSIX.1; they are present on the BSDs and Linux, but on few other "
"implementations.  B<RLIMIT_RSS> derives from BSD and is not specified in "
"POSIX.1; it is nevertheless present on most implementations.  "
"B<RLIMIT_MSGQUEUE>, B<RLIMIT_NICE>, B<RLIMIT_RTPRIO>, B<RLIMIT_RTTIME>, and "
"B<RLIMIT_SIGPENDING> are Linux-specific."
msgstr "B<RLIMIT_MEMLOCK> と B<RLIMIT_NPROC> は BSD から派生し、 POSIX.1 には指定されていない。これらは BSD 系と Linux に存在するが、他の実装は少ない。 B<RLIMIT_RSS> は BSD から派生し、POSIX.1 には指定されていない。それにも関わらず多くの実装で存在する。 B<RLIMIT_MSGQUEUE>, B<RLIMIT_NICE>, B<RLIMIT_RTPRIO>, B<RLIMIT_RTTIME>, B<RLIMIT_SIGPENDING> は Linux 固有のものである。"

#. type: Plain text
#: build/C/man2/getrlimit.2:601
msgid ""
"A child process created via B<fork>(2)  inherits its parent's resource "
"limits.  Resource limits are preserved across B<execve>(2)."
msgstr ""
"B<fork>(2)  で作成された作成された子プロセスは、 親プロセスのリソース制限を継"
"承する。 B<execve>(2)  の前後でリソース制限は保存される。"

#. type: Plain text
#: build/C/man2/getrlimit.2:604
msgid ""
"Resource limits are per-process attributes that are shared by all of the "
"threads in a process."
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:609
msgid ""
"Lowering the soft limit for a resource below the process's current "
"consumption of that resource will succeed (but will prevent the process from "
"further increasing its consumption of the resource)."
msgstr ""
"リソースのソフトリミットをそのプロセスが現在のリソース使用量より小さい値に設"
"定することはできる (但し、そのプロセスはそれ以降そのリソースの使用量を増やす"
"ことができなくなる)。"

#. type: Plain text
#: build/C/man2/getrlimit.2:618
msgid ""
"One can set the resource limits of the shell using the built-in I<ulimit> "
"command (I<limit> in B<csh>(1)).  The shell's resource limits are inherited "
"by the processes that it creates to execute commands."
msgstr ""
"シェルのリソース制限は、シェルの組み込みコマンドである I<ulimit> (B<csh>(1)  "
"では I<limit )> を使って設定することができる。 このシェルのリソース制限は、コ"
"マンドを実行してシェルが生成するプロセス に引き継がれる。"

#. type: Plain text
#: build/C/man2/getrlimit.2:623
msgid ""
"Since Linux 2.6.24, the resource limits of any process can be inspected via "
"I</proc/[pid]/limits>; see B<proc>(5)."
msgstr ""
"Linux 2.6.24 以降では、 プロセスのリソース上限は I</proc/[pid]/limits> で知る"
"ことができる。 B<proc>(5) 参照。"

#. type: Plain text
#: build/C/man2/getrlimit.2:632
msgid ""
"Ancient systems provided a B<vlimit>()  function with a similar purpose to "
"B<setrlimit>().  For backward compatibility, glibc also provides "
"B<vlimit>().  All new applications should be written using B<setrlimit>()."
msgstr ""
"古いシステムでは、 B<setrlimit>()  と同様の目的を持つ関数 B<vlimit>()  が提供"
"されていた。 後方互換性のため、glibc でも B<vlimit>()  を提供している。 全て"
"の新しいアプリケーションでは、 B<setrlimit>()  を使用すべきである。"

#. type: SS
#: build/C/man2/getrlimit.2:632
#, no-wrap
msgid "C library/kernel ABI differences"
msgstr "C ライブラリとカーネル ABI の違い"

#. type: Plain text
#: build/C/man2/getrlimit.2:641
msgid ""
"Since version 2.13, the glibc B<getrlimit>()  and B<setrlimit>()  wrapper "
"functions no longer invoke the corresponding system calls, but instead "
"employ B<prlimit>(), for the reasons described in BUGS."
msgstr ""
"バージョン 2.13 以降では、 glibc の B<getrlimit>() と B<setrlimit>() のラッ"
"パー関数はもはや対応するシステムコールを呼び出さず、 代わりに「バグ」の節で説"
"明されている理由から B<prlimit>() を利用している。"

#. type: Plain text
#: build/C/man2/getrlimit.2:646
msgid ""
"The name of the glibc wrapper function is B<prlimit>(); the underlying "
"system call is B<prlimit64>()."
msgstr ""

#. type: Plain text
#: build/C/man2/getrlimit.2:655
msgid ""
"In older Linux kernels, the B<SIGXCPU> and B<SIGKILL> signals delivered when "
"a process encountered the soft and hard B<RLIMIT_CPU> limits were delivered "
"one (CPU) second later than they should have been.  This was fixed in kernel "
"2.6.8."
msgstr ""
"以前の Linux カーネルでは、プロセスがソフトまたはハード B<RLIMIT_CPU> リミッ"
"トに達した場合に送られる B<SIGXCPU> と B<SIGKILL> シグナルが、本来送られるべ"
"き時点の 1 (CPU) 秒後に送られてしまう。 これはカーネル 2.6.8 で修正された。"

#.  see http://marc.theaimsgroup.com/?l=linux-kernel&m=114008066530167&w=2
#. type: Plain text
#: build/C/man2/getrlimit.2:663
msgid ""
"In 2.6.x kernels before 2.6.17, a B<RLIMIT_CPU> limit of 0 is wrongly "
"treated as \"no limit\" (like B<RLIM_INFINITY>).  Since Linux 2.6.17, "
"setting a limit of 0 does have an effect, but is actually treated as a limit "
"of 1 second."
msgstr ""
"2.6.17 より前の 2.6.x カーネルでは、 B<RLIMIT_CPU> リミットが 0 の場合、 "
"(B<RLIM_INFINITY> と同じように) 「制限なし」と間違って解釈されていた。 Linux "
"2.6.17 以降では、リミットを 0 に設定した場合にも 効果を持つようになっている"
"が、実際にはリミットの値は 1 秒となる。"

#.  See https://lwn.net/Articles/145008/
#. type: Plain text
#: build/C/man2/getrlimit.2:668
msgid ""
"A kernel bug means that B<RLIMIT_RTPRIO> does not work in kernel 2.6.12; the "
"problem is fixed in kernel 2.6.13."
msgstr ""
"カーネル 2.6.12 には、 B<RLIMIT_RTPRIO> が動作しないというバグがある。この問"
"題はカーネル 2.6.13 で修正されている。"

#.  see http://marc.theaimsgroup.com/?l=linux-kernel&m=112256338703880&w=2
#. type: Plain text
#: build/C/man2/getrlimit.2:679
msgid ""
"In kernel 2.6.12, there was an off-by-one mismatch between the priority "
"ranges returned by B<getpriority>(2)  and B<RLIMIT_NICE>.  This had the "
"effect that the actual ceiling for the nice value was calculated as I<19\\ -"
"\\ rlim_cur>.  This was fixed in kernel 2.6.13."
msgstr ""
"カーネル 2.6.12 では、 B<getpriority>(2)  と B<RLIMIT_NICE> が返す優先度の範"
"囲が一つずれていた。このため、nice 値の実際の上限が I<19\\ -\\ rlim_cur> に"
"なってしまうという影響があった。これはカーネル 2.6.13 で修正された。"

#.  The relevant patch, sent to LKML, seems to be
#.  http://thread.gmane.org/gmane.linux.kernel/273462
#.  From: Roland McGrath <roland <at> redhat.com>
#.  Subject: [PATCH 7/7] make RLIMIT_CPU/SIGXCPU per-process
#.  Date: 2005-01-23 23:27:46 GMT
#.  Tested Solaris 10, FreeBSD 9, OpenBSD 5.0
#.  FIXME . https://bugzilla.kernel.org/show_bug.cgi?id=50951
#. type: Plain text
#: build/C/man2/getrlimit.2:706
msgid ""
"Since Linux 2.6.12, if a process reaches its soft B<RLIMIT_CPU> limit and "
"has a handler installed for B<SIGXCPU>, then, in addition to invoking the "
"signal handler, the kernel increases the soft limit by one second.  This "
"behavior repeats if the process continues to consume CPU time, until the "
"hard limit is reached, at which point the process is killed.  Other "
"implementations do not change the B<RLIMIT_CPU> soft limit in this manner, "
"and the Linux behavior is probably not standards conformant; portable "
"applications should avoid relying on this Linux-specific behavior.  The "
"Linux-specific B<RLIMIT_RTTIME> limit exhibits the same behavior when the "
"soft limit is encountered."
msgstr ""
"Linux 2.6.12 以降では、 プロセスがその B<RLIMIT_CPU> ソフトリミットに達し、 "
"B<SIGXCPU> に対してシグナルハンドラーが設定されている場合、 シグナルハンド"
"ラーを起動するだけでなく、 カーネルは 1 秒間ソフトリミットを増やす。 そのプロ"
"セスが CPU 時間を消費し続けている限り、 ハードリミットに達するまで、この動作"
"が繰り返される。 ハードリミットに達すると、その時点でプロセスは kill され"
"る。 他の実装では、上記のような B<RLIMIT_CPU> ソフトリミットの変更は行われ"
"ず、 おそらく Linux の動作は標準に準拠していない。 移植性が必要なアプリケー"
"ションではこの Linux 固有の動作を前提にするのは避けるべきである。 Linux 固有"
"の上限 B<RLIMIT_RTTIME> でも、 ソフトリミットに達した場合に同じ動作となる。"

#.  d3561f78fd379a7110e46c87964ba7aa4120235c
#. type: Plain text
#: build/C/man2/getrlimit.2:716
msgid ""
"Kernels before 2.4.22 did not diagnose the error B<EINVAL> for "
"B<setrlimit>()  when I<rlim-E<gt>rlim_cur> was greater than I<rlim-"
"E<gt>rlim_max>."
msgstr ""
"2.4.22 より前のカーネルでは、 I<rlim-E<gt>rlim_cur> が I<rlim-E<gt>rlim_max> "
"より大きかった場合、 B<setrlimit>()  での B<EINVAL> エラーを検出できない。"

#. type: Plain text
#: build/C/man2/getrlimit.2:721
msgid ""
"Linux doesn't return an error when an attempt to set B<RLIMIT_CPU> has "
"failed, for compatibility reasons."
msgstr ""

#. type: SS
#: build/C/man2/getrlimit.2:721
#, no-wrap
msgid "Representation of \"large\" resource limit values on 32-bit platforms"
msgstr "32 ビットプラットフォームにおける「大きな」リソース上限値の表現"

#.  Linux still uses long for limits internally:
#.  c022a0acad534fd5f5d5f17280f6d4d135e74e81
#.  kernel/sys.c:do_prlimit() still uses struct rlimit which
#.  uses kernel_ulong_t for its members, i.e. 32-bit  on 32-bit kernel.
#.  https://bugzilla.kernel.org/show_bug.cgi?id=5042
#.  http://sources.redhat.com/bugzilla/show_bug.cgi?id=12201
#. type: Plain text
#: build/C/man2/getrlimit.2:756
msgid ""
"The glibc B<getrlimit>()  and B<setrlimit>()  wrapper functions use a 64-bit "
"I<rlim_t> data type, even on 32-bit platforms.  However, the I<rlim_t> data "
"type used in the B<getrlimit>()  and B<setrlimit>()  system calls is a (32-"
"bit)  I<unsigned long>.  Furthermore, in Linux, the kernel represents "
"resource limits on 32-bit platforms as I<unsigned long>.  However, a 32-bit "
"data type is not wide enough.  The most pertinent limit here is "
"B<RLIMIT_FSIZE>, which specifies the maximum size to which a file can grow: "
"to be useful, this limit must be represented using a type that is as wide as "
"the type used to represent file offsets\\(emthat is, as wide as a 64-bit "
"B<off_t> (assuming a program compiled with I<_FILE_OFFSET_BITS=64>)."
msgstr "glibc の B<getrlimit>() と B<setrlimit>() ラッパー関数は、32 ビットプラットフォームであっても 64 ビットの I<rlim_t> データ型を使用する。 しかし、 B<getrlimit>() と B<setrlimit>() システムコールで使用される I<rlim_t> データ型は (32 ビットの) I<unsigned long> である。 さらに、 Linux では、 カーネルは 32 ビットプラットフォームではリソース上限を I<unsigned long> として表現している。 しかしながら、 32 ビットデータ型は十分な大きさではない。 ここで最も関係がある上限値は B<RLIMIT_FSIZE> である。 この上限はファイルサイズの最大値であり、実用性の面からは、 この上限をファイルオフセットを表現するのに使用されている型、 つまり 64 ビットの B<off_t> (I<_FILE_OFFSET_BITS=64> でコンパイルしたプログラムの場合)、 と同じ幅を持つ型、を使って表現すべきである。"

#. type: Plain text
#: build/C/man2/getrlimit.2:766
msgid ""
"To work around this kernel limitation, if a program tried to set a resource "
"limit to a value larger than can be represented in a 32-bit I<unsigned "
"long>, then the glibc B<setrlimit>()  wrapper function silently converted "
"the limit value to B<RLIM_INFINITY>.  In other words, the requested resource "
"limit setting was silently ignored."
msgstr ""
"カーネルのこの制限に対する対策として、 プログラムがリソース上限を 32 ビット"
"の I<unsigned long> で表現できる値よりも大きな値に設定しようとした際には、 "
"glibc の B<setrlimit>() ラッパー関数はこの上限値を黙って B<RLIM_INFINITY> に"
"変換していた。 言い換えると、指定されたリソース上限値は黙って無視されていた。"

#.  https://www.sourceware.org/bugzilla/show_bug.cgi?id=12201
#. type: Plain text
#: build/C/man2/getrlimit.2:779
msgid ""
"Since version 2.13, glibc works around the limitations of the "
"B<getrlimit>()  and B<setrlimit>()  system calls by implementing "
"B<setrlimit>()  and B<getrlimit>()  as wrapper functions that call "
"B<prlimit>()."
msgstr ""
"バージョン 2.13 以降の glibc では、 B<getrlimit>() と B<setrlimit>() システム"
"コールの制限に対する回避手段として、\n"
"B<setrlimit>() と B<getrlimit>() を B<prlimit>() を呼び出すラッパー関数として"
"実装している。"

#. type: Plain text
#: build/C/man2/getrlimit.2:782
msgid "The program below demonstrates the use of B<prlimit>()."
msgstr "以下のプログラムに B<prlimit>() の使用例を示す。"

#. type: Plain text
#: build/C/man2/getrlimit.2:792
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#define _FILE_OFFSET_BITS 64\n"
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/resource.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#define _FILE_OFFSET_BITS 64\n"
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/resource.hE<gt>\n"

#. type: Plain text
#: build/C/man2/getrlimit.2:795
#, no-wrap
msgid ""
"#define errExit(msg) do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                        } while (0)\n"
msgstr ""
"#define errExit(msg) do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                        } while (0)\n"

#. type: Plain text
#: build/C/man2/getrlimit.2:802
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct rlimit old, new;\n"
"    struct rlimit *newp;\n"
"    pid_t pid;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct rlimit old, new;\n"
"    struct rlimit *newp;\n"
"    pid_t pid;\n"

#. type: Plain text
#: build/C/man2/getrlimit.2:808
#, no-wrap
msgid ""
"    if (!(argc == 2 || argc == 4)) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>pidE<gt> [E<lt>new-soft-limitE<gt> \"\n"
"                \"E<lt>new-hard-limitE<gt>]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (!(argc == 2 || argc == 4)) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>pidE<gt> [E<lt>new-soft-limitE<gt> \"\n"
"                \"E<lt>new-hard-limitE<gt>]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/getrlimit.2:810
#, no-wrap
msgid "    pid = atoi(argv[1]);        /* PID of target process */\n"
msgstr "    pid = atoi(argv[1]);        /* PID of target process */\n"

#. type: Plain text
#: build/C/man2/getrlimit.2:817
#, no-wrap
msgid ""
"    newp = NULL;\n"
"    if (argc == 4) {\n"
"        new.rlim_cur = atoi(argv[2]);\n"
"        new.rlim_max = atoi(argv[3]);\n"
"        newp = &new;\n"
"    }\n"
msgstr ""
"    newp = NULL;\n"
"    if (argc == 4) {\n"
"        new.rlim_cur = atoi(argv[2]);\n"
"        new.rlim_max = atoi(argv[3]);\n"
"        newp = &new;\n"
"    }\n"

#. type: Plain text
#: build/C/man2/getrlimit.2:820
#, no-wrap
msgid ""
"    /* Set CPU time limit of target process; retrieve and display\n"
"       previous limit */\n"
msgstr ""
"    /* Set CPU time limit of target process; retrieve and display\n"
"       previous limit */\n"

#. type: Plain text
#: build/C/man2/getrlimit.2:825
#, no-wrap
msgid ""
"    if (prlimit(pid, RLIMIT_CPU, newp, &old) == -1)\n"
"        errExit(\"prlimit-1\");\n"
"    printf(\"Previous limits: soft=%jd; hard=%jd\\en\",\n"
"            (intmax_t) old.rlim_cur, (intmax_t) old.rlim_max);\n"
msgstr ""
"    if (prlimit(pid, RLIMIT_CPU, newp, &old) == -1)\n"
"        errExit(\"prlimit-1\");\n"
"    printf(\"Previous limits: soft=%jd; hard=%jd\\en\",\n"
"            (intmax_t) old.rlim_cur, (intmax_t) old.rlim_max);\n"

#. type: Plain text
#: build/C/man2/getrlimit.2:827
#, no-wrap
msgid "    /* Retrieve and display new CPU time limit */\n"
msgstr "    /* Retrieve and display new CPU time limit */\n"

#. type: Plain text
#: build/C/man2/getrlimit.2:832
#, no-wrap
msgid ""
"    if (prlimit(pid, RLIMIT_CPU, NULL, &old) == -1)\n"
"        errExit(\"prlimit-2\");\n"
"    printf(\"New limits: soft=%jd; hard=%jd\\en\",\n"
"            (intmax_t) old.rlim_cur, (intmax_t) old.rlim_max);\n"
msgstr ""
"    if (prlimit(pid, RLIMIT_CPU, NULL, &old) == -1)\n"
"        errExit(\"prlimit-2\");\n"
"    printf(\"New limits: soft=%jd; hard=%jd\\en\",\n"
"            (intmax_t) old.rlim_cur, (intmax_t) old.rlim_max);\n"

#. type: Plain text
#: build/C/man2/getrlimit.2:835 build/C/man2/pidfd_send_signal.2:247
#: build/C/man3/posix_spawn.3:807
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man2/getrlimit.2:856
msgid ""
"B<prlimit>(1), B<dup>(2), B<fcntl>(2), B<fork>(2), B<getrusage>(2), "
"B<mlock>(2), B<mmap>(2), B<open>(2), B<quotactl>(2), B<sbrk>(2), "
"B<shmctl>(2), B<malloc>(3), B<sigqueue>(3), B<ulimit>(3), B<core>(5), "
"B<capabilities>(7), B<cgroups>(7), B<credentials>(7), B<signal>(7)"
msgstr "B<prlimit>(1), B<dup>(2), B<fcntl>(2), B<fork>(2), B<getrusage>(2), B<mlock>(2), B<mmap>(2), B<open>(2), B<quotactl>(2), B<sbrk>(2), B<shmctl>(2), B<malloc>(3), B<sigqueue>(3), B<ulimit>(3), B<core>(5), B<capabilities>(7), B<cgroups>(7), B<credentials>(7), B<signal>(7)"

#. type: TH
#: build/C/man2/getrusage.2:39
#, no-wrap
msgid "GETRUSAGE"
msgstr "GETRUSAGE"

#. type: TH
#: build/C/man2/getrusage.2:39
#, no-wrap
msgid "2020-12-21"
msgstr "2020-12-21"

#. type: Plain text
#: build/C/man2/getrusage.2:42
msgid "getrusage - get resource usage"
msgstr "getrusage - 資源の使用量を取得する"

#. type: Plain text
#: build/C/man2/getrusage.2:48
msgid "B<int getrusage(int >I<who>B<, struct rusage *>I<usage>B<);>"
msgstr "B<int getrusage(int >I<who>B<, struct rusage *>I<usage>B<);>"

#. type: Plain text
#: build/C/man2/getrusage.2:53
msgid ""
"B<getrusage>()  returns resource usage measures for I<who>, which can be one "
"of the following:"
msgstr ""
"B<getrusage>()  は I<who> の資源 (resource) の使用量を返す。 I<who> には以下"
"のいずれか一つを指定できる。"

#. type: TP
#: build/C/man2/getrusage.2:53
#, no-wrap
msgid "B<RUSAGE_SELF>"
msgstr "B<RUSAGE_SELF>"

#. type: Plain text
#: build/C/man2/getrusage.2:57
msgid ""
"Return resource usage statistics for the calling process, which is the sum "
"of resources used by all threads in the process."
msgstr ""
"呼び出したプロセスの資源使用量、 そのプロセス内の全スレッドが使用している資源"
"の合計を返す。"

#. type: TP
#: build/C/man2/getrusage.2:57
#, no-wrap
msgid "B<RUSAGE_CHILDREN>"
msgstr "B<RUSAGE_CHILDREN>"

#. type: Plain text
#: build/C/man2/getrusage.2:64
msgid ""
"Return resource usage statistics for all children of the calling process "
"that have terminated and been waited for.  These statistics will include the "
"resources used by grandchildren, and further removed descendants, if all of "
"the intervening descendants waited on their terminated children."
msgstr ""
"呼び出したプロセスの子プロセスのうち、 終了して待ち状態にある全プロセスが使用"
"している資源使用量の統計を返す。 これらの統計情報には、孫プロセスやその子孫の"
"プロセスのうち、 削除待ちのものが使用している資源も含まれる。"

#. type: TP
#: build/C/man2/getrusage.2:64
#, no-wrap
msgid "B<RUSAGE_THREAD> (since Linux 2.6.26)"
msgstr "B<RUSAGE_THREAD> (Linux 2.6.26 以降)"

#. type: Plain text
#: build/C/man2/getrusage.2:74
msgid ""
"Return resource usage statistics for the calling thread.  The B<_GNU_SOURCE> "
"feature test macro must be defined (before including I<any> header file)  in "
"order to obtain the definition of this constant from I<E<lt>sys/resource."
"hE<gt>>."
msgstr ""
"呼び出したスレッドに関する資源使用量の統計を返す。 I<E<lt>sys/resource."
"hE<gt>> からこの定数の定義を得るためには、 ((I<どの>ヘッダーファイルをインク"
"ルードするよりも前に) 機能検査マクロ B<_GNU_SOURCE> を定義しなければならな"
"い。"

#. type: Plain text
#: build/C/man2/getrusage.2:78
msgid ""
"The resource usages are returned in the structure pointed to by I<usage>, "
"which has the following form:"
msgstr ""
"資源使用量は I<usage> が指す構造体に格納されて返される。 構造体は以下の形式で"
"ある。"

#. type: Plain text
#: build/C/man2/getrusage.2:99
#, no-wrap
msgid ""
"struct rusage {\n"
"    struct timeval ru_utime; /* user CPU time used */\n"
"    struct timeval ru_stime; /* system CPU time used */\n"
"    long   ru_maxrss;        /* maximum resident set size */\n"
"    long   ru_ixrss;         /* integral shared memory size */\n"
"    long   ru_idrss;         /* integral unshared data size */\n"
"    long   ru_isrss;         /* integral unshared stack size */\n"
"    long   ru_minflt;        /* page reclaims (soft page faults) */\n"
"    long   ru_majflt;        /* page faults (hard page faults) */\n"
"    long   ru_nswap;         /* swaps */\n"
"    long   ru_inblock;       /* block input operations */\n"
"    long   ru_oublock;       /* block output operations */\n"
"    long   ru_msgsnd;        /* IPC messages sent */\n"
"    long   ru_msgrcv;        /* IPC messages received */\n"
"    long   ru_nsignals;      /* signals received */\n"
"    long   ru_nvcsw;         /* voluntary context switches */\n"
"    long   ru_nivcsw;        /* involuntary context switches */\n"
"};\n"
msgstr ""
"struct rusage {\n"
"    struct timeval ru_utime; /* 使用されたユーザー CPU 時間 */\n"
"    struct timeval ru_stime; /* 使用されたシステム CPU 時間 */\n"
"    long   ru_maxrss;        /* RAM 上に存在する仮想ページのサイズ\n"
"                               (resident set size) の最大値 */\n"
"    long   ru_ixrss;         /* 共有メモリーの合計サイズ */\n"
"    long   ru_idrss;         /* 非共有データの合計サイズ */\n"
"    long   ru_isrss;         /* 非共有スタックの合計サイズ */\n"
"    long   ru_minflt;        /* ページの再利用 (ソフトページフォルト) */\n"
"    long   ru_majflt;        /* ページフォールト (ハードページフォルト) */\n"
"    long   ru_nswap;         /* スワップ */\n"
"    long   ru_inblock;       /* ブロック入力操作 */\n"
"    long   ru_oublock;       /* ブロック出力操作 */\n"
"    long   ru_msgsnd;        /* 送信された IPC メッセージ */\n"
"    long   ru_msgrcv;        /* 受信された IPC メッセージ */\n"
"    long   ru_nsignals;      /* 受信されたシグナル */\n"
"    long   ru_nvcsw;         /* 意図したコンテキスト切り替え */\n"
"    long   ru_nivcsw;        /* 意図しないコンテキスト切り替え */\n"
"};\n"

#. type: Plain text
#: build/C/man2/getrusage.2:107
msgid ""
"Not all fields are completed; unmaintained fields are set to zero by the "
"kernel.  (The unmaintained fields are provided for compatibility with other "
"systems, and because they may one day be supported on Linux.)  The fields "
"are interpreted as follows:"
msgstr ""
"すべてのフィールドがサポートされているわけではない。 メンテナンスされていない"
"フィールドには、 カーネルが 0 を設定する (メンテナンスされていないフィールド"
"は、 他のシステムとの互換性のために提供されており、 いつか Linux でもサポート"
"されるかもしれない)。 各フィールドの詳細は以下の通りである。"

#. type: TP
#: build/C/man2/getrusage.2:107
#, no-wrap
msgid "I<ru_utime>"
msgstr "I<ru_utime>"

#. type: Plain text
#: build/C/man2/getrusage.2:113
msgid ""
"This is the total amount of time spent executing in user mode, expressed in "
"a I<timeval> structure (seconds plus microseconds)."
msgstr ""
"ユーザーモードでの実行で消費された合計時間。 I<timeval> 構造体 (秒とミリ秒) "
"で表現される。"

#. type: TP
#: build/C/man2/getrusage.2:113
#, no-wrap
msgid "I<ru_stime>"
msgstr "I<ru_stime>"

#. type: Plain text
#: build/C/man2/getrusage.2:119
msgid ""
"This is the total amount of time spent executing in kernel mode, expressed "
"in a I<timeval> structure (seconds plus microseconds)."
msgstr ""
"カーネルモードでの実行で消費された合計時間。 I<timeval> 構造体 (秒とミリ秒) "
"で表現される。"

#. type: TP
#: build/C/man2/getrusage.2:119
#, no-wrap
msgid "I<ru_maxrss> (since Linux 2.6.32)"
msgstr "I<ru_maxrss> (Linux 2.6.32 以降)"

#. type: Plain text
#: build/C/man2/getrusage.2:126
msgid ""
"This is the maximum resident set size used (in kilobytes).  For "
"B<RUSAGE_CHILDREN>, this is the resident set size of the largest child, not "
"the maximum resident set size of the process tree."
msgstr ""
"使用された resident set size の最大値 (キロバイト単位)。 B<RUSAGE_CHILDREN> "
"の場合には、プロセスツリーの resident set size の最大値ではなく、 最も大きい"
"子プロセスの resident set size となる。"

#. type: TP
#: build/C/man2/getrusage.2:126
#, no-wrap
msgid "I<ru_ixrss> (unmaintained)"
msgstr "I<ru_ixrss> (メンテナンスされていない)"

#.  On some systems, this field records the number of signals received.
#. type: Plain text
#: build/C/man2/getrusage.2:132 build/C/man2/getrusage.2:137
#: build/C/man2/getrusage.2:142 build/C/man2/getrusage.2:154
#: build/C/man2/getrusage.2:166 build/C/man2/getrusage.2:172
#: build/C/man2/getrusage.2:176
msgid "This field is currently unused on Linux."
msgstr "このフィールドは現在のところ Linux では未使用である。"

#. type: TP
#: build/C/man2/getrusage.2:132
#, no-wrap
msgid "I<ru_idrss> (unmaintained)"
msgstr "I<ru_idrss> (メンテナンスされていない)"

#. type: TP
#: build/C/man2/getrusage.2:137
#, no-wrap
msgid "I<ru_isrss> (unmaintained)"
msgstr "I<ru_isrss> (メンテナンスされていない)"

#. type: TP
#: build/C/man2/getrusage.2:142
#, no-wrap
msgid "I<ru_minflt>"
msgstr "I<ru_minflt>"

#. type: Plain text
#: build/C/man2/getrusage.2:147
msgid ""
"The number of page faults serviced without any I/O activity; here I/O "
"activity is avoided by ``reclaiming'' a page frame from the list of pages "
"awaiting reallocation."
msgstr ""
"I/O 動作なしで発生したページフォルトの回数。 再割り当てを待っているページリス"
"トからページフレームを「回収」 (reclaim) することで、 I/O 動作を避けることが"
"できる。"

#. type: TP
#: build/C/man2/getrusage.2:147
#, no-wrap
msgid "I<ru_majflt>"
msgstr "I<ru_majflt>"

#. type: Plain text
#: build/C/man2/getrusage.2:150
msgid "The number of page faults serviced that required I/O activity."
msgstr "I/O 動作を必要とするページフォルトの回数。"

#. type: TP
#: build/C/man2/getrusage.2:150
#, no-wrap
msgid "I<ru_nswap> (unmaintained)"
msgstr "I<ru_nswap> (メンテナンスされていない)"

#. type: TP
#: build/C/man2/getrusage.2:154
#, no-wrap
msgid "I<ru_inblock> (since Linux 2.6.22)"
msgstr "I<ru_inblock> (Linux 2.6.22 以降)"

#. type: Plain text
#: build/C/man2/getrusage.2:157
msgid "The number of times the filesystem had to perform input."
msgstr "ファイルシステムが入力を実行する必要があった回数。"

#. type: TP
#: build/C/man2/getrusage.2:157
#, no-wrap
msgid "I<ru_oublock> (since Linux 2.6.22)"
msgstr "I<ru_oublock> (Linux 2.6.22 以降)"

#. type: Plain text
#: build/C/man2/getrusage.2:160
msgid "The number of times the filesystem had to perform output."
msgstr "ファイルシステムが出力を実行する必要があった回数。"

#. type: TP
#: build/C/man2/getrusage.2:160
#, no-wrap
msgid "I<ru_msgsnd> (unmaintained)"
msgstr "I<ru_msgsnd> (メンテナンスされていない)"

#. type: TP
#: build/C/man2/getrusage.2:166
#, no-wrap
msgid "I<ru_msgrcv> (unmaintained)"
msgstr "I<ru_msgrcv> (メンテナンスされていない)"

#. type: TP
#: build/C/man2/getrusage.2:172
#, no-wrap
msgid "I<ru_nsignals> (unmaintained)"
msgstr "I<ru_nsignals> (メンテナンスされていない)"

#. type: TP
#: build/C/man2/getrusage.2:176
#, no-wrap
msgid "I<ru_nvcsw> (since Linux 2.6)"
msgstr "I<ru_nvcsw> (Linux 2.6 以降)"

#. type: Plain text
#: build/C/man2/getrusage.2:181
msgid ""
"The number of times a context switch resulted due to a process voluntarily "
"giving up the processor before its time slice was completed (usually to "
"await availability of a resource)."
msgstr ""
"自分のタイムスライスが完了する前にプロセスが自発的にプロセッサを解放して行わ"
"れたコンテキストスイッチの回数 (通常はリソースが利用可能になるのを待つために"
"行われる)。"

#. type: TP
#: build/C/man2/getrusage.2:181
#, no-wrap
msgid "I<ru_nivcsw> (since Linux 2.6)"
msgstr "I<ru_nivcsw> (Linux 2.6 以降)"

#. type: Plain text
#: build/C/man2/getrusage.2:186
msgid ""
"The number of times a context switch resulted due to a higher priority "
"process becoming runnable or because the current process exceeded its time "
"slice."
msgstr ""
"優先度が自分より高いプロセッサが実行可能になったか、現在のプロセスが自分のタ"
"イムスライスを超過したことにより行われたコンテキストスイッチの回数。"

#. type: Plain text
#: build/C/man2/getrusage.2:196
msgid "I<usage> points outside the accessible address space."
msgstr "I<usage> がアクセス可能なアドレス空間の外を指している。"

#. type: Plain text
#: build/C/man2/getrusage.2:200
msgid "I<who> is invalid."
msgstr "I<who> が無効である。"

#. type: tbl table
#: build/C/man2/getrusage.2:210
#, no-wrap
msgid "B<getrusage>()"
msgstr "B<getrusage>()"

#. type: Plain text
#: build/C/man2/getrusage.2:221
msgid ""
"POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD.  POSIX.1 specifies B<getrusage>(), "
"but specifies only the fields I<ru_utime> and I<ru_stime>."
msgstr "POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD.  POSIX.1 は B<getrusage>()  を規定しているが、規定しているフィールドは I<ru_utime> と I<ru_stime> だけである。"

#. type: Plain text
#: build/C/man2/getrusage.2:224
msgid "B<RUSAGE_THREAD> is Linux-specific."
msgstr "B<RUSAGE_THREAD> は Linux 固有である。"

#. type: Plain text
#: build/C/man2/getrusage.2:227
msgid "Resource usage metrics are preserved across an B<execve>(2)."
msgstr "B<execve>(2)  の前後でリソース使用量の指標は保持される。"

#. type: Plain text
#: build/C/man2/getrusage.2:235
msgid ""
"Including I<E<lt>sys/time.hE<gt>> is not required these days, but increases "
"portability.  (Indeed, I<struct timeval> is defined in I<E<lt>sys/time."
"hE<gt>>.)"
msgstr ""
"今日では I<E<lt>sys/time.hE<gt>> をインクルードする必要はないが、 インクルー"
"ドしておけば移植性が増す。 (実際 I<struct timeval> は I<E<lt>sys/time."
"hE<gt>> で定義されている。)"

#.  See the description of getrusage() in XSH.
#.  A similar statement was also in SUSv2.
#. type: Plain text
#: build/C/man2/getrusage.2:247
msgid ""
"In Linux kernel versions before 2.6.9, if the disposition of B<SIGCHLD> is "
"set to B<SIG_IGN> then the resource usages of child processes are "
"automatically included in the value returned by B<RUSAGE_CHILDREN>, although "
"POSIX.1-2001 explicitly prohibits this.  This nonconformance is rectified in "
"Linux 2.6.9 and later."
msgstr ""
"2.6.9 より前のバージョンの Linux カーネルでは、 B<SIGCHLD> の処理が "
"B<SIG_IGN> に設定されていると、 子プロセスのリソース使用量が "
"B<RUSAGE_CHILDREN> で返される値に自動的に含められる。 しかし POSIX.1-2001 で"
"は、これを明確に禁止している。 この準拠していなかった点は、Linux 2.6.9 以降で"
"改正された。"

#. type: Plain text
#: build/C/man2/getrusage.2:250
msgid ""
"The structure definition shown at the start of this page was taken from "
"4.3BSD Reno."
msgstr "このページの最初で示した構造体の定義は 4.3BSD Reno のものである。"

#. type: Plain text
#: build/C/man2/getrusage.2:259
msgid ""
"Ancient systems provided a B<vtimes>()  function with a similar purpose to "
"B<getrusage>().  For backward compatibility, glibc (up until version 2.32) "
"also provides B<vtimes>().  All new applications should be written using "
"B<getrusage>()."
msgstr "古いシステムでは、 B<getrusage>() と同様の目的を持つ関数 B<vtimes>() が提供されていた。後方互換性のため、glibc (バージョン 2.32 まで) でも B<vtimes>() を提供している。全ての新しいアプリケーションでは B<getrusage>() を使用すべきである。"

#. type: Plain text
#: build/C/man2/getrusage.2:264
msgid "See also the description of I</proc/[pid]/stat> in B<proc>(5)."
msgstr "B<proc>(5)  にある I</proc/[pid]/stat> の説明も参照のこと。"

#. type: Plain text
#: build/C/man2/getrusage.2:271
msgid ""
"B<clock_gettime>(2), B<getrlimit>(2), B<times>(2), B<wait>(2), B<wait4>(2), "
"B<clock>(3)"
msgstr ""
"B<clock_gettime>(2), B<getrlimit>(2), B<times>(2), B<wait>(2), B<wait4>(2), "
"B<clock>(3)"

#. type: TH
#: build/C/man2/getsid.2:27
#, no-wrap
msgid "GETSID"
msgstr "GETSID"

#. type: Plain text
#: build/C/man2/getsid.2:30
msgid "getsid - get session ID"
msgstr "getsid - セッション ID を取得する。"

#. type: Plain text
#: build/C/man2/getsid.2:36
msgid "B<pid_t getsid(pid_t>I< pid>B<);>"
msgstr "B<pid_t getsid(pid_t>I< pid>B<);>"

#. type: Plain text
#: build/C/man2/getsid.2:45
msgid "B<getsid>():"
msgstr "B<getsid>():"

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: build/C/man2/getsid.2:49 build/C/man2/setpgid.2:79
#, no-wrap
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* Since glibc 2.12: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L\n"
msgstr ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* glibc 2.12 以降: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L\n"

#. type: Plain text
#: build/C/man2/getsid.2:63
msgid ""
"I<getsid(0)> returns the session ID of the calling process.  B<getsid>()  "
"returns the session ID of the process with process ID I<pid>.  If I<pid> is "
"0, B<getsid>()  returns the session ID of the calling process."
msgstr "I<getsid(0)> は呼び出し元のプロセスのセッション ID を返す。 B<getsid>() はプロセス ID が I<pid> のプロセスのセッション ID を返す。 I<pid> が 0 の場合、 B<getsid>() は呼び出し元プロセスのセッション ID を返す。"

#. type: Plain text
#: build/C/man2/getsid.2:68
msgid ""
"On success, a session ID is returned.  On error, I<(pid_t)\\ -1> will be "
"returned, and I<errno> is set appropriately."
msgstr ""
"成功すると、セッション ID が返される。 エラーの場合、I<(pid_t) -1> が返さ"
"れ、 I<errno> が適切に設定される。"

#. type: Plain text
#: build/C/man2/getsid.2:75
msgid ""
"A process with process ID I<pid> exists, but it is not in the same session "
"as the calling process, and the implementation considers this an error."
msgstr "プロセス ID I<pid> のプロセスは存在するが、呼び出し元のプロセスと同じセッションではなく、 さらに実装がこの状態をエラーと判断した場合。"

#. type: Plain text
#: build/C/man2/getsid.2:80
msgid "No process with process ID I<pid> was found."
msgstr "プロセス ID が I<pid> のプロセスがない。"

#.  Linux has this system call since Linux 1.3.44.
#.  There is libc support since libc 5.2.19.
#. type: Plain text
#: build/C/man2/getsid.2:84
msgid "This system call is available on Linux since version 2.0."
msgstr "このシステムコールは Linux バージョン 2.0 以降で利用可能である。"

#. type: Plain text
#: build/C/man2/getsid.2:86 build/C/man2/setgid.2:76 build/C/man2/setsid.2:75
msgid "POSIX.1-2001, POSIX.1-2008, SVr4."
msgstr "POSIX.1-2001, POSIX.1-2008, SVr4."

#. type: Plain text
#: build/C/man2/getsid.2:89
msgid "Linux does not return B<EPERM>."
msgstr "Linux は B<EPERM> を返さない。"

#. type: Plain text
#: build/C/man2/getsid.2:93
msgid "See B<credentials>(7)  for a description of sessions and session IDs."
msgstr "セッションとセッション ID の説明は B<credentials>(7) を参照。"

#. type: Plain text
#: build/C/man2/getsid.2:97
msgid "B<getpgid>(2), B<setsid>(2), B<credentials>(7)"
msgstr "B<getpgid>(2), B<setsid>(2), B<credentials>(7)"

#. type: TH
#: build/C/man2/getuid.2:26
#, no-wrap
msgid "GETUID"
msgstr "GETUID"

#. type: Plain text
#: build/C/man2/getuid.2:29
msgid "getuid, geteuid - get user identity"
msgstr "getuid, geteuid - ユーザー ID を得る"

#. type: Plain text
#: build/C/man2/getuid.2:35
msgid "B<uid_t getuid(void);>"
msgstr "B<uid_t getuid(void);>"

#. type: Plain text
#: build/C/man2/getuid.2:37
msgid "B<uid_t geteuid(void);>"
msgstr "B<uid_t geteuid(void);>"

#. type: Plain text
#: build/C/man2/getuid.2:40
msgid "B<getuid>()  returns the real user ID of the calling process."
msgstr "B<getuid>()  は呼び出し元のプロセスの実ユーザー ID を返す。"

#. type: Plain text
#: build/C/man2/getuid.2:43
msgid "B<geteuid>()  returns the effective user ID of the calling process."
msgstr "B<geteuid>()  は呼び出し元のプロセスの実効ユーザー ID を返す。"

#. type: SS
#: build/C/man2/getuid.2:48
#, no-wrap
msgid "History"
msgstr "歴史"

#. type: Plain text
#: build/C/man2/getuid.2:57
msgid ""
"In UNIX\\ V6 the B<getuid>()  call returned I<(euid E<lt>E<lt> 8) + uid>.  "
"UNIX\\ V7 introduced separate calls B<getuid>()  and B<geteuid>()."
msgstr ""
"UNIX\\ V6 では B<getuid>()  コールは I<(euid E<lt>E<lt> 8) + uid> を返してい"
"た。 UNIX\\ V7 では B<getuid>()  と B<geteuid>()  という別々のコールが導入さ"
"れた。"

#. type: Plain text
#: build/C/man2/getuid.2:73
msgid ""
"The original Linux B<getuid>()  and B<geteuid>()  system calls supported "
"only 16-bit user IDs.  Subsequently, Linux 2.4 added B<getuid32>()  and "
"B<geteuid32>(), supporting 32-bit IDs.  The glibc B<getuid>()  and "
"B<geteuid>()  wrapper functions transparently deal with the variations "
"across kernel versions."
msgstr ""
"元々の Linux の B<getuid>() と B<geteuid>() システムコールは\n"
"16 ビットのグループ ID だけに対応していた。\n"
"その後、Linux 2.4 で、32 ビットの ID に対応した\n"
"B<getuid32>() と B<geteuid32>() が追加された。\n"
"glibc の B<getuid>() と B<geteuid>() のラッパー関数は\n"
"カーネルバージョンによるこの違いを吸収している。"

#. type: Plain text
#: build/C/man2/getuid.2:89
#, fuzzy
#| msgid ""
#| "The original Linux B<getuid>()  and B<geteuid>()  system calls supported "
#| "only 16-bit user IDs.  Subsequently, Linux 2.4 added B<getuid32>()  and "
#| "B<geteuid32>(), supporting 32-bit IDs.  The glibc B<getuid>()  and "
#| "B<geteuid>()  wrapper functions transparently deal with the variations "
#| "across kernel versions."
msgid ""
"On Alpha, instead of a pair of B<getuid>()  and B<geteuid>()  system calls, "
"a single B<getxuid>()  system call is provided, which returns a pair of real "
"and effective UIDs.  The glibc B<getuid>()  and B<geteuid>()  wrapper "
"functions transparently deal with this.  See B<syscall>(2)  for details "
"regarding register mapping."
msgstr ""
"元々の Linux の B<getuid>() と B<geteuid>() システムコールは\n"
"16 ビットのグループ ID だけに対応していた。\n"
"その後、Linux 2.4 で、32 ビットの ID に対応した\n"
"B<getuid32>() と B<geteuid32>() が追加された。\n"
"glibc の B<getuid>() と B<geteuid>() のラッパー関数は\n"
"カーネルバージョンによるこの違いを吸収している。"

#. type: Plain text
#: build/C/man2/getuid.2:94
msgid "B<getresuid>(2), B<setreuid>(2), B<setuid>(2), B<credentials>(7)"
msgstr "B<getresuid>(2), B<setreuid>(2), B<setuid>(2), B<credentials>(7)"

#. type: TH
#: build/C/man3/group_member.3:25
#, no-wrap
msgid "GROUP_MEMBER"
msgstr "GROUP_MEMBER"

#. type: TH
#: build/C/man3/group_member.3:25
#, no-wrap
msgid "2014-03-30"
msgstr "2014-03-30"

#. type: TH
#: build/C/man3/group_member.3:25 build/C/man3/posix_spawn.3:31
#, no-wrap
msgid "GNU"
msgstr "GNU"

#. type: Plain text
#: build/C/man3/group_member.3:28
msgid "group_member - test whether a process is in a group"
msgstr "group_member - プロセスがグループに属しているかを検査する"

#. type: Plain text
#: build/C/man3/group_member.3:32
msgid "B<int group_member(gid_t >I<gid>B<);>"
msgstr "B<int group_member(gid_t >I<gid>B<);>"

#. type: Plain text
#: build/C/man3/group_member.3:40
msgid "B<group_member>(): _GNU_SOURCE"
msgstr "B<group_member>(): _GNU_SOURCE"

#. type: Plain text
#: build/C/man3/group_member.3:48
msgid ""
"The B<group_member>()  function tests whether any of the caller's "
"supplementary group IDs (as returned by B<getgroups>(2))  matches I<gid>."
msgstr ""
"B<group_member>() 関数は、 呼び出し元の補助グループ ID (B<getgroups>(2) が返"
"す値) のいずれかが I<gid> に一致するかを検索する。"

#. type: Plain text
#: build/C/man3/group_member.3:55
msgid ""
"The B<group_member>()  function returns nonzero if any of the caller's "
"supplementary group IDs matches I<gid>, and zero otherwise."
msgstr ""
"B<group_member>() 関数は、 呼び出し元の補助グループ ID のいずれかが I<gid> に"
"一致すれば 0 以外の値を、そうでなければ 0 を返す。"

#. type: Plain text
#: build/C/man3/group_member.3:57
msgid "This function is a nonstandard GNU extension."
msgstr "この関数は非標準の GNU 拡張である。"

#. type: Plain text
#: build/C/man3/group_member.3:62
msgid "B<getgid>(2), B<getgroups>(2), B<getgrouplist>(3), B<group>(5)"
msgstr "B<getgid>(2), B<getgroups>(2), B<getgrouplist>(3), B<group>(5)"

#. type: TH
#: build/C/man2/iopl.2:33
#, no-wrap
msgid "IOPL"
msgstr "IOPL"

#. type: Plain text
#: build/C/man2/iopl.2:36
msgid "iopl - change I/O privilege level"
msgstr "iopl - I/O 特権レベルを変更する"

#. type: Plain text
#: build/C/man2/iopl.2:38
msgid "B<#include E<lt>sys/io.hE<gt>>"
msgstr "B<#include E<lt>sys/io.hE<gt>>"

#. type: Plain text
#: build/C/man2/iopl.2:40
msgid "B<int iopl(int >I<level>B<);>"
msgstr "B<int iopl(int >I<level>B<);>"

#. type: Plain text
#: build/C/man2/iopl.2:45
msgid ""
"B<iopl>()  changes the I/O privilege level of the calling thread, as "
"specified by the two least significant bits in I<level>."
msgstr "B<iopl>()  は呼び出し元のスレッドの I/O 特権レベルを I<level> の下位 2 ビットで指定した値に変更する。"

#. type: Plain text
#: build/C/man2/iopl.2:48
msgid ""
"The I/O privilege level for a normal thread is 0.  Permissions are inherited "
"from parents to children."
msgstr "通常のスレッドの I/O 特権レベルは 0 である。許可 (permissions) は親から子に継承される。"

#. type: Plain text
#: build/C/man2/iopl.2:56
#, fuzzy
#| msgid ""
#| "This call is mostly for the i386 architecture.  On many other "
#| "architectures it does not exist or will always return an error."
msgid ""
"This call is deprecated, is significantly slower than B<ioperm>(2), and is "
"only provided for older X servers which require access to all 65536 I/O "
"ports.  It is mostly for the i386 architecture.  On many other architectures "
"it does not exist or will always return an error."
msgstr ""
"このシステムコールはほとんど i386 アーキテクチャーのためだけのものである。 そ"
"の他の多くのアーキテクチャーでは存在しないか、常にエラーを返す。"

#. type: Plain text
#: build/C/man2/iopl.2:66
msgid "I<level> is greater than 3."
msgstr "引数 I<level> が 3 より大きい。"

#. type: Plain text
#: build/C/man2/iopl.2:69
msgid "This call is unimplemented."
msgstr "このシステムコールは実装されていない。"

#. type: Plain text
#: build/C/man2/iopl.2:77
msgid ""
"The calling thread has insufficient privilege to call B<iopl>(); the "
"B<CAP_SYS_RAWIO> capability is required to raise the I/O privilege level "
"above its current value."
msgstr "呼び出し元スレッドに B<iopl>()  を呼び出すのに十分な権限がなかった。 I/O 特権レベルを現在の値より上げるには B<CAP_SYS_RAWIO> ケーパビリティが必要である。"

#. type: Plain text
#: build/C/man2/iopl.2:81
msgid ""
"B<iopl>()  is Linux-specific and should not be used in programs that are "
"intended to be portable."
msgstr ""
"B<ipc>()  は Linux 特有であり、 移植を意図したプログラムでは 使用してはいけな"
"い。"

#.  Libc5 treats it as a system call and has a prototype in
#.  .IR <unistd.h> .
#.  Glibc1 does not have a prototype.
#. type: Plain text
#: build/C/man2/iopl.2:90
msgid ""
"Glibc2 has a prototype both in I<E<lt>sys/io.hE<gt>> and in I<E<lt>sys/perm."
"hE<gt>>.  Avoid the latter, it is available on i386 only."
msgstr "glibc2 は I<E<lt>sys/io.hE<gt>> と I<E<lt>sys/perm.hE<gt>> の両方にプロトタイプを持っている。 後者は i386 のみで利用可能なので、使用すべきではない。"

#. type: Plain text
#: build/C/man2/iopl.2:96
#, fuzzy
#| msgid ""
#| "In addition to granting unrestricted I/O port access, running at a higher "
#| "I/O privilege level also allows the process to disable interrupts.  This "
#| "will probably crash the system, and is not recommended."
msgid ""
"Prior to Linux 5.5 B<iopl>()  allowed the thread to disable interrupts while "
"running at a higher I/O privilege level.  This will probably crash the "
"system, and is not recommended."
msgstr ""
"より高い I/O 特権レベルでの動作をさせることによって I/O ポートアクセスの制限"
"を解除することに加えて、プロセスが割り込みを 無効にすることもできるようにな"
"る。この機能は時としてシステムの破壊を もたらすので勧められない。"

#. type: Plain text
#: build/C/man2/iopl.2:106
msgid ""
"Prior to Linux 3.7, on some architectures (such as i386), permissions "
"I<were> inherited by the child produced by B<fork>(2)  and were preserved "
"across B<execve>(2).  This behavior was inadvertently changed in Linux 3.7, "
"and won't be reinstated."
msgstr ""

#. type: Plain text
#: build/C/man2/iopl.2:110
msgid "B<ioperm>(2), B<outb>(2), B<capabilities>(7)"
msgstr "B<ioperm>(2), B<outb>(2), B<capabilities>(7)"

#. type: TH
#: build/C/man2/ioprio_set.2:24
#, no-wrap
msgid "IOPRIO_SET"
msgstr "IOPRIO_SET"

#. type: Plain text
#: build/C/man2/ioprio_set.2:27
msgid "ioprio_get, ioprio_set - get/set I/O scheduling class and priority"
msgstr "ioprio_get, ioprio_set - I/O スケジューリングクラスと優先度の設定/取得"

#. type: Plain text
#: build/C/man2/ioprio_set.2:31
#, no-wrap
msgid ""
"B<int ioprio_get(int >I<which>B<, int >I<who>B<);>\n"
"B<int ioprio_set(int >I<which>B<, int >I<who>B<, int >I<ioprio>B<);>\n"
msgstr ""
"B<int ioprio_get(int >I<which>B<, int >I<who>B<);>\n"
"B<int ioprio_set(int >I<which>B<, int >I<who>B<, int >I<ioprio>B<);>\n"

#. type: Plain text
#: build/C/man2/ioprio_set.2:35
msgid "I<Note>: There are no glibc wrappers for these system calls; see NOTES."
msgstr ""
"I<注意>: これらのシステムコールには glibc ラッパー関数は存在しない。 「注意」"
"の節を参照。"

#. type: Plain text
#: build/C/man2/ioprio_set.2:42
msgid ""
"The B<ioprio_get>()  and B<ioprio_set>()  system calls get and set the I/O "
"scheduling class and priority of one or more threads."
msgstr ""
"システムコール B<ioprio_get>()  / B<ioprio_set>()  は、(1つ以上の) スレッド"
"の I/O スケジューリングクラスと 優先度の取得/設定を行う。"

#. type: Plain text
#: build/C/man2/ioprio_set.2:54
msgid ""
"The I<which> and I<who> arguments identify the thread(s) on which the system "
"calls operate.  The I<which> argument determines how I<who> is interpreted, "
"and has one of the following values:"
msgstr ""
"I<which> と I<who> 引数でシステムコールの操作対象となるスレッドを指示す"
"る。 I<which> 引数は、 I<who> をどのように解釈するかを決めるもので、以下の"
"いずれか一つを指定する。"

#. type: TP
#: build/C/man2/ioprio_set.2:54
#, no-wrap
msgid "B<IOPRIO_WHO_PROCESS>"
msgstr "B<IOPRIO_WHO_PROCESS>"

#. type: Plain text
#: build/C/man2/ioprio_set.2:61
msgid ""
"I<who> is a process ID or thread ID identifying a single process or thread.  "
"If I<who> is 0, then operate on the calling thread."
msgstr ""
"I<who> は特定のプロセスやスレッドを特定するためのプロセス ID かスレッド ID で"
"ある。 I<who> が 0 の場合、呼び出し元のスレッドに対して操作が行われる。"

#. type: TP
#: build/C/man2/ioprio_set.2:61
#, no-wrap
msgid "B<IOPRIO_WHO_PGRP>"
msgstr "B<IOPRIO_WHO_PGRP>"

#. type: Plain text
#: build/C/man2/ioprio_set.2:68
msgid ""
"I<who> is a process group ID identifying all the members of a process "
"group.  If I<who> is 0, then operate on the process group of which the "
"caller is a member."
msgstr ""
"I<who> はプロセスグループ ID であり、プロセスグループの全メンバが対象とな"
"る。 I<who> が 0 の場合、 呼び出し元がメンバーとなっているプロセスグループに"
"対して操作が行われる。"

#. type: TP
#: build/C/man2/ioprio_set.2:68
#, no-wrap
msgid "B<IOPRIO_WHO_USER>"
msgstr "B<IOPRIO_WHO_USER>"

#.  FIXME . Need to document the behavior when 'who" is specified as 0
#.  See http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=652443
#. type: Plain text
#: build/C/man2/ioprio_set.2:75
msgid ""
"I<who> is a user ID identifying all of the processes that have a matching "
"real UID."
msgstr "I<who> はユーザーID であり、実 UID に一致する全プロセスが対象となる。"

#. type: Plain text
#: build/C/man2/ioprio_set.2:98
msgid ""
"If I<which> is specified as B<IOPRIO_WHO_PGRP> or B<IOPRIO_WHO_USER> when "
"calling B<ioprio_get>(), and more than one process matches I<who>, then the "
"returned priority will be the highest one found among all of the matching "
"processes.  One priority is said to be higher than another one if it belongs "
"to a higher priority class (B<IOPRIO_CLASS_RT> is the highest priority "
"class; B<IOPRIO_CLASS_IDLE> is the lowest)  or if it belongs to the same "
"priority class as the other process but has a higher priority level (a lower "
"priority number means a higher priority level)."
msgstr ""
"B<ioprio_get>()  の呼び出し時に I<which> に B<IOPRIO_WHO_PGRP> か "
"B<IOPRIO_WHO_USER> が指定され、 I<who> に一致するプロセスが複数あった場合、 "
"一致するプロセス全体の中で最も高い優先度が返される。 優先度が高いとは、より高"
"い優先度クラスに属している (B<IOPRIO_CLASS_RT> が最も高い優先度クラスで、 "
"B<IOPRIO_CLASS_IDLE> が最も低い)、もしくは 同じ優先度クラスに属しているが優先"
"度レベルが高い (優先度番号が小さい方が優先度レベルが高いことを意味する)、 と"
"いうことである。"

#. type: Plain text
#: build/C/man2/ioprio_set.2:108
msgid ""
"The I<ioprio> argument given to B<ioprio_set>()  is a bit mask that "
"specifies both the scheduling class and the priority to be assigned to the "
"target process(es).  The following macros are used for assembling and "
"dissecting I<ioprio> values:"
msgstr ""
"B<ioprio_set>()  に渡す I<ioprio> 引数は、対象となるプロセスに割り当てるス"
"ケジューリングクラスと 優先度の両方を指定するビットマスクである。 I<ioprio> "
"の値を組み立てたり解釈するのに、以下のマクロが利用できる。"

#. type: TP
#: build/C/man2/ioprio_set.2:108
#, no-wrap
msgid "B<IOPRIO_PRIO_VALUE(>I<class>B<, >I<data>B<)>"
msgstr "B<IOPRIO_PRIO_VALUE(>I<class>B<, >I<data>B<)>"

#. type: Plain text
#: build/C/man2/ioprio_set.2:117
msgid ""
"Given a scheduling I<class> and priority (I<data>), this macro combines the "
"two values to produce an I<ioprio> value, which is returned as the result of "
"the macro."
msgstr ""
"スケジューリングクラス I<class> と優先度 (I<data>)  を与えると、このマクロは "
"2つの値を組み合わせて、 I<ioprio> 値を生成し、マクロの結果として返す。"

#. type: TP
#: build/C/man2/ioprio_set.2:117
#, no-wrap
msgid "B<IOPRIO_PRIO_CLASS(>I<mask>B<)>"
msgstr "B<IOPRIO_PRIO_CLASS(>I<mask>B<)>"

#. type: Plain text
#: build/C/man2/ioprio_set.2:129
msgid ""
"Given I<mask> (an I<ioprio> value), this macro returns its I/O class "
"component, that is, one of the values B<IOPRIO_CLASS_RT>, "
"B<IOPRIO_CLASS_BE>, or B<IOPRIO_CLASS_IDLE>."
msgstr ""
"I<mask> (I<ioprio> 値) を与えると、このマクロは I/O クラス要素、つまり "
"B<IOPRIO_CLASS_RT>, B<IOPRIO_CLASS_BE>, B<IOPRIO_CLASS_IDLE> のいずれか一つの"
"値を返す。"

#. type: TP
#: build/C/man2/ioprio_set.2:129
#, no-wrap
msgid "B<IOPRIO_PRIO_DATA(>I<mask>B<)>"
msgstr "B<IOPRIO_PRIO_DATA(>I<mask>B<)>"

#. type: Plain text
#: build/C/man2/ioprio_set.2:138
msgid ""
"Given I<mask> (an I<ioprio> value), this macro returns its priority "
"(I<data>)  component."
msgstr ""
"I<mask> (I<ioprio> 値) を与えると、このマクロは優先度 (I<data>)  要素を返す。"

#. type: Plain text
#: build/C/man2/ioprio_set.2:144
#, fuzzy
#| msgid ""
#| "See the NOTES section for more information on scheduling classes and "
#| "priorities."
msgid ""
"See the NOTES section for more information on scheduling classes and "
"priorities, as well as the meaning of specifying I<ioprio> as 0."
msgstr ""
"スケジューリングクラスと優先度に関する詳しい情報は、 「備考」の節を参照のこ"
"と。"

#. type: Plain text
#: build/C/man2/ioprio_set.2:152
msgid ""
"I/O priorities are supported for reads and for synchronous (B<O_DIRECT>, "
"B<O_SYNC>)  writes.  I/O priorities are not supported for asynchronous "
"writes because they are issued outside the context of the program dirtying "
"the memory, and thus program-specific priorities do not apply."
msgstr ""
"I/O 優先度は読み出しと同期書き込み (B<O_DIRECT>, B<O_SYNC>)  に対応してい"
"る。 I/O 優先度は非同期書き込みには対応していない。なぜなら、 非同期書き込み"
"はメモリー書き換えを行うプログラムの動作 (context) とは 関係なく発行され、そ"
"のためプログラム単位の優先度は適用されないから である。"

#. type: Plain text
#: build/C/man2/ioprio_set.2:165
msgid ""
"On success, B<ioprio_get>()  returns the I<ioprio> value of the process with "
"highest I/O priority of any of the processes that match the criteria "
"specified in I<which> and I<who>.  On error, -1 is returned, and I<errno> is "
"set to indicate the error."
msgstr ""
"成功すると、 B<ioprio_get>()  は、 I<which> と I<who> で指定された基準に合致"
"した全プロセスで最も高い I/O 優先度を持つプロセスの I<ioprio> 値を返す。 エ"
"ラーの場合、-1 を返し、 I<errno> にエラーを示す値を設定する。"

#. type: Plain text
#: build/C/man2/ioprio_set.2:172
msgid ""
"On success, B<ioprio_set>()  returns 0.  On error, -1 is returned, and "
"I<errno> is set to indicate the error."
msgstr ""
"成功すると、 B<ioprio_set>()  は 0 を返す。 エラーの場合、-1 を返し、 "
"I<errno> にエラーを示す値を設定する。"

#. type: Plain text
#: build/C/man2/ioprio_set.2:182
msgid ""
"Invalid value for I<which> or I<ioprio>.  Refer to the NOTES section for "
"available scheduler classes and priority levels for I<ioprio>."
msgstr ""
"I<which> か I<ioprio> の値が不正である。 I<ioprio> 用に指定可能なスケジューラ"
"クラスと優先度レベルについては 「備考」を参照のこと。"

#. type: Plain text
#: build/C/man2/ioprio_set.2:190
msgid ""
"The calling process does not have the privilege needed to assign this "
"I<ioprio> to the specified process(es).  See the NOTES section for more "
"information on required privileges for B<ioprio_set>()."
msgstr ""
"呼び出し元プロセスが、指定されたプロセスに I<ioprio> を割り当てるのに必要な権"
"限を持っていない。 B<ioprio_set>()  に必要な権限についての詳しい情報は「備"
"考」の節を参照のこと。"

#. type: Plain text
#: build/C/man2/ioprio_set.2:196
msgid ""
"No process(es) could be found that matched the specification in I<which> and "
"I<who>."
msgstr ""
"I<which> と I<who> で指定された基準に合致するプロセスが見つからなかった。"

#. type: Plain text
#: build/C/man2/ioprio_set.2:199
msgid "These system calls have been available on Linux since kernel 2.6.13."
msgstr ""
"これらのシステムコールはカーネル 2.6.13 以降の Linux で利用可能である。"

#. type: Plain text
#: build/C/man2/ioprio_set.2:204
msgid ""
"Glibc does not provide a wrapper for these system calls; call them using "
"B<syscall>(2)."
msgstr ""
"glibc はこれらのシステムコールに対するラッパー関数を提供していない。 "
"B<syscall>(2)  を使って呼び出すこと。"

#. type: Plain text
#: build/C/man2/ioprio_set.2:223
msgid ""
"Two or more processes or threads can share an I/O context.  This will be the "
"case when B<clone>(2)  was called with the B<CLONE_IO> flag.  However, by "
"default, the distinct threads of a process will B<not> share the same I/O "
"context.  This means that if you want to change the I/O priority of all "
"threads in a process, you may need to call B<ioprio_set>()  on each of the "
"threads.  The thread ID that you would need for this operation is the one "
"that is returned by B<gettid>(2)  or B<clone>(2)."
msgstr ""
"複数のプロセスやスレッドが一つの I/O コンテキストを共有する場合がある。 "
"B<clone>(2) を B<CLONE_IO> フラグ付きで呼び出した場合にはこの状況となる。 し"
"かしながら、デフォルトでは、一つのプロセスの個々のスレッドは I/O コンテキスト"
"を共有「しない」。 したがって、 プロセス内のすべてのスレッドの I/O 優先度を変"
"更したい場合には、 それぞれのスレッドに対して B<ioprio_set>() を呼び出す必要"
"がある。 この操作を行うのに必要となるスレッド ID には B<gettid>(2) か "
"B<clone>(2) が返す値を指定する。"

#. type: Plain text
#: build/C/man2/ioprio_set.2:228
msgid ""
"These system calls have an effect only when used in conjunction with an I/O "
"scheduler that supports I/O priorities.  As at kernel 2.6.17 the only such "
"scheduler is the Completely Fair Queuing (CFQ) I/O scheduler."
msgstr ""
"これらのシステムコールは、I/O 優先度に対応した I/O スケジューラと 組み合わせ"
"て使用された場合にのみ効果を持つ。 カーネル 2.6.17 では、この条件を満たすスケ"
"ジューラは Completely Fair Queuing (CFQ) I/O スケジューラだけである。"

#.  commit 8ec680e4c3ec818efd1652f15199ed1c216ab550
#. type: Plain text
#: build/C/man2/ioprio_set.2:241
msgid ""
"If no I/O scheduler has been set for a thread, then by default the I/O "
"priority will follow the CPU nice value (B<setpriority>(2)).  In Linux "
"kernels before version 2.6.24, once an I/O priority had been set using "
"B<ioprio_set>(), there was no way to reset the I/O scheduling behavior to "
"the default.  Since Linux 2.6.24, specifying I<ioprio> as 0 can be used to "
"reset to the default I/O scheduling behavior."
msgstr ""

#. type: SS
#: build/C/man2/ioprio_set.2:241
#, no-wrap
msgid "Selecting an I/O scheduler"
msgstr "I/O スケジューラの選択"

#. type: Plain text
#: build/C/man2/ioprio_set.2:245
msgid ""
"I/O schedulers are selected on a per-device basis via the special file I</"
"sys/block/E<lt>deviceE<gt>/queue/scheduler>."
msgstr ""
"I/O スケジューラの選択はデバイス単位に行われ、その選択は スペシャルファイル "
"I</sys/block/E<lt>deviceE<gt>/queue/scheduler> 経由で行われる。"

#. type: Plain text
#: build/C/man2/ioprio_set.2:251
msgid ""
"One can view the current I/O scheduler via the I</sys> filesystem.  For "
"example, the following command displays a list of all schedulers currently "
"loaded in the kernel:"
msgstr ""
"現在の I/O スケジューラは I</sys> ファイルシステム経由で参照できる。例えば、"
"以下のコマンドを実行すると、 現在カーネルでロードされているスケジューラの全リ"
"ストが表示される。"

#. type: Plain text
#: build/C/man2/ioprio_set.2:256
#, no-wrap
msgid ""
"$B< cat /sys/block/sda/queue/scheduler>\n"
"noop anticipatory deadline [cfq]\n"
msgstr ""
"$B< cat /sys/block/sda/queue/scheduler>\n"
"noop anticipatory deadline [cfq]\n"

#. type: Plain text
#: build/C/man2/ioprio_set.2:270
msgid ""
"The scheduler surrounded by brackets is the one actually in use for the "
"device (I<sda> in the example).  Setting another scheduler is done by "
"writing the name of the new scheduler to this file.  For example, the "
"following command will set the scheduler for the I<sda> device to I<cfq>:"
msgstr "括弧で囲まれたスケジューラがそのデバイス (上の例では I<sda>)  について実際に使用されているスケジューラである。 別のスケジューラを設定するには、このファイルに新しいスケジューラ名を 書き込めばよい。例えば、以下のコマンドを実行すると、デバイス I<sda> のスケジューラとして I<cfq> が設定される。"

#. type: Plain text
#: build/C/man2/ioprio_set.2:276
#, no-wrap
msgid ""
"$B< su>\n"
"Password:\n"
"#B< echo cfq E<gt> /sys/block/sda/queue/scheduler>\n"
msgstr ""
"$B< su>\n"
"Password:\n"
"#B< echo cfq E<gt> /sys/block/sda/queue/scheduler>\n"

#. type: SS
#: build/C/man2/ioprio_set.2:279
#, no-wrap
msgid "The Completely Fair Queuing (CFQ) I/O scheduler"
msgstr "Completely Fair Queuing (CFQ) I/O スケジューラ"

#. type: Plain text
#: build/C/man2/ioprio_set.2:285
msgid ""
"Since version 3 (also known as CFQ Time Sliced), CFQ implements I/O nice "
"levels similar to those of CPU scheduling.  These nice levels are grouped "
"into three scheduling classes, each one containing one or more priority "
"levels:"
msgstr ""
"バージョン 3 (別名 CFQ Time Sliced) 以降、 CPU スケジューリングと同様の I/O "
"nice レベルが CFQ に実装されている。 これらの nice レベルは 3つのスケジューリ"
"ングクラスに分類でき、 各スケジューリングクラスにつき 1つ以上の優先度レベルが"
"定義されている。"

#. type: TP
#: build/C/man2/ioprio_set.2:285
#, no-wrap
msgid "B<IOPRIO_CLASS_RT> (1)"
msgstr "B<IOPRIO_CLASS_RT> (1)"

#. type: Plain text
#: build/C/man2/ioprio_set.2:300
msgid ""
"This is the real-time I/O class.  This scheduling class is given higher "
"priority than any other class: processes from this class are given first "
"access to the disk every time.  Thus, this I/O class needs to be used with "
"some care: one I/O real-time process can starve the entire system.  Within "
"the real-time class, there are 8 levels of class data (priority) that "
"determine exactly how much time this process needs the disk for on each "
"service.  The highest real-time priority level is 0; the lowest is 7.  In "
"the future, this might change to be more directly mappable to performance, "
"by passing in a desired data rate instead."
msgstr ""
"これはリアルタイム I/O クラスである。 このスケジューリングクラスには他のクラ"
"スよりも高い優先度が与えられる。 このクラスのプロセスには、常にディスクへのア"
"クセスが優先して 割り当てられる。そのため、この I/O クラスを使う際には、 たっ"
"た一つの リアルタイム I/O クラスのプロセスにより システム全体のディスクアクセ"
"スができなくなってしまうことがある という点に、注意を払う必要がある。 このク"
"ラスには、8 段階の class data (優先度レベル) がある。 この値は、そのプロセス"
"が 1回のディスクアクセスにどれだけの 時間が必要かを正確に決めるためのものであ"
"る。 最高のリアルタイム優先度レベルは 0 で、最低は 7 である。 将来的には、優"
"先度レベルは、希望するデータレートを渡すなど、 より直接的に性能条件を反映でき"
"るように変更されるかもしれない。"

#. type: TP
#: build/C/man2/ioprio_set.2:300
#, no-wrap
msgid "B<IOPRIO_CLASS_BE> (2)"
msgstr "B<IOPRIO_CLASS_BE> (2)"

#. type: Plain text
#: build/C/man2/ioprio_set.2:313
msgid ""
"This is the best-effort scheduling class, which is the default for any "
"process that hasn't set a specific I/O priority.  The class data (priority) "
"determines how much I/O bandwidth the process will get.  Best-effort "
"priority levels are analogous to CPU nice values (see B<getpriority>(2)).  "
"The priority level determines a priority relative to other processes in the "
"best-effort scheduling class.  Priority levels range from 0 (highest) to 7 "
"(lowest)."
msgstr ""
"これは ベストエフォートスケジューリングクラスである。 このクラスは、特定の I/"
"O 優先度を設定していないプロセスの デフォルト値である。 class data (優先度レ"
"ベル) により、そのプロセスがどの程度の I/O 帯域を得られるかが決定される。 ベ"
"ストエフォート優先度レベルは、CPU の nice 値 (B<getpriority>(2)  参照) と同様"
"のものである。 優先度レベルは、ベストエフォートスケジューリングクラスの中で "
"他のプロセスとの相対的な優先度を決定する。 優先度レベルの値の範囲は 0 (最高) "
"から 7 (最低) である。"

#. type: TP
#: build/C/man2/ioprio_set.2:313
#, no-wrap
msgid "B<IOPRIO_CLASS_IDLE> (3)"
msgstr "B<IOPRIO_CLASS_IDLE> (3)"

#. type: Plain text
#: build/C/man2/ioprio_set.2:322
msgid ""
"This is the idle scheduling class.  Processes running at this level get I/O "
"time only when no one else needs the disk.  The idle class has no class "
"data.  Attention is required when assigning this priority class to a "
"process, since it may become starved if higher priority processes are "
"constantly accessing the disk."
msgstr ""
"これは idle スケジューリングクラスである。 このレベルで動作するプロセスは他に"
"ディスクアクセスをしようとする プロセスがない場合にのみ I/O 時間を取得する。 "
"idle クラスには class data (優先度) は用意されていない。 プロセスにこの優先度"
"を割り当てる際には注意が必要である。 なぜなら、優先度の高いプロセスが常にディ"
"スクにアクセスしている場合には ディスクにアクセスできなくなる可能性があるから"
"だ。"

#. type: Plain text
#: build/C/man2/ioprio_set.2:326
msgid ""
"Refer to the kernel source file I<Documentation/block/ioprio.txt> for more "
"information on the CFQ I/O Scheduler and an example program."
msgstr "CFQ I/O スケジューラの更なる情報とサンプルプログラムについては、カーネルのソースファイル I<Documentation/block/ioprio.txt> を参照のこと。"

#. type: SS
#: build/C/man2/ioprio_set.2:326
#, no-wrap
msgid "Required permissions to set I/O priorities"
msgstr "I/O 優先度の設定に必要な許可"

#. type: Plain text
#: build/C/man2/ioprio_set.2:329
msgid ""
"Permission to change a process's priority is granted or denied based on two "
"criteria:"
msgstr "プロセスの優先度を変更する許可が得られるかどうかは 以下の 2 つの基準に基いて決定される。"

#. type: TP
#: build/C/man2/ioprio_set.2:329
#, no-wrap
msgid "B<Process ownership>"
msgstr "B<プロセスの所有権>"

#. type: Plain text
#: build/C/man2/ioprio_set.2:337
msgid ""
"An unprivileged process may set the I/O priority only for a process whose "
"real UID matches the real or effective UID of the calling process.  A "
"process which has the B<CAP_SYS_NICE> capability can change the priority of "
"any process."
msgstr ""
"非特権プロセスは、プロセスの実 UID が呼び出し元プロセスの実 UID もしくは 実"
"効 UID と一致するプロセスの I/O 優先度のみを設定できる。 B<CAP_SYS_NICE> ケー"
"パビリティを持つプロセスは、どのプロセスの優先度でも変更できる。"

#. type: TP
#: build/C/man2/ioprio_set.2:337
#, no-wrap
msgid "B<What is the desired priority>"
msgstr "B<どの優先度に設定しようとしているか>"

#. type: Plain text
#: build/C/man2/ioprio_set.2:349
msgid ""
"Attempts to set very high priorities (B<IOPRIO_CLASS_RT>)  require the "
"B<CAP_SYS_ADMIN> capability.  Kernel versions up to 2.6.24 also required "
"B<CAP_SYS_ADMIN> to set a very low priority (B<IOPRIO_CLASS_IDLE>), but "
"since Linux 2.6.25, this is no longer required."
msgstr ""
"非常に高い優先度 (B<IOPRIO_CLASS_RT>)  を設定しようとする場合、 "
"B<CAP_SYS_ADMIN> ケーパビリティが必要である。 カーネル 2.6.24 以前では、非常"
"に低い優先度 (B<IOPRIO_CLASS_IDLE>)  を設定するためにも B<CAP_SYS_ADMIN> ケー"
"パビリティが必要であったが、 Linux 2.6.25 以降ではもはや必要なくなった。"

#. type: Plain text
#: build/C/man2/ioprio_set.2:354
msgid ""
"A call to B<ioprio_set>()  must follow both rules, or the call will fail "
"with the error B<EPERM>."
msgstr ""
"B<ioprio_set>()  はこの両方のルールに従い、条件を満たさない場合、エラー "
"B<EPERM> で失敗する。"

#.  6 May 07: Bug report raised:
#.  http://sources.redhat.com/bugzilla/show_bug.cgi?id=4464
#.  Ulrich Drepper replied that he wasn't going to add these
#.  to glibc.
#. type: Plain text
#: build/C/man2/ioprio_set.2:363
msgid ""
"Glibc does not yet provide a suitable header file defining the function "
"prototypes and macros described on this page.  Suitable definitions can be "
"found in I<linux/ioprio.h>."
msgstr ""
"glibc は、このページに記載された関数プロトタイプやマクロを定義する 適切なヘッ"
"ダーファイルをまだ提供していない。 必要な定義については I<linux/ioprio.h> を"
"見ればよい。"

#. type: Plain text
#: build/C/man2/ioprio_set.2:369
msgid ""
"B<ionice>(1), B<getpriority>(2), B<open>(2), B<capabilities>(7), "
"B<cgroups>(7)"
msgstr "B<ionice>(1), B<getpriority>(2), B<open>(2), B<capabilities>(7), B<cgroups>(7)"

#. type: Plain text
#: build/C/man2/ioprio_set.2:372
msgid "I<Documentation/block/ioprio.txt> in the Linux kernel source tree"
msgstr "Linux カーネルソース内の I<Documentation/block/ioprio.txt>"

#. type: TH
#: build/C/man2/ipc.2:25
#, no-wrap
msgid "IPC"
msgstr "IPC"

#. type: TH
#: build/C/man2/ipc.2:25
#, no-wrap
msgid "2019-08-02"
msgstr "2019-08-02"

#. type: Plain text
#: build/C/man2/ipc.2:28
msgid "ipc - System V IPC system calls"
msgstr "ipc - System V IPC システムコール"

#. type: Plain text
#: build/C/man2/ipc.2:33
#, no-wrap
msgid ""
"B<int ipc(unsigned int >I<call>B<, int >I<first>B<, int >I<second>B<, int >I<third>B<,>\n"
"B<        void *>I<ptr>B<, long >I<fifth>B<);>\n"
msgstr ""
"B<int ipc(unsigned int >I<call>B<, int >I<first>B<, int >I<second>B<, int >I<third>B<,>\n"
"B<        void *>I<ptr>B<, long >I<fifth>B<);>\n"

#. type: Plain text
#: build/C/man2/ipc.2:41
msgid ""
"B<ipc>()  is a common kernel entry point for the System\\ V IPC calls for "
"messages, semaphores, and shared memory.  I<call> determines which IPC "
"function to invoke; the other arguments are passed through to the "
"appropriate call."
msgstr ""
"B<ipc>()  は メッセージ、セマフォー、共有メモリーに関する System\\ V IPC コー"
"ルの 共通のカーネルへのエントリーポイントである。 I<call> はどの IPC 関数を呼"
"び出すかを決め； 他の引数は適切なコールへと渡される。"

#. type: Plain text
#: build/C/man2/ipc.2:45
msgid ""
"User-space programs should call the appropriate functions by their usual "
"names.  Only standard library implementors and kernel hackers need to know "
"about B<ipc>()."
msgstr "ユーザー空間プログラムは通常の名前で適切な関数を呼び出すべきである。 標準ライブラリの実装者やカーネルハッカーのみが B<ipc>()  について知る必要がある。"

#. type: Plain text
#: build/C/man2/ipc.2:49
msgid ""
"B<ipc>()  is Linux-specific, and should not be used in programs intended to "
"be portable."
msgstr ""
"B<ipc>()  は Linux 特有であり、 移植を意図したプログラムでは 使用してはいけな"
"い。"

#. type: Plain text
#: build/C/man2/ipc.2:57
msgid ""
"On some architectures\\(emfor example x86-64 and ARM\\(emthere is no "
"B<ipc>()  system call; instead, B<msgctl>(2), B<semctl>(2), B<shmctl>(2), "
"and so on really are implemented as separate system calls."
msgstr ""
"いくつかのアーキテクチャー\\(emfor 例えば x86-64 や ARM\\(emでは、システム"
"コール B<ipc>()  が存在しない。実際には、その代わりに B<msgctl>(2), "
"B<semctl>(2), B<shmctl>(2)  などが独立したシステムコールとして実装されてい"
"る。"

#. type: Plain text
#: build/C/man2/ipc.2:71
msgid ""
"B<msgctl>(2), B<msgget>(2), B<msgrcv>(2), B<msgsnd>(2), B<semctl>(2), "
"B<semget>(2), B<semop>(2), B<semtimedop>(2), B<shmat>(2), B<shmctl>(2), "
"B<shmdt>(2), B<shmget>(2), B<sysvipc>(7)"
msgstr "B<msgctl>(2), B<msgget>(2), B<msgrcv>(2), B<msgsnd>(2), B<semctl>(2), B<semget>(2), B<semop>(2), B<semtimedop>(2), B<shmat>(2), B<shmctl>(2), B<shmdt>(2), B<shmget>(2), B<sysvipc>(7)"

#. type: TH
#: build/C/man2/seteuid.2:29
#, no-wrap
msgid "SETEUID"
msgstr "SETEUID"

#. type: Plain text
#: build/C/man2/seteuid.2:32
msgid "seteuid, setegid - set effective user or group ID"
msgstr "seteuid, setegid - 実効ユーザー ID や 実効グループ ID を設定する"

#. type: Plain text
#: build/C/man2/seteuid.2:38
msgid "B<int seteuid(uid_t >I<euid>B<);>"
msgstr "B<int seteuid(uid_t >I<euid>B<);>"

#. type: Plain text
#: build/C/man2/seteuid.2:40
msgid "B<int setegid(gid_t >I<egid>B<);>"
msgstr "B<int setegid(gid_t >I<egid>B<);>"

#. type: Plain text
#: build/C/man2/seteuid.2:49
msgid "B<seteuid>(), B<setegid>():"
msgstr "B<seteuid>(), B<setegid>():"

#. type: Plain text
#: build/C/man2/seteuid.2:52
#, no-wrap
msgid ""
"_POSIX_C_SOURCE\\ E<gt>=\\ 200112L\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE\n"
msgstr ""
"_POSIX_C_SOURCE\\ E<gt>=\\ 200112L\n"
"    || /* glibc 2.19 以前: */ _BSD_SOURCE\n"

#. type: Plain text
#: build/C/man2/seteuid.2:59
msgid ""
"B<seteuid>()  sets the effective user ID of the calling process.  "
"Unprivileged processes may only set the effective user ID to the real user "
"ID, the effective user ID or the saved set-user-ID."
msgstr "B<seteuid>()  は呼び出し元のプロセスの実効ユーザー ID を設定する。 非特権プロセスの場合、実効ユーザー ID に設定できるのは、 実ユーザー ID・実効ユーザー ID・保存 set-user-ID のいずれかだけである。"

#.  When
#.  .I euid
#.  equals \-1, nothing is changed.
#.  (This is an artifact of the implementation in glibc of seteuid()
#.  using setresuid(2).)
#. type: Plain text
#: build/C/man2/seteuid.2:68
msgid ""
"Precisely the same holds for B<setegid>()  with \"group\" instead of \"user"
"\"."
msgstr ""
"B<setegid>()  は「ユーザー」ではなく「グループ」に対して全く同じことを行う。"

#. type: Plain text
#: build/C/man2/seteuid.2:80
msgid ""
"I<Note>: there are cases where B<seteuid>()  can fail even when the caller "
"is UID 0; it is a grave security error to omit checking for a failure return "
"from B<seteuid>()."
msgstr ""
"I<注意>: 呼び出し元が UID 0 であっても B<seteuid>() が失敗する場合がある。 "
"B<seteuid>() からのリターンが失敗かどうかの確認を省略することは重大なセキュリ"
"ティ上のエラーとなる。"

#. type: Plain text
#: build/C/man2/seteuid.2:84
msgid "The target user or group ID is not valid in this user namespace."
msgstr ""
"対象のユーザー ID かグループ ID がこのユーザー名前空間では有効ではない。"

#. type: Plain text
#: build/C/man2/seteuid.2:94
#, fuzzy
#| msgid ""
#| "The calling process is not privileged (does not have the B<CAP_SETGID> "
#| "capability), and I<gid> does not match the real group ID or saved set-"
#| "group-ID of the calling process."
msgid ""
"In the case of B<seteuid>(): the calling process is not privileged (does not "
"have the B<CAP_SETUID> capability in its user namespace) and I<euid> does "
"not match the current real user ID, current effective user ID, or current "
"saved set-user-ID."
msgstr ""
"呼び出し元のプロセスに権限がなく (B<CAP_SETGID> ケーパビリティがなく)、かつ "
"I<gid> が呼び出し元のプロセスの実グループID と保存セットグループID のどちらと"
"も一致しない。"

#. type: Plain text
#: build/C/man2/seteuid.2:103
#, fuzzy
#| msgid ""
#| "The calling process is not privileged (does not have the B<CAP_SETGID> "
#| "capability), and I<gid> does not match the real group ID or saved set-"
#| "group-ID of the calling process."
msgid ""
"In the case of B<setegid>(): the calling process is not privileged (does not "
"have the B<CAP_SETGID> capability in its user namespace) and I<egid> does "
"not match the current real group ID, current effective group ID, or current "
"saved set-group-ID."
msgstr ""
"呼び出し元のプロセスに権限がなく (B<CAP_SETGID> ケーパビリティがなく)、かつ "
"I<gid> が呼び出し元のプロセスの実グループID と保存セットグループID のどちらと"
"も一致しない。"

#. type: Plain text
#: build/C/man2/seteuid.2:111
msgid ""
"Setting the effective user (group) ID to the saved set-user-ID (saved set-"
"group-ID) is possible since Linux 1.1.37 (1.1.38).  On an arbitrary system "
"one should check B<_POSIX_SAVED_IDS>."
msgstr ""
"実効ユーザー (グループ) ID を保存 set-user-ID (保存 set-group-ID) に 設定でき"
"るのは、Linux 1.1.37 (1.1.38) 以降である。 全てのシステムにおいて "
"B<_POSIX_SAVED_IDS> をチェックすべきである。"

#. type: Plain text
#: build/C/man2/seteuid.2:127
msgid ""
"Under glibc 2.0, B<seteuid(>I<euid>B<)> is equivalent to B<setreuid(-1,>I< "
"euid>B<)> and hence may change the saved set-user-ID.  Under glibc 2.1 and "
"later, it is equivalent to B<setresuid(-1,>I< euid>B<, -1)> and hence does "
"not change the saved set-user-ID.  Analogous remarks hold for B<setegid>(), "
"with the difference that the change in implementation from B<setregid(-1,>I< "
"egid>B<)> to B<setresgid(-1,>I< egid>B<, -1)> occurred in glibc 2.2 or 2.3 "
"(depending on the hardware architecture)."
msgstr ""
"glibc 2.0 では、 B<seteuid(>I<euid>B<)> は B<setreuid(-1,>I< euid>B<)> と等価"
"であり、保存 set-user-ID を変更するかもしれない。 glibc 2.1 では、 "
"B<setresuid(-1,>I< euid>B<, -1)> と等価であり、保存 set-user-ID 変更しない。 "
"同様のことが B<setegid>() にも言えるが、 glibc 2.2 か 2.3 で、 実装が "
"B<setregid(-1,>I< egid>B<)> から B<setresgid(-1,>I< egid>B<, -1)> へ変更され"
"た点だけが違う (どの glibc バージョンで変更が行われたかは、ハードウェアアーキ"
"テクチャーによって異なる)。"

#. type: Plain text
#: build/C/man2/seteuid.2:136
msgid ""
"According to POSIX.1, B<seteuid>()  (B<setegid>())  need not permit I<euid> "
"(I<egid>)  to be the same value as the current effective user (group) ID, "
"and some implementations do not permit this."
msgstr ""
"POSIX.1 では、 B<seteuid>()  (B<setegid>())  で、 I<euid> (I<egid>)  として現"
"在の実効ユーザー (グループ) ID と同じ値を指定可能である 必要はないとされてお"
"り、いくつかの実装では I<euid> (I<egid>)  として現在の実効ユーザー (グルー"
"プ) ID と同じ値を 指定することができない。"

#. type: Plain text
#: build/C/man2/seteuid.2:145
msgid ""
"On Linux, B<seteuid>()  and B<setegid>()  are implemented as library "
"functions that call, respectively, B<setreuid>(2)  and B<setregid>(2)."
msgstr "Linux では、 B<seteuid>() と B<setegid>() は、それぞれ B<setreuid>(2) と B<setregid>(2) を呼び出すライブラリ関数として実装されている。"

#. type: Plain text
#: build/C/man2/seteuid.2:153
msgid ""
"B<geteuid>(2), B<setresuid>(2), B<setreuid>(2), B<setuid>(2), "
"B<capabilities>(7), B<credentials>(7), B<user_namespaces>(7)"
msgstr ""
"B<geteuid>(2), B<setresuid>(2), B<setreuid>(2), B<setuid>(2), "
"B<capabilities>(7), B<credentials>(7), B<user_namespaces>(7)"

#. type: TH
#: build/C/man2/setfsgid.2:32
#, no-wrap
msgid "SETFSGID"
msgstr "SETFSGID"

#. type: TH
#: build/C/man2/setfsgid.2:32 build/C/man2/setfsuid.2:32
#, no-wrap
msgid "2019-05-09"
msgstr "2019-05-09"

#. type: Plain text
#: build/C/man2/setfsgid.2:35
msgid "setfsgid - set group identity used for filesystem checks"
msgstr ""
"setfsgid - ファイルシステムのチェックに用いられるグループ ID を設定する"

#. type: Plain text
#: build/C/man2/setfsgid.2:37 build/C/man2/setfsuid.2:37
msgid "B<#include E<lt>sys/fsuid.hE<gt>>"
msgstr "B<#include E<lt>sys/fsuid.hE<gt>>"

#. type: Plain text
#: build/C/man2/setfsgid.2:39
msgid "B<int setfsgid(uid_t >I<fsgid>B<);>"
msgstr "B<int setfsgid(uid_t >I<fsgid>B<);>"

#. type: Plain text
#: build/C/man2/setfsgid.2:46
msgid ""
"On Linux, a process has both a filesystem group ID and an effective group "
"ID.  The (Linux-specific) filesystem group ID is used for permissions "
"checking when accessing filesystem objects, while the effective group ID is "
"used for some other kinds of permissions checks (see B<credentials>(7))."
msgstr ""

#. type: Plain text
#: build/C/man2/setfsgid.2:57
msgid ""
"Normally, the value of the process's filesystem group ID is the same as the "
"value of its effective group ID.  This is so, because whenever a process's "
"effective group ID is changed, the kernel also changes the filesystem group "
"ID to be the same as the new value of the effective group ID.  A process can "
"cause the value of its filesystem group ID to diverge from its effective "
"group ID by using B<setfsgid>()  to change its filesystem group ID to the "
"value given in I<fsgid>."
msgstr ""

#. type: Plain text
#: build/C/man2/setfsgid.2:63
msgid ""
"B<setfsgid>()  will succeed only if the caller is the superuser or if "
"I<fsgid> matches either the caller's real group ID, effective group ID, "
"saved set-group-ID, or current the filesystem user ID."
msgstr ""
"B<setfsgid>()  は、スーパーユーザーによって呼び出された場合か、 I<fsgid> が呼"
"び出し元の実グループID、実効グループID、 保存セットグループID (saved set-"
"group-ID)、現在のファイルシステムグループ ID の値のいずれかに一致する場合にの"
"み成功する。"

#. type: Plain text
#: build/C/man2/setfsgid.2:66
msgid ""
"On both success and failure, this call returns the previous filesystem group "
"ID of the caller."
msgstr ""
"成功時も失敗時も、 この呼び出しは直前の呼び出し元のファイルシステムグループ "
"ID の値を返す。"

#.  This system call is present since Linux 1.1.44
#.  and in libc since libc 4.7.6.
#. type: Plain text
#: build/C/man2/setfsgid.2:70 build/C/man2/setfsuid.2:81
msgid "This system call is present in Linux since version 1.2."
msgstr "このシステムコールはバージョン 1.2 以降の Linux に存在する。"

#. type: Plain text
#: build/C/man2/setfsgid.2:74
msgid ""
"B<setfsgid>()  is Linux-specific and should not be used in programs intended "
"to be portable."
msgstr ""
"B<setfsgid>()  は Linux 特有であり、移植を想定したプログラムで使用してはいけ"
"ない。"

#. type: Plain text
#: build/C/man2/setfsgid.2:86
#, fuzzy
#| msgid ""
#| "Note that at the time this system call was introduced, a process could "
#| "send a signal to a process with the same effective user ID.  Today signal "
#| "permission handling is slightly different.  See B<setfsuid>(2)  for a "
#| "discussion of why the use of both B<setfsuid>(2)  and B<setfsgid>()  is "
#| "nowadays unneeded."
msgid ""
"The filesystem group ID concept and the B<setfsgid>()  system call were "
"invented for historical reasons that are no longer applicable on modern "
"Linux kernels.  See B<setfsuid>(2)  for a discussion of why the use of both "
"B<setfsuid>(2)  and B<setfsgid>()  is nowadays unneeded."
msgstr ""
"このシステムコールが導入された当時、プロセスは 同じ実効ユーザーIDのプロセスへ"
"シグナルを送ることができた。 今日では、シグナル送信権限の扱いはかなり違うもの"
"になっている。 なぜ今日では B<setfsuid>(2) と B<setfsgid>() の両者が不要なの"
"かの議論については B<setfsuid>(2) を参照のこと。"

#. type: Plain text
#: build/C/man2/setfsgid.2:96
msgid ""
"The original Linux B<setfsgid>()  system call supported only 16-bit group "
"IDs.  Subsequently, Linux 2.4 added B<setfsgid32>()  supporting 32-bit IDs.  "
"The glibc B<setfsgid>()  wrapper function transparently deals with the "
"variation across kernel versions."
msgstr ""
"元々の Linux の B<setfsgid>() システムコールは\n"
"16 ビットのグループ ID だけに対応していた。\n"
"その後、Linux 2.4 で、32 ビットの ID に対応した\n"
"B<setfsgid32>() が追加された。\n"
"glibc の B<setfsgid>() のラッパー関数は\n"
"カーネルバージョンによるこの違いを吸収している。"

#. type: Plain text
#: build/C/man2/setfsgid.2:105
#, fuzzy
#| msgid ""
#| "When glibc determines that the argument is not a valid group ID, it will "
#| "return -1 and set I<errno> to B<EINVAL> without attempting the system "
#| "call."
msgid ""
"In glibc 2.15 and earlier, when the wrapper for this system call determines "
"that the argument can't be passed to the kernel without integer truncation "
"(because the kernel is old and does not support 32-bit group IDs), it will "
"return -1 and set I<errno> to B<EINVAL> without attempting the system call."
msgstr ""
"glibc が引数がグループID として不正だと判断した場合は、 システムコールを行"
"わず I<errno> に B<EINVAL> を設定して -1 が返される。"

#. type: Plain text
#: build/C/man2/setfsgid.2:122
msgid ""
"No error indications of any kind are returned to the caller, and the fact "
"that both successful and unsuccessful calls return the same value makes it "
"impossible to directly determine whether the call succeeded or failed.  "
"Instead, the caller must resort to looking at the return value from a "
"further call such as I<setfsgid(-1)> (which will always fail), in order to "
"determine if a preceding call to B<setfsgid>()  changed the filesystem group "
"ID.  At the very least, B<EPERM> should be returned when the call fails "
"(because the caller lacks the B<CAP_SETGID> capability)."
msgstr ""
"いかなる種類のエラーメッセージも返さず、 成功した場合も失敗した場合も呼び出し"
"は同じ値を返すため、 呼び出しが成功したか失敗したかを直接判定することはできな"
"い。 その代わり、 直前の B<setfsgid>() の呼び出しがファイルシステムグループ "
"ID を変更したかどうかを判定するために、 呼び出し元はこの後に I<setfsgid(-1)> "
"などを呼び出して返り値を見なければならない (I<setfsgid(-1)> は常に失敗す"
"る)。 最低でも、失敗した場合は B<EPERM> くらいは返すべきである (呼び出し元に"
"は B<CAP_SETGID> ケーパビリティがなかったのだから)。"

#. type: Plain text
#: build/C/man2/setfsgid.2:127
msgid "B<kill>(2), B<setfsuid>(2), B<capabilities>(7), B<credentials>(7)"
msgstr "B<kill>(2), B<setfsuid>(2), B<capabilities>(7), B<credentials>(7)"

#. type: TH
#: build/C/man2/setfsuid.2:32
#, no-wrap
msgid "SETFSUID"
msgstr "SETFSUID"

#. type: Plain text
#: build/C/man2/setfsuid.2:35
msgid "setfsuid - set user identity used for filesystem checks"
msgstr ""
"setfsuid - ファイルシステムのチェックに用いられるユーザー ID を設定する"

#. type: Plain text
#: build/C/man2/setfsuid.2:39
msgid "B<int setfsuid(uid_t >I<fsuid>B<);>"
msgstr "B<int setfsuid(uid_t >I<fsuid>B<);>"

#. type: Plain text
#: build/C/man2/setfsuid.2:46
msgid ""
"On Linux, a process has both a filesystem user ID and an effective user ID.  "
"The (Linux-specific) filesystem user ID is used for permissions checking "
"when accessing filesystem objects, while the effective user ID is used for "
"various other kinds of permissions checks (see B<credentials>(7))."
msgstr ""

#. type: Plain text
#: build/C/man2/setfsuid.2:57
msgid ""
"Normally, the value of the process's filesystem user ID is the same as the "
"value of its effective user ID.  This is so, because whenever a process's "
"effective user ID is changed, the kernel also changes the filesystem user ID "
"to be the same as the new value of the effective user ID.  A process can "
"cause the value of its filesystem user ID to diverge from its effective user "
"ID by using B<setfsuid>()  to change its filesystem user ID to the value "
"given in I<fsuid>."
msgstr ""

#. type: Plain text
#: build/C/man2/setfsuid.2:68
#, fuzzy
#| msgid ""
#| "Explicit calls to B<setfsuid>()  and B<setfsgid>(2)  are usually used "
#| "only by programs such as the Linux NFS server that need to change what "
#| "user and group ID is used for file access without a corresponding change "
#| "in the real and effective user and group IDs.  A change in the normal "
#| "user IDs for a program such as the NFS server is a security hole that can "
#| "expose it to unwanted signals.  (But see below.)"
msgid ""
"Explicit calls to B<setfsuid>()  and B<setfsgid>(2)  are (were) usually used "
"only by programs such as the Linux NFS server that need to change what user "
"and group ID is used for file access without a corresponding change in the "
"real and effective user and group IDs.  A change in the normal user IDs for "
"a program such as the NFS server is (was) a security hole that can expose it "
"to unwanted signals.  (However, this issue is historical; see below.)"
msgstr ""
"通常、 B<setfsuid>()  や B<setfsgid>() を明示的に呼び出すのは、Linux NFS サー"
"バー のように、 ファイルアクセスに用いるユーザーID / グループID を変更しなけ"
"ればならないが、 対応する実(real)/実効(effective) ユーザーID / グループID は"
"変更したくないような プログラムに限られる。 NFS サーバーのようなプログラム"
"で、通常のユーザーID を変更すると、 プロセスを望まないシグナルにさらす可能性"
"があり、 セキュリティホールになる。(下記参照)"

#. type: Plain text
#: build/C/man2/setfsuid.2:74
msgid ""
"B<setfsuid>()  will succeed only if the caller is the superuser or if "
"I<fsuid> matches either the caller's real user ID, effective user ID, saved "
"set-user-ID, or current filesystem user ID."
msgstr ""
"B<setfsuid>()  は、スーパーユーザーによって呼び出された場合か、 I<fsuid> が呼"
"び出し元の実ユーザーID、実効ユーザーID、 保存セットユーザーID (saved set-"
"user-ID)、現在のファイルシステムグループ ID の値のいずれかに一致する場合にの"
"み成功する。"

#. type: Plain text
#: build/C/man2/setfsuid.2:77
msgid ""
"On both success and failure, this call returns the previous filesystem user "
"ID of the caller."
msgstr ""
"成功時も失敗時も、 この呼び出しは直前の呼び出し元のファイルシステムユーザー "
"ID の値を返す。"

#. type: Plain text
#: build/C/man2/setfsuid.2:85
msgid ""
"B<setfsuid>()  is Linux-specific and should not be used in programs intended "
"to be portable."
msgstr ""
"B<setfsuid>()  は Linux 特有であり、移植を想定したプログラムで使用してはいけ"
"ない。"

#. type: Plain text
#: build/C/man2/setfsuid.2:104
msgid ""
"At the time when this system call was introduced, one process could send a "
"signal to another process with the same effective user ID.  This meant that "
"if a privileged process changed its effective user ID for the purpose of "
"file permission checking, then it could become vulnerable to receiving "
"signals sent by another (unprivileged) process with the same user ID.  The "
"filesystem user ID attribute was thus added to allow a process to change its "
"user ID for the purposes of file permission checking without at the same "
"time becoming vulnerable to receiving unwanted signals.  Since Linux 2.0, "
"signal permission handling is different (see B<kill>(2)), with the result "
"that a process can change its effective user ID without being vulnerable to "
"receiving signals from unwanted processes.  Thus, B<setfsuid>()  is nowadays "
"unneeded and should be avoided in new applications (likewise for "
"B<setfsgid>(2))."
msgstr ""
"このシステムコールが導入された当時、 あるプロセスは同じ実効ユーザー ID を持つ"
"別のプロセスにシグナルを送信できた。 これは、 特権プロセスがファイルのアクセ"
"ス許可をチェックするために自身の実効ユーザー ID を変更すると、 同じユーザー "
"ID を持つ別の (非特権) プロセスが送信したシグナルを受け取るようになってしまう"
"ことを意味する。そのため、 プロセスが、 受け取りたくないシグナルを受信する状"
"態にならずに、 ファイルのアクセス許可をチェックするために自身のユーザー ID を"
"変更できるように、 ファイルシステムユーザー ID 属性が追加された。 Linux 2.0 "
"以降では、 シグナルの送信許可の扱いは異なり (B<kill>(2) 参照)、 プロセスは、 "
"望まないプロセスからシグナルを受信してしまう状態にならずに、 自身の実効ユー"
"ザー ID を変更することができる。 したがって、 B<setfsuid>() は今日では不要で"
"あり、 新規のアプリケーションでは使用すべきではない (B<setfsgid>(2) も同様)。"

#. type: Plain text
#: build/C/man2/setfsuid.2:114
msgid ""
"The original Linux B<setfsuid>()  system call supported only 16-bit user "
"IDs.  Subsequently, Linux 2.4 added B<setfsuid32>()  supporting 32-bit IDs.  "
"The glibc B<setfsuid>()  wrapper function transparently deals with the "
"variation across kernel versions."
msgstr ""
"元々の Linux の B<setfsuid>() システムコールは\n"
"16 ビットのグループ ID だけに対応していた。\n"
"その後、Linux 2.4 で、32 ビットの ID に対応した\n"
"B<setfsuid32>() が追加された。\n"
"glibc の B<setfsuid>() のラッパー関数は\n"
"カーネルバージョンによるこの違いを吸収している。"

#. type: Plain text
#: build/C/man2/setfsuid.2:123
#, fuzzy
#| msgid ""
#| "When glibc determines that the argument is not a valid user ID, it will "
#| "return -1 and set I<errno> to B<EINVAL> without attempting the system "
#| "call."
msgid ""
"In glibc 2.15 and earlier, when the wrapper for this system call determines "
"that the argument can't be passed to the kernel without integer truncation "
"(because the kernel is old and does not support 32-bit user IDs), it will "
"return -1 and set I<errno> to B<EINVAL> without attempting the system call."
msgstr ""
"glibc が引数がユーザーID として不正だと判断した場合は、 システムコールを行"
"わず I<errno> に B<EINVAL> を設定して -1 が返される。"

#. type: Plain text
#: build/C/man2/setfsuid.2:140
msgid ""
"No error indications of any kind are returned to the caller, and the fact "
"that both successful and unsuccessful calls return the same value makes it "
"impossible to directly determine whether the call succeeded or failed.  "
"Instead, the caller must resort to looking at the return value from a "
"further call such as I<setfsuid(-1)> (which will always fail), in order to "
"determine if a preceding call to B<setfsuid>()  changed the filesystem user "
"ID.  At the very least, B<EPERM> should be returned when the call fails "
"(because the caller lacks the B<CAP_SETUID> capability)."
msgstr ""
"いかなる種類のエラーメッセージも返さず、 成功した場合も失敗した場合も呼び出し"
"は同じ値を返すため、 呼び出しが成功したか失敗したかを直接判定することはできな"
"い。 その代わり、 直前の B<setfsuid>() の呼び出しがファイルシステムグループ "
"ID を変更したかどうかを判定するために、 呼び出し元はこの後に I<setfsuid(-1)> "
"などを呼び出して返り値を見なければならない (I<setfsuid(-1)> は常に失敗す"
"る)。 最低でも、失敗した場合は B<EPERM> くらいは返すべきである (呼び出し元に"
"は B<CAP_SETUID> ケーパビリティがなかったのだから)。"

#. type: Plain text
#: build/C/man2/setfsuid.2:145
msgid "B<kill>(2), B<setfsgid>(2), B<capabilities>(7), B<credentials>(7)"
msgstr "B<kill>(2), B<setfsgid>(2), B<capabilities>(7), B<credentials>(7)"

#. type: TH
#: build/C/man2/setgid.2:30
#, no-wrap
msgid "SETGID"
msgstr "SETGID"

#. type: Plain text
#: build/C/man2/setgid.2:33
msgid "setgid - set group identity"
msgstr "setgid - グループ識別(identity)を設定する"

#. type: Plain text
#: build/C/man2/setgid.2:39
msgid "B<int setgid(gid_t >I<gid>B<);>"
msgstr "B<int setgid(gid_t >I<gid>B<);>"

#. type: Plain text
#: build/C/man2/setgid.2:46
#, fuzzy
#| msgid ""
#| "B<setgid>()  sets the effective group ID of the calling process.  If the "
#| "caller is the superuser, the real GID and saved set-group-ID are also set."
msgid ""
"B<setgid>()  sets the effective group ID of the calling process.  If the "
"calling process is privileged (more precisely: has the B<CAP_SETGID> "
"capability in its user namespace), the real GID and saved set-group-ID are "
"also set."
msgstr ""
"B<setgid>()  は呼び出し元のプロセスの実効 (effective) グループID を設定す"
"る。 もしスーパーユーザーによって呼び出された場合は、 実 (real) グループID と"
"保存 (saved) set-group-ID も設定される。"

#. type: Plain text
#: build/C/man2/setgid.2:56
msgid ""
"Under Linux, B<setgid>()  is implemented like the POSIX version with the "
"B<_POSIX_SAVED_IDS> feature.  This allows a set-group-ID program that is not "
"set-user-ID-root to drop all of its group privileges, do some un-privileged "
"work, and then reengage the original effective group ID in a secure manner."
msgstr ""
"Linux において、 B<setgid>()  は B<_POSIX_SAVED_IDS> をもった POSIX 版のよう"
"に実装されている。 これは set-user-ID-root でない set-group-ID プログラムにそ"
"のグループの 特権の全て落とし、特権の必要ない仕事をし、本来の実効グループID "
"に 安全な方法で再び戻すことを許す。"

#. type: Plain text
#: build/C/man2/setgid.2:67
msgid "The group ID specified in I<gid> is not valid in this user namespace."
msgstr ""
"I<gid> で指定されたグループ ID がこのユーザー名前空間では有効ではない。"

#. type: Plain text
#: build/C/man2/setgid.2:74
msgid ""
"The calling process is not privileged (does not have the B<CAP_SETGID> "
"capability in its user namespace), and I<gid> does not match the real group "
"ID or saved set-group-ID of the calling process."
msgstr "呼び出し元のプロセスに権限がなく (そのプロセスのユーザー名前空間で B<CAP_SETGID> ケーパビリティがなく)、かつ I<gid> が呼び出し元のプロセスの実グループID と保存セットグループID のどちらとも一致しない。"

#. type: Plain text
#: build/C/man2/setgid.2:87
msgid ""
"The original Linux B<setgid>()  system call supported only 16-bit group "
"IDs.  Subsequently, Linux 2.4 added B<setgid32>()  supporting 32-bit IDs.  "
"The glibc B<setgid>()  wrapper function transparently deals with the "
"variation across kernel versions."
msgstr ""
"元々の Linux の B<setgid>() システムコールは\n"
"16 ビットのグループ ID だけに対応していた。\n"
"その後、Linux 2.4 で、32 ビットの ID に対応した\n"
"B<setgid32>() が追加された。\n"
"glibc の B<setgid>() のラッパー関数は\n"
"カーネルバージョンによるこの違いを吸収している。"

#. type: Plain text
#: build/C/man2/setgid.2:101
msgid ""
"At the kernel level, user IDs and group IDs are a per-thread attribute.  "
"However, POSIX requires that all threads in a process share the same "
"credentials.  The NPTL threading implementation handles the POSIX "
"requirements by providing wrapper functions for the various system calls "
"that change process UIDs and GIDs.  These wrapper functions (including the "
"one for B<setgid>())  employ a signal-based technique to ensure that when "
"one thread changes credentials, all of the other threads in the process also "
"change their credentials.  For details, see B<nptl>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/setgid.2:108
msgid ""
"B<getgid>(2), B<setegid>(2), B<setregid>(2), B<capabilities>(7), "
"B<credentials>(7), B<user_namespaces>(7)"
msgstr ""
"B<getgid>(2), B<setegid>(2), B<setregid>(2), B<capabilities>(7), "
"B<credentials>(7), B<user_namespaces>(7)"

#. type: TH
#: build/C/man2/setpgid.2:48
#, no-wrap
msgid "SETPGID"
msgstr "SETPGID"

#. type: Plain text
#: build/C/man2/setpgid.2:51
msgid "setpgid, getpgid, setpgrp, getpgrp - set/get process group"
msgstr "setpgid, getpgid, setpgrp, getpgrp - プロセスグループの設定/取得を行う"

#. type: Plain text
#: build/C/man2/setpgid.2:57
msgid "B<int setpgid(pid_t >I<pid>B<, pid_t >I<pgid>B<);>"
msgstr "B<int setpgid(pid_t >I<pid>B<, pid_t >I<pgid>B<);>"

#. type: Plain text
#: build/C/man2/setpgid.2:59
msgid "B<pid_t getpgid(pid_t >I<pid>B<);>"
msgstr "B<pid_t getpgid(pid_t >I<pid>B<);>"

#. type: Plain text
#: build/C/man2/setpgid.2:61
msgid "B<pid_t getpgrp(void);> /* POSIX.1 version */"
msgstr "B<pid_t getpgrp(void);> /* POSIX.1 version */"

#. type: Plain text
#: build/C/man2/setpgid.2:63
msgid "B<pid_t getpgrp(pid_t >I<pid>B<);> /* BSD version */"
msgstr "B<pid_t getpgrp(pid_t >I<pid>B<);> /* BSD version */"

#. type: Plain text
#: build/C/man2/setpgid.2:65
msgid "B<int setpgrp(void);> /* System V version */"
msgstr "B<int setpgrp(void);> /* System V version */"

#. type: Plain text
#: build/C/man2/setpgid.2:67
msgid "B<int setpgrp(pid_t >I<pid>B<, pid_t >I<pgid>B<);> /* BSD version */"
msgstr "B<int setpgrp(pid_t >I<pid>B<, pid_t >I<pgid>B<);> /* BSD version */"

#. type: Plain text
#: build/C/man2/setpgid.2:75
msgid "B<getpgid>():"
msgstr "B<getpgid>():"

#. type: Plain text
#: build/C/man2/setpgid.2:82
msgid "B<setpgrp>() (POSIX.1):"
msgstr "B<setpgrp>() (POSIX.1):"

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: build/C/man2/setpgid.2:87
#, no-wrap
msgid ""
"    _XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"        || /* Since glibc 2.19: */ _DEFAULT_SOURCE\n"
"        || /* Glibc versions E<lt>= 2.19: */ _SVID_SOURCE\n"
msgstr ""
"    _XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"        || /* glibc 2.19 以降: */ _DEFAULT_SOURCE\n"
"        || /* glibc 2.19 以前: */ _SVID_SOURCE\n"

#. type: Plain text
#: build/C/man2/setpgid.2:91
msgid "B<setpgrp>()\\ (BSD), B<getpgrp>()\\ (BSD):"
msgstr "B<setpgrp>()\\ (BSD), B<getpgrp>()\\ (BSD):"

#. type: Plain text
#: build/C/man2/setpgid.2:96
#, no-wrap
msgid ""
"    [These are available only before glibc 2.19]\n"
"    _BSD_SOURCE &&\n"
"        !\\ (_POSIX_SOURCE || _POSIX_C_SOURCE || _XOPEN_SOURCE ||\n"
"            _GNU_SOURCE || _SVID_SOURCE)\n"
msgstr ""
"    [これらは glibc 2.19 より前でのみ利用可能]\n"
"    _BSD_SOURCE &&\n"
"        !\\ (_POSIX_SOURCE || _POSIX_C_SOURCE || _XOPEN_SOURCE ||\n"
"            _GNU_SOURCE || _SVID_SOURCE)\n"

#. type: Plain text
#: build/C/man2/setpgid.2:107
msgid ""
"All of these interfaces are available on Linux, and are used for getting and "
"setting the process group ID (PGID) of a process.  The preferred, POSIX.1-"
"specified ways of doing this are: B<getpgrp>(void), for retrieving the "
"calling process's PGID; and B<setpgid>(), for setting a process's PGID."
msgstr ""
"これらのインターフェースすべてが Linux で利用可能で、 これらを使ってプロセス"
"のプロセスグループ ID (PGID) の 取得や設定ができる。 推奨の、POSIX.1 で規定さ"
"れた方法では、 B<getpgrp>(void)  で呼び出し元プロセスの PGID を取得し、 "
"B<setpgid>()  で設定する。"

#. type: Plain text
#: build/C/man2/setpgid.2:132
msgid ""
"B<setpgid>()  sets the PGID of the process specified by I<pid> to I<pgid>.  "
"If I<pid> is zero, then the process ID of the calling process is used.  If "
"I<pgid> is zero, then the PGID of the process specified by I<pid> is made "
"the same as its process ID.  If B<setpgid>()  is used to move a process from "
"one process group to another (as is done by some shells when creating "
"pipelines), both process groups must be part of the same session (see "
"B<setsid>(2)  and B<credentials>(7)).  In this case, the I<pgid> specifies "
"an existing process group to be joined and the session ID of that group must "
"match the session ID of the joining process."
msgstr ""
"B<setpgid>()  は I<pid> で指定したプロセスの PGID に I<pgid> を設定する。 "
"I<pid> がゼロならば、呼び出し元プロセスのプロセス ID が pid として使用され"
"る。 I<pgid> がゼロならば、 I<pid> で指定されたプロセスの PGID がそのプロセス"
"のプロセス ID と 同じに設定される。 B<setpgid>()  をプロセスをあるプロセスグ"
"ループから別のグループへ 移動するために使用する場合は (一部のシェルはパイプラ"
"インを生成 する時にこれを行う)、両方のプロセスグループは同じセッションの 一部"
"でなければならない (B<setsid>(2)  と B<credentials>(7)  参照)。この場合は "
"I<pgid> は参加すべき既存の プロセスグループを指定し、そのセッション ID は参加"
"するプロセスの セッション ID に一致しなければならない。"

#. type: Plain text
#: build/C/man2/setpgid.2:137
msgid ""
"The POSIX.1 version of B<getpgrp>(), which takes no arguments, returns the "
"PGID of the calling process."
msgstr ""
"POSIX.1 バージョンの B<getpgrp>()  は引数を一つもとらず、 呼び出し元プロセ"
"スの PGID を返す。"

#. type: Plain text
#: build/C/man2/setpgid.2:148
msgid ""
"B<getpgid>()  returns the PGID of the process specified by I<pid>.  If "
"I<pid> is zero, the process ID of the calling process is used.  (Retrieving "
"the PGID of a process other than the caller is rarely necessary, and the "
"POSIX.1 B<getpgrp>()  is preferred for that task.)"
msgstr ""
"B<getpgid>()  は I<pid> で指定されたプロセスの PGID を返す。 I<pid> がゼロな"
"らば、呼び出し元プロセスのプロセス ID が pid として使用される。 (呼び出し元プ"
"ロセス以外のプロセスの PGID の取得が必要になることは めったになく、呼び出し元"
"プロセスの PGID を取得するには POSIX.1 バージョンの B<getpgrp>()  を使うのが"
"望ましい。)"

#. type: Plain text
#: build/C/man2/setpgid.2:153
msgid ""
"The System\\ V-style B<setpgrp>(), which takes no arguments, is equivalent "
"to I<setpgid(0,\\ 0)>."
msgstr ""
"System\\ V バージョンの B<setpgrp>()  は引数を一つもとらず、 I<setpgid(0,"
"\\ 0)> と等価である。"

#. type: Plain text
#: build/C/man2/setpgid.2:161
msgid ""
"The BSD-specific B<setpgrp>()  call, which takes arguments I<pid> and "
"I<pgid>, is a wrapper function that calls"
msgstr ""
"BSD 仕様の B<setpgrp>()  は I<pid> と I<pgid> を引数にとり、 以下を呼び出す"
"ラッパー関数である。"

#. type: Plain text
#: build/C/man2/setpgid.2:163
#, no-wrap
msgid "    setpgid(pid, pgid)\n"
msgstr "    setpgid(pid, pgid)\n"

#.  The true BSD setpgrp() system call differs in allowing the PGID
#.  to be set to arbitrary values, rather than being restricted to
#.  PGIDs in the same session.
#. type: Plain text
#: build/C/man2/setpgid.2:174
msgid ""
"Since glibc 2.19, the BSD-specific B<setpgrp>()  function is no longer "
"exposed by I<E<lt>unistd.hE<gt>>; calls should be replaced with the "
"B<setpgid>()  call shown above."
msgstr ""
"glibc 2.19 以降、 BSD 固有の B<setpgrp>() 関数はもはや I<E<lt>unistd.hE<gt>> "
"では公開されない。 この関数の呼び出しは上記の B<setpgid>() の呼び出しで置き換"
"えるべきである。"

#. type: Plain text
#: build/C/man2/setpgid.2:180
msgid ""
"The BSD-specific B<getpgrp>()  call, which takes a single I<pid> argument, "
"is a wrapper function that calls"
msgstr ""
"BSD 仕様の B<getpgrp>()  は I<pid> だけを引数にとり、 以下を呼び出すラッ"
"パー関数である。"

#. type: Plain text
#: build/C/man2/setpgid.2:182
#, no-wrap
msgid "    getpgid(pid)\n"
msgstr "    getpgid(pid)\n"

#. type: Plain text
#: build/C/man2/setpgid.2:193
msgid ""
"Since glibc 2.19, the BSD-specific B<getpgrp>()  function is no longer "
"exposed by I<E<lt>unistd.hE<gt>>; calls should be replaced with calls to the "
"POSIX.1 B<getpgrp>()  which takes no arguments (if the intent is to obtain "
"the caller's PGID), or with the B<getpgid>()  call shown above."
msgstr ""
"glibc 2.19 以降、 BSD 固有の B<getpgrp>() 関数はもはや I<E<lt>unistd.hE<gt>> "
"では公開されない。 この関数の呼び出しは、引数を取らない POSIX.1 の "
"B<getpgrp>() の呼び出し (呼び出し元の PGID を取得する目的の場合)、もしくは上"
"記の B<getpgid>() の呼び出しで置き換えるべきである。"

#. type: Plain text
#: build/C/man2/setpgid.2:202
msgid ""
"On success, B<setpgid>()  and B<setpgrp>()  return zero.  On error, -1 is "
"returned, and I<errno> is set appropriately."
msgstr ""
"B<setpgid>()  と B<setpgrp>()  は成功した場合、ゼロを返す。エラーの場合は -1 "
"を返し、 I<errno> が適切に設定される。"

#. type: Plain text
#: build/C/man2/setpgid.2:206
msgid "The POSIX.1 B<getpgrp>()  always returns the PGID of the caller."
msgstr ""
"POSIX.1 バージョンの B<getpgrp>()  は常に呼び出しプロセスの PGID を返す。"

#. type: Plain text
#: build/C/man2/setpgid.2:214
msgid ""
"B<getpgid>(), and the BSD-specific B<getpgrp>()  return a process group on "
"success.  On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""
"B<getpgid>()  と BSD 仕様の B<getpgrp>()  は成功した場合プロセスグループを返"
"す。 エラーの場合は -1 を返し、 I<errno> が適切に設定される。"

#. type: Plain text
#: build/C/man2/setpgid.2:223
msgid ""
"An attempt was made to change the process group ID of one of the children of "
"the calling process and the child had already performed an B<execve>(2)  "
"(B<setpgid>(), B<setpgrp>())."
msgstr ""
"呼び出し元プロセスの子プロセスのプロセスグループ ID を変更しようとしたが、 す"
"でにその子プロセスは B<execve>(2)  を実行していた。 (B<setpgid>(), "
"B<setpgrp>())"

#. type: Plain text
#: build/C/man2/setpgid.2:229
msgid "I<pgid> is less than 0 (B<setpgid>(), B<setpgrp>())."
msgstr "I<pgid> が 0 より小さい。 (B<setpgid>(), B<setpgrp>())"

#. type: Plain text
#: build/C/man2/setpgid.2:238
msgid ""
"An attempt was made to move a process into a process group in a different "
"session, or to change the process group ID of one of the children of the "
"calling process and the child was in a different session, or to change the "
"process group ID of a session leader (B<setpgid>(), B<setpgrp>())."
msgstr ""
"プロセスを異なるセッションのプロセスグループに移動させようとした。 または呼び"
"出し元プロセスの子プロセスのプロセスグループ ID を変更しようと したが、その子"
"プロセスは別のセッションだった。 またはセッションリーダーのプロセスグループ "
"ID を変更しようとした。 (B<setpgid>(), B<setpgrp>())"

#. type: Plain text
#: build/C/man2/setpgid.2:248
msgid ""
"For B<getpgid>(): I<pid> does not match any process.  For B<setpgid>(): "
"I<pid> is not the calling process and not a child of the calling process."
msgstr ""
"B<getpgid>()  の場合: I<pid> がどのプロセスにも一致しない。 B<setpgid>()  の"
"場合: I<pid> が呼び出し元のプロセスではなく、呼び出し元のプロセスの子プロセス"
"でもない。"

#. type: Plain text
#: build/C/man2/setpgid.2:254
msgid ""
"B<setpgid>()  and the version of B<getpgrp>()  with no arguments conform to "
"POSIX.1-2001."
msgstr ""
"B<setpgid>()  と、引数なしバージョンの B<getpgrp>()  は POSIX.1-2001 に準拠"
"している。"

#. type: Plain text
#: build/C/man2/setpgid.2:263
msgid ""
"POSIX.1-2001 also specifies B<getpgid>()  and the version of B<setpgrp>()  "
"that takes no arguments.  (POSIX.1-2008 marks this B<setpgrp>()  "
"specification as obsolete.)"
msgstr ""
"POSIX.1-2001 は、 B<getpgid>()  と、引数なしバージョンの B<setpgrp>()  も規"
"定している。 POSIX.1-2008 は、この B<setpgrp>()  の仕様を廃止予定としている。"

#. type: Plain text
#: build/C/man2/setpgid.2:270
msgid ""
"The version of B<getpgrp>()  with one argument and the version of "
"B<setpgrp>()  that takes two arguments derive from 4.2BSD, and are not "
"specified by POSIX.1."
msgstr ""
"引数 1 個バージョンの B<getpgrp>()  と引数 2 個バージョンの "
"B<setpgrp>()  は 4.2BSD に由来し、 POSIX.1 では規定されていない。"

#. type: Plain text
#: build/C/man2/setpgid.2:276
msgid ""
"A child created via B<fork>(2)  inherits its parent's process group ID.  The "
"PGID is preserved across an B<execve>(2)."
msgstr ""
"B<fork>(2)  で作成された子プロセスは、親プロセスの PGID を継承する。 "
"B<execve>(2)  の前後で PGID は保存される。"

#. type: Plain text
#: build/C/man2/setpgid.2:281
msgid ""
"Each process group is a member of a session and each process is a member of "
"the session of which its process group is a member.  (See B<credentials>(7).)"
msgstr "各プロセスグループはセッションのメンバーであり、各プロセスは そのプロセスグループが所属しているセッションのメンバーである (B<credentials>(7) 参照)。"

#. type: Plain text
#: build/C/man2/setpgid.2:308
msgid ""
"A session can have a controlling terminal.  At any time, one (and only one) "
"of the process groups in the session can be the foreground process group for "
"the terminal; the remaining process groups are in the background.  If a "
"signal is generated from the terminal (e.g., typing the interrupt key to "
"generate B<SIGINT>), that signal is sent to the foreground process group.  "
"(See B<termios>(3)  for a description of the characters that generate "
"signals.)  Only the foreground process group may B<read>(2)  from the "
"terminal; if a background process group tries to B<read>(2)  from the "
"terminal, then the group is sent a B<SIGTTIN> signal, which suspends it.  "
"The B<tcgetpgrp>(3)  and B<tcsetpgrp>(3)  functions are used to get/set the "
"foreground process group of the controlling terminal."
msgstr ""
"セッションは制御端末 (controlling terminal) を持つことができる。 いつでも、"
"セッションに所属するプロセスグループの一つ (だけ) が 端末のフォアグランドのプ"
"ロセスグループになることができ、 残りのプロセスグループはバックグラウンドにな"
"る。 端末からシグナルが生成された場合 (例えば、中断キーを叩いて B<SIGINT> が"
"生成されるなど)、そのシグナルはフォアグラウンドのプロセスグループ に送られる "
"(シグナルを生成する文字の説明は B<termios>(3)  を参照)。 フォアグラウンドのプ"
"ロセスグループだけが端末からの B<read>(2)  ができる。 バックグラウンドのプロ"
"セスグループが端末からの B<read>(2)  を行おうとした場合、そのプロセスグループ"
"にはシグナル B<SIGTTIN> が送られ、そのプロセスグループは一時停止 (suspend) す"
"る。 関数 B<tcgetpgrp>(3)  と B<tcsetpgrp>(3)  を使うと、制御端末のフォアグラ"
"ウンドのプロセスグループを 取得/設定できる。"

#. type: Plain text
#: build/C/man2/setpgid.2:316
msgid ""
"The B<setpgid>()  and B<getpgrp>()  calls are used by programs such as "
"B<bash>(1)  to create process groups in order to implement shell job control."
msgstr ""
"B<setpgid>()  と B<getpgrp>()  は、 B<bash>(1)  のようなプログラムで、シェル"
"のジョブ制御 (job control) の実装のための プロセスグループを作成するのに使わ"
"れる。"

#.  exit.3 refers to the following text:
#. type: Plain text
#: build/C/man2/setpgid.2:330
msgid ""
"If the termination of a process causes a process group to become orphaned, "
"and if any member of the newly orphaned process group is stopped, then a "
"B<SIGHUP> signal followed by a B<SIGCONT> signal will be sent to each "
"process in the newly orphaned process group.  An orphaned process group is "
"one in which the parent of every member of process group is either itself "
"also a member of the process group or is a member of a process group in a "
"different session (see also B<credentials>(7))."
msgstr ""
"プロセスの終了によってプロセスグループが孤児 (orphaned) になった際に、 その新"
"たに孤児になったプロセスグループに停止しているメンバーがいれば、 その孤児に"
"なったプロセスグループに属す全てのプロセスに B<SIGHUP> シグナルに続けて "
"B<SIGCONT> シグナルが送られる。 孤児になった (orphaned) プロセスグループと"
"は、 そのプロセスグループの全てのメンバーについて、メンバーの親プロセスが、 "
"親プロセス自身もそのプロセスグループのメンバーか、 別のセッションに属すプロセ"
"スグループのメンバーのいずれかであるような、 プロセスグループのことである。"

#. type: Plain text
#: build/C/man2/setpgid.2:337
msgid ""
"B<getuid>(2), B<setsid>(2), B<tcgetpgrp>(3), B<tcsetpgrp>(3), B<termios>(3), "
"B<credentials>(7)"
msgstr ""
"B<getuid>(2), B<setsid>(2), B<tcgetpgrp>(3), B<tcsetpgrp>(3), B<termios>(3), "
"B<credentials>(7)"

#. type: TH
#: build/C/man2/setresuid.2:27
#, no-wrap
msgid "SETRESUID"
msgstr "SETRESUID"

#. type: Plain text
#: build/C/man2/setresuid.2:30
msgid "setresuid, setresgid - set real, effective and saved user or group ID"
msgstr ""
"setresuid, setresgid - ユーザーやグループの 実、実効、保存 ID を設定する"

#. type: Plain text
#: build/C/man2/setresuid.2:36
msgid "B<int setresuid(uid_t >I<ruid>B<, uid_t >I<euid>B<, uid_t >I<suid>B<);>"
msgstr ""
"B<int setresuid(uid_t >I<ruid>B<, uid_t >I<euid>B<, uid_t >I<suid>B<);>"

#. type: Plain text
#: build/C/man2/setresuid.2:38
msgid "B<int setresgid(gid_t >I<rgid>B<, gid_t >I<egid>B<, gid_t >I<sgid>B<);>"
msgstr ""
"B<int setresgid(gid_t >I<rgid>B<, gid_t >I<egid>B<, gid_t >I<sgid>B<);>"

#. type: Plain text
#: build/C/man2/setresuid.2:42
msgid ""
"B<setresuid>()  sets the real user ID, the effective user ID, and the saved "
"set-user-ID of the calling process."
msgstr ""
"B<setresuid>()  は呼び出し元のプロセスの実 (real) ユーザーID、実効 "
"(effective) ユーザーID、 保存 set-user-ID を設定する。"

#. type: Plain text
#: build/C/man2/setresuid.2:47
msgid ""
"An unprivileged process may change its real UID, effective UID, and saved "
"set-user-ID, each to one of: the current real UID, the current effective UID "
"or the current saved set-user-ID."
msgstr "非特権プロセスは、その実 UID、実効 UID、保存 set-user-ID を、 現在の実 UID、現在の実効 UID、現在の保存 set-user-ID のどれかに変更することができる:"

#. type: Plain text
#: build/C/man2/setresuid.2:51
msgid ""
"A privileged process (on Linux, one having the B<CAP_SETUID> capability)  "
"may set its real UID, effective UID, and saved set-user-ID to arbitrary "
"values."
msgstr "特権プロセス (Linux では B<CAP_SETUID> ケーパビリティ (capability) を持つ プロセス) は、自身の実 UID、実効 UID、保存 set-user-ID を任意の値に設定できる。"

#. type: Plain text
#: build/C/man2/setresuid.2:53
msgid ""
"If one of the arguments equals -1, the corresponding value is not changed."
msgstr "引数のどれかが -1 の場合はその値は変更されずに残される。"

#. type: Plain text
#: build/C/man2/setresuid.2:57
msgid ""
"Regardless of what changes are made to the real UID, effective UID, and "
"saved set-user-ID, the filesystem UID is always set to the same value as the "
"(possibly new) effective UID."
msgstr ""
"実 UID、実効 UID、保存 set-user-ID にどんな変更が行われたかに関わらず、 ファ"
"イルシステム UID は常に実効 UID (可能であれば変更後の新しい実効 UID)  と同じ"
"値に設定される。"

#. type: Plain text
#: build/C/man2/setresuid.2:64
msgid ""
"Completely analogously, B<setresgid>()  sets the real GID, effective GID, "
"and saved set-group-ID of the calling process (and always modifies the "
"filesystem GID to be the same as the effective GID), with the same "
"restrictions for unprivileged processes."
msgstr ""
"全く同じように、 B<setresgid>()  は呼び出し元のプロセスの実 GID、実効 GID、保"
"存 set-group-ID を設定する (さらにファイルシステム GID を実効 GID と同じ値に"
"修正する)。 非特権プロセスは同様の制限を受ける。"

#. type: Plain text
#: build/C/man2/setresuid.2:76
msgid ""
"I<Note>: there are cases where B<setresuid>()  can fail even when the caller "
"is UID 0; it is a grave security error to omit checking for a failure return "
"from B<setresuid>()."
msgstr ""
"I<注意>: 呼び出し元が UID 0 であっても B<setresuid>() が失敗する場合がある。 "
"B<setresuid>() からのリターンが失敗かどうかの確認を省略することは重大なセキュ"
"リティ上のエラーとなる。"

#. type: TP
#: build/C/man2/setresuid.2:77 build/C/man2/setresuid.2:84
#: build/C/man2/setreuid.2:109 build/C/man2/setreuid.2:116
#: build/C/man2/setuid.2:86 build/C/man2/setuid.2:93
#, no-wrap
msgid "B<EAGAIN>"
msgstr "B<EAGAIN>"

#. type: Plain text
#: build/C/man2/setresuid.2:84 build/C/man2/setreuid.2:116
msgid ""
"The call would change the caller's real UID (i.e., I<ruid> does not match "
"the caller's real UID), but there was a temporary failure allocating the "
"necessary kernel data structures."
msgstr ""
"この呼び出しで呼び出し元の実 UID が変更されるはずだったが (つまり、 I<ruid> "
"が呼び出し元の実 UID と一致していない)、 必要なカーネルのデータ構造体の割り当"
"てで一時的な失敗があった。"

#. type: Plain text
#: build/C/man2/setresuid.2:99 build/C/man2/setreuid.2:131
msgid ""
"I<ruid> does not match the caller's real UID and this call would bring the "
"number of processes belonging to the real user ID I<ruid> over the caller's "
"B<RLIMIT_NPROC> resource limit.  Since Linux 3.1, this error case no longer "
"occurs (but robust applications should check for this error); see the "
"description of B<EAGAIN> in B<execve>(2)."
msgstr ""
"I<ruid> は呼び出し元の実 UID と一致しておらず、 この呼び出しで実ユーザー ID "
"I<ruid> に属するプロセス数が呼び出し元の B<RLIMIT_NPROC> リソース上限を超過す"
"るところであった。 Linux 3.1 以降では、このエラーはもはや発生することはない "
"(しかし、堅牢性が求められるアプリケーションではこのエラーを確認すべきであ"
"る)。 B<execve>(2) の B<EAGAIN> の説明を参照。"

#. type: Plain text
#: build/C/man2/setresuid.2:103 build/C/man2/setreuid.2:135
msgid ""
"One or more of the target user or group IDs is not valid in this user "
"namespace."
msgstr ""
"対象のユーザー ID やグループ ID のうち 1 つ以上がこのユーザー名前空間で有効で"
"はない。"

#. type: Plain text
#: build/C/man2/setresuid.2:116
#, fuzzy
#| msgid ""
#| "The calling process is not privileged (did not have the B<CAP_SETUID> "
#| "capability) and tried to change the IDs to values that are not permitted."
msgid ""
"The calling process is not privileged (did not have the necessary capability "
"in its user namespace)  and tried to change the IDs to values that are not "
"permitted.  For B<setresuid>(), the necessary capability is B<CAP_SETUID>; "
"for B<setresgid>(), it is B<CAP_SETGID>."
msgstr ""
"呼び出したプロセスが特権を持たないのに (B<CAP_SETUID> ケーパビリティを持たな"
"いのに)、 ID を許されていない値に変更しようとした。"

#. type: Plain text
#: build/C/man2/setresuid.2:118
msgid "These calls are available under Linux since Linux 2.1.44."
msgstr "Linux ではバージョン 2.1.44 より利用可能になった。"

#. type: Plain text
#: build/C/man2/setresuid.2:125
msgid ""
"Under HP-UX and FreeBSD, the prototype is found in I<E<lt>unistd.hE<gt>>.  "
"Under Linux, the prototype is provided by glibc since version 2.3.2."
msgstr ""
"HP-UX や FreeBSD では I<E<lt>unistd.hE<gt>> にプロトタイプが存在する。 \n"
"Linux では、glibc 2.3.2 以降で プロトタイプが提供されている。"

#. type: Plain text
#: build/C/man2/setresuid.2:142
msgid ""
"The original Linux B<setresuid>()  and B<setresgid>()  system calls "
"supported only 16-bit user and group IDs.  Subsequently, Linux 2.4 added "
"B<setresuid32>()  and B<setresgid32>(), supporting 32-bit IDs.  The glibc "
"B<setresuid>()  and B<setresgid>()  wrapper functions transparently deal "
"with the variations across kernel versions."
msgstr ""
"元々の Linux の B<setresuid>() と B<setresgid>() システムコールは\n"
"16 ビットのグループ ID だけに対応していた。\n"
"その後、Linux 2.4 で、32 ビットの ID に対応した\n"
"B<setresuid32>() と B<setresgid32>() が追加された。\n"
"glibc の B<setresuid>() と B<setresgid>() のラッパー関数は\n"
"カーネルバージョンによるこの違いを吸収している。"

#. type: Plain text
#: build/C/man2/setresuid.2:158
msgid ""
"At the kernel level, user IDs and group IDs are a per-thread attribute.  "
"However, POSIX requires that all threads in a process share the same "
"credentials.  The NPTL threading implementation handles the POSIX "
"requirements by providing wrapper functions for the various system calls "
"that change process UIDs and GIDs.  These wrapper functions (including those "
"for B<setresuid>()  and B<setresgid>())  employ a signal-based technique to "
"ensure that when one thread changes credentials, all of the other threads in "
"the process also change their credentials.  For details, see B<nptl>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/setresuid.2:168
msgid ""
"B<getresuid>(2), B<getuid>(2), B<setfsgid>(2), B<setfsuid>(2), "
"B<setreuid>(2), B<setuid>(2), B<capabilities>(7), B<credentials>(7), "
"B<user_namespaces>(7)"
msgstr ""
"B<getresuid>(2), B<getuid>(2), B<setfsgid>(2), B<setfsuid>(2), "
"B<setreuid>(2), B<setuid>(2), B<capabilities>(7), B<credentials>(7), "
"B<user_namespaces>(7)"

#. type: TH
#: build/C/man2/setreuid.2:46
#, no-wrap
msgid "SETREUID"
msgstr "SETREUID"

#. type: Plain text
#: build/C/man2/setreuid.2:49
msgid "setreuid, setregid - set real and/or effective user or group ID"
msgstr ""
"setreuid, setregid - 実 (real) と実効 (effective) ユーザー (グループ) ID を設"
"定する"

#. type: Plain text
#: build/C/man2/setreuid.2:55
msgid "B<int setreuid(uid_t >I<ruid>B<, uid_t >I<euid>B<);>"
msgstr "B<int setreuid(uid_t >I<ruid>B<, uid_t >I<euid>B<);>"

#. type: Plain text
#: build/C/man2/setreuid.2:57
msgid "B<int setregid(gid_t >I<rgid>B<, gid_t >I<egid>B<);>"
msgstr "B<int setregid(gid_t >I<rgid>B<, gid_t >I<egid>B<);>"

#. type: Plain text
#: build/C/man2/setreuid.2:65
msgid "B<setreuid>(), B<setregid>():"
msgstr "B<setreuid>(), B<setregid>():"

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: build/C/man2/setreuid.2:71
#, no-wrap
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* Since glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man2/setreuid.2:76
msgid "B<setreuid>()  sets real and effective user IDs of the calling process."
msgstr ""
"B<setreuid>()  は呼び出し元のプロセスの実 (real) ユーザー ID と 実効 "
"(effective) ユーザー ID を設定する。"

#. type: Plain text
#: build/C/man2/setreuid.2:79
msgid ""
"Supplying a value of -1 for either the real or effective user ID forces the "
"system to leave that ID unchanged."
msgstr ""
"実ユーザー ID や実効ユーザー ID に -1 を与えた場合、 システムはその ID を変更"
"しない。"

#. type: Plain text
#: build/C/man2/setreuid.2:82
msgid ""
"Unprivileged processes may only set the effective user ID to the real user "
"ID, the effective user ID, or the saved set-user-ID."
msgstr ""
"非特権プロセスは実効ユーザー ID を実ユーザー ID または実効ユーザー ID または "
"保存 set-user-ID にしか設定できない。"

#. type: Plain text
#: build/C/man2/setreuid.2:85
msgid ""
"Unprivileged users may only set the real user ID to the real user ID or the "
"effective user ID."
msgstr ""
"非特権ユーザーは、実ユーザー ID を実ユーザー ID または 実効ユーザー ID にしか"
"設定できない。"

#. type: Plain text
#: build/C/man2/setreuid.2:91
msgid ""
"If the real user ID is set (i.e., I<ruid> is not -1) or the effective user "
"ID is set to a value not equal to the previous real user ID, the saved set-"
"user-ID will be set to the new effective user ID."
msgstr ""
"実ユーザーID が設定されたり (I<ruid> が -1 ではない)、実効ユーザーID が前の実"
"ユーザーID と 異った値に設定された場合、保存 set-user-ID には新しい実効ユー"
"ザーID の値が設定される。"

#. type: Plain text
#: build/C/man2/setreuid.2:96
msgid ""
"Completely analogously, B<setregid>()  sets real and effective group ID's of "
"the calling process, and all of the above holds with \"group\" instead of "
"\"user\"."
msgstr ""
"これと全く同様に、 B<setregid>()  は呼び出し元のプロセスの実グループ ID と実"
"効グループ ID を設定し、 上記の説明で「ユーザー」を「グループ」に読み替えたこ"
"とが成り立つ。"

#. type: Plain text
#: build/C/man2/setreuid.2:108
msgid ""
"I<Note>: there are cases where B<setreuid>()  can fail even when the caller "
"is UID 0; it is a grave security error to omit checking for a failure return "
"from B<setreuid>()."
msgstr ""
"I<注意>: 呼び出し元が UID 0 であっても B<setreuid>() が失敗する場合がある。 "
"B<setreuid>() からのリターンが失敗かどうかの確認を省略することは重大なセキュ"
"リティ上のエラーとなる。"

#. type: Plain text
#: build/C/man2/setreuid.2:151
#, fuzzy
#| msgid ""
#| "The calling process is not privileged (Linux: does not have the "
#| "B<CAP_SETUID> capability in the case of B<setreuid>(), or the "
#| "B<CAP_SETGID> capability in the case of B<setregid>())  and a change "
#| "other than (i)  swapping the effective user (group) ID with the real user "
#| "(group) ID, or (ii) setting one to the value of the other or (iii) "
#| "setting the effective user (group) ID to the value of the saved set-user-"
#| "ID (saved set-group-ID) was specified."
msgid ""
"The calling process is not privileged (on Linux, does not have the necessary "
"capability in its user namespace: B<CAP_SETUID> in the case of "
"B<setreuid>(), or B<CAP_SETGID> in the case of B<setregid>())  and a change "
"other than (i)  swapping the effective user (group) ID with the real user "
"(group) ID, or (ii) setting one to the value of the other or (iii) setting "
"the effective user (group) ID to the value of the saved set-user-ID (saved "
"set-group-ID) was specified."
msgstr ""
"呼び出し元のプロセスに特権がなく (Linux では B<setreuid>()  の場合に "
"B<CAP_SETUID> ケーパビリティ (capability) がなく、 B<setregid>()  の場合に "
"B<CAP_SETGID> ケーパビリティがない)、 以下のいずれでもない変更が指定された: "
"(i) 実効ユーザー (グループ) ID と実ユーザー (グループ) ID を入れ換える。 "
"(ii) 片方の値を他方に設定する。 (iii) 実効ユーザー (グループ) ID に保存 set-"
"user-ID (保存 set-group-ID)  の値を設定する。"

#. type: Plain text
#: build/C/man2/setreuid.2:157
msgid ""
"POSIX.1-2001, POSIX.1-2008, 4.3BSD (B<setreuid>()  and B<setregid>()  first "
"appeared in 4.2BSD)."
msgstr "POSIX.1-2001, POSIX.1-2008, 4.3BSD (B<setreuid>()  と B<setregid>()  関数コールは 4.2BSD で初めて登場した)。"

#. type: Plain text
#: build/C/man2/setreuid.2:161
msgid ""
"Setting the effective user (group) ID to the saved set-user-ID (saved set-"
"group-ID) is possible since Linux 1.1.37 (1.1.38)."
msgstr ""
"実効ユーザー (グループ) ID を保存ユーザー (グループ) ID に 設定することが、"
"Linux 1.1.37 (1.1.38) から可能になった。"

#. type: Plain text
#: build/C/man2/setreuid.2:178
msgid ""
"POSIX.1 does not specify all of the UID changes that Linux permits for an "
"unprivileged process.  For B<setreuid>(), the effective user ID can be made "
"the same as the real user ID or the saved set-user-ID, and it is unspecified "
"whether unprivileged processes may set the real user ID to the real user ID, "
"the effective user ID, or the saved set-user-ID.  For B<setregid>(), the "
"real group ID can be changed to the value of the saved set-group-ID, and the "
"effective group ID can be changed to the value of the real group ID or the "
"saved set-group-ID.  The precise details of what ID changes are permitted "
"vary across implementations."
msgstr "POSIX.1 では、 Linux が非特権プロセスに対して認めている ID の変更の全パターンを規定しているわけではない。 B<setreuid>()  では、実効ユーザー ID を実ユーザー ID もしくは保存 set-user-ID と 同じ値にすることができるが、 非特権プロセスが実ユーザー ID を実ユーザー ID、実効ユーザー ID、 保存 set-user-ID のどの値にも設定できるかは規定されていない。 B<setregid>()  では、実グループ ID を保存 set-group-ID と同じ値に変更でき、 実効グループ ID を実グループ ID や保存 set-group-ID と同じ値に変更できる。 どのような ID の変更が認められているかの正確な詳細は 実装ごとに異なる。"

#. type: Plain text
#: build/C/man2/setreuid.2:181
msgid ""
"POSIX.1 makes no specification about the effect of these calls on the saved "
"set-user-ID and saved set-group-ID."
msgstr ""
"POSIX.1 では、これらのシステムコールが保存 set-user-ID や 保存 set-group-ID "
"に与える影響については規定していない。"

#. type: Plain text
#: build/C/man2/setreuid.2:198
msgid ""
"The original Linux B<setreuid>()  and B<setregid>()  system calls supported "
"only 16-bit user and group IDs.  Subsequently, Linux 2.4 added "
"B<setreuid32>()  and B<setregid32>(), supporting 32-bit IDs.  The glibc "
"B<setreuid>()  and B<setregid>()  wrapper functions transparently deal with "
"the variations across kernel versions."
msgstr ""
"元々の Linux の B<setreuid>() と B<setregid>() システムコールは\n"
"16 ビットのグループ ID だけに対応していた。\n"
"その後、Linux 2.4 で、32 ビットの ID に対応した\n"
"B<setreuid32>() と B<setregid32>() が追加された。\n"
"glibc の B<setreuid>() と B<setregid>() のラッパー関数は\n"
"カーネルバージョンによるこの違いを吸収している。"

#. type: Plain text
#: build/C/man2/setreuid.2:214
msgid ""
"At the kernel level, user IDs and group IDs are a per-thread attribute.  "
"However, POSIX requires that all threads in a process share the same "
"credentials.  The NPTL threading implementation handles the POSIX "
"requirements by providing wrapper functions for the various system calls "
"that change process UIDs and GIDs.  These wrapper functions (including those "
"for B<setreuid>()  and B<setregid>())  employ a signal-based technique to "
"ensure that when one thread changes credentials, all of the other threads in "
"the process also change their credentials.  For details, see B<nptl>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/setreuid.2:224
msgid ""
"B<getgid>(2), B<getuid>(2), B<seteuid>(2), B<setgid>(2), B<setresuid>(2), "
"B<setuid>(2), B<capabilities>(7), B<credentials>(7), B<user_namespaces>(7)"
msgstr "B<getgid>(2), B<getuid>(2), B<seteuid>(2), B<setgid>(2), B<setresuid>(2), B<setuid>(2), B<capabilities>(7), B<credentials>(7), B<user_namespaces>(7)"

#. type: TH
#: build/C/man2/setsid.2:31
#, no-wrap
msgid "SETSID"
msgstr "SETSID"

#. type: Plain text
#: build/C/man2/setsid.2:34
msgid "setsid - creates a session and sets the process group ID"
msgstr "setsid - セッション (session) を作成し、プロセスグループ ID を設定する"

#. type: Plain text
#: build/C/man2/setsid.2:41
msgid "B<pid_t setsid(void);>"
msgstr "B<pid_t setsid(void);>"

#. type: Plain text
#: build/C/man2/setsid.2:52
msgid ""
"B<setsid>()  creates a new session if the calling process is not a process "
"group leader.  The calling process is the leader of the new session (i.e., "
"its session ID is made the same as its process ID).  The calling process "
"also becomes the process group leader of a new process group in the session "
"(i.e., its process group ID is made the same as its process ID)."
msgstr ""
"B<setsid>() は、 呼び出したプロセスがプロセスグループリーダー (process group "
"leader) でなければ、 新しいセッションを作成する。 呼び出したプロセスは、 新し"
"いセッションのリーダーとなる (すなわち、そのセッション ID がプロセス ID と同"
"じ値になる)。 また、呼び出したプロセスは、 そのセッションの新しいプロセスグ"
"ループのプロセスグループリーダーにもなる (すなわち、プロセスグループ ID がプ"
"ロセス ID と同じ値になる)。"

#. type: Plain text
#: build/C/man2/setsid.2:55
msgid ""
"The calling process will be the only process in the new process group and in "
"the new session."
msgstr "呼び出したプロセスは、 新しいプロセスグループと新しいセッションの唯一のプロセスとなる。"

#. type: Plain text
#: build/C/man2/setsid.2:59
msgid ""
"Initially, the new session has no controlling terminal.  For details of how "
"a session acquires a controlling terminal, see B<credentials>(7)."
msgstr "最初は、新しいセッションは制御端末を持たない。セッションが制御端末を獲得する方法については B<credentials>(7) を参照。"

#. type: Plain text
#: build/C/man2/setsid.2:66
msgid ""
"On success, the (new) session ID of the calling process is returned.  On "
"error, I<(pid_t)\\ -1> is returned, and I<errno> is set to indicate the "
"error."
msgstr ""
"成功すると、呼び出したプロセスの (新しい) セッション ID が返される。 エラーの"
"場合は、 I<(pid_t)\\ -1> が返され、 I<errno> にエラーを示す値が設定される。"

#. type: Plain text
#: build/C/man2/setsid.2:73
msgid ""
"The process group ID of any process equals the PID of the calling process.  "
"Thus, in particular, B<setsid>()  fails if the calling process is already a "
"process group leader."
msgstr ""
"いずれかのプロセスのプロセスグループ ID が、 呼び出したプロセスの PID と等し"
"い。 これは、呼び出したプロセスが既にプロセスリーダーの場合には B<setsid>()  "
"は失敗することを意味する。"

#. type: Plain text
#: build/C/man2/setsid.2:81
msgid ""
"A child created via B<fork>(2)  inherits its parent's session ID.  The "
"session ID is preserved across an B<execve>(2)."
msgstr ""
"B<fork>(2)  で作成された子プロセスは、親プロセスのセッション ID を継承する。 "
"B<execve>(2)  の前後でセッション ID は保存される。"

#. type: Plain text
#: build/C/man2/setsid.2:98
#, fuzzy
#| msgid ""
#| "A process group leader is a process whose process group ID equals its "
#| "PID.  Disallowing a process group leader from calling B<setsid>()  "
#| "prevents the possibility that a process group leader places itself in a "
#| "new session while other processes in the process group remain in the "
#| "original session; such a scenario would break the strict two-level "
#| "hierarchy of sessions and process groups.  In order to be sure that "
#| "B<setsid>()  will succeed, B<fork>(2)  and B<_exit>(2), and have the "
#| "child do B<setsid>()."
msgid ""
"A process group leader is a process whose process group ID equals its PID.  "
"Disallowing a process group leader from calling B<setsid>()  prevents the "
"possibility that a process group leader places itself in a new session while "
"other processes in the process group remain in the original session; such a "
"scenario would break the strict two-level hierarchy of sessions and process "
"groups.  In order to be sure that B<setsid>()  will succeed, call "
"B<fork>(2)  and have the parent B<_exit>(2), while the child (which by "
"definition can't be a process group leader) calls B<setsid>()."
msgstr ""
"プロセスグループリーダーは、 プロセスグループ ID がその PID と同じ値のプロセ"
"スである。 プロセスグループリーダーが B<setsid>() を呼び出すことを許可しない"
"と、 そのプロセスグループ内の他のプロセスを元のセッションに残したまま、 プロ"
"セスグループリーダーが自分自身を新しいセッションに入れるということができなく"
"なる。 このようなシナリオは、 セッションとプロセスグループという厳密な 2 階層"
"モデルを壊すことになる。 B<setsid>() が成功することを保証するには、 "
"B<fork>(2) と B<_exit>(2) を行い、 その子プロセスに B<setsid>() をさせればよ"
"い。"

#. type: Plain text
#: build/C/man2/setsid.2:105
msgid ""
"If a session has a controlling terminal, and the B<CLOCAL> flag for that "
"terminal is not set, and a terminal hangup occurs, then the session leader "
"is sent a B<SIGHUP> signal."
msgstr "セッションが制御端末を持っていて、その端末に対して B<CLOCAL> フラグが設定されておらず、端末のハングアップが起きた場合、 セッションリーダーに B<SIGHUP> シグナルが送られる。"

#. type: Plain text
#: build/C/man2/setsid.2:110
msgid ""
"If a process that is a session leader terminates, then a B<SIGHUP> signal is "
"sent to each process in the foreground process group of the controlling "
"terminal."
msgstr "セッションリーダーのプロセスが終了した場合には、その制御端末のフォアグランドのプロセスグループに所属する各プロセスに B<SIGHUP> シグナルが送られる。"

#. type: Plain text
#: build/C/man2/setsid.2:118
msgid ""
"B<setsid>(1), B<getsid>(2), B<setpgid>(2), B<setpgrp>(2), B<tcgetsid>(3), "
"B<credentials>(7), B<sched>(7)"
msgstr ""
"B<setsid>(1), B<getsid>(2), B<setpgid>(2), B<setpgrp>(2), B<tcgetsid>(3), "
"B<credentials>(7)"

#. type: TH
#: build/C/man2/setuid.2:31
#, no-wrap
msgid "SETUID"
msgstr "SETUID"

#. type: Plain text
#: build/C/man2/setuid.2:34
msgid "setuid - set user identity"
msgstr "setuid - ユーザー識別 (identity) を設定する"

#. type: Plain text
#: build/C/man2/setuid.2:40
msgid "B<int setuid(uid_t >I<uid>B<);>"
msgstr "B<int setuid(uid_t >I<uid>B<);>"

#. type: Plain text
#: build/C/man2/setuid.2:48
#, fuzzy
#| msgid ""
#| "B<setuid>()  sets the effective user ID of the calling process.  If the "
#| "effective UID of the caller is root, the real UID and saved set-user-ID "
#| "are also set."
msgid ""
"B<setuid>()  sets the effective user ID of the calling process.  If the "
"calling process is privileged (more precisely: if the process has the "
"B<CAP_SETUID> capability in its user namespace), the real UID and saved set-"
"user-ID are also set."
msgstr ""
"B<setuid>()  は呼び出し元のプロセスの実効 (effective) ユーザー ID を設定す"
"る。 もし呼び出し元プロセスの実効 UID が root ならば、 実 (real) UID と保存 "
"(saved) set-user-ID も設定される。"

#. type: Plain text
#: build/C/man2/setuid.2:57
msgid ""
"Under Linux, B<setuid>()  is implemented like the POSIX version with the "
"B<_POSIX_SAVED_IDS> feature.  This allows a set-user-ID (other than root) "
"program to drop all of its user privileges, do some un-privileged work, and "
"then reengage the original effective user ID in a secure manner."
msgstr ""
"Linux では、 B<setuid>()  は B<_POSIX_SAVED_IDS> をもった POSIX 版のように実"
"装されている。 これは (ルート以外の) set-user-ID プログラムにそのユーザーの特"
"権を 全て与え、特権の必要ない仕事をし、本来の実効ユーザー ID に 安全な方法で"
"再び戻すことを許す。"

#. type: Plain text
#: build/C/man2/setuid.2:66
msgid ""
"If the user is root or the program is set-user-ID-root, special care must be "
"taken: B<setuid>()  checks the effective user ID of the caller and if it is "
"the superuser, all process-related user ID's are set to I<uid>.  After this "
"has occurred, it is impossible for the program to regain root privileges."
msgstr "ユーザーが root またはプログラムが root に set-user-ID されているならば、 特別の注意が払われる。 B<setuid>() は呼び出し者の実効ユーザー ID をチェックし、 それがスーパーユーザーならば、 プロセスに関連する全てのユーザー ID に I<uid> を設定する。 これが行なわれた後にはプログラムが再びルートの特権を得ることはできない。"

#. type: Plain text
#: build/C/man2/setuid.2:73
msgid ""
"Thus, a set-user-ID-root program wishing to temporarily drop root "
"privileges, assume the identity of an unprivileged user, and then regain "
"root privileges afterward cannot use B<setuid>().  You can accomplish this "
"with B<seteuid>(2)."
msgstr ""
"したがって、set-user-ID-root プログラムで、一時的にルート特権を解除し、 非特"
"権ユーザーであるかのように振舞い、後でルート権限をもう一度得ようと する場合に"
"は、 B<setuid>()  を使うことができない。その場合には、 B<seteuid>(2)  を使う"
"必要がある。"

#. type: Plain text
#: build/C/man2/setuid.2:85
msgid ""
"I<Note>: there are cases where B<setuid>()  can fail even when the caller is "
"UID 0; it is a grave security error to omit checking for a failure return "
"from B<setuid>()."
msgstr ""
"I<注意>: 呼び出し元が UID 0 であっても B<setuid>() が失敗する場合がある。 "
"B<setuid>() からのリターンが失敗かどうかの確認を省略することは重大なセキュリ"
"ティ上のエラーとなる。"

#. type: Plain text
#: build/C/man2/setuid.2:93
msgid ""
"The call would change the caller's real UID (i.e., I<uid> does not match the "
"caller's real UID), but there was a temporary failure allocating the "
"necessary kernel data structures."
msgstr ""
"この呼び出しで呼び出し元の実 UID が変更されるはずだったが (つまり、 I<uid> が"
"呼び出し元の実 UID と一致していない)、 必要なカーネルのデータ構造体の割り当て"
"で一時的な失敗があった。"

#. type: Plain text
#: build/C/man2/setuid.2:108
msgid ""
"I<uid> does not match the real user ID of the caller and this call would "
"bring the number of processes belonging to the real user ID I<uid> over the "
"caller's B<RLIMIT_NPROC> resource limit.  Since Linux 3.1, this error case "
"no longer occurs (but robust applications should check for this error); see "
"the description of B<EAGAIN> in B<execve>(2)."
msgstr ""
"I<uid> は呼び出し元の実 UID と一致しておらず、 この呼び出しで実ユーザー ID "
"I<ruid> に属するプロセス数が呼び出し元の B<RLIMIT_NPROC> リソース上限を超過す"
"るところであった。 Linux 3.1 以降では、このエラーはもはや発生することはない "
"(しかし、堅牢性が求められるアプリケーションではこのエラーを確認すべきであ"
"る)。 B<execve>(2) の B<EAGAIN> の説明を参照。"

#. type: Plain text
#: build/C/man2/setuid.2:113
msgid "The user ID specified in I<uid> is not valid in this user namespace."
msgstr ""
"I<uid> で指定されたユーザー ID がこのユーザー名前空間では有効ではない。"

#. type: Plain text
#: build/C/man2/setuid.2:120
msgid ""
"The user is not privileged (Linux: does not have the B<CAP_SETUID> "
"capability in its user namespace) and I<uid> does not match the real UID or "
"saved set-user-ID of the calling process."
msgstr "ユーザーが特権を持たず (Linux ではそのユーザー名前空間で B<CAP_SETUID> ケーパビリティ (capability) を持たず)、 I<uid> が呼び出し元プロセスの実 UID または保存 set-user-ID と一致しない。"

#.  SVr4 documents an additional EINVAL error condition.
#. type: Plain text
#: build/C/man2/setuid.2:125
msgid ""
"POSIX.1-2001, POSIX.1-2008, SVr4.  Not quite compatible with the 4.4BSD "
"call, which sets all of the real, saved, and effective user IDs."
msgstr "POSIX.1-2001, POSIX.1-2008, SVr4.  4.4BSD のコールとは完全な互換性はない、 BSD のコールは実 (real)、保存 (saved)、実効 (effective) ID の全てを設定する。"

#. type: Plain text
#: build/C/man2/setuid.2:133
msgid ""
"Linux has the concept of the filesystem user ID, normally equal to the "
"effective user ID.  The B<setuid>()  call also sets the filesystem user ID "
"of the calling process.  See B<setfsuid>(2)."
msgstr ""
"Linux はファイルシステムユーザー ID の概念を持つ。\n"
"通常、これは実効ユーザー ID に等しい。 \n"
"B<setuid>()  コールは呼び出し元のプロセスの\n"
"ファイルシステムユーザー ID も設定する。 \n"
"B<setfsuid>(2) も参照すること。"

#. type: Plain text
#: build/C/man2/setuid.2:138
msgid ""
"If I<uid> is different from the old effective UID, the process will be "
"forbidden from leaving core dumps."
msgstr ""
"I<uid> が前の実効 UID と異っていた場合、\n"
"プロセスはコアダンプすることを禁止される。"

#. type: Plain text
#: build/C/man2/setuid.2:149
msgid ""
"The original Linux B<setuid>()  system call supported only 16-bit user IDs.  "
"Subsequently, Linux 2.4 added B<setuid32>()  supporting 32-bit IDs.  The "
"glibc B<setuid>()  wrapper function transparently deals with the variation "
"across kernel versions."
msgstr ""
"元々の Linux の B<setuid>() システムコールは\n"
"16 ビットのグループ ID だけに対応していた。\n"
"その後、Linux 2.4 で、32 ビットの ID に対応した\n"
"B<setuid32>() が追加された。\n"
"glibc の B<setuid>() のラッパー関数は\n"
"カーネルバージョンによるこの違いを吸収している。"

#. type: Plain text
#: build/C/man2/setuid.2:163
msgid ""
"At the kernel level, user IDs and group IDs are a per-thread attribute.  "
"However, POSIX requires that all threads in a process share the same "
"credentials.  The NPTL threading implementation handles the POSIX "
"requirements by providing wrapper functions for the various system calls "
"that change process UIDs and GIDs.  These wrapper functions (including the "
"one for B<setuid>())  employ a signal-based technique to ensure that when "
"one thread changes credentials, all of the other threads in the process also "
"change their credentials.  For details, see B<nptl>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/setuid.2:171
msgid ""
"B<getuid>(2), B<seteuid>(2), B<setfsuid>(2), B<setreuid>(2), "
"B<capabilities>(7), B<credentials>(7), B<user_namespaces>(7)"
msgstr ""
"B<getuid>(2), B<seteuid>(2), B<setfsuid>(2), B<setreuid>(2), "
"B<capabilities>(7), B<credentials>(7), B<user_namespaces>(7)"

#. type: TH
#: build/C/man7/sysvipc.7:25
#, no-wrap
msgid "SVIPC"
msgstr "SVIPC"

#. type: TH
#: build/C/man7/sysvipc.7:25
#, no-wrap
msgid "2020-04-11"
msgstr "2020-04-11"

#. type: Plain text
#: build/C/man7/sysvipc.7:28
msgid "sysvipc - System V interprocess communication mechanisms"
msgstr "sysvipc - System V プロセス間通信機構"

#. type: Plain text
#: build/C/man7/sysvipc.7:33
msgid ""
"System V IPC is the name given to three interprocess communication "
"mechanisms that are widely available on UNIX systems: message queues, "
"semaphore, and shared memory."
msgstr ""

#. type: SS
#: build/C/man7/sysvipc.7:33
#, no-wrap
msgid "Message queues"
msgstr "メッセージキュー"

#. type: Plain text
#: build/C/man7/sysvipc.7:39
msgid ""
"System V message queues allow data to be exchanged in units called "
"messages.  Each messages can have an associated priority, POSIX message "
"queues provide an alternative API for achieving the same result; see "
"B<mq_overview>(7)."
msgstr ""

#. type: Plain text
#: build/C/man7/sysvipc.7:41
msgid "The System V message queue API consists of the following system calls:"
msgstr ""

#. type: TP
#: build/C/man7/sysvipc.7:41
#, no-wrap
msgid "B<msgget>(2)"
msgstr "B<msgget>(2)"

#. type: Plain text
#: build/C/man7/sysvipc.7:45
msgid ""
"Create a new message queue or obtain the ID of an existing message queue.  "
"This call returns an identifier that is used in the remaining APIs."
msgstr ""

#. type: TP
#: build/C/man7/sysvipc.7:45
#, no-wrap
msgid "B<msgsnd>(2)"
msgstr "B<msgsnd>(2)"

#. type: Plain text
#: build/C/man7/sysvipc.7:48
#, fuzzy
#| msgid "Message queues"
msgid "Add a message to a queue."
msgstr "メッセージキュー"

#. type: TP
#: build/C/man7/sysvipc.7:48
#, no-wrap
msgid "B<msgrcv>(2)"
msgstr "B<msgrcv>(2)"

#. type: Plain text
#: build/C/man7/sysvipc.7:51
msgid "Remove a message from a queue."
msgstr ""

#. type: TP
#: build/C/man7/sysvipc.7:51
#, no-wrap
msgid "B<msgctl>(2)"
msgstr "B<msgctl>(2)"

#. type: Plain text
#: build/C/man7/sysvipc.7:55
msgid "Perform various control operations on a queue, including deletion."
msgstr ""

#. type: SS
#: build/C/man7/sysvipc.7:55
#, no-wrap
msgid "Semaphore sets"
msgstr "セマフォー集合"

#. type: Plain text
#: build/C/man7/sysvipc.7:62
msgid ""
"System V semaphores allow processes to synchronize their actions System V "
"semaphores are allocated in groups called sets; each semaphore in a set is a "
"counting semaphore.  POSIX semaphores provide an alternative API for "
"achieving the same result; see B<sem_overview>(7)."
msgstr ""

#. type: Plain text
#: build/C/man7/sysvipc.7:64
msgid "The System V semaphore API consists of the following system calls:"
msgstr ""

#. type: TP
#: build/C/man7/sysvipc.7:64
#, no-wrap
msgid "B<semget>(2)"
msgstr "B<semget>(2)"

#. type: Plain text
#: build/C/man7/sysvipc.7:68
msgid ""
"Create a new set or obtain the ID of an existing set.  This call returns an "
"identifier that is used in the remaining APIs."
msgstr ""

#. type: TP
#: build/C/man7/sysvipc.7:68
#, no-wrap
msgid "B<semop>(2)"
msgstr "B<semop>(2)"

#. type: Plain text
#: build/C/man7/sysvipc.7:71
msgid "Perform operations on the semaphores in a set."
msgstr ""

#. type: TP
#: build/C/man7/sysvipc.7:71
#, no-wrap
msgid "B<semctl>(2)"
msgstr "B<semctl>(2)"

#. type: Plain text
#: build/C/man7/sysvipc.7:75
msgid "Perform various control operations on a set, including deletion."
msgstr ""

#. type: SS
#: build/C/man7/sysvipc.7:75
#, no-wrap
msgid "Shared memory segments"
msgstr "共有メモリーセグメント"

#. type: Plain text
#: build/C/man7/sysvipc.7:80
msgid ""
"System V shared memory allows processes to share a region a memory (a "
"\"segment\").  POSIX shared memory is an alternative API for achieving the "
"same result; see B<shm_overview>(7)."
msgstr ""

#. type: Plain text
#: build/C/man7/sysvipc.7:82
msgid "The System V shared memory API consists of the following system calls:"
msgstr ""

#. type: TP
#: build/C/man7/sysvipc.7:82
#, no-wrap
msgid "B<shmget>(2)"
msgstr "B<shmget>(2)"

#. type: Plain text
#: build/C/man7/sysvipc.7:86
msgid ""
"Create a new segment or obtain the ID of an existing segment.  This call "
"returns an identifier that is used in the remaining APIs."
msgstr ""

#. type: TP
#: build/C/man7/sysvipc.7:86
#, no-wrap
msgid "B<shmat>(2)"
msgstr "B<shmat>(2)"

#. type: Plain text
#: build/C/man7/sysvipc.7:90
#, fuzzy
#| msgid ""
#| "One of the arguments specified an address outside the calling program's "
#| "address space."
msgid ""
"Attach an existing shared memory object into the calling process's address "
"space."
msgstr ""
"指定した引数のどれかが、呼び出したプログラムのアドレス空間の外の アドレスで"
"ある。"

#. type: TP
#: build/C/man7/sysvipc.7:90
#, no-wrap
msgid "B<shmdt>(2)"
msgstr "B<shmdt>(2)"

#. type: Plain text
#: build/C/man7/sysvipc.7:93
#, fuzzy
#| msgid ""
#| "One of the arguments specified an address outside the calling program's "
#| "address space."
msgid "Detach a segment from the calling process's address space."
msgstr ""
"指定した引数のどれかが、呼び出したプログラムのアドレス空間の外の アドレスで"
"ある。"

#. type: TP
#: build/C/man7/sysvipc.7:93
#, no-wrap
msgid "B<shmctl>(2)"
msgstr "B<shmctl>(2)"

#. type: Plain text
#: build/C/man7/sysvipc.7:97
msgid "Perform various control operations on a segment, including deletion."
msgstr ""

#. type: SS
#: build/C/man7/sysvipc.7:97
#, no-wrap
msgid "IPC namespaces"
msgstr "IPC 名前空間"

#. type: Plain text
#: build/C/man7/sysvipc.7:101
msgid ""
"For a discussion of the interaction of System V IPC objects and IPC "
"namespaces, see B<ipc_namespaces>(7)."
msgstr "System V IPC オブジェクトと IPC 名前空間の相互の影響に関する議論は B<ipc_namespaces>(7) を参照。"

#. type: Plain text
#: build/C/man7/sysvipc.7:120
msgid ""
"B<ipcmk>(1), B<ipcrm>(1), B<ipcs>(1), B<lsipc>(1), B<ipc>(2), B<msgctl>(2), "
"B<msgget>(2), B<msgrcv>(2), B<msgsnd>(2), B<semctl>(2), B<semget>(2), "
"B<semop>(2), B<shmat>(2), B<shmctl>(2), B<shmdt>(2), B<shmget>(2), "
"B<ftok>(3), B<ipc_namespaces>(7)"
msgstr "B<ipcmk>(1), B<ipcrm>(1), B<ipcs>(1), B<lsipc>(1), B<ipc>(2), B<msgctl>(2), B<msgget>(2), B<msgrcv>(2), B<msgsnd>(2), B<semctl>(2), B<semget>(2), B<semop>(2), B<shmat>(2), B<shmctl>(2), B<shmdt>(2), B<shmget>(2), B<ftok>(3), B<ipc_namespaces>(7)"

#. type: TH
#: build/C/man3/ulimit.3:27
#, no-wrap
msgid "ULIMIT"
msgstr "ULIMIT"

#. type: Plain text
#: build/C/man3/ulimit.3:30
msgid "ulimit - get and set user limits"
msgstr "ulimit - ユーザー制限を取得・設定する"

#. type: Plain text
#: build/C/man3/ulimit.3:32
msgid "B<#include E<lt>ulimit.hE<gt>>"
msgstr "B<#include E<lt>ulimit.hE<gt>>"

#. type: Plain text
#: build/C/man3/ulimit.3:34
msgid "B<long ulimit(int >I<cmd>B<, long >I<newlimit>B<);>"
msgstr "B<long ulimit(int >I<cmd>B<, long >I<newlimit>B<);>"

#. type: Plain text
#: build/C/man3/ulimit.3:46
msgid ""
"Warning: this routine is obsolete.  Use B<getrlimit>(2), B<setrlimit>(2), "
"and B<sysconf>(3)  instead.  For the shell command B<ulimit>(), see "
"B<bash>(1)."
msgstr ""
"注意: このルーチンは古い。 代わりに B<getrlimit>(2), B<setrlimit>(2), "
"B<sysconf>(3)  などを用いること。 シェルコマンドとしての B<ulimit>()  につい"
"ては、 B<bash>(1)  を見ること。"

#. type: Plain text
#: build/C/man3/ulimit.3:53
msgid ""
"The B<ulimit>()  call will get or set some limit for the calling process.  "
"The I<cmd> argument can have one of the following values."
msgstr ""
"B<ulimit>()  は呼び出し元のプロセスに関する制限のいくつかを取得・設定する。 "
"I<cmd> 引数には、以下の値のうちのどれか一つを与えることができる。"

#. type: TP
#: build/C/man3/ulimit.3:53
#, no-wrap
msgid "B<UL_GETFSIZE>"
msgstr "B<UL_GETFSIZE>"

#. type: Plain text
#: build/C/man3/ulimit.3:56
msgid "Return the limit on the size of a file, in units of 512 bytes."
msgstr "ファイルサイズに関する制限を返す。単位は 512 バイト。"

#. type: TP
#: build/C/man3/ulimit.3:56
#, no-wrap
msgid "B<UL_SETFSIZE>"
msgstr "B<UL_SETFSIZE>"

#. type: Plain text
#: build/C/man3/ulimit.3:59
msgid "Set the limit on the size of a file."
msgstr "ファイルサイズに関する制限を設定する。"

#. type: TP
#: build/C/man3/ulimit.3:59
#, no-wrap
msgid "B<3>"
msgstr "B<3>"

#. type: Plain text
#: build/C/man3/ulimit.3:63
msgid ""
"(Not implemented for Linux.)  Return the maximum possible address of the "
"data segment."
msgstr ""
"(Linux では実装されていない)  データセグメントで指定できるアドレスの最大値を"
"返す。"

#. type: TP
#: build/C/man3/ulimit.3:63
#, no-wrap
msgid "B<4>"
msgstr "B<4>"

#. type: Plain text
#: build/C/man3/ulimit.3:67
msgid ""
"(Implemented but no symbolic constant provided.)  Return the maximum number "
"of files that the calling process can open."
msgstr ""
"(実装されているが、対応するシンボリックな定数は存在しない)  プロセスがオープ"
"ンできるファイル数の最大値を返す。"

#. type: Plain text
#: build/C/man3/ulimit.3:74
msgid ""
"On success, B<ulimit>()  returns a nonnegative value.  On error, -1 is "
"returned, and I<errno> is set appropriately."
msgstr ""
"成功すると B<ulimit>()  は 0 または正の値を返す。 エラーが生じると -1 を返"
"し、 I<errno> を適切な値に設定する。"

#. type: Plain text
#: build/C/man3/ulimit.3:78
msgid "An unprivileged process tried to increase a limit."
msgstr "非特権プロセスが制限値を増加させようとした。"

#. type: tbl table
#: build/C/man3/ulimit.3:88
#, no-wrap
msgid "B<ulimit>()"
msgstr "B<ulimit>()"

#. type: Plain text
#: build/C/man3/ulimit.3:96
msgid "SVr4, POSIX.1-2001.  POSIX.1-2008 marks B<ulimit>()  as obsolete."
msgstr ""
"SVr4, POSIX.1-2001.  POSIX.1-2008 は B<ulimit>()  を廃止予定としている。"

#. type: Plain text
#: build/C/man3/ulimit.3:101
msgid "B<bash>(1), B<getrlimit>(2), B<setrlimit>(2), B<sysconf>(3)"
msgstr "B<bash>(1), B<getrlimit>(2), B<setrlimit>(2), B<sysconf>(3)"

#. type: TH
#: build/C/man2/seccomp.2:28
#, no-wrap
msgid "SECCOMP"
msgstr "SECCOMP"

#. type: Plain text
#: build/C/man2/seccomp.2:31
msgid "seccomp - operate on Secure Computing state of the process"
msgstr ""

#.  Kees Cook noted: Anything that uses SECCOMP_RET_TRACE returns will
#.                   need <sys/ptrace.h>
#. type: Plain text
#: build/C/man2/seccomp.2:40
#, no-wrap
msgid ""
"B<#include E<lt>linux/seccomp.hE<gt>>\n"
"B<#include E<lt>linux/filter.hE<gt>>\n"
"B<#include E<lt>linux/audit.hE<gt>>\n"
"B<#include E<lt>linux/signal.hE<gt>>\n"
"B<#include E<lt>sys/ptrace.hE<gt>>\n"
msgstr ""
"B<#include E<lt>linux/seccomp.hE<gt>>\n"
"B<#include E<lt>linux/filter.hE<gt>>\n"
"B<#include E<lt>linux/audit.hE<gt>>\n"
"B<#include E<lt>linux/signal.hE<gt>>\n"
"B<#include E<lt>sys/ptrace.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/seccomp.2:43
#, no-wrap
msgid "B<int seccomp(unsigned int >I<operation>B<, unsigned int >I<flags>B<, void *>I<args>B<);>\n"
msgstr "B<int seccomp(unsigned int >I<operation>B<, unsigned int >I<flags>B<, void *>I<args>B<);>\n"

#. type: Plain text
#: build/C/man2/seccomp.2:49
msgid ""
"The B<seccomp>()  system call operates on the Secure Computing (seccomp) "
"state of the calling process."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:53
msgid "Currently, Linux supports the following I<operation> values:"
msgstr ""

#. type: TP
#: build/C/man2/seccomp.2:53
#, no-wrap
msgid "B<SECCOMP_SET_MODE_STRICT>"
msgstr "B<SECCOMP_SET_MODE_STRICT>"

#. type: Plain text
#: build/C/man2/seccomp.2:69
msgid ""
"The only system calls that the calling thread is permitted to make are "
"B<read>(2), B<write>(2), B<_exit>(2)  (but not B<exit_group>(2)), and "
"B<sigreturn>(2).  Other system calls result in the delivery of a B<SIGKILL> "
"signal.  Strict secure computing mode is useful for number-crunching "
"applications that may need to execute untrusted byte code, perhaps obtained "
"by reading from a pipe or socket."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:96
msgid ""
"Note that although the calling thread can no longer call B<sigprocmask>(2), "
"it can use B<sigreturn>(2)  to block all signals apart from B<SIGKILL> and "
"B<SIGSTOP>.  This means that B<alarm>(2)  (for example) is not sufficient "
"for restricting the process's execution time.  Instead, to reliably "
"terminate the process, B<SIGKILL> must be used.  This can be done by using "
"B<timer_create>(2)  with B<SIGEV_SIGNAL> and I<sigev_signo> set to "
"B<SIGKILL>, or by using B<setrlimit>(2)  to set the hard limit for "
"B<RLIMIT_CPU>."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:100
msgid ""
"This operation is available only if the kernel is configured with "
"B<CONFIG_SECCOMP> enabled."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:106
msgid "The value of I<flags> must be 0, and I<args> must be NULL."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:108
msgid "This operation is functionally identical to the call:"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:112
#, no-wrap
msgid "prctl(PR_SET_SECCOMP, SECCOMP_MODE_STRICT);\n"
msgstr "prctl(PR_SET_SECCOMP, SECCOMP_MODE_STRICT);\n"

#. type: TP
#: build/C/man2/seccomp.2:114
#, no-wrap
msgid "B<SECCOMP_SET_MODE_FILTER>"
msgstr "B<SECCOMP_SET_MODE_FILTER>"

#. type: Plain text
#: build/C/man2/seccomp.2:129
msgid ""
"The system calls allowed are defined by a pointer to a Berkeley Packet "
"Filter (BPF) passed via I<args>.  This argument is a pointer to a I<struct\\ "
"sock_fprog>; it can be designed to filter arbitrary system calls and system "
"call arguments.  If the filter is invalid, B<seccomp>()  fails, returning "
"B<EINVAL> in I<errno>."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:141
msgid ""
"If B<fork>(2)  or B<clone>(2)  is allowed by the filter, any child processes "
"will be constrained to the same system call filters as the parent.  If "
"B<execve>(2)  is allowed, the existing filters will be preserved across a "
"call to B<execve>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:151
msgid ""
"In order to use the B<SECCOMP_SET_MODE_FILTER> operation, either the calling "
"thread must have the B<CAP_SYS_ADMIN> capability in its user namespace, or "
"the thread must already have the I<no_new_privs> bit set.  If that bit was "
"not already set by an ancestor of this thread, the thread must make the "
"following call:"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:155
#, no-wrap
msgid "prctl(PR_SET_NO_NEW_PRIVS, 1);\n"
msgstr "prctl(PR_SET_NO_NEW_PRIVS, 1);\n"

#. type: Plain text
#: build/C/man2/seccomp.2:176
msgid ""
"Otherwise, the B<SECCOMP_SET_MODE_FILTER> operation fails and returns "
"B<EACCES> in I<errno>.  This requirement ensures that an unprivileged "
"process cannot apply a malicious filter and then invoke a set-user-ID or "
"other privileged program using B<execve>(2), thus potentially compromising "
"that program.  (Such a malicious filter might, for example, cause an attempt "
"to use B<setuid>(2)  to set the caller's user IDs to nonzero values to "
"instead return 0 without actually making the system call.  Thus, the program "
"might be tricked into retaining superuser privileges in circumstances where "
"it is possible to influence it to do dangerous things because it did not "
"actually drop privileges.)"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:184
msgid ""
"If B<prctl>(2)  or B<seccomp>()  is allowed by the attached filter, further "
"filters may be added.  This will increase evaluation time, but allows for "
"further reduction of the attack surface during execution of a thread."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:190
msgid ""
"The B<SECCOMP_SET_MODE_FILTER> operation is available only if the kernel is "
"configured with B<CONFIG_SECCOMP_FILTER> enabled."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:194
msgid ""
"When I<flags> is 0, this operation is functionally identical to the call:"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:198
#, no-wrap
msgid "prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, args);\n"
msgstr "prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, args);\n"

#. type: Plain text
#: build/C/man2/seccomp.2:204
msgid "The recognized I<flags> are:"
msgstr ""

#. type: TP
#: build/C/man2/seccomp.2:205
#, no-wrap
msgid "B<SECCOMP_FILTER_FLAG_TSYNC>"
msgstr "B<SECCOMP_FILTER_FLAG_TSYNC>"

#. type: Plain text
#: build/C/man2/seccomp.2:213
msgid ""
"When adding a new filter, synchronize all other threads of the calling "
"process to the same seccomp filter tree.  A \"filter tree\" is the ordered "
"list of filters attached to a thread.  (Attaching identical filters in "
"separate B<seccomp>()  calls results in different filters from this "
"perspective.)"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:221
msgid ""
"If any thread cannot synchronize to the same filter tree, the call will not "
"attach the new seccomp filter, and will fail, returning the first thread ID "
"found that cannot synchronize.  Synchronization will fail if another thread "
"in the same process is in B<SECCOMP_MODE_STRICT> or if it has attached new "
"seccomp filters to itself, diverging from the calling thread's filter tree."
msgstr ""

#. type: TP
#: build/C/man2/seccomp.2:221
#, no-wrap
msgid "B<SECCOMP_FILTER_FLAG_LOG> (since Linux 4.14)"
msgstr "B<SECCOMP_FILTER_FLAG_LOG> (Linux 4.14 以降)"

#.  commit e66a39977985b1e69e17c4042cb290768eca9b02
#. type: Plain text
#: build/C/man2/seccomp.2:231
msgid ""
"All filter return actions except B<SECCOMP_RET_ALLOW> should be logged.  An "
"administrator may override this filter flag by preventing specific actions "
"from being logged via the I</proc/sys/kernel/seccomp/actions_logged> file."
msgstr ""

#. type: TP
#: build/C/man2/seccomp.2:231
#, no-wrap
msgid "B<SECCOMP_FILTER_FLAG_SPEC_ALLOW> (since Linux 4.17)"
msgstr "B<SECCOMP_FILTER_FLAG_SPEC_ALLOW> (Linux 4.17 以降)"

#.  commit 00a02d0c502a06d15e07b857f8ff921e3e402675
#. type: Plain text
#: build/C/man2/seccomp.2:235
msgid "Disable Speculative Store Bypass mitigation."
msgstr ""

#. type: TP
#: build/C/man2/seccomp.2:236
#, no-wrap
msgid "B<SECCOMP_GET_ACTION_AVAIL> (since Linux 4.14)"
msgstr "B<SECCOMP_GET_ACTION_AVAIL> (Linux 4.14 以降)"

#.  commit d612b1fd8010d0d67b5287fe146b8b55bcbb8655
#. type: Plain text
#: build/C/man2/seccomp.2:244
msgid ""
"Test to see if an action is supported by the kernel.  This operation is "
"helpful to confirm that the kernel knows of a more recently added filter "
"return action since the kernel treats all unknown actions as "
"B<SECCOMP_RET_KILL_PROCESS>."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:250
msgid ""
"The value of I<flags> must be 0, and I<args> must be a pointer to an "
"unsigned 32-bit filter return action."
msgstr ""

#. type: SS
#: build/C/man2/seccomp.2:250
#, no-wrap
msgid "Filters"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:255
msgid ""
"When adding filters via B<SECCOMP_SET_MODE_FILTER>, I<args> points to a "
"filter program:"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:263
#, no-wrap
msgid ""
"struct sock_fprog {\n"
"    unsigned short      len;    /* Number of BPF instructions */\n"
"    struct sock_filter *filter; /* Pointer to array of\n"
"                                   BPF instructions */\n"
"};\n"
msgstr ""
"struct sock_fprog {\n"
"    unsigned short      len;    /* Number of BPF instructions */\n"
"    struct sock_filter *filter; /* Pointer to array of\n"
"                                   BPF instructions */\n"
"};\n"

#. type: Plain text
#: build/C/man2/seccomp.2:267
msgid "Each program must contain one or more BPF instructions:"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:276
#, no-wrap
msgid ""
"struct sock_filter {            /* Filter block */\n"
"    __u16 code;                 /* Actual filter code */\n"
"    __u8  jt;                   /* Jump true */\n"
"    __u8  jf;                   /* Jump false */\n"
"    __u32 k;                    /* Generic multiuse field */\n"
"};\n"
msgstr ""
"struct sock_filter {            /* Filter block */\n"
"    __u16 code;                 /* Actual filter code */\n"
"    __u8  jt;                   /* Jump true */\n"
"    __u8  jf;                   /* Jump false */\n"
"    __u32 k;                    /* Generic multiuse field */\n"
"};\n"

#.  Quoting Kees Cook:
#.      If BPF even allows changing the data, it's not copied back to
#.      the syscall when it runs. Anything wanting to do things like
#.      that would need to use ptrace to catch the call and directly
#.      modify the registers before continuing with the call.
#. type: Plain text
#: build/C/man2/seccomp.2:289
msgid ""
"When executing the instructions, the BPF program operates on the system call "
"information made available (i.e., use the B<BPF_ABS> addressing mode) as a "
"(read-only)  buffer of the following form:"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:299
#, no-wrap
msgid ""
"struct seccomp_data {\n"
"    int   nr;                   /* System call number */\n"
"    __u32 arch;                 /* AUDIT_ARCH_* value\n"
"                                   (see E<lt>linux/audit.hE<gt>) */\n"
"    __u64 instruction_pointer;  /* CPU instruction pointer */\n"
"    __u64 args[6];              /* Up to 6 system call arguments */\n"
"};\n"
msgstr ""
"struct seccomp_data {\n"
"    int   nr;                   /* System call number */\n"
"    __u32 arch;                 /* AUDIT_ARCH_* value\n"
"                                   (see E<lt>linux/audit.hE<gt>) */\n"
"    __u64 instruction_pointer;  /* CPU instruction pointer */\n"
"    __u64 args[6];              /* Up to 6 system call arguments */\n"
"};\n"

#. type: Plain text
#: build/C/man2/seccomp.2:311
msgid ""
"Because numbering of system calls varies between architectures and some "
"architectures (e.g., x86-64) allow user-space code to use the calling "
"conventions of multiple architectures (and the convention being used may "
"vary over the life of a process that uses B<execve>(2)  to execute binaries "
"that employ the different conventions), it is usually necessary to verify "
"the value of the I<arch> field."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:322
msgid ""
"It is strongly recommended to use an allow-list approach whenever possible "
"because such an approach is more robust and simple.  A deny-list will have "
"to be updated whenever a potentially dangerous system call is added (or a "
"dangerous flag or option if those are deny-listed), and it is often possible "
"to alter the representation of a value without altering its meaning, leading "
"to a deny-list bypass.  See also I<Caveats> below."
msgstr ""

#
#.  As noted by Dave Drysdale in a note at the end of
#.  https://lwn.net/Articles/604515/
#.      One additional detail to point out for the x32 ABI case:
#.      the syscall number gets a high bit set (__X32_SYSCALL_BIT),
#.      to mark it as an x32 call.
#.      If x32 support is included in the kernel, then __SYSCALL_MASK
#.      will have a value that is not all-ones, and this will trigger
#.      an extra instruction in system_call to mask off the extra bit,
#.      so that the syscall table indexing still works.
#. type: Plain text
#: build/C/man2/seccomp.2:344
msgid ""
"The I<arch> field is not unique for all calling conventions.  The x86-64 ABI "
"and the x32 ABI both use B<AUDIT_ARCH_X86_64> as I<arch>, and they run on "
"the same processors.  Instead, the mask B<__X32_SYSCALL_BIT> is used on the "
"system call number to tell the two ABIs apart."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:358
msgid ""
"This means that a policy must either deny all syscalls with "
"B<__X32_SYSCALL_BIT> or it must recognize syscalls with and without "
"B<__X32_SYSCALL_BIT> set.  A list of system calls to be denied based on "
"I<nr> that does not also contain I<nr> values with B<__X32_SYSCALL_BIT> set "
"can be bypassed by a malicious program that sets B<__X32_SYSCALL_BIT>."
msgstr ""

#.  commit 6365b842aae4490ebfafadfc6bb27a6d3cc54757
#. type: Plain text
#: build/C/man2/seccomp.2:380
msgid ""
"Additionally, kernels prior to Linux 5.4 incorrectly permitted I<nr> in the "
"ranges 512-547 as well as the corresponding non-x32 syscalls ORed with "
"B<__X32_SYSCALL_BIT>.  For example, I<nr> == 521 and I<nr> == (101 | "
"B<__X32_SYSCALL_BIT>)  would result in invocations of B<ptrace>(2)  with "
"potentially confused x32-vs-x86_64 semantics in the kernel.  Policies "
"intended to work on kernels before Linux 5.4 must ensure that they deny or "
"otherwise correctly handle these system calls.  On Linux 5.4 and newer, such "
"system calls will fail with the error B<ENOSYS>, without doing anything."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:394
msgid ""
"The I<instruction_pointer> field provides the address of the machine-"
"language instruction that performed the system call.  This might be useful "
"in conjunction with the use of I</proc/[pid]/maps> to perform checks based "
"on which region (mapping) of the program made the system call.  (Probably, "
"it is wise to lock down the B<mmap>(2)  and B<mprotect>(2)  system calls to "
"prevent the program from subverting such checks.)"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:408
msgid ""
"When checking values from I<args>, keep in mind that arguments are often "
"silently truncated before being processed, but after the seccomp check.  For "
"example, this happens if the i386 ABI is used on an x86-64 kernel: although "
"the kernel will normally not look beyond the 32 lowest bits of the "
"arguments, the values of the full 64-bit registers will be present in the "
"seccomp data.  A less surprising example is that if the x86-64 ABI is used "
"to perform a system call that takes an argument of type I<int>, the more-"
"significant half of the argument register is ignored by the system call, but "
"visible in the seccomp data."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:417
msgid ""
"A seccomp filter returns a 32-bit value consisting of two parts: the most "
"significant 16 bits (corresponding to the mask defined by the constant "
"B<SECCOMP_RET_ACTION_FULL>)  contain one of the \"action\" values listed "
"below; the least significant 16-bits (defined by the constant "
"B<SECCOMP_RET_DATA>)  are \"data\" to be associated with this return value."
msgstr ""

#
#.  From an Aug 2015 conversation with Kees Cook where I asked why *all*
#.  filters are applied even if one of the early filters returns
#.  SECCOMP_RET_KILL:
#.      It's just because it would be an optimization that would only speed up
#.      the RET_KILL case, but it's the uncommon one and the one that doesn't
#.      benefit meaningfully from such a change (you need to kill the process
#.      really quickly?). We would speed up killing a program at the (albeit
#.      tiny) expense to all other filtered programs. Best to keep the filter
#.      execution logic clear, simple, and as fast as possible for all
#.      filters.
#. type: Plain text
#: build/C/man2/seccomp.2:441
msgid ""
"If multiple filters exist, they are I<all> executed, in reverse order of "
"their addition to the filter tree\\(emthat is, the most recently installed "
"filter is executed first.  (Note that all filters will be called even if one "
"of the earlier filters returns B<SECCOMP_RET_KILL>.  This is done to "
"simplify the kernel code and to provide a tiny speed-up in the execution of "
"sets of filters by avoiding a check for this uncommon case.)  The return "
"value for the evaluation of a given system call is the first-seen action "
"value of highest precedence (along with its accompanying data)  returned by "
"execution of all of the filters."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:444
msgid ""
"In decreasing order of precedence, the action values that may be returned by "
"a seccomp filter are:"
msgstr ""

#. type: TP
#: build/C/man2/seccomp.2:444
#, no-wrap
msgid "B<SECCOMP_RET_KILL_PROCESS> (since Linux 4.14)"
msgstr "B<SECCOMP_RET_KILL_PROCESS> (Linux 4.14 以降)"

#.  commit 4d3b0b05aae9ee9ce0970dc4cc0fb3fad5e85945
#.  commit 0466bdb99e8744bc9befa8d62a317f0fd7fd7421
#. type: Plain text
#: build/C/man2/seccomp.2:458
msgid ""
"This value results in immediate termination of the process, with a core "
"dump.  The system call is not executed.  By contrast with "
"B<SECCOMP_RET_KILL_THREAD> below, all threads in the thread group are "
"terminated.  (For a discussion of thread groups, see the description of the "
"B<CLONE_THREAD> flag in B<clone>(2).)"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:474
msgid ""
"The process terminates I<as though> killed by a B<SIGSYS> signal.  Even if a "
"signal handler has been registered for B<SIGSYS>, the handler will be "
"ignored in this case and the process always terminates.  To a parent process "
"that is waiting on this process (using B<waitpid>(2)  or similar), the "
"returned I<wstatus> will indicate that its child was terminated as though by "
"a B<SIGSYS> signal."
msgstr ""

#. type: TP
#: build/C/man2/seccomp.2:474
#, no-wrap
msgid "B<SECCOMP_RET_KILL_THREAD> (or B<SECCOMP_RET_KILL>)"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:480
msgid ""
"This value results in immediate termination of the thread that made the "
"system call.  The system call is not executed.  Other threads in the same "
"thread group will continue to execute."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:489
msgid ""
"The thread terminates I<as though> killed by a B<SIGSYS> signal.  See "
"B<SECCOMP_RET_KILL_PROCESS> above."
msgstr ""

#.  See these commits:
#.  seccomp: dump core when using SECCOMP_RET_KILL
#.     (b25e67161c295c98acda92123b2dd1e7d8642901)
#.  seccomp: Only dump core when single-threaded
#.     (d7276e321ff8a53106a59c85ca46d03e34288893)
#. type: Plain text
#: build/C/man2/seccomp.2:504
msgid ""
"Before Linux 4.11, any process terminated in this way would not trigger a "
"coredump (even though B<SIGSYS> is documented in B<signal>(7)  as having a "
"default action of termination with a core dump).  Since Linux 4.11, a single-"
"threaded process will dump core if terminated in this way."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:512
msgid ""
"With the addition of B<SECCOMP_RET_KILL_PROCESS> in Linux 4.14, "
"B<SECCOMP_RET_KILL_THREAD> was added as a synonym for B<SECCOMP_RET_KILL>, "
"in order to more clearly distinguish the two actions."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:518
msgid ""
"B<Note>: the use of B<SECCOMP_RET_KILL_THREAD> to kill a single thread in a "
"multithreaded process is likely to leave the process in a permanently "
"inconsistent and possibly corrupt state."
msgstr ""

#. type: TP
#: build/C/man2/seccomp.2:518
#, no-wrap
msgid "B<SECCOMP_RET_TRAP>"
msgstr "B<SECCOMP_RET_TRAP>"

#. type: Plain text
#: build/C/man2/seccomp.2:529
msgid ""
"This value results in the kernel sending a thread-directed B<SIGSYS> signal "
"to the triggering thread.  (The system call is not executed.)  Various "
"fields will be set in the I<siginfo_t> structure (see B<sigaction>(2))  "
"associated with signal:"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:534
msgid "I<si_signo> will contain B<SIGSYS>."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:537
msgid "I<si_call_addr> will show the address of the system call instruction."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:542
msgid ""
"I<si_syscall> and I<si_arch> will indicate which system call was attempted."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:546
msgid "I<si_code> will contain B<SYS_SECCOMP>."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:551
msgid ""
"I<si_errno> will contain the B<SECCOMP_RET_DATA> portion of the filter "
"return value."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:560
msgid ""
"The program counter will be as though the system call happened (i.e., the "
"program counter will not point to the system call instruction).  The return "
"value register will contain an architecture-dependent value; if resuming "
"execution, set it to something appropriate for the system call.  (The "
"architecture dependency is because replacing it with B<ENOSYS> could "
"overwrite some useful information.)"
msgstr ""

#. type: TP
#: build/C/man2/seccomp.2:560
#, no-wrap
msgid "B<SECCOMP_RET_ERRNO>"
msgstr "B<SECCOMP_RET_ERRNO>"

#. type: Plain text
#: build/C/man2/seccomp.2:567
msgid ""
"This value results in the B<SECCOMP_RET_DATA> portion of the filter's return "
"value being passed to user space as the I<errno> value without executing the "
"system call."
msgstr ""

#. type: TP
#: build/C/man2/seccomp.2:567
#, no-wrap
msgid "B<SECCOMP_RET_TRACE>"
msgstr "B<SECCOMP_RET_TRACE>"

#. type: Plain text
#: build/C/man2/seccomp.2:577
msgid ""
"When returned, this value will cause the kernel to attempt to notify a "
"B<ptrace>(2)-based tracer prior to executing the system call.  If there is "
"no tracer present, the system call is not executed and returns a failure "
"status with I<errno> set to B<ENOSYS>."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:588
msgid ""
"A tracer will be notified if it requests B<PTRACE_O_TRACESECCOMP> using "
"I<ptrace(PTRACE_SETOPTIONS)>.  The tracer will be notified of a "
"B<PTRACE_EVENT_SECCOMP> and the B<SECCOMP_RET_DATA> portion of the filter's "
"return value will be available to the tracer via B<PTRACE_GETEVENTMSG>."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:595
msgid ""
"The tracer can skip the system call by changing the system call number to "
"-1.  Alternatively, the tracer can change the system call requested by "
"changing the system call to a valid system call number.  If the tracer asks "
"to skip the system call, then the system call will appear to return the "
"value that the tracer puts in the return value register."
msgstr ""

#.  This was changed in ce6526e8afa4.
#.  A related hole, using PTRACE_SYSCALL instead of SECCOMP_RET_TRACE, was
#.  changed in arch-specific commits, e.g. 93e35efb8de4 for X86 and
#.  0f3912fd934c for ARM.
#. type: Plain text
#: build/C/man2/seccomp.2:609
msgid ""
"Before kernel 4.8, the seccomp check will not be run again after the tracer "
"is notified.  (This means that, on older kernels, seccomp-based sandboxes "
"B<must not> allow use of B<ptrace>(2)\\(emeven of other sandboxed processes"
"\\(emwithout extreme care; ptracers can use this mechanism to escape from "
"the seccomp sandbox.)"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:613
msgid ""
"Note that a tracer process will not be notified if another filter returns an "
"action value with a precedence greater than B<SECCOMP_RET_TRACE>."
msgstr ""

#. type: TP
#: build/C/man2/seccomp.2:613
#, no-wrap
msgid "B<SECCOMP_RET_LOG> (since Linux 4.14)"
msgstr "B<SECCOMP_RET_LOG> (Linux 4.14 以降)"

#.  commit 59f5cf44a38284eb9e76270c786fb6cc62ef8ac4
#. type: Plain text
#: build/C/man2/seccomp.2:622
msgid ""
"This value results in the system call being executed after the filter return "
"action is logged.  An administrator may override the logging of this action "
"via the I</proc/sys/kernel/seccomp/actions_logged> file."
msgstr ""

#. type: TP
#: build/C/man2/seccomp.2:622
#, no-wrap
msgid "B<SECCOMP_RET_ALLOW>"
msgstr "B<SECCOMP_RET_ALLOW>"

#. type: Plain text
#: build/C/man2/seccomp.2:625
msgid "This value results in the system call being executed."
msgstr ""

#.  commit 4d3b0b05aae9ee9ce0970dc4cc0fb3fad5e85945
#. type: Plain text
#: build/C/man2/seccomp.2:635
msgid ""
"If an action value other than one of the above is specified, then the filter "
"action is treated as either B<SECCOMP_RET_KILL_PROCESS> (since Linux 4.14)  "
"or B<SECCOMP_RET_KILL_THREAD> (in Linux 4.13 and earlier)."
msgstr ""

#
#. type: SS
#: build/C/man2/seccomp.2:635
#, no-wrap
msgid "/proc interfaces"
msgstr "/proc インターフェース"

#. type: Plain text
#: build/C/man2/seccomp.2:639
msgid ""
"The files in the directory I</proc/sys/kernel/seccomp> provide additional "
"seccomp information and configuration:"
msgstr ""

#. type: TP
#: build/C/man2/seccomp.2:639
#, no-wrap
msgid "I<actions_avail> (since Linux 4.14)"
msgstr "I<actions_avail> (Linux 4.14 以降)"

#.  commit 8e5f1ad116df6b0de65eac458d5e7c318d1c05af
#. type: Plain text
#: build/C/man2/seccomp.2:646
msgid ""
"A read-only ordered list of seccomp filter return actions in string form.  "
"The ordering, from left-to-right, is in decreasing order of precedence.  The "
"list represents the set of seccomp filter return actions supported by the "
"kernel."
msgstr ""

#. type: TP
#: build/C/man2/seccomp.2:646
#, no-wrap
msgid "I<actions_logged> (since Linux 4.14)"
msgstr "I<actions_logged> (Linux 4.14 以降)"

#.  commit 0ddec0fc8900201c0897b87b762b7c420436662f
#. type: Plain text
#: build/C/man2/seccomp.2:655
msgid ""
"A read-write ordered list of seccomp filter return actions that are allowed "
"to be logged.  Writes to the file do not need to be in ordered form but "
"reads from the file will be ordered in the same way as the I<actions_avail> "
"file."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:666
msgid ""
"It is important to note that the value of I<actions_logged> does not prevent "
"certain filter return actions from being logged when the audit subsystem is "
"configured to audit a task.  If the action is not found in the "
"I<actions_logged> file, the final decision on whether to audit the action "
"for that task is ultimately left up to the audit subsystem to decide for all "
"filter return actions other than B<SECCOMP_RET_ALLOW>."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:675
msgid ""
"The \"allow\" string is not accepted in the I<actions_logged> file as it is "
"not possible to log B<SECCOMP_RET_ALLOW> actions.  Attempting to write "
"\"allow\" to the file will fail with the error B<EINVAL>."
msgstr ""

#. type: SS
#: build/C/man2/seccomp.2:675
#, no-wrap
msgid "Audit logging of seccomp actions"
msgstr ""

#.  commit 59f5cf44a38284eb9e76270c786fb6cc62ef8ac4
#.  or auditing could be enabled via the netlink API (AUDIT_SET)
#. type: Plain text
#: build/C/man2/seccomp.2:687
msgid ""
"Since Linux 4.14, the kernel provides the facility to log the actions "
"returned by seccomp filters in the audit log.  The kernel makes the decision "
"to log an action based on the action type, whether or not the action is "
"present in the I<actions_logged> file, and whether kernel auditing is "
"enabled (e.g., via the kernel boot option I<audit=1>).  The rules are as "
"follows:"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:691
msgid "If the action is B<SECCOMP_RET_ALLOW>, the action is not logged."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:699
msgid ""
"Otherwise, if the action is either B<SECCOMP_RET_KILL_PROCESS> or "
"B<SECCOMP_RET_KILL_THREAD>, and that action appears in the I<actions_logged> "
"file, the action is logged."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:706
msgid ""
"Otherwise, if the filter has requested logging (the "
"B<SECCOMP_FILTER_FLAG_LOG> flag)  and the action appears in the "
"I<actions_logged> file, the action is logged."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:710
msgid ""
"Otherwise, if kernel auditing is enabled and the process is being audited "
"(B<autrace>(8)), the action is logged."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:712
msgid "Otherwise, the action is not logged."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:728
msgid ""
"On success, B<seccomp>()  returns 0.  On error, if "
"B<SECCOMP_FILTER_FLAG_TSYNC> was used, the return value is the ID of the "
"thread that caused the synchronization failure.  (This ID is a kernel thread "
"ID of the type returned by B<clone>(2)  and B<gettid>(2).)  On other errors, "
"-1 is returned, and I<errno> is set to indicate the cause of the error."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:731
msgid "B<seccomp>()  can fail for the following reasons:"
msgstr "B<seccomp>()  は以下のエラーで失敗する。"

#. type: Plain text
#: build/C/man2/seccomp.2:739
msgid ""
"The caller did not have the B<CAP_SYS_ADMIN> capability in its user "
"namespace, or had not set I<no_new_privs> before using "
"B<SECCOMP_SET_MODE_FILTER>."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:743
msgid "I<args> was not a valid address."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:747
msgid ""
"I<operation> is unknown or is not supported by this kernel version or "
"configuration."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:753
msgid "The specified I<flags> are invalid for the given I<operation>."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:760
msgid ""
"I<operation> included B<BPF_ABS>, but the specified offset was not aligned "
"to a 32-bit boundary or exceeded I<sizeof(struct\\ seccomp_data)>."
msgstr ""

#.  See kernel/seccomp.c::seccomp_may_assign_mode() in 3.18 sources
#. type: Plain text
#: build/C/man2/seccomp.2:766
msgid ""
"A secure computing mode has already been set, and I<operation> differs from "
"the existing setting."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:776
msgid ""
"I<operation> specified B<SECCOMP_SET_MODE_FILTER>, but the filter program "
"pointed to by I<args> was not valid or the length of the filter program was "
"zero or exceeded B<BPF_MAXINSNS> (4096) instructions."
msgstr ""

#.  ENOMEM in kernel/seccomp.c::seccomp_attach_filter() in 3.18 sources
#. type: Plain text
#: build/C/man2/seccomp.2:789
msgid ""
"The total length of all filter programs attached to the calling thread would "
"exceed B<MAX_INSNS_PER_PATH> (32768) instructions.  Note that for the "
"purposes of calculating this limit, each already existing filter program "
"incurs an overhead penalty of 4 instructions."
msgstr ""

#. type: TP
#: build/C/man2/seccomp.2:789
#, no-wrap
msgid "B<EOPNOTSUPP>"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:796
msgid ""
"I<operation> specified B<SECCOMP_GET_ACTION_AVAIL>, but the kernel does not "
"support the filter return action specified by I<args>."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:800
msgid ""
"Another thread caused a failure during thread sync, but its ID could not be "
"determined."
msgstr ""

#.  FIXME . Add glibc version
#. type: Plain text
#: build/C/man2/seccomp.2:805
msgid "The B<seccomp>()  system call first appeared in Linux 3.17."
msgstr "B<seccomp>() システムコールは Linux 3.17 で初めて登場した。"

#. type: Plain text
#: build/C/man2/seccomp.2:809
msgid "The B<seccomp>()  system call is a nonstandard Linux extension."
msgstr "B<seccomp>() システムコールは非標準の Linux 拡張である。"

#. type: Plain text
#: build/C/man2/seccomp.2:814
msgid ""
"Rather than hand-coding seccomp filters as shown in the example below, you "
"may prefer to employ the I<libseccomp> library, which provides a front-end "
"for generating seccomp filters."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:821
msgid ""
"The I<Seccomp> field of the I</proc/[pid]/status> file provides a method of "
"viewing the seccomp mode of a process; see B<proc>(5)."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:828
msgid ""
"B<seccomp>()  provides a superset of the functionality provided by the "
"B<prctl>(2)  B<PR_SET_SECCOMP> operation (which does not support I<flags>)."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:834
msgid ""
"Since Linux 4.4, the B<ptrace>(2)  B<PTRACE_SECCOMP_GET_FILTER> operation "
"can be used to dump a process's seccomp filters."
msgstr ""

#. type: SS
#: build/C/man2/seccomp.2:834
#, no-wrap
msgid "Architecture support for seccomp BPF"
msgstr ""

#.  Check by grepping for HAVE_ARCH_SECCOMP_FILTER in Kconfig files in
#.  kernel source. Last checked in Linux 4.16-rc source.
#. type: Plain text
#: build/C/man2/seccomp.2:839
msgid ""
"Architecture support for seccomp BPF filtering is available on the following "
"architectures:"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:841
msgid "x86-64, i386, x32 (since Linux 3.5)"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:844
msgid "ARM (since Linux 3.8)"
msgstr "ARM (Linux 3.8 以降)"

#. type: Plain text
#: build/C/man2/seccomp.2:846
msgid "s390 (since Linux 3.8)"
msgstr "s390 (Linux 3.8 以降)"

#. type: Plain text
#: build/C/man2/seccomp.2:848
msgid "MIPS (since Linux 3.16)"
msgstr "MIPS (Linux 3.16 以降)"

#. type: Plain text
#: build/C/man2/seccomp.2:850
msgid "ARM-64 (since Linux 3.19)"
msgstr "ARM-64 (Linux 3.19 以降)"

#. type: Plain text
#: build/C/man2/seccomp.2:852
msgid "PowerPC (since Linux 4.3)"
msgstr "PowerPC (Linux 4.3 以降)"

#. type: Plain text
#: build/C/man2/seccomp.2:854
msgid "Tile (since Linux 4.3)"
msgstr "Tile (Linux 4.3 以降)"

#.  User mode Linux since Linux 4.6
#. type: Plain text
#: build/C/man2/seccomp.2:857
msgid "PA-RISC (since Linux 4.6)"
msgstr "PA-RISC (Linux 4.6 以降)"

#. type: SS
#: build/C/man2/seccomp.2:859
#, no-wrap
msgid "Caveats"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:862
msgid ""
"There are various subtleties to consider when applying seccomp filters to a "
"program, including the following:"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:877
msgid ""
"Some traditional system calls have user-space implementations in the "
"B<vdso>(7)  on many architectures.  Notable examples include "
"B<clock_gettime>(2), B<gettimeofday>(2), and B<time>(2).  On such "
"architectures, seccomp filtering for these system calls will have no "
"effect.  (However, there are cases where the B<vdso>(7)  implementations may "
"fall back to invoking the true system call, in which case seccomp filters "
"would see the system call.)"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:883
msgid ""
"Seccomp filtering is based on system call numbers.  However, applications "
"typically do not directly invoke system calls, but instead call wrapper "
"functions in the C library which in turn invoke the system calls.  "
"Consequently, one must be aware of the following:"
msgstr ""

#. type: IP
#: build/C/man2/seccomp.2:884 build/C/man2/seccomp.2:895
#: build/C/man2/seccomp.2:900 build/C/man7/cgroups.7:1590
#: build/C/man7/cgroups.7:1597 build/C/man7/cgroups.7:1602
#: build/C/man2/pidfd_getfd.2:134 build/C/man2/pidfd_getfd.2:139
#: build/C/man2/pidfd_getfd.2:146 build/C/man2/pidfd_open.2:114
#: build/C/man2/pidfd_open.2:121 build/C/man2/pidfd_open.2:131
#: build/C/man2/pidfd_open.2:153 build/C/man2/pidfd_open.2:158
#: build/C/man2/pidfd_open.2:171 build/C/man2/pidfd_open.2:175
#: build/C/man2/pidfd_open.2:180
#, no-wrap
msgid "\\(bu"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:895
msgid ""
"The glibc wrappers for some traditional system calls may actually employ "
"system calls with different names in the kernel.  For example, the "
"B<exit>(2)  wrapper function actually employs the B<exit_group>(2)  system "
"call, and the B<fork>(2)  wrapper function actually calls B<clone>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:900
msgid ""
"The behavior of wrapper functions may vary across architectures, according "
"to the range of system calls provided on those architectures.  In other "
"words, the same wrapper function may invoke different system calls on "
"different architectures."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:908
msgid ""
"Finally, the behavior of wrapper functions can change across glibc "
"versions.  For example, in older versions, the glibc wrapper function for "
"B<open>(2)  invoked the system call of the same name, but starting in glibc "
"2.26, the implementation switched to calling B<openat>(2)  on all "
"architectures."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:916
msgid ""
"The consequence of the above points is that it may be necessary to filter "
"for a system call other than might be expected.  Various manual pages in "
"Section 2 provide helpful details about the differences between wrapper "
"functions and the underlying system calls in subsections entitled I<C "
"library/kernel differences>."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:924
msgid ""
"Furthermore, note that the application of seccomp filters even risks causing "
"bugs in an application, when the filters cause unexpected failures for "
"legitimate operations that the application might need to perform.  Such bugs "
"may not easily be discovered when testing the seccomp filters if the bugs "
"occur in rarely used application code paths."
msgstr ""

#. type: SS
#: build/C/man2/seccomp.2:924
#, no-wrap
msgid "Seccomp-specific BPF details"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:926
msgid "Note the following BPF details specific to seccomp filters:"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:934
msgid ""
"The B<BPF_H> and B<BPF_B> size modifiers are not supported: all operations "
"must load and store (4-byte) words (B<BPF_W>)."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:940
msgid ""
"To access the contents of the I<seccomp_data> buffer, use the B<BPF_ABS> "
"addressing mode modifier."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:947
msgid ""
"The B<BPF_LEN> addressing mode modifier yields an immediate mode operand "
"whose value is the size of the I<seccomp_data> buffer."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:953
msgid ""
"The program below accepts four or more arguments.  The first three arguments "
"are a system call number, a numeric architecture identifier, and an error "
"number.  The program uses these values to construct a BPF filter that is "
"used at run time to perform the following checks:"
msgstr ""

#. type: IP
#: build/C/man2/seccomp.2:953
#, no-wrap
msgid "[1]"
msgstr "[1]"

#. type: Plain text
#: build/C/man2/seccomp.2:957
msgid ""
"If the program is not running on the specified architecture, the BPF filter "
"causes system calls to fail with the error B<ENOSYS>."
msgstr ""

#. type: IP
#: build/C/man2/seccomp.2:957
#, no-wrap
msgid "[2]"
msgstr "[2]"

#. type: Plain text
#: build/C/man2/seccomp.2:962
msgid ""
"If the program attempts to execute the system call with the specified "
"number, the BPF filter causes the system call to fail, with I<errno> being "
"set to the specified error number."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:971
msgid ""
"The remaining command-line arguments specify the pathname and additional "
"arguments of a program that the example program should attempt to execute "
"using B<execv>(3)  (a library function that employs the B<execve>(2)  system "
"call).  Some example runs of the program are shown below."
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:975
msgid ""
"First, we display the architecture that we are running on (x86-64)  and then "
"construct a shell function that looks up system call numbers on this "
"architecture:"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:984
#, no-wrap
msgid ""
"$ B<uname -m>\n"
"x86_64\n"
"$ B<syscall_nr() {\n"
"    cat /usr/src/linux/arch/x86/syscalls/syscall_64.tbl | \\e\n"
"    awk \\(aq$2 != \"x32\" && $3 == \"\\(aq$1\\(aq\" { print $1 }\\(aq\n"
"}>\n"
msgstr ""
"$ B<uname -m>\n"
"x86_64\n"
"$ B<syscall_nr() {\n"
"    cat /usr/src/linux/arch/x86/syscalls/syscall_64.tbl | \\e\n"
"    awk \\(aq$2 != \"x32\" && $3 == \"\\(aq$1\\(aq\" { print $1 }\\(aq\n"
"}>\n"

#. type: Plain text
#: build/C/man2/seccomp.2:991
msgid ""
"When the BPF filter rejects a system call (case [2] above), it causes the "
"system call to fail with the error number specified on the command line.  In "
"the experiments shown here, we'll use error number 99:"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:996
#, no-wrap
msgid ""
"$ B<errno 99>\n"
"EADDRNOTAVAIL 99 Cannot assign requested address\n"
msgstr ""
"$ B<errno 99>\n"
"EADDRNOTAVAIL 99 Cannot assign requested address\n"

#. type: Plain text
#: build/C/man2/seccomp.2:1004
msgid ""
"In the following example, we attempt to run the command B<whoami>(1), but "
"the BPF filter rejects the B<execve>(2)  system call, so that the command is "
"not even executed:"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:1015
#, no-wrap
msgid ""
"$ B<syscall_nr execve>\n"
"59\n"
"$ B<./a.out>\n"
"Usage: ./a.out E<lt>syscall_nrE<gt> E<lt>archE<gt> E<lt>errnoE<gt> E<lt>progE<gt> [E<lt>argsE<gt>]\n"
"Hint for E<lt>archE<gt>: AUDIT_ARCH_I386: 0x40000003\n"
"                 AUDIT_ARCH_X86_64: 0xC000003E\n"
"$ B<./a.out 59 0xC000003E 99 /bin/whoami>\n"
"execv: Cannot assign requested address\n"
msgstr ""
"$ B<syscall_nr execve>\n"
"59\n"
"$ B<./a.out>\n"
"Usage: ./a.out E<lt>syscall_nrE<gt> E<lt>archE<gt> E<lt>errnoE<gt> E<lt>progE<gt> [E<lt>argsE<gt>]\n"
"Hint for E<lt>archE<gt>: AUDIT_ARCH_I386: 0x40000003\n"
"                 AUDIT_ARCH_X86_64: 0xC000003E\n"
"$ B<./a.out 59 0xC000003E 99 /bin/whoami>\n"
"execv: Cannot assign requested address\n"

#. type: Plain text
#: build/C/man2/seccomp.2:1023
msgid ""
"In the next example, the BPF filter rejects the B<write>(2)  system call, so "
"that, although it is successfully started, the B<whoami>(1)  command is not "
"able to write output:"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:1029
#, no-wrap
msgid ""
"$ B<syscall_nr write>\n"
"1\n"
"$ B<./a.out 1 0xC000003E 99 /bin/whoami>\n"
msgstr ""
"$ B<syscall_nr write>\n"
"1\n"
"$ B<./a.out 1 0xC000003E 99 /bin/whoami>\n"

#. type: Plain text
#: build/C/man2/seccomp.2:1036
msgid ""
"In the final example, the BPF filter rejects a system call that is not used "
"by the B<whoami>(1)  command, so it is able to successfully execute and "
"produce output:"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:1043
#, no-wrap
msgid ""
"$ B<syscall_nr preadv>\n"
"295\n"
"$ B<./a.out 295 0xC000003E 99 /bin/whoami>\n"
"cecilia\n"
msgstr ""
"$ B<syscall_nr preadv>\n"
"295\n"
"$ B<./a.out 295 0xC000003E 99 /bin/whoami>\n"
"cecilia\n"

#. type: SS
#: build/C/man2/seccomp.2:1045 build/C/man2/pidfd_open.2:209
#: build/C/man3/posix_spawn.3:681
#, no-wrap
msgid "Program source"
msgstr "プログラムのソース"

#. type: Plain text
#: build/C/man2/seccomp.2:1056
#, no-wrap
msgid ""
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>stddef.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>linux/audit.hE<gt>\n"
"#include E<lt>linux/filter.hE<gt>\n"
"#include E<lt>linux/seccomp.hE<gt>\n"
"#include E<lt>sys/prctl.hE<gt>\n"
msgstr ""
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>stddef.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>linux/audit.hE<gt>\n"
"#include E<lt>linux/filter.hE<gt>\n"
"#include E<lt>linux/seccomp.hE<gt>\n"
"#include E<lt>sys/prctl.hE<gt>\n"

#. type: Plain text
#: build/C/man2/seccomp.2:1059
#, no-wrap
msgid ""
"#define X32_SYSCALL_BIT 0x40000000\n"
"#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))\n"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:1064
#, no-wrap
msgid ""
"static int\n"
"install_filter(int syscall_nr, int t_arch, int f_errno)\n"
"{\n"
"    unsigned int upper_nr_limit = 0xffffffff;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:1070
#, no-wrap
msgid ""
"    /* Assume that AUDIT_ARCH_X86_64 means the normal x86-64 ABI\n"
"       (in the x32 ABI, all system calls have bit 30 set in the\n"
"       \\(aqnr\\(aq field, meaning the numbers are E<gt>= X32_SYSCALL_BIT) */\n"
"    if (t_arch == AUDIT_ARCH_X86_64)\n"
"        upper_nr_limit = X32_SYSCALL_BIT - 1;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:1076
#, no-wrap
msgid ""
"    struct sock_filter filter[] = {\n"
"        /* [0] Load architecture from \\(aqseccomp_data\\(aq buffer into\n"
"               accumulator */\n"
"        BPF_STMT(BPF_LD | BPF_W | BPF_ABS,\n"
"                 (offsetof(struct seccomp_data, arch))),\n"
msgstr ""
"    struct sock_filter filter[] = {\n"
"        /* [0] Load architecture from \\(aqseccomp_data\\(aq buffer into\n"
"               accumulator */\n"
"        BPF_STMT(BPF_LD | BPF_W | BPF_ABS,\n"
"                 (offsetof(struct seccomp_data, arch))),\n"

#. type: Plain text
#: build/C/man2/seccomp.2:1080
#, no-wrap
msgid ""
"        /* [1] Jump forward 5 instructions if architecture does not\n"
"               match \\(aqt_arch\\(aq */\n"
"        BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, t_arch, 0, 5),\n"
msgstr ""
"        /* [1] Jump forward 5 instructions if architecture does not\n"
"               match \\(aqt_arch\\(aq */\n"
"        BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, t_arch, 0, 5),\n"

#. type: Plain text
#: build/C/man2/seccomp.2:1085
#, no-wrap
msgid ""
"        /* [2] Load system call number from \\(aqseccomp_data\\(aq buffer into\n"
"               accumulator */\n"
"        BPF_STMT(BPF_LD | BPF_W | BPF_ABS,\n"
"                 (offsetof(struct seccomp_data, nr))),\n"
msgstr ""
"        /* [2] Load system call number from \\(aqseccomp_data\\(aq buffer into\n"
"               accumulator */\n"
"        BPF_STMT(BPF_LD | BPF_W | BPF_ABS,\n"
"                 (offsetof(struct seccomp_data, nr))),\n"

#. type: Plain text
#: build/C/man2/seccomp.2:1090
#, no-wrap
msgid ""
"        /* [3] Check ABI - only needed for x86-64 in deny-list use\n"
"               cases.  Use BPF_JGT instead of checking against the bit\n"
"               mask to avoid having to reload the syscall number. */\n"
"        BPF_JUMP(BPF_JMP | BPF_JGT | BPF_K, upper_nr_limit, 3, 0),\n"
msgstr ""

#. type: Plain text
#: build/C/man2/seccomp.2:1094
#, no-wrap
msgid ""
"        /* [4] Jump forward 1 instruction if system call number\n"
"               does not match \\(aqsyscall_nr\\(aq */\n"
"        BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, syscall_nr, 0, 1),\n"
msgstr ""
"        /* [4] Jump forward 1 instruction if system call number\n"
"               does not match \\(aqsyscall_nr\\(aq */\n"
"        BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, syscall_nr, 0, 1),\n"

#. type: Plain text
#: build/C/man2/seccomp.2:1099
#, no-wrap
msgid ""
"        /* [5] Matching architecture and system call: don\\(aqt execute\n"
"           the system call, and return \\(aqf_errno\\(aq in \\(aqerrno\\(aq */\n"
"        BPF_STMT(BPF_RET | BPF_K,\n"
"                 SECCOMP_RET_ERRNO | (f_errno & SECCOMP_RET_DATA)),\n"
msgstr ""
"        /* [5] Matching architecture and system call: don\\(aqt execute\n"
"           the system call, and return \\(aqf_errno\\(aq in \\(aqerrno\\(aq */\n"
"        BPF_STMT(BPF_RET | BPF_K,\n"
"                 SECCOMP_RET_ERRNO | (f_errno & SECCOMP_RET_DATA)),\n"

#. type: Plain text
#: build/C/man2/seccomp.2:1103
#, no-wrap
msgid ""
"        /* [6] Destination of system call number mismatch: allow other\n"
"               system calls */\n"
"        BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_ALLOW),\n"
msgstr ""
"        /* [6] Destination of system call number mismatch: allow other\n"
"               system calls */\n"
"        BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_ALLOW),\n"

#. type: Plain text
#: build/C/man2/seccomp.2:1107
#, no-wrap
msgid ""
"        /* [7] Destination of architecture mismatch: kill process */\n"
"        BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_KILL_PROCESS),\n"
"    };\n"
msgstr ""
"        /* [7] Destination of architecture mismatch: kill process */\n"
"        BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_KILL_PROCESS),\n"
"    };\n"

#. type: Plain text
#: build/C/man2/seccomp.2:1112
#, no-wrap
msgid ""
"    struct sock_fprog prog = {\n"
"        .len = ARRAY_SIZE(filter),\n"
"        .filter = filter,\n"
"    };\n"
msgstr ""
"    struct sock_fprog prog = {\n"
"        .len = ARRAY_SIZE(filter),\n"
"        .filter = filter,\n"
"    };\n"

#. type: Plain text
#: build/C/man2/seccomp.2:1117
#, no-wrap
msgid ""
"    if (seccomp(SECCOMP_SET_MODE_FILTER, 0, &prog)) {\n"
"        perror(\"seccomp\");\n"
"        return 1;\n"
"    }\n"
msgstr ""
"    if (seccomp(SECCOMP_SET_MODE_FILTER, 0, &prog)) {\n"
"        perror(\"seccomp\");\n"
"        return 1;\n"
"    }\n"

#. type: Plain text
#: build/C/man2/seccomp.2:1120
#, no-wrap
msgid ""
"    return 0;\n"
"}\n"
msgstr ""
"    return 0;\n"
"}\n"

#. type: Plain text
#: build/C/man2/seccomp.2:1132
#, no-wrap
msgid ""
"int\n"
"main(int argc, char **argv)\n"
"{\n"
"    if (argc E<lt> 5) {\n"
"        fprintf(stderr, \"Usage: \"\n"
"                \"%s E<lt>syscall_nrE<gt> E<lt>archE<gt> E<lt>errnoE<gt> E<lt>progE<gt> [E<lt>argsE<gt>]\\en\"\n"
"                \"Hint for E<lt>archE<gt>: AUDIT_ARCH_I386: 0x%X\\en\"\n"
"                \"                 AUDIT_ARCH_X86_64: 0x%X\\en\"\n"
"                \"\\en\", argv[0], AUDIT_ARCH_I386, AUDIT_ARCH_X86_64);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"int\n"
"main(int argc, char **argv)\n"
"{\n"
"    if (argc E<lt> 5) {\n"
"        fprintf(stderr, \"Usage: \"\n"
"                \"%s E<lt>syscall_nrE<gt> E<lt>archE<gt> E<lt>errnoE<gt> E<lt>progE<gt> [E<lt>argsE<gt>]\\en\"\n"
"                \"Hint for E<lt>archE<gt>: AUDIT_ARCH_I386: 0x%X\\en\"\n"
"                \"                 AUDIT_ARCH_X86_64: 0x%X\\en\"\n"
"                \"\\en\", argv[0], AUDIT_ARCH_I386, AUDIT_ARCH_X86_64);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/seccomp.2:1137
#, no-wrap
msgid ""
"    if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {\n"
"        perror(\"prctl\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {\n"
"        perror(\"prctl\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/seccomp.2:1142
#, no-wrap
msgid ""
"    if (install_filter(strtol(argv[1], NULL, 0),\n"
"                       strtol(argv[2], NULL, 0),\n"
"                       strtol(argv[3], NULL, 0)))\n"
"        exit(EXIT_FAILURE);\n"
msgstr ""
"    if (install_filter(strtol(argv[1], NULL, 0),\n"
"                       strtol(argv[2], NULL, 0),\n"
"                       strtol(argv[3], NULL, 0)))\n"
"        exit(EXIT_FAILURE);\n"

#. type: Plain text
#: build/C/man2/seccomp.2:1147
#, no-wrap
msgid ""
"    execv(argv[4], &argv[4]);\n"
"    perror(\"execv\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""
"    execv(argv[4], &argv[4]);\n"
"    perror(\"execv\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"

#. type: Plain text
#: build/C/man2/seccomp.2:1158
msgid ""
"B<bpfc>(1), B<strace>(1), B<bpf>(2), B<prctl>(2), B<ptrace>(2), "
"B<sigaction>(2), B<proc>(5), B<signal>(7), B<socket>(7)"
msgstr "B<bpfc>(1), B<strace>(1), B<bpf>(2), B<prctl>(2), B<ptrace>(2), B<sigaction>(2), B<proc>(5), B<signal>(7), B<socket>(7)"

#. type: Plain text
#: build/C/man2/seccomp.2:1168
msgid ""
"Various pages from the I<libseccomp> library, including: "
"B<scmp_sys_resolver>(1), B<seccomp_export_bpf>(3), B<seccomp_init>(3), "
"B<seccomp_load>(3), and B<seccomp_rule_add>(3)."
msgstr ""

#.  commit c061f33f35be0ccc80f4b8e0aea5dfd2ed7e01a3
#. type: Plain text
#: build/C/man2/seccomp.2:1177
#, fuzzy
#| msgid ""
#| "The kernel source files I<Documentation/networking/filter.txt> and "
#| "I<Documentation/prctl/seccomp_filter.txt>."
msgid ""
"The kernel source files I<Documentation/networking/filter.txt> and "
"I<Documentation/userspace-api/seccomp_filter.rst> (or I<Documentation/prctl/"
"seccomp_filter.txt> before Linux 4.13)."
msgstr ""
"カーネルのソースファイル I<Documentation/networking/filter.txt> と "
"I<Documentation/prctl/seccomp_filter.txt>"

#. type: Plain text
#: build/C/man2/seccomp.2:1183
msgid ""
"McCanne, S.\\& and Jacobson, V.\\& (1992)  I<The BSD Packet Filter: A New "
"Architecture for User-level Packet Capture>, Proceedings of the USENIX "
"Winter 1993 Conference E<.UR http://www.tcpdump.org/papers/bpf-usenix93.pdf> "
"E<.UE>"
msgstr ""

#. type: TH
#: build/C/man7/cgroups.7:26
#, no-wrap
msgid "CGROUPS"
msgstr "CGROUPS"

#. type: Plain text
#: build/C/man7/cgroups.7:29
msgid "cgroups - Linux control groups"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:40
msgid ""
"Control groups, usually referred to as cgroups, are a Linux kernel feature "
"which allow processes to be organized into hierarchical groups whose usage "
"of various types of resources can then be limited and monitored.  The "
"kernel's cgroup interface is provided through a pseudo-filesystem called "
"cgroupfs.  Grouping is implemented in the core cgroup kernel code, while "
"resource tracking and limits are implemented in a set of per-resource-type "
"subsystems (memory, CPU, and so on)."
msgstr ""

#. type: SS
#: build/C/man7/cgroups.7:40
#, no-wrap
msgid "Terminology"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:45
msgid ""
"A I<cgroup> is a collection of processes that are bound to a set of limits "
"or parameters defined via the cgroup filesystem."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:57
msgid ""
"A I<subsystem> is a kernel component that modifies the behavior of the "
"processes in a cgroup.  Various subsystems have been implemented, making it "
"possible to do things such as limiting the amount of CPU time and memory "
"available to a cgroup, accounting for the CPU time used by a cgroup, and "
"freezing and resuming execution of the processes in a cgroup.  Subsystems "
"are sometimes also known as I<resource controllers> (or simply, controllers)."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:70
msgid ""
"The cgroups for a controller are arranged in a I<hierarchy>.  This hierarchy "
"is defined by creating, removing, and renaming subdirectories within the "
"cgroup filesystem.  At each level of the hierarchy, attributes (e.g., "
"limits) can be defined.  The limits, control, and accounting provided by "
"cgroups generally have effect throughout the subhierarchy underneath the "
"cgroup where the attributes are defined.  Thus, for example, the limits "
"placed on a cgroup at a higher level in the hierarchy cannot be exceeded by "
"descendant cgroups."
msgstr ""

#. type: SS
#: build/C/man7/cgroups.7:70
#, no-wrap
msgid "Cgroups version 1 and version 2"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:83
msgid ""
"The initial release of the cgroups implementation was in Linux 2.6.24.  Over "
"time, various cgroup controllers have been added to allow the management of "
"various types of resources.  However, the development of these controllers "
"was largely uncoordinated, with the result that many inconsistencies arose "
"between controllers and management of the cgroup hierarchies became rather "
"complex.  A longer description of these problems can be found in the kernel "
"source file I<Documentation/admin-guide/cgroup-v2.rst> (or I<Documentation/"
"cgroup-v2.txt> in Linux 4.17 and earlier)."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:97
msgid ""
"Because of the problems with the initial cgroups implementation (cgroups "
"version 1), starting in Linux 3.10, work began on a new, orthogonal "
"implementation to remedy these problems.  Initially marked experimental, and "
"hidden behind the I<-o\\ __DEVEL__sane_behavior> mount option, the new "
"version (cgroups version 2)  was eventually made official with the release "
"of Linux 4.5.  Differences between the two versions are described in the "
"text below.  The file I<cgroup.sane_behavior>, present in cgroups v1, is a "
"relic of this mount option. The file always reports \"0\" and is only "
"retained for backward compatibility."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:112
msgid ""
"Although cgroups v2 is intended as a replacement for cgroups v1, the older "
"system continues to exist (and for compatibility reasons is unlikely to be "
"removed).  Currently, cgroups v2 implements only a subset of the controllers "
"available in cgroups v1.  The two systems are implemented so that both v1 "
"controllers and v2 controllers can be mounted on the same system.  Thus, for "
"example, it is possible to use those controllers that are supported under "
"version 2, while also using version 1 controllers where version 2 does not "
"yet support those controllers.  The only restriction here is that a "
"controller can't be simultaneously employed in both a cgroups v1 hierarchy "
"and in the cgroups v2 hierarchy."
msgstr ""

#. type: SH
#: build/C/man7/cgroups.7:112
#, no-wrap
msgid "CGROUPS VERSION 1"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:119
msgid ""
"Under cgroups v1, each controller may be mounted against a separate cgroup "
"filesystem that provides its own hierarchical organization of the processes "
"on the system.  It is also possible to comount multiple (or even all) "
"cgroups v1 controllers against the same cgroup filesystem, meaning that the "
"comounted controllers manage the same hierarchical organization of processes."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:136
msgid ""
"For each mounted hierarchy, the directory tree mirrors the control group "
"hierarchy.  Each control group is represented by a directory, with each of "
"its child control cgroups represented as a child directory.  For instance, "
"I</user/joe/1.session> represents control group I<1.session>, which is a "
"child of cgroup I<joe>, which is a child of I</user>.  Under each cgroup "
"directory is a set of files which can be read or written to, reflecting "
"resource limits and a few general cgroup properties."
msgstr ""

#. type: SS
#: build/C/man7/cgroups.7:136
#, no-wrap
msgid "Tasks (threads) versus processes"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:146
msgid ""
"In cgroups v1, a distinction is drawn between I<processes> and I<tasks>.  In "
"this view, a process can consist of multiple tasks (more commonly called "
"threads, from a user-space perspective, and called such in the remainder of "
"this man page).  In cgroups v1, it is possible to independently manipulate "
"the cgroup memberships of the threads in a process."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:159
msgid ""
"The cgroups v1 ability to split threads across different cgroups caused "
"problems in some cases.  For example, it made no sense for the I<memory> "
"controller, since all of the threads of a process share a single address "
"space.  Because of these problems, the ability to independently manipulate "
"the cgroup memberships of the threads in a process was removed in the "
"initial cgroups v2 implementation, and subsequently restored in a more "
"limited form (see the discussion of \"thread mode\" below)."
msgstr ""

#. type: SS
#: build/C/man7/cgroups.7:159
#, no-wrap
msgid "Mounting v1 controllers"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:165
msgid ""
"The use of cgroups requires a kernel built with the B<CONFIG_CGROUP> "
"option.  In addition, each of the v1 controllers has an associated "
"configuration option that must be set in order to employ that controller."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:175
msgid ""
"In order to use a v1 controller, it must be mounted against a cgroup "
"filesystem.  The usual place for such mounts is under a B<tmpfs>(5)  "
"filesystem mounted at I</sys/fs/cgroup>.  Thus, one might mount the I<cpu> "
"controller as follows:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:179
#, no-wrap
msgid "mount -t cgroup -o cpu none /sys/fs/cgroup/cpu\n"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:188
msgid ""
"It is possible to comount multiple controllers against the same hierarchy.  "
"For example, here the I<cpu> and I<cpuacct> controllers are comounted "
"against a single hierarchy:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:192
#, no-wrap
msgid "mount -t cgroup -o cpu,cpuacct none /sys/fs/cgroup/cpu,cpuacct\n"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:203
msgid ""
"Comounting controllers has the effect that a process is in the same cgroup "
"for all of the comounted controllers.  Separately mounting controllers "
"allows a process to be in cgroup I</foo1> for one controller while being in "
"I</foo2/foo3> for another."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:205
msgid ""
"It is possible to comount all v1 controllers against the same hierarchy:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:209
#, no-wrap
msgid "mount -t cgroup -o all cgroup /sys/fs/cgroup\n"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:215
msgid ""
"(One can achieve the same result by omitting I<-o all>, since it is the "
"default if no controllers are explicitly specified.)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:229
msgid ""
"It is not possible to mount the same controller against multiple cgroup "
"hierarchies.  For example, it is not possible to mount both the I<cpu> and "
"I<cpuacct> controllers against one hierarchy, and to mount the I<cpu> "
"controller alone against another hierarchy.  It is possible to create "
"multiple mount points with exactly the same set of comounted controllers.  "
"However, in this case all that results is multiple mount points providing a "
"view of the same hierarchy."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:236
msgid ""
"Note that on many systems, the v1 controllers are automatically mounted "
"under I</sys/fs/cgroup>; in particular, B<systemd>(1)  automatically creates "
"such mount points."
msgstr ""

#. type: SS
#: build/C/man7/cgroups.7:236
#, no-wrap
msgid "Unmounting v1 controllers"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:240
msgid ""
"A mounted cgroup filesystem can be unmounted using the B<umount>(8)  "
"command, as in the following example:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:244
#, no-wrap
msgid "umount /sys/fs/cgroup/pids\n"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:258
msgid ""
"I<But note well>: a cgroup filesystem is unmounted only if it is not busy, "
"that is, it has no child cgroups.  If this is not the case, then the only "
"effect of the B<umount>(8)  is to make the mount invisible.  Thus, to ensure "
"that the mount point is really removed, one must first remove all child "
"cgroups, which in turn can be done only after all member processes have been "
"moved from those cgroups to the root cgroup."
msgstr ""

#. type: SS
#: build/C/man7/cgroups.7:258
#, no-wrap
msgid "Cgroups version 1 controllers"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:264
msgid ""
"Each of the cgroups version 1 controllers is governed by a kernel "
"configuration option (listed below).  Additionally, the availability of the "
"cgroups feature is governed by the B<CONFIG_CGROUPS> kernel configuration "
"option."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:264
#, no-wrap
msgid "I<cpu> (since Linux 2.6.24; B<CONFIG_CGROUP_SCHED>)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:274
msgid ""
"Cgroups can be guaranteed a minimum number of \"CPU shares\" when a system "
"is busy.  This does not limit a cgroup's CPU usage if the CPUs are not "
"busy.  For further information, see I<Documentation/scheduler/sched-design-"
"CFS.rst> (or I<Documentation/scheduler/sched-design-CFS.txt> in Linux 5.2 "
"and earlier)."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:288
msgid ""
"In Linux 3.2, this controller was extended to provide CPU \"bandwidth\" "
"control.  If the kernel is configured with B<CONFIG_CFS_BANDWIDTH>, then "
"within each scheduling period (defined via a file in the cgroup directory), "
"it is possible to define an upper limit on the CPU time allocated to the "
"processes in a cgroup.  This upper limit applies even if there is no other "
"competition for the CPU.  Further information can be found in the kernel "
"source file I<Documentation/scheduler/sched-bwc.rst> (or I<Documentation/"
"scheduler/sched-bwc.txt> in Linux 5.2 and earlier)."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:288
#, no-wrap
msgid "I<cpuacct> (since Linux 2.6.24; B<CONFIG_CGROUP_CPUACCT>)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:291
msgid "This provides accounting for CPU usage by groups of processes."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:297
msgid ""
"Further information can be found in the kernel source file I<Documentation/"
"admin-guide/cgroup-v1/cpuacct.rst> (or I<Documentation/cgroup-v1/cpuacct."
"txt> in Linux 5.2 and earlier)."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:297
#, no-wrap
msgid "I<cpuset> (since Linux 2.6.24; B<CONFIG_CPUSETS>)"
msgstr "I<cpuset> (Linux 2.6.24 以降; B<CONFIG_CPUSETS>)"

#. type: Plain text
#: build/C/man7/cgroups.7:301
msgid ""
"This cgroup can be used to bind the processes in a cgroup to a specified set "
"of CPUs and NUMA nodes."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:307
msgid ""
"Further information can be found in the kernel source file I<Documentation/"
"admin-guide/cgroup-v1/cpusets.rst> (or I<Documentation/cgroup-v1/cpusets."
"txt> in Linux 5.2 and earlier)."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:308
#, no-wrap
msgid "I<memory> (since Linux 2.6.25; B<CONFIG_MEMCG>)"
msgstr "I<memory> (Linux 2.6.25 以降; B<CONFIG_MEMCG>)"

#. type: Plain text
#: build/C/man7/cgroups.7:312
msgid ""
"The memory controller supports reporting and limiting of process memory, "
"kernel memory, and swap used by cgroups."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:318
msgid ""
"Further information can be found in the kernel source file I<Documentation/"
"admin-guide/cgroup-v1/memory.rst> (or I<Documentation/cgroup-v1/memory.txt> "
"in Linux 5.2 and earlier)."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:318
#, no-wrap
msgid "I<devices> (since Linux 2.6.26; B<CONFIG_CGROUP_DEVICE>)"
msgstr "I<devices> (Linux 2.6.26 以降; B<CONFIG_CGROUP_DEVICE>)"

#. type: Plain text
#: build/C/man7/cgroups.7:325
msgid ""
"This supports controlling which processes may create (mknod) devices as well "
"as open them for reading or writing.  The policies may be specified as allow-"
"lists and deny-lists.  Hierarchy is enforced, so new rules must not violate "
"existing rules for the target or ancestor cgroups."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:331
msgid ""
"Further information can be found in the kernel source file I<Documentation/"
"admin-guide/cgroup-v1/devices.rst> (or I<Documentation/cgroup-v1/devices."
"txt> in Linux 5.2 and earlier)."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:331
#, no-wrap
msgid "I<freezer> (since Linux 2.6.28; B<CONFIG_CGROUP_FREEZER>)"
msgstr "I<freezer> (Linux 2.6.28 以降; B<CONFIG_CGROUP_FREEZER>)"

#. type: Plain text
#: build/C/man7/cgroups.7:341
msgid ""
"The I<freezer> cgroup can suspend and restore (resume) all processes in a "
"cgroup.  Freezing a cgroup I</A> also causes its children, for example, "
"processes in I</A/B>, to be frozen."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:347
msgid ""
"Further information can be found in the kernel source file I<Documentation/"
"admin-guide/cgroup-v1/freezer-subsystem.rst> (or I<Documentation/cgroup-v1/"
"freezer-subsystem.txt> in Linux 5.2 and earlier)."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:347
#, no-wrap
msgid "I<net_cls> (since Linux 2.6.29; B<CONFIG_CGROUP_NET_CLASSID>)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:356
msgid ""
"This places a classid, specified for the cgroup, on network packets created "
"by a cgroup.  These classids can then be used in firewall rules, as well as "
"used to shape traffic using B<tc>(8).  This applies only to packets leaving "
"the cgroup, not to traffic arriving at the cgroup."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:362
msgid ""
"Further information can be found in the kernel source file I<Documentation/"
"admin-guide/cgroup-v1/net_cls.rst> (or I<Documentation/cgroup-v1/net_cls."
"txt> in Linux 5.2 and earlier)."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:362
#, no-wrap
msgid "I<blkio> (since Linux 2.6.33; B<CONFIG_BLK_CGROUP>)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:369
msgid ""
"The I<blkio> cgroup controls and limits access to specified block devices by "
"applying IO control in the form of throttling and upper limits against leaf "
"nodes and intermediate nodes in the storage hierarchy."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:376
msgid ""
"Two policies are available.  The first is a proportional-weight time-based "
"division of disk implemented with CFQ.  This is in effect for leaf nodes "
"using CFQ.  The second is a throttling policy which specifies upper I/O rate "
"limits on a device."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:382
msgid ""
"Further information can be found in the kernel source file I<Documentation/"
"admin-guide/cgroup-v1/blkio-controller.rst> (or I<Documentation/cgroup-v1/"
"blkio-controller.txt> in Linux 5.2 and earlier)."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:382
#, no-wrap
msgid "I<perf_event> (since Linux 2.6.39; B<CONFIG_CGROUP_PERF>)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:387
msgid ""
"This controller allows I<perf> monitoring of the set of processes grouped in "
"a cgroup."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:389
msgid "Further information can be found in the kernel source files"
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:389
#, no-wrap
msgid "I<net_prio> (since Linux 3.3; B<CONFIG_CGROUP_NET_PRIO>)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:392
msgid ""
"This allows priorities to be specified, per network interface, for cgroups."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:398
msgid ""
"Further information can be found in the kernel source file I<Documentation/"
"admin-guide/cgroup-v1/net_prio.rst> (or I<Documentation/cgroup-v1/net_prio."
"txt> in Linux 5.2 and earlier)."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:398
#, no-wrap
msgid "I<hugetlb> (since Linux 3.5; B<CONFIG_CGROUP_HUGETLB>)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:401
msgid "This supports limiting the use of huge pages by cgroups."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:407
msgid ""
"Further information can be found in the kernel source file I<Documentation/"
"admin-guide/cgroup-v1/hugetlb.rst> (or I<Documentation/cgroup-v1/hugetlb."
"txt> in Linux 5.2 and earlier)."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:407
#, no-wrap
msgid "I<pids> (since Linux 4.3; B<CONFIG_CGROUP_PIDS>)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:411
msgid ""
"This controller permits limiting the number of process that may be created "
"in a cgroup (and its descendants)."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:417
msgid ""
"Further information can be found in the kernel source file I<Documentation/"
"admin-guide/cgroup-v1/pids.rst> (or I<Documentation/cgroup-v1/pids.txt> in "
"Linux 5.2 and earlier)."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:417
#, no-wrap
msgid "I<rdma> (since Linux 4.11; B<CONFIG_CGROUP_RDMA>)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:421
msgid ""
"The RDMA controller permits limiting the use of RDMA/IB-specific resources "
"per cgroup."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:428
msgid ""
"Further information can be found in the kernel source file I<Documentation/"
"admin-guide/cgroup-v1/rdma.rst> (or I<Documentation/cgroup-v1/rdma.txt> in "
"Linux 5.2 and earlier)."
msgstr ""

#. type: SS
#: build/C/man7/cgroups.7:428
#, no-wrap
msgid "Creating cgroups and moving processes"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:432
msgid ""
"A cgroup filesystem initially contains a single root cgroup, '/', which all "
"processes belong to.  A new cgroup is created by creating a directory in the "
"cgroup filesystem:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:436
#, no-wrap
msgid "mkdir /sys/fs/cgroup/cpu/cg1\n"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:440
msgid "This creates a new empty cgroup."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:444
msgid ""
"A process may be moved to this cgroup by writing its PID into the cgroup's "
"I<cgroup.procs> file:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:448
#, no-wrap
msgid "echo $$ E<gt> /sys/fs/cgroup/cpu/cg1/cgroup.procs\n"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:452
#, fuzzy
#| msgid "At least one line must be written to the file."
msgid "Only one PID at a time should be written to this file."
msgstr "少なくとも 1 行はファイルに書き込まなければならない。"

#. type: Plain text
#: build/C/man7/cgroups.7:456
msgid ""
"Writing the value 0 to a I<cgroup.procs> file causes the writing process to "
"be moved to the corresponding cgroup."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:460
msgid ""
"When writing a PID into the I<cgroup.procs>, all threads in the process are "
"moved into the new cgroup at once."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:466
msgid ""
"Within a hierarchy, a process can be a member of exactly one cgroup.  "
"Writing a process's PID to a I<cgroup.procs> file automatically removes it "
"from the cgroup of which it was previously a member."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:474
msgid ""
"The I<cgroup.procs> file can be read to obtain a list of the processes that "
"are members of a cgroup.  The returned list of PIDs is not guaranteed to be "
"in order.  Nor is it guaranteed to be free of duplicates.  (For example, a "
"PID may be recycled while reading from the list.)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:487
msgid ""
"In cgroups v1, an individual thread can be moved to another cgroup by "
"writing its thread ID (i.e., the kernel thread ID returned by B<clone>(2)  "
"and B<gettid>(2))  to the I<tasks> file in a cgroup directory.  This file "
"can be read to discover the set of threads that are members of the cgroup."
msgstr ""

#. type: SS
#: build/C/man7/cgroups.7:487
#, no-wrap
msgid "Removing cgroups"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:495
msgid ""
"To remove a cgroup, it must first have no child cgroups and contain no "
"(nonzombie) processes.  So long as that is the case, one can simply remove "
"the corresponding directory pathname.  Note that files in a cgroup directory "
"cannot and need not be removed."
msgstr ""

#. type: SS
#: build/C/man7/cgroups.7:495
#, no-wrap
msgid "Cgroups v1 release notification"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:500
msgid ""
"Two files can be used to determine whether the kernel provides notifications "
"when a cgroup becomes empty.  A cgroup is considered to be empty when it "
"contains no child cgroups and no member processes."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:513
msgid ""
"A special file in the root directory of each cgroup hierarchy, "
"I<release_agent>, can be used to register the pathname of a program that may "
"be invoked when a cgroup in the hierarchy becomes empty.  The pathname of "
"the newly empty cgroup (relative to the cgroup mount point)  is provided as "
"the sole command-line argument when the I<release_agent> program is "
"invoked.  The I<release_agent> program might remove the cgroup directory, or "
"perhaps repopulate it with a process."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:517
msgid ""
"The default value of the I<release_agent> file is empty, meaning that no "
"release agent is invoked."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:522
msgid ""
"The content of the I<release_agent> file can also be specified via a mount "
"option when the cgroup filesystem is mounted:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:526
#, no-wrap
msgid "mount -o release_agent=pathname ...\n"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:546
msgid ""
"Whether or not the I<release_agent> program is invoked when a particular "
"cgroup becomes empty is determined by the value in the I<notify_on_release> "
"file in the corresponding cgroup directory.  If this file contains the value "
"0, then the I<release_agent> program is not invoked.  If it contains the "
"value 1, the I<release_agent> program is invoked.  The default value for "
"this file in the root cgroup is 0.  At the time when a new cgroup is "
"created, the value in this file is inherited from the corresponding file in "
"the parent cgroup."
msgstr ""

#. type: SS
#: build/C/man7/cgroups.7:546
#, no-wrap
msgid "Cgroup v1 named hierarchies"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:549
msgid ""
"In cgroups v1, it is possible to mount a cgroup hierarchy that has no "
"attached controllers:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:553
#, no-wrap
msgid "mount -t cgroup -o none,name=somename none /some/mount/point\n"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:565
msgid ""
"Multiple instances of such hierarchies can be mounted; each hierarchy must "
"have a unique name.  The only purpose of such hierarchies is to track "
"processes.  (See the discussion of release notification below.)  An example "
"of this is the I<name=systemd> cgroup hierarchy that is used by "
"B<systemd>(1)  to track services and user sessions."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:571
msgid ""
"Since Linux 5.0, the I<cgroup_no_v1> kernel boot option (described below) "
"can be used to disable cgroup v1 named hierarchies, by specifying "
"I<cgroup_no_v1=named>."
msgstr ""

#. type: SH
#: build/C/man7/cgroups.7:573
#, no-wrap
msgid "CGROUPS VERSION 2"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:580
msgid ""
"In cgroups v2, all mounted controllers reside in a single unified "
"hierarchy.  While (different) controllers may be simultaneously mounted "
"under the v1 and v2 hierarchies, it is not possible to mount the same "
"controller simultaneously under both the v1 and the v2 hierarchies."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:583
msgid ""
"The new behaviors in cgroups v2 are summarized here, and in some cases "
"elaborated in the following subsections."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:586
msgid ""
"Cgroups v2 provides a unified hierarchy against which all controllers are "
"mounted."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:591
msgid ""
"\"Internal\" processes are not permitted.  With the exception of the root "
"cgroup, processes may reside only in leaf nodes (cgroups that do not "
"themselves contain child cgroups).  The details are somewhat more subtle "
"than this, and are described below."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:596
msgid ""
"Active cgroups must be specified via the files I<cgroup.controllers> and "
"I<cgroup.subtree_control>."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:605
msgid ""
"The I<tasks> file has been removed.  In addition, the I<cgroup."
"clone_children> file that is employed by the I<cpuset> controller has been "
"removed."
msgstr ""

#. type: IP
#: build/C/man7/cgroups.7:605
#, no-wrap
msgid "5."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:609
msgid ""
"An improved mechanism for notification of empty cgroups is provided by the "
"I<cgroup.events> file."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:616
msgid ""
"For more changes, see the I<Documentation/admin-guide/cgroup-v2.rst> file in "
"the kernel source (or I<Documentation/cgroup-v2.txt> in Linux 4.17 and "
"earlier)."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:621
msgid ""
"Some of the new behaviors listed above saw subsequent modification with the "
"addition in Linux 4.14 of \"thread mode\" (described below)."
msgstr ""

#. type: SS
#: build/C/man7/cgroups.7:621
#, no-wrap
msgid "Cgroups v2 unified hierarchy"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:633
msgid ""
"In cgroups v1, the ability to mount different controllers against different "
"hierarchies was intended to allow great flexibility for application design.  "
"In practice, though, the flexibility turned out to be less useful than "
"expected, and in many cases added complexity.  Therefore, in cgroups v2, all "
"available controllers are mounted against a single hierarchy.  The available "
"controllers are automatically mounted, meaning that it is not necessary (or "
"possible) to specify the controllers when mounting the cgroup v2 filesystem "
"using a command such as the following:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:637
#, no-wrap
msgid "mount -t cgroup2 none /mnt/cgroup2\n"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:662
msgid ""
"A cgroup v2 controller is available only if it is not currently in use via a "
"mount against a cgroup v1 hierarchy.  Or, to put things another way, it is "
"not possible to employ the same controller against both a v1 hierarchy and "
"the unified v2 hierarchy.  This means that it may be necessary first to "
"unmount a v1 controller (as described above) before that controller is "
"available in v2.  Since B<systemd>(1)  makes heavy use of some v1 "
"controllers by default, it can in some cases be simpler to boot the system "
"with selected v1 controllers disabled.  To do this, specify the "
"I<cgroup_no_v1=list> option on the kernel boot command line; I<list> is a "
"comma-separated list of the names of the controllers to disable, or the word "
"I<all> to disable all v1 controllers.  (This situation is correctly handled "
"by B<systemd>(1), which falls back to operating without the specified "
"controllers.)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:671
msgid ""
"Note that on many modern systems, B<systemd>(1)  automatically mounts the "
"I<cgroup2> filesystem at I</sys/fs/cgroup/unified> during the boot process."
msgstr ""

#. type: SS
#: build/C/man7/cgroups.7:671
#, no-wrap
msgid "Cgroups v2 mount options"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:675
msgid ""
"The following options (I<mount -o>)  can be specified when mounting the "
"group v2 filesystem:"
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:675 build/C/man7/cgroups.7:1907
#, no-wrap
msgid "I<nsdelegate> (since Linux 4.15)"
msgstr "I<nsdelegate> (Linux 4.15 以降)"

#. type: Plain text
#: build/C/man7/cgroups.7:679
msgid ""
"Treat cgroup namespaces as delegation boundaries.  For details, see below."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:679 build/C/man7/cgroups.7:1902
#, no-wrap
msgid "I<memory_localevents> (since Linux 5.2)"
msgstr "I<memory_localevents> (Linux 5.2 以降)"

#.  commit 9852ae3fe5293264f01c49f2571ef7688f7823ce
#. type: Plain text
#: build/C/man7/cgroups.7:695
msgid ""
"The I<memory.events> should show statistics only for the cgroup itself, and "
"not for any descendant cgroups.  This was the behavior before Linux 5.2.  "
"Starting in Linux 5.2, the default behavior is to include statistics for "
"descendant cgroups in I<memory.events>, and this mount option can be used to "
"revert to the legacy behavior.  This option is system wide and can be set on "
"mount or modified through remount only from the initial mount namespace; it "
"is silently ignored in noninitial namespaces."
msgstr ""

#. type: SS
#: build/C/man7/cgroups.7:695
#, no-wrap
msgid "Cgroups v2 controllers"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:702
msgid ""
"The following controllers, documented in the kernel source file "
"I<Documentation/admin-guide/cgroup-v2.rst> (or I<Documentation/cgroup-v2."
"txt> in Linux 4.17 and earlier), are supported in cgroups version 2:"
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:702
#, no-wrap
msgid "I<cpu> (since Linux 4.15)"
msgstr "I<cpu> (Linux 4.15 以降)"

#. type: Plain text
#: build/C/man7/cgroups.7:709
msgid ""
"This is the successor to the version 1 I<cpu> and I<cpuacct> controllers."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:709
#, no-wrap
msgid "I<cpuset> (since Linux 5.0)"
msgstr "I<cpuset> (Linux 5.0 以降)"

#. type: Plain text
#: build/C/man7/cgroups.7:714
msgid "This is the successor of the version 1 I<cpuset> controller."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:714
#, no-wrap
msgid "I<freezer> (since Linux 5.2)"
msgstr "I<freezer> (Linux 5.2 以降)"

#.  commit 76f969e8948d82e78e1bc4beb6b9465908e74873
#. type: Plain text
#: build/C/man7/cgroups.7:720
msgid "This is the successor of the version 1 I<freezer> controller."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:720
#, no-wrap
msgid "I<hugetlb> (since Linux 5.6)"
msgstr "I<hugetlb> (Linux 5.6 以降)"

#. type: Plain text
#: build/C/man7/cgroups.7:725
msgid "This is the successor of the version 1 I<hugetlb> controller."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:725
#, no-wrap
msgid "I<io> (since Linux 4.5)"
msgstr "I<io> (Linux 4.5 以降)"

#. type: Plain text
#: build/C/man7/cgroups.7:730
msgid "This is the successor of the version 1 I<blkio> controller."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:730
#, no-wrap
msgid "I<memory> (since Linux 4.5)"
msgstr "I<memory> (Linux 4.5 以降)"

#. type: Plain text
#: build/C/man7/cgroups.7:735
msgid "This is the successor of the version 1 I<memory> controller."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:735
#, no-wrap
msgid "I<perf_event> (since Linux 4.11)"
msgstr "I<perf_event> (Linux 4.11 以降)"

#. type: Plain text
#: build/C/man7/cgroups.7:740
msgid "This is the same as the version 1 I<perf_event> controller."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:740
#, no-wrap
msgid "I<pids> (since Linux 4.5)"
msgstr "I<pids> (Linux 4.5 以降)"

#. type: Plain text
#: build/C/man7/cgroups.7:745
msgid "This is the same as the version 1 I<pids> controller."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:745
#, no-wrap
msgid "I<rdma> (since Linux 4.11)"
msgstr "I<rdma> (Linux 4.11 以降)"

#. type: Plain text
#: build/C/man7/cgroups.7:750
msgid "This is the same as the version 1 I<rdma> controller."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:760
msgid ""
"There is no direct equivalent of the I<net_cls> and I<net_prio> controllers "
"from cgroups version 1.  Instead, support has been added to B<iptables>(8)  "
"to allow eBPF filters that hook on cgroup v2 pathnames to make decisions "
"about network traffic on a per-cgroup basis."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:768
msgid ""
"The v2 I<devices> controller provides no interface files; instead, device "
"control is gated by attaching an eBPF (B<BPF_CGROUP_DEVICE>)  program to a "
"v2 cgroup."
msgstr ""

#. type: SS
#: build/C/man7/cgroups.7:768
#, no-wrap
msgid "Cgroups v2 subtree control"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:770
msgid "Each cgroup in the v2 hierarchy contains the following two files:"
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:770
#, no-wrap
msgid "I<cgroup.controllers>"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:778
msgid ""
"This read-only file exposes a list of the controllers that are I<available> "
"in this cgroup.  The contents of this file match the contents of the "
"I<cgroup.subtree_control> file in the parent cgroup."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:778
#, no-wrap
msgid "I<cgroup.subtree_control>"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:791
msgid ""
"This is a list of controllers that are I<active> (I<enabled>)  in the "
"cgroup.  The set of controllers in this file is a subset of the set in the "
"I<cgroup.controllers> of this cgroup.  The set of active controllers is "
"modified by writing strings to this file containing space-delimited "
"controller names, each preceded by '+' (to enable a controller)  or '-' (to "
"disable a controller), as in the following example:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:795
#, no-wrap
msgid "echo \\(aq+pids -memory\\(aq E<gt> x/y/cgroup.subtree_control\n"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:806
msgid ""
"An attempt to enable a controller that is not present in I<cgroup."
"controllers> leads to an B<ENOENT> error when writing to the I<cgroup."
"subtree_control> file."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:813
msgid ""
"Because the list of controllers in I<cgroup.subtree_control> is a subset of "
"those I<cgroup.controllers>, a controller that has been disabled in one "
"cgroup in the hierarchy can never be re-enabled in the subtree below that "
"cgroup."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:829
msgid ""
"A cgroup's I<cgroup.subtree_control> file determines the set of controllers "
"that are exercised in the I<child> cgroups.  When a controller (e.g., "
"I<pids>)  is present in the I<cgroup.subtree_control> file of a parent "
"cgroup, then the corresponding controller-interface files (e.g., I<pids."
"max>)  are automatically created in the children of that cgroup and can be "
"used to exert resource control in the child cgroups."
msgstr ""

#. type: SS
#: build/C/man7/cgroups.7:829
#, no-wrap
msgid "Cgroups v2 \"no internal processes\" rule"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:836
msgid ""
"Cgroups v2 enforces a so-called \"no internal processes\" rule.  Roughly "
"speaking, this rule means that, with the exception of the root cgroup, "
"processes may reside only in leaf nodes (cgroups that do not themselves "
"contain child cgroups).  This avoids the need to decide how to partition "
"resources between processes which are members of cgroup A and processes in "
"child cgroups of A."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:860
msgid ""
"For instance, if cgroup I</cg1/cg2> exists, then a process may reside in I</"
"cg1/cg2>, but not in I</cg1>.  This is to avoid an ambiguity in cgroups v1 "
"with respect to the delegation of resources between processes in I</cg1> and "
"its child cgroups.  The recommended approach in cgroups v2 is to create a "
"subdirectory called I<leaf> for any nonleaf cgroup which should contain "
"processes, but no child cgroups.  Thus, processes which previously would "
"have gone into I</cg1> would now go into I</cg1/leaf>.  This has the "
"advantage of making explicit the relationship between processes in I</cg1/"
"leaf> and I</cg1>'s other children."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:873
msgid ""
"The \"no internal processes\" rule is in fact more subtle than stated "
"above.  More precisely, the rule is that a (nonroot) cgroup can't both (1) "
"have member processes, and (2) distribute resources into child cgroups"
"\\(emthat is, have a nonempty I<cgroup.subtree_control> file.  Thus, it "
"I<is> possible for a cgroup to have both member processes and child cgroups, "
"but before controllers can be enabled for that cgroup, the member processes "
"must be moved out of the cgroup (e.g., perhaps into the child cgroups)."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:877
msgid ""
"With the Linux 4.14 addition of \"thread mode\" (described below), the \"no "
"internal processes\" rule has been relaxed in some cases."
msgstr ""

#. type: SS
#: build/C/man7/cgroups.7:877
#, no-wrap
msgid "Cgroups v2 cgroup.events file"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:883
msgid ""
"Each nonroot cgroup in the v2 hierarchy contains a read-only file, I<cgroup."
"events>, whose contents are key-value pairs (delimited by newline "
"characters, with the key and value separated by spaces)  providing state "
"information about the cgroup:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:889
#, no-wrap
msgid ""
"$ B<cat mygrp/cgroup.events>\n"
"populated 1\n"
"frozen 0\n"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:893
msgid "The following keys may appear in this file:"
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:893
#, no-wrap
msgid "I<populated>"
msgstr "I<populated>"

#. type: Plain text
#: build/C/man7/cgroups.7:898
msgid ""
"The value of this key is either 1, if this cgroup or any of its descendants "
"has member processes, or otherwise 0."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:898
#, no-wrap
msgid "I<frozen> (since Linux 5.2)"
msgstr "I<frozen> (Linux 5.2 以降)"

#.  commit 76f969e8948d82e78e1bc4beb6b9465908e7487
#. type: Plain text
#: build/C/man7/cgroups.7:903
msgid ""
"The value of this key is 1 if this cgroup is currently frozen, or 0 if it is "
"not."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:922
msgid ""
"The I<cgroup.events> file can be monitored, in order to receive notification "
"when the value of one of its keys changes.  Such monitoring can be done "
"using B<inotify>(7), which notifies changes as B<IN_MODIFY> events, or "
"B<poll>(2), which notifies changes by returning the B<POLLPRI> and "
"B<POLLERR> bits in the I<revents> field."
msgstr ""

#. type: SS
#: build/C/man7/cgroups.7:922
#, no-wrap
msgid "Cgroup v2 release notification"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:939
msgid ""
"Cgroups v2 provides a new mechanism for obtaining notification when a cgroup "
"becomes empty.  The cgroups v1 I<release_agent> and I<notify_on_release> "
"files are removed, and replaced by the I<populated> key in the I<cgroup."
"events> file.  This key either has the value 0, meaning that the cgroup (and "
"its descendants)  contain no (nonzombie) member processes, or 1, meaning "
"that the cgroup (or one of its descendants)  contains member processes."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:944
msgid ""
"The cgroups v2 release-notification mechanism offers the following "
"advantages over the cgroups v1 I<release_agent> mechanism:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:951
msgid ""
"It allows for cheaper notification, since a single process can monitor "
"multiple I<cgroup.events> files (using the techniques described earlier).  "
"By contrast, the cgroups v1 mechanism requires the expense of creating a "
"process for each notification."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:957
msgid ""
"Notification for different cgroup subhierarchies can be delegated to "
"different processes.  By contrast, the cgroups v1 mechanism allows only one "
"release agent for an entire hierarchy."
msgstr ""

#. type: SS
#: build/C/man7/cgroups.7:957
#, no-wrap
msgid "Cgroups v2 cgroup.stat file"
msgstr ""

#.  commit ec39225cca42c05ac36853d11d28f877fde5c42e
#. type: Plain text
#: build/C/man7/cgroups.7:964
msgid ""
"Each cgroup in the v2 hierarchy contains a read-only I<cgroup.stat> file "
"(first introduced in Linux 4.14)  that consists of lines containing key-"
"value pairs.  The following keys currently appear in this file:"
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:964
#, no-wrap
msgid "I<nr_descendants>"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:968
msgid ""
"This is the total number of visible (i.e., living) descendant cgroups "
"underneath this cgroup."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:968
#, no-wrap
msgid "I<nr_dying_descendants>"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:978
msgid ""
"This is the total number of dying descendant cgroups underneath this "
"cgroup.  A cgroup enters the dying state after being deleted.  It remains in "
"that state for an undefined period (which will depend on system load)  while "
"resources are freed before the cgroup is destroyed.  Note that the presence "
"of some cgroups in the dying state is normal, and is not indicative of any "
"problem."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:982
msgid ""
"A process can't be made a member of a dying cgroup, and a dying cgroup can't "
"be brought back to life."
msgstr ""

#. type: SS
#: build/C/man7/cgroups.7:982
#, no-wrap
msgid "Limiting the number of descendant cgroups"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:986
msgid ""
"Each cgroup in the v2 hierarchy contains the following files, which can be "
"used to view and set limits on the number of descendant cgroups under that "
"cgroup:"
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:986
#, no-wrap
msgid "I<cgroup.max.depth> (since Linux 4.14)"
msgstr "I<cgroup.max.depth> (Linux 4.14 以降)"

#.  commit 1a926e0bbab83bae8207d05a533173425e0496d1
#. type: Plain text
#: build/C/man7/cgroups.7:996
msgid ""
"This file defines a limit on the depth of nesting of descendant cgroups.  A "
"value of 0 in this file means that no descendant cgroups can be created.  An "
"attempt to create a descendant whose nesting level exceeds the limit fails "
"(I<mkdir>(2)  fails with the error B<EAGAIN>)."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1002 build/C/man7/cgroups.7:1018
msgid ""
"Writing the string I<\"max\"> to this file means that no limit is imposed.  "
"The default value in this file is I<\"max\">."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:1002
#, no-wrap
msgid "I<cgroup.max.descendants> (since Linux 4.14)"
msgstr "I<cgroup.max.descendants> (Linux 4.14 以降)"

#.  commit 1a926e0bbab83bae8207d05a533173425e0496d1
#. type: Plain text
#: build/C/man7/cgroups.7:1011
msgid ""
"This file defines a limit on the number of live descendant cgroups that this "
"cgroup may have.  An attempt to create more descendants than allowed by the "
"limit fails (I<mkdir>(2)  fails with the error B<EAGAIN>)."
msgstr ""

#. type: SH
#: build/C/man7/cgroups.7:1018
#, no-wrap
msgid "CGROUPS DELEGATION: DELEGATING A HIERARCHY TO A LESS PRIVILEGED USER"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1028
msgid ""
"In the context of cgroups, delegation means passing management of some "
"subtree of the cgroup hierarchy to a nonprivileged user.  Cgroups v1 "
"provides support for delegation based on file permissions in the cgroup "
"hierarchy but with less strict containment rules than v2 (as noted below).  "
"Cgroups v2 supports delegation with containment by explicit design.  The "
"focus of the discussion in this section is on delegation in cgroups v2, with "
"some differences for cgroups v1 noted along the way."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1039
msgid ""
"Some terminology is required in order to describe delegation.  A "
"I<delegater> is a privileged user (i.e., root) who owns a parent cgroup.  A "
"I<delegatee> is a nonprivileged user who will be granted the permissions "
"needed to manage some subhierarchy under that parent cgroup, known as the "
"I<delegated subtree>."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1048
msgid ""
"To perform delegation, the delegater makes certain directories and files "
"writable by the delegatee, typically by changing the ownership of the "
"objects to be the user ID of the delegatee.  Assuming that we want to "
"delegate the hierarchy rooted at (say)  I</dlgt_grp> and that there are not "
"yet any child cgroups under that cgroup, the ownership of the following is "
"changed to the user ID of the delegatee:"
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:1048
#, no-wrap
msgid "I</dlgt_grp>"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1053
msgid ""
"Changing the ownership of the root of the subtree means that any new cgroups "
"created under the subtree (and the files they contain)  will also be owned "
"by the delegatee."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:1053
#, no-wrap
msgid "I</dlgt_grp/cgroup.procs>"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1057
msgid ""
"Changing the ownership of this file means that the delegatee can move "
"processes into the root of the delegated subtree."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:1057
#, no-wrap
msgid "I</dlgt_grp/cgroup.subtree_control> (cgroups v2 only)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1065
msgid ""
"Changing the ownership of this file means that the delegatee can enable "
"controllers (that are present in I</dlgt_grp/cgroup.controllers>)  in order "
"to further redistribute resources at lower levels in the subtree.  (As an "
"alternative to changing the ownership of this file, the delegater might "
"instead add selected controllers to this file.)"
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:1065
#, no-wrap
msgid "I</dlgt_grp/cgroup.threads> (cgroups v2 only)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1076
msgid ""
"Changing the ownership of this file is necessary if a threaded subtree is "
"being delegated (see the description of \"thread mode\", below).  This "
"permits the delegatee to write thread IDs to the file.  (The ownership of "
"this file can also be changed when delegating a domain subtree, but "
"currently this serves no purpose, since, as described below, it is not "
"possible to move a thread between domain cgroups by writing its thread ID to "
"the I<cgroup.threads> file.)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1080
msgid ""
"In cgroups v1, the corresponding file that should instead be delegated is "
"the I<tasks> file."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1092
msgid ""
"The delegater should I<not> change the ownership of any of the controller "
"interfaces files (e.g., I<pids.max>, I<memory.high>)  in I<dlgt_grp>.  Those "
"files are used from the next level above the delegated subtree in order to "
"distribute resources into the subtree, and the delegatee should not have "
"permission to change the resources that are distributed into the delegated "
"subtree."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1096
msgid ""
"See also the discussion of the I</sys/kernel/cgroup/delegate> file in NOTES "
"for information about further delegatable files in cgroups v2."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1108
msgid ""
"After the aforementioned steps have been performed, the delegatee can create "
"child cgroups within the delegated subtree (the cgroup subdirectories and "
"the files they contain will be owned by the delegatee)  and move processes "
"between cgroups in the subtree.  If some controllers are present in "
"I<dlgt_grp/cgroup.subtree_control>, or the ownership of that file was passed "
"to the delegatee, the delegatee can also control the further redistribution "
"of the corresponding resources into the delegated subtree."
msgstr ""

#. type: SS
#: build/C/man7/cgroups.7:1108
#, no-wrap
msgid "Cgroups v2 delegation: nsdelegate and cgroup namespaces"
msgstr ""

#.  commit 5136f6365ce3eace5a926e10f16ed2a233db5ba9
#. type: Plain text
#: build/C/man7/cgroups.7:1119
msgid ""
"Starting with Linux 4.13, there is a second way to perform cgroup delegation "
"in the cgroups v2 hierarchy.  This is done by mounting or remounting the "
"cgroup v2 filesystem with the I<nsdelegate> mount option.  For example, if "
"the cgroup v2 filesystem has already been mounted, we can remount it with "
"the I<nsdelegate> option as follows:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1124
#, no-wrap
msgid ""
"mount -t cgroup2 -o remount,nsdelegate \\e\n"
"                 none /sys/fs/cgroup/unified\n"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1138
msgid ""
"The effect of this mount option is to cause cgroup namespaces to "
"automatically become delegation boundaries.  More specifically, the "
"following restrictions apply for processes inside the cgroup namespace:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1148
msgid ""
"Writes to controller interface files in the root directory of the namespace "
"will fail with the error B<EPERM>.  Processes inside the cgroup namespace "
"can still write to delegatable files in the root directory of the cgroup "
"namespace such as I<cgroup.procs> and I<cgroup.subtree_control>, and can "
"create subhierarchy underneath the root directory."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1157
msgid ""
"Attempts to migrate processes across the namespace boundary are denied (with "
"the error B<ENOENT>).  Processes inside the cgroup namespace can still "
"(subject to the containment rules described below)  move processes between "
"cgroups I<within> the subhierarchy under the namespace root."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1175
msgid ""
"The ability to define cgroup namespaces as delegation boundaries makes "
"cgroup namespaces more useful.  To understand why, suppose that we already "
"have one cgroup hierarchy that has been delegated to a nonprivileged user, "
"I<cecilia>, using the older delegation technique described above.  Suppose "
"further that I<cecilia> wanted to further delegate a subhierarchy under the "
"existing delegated hierarchy.  (For example, the delegated hierarchy might "
"be associated with an unprivileged container run by I<cecilia>.)  Even if a "
"cgroup namespace was employed, because both hierarchies are owned by the "
"unprivileged user I<cecilia>, the following illegitimate actions could be "
"performed:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1183
msgid ""
"A process in the inferior hierarchy could change the resource controller "
"settings in the root directory of that hierarchy.  (These resource "
"controller settings are intended to allow control to be exercised from the "
"I<parent> cgroup; a process inside the child cgroup should not be allowed to "
"modify them.)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1187
msgid ""
"A process inside the inferior hierarchy could move processes into and out of "
"the inferior hierarchy if the cgroups in the superior hierarchy were somehow "
"visible."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1191
msgid ""
"Employing the I<nsdelegate> mount option prevents both of these "
"possibilities."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1197
msgid ""
"The I<nsdelegate> mount option only has an effect when performed in the "
"initial mount namespace; in other mount namespaces, the option is silently "
"ignored."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1206
msgid ""
"I<Note>: On some systems, B<systemd>(1)  automatically mounts the cgroup v2 "
"filesystem.  In order to experiment with the I<nsdelegate> operation, it may "
"be useful to boot the kernel with the following command-line options:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1210
#, no-wrap
msgid "cgroup_no_v1=all systemd.legacy_systemd_cgroup_controller\n"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1221
msgid ""
"These options cause the kernel to boot with the cgroups v1 controllers "
"disabled (meaning that the controllers are available in the v2 hierarchy), "
"and tells B<systemd>(1)  not to mount and use the cgroup v2 hierarchy, so "
"that the v2 hierarchy can be manually mounted with the desired options after "
"boot-up."
msgstr ""

#. type: SS
#: build/C/man7/cgroups.7:1221
#, no-wrap
msgid "Cgroup delegation containment rules"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1232
msgid ""
"Some delegation I<containment rules> ensure that the delegatee can move "
"processes between cgroups within the delegated subtree, but can't move "
"processes from outside the delegated subtree into the subtree or vice "
"versa.  A nonprivileged process (i.e., the delegatee) can write the PID of a "
"\"target\" process into a I<cgroup.procs> file only if all of the following "
"are true:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1236
msgid ""
"The writer has write permission on the I<cgroup.procs> file in the "
"destination cgroup."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1246
msgid ""
"The writer has write permission on the I<cgroup.procs> file in the nearest "
"common ancestor of the source and destination cgroups.  Note that in some "
"cases, the nearest common ancestor may be the source or destination cgroup "
"itself.  This requirement is not enforced for cgroups v1 hierarchies, with "
"the consequence that containment in v1 is less strict than in v2.  (For "
"example, in cgroups v1 the user that owns two distinct delegated "
"subhierarchies can move a process between the hierarchies.)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1251
msgid ""
"If the cgroup v2 filesystem was mounted with the I<nsdelegate> option, the "
"writer must be able to see the source and destination cgroups from its "
"cgroup namespace."
msgstr ""

#.  commit 576dd464505fc53d501bb94569db76f220104d28
#. type: Plain text
#: build/C/man7/cgroups.7:1261
msgid ""
"In cgroups v1: the effective UID of the writer (i.e., the delegatee) matches "
"the real user ID or the saved set-user-ID of the target process.  Before "
"Linux 4.11, this requirement also applied in cgroups v2 (This was a "
"historical requirement inherited from cgroups v1 that was later deemed "
"unnecessary, since the other rules suffice for containment in cgroups v2.)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1269
msgid ""
"I<Note>: one consequence of these delegation containment rules is that the "
"unprivileged delegatee can't place the first process into the delegated "
"subtree; instead, the delegater must place the first process (a process "
"owned by the delegatee) into the delegated subtree."
msgstr ""

#. type: SH
#: build/C/man7/cgroups.7:1269
#, no-wrap
msgid "CGROUPS VERSION 2 THREAD MODE"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1272
msgid ""
"Among the restrictions imposed by cgroups v2 that were not present in "
"cgroups v1 are the following:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1275
msgid ""
"I<No thread-granularity control>: all of the threads of a process must be in "
"the same cgroup."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1279
msgid ""
"I<No internal processes>: a cgroup can't both have member processes and "
"exercise controllers on child cgroups."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1291
msgid ""
"Both of these restrictions were added because the lack of these restrictions "
"had caused problems in cgroups v1.  In particular, the cgroups v1 ability to "
"allow thread-level granularity for cgroup membership made no sense for some "
"controllers.  (A notable example was the I<memory> controller: since threads "
"share an address space, it made no sense to split threads across different "
"I<memory> cgroups.)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1300
msgid ""
"Notwithstanding the initial design decision in cgroups v2, there were use "
"cases for certain controllers, notably the I<cpu> controller, for which "
"thread-level granularity of control was meaningful and useful.  To "
"accommodate such use cases, Linux 4.14 added I<thread mode> for cgroups v2."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1302
msgid "Thread mode allows the following:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1308
msgid ""
"The creation of I<threaded subtrees> in which the threads of a process may "
"be spread across cgroups inside the tree.  (A threaded subtree may contain "
"multiple multithreaded processes.)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1312
msgid ""
"The concept of I<threaded controllers>, which can distribute resources "
"across the cgroups in a threaded subtree."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1317
msgid ""
"A relaxation of the \"no internal processes rule\", so that, within a "
"threaded subtree, a cgroup can both contain member threads and exercise "
"resource control over child cgroups."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1324
msgid ""
"With the addition of thread mode, each nonroot cgroup now contains a new "
"file, I<cgroup.type>, that exposes, and in some circumstances can be used to "
"change, the \"type\" of a cgroup.  This file contains one of the following "
"type values:"
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:1324
#, no-wrap
msgid "I<domain>"
msgstr "I<domain>"

#. type: Plain text
#: build/C/man7/cgroups.7:1332
msgid ""
"This is a normal v2 cgroup that provides process-granularity control.  If a "
"process is a member of this cgroup, then all threads of the process are (by "
"definition) in the same cgroup.  This is the default cgroup type, and "
"provides the same behavior that was provided for cgroups in the initial "
"cgroups v2 implementation."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:1332
#, no-wrap
msgid "I<threaded>"
msgstr "I<threaded>"

#. type: Plain text
#: build/C/man7/cgroups.7:1337
msgid ""
"This cgroup is a member of a threaded subtree.  Threads can be added to this "
"cgroup, and controllers can be enabled for the cgroup."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:1337
#, no-wrap
msgid "I<domain threaded>"
msgstr "I<domain threaded>"

#. type: Plain text
#: build/C/man7/cgroups.7:1341
msgid ""
"This is a domain cgroup that serves as the root of a threaded subtree.  This "
"cgroup type is also known as \"threaded root\"."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:1341
#, no-wrap
msgid "I<domain invalid>"
msgstr "I<domain invalid>"

#. type: Plain text
#: build/C/man7/cgroups.7:1355
msgid ""
"This is a cgroup inside a threaded subtree that is in an \"invalid\" state.  "
"Processes can't be added to the cgroup, and controllers can't be enabled for "
"the cgroup.  The only thing that can be done with this cgroup (other than "
"deleting it)  is to convert it to a I<threaded> cgroup by writing the string "
"I<\"threaded\"> to the I<cgroup.type> file."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1364
msgid ""
"The rationale for the existence of this \"interim\" type during the creation "
"of a threaded subtree (rather than the kernel simply immediately converting "
"all cgroups under the threaded root to the type I<threaded>)  is to allow "
"for possible future extensions to the thread mode model"
msgstr ""

#. type: SS
#: build/C/man7/cgroups.7:1364
#, no-wrap
msgid "Threaded versus domain controllers"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1367
msgid ""
"With the addition of threads mode, cgroups v2 now distinguishes two types of "
"resource controllers:"
msgstr ""

#.  In the kernel source, look for ".threaded[ \t]*= true" in
#.  initializations of struct cgroup_subsys
#. type: Plain text
#: build/C/man7/cgroups.7:1380
msgid ""
"I<Threaded> controllers: these controllers support thread-granularity for "
"resource control and can be enabled inside threaded subtrees, with the "
"result that the corresponding controller-interface files appear inside the "
"cgroups in the threaded subtree.  As at Linux 4.19, the following "
"controllers are threaded: I<cpu>, I<perf_event>, and I<pids>."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1388
msgid ""
"I<Domain> controllers: these controllers support only process granularity "
"for resource control.  From the perspective of a domain controller, all "
"threads of a process are always in the same cgroup.  Domain controllers "
"can't be enabled inside a threaded subtree."
msgstr ""

#. type: SS
#: build/C/man7/cgroups.7:1388
#, no-wrap
msgid "Creating a threaded subtree"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1391
msgid ""
"There are two pathways that lead to the creation of a threaded subtree.  The "
"first pathway proceeds as follows:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1401
msgid ""
"We write the string I<\"threaded\"> to the I<cgroup.type> file of a cgroup "
"I<y/z> that currently has the type I<domain>.  This has the following "
"effects:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1407
msgid "The type of the cgroup I<y/z> becomes I<threaded>."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1414
msgid ""
"The type of the parent cgroup, I<y>, becomes I<domain threaded>.  The parent "
"cgroup is the root of a threaded subtree (also known as the \"threaded root"
"\")."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1427
msgid ""
"All other cgroups under I<y> that were not already of type I<threaded> "
"(because they were inside already existing threaded subtrees under the new "
"threaded root)  are converted to type I<domain invalid>.  Any subsequently "
"created cgroups under I<y> will also have the type I<domain invalid>."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1445
msgid ""
"We write the string I<\"threaded\"> to each of the I<domain invalid> cgroups "
"under I<y>, in order to convert them to the type I<threaded>.  As a "
"consequence of this step, all threads under the threaded root now have the "
"type I<threaded> and the threaded subtree is now fully usable.  The "
"requirement to write I<\"threaded\"> to each of these cgroups is somewhat "
"cumbersome, but allows for possible future extensions to the thread-mode "
"model."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1447
msgid "The second way of creating a threaded subtree is as follows:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1457
msgid ""
"In an existing cgroup, I<z>, that currently has the type I<domain>, we (1) "
"enable one or more threaded controllers and (2) make a process a member of "
"I<z>.  (These two steps can be done in either order.)  This has the "
"following consequences:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1463
msgid "The type of I<z> becomes I<domain threaded>."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1470
msgid ""
"All of the descendant cgroups of I<x> that were not already of type "
"I<threaded> are converted to type I<domain invalid>."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1480
msgid ""
"As before, we make the threaded subtree usable by writing the string I<"
"\"threaded\"> to each of the I<domain invalid> cgroups under I<y>, in order "
"to convert them to the type I<threaded>."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1496
msgid ""
"One of the consequences of the above pathways to creating a threaded subtree "
"is that the threaded root cgroup can be a parent only to I<threaded> (and "
"I<domain invalid>)  cgroups.  The threaded root cgroup can't be a parent of "
"a I<domain> cgroups, and a I<threaded> cgroup can't have a sibling that is a "
"I<domain> cgroup."
msgstr ""

#. type: SS
#: build/C/man7/cgroups.7:1496
#, no-wrap
msgid "Using a threaded subtree"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1502
msgid ""
"Within a threaded subtree, threaded controllers can be enabled in each "
"subgroup whose type has been changed to I<threaded>; upon doing so, the "
"corresponding controller interface files appear in the children of that "
"cgroup."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1516
msgid ""
"A process can be moved into a threaded subtree by writing its PID to the "
"I<cgroup.procs> file in one of the cgroups inside the tree.  This has the "
"effect of making all of the threads in the process members of the "
"corresponding cgroup and makes the process a member of the threaded "
"subtree.  The threads of the process can then be spread across the threaded "
"subtree by writing their thread IDs (see B<gettid>(2))  to the I<cgroup."
"threads> files in different cgroups inside the subtree.  The threads of a "
"process must all reside in the same threaded subtree."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1522
msgid ""
"As with writing to I<cgroup.procs>, some containment rules apply when "
"writing to the I<cgroup.threads> file:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1526
msgid ""
"The writer must have write permission on the cgroup.threads file in the "
"destination cgroup."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1532
msgid ""
"The writer must have write permission on the I<cgroup.procs> file in the "
"common ancestor of the source and destination cgroups.  (In some cases, the "
"common ancestor may be the source or destination cgroup itself.)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1541
msgid ""
"The source and destination cgroups must be in the same threaded subtree.  "
"(Outside a threaded subtree, an attempt to move a thread by writing its "
"thread ID to the I<cgroup.threads> file in a different I<domain> cgroup "
"fails with the error B<EOPNOTSUPP>.)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1550
msgid ""
"The I<cgroup.threads> file is present in each cgroup (including I<domain> "
"cgroups) and can be read in order to discover the set of threads that is "
"present in the cgroup.  The set of thread IDs obtained when reading this "
"file is not guaranteed to be ordered or free of duplicates."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1558
msgid ""
"The I<cgroup.procs> file in the threaded root shows the PIDs of all "
"processes that are members of the threaded subtree.  The I<cgroup.procs> "
"files in the other cgroups in the subtree are not readable."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1566
msgid ""
"Domain controllers can't be enabled in a threaded subtree; no controller-"
"interface files appear inside the cgroups underneath the threaded root.  "
"From the point of view of a domain controller, threaded subtrees are "
"invisible: a multithreaded process inside a threaded subtree appears to a "
"domain controller as a process that resides in the threaded root cgroup."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1571
msgid ""
"Within a threaded subtree, the \"no internal processes\" rule does not "
"apply: a cgroup can both contain member processes (or thread)  and exercise "
"controllers on child cgroups."
msgstr ""

#. type: SS
#: build/C/man7/cgroups.7:1571
#, no-wrap
msgid "Rules for writing to cgroup.type and creating threaded subtrees"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1575
msgid "A number of rules apply when writing to the I<cgroup.type> file:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1583
msgid ""
"Only the string I<\"threaded\"> may be written.  In other words, the only "
"explicit transition that is possible is to convert a I<domain> cgroup to "
"type I<threaded>."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1589
msgid ""
"The effect of writing I<\"threaded\"> depends on the current value in "
"I<cgroup.type>, as follows:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1597
msgid ""
"I<domain> or I<domain threaded>: start the creation of a threaded subtree "
"(whose root is the parent of this cgroup) via the first of the pathways "
"described above;"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1602
msgid ""
"I<domain\\ invalid>: convert this cgroup (which is inside a threaded "
"subtree) to a usable (i.e., I<threaded>)  state;"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1605
msgid "I<threaded>: no effect (a \"no-op\")."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1614
msgid ""
"We can't write to a I<cgroup.type> file if the parent's type is I<domain "
"invalid>.  In other words, the cgroups of a threaded subtree must be "
"converted to the I<threaded> state in a top-down manner."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1618
msgid ""
"There are also some constraints that must be satisfied in order to create a "
"threaded subtree rooted at the cgroup I<x>:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1624
msgid ""
"There can be no member processes in the descendant cgroups of I<x>.  (The "
"cgroup I<x> can itself have member processes.)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1629
msgid ""
"No domain controllers may be enabled in I<x>'s I<cgroup.subtree_control> "
"file."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1637
msgid ""
"If any of the above constraints is violated, then an attempt to write I<"
"\"threaded\"> to a I<cgroup.type> file fails with the error B<ENOTSUP>."
msgstr ""

#. type: SS
#: build/C/man7/cgroups.7:1637
#, no-wrap
msgid "The \"domain threaded\" cgroup type"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1642
msgid ""
"According to the pathways described above, the type of a cgroup can change "
"to I<domain threaded> in either of the following cases:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1646
msgid "The string I<\"threaded\"> is written to a child cgroup."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1649
msgid ""
"A threaded controller is enabled inside the cgroup and a process is made a "
"member of the cgroup."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1664
msgid ""
"A I<domain threaded> cgroup, I<x>, can revert to the type I<domain> if the "
"above conditions no longer hold true\\(emthat is, if all I<threaded> child "
"cgroups of I<x> are removed and either I<x> no longer has threaded "
"controllers enabled or no longer has member processes."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1671
msgid "When a I<domain threaded> cgroup I<x> reverts to the type I<domain>:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1678
msgid ""
"All I<domain invalid> descendants of I<x> that are not in lower-level "
"threaded subtrees revert to the type I<domain>."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1682
msgid ""
"The root cgroups in any lower-level threaded subtrees revert to the type "
"I<domain threaded>."
msgstr ""

#. type: SS
#: build/C/man7/cgroups.7:1682
#, no-wrap
msgid "Exceptions for the root cgroup"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1694
msgid ""
"The root cgroup of the v2 hierarchy is treated exceptionally: it can be the "
"parent of both I<domain> and I<threaded> cgroups.  If the string I<\"threaded"
"\"> is written to the I<cgroup.type> file of one of the children of the root "
"cgroup, then"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1697
msgid "The type of that cgroup becomes I<threaded>."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1701
msgid ""
"The type of any descendants of that cgroup that are not part of lower-level "
"threaded subtrees changes to I<domain invalid>."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1707
msgid ""
"Note that in this case, there is no cgroup whose type becomes I<domain "
"threaded>.  (Notionally, the root cgroup can be considered as the threaded "
"root for the cgroup whose type was changed to I<threaded>.)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1714
msgid ""
"The aim of this exceptional treatment for the root cgroup is to allow a "
"threaded cgroup that employs the I<cpu> controller to be placed as high as "
"possible in the hierarchy, so as to minimize the (small) cost of traversing "
"the cgroup hierarchy."
msgstr ""

#. type: SS
#: build/C/man7/cgroups.7:1714
#, no-wrap
msgid "The cgroups v2 \"cpu\" controller and realtime threads"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1737
msgid ""
"As at Linux 4.19, the cgroups v2 I<cpu> controller does not support control "
"of realtime threads (specifically threads scheduled under any of the "
"policies B<SCHED_FIFO>, B<SCHED_RR>, described B<SCHED_DEADLINE>; see "
"B<sched>(7)).  Therefore, the I<cpu> controller can be enabled in the root "
"cgroup only if all realtime threads are in the root cgroup.  (If there are "
"realtime threads in nonroot cgroups, then a B<write>(2)  of the string I<"
"\"+cpu\"> to the I<cgroup.subtree_control> file fails with the error "
"B<EINVAL>.)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1746
msgid ""
"On some systems, B<systemd>(1)  places certain realtime threads in nonroot "
"cgroups in the v2 hierarchy.  On such systems, these threads must first be "
"moved to the root cgroup before the I<cpu> controller can be enabled."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1749
msgid "The following errors can occur for B<mount>(2):"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1755
msgid ""
"An attempt to mount a cgroup version 1 filesystem specified neither the "
"I<name=> option (to mount a named hierarchy) nor a controller name (or "
"I<all>)."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1761
#, fuzzy
#| msgid ""
#| "A child process created via B<fork>(2)  inherits its parent's resource "
#| "limits.  Resource limits are preserved across B<execve>(2)."
msgid ""
"A child process created via B<fork>(2)  inherits its parent's cgroup "
"memberships.  A process's cgroup memberships are preserved across "
"B<execve>(2)."
msgstr ""
"B<fork>(2)  で作成された作成された子プロセスは、 親プロセスのリソース制限を継"
"承する。 B<execve>(2)  の前後でリソース制限は保存される。"

#. type: Plain text
#: build/C/man7/cgroups.7:1768
msgid ""
"The B<clone3>(2)  B<CLONE_INTO_CGROUP> flag can be used to create a child "
"process that begins its life in a different version 2 cgroup from the parent "
"process."
msgstr ""

#. type: SS
#: build/C/man7/cgroups.7:1768
#, no-wrap
msgid "/proc files"
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:1769
#, no-wrap
msgid "I</proc/cgroups> (since Linux 2.6.24)"
msgstr "I</proc/cgroups> (Linux 2.6.24 以降)"

#. type: Plain text
#: build/C/man7/cgroups.7:1775
msgid ""
"This file contains information about the controllers that are compiled into "
"the kernel.  An example of the contents of this file (reformatted for "
"readability)  is the following:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1791
#, no-wrap
msgid ""
"#subsys_name    hierarchy      num_cgroups    enabled\n"
"cpuset          4              1              1\n"
"cpu             8              1              1\n"
"cpuacct         8              1              1\n"
"blkio           6              1              1\n"
"memory          3              1              1\n"
"devices         10             84             1\n"
"freezer         7              1              1\n"
"net_cls         9              1              1\n"
"perf_event      5              1              1\n"
"net_prio        9              1              1\n"
"hugetlb         0              1              0\n"
"pids            2              1              1\n"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1795
#, fuzzy
#| msgid "The files in this subdirectory are as follows:"
msgid "The fields in this file are, from left to right:"
msgstr "このサブディレクトリのファイルは以下のとおりである。"

#. type: Plain text
#: build/C/man7/cgroups.7:1798
msgid "The name of the controller."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1803
msgid ""
"The unique ID of the cgroup hierarchy on which this controller is mounted.  "
"If multiple cgroups v1 controllers are bound to the same hierarchy, then "
"each will show the same hierarchy ID in this field.  The value in this field "
"will be 0 if:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1806
msgid "the controller is not mounted on a cgroups v1 hierarchy;"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1808
msgid "the controller is bound to the cgroups v2 single unified hierarchy; or"
msgstr ""

#. type: IP
#: build/C/man7/cgroups.7:1808
#, no-wrap
msgid "c)"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1810
msgid "the controller is disabled (see below)."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1813
msgid "The number of control groups in this hierarchy using this controller."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1818
msgid ""
"This field contains the value 1 if this controller is enabled, or 0 if it "
"has been disabled (via the I<cgroup_disable> kernel command-line boot "
"parameter)."
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:1819
#, no-wrap
msgid "I</proc/[pid]/cgroup> (since Linux 2.6.24)"
msgstr "I</proc/[pid]/cgroup> (Linux 2.6.24 以降)"

#. type: Plain text
#: build/C/man7/cgroups.7:1825
msgid ""
"This file describes control groups to which the process with the "
"corresponding PID belongs.  The displayed information differs for cgroups "
"version 1 and version 2 hierarchies."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1828
msgid ""
"For each cgroup hierarchy of which the process is a member, there is one "
"entry containing three colon-separated fields:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1832
#, no-wrap
msgid "hierarchy-ID:controller-list:cgroup-path\n"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1836
msgid "For example:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1840
#, no-wrap
msgid "5:cpuacct,cpu,cpuset:/daemons\n"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1844
msgid "The colon-separated fields are, from left to right:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1851
msgid ""
"For cgroups version 1 hierarchies, this field contains a unique hierarchy ID "
"number that can be matched to a hierarchy ID in I</proc/cgroups>.  For the "
"cgroups version 2 hierarchy, this field contains the value 0."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1856
msgid ""
"For cgroups version 1 hierarchies, this field contains a comma-separated "
"list of the controllers bound to the hierarchy.  For the cgroups version 2 "
"hierarchy, this field is empty."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1860
msgid ""
"This field contains the pathname of the control group in the hierarchy to "
"which the process belongs.  This pathname is relative to the mount point of "
"the hierarchy."
msgstr ""

#. type: SS
#: build/C/man7/cgroups.7:1862
#, no-wrap
msgid "/sys/kernel/cgroup files"
msgstr ""

#. type: TP
#: build/C/man7/cgroups.7:1863
#, no-wrap
msgid "I</sys/kernel/cgroup/delegate> (since Linux 4.15)"
msgstr "I</sys/kernel/cgroup/delegate> (Linux 4.15 以降)"

#.  commit 01ee6cfb1483fe57c9cbd8e73817dfbf9bacffd3
#. type: Plain text
#: build/C/man7/cgroups.7:1873
msgid ""
"This file exports a list of the cgroups v2 files (one per line) that are "
"delegatable (i.e., whose ownership should be changed to the user ID of the "
"delegatee).  In the future, the set of delegatable files may change or grow, "
"and this file provides a way for the kernel to inform user-space "
"applications of which files must be delegated.  As at Linux 4.15, one sees "
"the following when inspecting this file:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1880
#, no-wrap
msgid ""
"$ B<cat /sys/kernel/cgroup/delegate>\n"
"cgroup.procs\n"
"cgroup.subtree_control\n"
"cgroup.threads\n"
msgstr ""
"$ B<cat /sys/kernel/cgroup/delegate>\n"
"cgroup.procs\n"
"cgroup.subtree_control\n"
"cgroup.threads\n"

#. type: TP
#: build/C/man7/cgroups.7:1882
#, no-wrap
msgid "I</sys/kernel/cgroup/features> (since Linux 4.15)"
msgstr "I</sys/kernel/cgroup/features> (Linux 4.15 以降)"

#.  commit 5f2e673405b742be64e7c3604ed4ed3ac14f35ce
#. type: Plain text
#: build/C/man7/cgroups.7:1891
msgid ""
"Over time, the set of cgroups v2 features that are provided by the kernel "
"may change or grow, or some features may not be enabled by default.  This "
"file provides a way for user-space applications to discover what features "
"the running kernel supports and has enabled.  Features are listed one per "
"line:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1897
#, no-wrap
msgid ""
"$ B<cat /sys/kernel/cgroup/features>\n"
"nsdelegate\n"
"memory_localevents\n"
msgstr ""
"$ B<cat /sys/kernel/cgroup/features>\n"
"nsdelegate\n"
"memory_localevents\n"

#. type: Plain text
#: build/C/man7/cgroups.7:1901
msgid "The entries that can appear in this file are:"
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1907
msgid "The kernel supports the I<memory_localevents> mount option."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1912
msgid "The kernel supports the I<nsdelegate> mount option."
msgstr ""

#. type: Plain text
#: build/C/man7/cgroups.7:1927
msgid ""
"B<prlimit>(1), B<systemd>(1), B<systemd-cgls>(1), B<systemd-cgtop>(1), "
"B<clone>(2), B<ioprio_set>(2), B<perf_event_open>(2), B<setrlimit>(2), "
"B<cgroup_namespaces>(7), B<cpuset>(7), B<namespaces>(7), B<sched>(7), "
"B<user_namespaces>(7)"
msgstr "B<prlimit>(1), B<systemd>(1), B<systemd-cgls>(1), B<systemd-cgtop>(1), B<clone>(2), B<ioprio_set>(2), B<perf_event_open>(2), B<setrlimit>(2), B<cgroup_namespaces>(7), B<cpuset>(7), B<namespaces>(7), B<sched>(7), B<user_namespaces>(7)"

#. type: Plain text
#: build/C/man7/cgroups.7:1930
msgid "The kernel source file I<Documentation/admin-guide/cgroup-v2.rst>."
msgstr "カーネルのソースファイル I<Documentation/admin-guide/cgroup-v2.rst>"

#. type: TH
#: build/C/man2/pidfd_getfd.2:25
#, no-wrap
msgid "PIDFD_GETFD"
msgstr ""

#. type: TH
#: build/C/man2/pidfd_getfd.2:25
#, no-wrap
msgid "2020-03-31"
msgstr "2020-03-31"

#. type: Plain text
#: build/C/man2/pidfd_getfd.2:28
msgid "pidfd_getfd - obtain a duplicate of another process's file descriptor"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_getfd.2:31
#, no-wrap
msgid "B<int pidfd_getfd(int >I<pidfd>B<, int >I<targetfd>B<, unsigned int >I<flags>B<);>\n"
msgstr "B<int pidfd_getfd(int >I<pidfd>B<, int >I<targetfd>B<, unsigned int >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man2/pidfd_getfd.2:40
msgid ""
"The B<pidfd_getfd>()  system call allocates a new file descriptor in the "
"calling process.  This new file descriptor is a duplicate of an existing "
"file descriptor, I<targetfd>, in the process referred to by the PID file "
"descriptor I<pidfd>."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_getfd.2:50
msgid ""
"The duplicate file descriptor refers to the same open file description (see "
"B<open>(2))  as the original file descriptor in the process referred to by "
"I<pidfd>.  The two file descriptors thus share file status flags and file "
"offset.  Furthermore, operations on the underlying file object (for example, "
"assigning an address to a socket object using B<bind>(2))  can equally be "
"performed via the duplicate file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_getfd.2:57
msgid ""
"The close-on-exec flag (B<FD_CLOEXEC>; see B<fcntl>(2))  is set on the file "
"descriptor returned by B<pidfd_getfd>()."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_getfd.2:62
msgid ""
"The I<flags> argument is reserved for future use.  Currently, it must be "
"specified as 0."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_getfd.2:68
msgid ""
"Permission to duplicate another process's file descriptor is governed by a "
"ptrace access mode B<PTRACE_MODE_ATTACH_REALCREDS> check (see B<ptrace>(2))."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_getfd.2:75
#, fuzzy
#| msgid ""
#| "On success, B<ioprio_set>()  returns 0.  On error, -1 is returned, and "
#| "I<errno> is set to indicate the error."
msgid ""
"On success, B<pidfd_getfd>()  returns a file descriptor (a nonnegative "
"integer).  On error, -1 is returned and I<errno> is set to indicate the "
"cause of the error."
msgstr ""
"成功すると、 B<ioprio_set>()  は 0 を返す。 エラーの場合、-1 を返し、 "
"I<errno> にエラーを示す値を設定する。"

#. type: TP
#: build/C/man2/pidfd_getfd.2:76 build/C/man2/pidfd_getfd.2:80
#: build/C/man2/pidfd_send_signal.2:98
#, no-wrap
msgid "B<EBADF>"
msgstr "B<EBADF>"

#. type: Plain text
#: build/C/man2/pidfd_getfd.2:80 build/C/man2/pidfd_send_signal.2:102
msgid "I<pidfd> is not a valid PID file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_getfd.2:85
msgid ""
"I<targetfd> is not an open file descriptor in the process referred to by "
"I<pidfd>."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_getfd.2:89 build/C/man2/pidfd_open.2:59
#: build/C/man2/pidfd_send_signal.2:114
msgid "I<flags> is not 0."
msgstr ""

#. type: TP
#: build/C/man2/pidfd_getfd.2:89 build/C/man2/pidfd_open.2:63
#, no-wrap
msgid "B<EMFILE>"
msgstr "B<EMFILE>"

#. type: Plain text
#: build/C/man2/pidfd_getfd.2:96 build/C/man2/pidfd_open.2:70
msgid ""
"The per-process limit on the number of open file descriptors has been "
"reached (see the description of B<RLIMIT_NOFILE> in B<getrlimit>(2))."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_getfd.2:107
#, fuzzy
#| msgid ""
#| "(B<prlimit>())  The calling process did not have permission to set limits "
#| "for the process specified by I<pid>."
msgid ""
"The calling process did not have B<PTRACE_MODE_ATTACH_REALCREDS> permissions "
"(see B<ptrace>(2))  over the process referred to by I<pidfd>."
msgstr ""
"(B<prlimit>()) 呼び出し元のプロセスが I<pid> で指定されたプロセスの上限を設定"
"する許可を持っていなかった。"

#. type: Plain text
#: build/C/man2/pidfd_getfd.2:113
msgid ""
"The process referred to by I<pidfd> does not exist (i.e., it has terminated "
"and been waited on)."
msgstr ""

#.  commit 8649c322f75c96e7ced2fec201e123b2b073bf09
#. type: Plain text
#: build/C/man2/pidfd_getfd.2:117
msgid "B<pidfd_getfd>()  first appeared in Linux 5.6."
msgstr "B<pidfd_getfd>() は Linux 5.6 で初めて登場した。"

#. type: Plain text
#: build/C/man2/pidfd_getfd.2:120
msgid "B<pidfd_getfd>()  is Linux specific."
msgstr "B<pidfd_getfd>() は Linux 固有である。"

#. type: Plain text
#: build/C/man2/pidfd_getfd.2:123 build/C/man2/pidfd_open.2:93
#: build/C/man2/pidfd_send_signal.2:139
#, fuzzy
#| msgid ""
#| "Glibc does not provide a wrapper for these system calls; call them using "
#| "B<syscall>(2)."
msgid ""
"Currently, there is no glibc wrapper for this system call; call it using "
"B<syscall>(2)."
msgstr ""
"glibc はこれらのシステムコールに対するラッパー関数を提供していない。 "
"B<syscall>(2)  を使って呼び出すこと。"

#. type: Plain text
#: build/C/man2/pidfd_getfd.2:126
msgid "For a description of PID file descriptors, see B<pidfd_open>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_getfd.2:134
msgid ""
"The effect of B<pidfd_getfd>()  is similar to the use of B<SCM_RIGHTS> "
"messages described in B<unix>(7), but differs in the following respects:"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_getfd.2:139
msgid ""
"In order to pass a file descriptor using an B<SCM_RIGHTS> message, the two "
"processes must first establish a UNIX domain socket connection."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_getfd.2:146
msgid ""
"The use of B<SCM_RIGHTS> requires cooperation on the part of the process "
"whose file descriptor is being copied.  By contrast, no such cooperation is "
"necessary when using B<pidfd_getfd>()."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_getfd.2:152
msgid ""
"The ability to use B<pidfd_getfd>()  is restricted by a "
"B<PTRACE_MODE_ATTACH_REALCREDS> ptrace access mode check."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_getfd.2:157
msgid "B<clone3>(2), B<dup>(2), B<kcmp>(2), B<pidfd_open>(2)"
msgstr "B<clone3>(2), B<dup>(2), B<kcmp>(2), B<pidfd_open>(2)"

#. type: TH
#: build/C/man2/pidfd_open.2:25
#, no-wrap
msgid "PIDFD_OPEN"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_open.2:28
msgid "pidfd_open - obtain a file descriptor that refers to a process"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_open.2:31
#, no-wrap
msgid "B<#include E<lt>sys/types.hE<gt>>\n"
msgstr "B<#include E<lt>sys/types.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/pidfd_open.2:33
#, no-wrap
msgid "B<int pidfd_open(pid_t >I<pid>B<, unsigned int >I<flags>B<);>\n"
msgstr "B<int pidfd_open(pid_t >I<pid>B<, unsigned int >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man2/pidfd_open.2:42
msgid ""
"The B<pidfd_open>()  system call creates a file descriptor that refers to "
"the process whose PID is specified in I<pid>.  The file descriptor is "
"returned as the function result; the close-on-exec flag is set on the file "
"descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_open.2:47 build/C/man2/pidfd_send_signal.2:90
msgid ""
"The I<flags> argument is reserved for future use; currently, this argument "
"must be specified as 0."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_open.2:54
#, fuzzy
#| msgid ""
#| "On success, B<ioprio_set>()  returns 0.  On error, -1 is returned, and "
#| "I<errno> is set to indicate the error."
msgid ""
"On success, B<pidfd_open>()  returns a file descriptor (a nonnegative "
"integer).  On error, -1 is returned and I<errno> is set to indicate the "
"cause of the error."
msgstr ""
"成功すると、 B<ioprio_set>()  は 0 を返す。 エラーの場合、-1 を返し、 "
"I<errno> にエラーを示す値を設定する。"

#. type: Plain text
#: build/C/man2/pidfd_open.2:63
msgid "I<pid> is not valid."
msgstr "I<pid> が有効ではない。"

#. type: Plain text
#: build/C/man2/pidfd_open.2:76
msgid "The anonymous inode filesystem is not available in this kernel."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_open.2:79
msgid "Insufficient kernel memory was available."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_open.2:84
msgid "The process specified by I<pid> does not exist."
msgstr "I<pid> で指定されたプロセスが存在しない。"

#. type: Plain text
#: build/C/man2/pidfd_open.2:87
msgid "B<pidfd_open>()  first appeared in Linux 5.3."
msgstr "B<pidfd_open>() は Linux 5.3 で初めて登場した。"

#. type: Plain text
#: build/C/man2/pidfd_open.2:90
msgid "B<pidfd_open>()  is Linux specific."
msgstr "B<pidfd_open>() は Linux 固有である。"

#. type: Plain text
#: build/C/man2/pidfd_open.2:97
msgid ""
"The following code sequence can be used to obtain a file descriptor for the "
"child of B<fork>(2):"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_open.2:105
#, no-wrap
msgid ""
"pid = fork();\n"
"if (pid E<gt> 0) {     /* If parent */\n"
"    pidfd = pidfd_open(pid, 0);\n"
"    ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_open.2:114
msgid ""
"Even if the child has already terminated by the time of the B<pidfd_open>()  "
"call, its PID will not have been recycled and the returned file descriptor "
"will refer to the resulting zombie process.  Note, however, that this is "
"guaranteed only if the following conditions hold true:"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_open.2:121
msgid ""
"the disposition of B<SIGCHLD> has not been explicitly set to B<SIG_IGN> (see "
"B<sigaction>(2));"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_open.2:131
msgid ""
"the B<SA_NOCLDWAIT> flag was not specified while establishing a handler for "
"B<SIGCHLD> or while setting the disposition of that signal to B<SIG_DFL> "
"(see B<sigaction>(2)); and"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_open.2:136
msgid ""
"the zombie process was not reaped elsewhere in the program (e.g., either by "
"an asynchronously executed signal handler or by B<wait>(2)  or similar in "
"another thread)."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_open.2:145
msgid ""
"If any of these conditions does not hold, then the child process (along with "
"a PID file descriptor that refers to it)  should instead be created using "
"B<clone>(2)  with the B<CLONE_PIDFD> flag."
msgstr ""

#. type: SS
#: build/C/man2/pidfd_open.2:145
#, no-wrap
msgid "Use cases for PID file descriptors"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_open.2:153
msgid ""
"A PID file descriptor returned by B<pidfd_open>()  (or by B<clone>(2)  with "
"the B<CLONE_PID> flag) can be used for the following purposes:"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_open.2:158
msgid ""
"The B<pidfd_send_signal>(2)  system call can be used to send a signal to the "
"process referred to by a PID file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_open.2:171
msgid ""
"A PID file descriptor can be monitored using B<poll>(2), B<select>(2), and "
"B<epoll>(7).  When the process that it refers to terminates, these "
"interfaces indicate the file descriptor as readable.  Note, however, that in "
"the current implementation, nothing can be read from the file descriptor "
"(B<read>(2)  on the file descriptor fails with the error B<EINVAL>)."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_open.2:175
msgid ""
"If the PID file descriptor refers to a child of the calling process, then it "
"can be waited on using B<waitid>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_open.2:180
msgid ""
"The B<pidfd_getfd>(2)  system call can be used to obtain a duplicate of a "
"file descriptor of another process referred to by a PID file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_open.2:185
msgid ""
"A PID file descriptor can be used as the argument of B<setns>(2)  in order "
"to move into one or more of the same namespaces as the process referred to "
"by the file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_open.2:200
msgid ""
"The B<pidfd_open>()  system call is the preferred way of obtaining a PID "
"file descriptor for an already existing process.  The alternative is to "
"obtain a file descriptor by opening a I</proc/[pid]> directory.  However, "
"the latter technique is possible only if the B<proc>(5)  filesystem is "
"mounted; furthermore, the file descriptor obtained in this way is I<not> "
"pollable and can't be waited on with B<waitid>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_open.2:209
msgid ""
"The program below opens a PID file descriptor for the process whose PID is "
"specified as its command-line argument.  It then uses B<poll>(2)  to monitor "
"the file descriptor for process exit, as indicated by an B<EPOLLIN> event."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_open.2:219
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/syscall.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>poll.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/syscall.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>poll.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"

#. type: Plain text
#: build/C/man2/pidfd_open.2:223
#, no-wrap
msgid ""
"#ifndef __NR_pidfd_open\n"
"#define __NR_pidfd_open 434   /* System call # on most architectures */\n"
"#endif\n"
msgstr ""
"#ifndef __NR_pidfd_open\n"
"#define __NR_pidfd_open 434   /* System call # on most architectures */\n"
"#endif\n"

#. type: Plain text
#: build/C/man2/pidfd_open.2:229
#, no-wrap
msgid ""
"static int\n"
"pidfd_open(pid_t pid, unsigned int flags)\n"
"{\n"
"    return syscall(__NR_pidfd_open, pid, flags);\n"
"}\n"
msgstr ""
"static int\n"
"pidfd_open(pid_t pid, unsigned int flags)\n"
"{\n"
"    return syscall(__NR_pidfd_open, pid, flags);\n"
"}\n"

#. type: Plain text
#: build/C/man2/pidfd_open.2:235
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct pollfd pollfd;\n"
"    int pidfd, ready;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct pollfd pollfd;\n"
"    int pidfd, ready;\n"

#. type: Plain text
#: build/C/man2/pidfd_open.2:240
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>pidE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_SUCCESS);\n"
"    }\n"
msgstr ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>pidE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_SUCCESS);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/pidfd_open.2:246
#, no-wrap
msgid ""
"    pidfd = pidfd_open(atoi(argv[1]), 0);\n"
"    if (pidfd == -1) {\n"
"        perror(\"pidfd_open\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    pidfd = pidfd_open(atoi(argv[1]), 0);\n"
"    if (pidfd == -1) {\n"
"        perror(\"pidfd_open\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/pidfd_open.2:249
#, no-wrap
msgid ""
"    pollfd.fd = pidfd;\n"
"    pollfd.events = POLLIN;\n"
msgstr ""
"    pollfd.fd = pidfd;\n"
"    pollfd.events = POLLIN;\n"

#. type: Plain text
#: build/C/man2/pidfd_open.2:255
#, no-wrap
msgid ""
"    ready = poll(&pollfd, 1, -1);\n"
"    if (ready == -1) {\n"
"        perror(\"poll\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    ready = poll(&pollfd, 1, -1);\n"
"    if (ready == -1) {\n"
"        perror(\"poll\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/pidfd_open.2:258
#, no-wrap
msgid ""
"    printf(\"Events (%#x): POLLIN is %sset\\en\", pollfd.revents,\n"
"            (pollfd.revents & POLLIN) ? \"\" : \"not \");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_open.2:262
#, no-wrap
msgid ""
"    close(pidfd);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    close(pidfd);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man2/pidfd_open.2:273
msgid ""
"B<clone>(2), B<kill>(2), B<pidfd_getfd>(2), B<pidfd_send_signal>(2), "
"B<poll>(2), B<select>(2), B<setns>(2), B<waitid>(2), B<epoll>(7)"
msgstr "B<clone>(2), B<kill>(2), B<pidfd_getfd>(2), B<pidfd_send_signal>(2), B<poll>(2), B<select>(2), B<setns>(2), B<waitid>(2), B<epoll>(7)"

#. type: TH
#: build/C/man2/pidfd_send_signal.2:25
#, no-wrap
msgid "PIDFD_SEND_SIGNAL"
msgstr ""

#. type: TH
#: build/C/man2/pidfd_send_signal.2:25
#, no-wrap
msgid "2020-06-09"
msgstr "2020-06-09"

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:28
msgid ""
"pidfd_send_signal - send a signal to a process specified by a file descriptor"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:31
#, no-wrap
msgid "B<#include E<lt>signal.hE<gt>>\n"
msgstr "B<#include E<lt>signal.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:34
#, no-wrap
msgid ""
"B<int pidfd_send_signal(int >I<pidfd>B<, int >I<sig>B<, siginfo_t *>I<info>B<,>\n"
"B<                      unsigned int >I<flags>B<);>\n"
msgstr ""

#.  See the very detailed commit message for kernel commit
#.  3eb39f47934f9d5a3027fe00d906a45fe3a15fad
#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:45
msgid ""
"The B<pidfd_send_signal>()  system call sends the signal I<sig> to the "
"target process referred to by I<pidfd>, a PID file descriptor that refers to "
"a process."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:52
msgid ""
"If the I<info> argument points to a I<siginfo_t> buffer, that buffer should "
"be populated as described in B<rt_sigqueueinfo>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:61
msgid ""
"If the I<info> argument is a NULL pointer, this is equivalent to specifying "
"a pointer to a I<siginfo_t> buffer whose fields match the values that are "
"implicitly supplied when a signal is sent using B<kill>(2):"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:66
msgid "I<si_signo> is set to the signal number;"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:69
msgid "I<si_errno> is set to 0;"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:73
msgid "I<si_code> is set to B<SI_USER>;"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:76
msgid "I<si_pid> is set to the caller's PID; and"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:79
msgid "I<si_uid> is set to the caller's real user ID."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:85
#, fuzzy
#| msgid ""
#| "The writing process must be in either the user namespace of the process "
#| "I<pid> or inside the parent user namespace of the process I<pid>."
msgid ""
"The calling process must either be in the same PID namespace as the process "
"referred to by I<pidfd>, or be in an ancestor of that namespace."
msgstr ""
"書き込みプロセスは、 プロセス I<pid> のユーザー名前空間もしくはプロセス "
"I<pid> の親のユーザー名前空間に属していなければならない。"

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:97
msgid ""
"On success, B<pidfd_send_signal>()  returns 0.  On error, -1 is returned and "
"I<errno> is set to indicate the cause of the error."
msgstr "成功すると、 B<pidfd_send_signal>()  は 0 を返す。 エラーの場合、-1 を返し、 I<errno> にエラーの原因を示す値を設定する。"

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:106
msgid "I<sig> is not a valid signal."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:110
msgid ""
"The calling process is not in a PID namespace from which it can send a "
"signal to the target process."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:118
#, fuzzy
#| msgid ""
#| "(B<prlimit>())  The calling process did not have permission to set limits "
#| "for the process specified by I<pid>."
msgid ""
"The calling process does not have permission to send the signal to the "
"target process."
msgstr ""
"(B<prlimit>()) 呼び出し元のプロセスが I<pid> で指定されたプロセスの上限を設定"
"する許可を持っていなかった。"

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:125
msgid ""
"I<pidfd> doesn't refer to the calling process, and I<info.si_code> is "
"invalid (see B<rt_sigqueueinfo>(2))."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:129
msgid ""
"The target process does not exist (i.e., it has terminated and been waited "
"on)."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:132
msgid "B<pidfd_send_signal>()  first appeared in Linux 5.1."
msgstr "B<pidfd_send_signal>() は Linux 5.1 で初めて登場した。"

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:135
msgid "B<pidfd_send_signal>()  is Linux specific."
msgstr "B<pidfd_send_signal>() は Linux 固有である。"

#. type: SS
#: build/C/man2/pidfd_send_signal.2:139
#, no-wrap
msgid "PID file descriptors"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:145
msgid ""
"The I<pidfd> argument is a PID file descriptor, a file descriptor that "
"refers to process.  Such a file descriptor can be obtained in any of the "
"following ways:"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:149
#, fuzzy
#| msgid "The /proc/[pid]/ns/ directory"
msgid "by opening a I</proc/[pid]> directory;"
msgstr "/proc/[pid]/ns/ ディレクトリ"

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:153
msgid "using B<pidfd_open>(2); or"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:161
msgid ""
"via the PID file descriptor that is returned by a call to B<clone>(2)  or "
"B<clone3>(2)  that specifies the B<CLONE_PIDFD> flag."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:179
msgid ""
"The B<pidfd_send_signal>()  system call allows the avoidance of race "
"conditions that occur when using traditional interfaces (such as "
"B<kill>(2))  to signal a process.  The problem is that the traditional "
"interfaces specify the target process via a process ID (PID), with the "
"result that the sender may accidentally send a signal to the wrong process "
"if the originally intended target process has terminated and its PID has "
"been recycled for another process.  By contrast, a PID file descriptor is a "
"stable reference to a specific process; if that process terminates, "
"B<pidfd_send_signal>()  fails with the error B<ESRCH>."
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:190
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>limits.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/syscall.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#include E<lt>limits.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/syscall.hE<gt>\n"

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:194
#, no-wrap
msgid ""
"#ifndef __NR_pidfd_send_signal\n"
"#define __NR_pidfd_send_signal 424\n"
"#endif\n"
msgstr ""
"#ifndef __NR_pidfd_send_signal\n"
"#define __NR_pidfd_send_signal 424\n"
"#endif\n"

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:201
#, no-wrap
msgid ""
"static int\n"
"pidfd_send_signal(int pidfd, int sig, siginfo_t *info,\n"
"        unsigned int flags)\n"
"{\n"
"    return syscall(__NR_pidfd_send_signal, pidfd, sig, info, flags);\n"
"}\n"
msgstr ""
"static int\n"
"pidfd_send_signal(int pidfd, int sig, siginfo_t *info,\n"
"        unsigned int flags)\n"
"{\n"
"    return syscall(__NR_pidfd_send_signal, pidfd, sig, info, flags);\n"
"}\n"

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:208
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    siginfo_t info;\n"
"    char path[PATH_MAX];\n"
"    int pidfd, sig;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    siginfo_t info;\n"
"    char path[PATH_MAX];\n"
"    int pidfd, sig;\n"

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:213
#, no-wrap
msgid ""
"    if (argc != 3) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>pidE<gt> E<lt>signalE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 3) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>pidE<gt> E<lt>signalE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:215
#, no-wrap
msgid "    sig = atoi(argv[2]);\n"
msgstr "    sig = atoi(argv[2]);\n"

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:218
#, no-wrap
msgid ""
"    /* Obtain a PID file descriptor by opening the /proc/PID directory\n"
"       of the target process */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:220
#, no-wrap
msgid "    snprintf(path, sizeof(path), \"/proc/%s\", argv[1]);\n"
msgstr "    snprintf(path, sizeof(path), \"/proc/%s\", argv[1]);\n"

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:226
#, no-wrap
msgid ""
"    pidfd = open(path, O_RDONLY);\n"
"    if (pidfd == -1) {\n"
"        perror(\"open\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    pidfd = open(path, O_RDONLY);\n"
"    if (pidfd == -1) {\n"
"        perror(\"open\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:229
#, no-wrap
msgid ""
"    /* Populate a \\(aqsiginfo_t\\(aq structure for use with\n"
"       pidfd_send_signal() */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:237
#, no-wrap
msgid ""
"    memset(&info, 0, sizeof(info));\n"
"    info.si_code = SI_QUEUE;\n"
"    info.si_signo = sig;\n"
"    info.si_errno = 0;\n"
"    info.si_uid = getuid();\n"
"    info.si_pid = getpid();\n"
"    info.si_value.sival_int = 1234;\n"
msgstr ""
"    memset(&info, 0, sizeof(info));\n"
"    info.si_code = SI_QUEUE;\n"
"    info.si_signo = sig;\n"
"    info.si_errno = 0;\n"
"    info.si_uid = getuid();\n"
"    info.si_pid = getpid();\n"
"    info.si_value.sival_int = 1234;\n"

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:239
#, no-wrap
msgid "    /* Send the signal */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:244
#, no-wrap
msgid ""
"    if (pidfd_send_signal(pidfd, sig, &info, 0) == -1) {\n"
"        perror(\"pidfd_send_signal\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (pidfd_send_signal(pidfd, sig, &info, 0) == -1) {\n"
"        perror(\"pidfd_send_signal\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/pidfd_send_signal.2:256
msgid ""
"B<clone>(2), B<kill>(2), B<pidfd_open>(2), B<rt_sigqueueinfo>(2), "
"B<sigaction>(2), B<pid_namespaces>(7), B<signal>(7)"
msgstr "B<clone>(2), B<kill>(2), B<pidfd_open>(2), B<rt_sigqueueinfo>(2), B<sigaction>(2), B<pid_namespaces>(7), B<signal>(7)"

#. type: TH
#: build/C/man3/posix_spawn.3:31
#, no-wrap
msgid "POSIX_SPAWN"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:34
msgid "posix_spawn, posix_spawnp - spawn a process"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:37
#, no-wrap
msgid "B<#include E<lt>spawn.hE<gt>>\n"
msgstr "B<#include E<lt>spawn.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/posix_spawn.3:42
#, no-wrap
msgid ""
"B<int posix_spawn(pid_t *>I<pid>B<, const char *>I<path>B<,>\n"
"B<                const posix_spawn_file_actions_t *>I<file_actions>B<,>\n"
"B<                const posix_spawnattr_t *>I<attrp>B<,>\n"
"B<                char *const >I<argv[]>B<, char *const >I<envp[]>B<);>\n"
msgstr ""
"B<int posix_spawn(pid_t *>I<pid>B<, const char *>I<path>B<,>\n"
"B<                const posix_spawn_file_actions_t *>I<file_actions>B<,>\n"
"B<                const posix_spawnattr_t *>I<attrp>B<,>\n"
"B<                char *const >I<argv[]>B<, char *const >I<envp[]>B<);>\n"

#. type: Plain text
#: build/C/man3/posix_spawn.3:47
#, no-wrap
msgid ""
"B<int posix_spawnp(pid_t *>I<pid>B<, const char *>I<file>B<,>\n"
"B<                 const posix_spawn_file_actions_t *>I<file_actions>B<,>\n"
"B<                 const posix_spawnattr_t *>I<attrp>B<,>\n"
"B<                 char *const >I<argv[]>B<, char *const >I<envp[]>B<);>\n"
msgstr ""
"B<int posix_spawnp(pid_t *>I<pid>B<, const char *>I<file>B<,>\n"
"B<                 const posix_spawn_file_actions_t *>I<file_actions>B<,>\n"
"B<                 const posix_spawnattr_t *>I<attrp>B<,>\n"
"B<                 char *const >I<argv[]>B<, char *const >I<envp[]>B<);>\n"

#. type: Plain text
#: build/C/man3/posix_spawn.3:61
msgid ""
"The B<posix_spawn>()  and B<posix_spawnp>()  functions are used to create a "
"new child process that executes a specified file.  These functions were "
"specified by POSIX to provide a standardized method of creating new "
"processes on machines that lack the capability to support the B<fork>(2)  "
"system call.  These machines are generally small, embedded systems lacking "
"MMU support."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:79
msgid ""
"The B<posix_spawn>()  and B<posix_spawnp>()  functions provide the "
"functionality of a combined B<fork>(2)  and B<exec>(3), with some optional "
"housekeeping steps in the child process before the B<exec>(3).  These "
"functions are not meant to replace the B<fork>(2)  and B<execve>(2)  system "
"calls.  In fact, they provide only a subset of the functionality that can be "
"achieved by using the system calls."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:102
msgid ""
"The only difference between B<posix_spawn>()  and B<posix_spawnp>()  is the "
"manner in which they specify the file to be executed by the child process.  "
"With B<posix_spawn>(), the executable file is specified as a pathname (which "
"can be absolute or relative).  With B<posix_spawnp>(), the executable file "
"is specified as a simple filename; the system searches for this file in the "
"list of directories specified by B<PATH> (in the same way as for "
"B<execvp>(3)).  For the remainder of this page, the discussion is phrased in "
"terms of B<posix_spawn>(), with the understanding that B<posix_spawnp>()  "
"differs only on the point just described."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:104
#, fuzzy
#| msgid "The files in this subdirectory are as follows:"
msgid "The remaining arguments to these two functions are as follows:"
msgstr "このサブディレクトリのファイルは以下のとおりである。"

#. type: Plain text
#: build/C/man3/posix_spawn.3:109
msgid ""
"The I<pid> argument points to a buffer that is used to return the process ID "
"of the new child process."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:127
msgid ""
"The I<file_actions> argument points to a I<spawn file actions object> that "
"specifies file-related actions to be performed in the child between the "
"B<fork>(2)  and B<exec>(3)  steps.  This object is initialized and populated "
"before the B<posix_spawn>()  call using B<posix_spawn_file_actions_init>(3)  "
"and the B<posix_spawn_file_actions_*>()  functions."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:140
msgid ""
"The I<attrp> argument points to an I<attributes objects> that specifies "
"various attributes of the created child process.  This object is initialized "
"and populated before the B<posix_spawn>()  call using "
"B<posix_spawnattr_init>(3)  and the B<posix_spawnattr_*>()  functions."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:148
msgid ""
"The I<argv> and I<envp> arguments specify the argument list and environment "
"for the program that is executed in the child process, as for B<execve>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:157
msgid ""
"Below, the functions are described in terms of a three-step process: the "
"B<fork>()  step, the pre-B<exec>()  step (executed in the child), and the "
"B<exec>()  step (executed in the child)."
msgstr ""

#. type: SS
#: build/C/man3/posix_spawn.3:157
#, no-wrap
msgid "fork() step"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:172
msgid ""
"Since glibc 2.24, the B<posix_spawn>()  function commences by calling "
"B<clone>(2)  with B<CLONE_VM> and B<CLONE_VFORK> flags.  Older "
"implementations use B<fork>(2), or possibly B<vfork>(2)  (see below)."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:178
msgid ""
"The PID of the new child process is placed in I<*pid>.  The "
"B<posix_spawn>()  function then returns control to the parent process."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:185
msgid ""
"Subsequently, the parent can use one of the system calls described in "
"B<wait>(2)  to check the status of the child process.  If the child fails in "
"any of the housekeeping steps described below, or fails to execute the "
"desired file, it exits with a status of 127."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:191
msgid ""
"Before glibc 2.24, the child process is created using B<vfork>(2)  instead "
"of B<fork>(2)  when either of the following is true:"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:199
msgid ""
"the I<spawn-flags> element of the attributes object pointed to by I<attrp> "
"contains the GNU-specific flag B<POSIX_SPAWN_USEVFORK>; or"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:213
msgid ""
"I<file_actions> is NULL and the I<spawn-flags> element of the attributes "
"object pointed to by I<attrp> does I<not> contain B<POSIX_SPAWN_SETSIGMASK>, "
"B<POSIX_SPAWN_SETSIGDEF>, B<POSIX_SPAWN_SETSCHEDPARAM>, "
"B<POSIX_SPAWN_SETSCHEDULER>, B<POSIX_SPAWN_SETPGROUP>, or "
"B<POSIX_SPAWN_RESETIDS>."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:220
msgid ""
"In other words, B<vfork>(2)  is used if the caller requests it, or if there "
"is no cleanup expected in the child before it B<exec>(3)s the requested file."
msgstr ""

#. type: SS
#: build/C/man3/posix_spawn.3:221
#, no-wrap
msgid "pre-exec() step: housekeeping"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:238
msgid ""
"In between the B<fork()> and the B<exec()> steps, a child process may need "
"to perform a set of housekeeping actions.  The B<posix_spawn>()  and "
"B<posix_spawnp>()  functions support a small, well-defined set of system "
"tasks that the child process can accomplish before it executes the "
"executable file.  These operations are controlled by the attributes object "
"pointed to by I<attrp> and the file actions object pointed to by "
"I<file_actions>.  In the child, processing is done in the following sequence:"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:244
msgid ""
"Process attribute actions: signal mask, signal default handlers, scheduling "
"algorithm and parameters, process group, and effective user and group IDs "
"are changed as specified by the attributes object pointed to by I<attrp>."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:251
msgid ""
"File actions, as specified in the I<file_actions> argument, are performed in "
"the order that they were specified using calls to the "
"B<posix_spawn_file_actions_add*>()  functions."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:255
msgid "File descriptors with the B<FD_CLOEXEC> flag set are closed."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:266
msgid ""
"All process attributes in the child, other than those affected by attributes "
"specified in the object pointed to by I<attrp> and the file actions in the "
"object pointed to by I<file_actions>, will be affected as though the child "
"was created with B<fork>(2)  and it executed the program with B<execve>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:277
msgid ""
"The process attributes actions are defined by the attributes object pointed "
"to by I<attrp>.  The I<spawn-flags> attribute (set using "
"B<posix_spawnattr_setflags>(3))  controls the general actions that occur, "
"and other attributes in the object specify values to be used during those "
"actions."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:281
msgid ""
"The effects of the flags that may be specified in I<spawn-flags> are as "
"follows:"
msgstr ""

#. type: TP
#: build/C/man3/posix_spawn.3:281
#, no-wrap
msgid "B<POSIX_SPAWN_SETSIGMASK>"
msgstr ""

#.  FIXME .
#.  (see
#.  .BR posix_spawnattr_setsigmask (3))
#. type: Plain text
#: build/C/man3/posix_spawn.3:294
msgid ""
"Set the signal mask to the signal set specified in the I<spawn-sigmask> "
"attribute of the object pointed to by I<attrp>.  If the "
"B<POSIX_SPAWN_SETSIGMASK> flag is not set, then the child inherits the "
"parent's signal mask."
msgstr ""

#. type: TP
#: build/C/man3/posix_spawn.3:294
#, no-wrap
msgid "B<POSIX_SPAWN_SETSIGDEF>"
msgstr ""

#.  FIXME .
#.  (see
#.  .BR posix_spawnattr_setsigdefault (3))
#. type: Plain text
#: build/C/man3/posix_spawn.3:311
msgid ""
"Reset the disposition of all signals in the set specified in the I<spawn-"
"sigdefault> attribute of the object pointed to by I<attrp> to the default.  "
"For the treatment of the dispositions of signals not specified in the "
"I<spawn-sigdefault> attribute, or the treatment when "
"B<POSIX_SPAWN_SETSIGDEF> is not specified, see B<execve>(2)."
msgstr ""

#. type: TP
#: build/C/man3/posix_spawn.3:311
#, no-wrap
msgid "B<POSIX_SPAWN_SETSCHEDPARAM>"
msgstr ""

#.  (POSIX_PRIORITY_SCHEDULING only)
#.  FIXME .
#.  (see
#.  .BR posix_spawnattr_setschedparam (3))
#. type: Plain text
#: build/C/man3/posix_spawn.3:325
msgid ""
"If this flag is set, and the B<POSIX_SPAWN_SETSCHEDULER> flag is not set, "
"then set the scheduling parameters to the parameters specified in the "
"I<spawn-schedparam> attribute of the object pointed to by I<attrp>."
msgstr ""

#. type: TP
#: build/C/man3/posix_spawn.3:325
#, no-wrap
msgid "B<POSIX_SPAWN_SETSCHEDULER>"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:329
msgid ""
"Set the scheduling policy algorithm and parameters of the child, as follows:"
msgstr ""

#.  FIXME .
#.  (see
#.  .BR posix_spawnattr_setpolicy (3))
#. type: Plain text
#: build/C/man3/posix_spawn.3:339
msgid ""
"The scheduling policy is set to the value specified in the I<spawn-"
"schedpolicy> attribute of the object pointed to by I<attrp>."
msgstr ""

#.  FIXME .
#.  (see
#.  .BR posix_spawnattr_setschedparam (3))
#. type: Plain text
#: build/C/man3/posix_spawn.3:349
msgid ""
"The scheduling parameters are set to the value specified in the I<spawn-"
"schedparam> attribute of the object pointed to by I<attrp> (but see BUGS)."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:356
msgid ""
"If the B<POSIX_SPAWN_SETSCHEDPARAM> and B<POSIX_SPAWN_SETSCHEDPOLICY> flags "
"are not specified, the child inherits the corresponding scheduling "
"attributes from the parent."
msgstr ""

#. type: TP
#: build/C/man3/posix_spawn.3:357
#, no-wrap
msgid "B<POSIX_SPAWN_RESETIDS>"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:368
msgid ""
"If this flag is set, reset the effective UID and GID to the real UID and GID "
"of the parent process.  If this flag is not set, then the child retains the "
"effective UID and GID of the parent.  In either case, if the set-user-ID and "
"set-group-ID permission bits are enabled on the executable file, their "
"effect will override the setting of the effective UID and GID (se "
"B<execve>(2))."
msgstr ""

#. type: TP
#: build/C/man3/posix_spawn.3:368
#, no-wrap
msgid "B<POSIX_SPAWN_SETPGROUP>"
msgstr ""

#.  FIXME .
#.  (see
#.  .BR posix_spawnattr_setpgroup (3))
#. type: Plain text
#: build/C/man3/posix_spawn.3:385
msgid ""
"Set the process group to the value specified in the I<spawn-pgroup> "
"attribute of the object pointed to by I<attrp>.  If the I<spawn-pgroup> "
"attribute has the value 0, the child's process group ID is made the same as "
"its process ID.  If the B<POSIX_SPAWN_SETPGROUP> flag is not set, the child "
"inherits the parent's process group ID."
msgstr ""

#. type: TP
#: build/C/man3/posix_spawn.3:385
#, no-wrap
msgid "B<POSIX_SPAWN_USEVFORK>"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:397
msgid ""
"Since glibc 2.24, this flag has no effect.  On older implementations, "
"setting this flag forces the B<fork()> step to use B<vfork>(2)  instead of "
"B<fork>(2).  The B<_GNU_SOURCE> feature test macro must be defined to obtain "
"the definition of this constant."
msgstr ""

#. type: TP
#: build/C/man3/posix_spawn.3:397
#, no-wrap
msgid "B<POSIX_SPAWN_SETSID> (since glibc 2.26)"
msgstr "B<POSIX_SPAWN_SETSID> (glibc 2.26 以降)"

#.  This flag has been accepted in POSIX, see:
#.  http://austingroupbugs.net/view.php?id=1044
#.  and has been implemented in glibc since version 2.26
#.  commit daeb1fa2e1b33323e719015f5f546988bd4cc73b
#. type: Plain text
#: build/C/man3/posix_spawn.3:411
msgid ""
"If this flag is set, the child process shall create a new session and become "
"the session leader.  The child process shall also become the process group "
"leader of the new process group in the session (see B<setsid>(2)).  The "
"B<_GNU_SOURCE> feature test macro must be defined to obtain the definition "
"of this constant."
msgstr ""

#.  mtk: I think we probably don't want to say the following, since it
#.       could lead people to do the wrong thing
#.  The POSIX standard tells you to call
#.  this function to de-initialize the attributes object pointed to by
#.  .I attrp
#.  when you are done with it;
#.  however, on Linux systems this operation is a no-op.
#. type: Plain text
#: build/C/man3/posix_spawn.3:422
msgid ""
"If I<attrp> is NULL, then the default behaviors described above for each "
"flag apply."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:439
msgid ""
"The I<file_actions> argument specifies a sequence of file operations that "
"are performed in the child process after the general processing described "
"above, and before it performs the B<exec>(3).  If I<file_actions> is NULL, "
"then no special action is taken, and standard B<exec>(3)  semantics apply"
"\\(emfile descriptors open before the exec remain open in the new process, "
"except those for which the B<FD_CLOEXEC> flag has been set.  File locks "
"remain in place."
msgstr ""

#.  FIXME . I think the following is best placed in the
#.  posix_spawn_file_actions_adddup2(3) page, and a similar statement is
#.  also needed in posix_spawn_file_actions_addclose(3)
#.  Note that you can specify file descriptors in
#.  .I posix_spawn_file_actions_adddup2 (3)
#.  which would not be usable if you called
#.  .BR dup2 (2)
#.  at that time--i.e., file descriptors that are opened or
#.  closed by the earlier operations
#.  added to
#.  .I file_actions .
#. type: Plain text
#: build/C/man3/posix_spawn.3:468
msgid ""
"If I<file_actions> is not NULL, then it contains an ordered set of requests "
"to B<open>(2), B<close>(2), and B<dup2>(2)  files.  These requests are added "
"to the I<file_actions> by B<posix_spawn_file_actions_addopen>(3), "
"B<posix_spawn_file_actions_addclose>(3), and "
"B<posix_spawn_file_actions_adddup2>(3).  The requested operations are "
"performed in the order they were added to I<file_actions>."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:474
msgid ""
"If any of the housekeeping actions fails (due to bogus values being passed "
"or other reasons why signal handling, process scheduling, process group ID "
"functions, and file descriptor operations might fail), the child process "
"exits with exit value 127."
msgstr ""

#. type: SS
#: build/C/man3/posix_spawn.3:474
#, no-wrap
msgid "exec() step"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:478
msgid ""
"Once the child has successfully forked and performed all requested pre-exec "
"steps, the child runs the requested executable."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:487
msgid ""
"The child process takes its environment from the I<envp> argument, which is "
"interpreted as if it had been passed to B<execve>(2).  The arguments to the "
"created process come from the I<argv> argument, which is processed as for "
"B<execve>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:503
msgid ""
"Upon successful completion, B<posix_spawn>()  and B<posix_spawnp>()  place "
"the PID of the child process in I<pid>, and return 0.  If there is an error "
"during the B<fork()> step, then no child is created, the contents of I<*pid> "
"are unspecified, and these functions return an error number as described "
"below."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:511
msgid ""
"Even when these functions return a success status, the child process may "
"still fail for a plethora of reasons related to its pre-B<exec>() "
"initialization.  In addition, the B<exec>(3)  may fail.  In all of these "
"cases, the child process will exit with the exit value of 127."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:527
msgid ""
"The B<posix_spawn>()  and B<posix_spawnp>()  functions fail only in the case "
"where the underlying B<fork>(2), B<vfork>(2)  or B<clone>(2)  call fails; in "
"these cases, these functions return an error number, which will be one of "
"the errors described for B<fork>(2), B<vfork>(2)  or B<clone>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:529
msgid "In addition, these functions fail if:"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:532
msgid "Function not supported on this system."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:538
msgid ""
"The B<posix_spawn>()  and B<posix_spawnp>()  functions are available since "
"glibc 2.2."
msgstr ""

#.  FIXME . This piece belongs in spawnattr_setflags(3)
#.  The
#.  .B POSIX_SPAWN_USEVFORK
#.  flag is a GNU extension; the
#.  .B _GNU_SOURCE
#.  feature test macro must be defined (before including any header files)
#.  to obtain the definition of this constant.
#. type: Plain text
#: build/C/man3/posix_spawn.3:547
msgid "POSIX.1-2001, POSIX.1-2008."
msgstr "POSIX.1-2001, POSIX.1-2008."

#. type: Plain text
#: build/C/man3/posix_spawn.3:564
msgid ""
"The housekeeping activities in the child are controlled by the objects "
"pointed to by I<attrp> (for non-file actions) and I<file_actions> In POSIX "
"parlance, the I<posix_spawnattr_t> and I<posix_spawn_file_actions_t> data "
"types are referred to as objects, and their elements are not specified by "
"name.  Portable programs should initialize these objects using only the "
"POSIX-specified functions.  (In other words, although these objects may be "
"implemented as structures containing fields, portable programs must avoid "
"dependence on such implementation details.)"
msgstr ""

#.  Tested on glibc 2.12
#. type: Plain text
#: build/C/man3/posix_spawn.3:575
msgid ""
"According to POSIX, it is unspecified whether fork handlers established with "
"B<pthread_atfork>(3)  are called when B<posix_spawn>()  is invoked.  Since "
"glibc 2.24, the fork handlers are not executed in any case.  On older "
"implementations, fork handlers are called only if the child is created using "
"B<fork>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:587
msgid ""
"There is no \"posix_fspawn\" function (i.e., a function that is to "
"B<posix_spawn>()  as B<fexecve>(3)  is to B<execve>(2)).  However, this "
"functionality can be obtained by specifying the I<path> argument as one of "
"the files in the caller's I</proc/self/fd> directory."
msgstr ""

#.  http://sourceware.org/bugzilla/show_bug.cgi?id=12052
#. type: Plain text
#: build/C/man3/posix_spawn.3:602
msgid ""
"POSIX.1 says that when B<POSIX_SPAWN_SETSCHEDULER> is specified in I<spawn-"
"flags>, then the B<POSIX_SPAWN_SETSCHEDPARAM> (if present) is ignored.  "
"However, before glibc 2.14, calls to B<posix_spawn>()  failed with an error "
"if B<POSIX_SPAWN_SETSCHEDULER> was specified without also specifying "
"B<POSIX_SPAWN_SETSCHEDPARAM>."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:609
msgid ""
"The program below demonstrates the use of various functions in the POSIX "
"spawn API.  The program accepts command-line attributes that can be used to "
"create file actions and attributes objects.  The remaining command-line "
"arguments are used as the executable name and command-line arguments of the "
"program that is executed in the child."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:615
msgid ""
"In the first run, the B<date>(1)  command is executed in the child, and the "
"B<posix_spawn>()  call employs no file actions or attributes objects."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:622
#, no-wrap
msgid ""
"$ B<./a.out date>\n"
"PID of child: 7634\n"
"Tue Feb  1 19:47:50 CEST 2011\n"
"Child status: exited, status=0\n"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:632
msgid ""
"In the next run, the I<-c> command-line option is used to create a file "
"actions object that closes standard output in the child.  Consequently, "
"B<date>(1)  fails when trying to perform output and exits with a status of 1."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:639
#, no-wrap
msgid ""
"$ B<./a.out -c date>\n"
"PID of child: 7636\n"
"date: write error: Bad file descriptor\n"
"Child status: exited, status=1\n"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:656
msgid ""
"In the next run, the I<-s> command-line option is used to create an "
"attributes object that specifies that all (blockable) signals in the child "
"should be blocked.  Consequently, trying to kill child with the default "
"signal sent by B<kill>(1)  (i.e., B<SIGTERM>)  fails, because that signal is "
"blocked.  Therefore, to kill the child, B<SIGKILL> is necessary (B<SIGKILL> "
"can't be blocked)."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:662
#, no-wrap
msgid ""
"$ B<./a.out -s sleep 60 &>\n"
"[1] 7637\n"
"$ PID of child: 7638\n"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:667
#, no-wrap
msgid ""
"$ B<kill 7638>\n"
"$ B<kill -KILL 7638>\n"
"$ Child status: killed by signal 9\n"
"[1]+  Done                    ./a.out -s sleep 60\n"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:673
msgid ""
"When we try to execute a nonexistent command in the child, the B<exec>(3)  "
"fails and the child exits with a status of 127."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:679
#, no-wrap
msgid ""
"$ B<./a.out xxxxx\n"
"PID of child: 10190\n"
"Child status: exited, status=127>\n"
msgstr ""
"$ B<./a.out xxxxx\n"
"PID of child: 10190\n"
"Child status: exited, status=127>\n"

#. type: Plain text
#: build/C/man3/posix_spawn.3:692
#, no-wrap
msgid ""
"#include E<lt>spawn.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>wait.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""
"#include E<lt>spawn.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>wait.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"

#. type: Plain text
#: build/C/man3/posix_spawn.3:695
#, no-wrap
msgid ""
"#define errExit(msg)    do { perror(msg); \\e\n"
"                             exit(EXIT_FAILURE); } while (0)\n"
msgstr ""
"#define errExit(msg)    do { perror(msg); \\e\n"
"                             exit(EXIT_FAILURE); } while (0)\n"

#. type: Plain text
#: build/C/man3/posix_spawn.3:699
#, no-wrap
msgid ""
"#define errExitEN(en, msg) \\e\n"
"                        do { errno = en; perror(msg); \\e\n"
"                             exit(EXIT_FAILURE); } while (0)\n"
msgstr ""
"#define errExitEN(en, msg) \\e\n"
"                        do { errno = en; perror(msg); \\e\n"
"                             exit(EXIT_FAILURE); } while (0)\n"

#. type: Plain text
#: build/C/man3/posix_spawn.3:701
#, no-wrap
msgid "char **environ;\n"
msgstr "char **environ;\n"

#. type: Plain text
#: build/C/man3/posix_spawn.3:712
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pid_t child_pid;\n"
"    int s, opt, status;\n"
"    sigset_t mask;\n"
"    posix_spawnattr_t attr;\n"
"    posix_spawnattr_t *attrp;\n"
"    posix_spawn_file_actions_t file_actions;\n"
"    posix_spawn_file_actions_t *file_actionsp;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pid_t child_pid;\n"
"    int s, opt, status;\n"
"    sigset_t mask;\n"
"    posix_spawnattr_t attr;\n"
"    posix_spawnattr_t *attrp;\n"
"    posix_spawn_file_actions_t file_actions;\n"
"    posix_spawn_file_actions_t *file_actionsp;\n"

#. type: Plain text
#: build/C/man3/posix_spawn.3:715
#, no-wrap
msgid ""
"    /* Parse command-line options, which can be used to specify an\n"
"       attributes object and file actions object for the child. */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:718
#, no-wrap
msgid ""
"    attrp = NULL;\n"
"    file_actionsp = NULL;\n"
msgstr ""
"    attrp = NULL;\n"
"    file_actionsp = NULL;\n"

#. type: Plain text
#: build/C/man3/posix_spawn.3:722
#, no-wrap
msgid ""
"    while ((opt = getopt(argc, argv, \"sc\")) != -1) {\n"
"        switch (opt) {\n"
"        case \\(aqc\\(aq:       /* -c: close standard output in child */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:725
#, no-wrap
msgid ""
"            /* Create a file actions object and add a \"close\"\n"
"               action to it */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:729
#, no-wrap
msgid ""
"            s = posix_spawn_file_actions_init(&file_actions);\n"
"            if (s != 0)\n"
"                errExitEN(s, \"posix_spawn_file_actions_init\");\n"
msgstr ""
"            s = posix_spawn_file_actions_init(&file_actions);\n"
"            if (s != 0)\n"
"                errExitEN(s, \"posix_spawn_file_actions_init\");\n"

#. type: Plain text
#: build/C/man3/posix_spawn.3:734
#, no-wrap
msgid ""
"            s = posix_spawn_file_actions_addclose(&file_actions,\n"
"                                                  STDOUT_FILENO);\n"
"            if (s != 0)\n"
"                errExitEN(s, \"posix_spawn_file_actions_addclose\");\n"
msgstr ""
"            s = posix_spawn_file_actions_addclose(&file_actions,\n"
"                                                  STDOUT_FILENO);\n"
"            if (s != 0)\n"
"                errExitEN(s, \"posix_spawn_file_actions_addclose\");\n"

#. type: Plain text
#: build/C/man3/posix_spawn.3:737
#, no-wrap
msgid ""
"            file_actionsp = &file_actions;\n"
"            break;\n"
msgstr ""
"            file_actionsp = &file_actions;\n"
"            break;\n"

#. type: Plain text
#: build/C/man3/posix_spawn.3:739
#, no-wrap
msgid "        case \\(aqs\\(aq:       /* -s: block all signals in child */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:742
#, no-wrap
msgid ""
"            /* Create an attributes object and add a \"set signal mask\"\n"
"               action to it */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:749
#, no-wrap
msgid ""
"            s = posix_spawnattr_init(&attr);\n"
"            if (s != 0)\n"
"                errExitEN(s, \"posix_spawnattr_init\");\n"
"            s = posix_spawnattr_setflags(&attr, POSIX_SPAWN_SETSIGMASK);\n"
"            if (s != 0)\n"
"                errExitEN(s, \"posix_spawnattr_setflags\");\n"
msgstr ""
"            s = posix_spawnattr_init(&attr);\n"
"            if (s != 0)\n"
"                errExitEN(s, \"posix_spawnattr_init\");\n"
"            s = posix_spawnattr_setflags(&attr, POSIX_SPAWN_SETSIGMASK);\n"
"            if (s != 0)\n"
"                errExitEN(s, \"posix_spawnattr_setflags\");\n"

#. type: Plain text
#: build/C/man3/posix_spawn.3:754
#, no-wrap
msgid ""
"            sigfillset(&mask);\n"
"            s = posix_spawnattr_setsigmask(&attr, &mask);\n"
"            if (s != 0)\n"
"                errExitEN(s, \"posix_spawnattr_setsigmask\");\n"
msgstr ""
"            sigfillset(&mask);\n"
"            s = posix_spawnattr_setsigmask(&attr, &mask);\n"
"            if (s != 0)\n"
"                errExitEN(s, \"posix_spawnattr_setsigmask\");\n"

#. type: Plain text
#: build/C/man3/posix_spawn.3:759
#, no-wrap
msgid ""
"            attrp = &attr;\n"
"            break;\n"
"        }\n"
"    }\n"
msgstr ""
"            attrp = &attr;\n"
"            break;\n"
"        }\n"
"    }\n"

#. type: Plain text
#: build/C/man3/posix_spawn.3:764
#, no-wrap
msgid ""
"    /* Spawn the child. The name of the program to execute and the\n"
"       command-line arguments are taken from the command-line arguments\n"
"       of this program. The environment of the program execed in the\n"
"       child is made the same as the parent\\(aqs environment. */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:769
#, no-wrap
msgid ""
"    s = posix_spawnp(&child_pid, argv[optind], file_actionsp, attrp,\n"
"                     &argv[optind], environ);\n"
"    if (s != 0)\n"
"        errExitEN(s, \"posix_spawn\");\n"
msgstr ""
"    s = posix_spawnp(&child_pid, argv[optind], file_actionsp, attrp,\n"
"                     &argv[optind], environ);\n"
"    if (s != 0)\n"
"        errExitEN(s, \"posix_spawn\");\n"

#. type: Plain text
#: build/C/man3/posix_spawn.3:771
#, no-wrap
msgid "    /* Destroy any objects that we created earlier */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_spawn.3:777
#, no-wrap
msgid ""
"    if (attrp != NULL) {\n"
"        s = posix_spawnattr_destroy(attrp);\n"
"        if (s != 0)\n"
"            errExitEN(s, \"posix_spawnattr_destroy\");\n"
"    }\n"
msgstr ""
"    if (attrp != NULL) {\n"
"        s = posix_spawnattr_destroy(attrp);\n"
"        if (s != 0)\n"
"            errExitEN(s, \"posix_spawnattr_destroy\");\n"
"    }\n"

#. type: Plain text
#: build/C/man3/posix_spawn.3:783
#, no-wrap
msgid ""
"    if (file_actionsp != NULL) {\n"
"        s = posix_spawn_file_actions_destroy(file_actionsp);\n"
"        if (s != 0)\n"
"            errExitEN(s, \"posix_spawn_file_actions_destroy\");\n"
"    }\n"
msgstr ""
"    if (file_actionsp != NULL) {\n"
"        s = posix_spawn_file_actions_destroy(file_actionsp);\n"
"        if (s != 0)\n"
"            errExitEN(s, \"posix_spawn_file_actions_destroy\");\n"
"    }\n"

#. type: Plain text
#: build/C/man3/posix_spawn.3:785
#, no-wrap
msgid "    printf(\"PID of child: %jd\\en\", (intmax_t) child_pid);\n"
msgstr "    printf(\"PID of child: %jd\\en\", (intmax_t) child_pid);\n"

#. type: Plain text
#: build/C/man3/posix_spawn.3:787
#, fuzzy, no-wrap
#| msgid "    /* Create the child in new namespace(s) */\n"
msgid "    /* Monitor status of the child until it terminates */\n"
msgstr "    /* 新しい名前空間で子プロセスを作成する */\n"

#. type: Plain text
#: build/C/man3/posix_spawn.3:792
#, no-wrap
msgid ""
"    do {\n"
"        s = waitpid(child_pid, &status, WUNTRACED | WCONTINUED);\n"
"        if (s == -1)\n"
"            errExit(\"waitpid\");\n"
msgstr ""
"    do {\n"
"        s = waitpid(child_pid, &status, WUNTRACED | WCONTINUED);\n"
"        if (s == -1)\n"
"            errExit(\"waitpid\");\n"

#. type: Plain text
#: build/C/man3/posix_spawn.3:804
#, no-wrap
msgid ""
"        printf(\"Child status: \");\n"
"        if (WIFEXITED(status)) {\n"
"            printf(\"exited, status=%d\\en\", WEXITSTATUS(status));\n"
"        } else if (WIFSIGNALED(status)) {\n"
"            printf(\"killed by signal %d\\en\", WTERMSIG(status));\n"
"        } else if (WIFSTOPPED(status)) {\n"
"            printf(\"stopped by signal %d\\en\", WSTOPSIG(status));\n"
"        } else if (WIFCONTINUED(status)) {\n"
"            printf(\"continued\\en\");\n"
"        }\n"
"    } while (!WIFEXITED(status) && !WIFSIGNALED(status));\n"
msgstr ""
"        printf(\"Child status: \");\n"
"        if (WIFEXITED(status)) {\n"
"            printf(\"exited, status=%d\\en\", WEXITSTATUS(status));\n"
"        } else if (WIFSIGNALED(status)) {\n"
"            printf(\"killed by signal %d\\en\", WTERMSIG(status));\n"
"        } else if (WIFSTOPPED(status)) {\n"
"            printf(\"stopped by signal %d\\en\", WSTOPSIG(status));\n"
"        } else if (WIFCONTINUED(status)) {\n"
"            printf(\"continued\\en\");\n"
"        }\n"
"    } while (!WIFEXITED(status) && !WIFSIGNALED(status));\n"

#. type: Plain text
#: build/C/man3/posix_spawn.3:846
msgid ""
"B<close>(2), B<dup2>(2), B<execl>(2), B<execlp>(2), B<fork>(2), B<open>(2), "
"B<sched_setparam>(2), B<sched_setscheduler>(2), B<setpgid>(2), B<setuid>(2), "
"B<sigaction>(2), B<sigprocmask>(2), B<posix_spawn_file_actions_addclose>(3), "
"B<posix_spawn_file_actions_adddup2>(3), "
"B<posix_spawn_file_actions_addopen>(3), "
"B<posix_spawn_file_actions_destroy>(3), B<posix_spawn_file_actions_init>(3), "
"B<posix_spawnattr_destroy>(3), B<posix_spawnattr_getflags>(3), "
"B<posix_spawnattr_getpgroup>(3), B<posix_spawnattr_getschedparam>(3), "
"B<posix_spawnattr_getschedpolicy>(3), B<posix_spawnattr_getsigdefault>(3), "
"B<posix_spawnattr_getsigmask>(3), B<posix_spawnattr_init>(3), "
"B<posix_spawnattr_setflags>(3), B<posix_spawnattr_setpgroup>(3), "
"B<posix_spawnattr_setschedparam>(3), B<posix_spawnattr_setschedpolicy>(3), "
"B<posix_spawnattr_setsigdefault>(3), B<posix_spawnattr_setsigmask>(3), "
"B<pthread_atfork>(3), I<E<lt>spawn.hE<gt>>, Base Definitions volume of "
"POSIX.1-2001, I<http://www.opengroup.org/unix/online.html>"
msgstr ""

#~ msgid ""
#~ "Make arbitrary manipulations of process GIDs and supplementary GID list; "
#~ "forge GID when passing socket credentials via UNIX domain sockets; write "
#~ "a group ID mapping in a user namespace (see B<user_namespaces>(7))."
#~ msgstr ""
#~ "プロセスの GID と追加の GID リストに対する任意の操作を行う。 UNIX ドメイン"
#~ "ソケット経由でソケットの資格情報 (credential) を渡す際に 偽の GID を渡すこ"
#~ "とができる。 ユーザー名前空間にグループ ID マッピングを書き込むことができ"
#~ "る (B<user_namespaces>(7) 参照)。"

#~ msgid ""
#~ "Make arbitrary manipulations of process UIDs (B<setuid>(2), "
#~ "B<setreuid>(2), B<setresuid>(2), B<setfsuid>(2)); forge UID when passing "
#~ "socket credentials via UNIX domain sockets; write a user ID mapping in a "
#~ "user namespace (see B<user_namespaces>(7))."
#~ msgstr ""
#~ "プロセスの UID に対する任意の操作 (B<setuid>(2), B<setreuid>(2), "
#~ "B<setresuid>(2), B<setfsuid>(2))  を行う。 UNIX ドメインソケット経由でソ"
#~ "ケットの資格情報 (credential) を渡す際に 偽の UID を渡すことができる。 "
#~ "ユーザー名前空間にユーザー ID マッピングを書き込むことができる "
#~ "(B<user_namespaces>(7) 参照)。"

#~ msgid "denotes the value of a capability set after the B<execve>(2)"
#~ msgstr "B<execve>(2)  後のスレッドのケーパビリティセットの値"

#~ msgid ""
#~ "In order to provide an all-powerful I<root> using capability sets, during "
#~ "an B<execve>(2):"
#~ msgstr ""
#~ "B<execve>(2)  時に、ケーパビリティセットを使って、全ての権限を持った "
#~ "I<root> を実現するには、以下のようにする。"

#~ msgid ""
#~ "If a set-user-ID-root program is being executed, or the real user ID of "
#~ "the process is 0 (root)  then the file inheritable and permitted sets are "
#~ "defined to be all ones (i.e., all capabilities enabled)."
#~ msgstr ""
#~ "set-user-ID-root プログラムが実行される場合、 またはプロセスの実ユーザー "
#~ "ID が 0 (root) の場合、 ファイルの継承可能セットと許可セットを全て 1 (全て"
#~ "のケーパビリティが有効) に定義する。"

#~ msgid ""
#~ "The upshot of the above rules, combined with the capabilities "
#~ "transformations described above, is that when a process B<execve>(2)s a "
#~ "set-user-ID-root program, or when a process with an effective UID of 0 "
#~ "B<execve>(2)s a program, it gains all capabilities in its permitted and "
#~ "effective capability sets, except those masked out by the capability "
#~ "bounding set.  This provides semantics that are the same as those "
#~ "provided by traditional UNIX systems."
#~ msgstr ""
#~ "上記のルールにケーパビリティ変換を適用した結果をまとめると、 プロセスが "
#~ "set-user-ID-root プログラムを B<execve>(2)  する場合、または実効 UID が 0 "
#~ "のプロセスがプログラムを B<execve>(2)  する場合、許可と実効のケーパビリ"
#~ "ティセットの全ケーパビリティ (正確には、ケーパビリティバウンディングセット"
#~ "によるマスクで除外されるもの 以外の全てのケーパビリティ) を取得するという"
#~ "ことである。 これにより、伝統的な UNIX システムと同じ振る舞いができるよう"
#~ "になっている。"

#~ msgid ""
#~ "As of Linux 2.2, the power of the superuser (root) has been partitioned "
#~ "into a set of discrete capabilities.  Each thread has a set of effective "
#~ "capabilities identifying which capabilities (if any) it may currently "
#~ "exercise.  Each thread also has a set of inheritable capabilities that "
#~ "may be passed through an B<execve>(2)  call, and a set of permitted "
#~ "capabilities that it can make effective or inheritable."
#~ msgstr ""
#~ "Linux 2.2 で、スーパーユーザー (root) の権限は、個別のケーパビリティ "
#~ "(capabilities) へと分割され、その集合として表現されるようになった。 各ス"
#~ "レッドは「実効ケーパビリティ (effective capability) の集合」を持ち、 それ"
#~ "によって現在どの操作が実行可能かを識別できる。 また、各スレッドは、 「継承"
#~ "可能ケーパビリティ (inheritable capability) の集合」と 「許可ケーパビリ"
#~ "ティ (permitted capability) の集合」を持つ。 「継承可能ケーパビリティの集"
#~ "合」は B<execve>(2)  を通じて渡すことができるケーパビリティの集合であり、 "
#~ "「許可ケーパビリティ (permitted capability) の集合」は 実効ケーパビリティ"
#~ "や継承可能ケーパビリティとして有効にできる ケーパビリティを規定するもので"
#~ "ある。"

#~ msgid ""
#~ "Another change affecting the behavior of these system calls is kernel "
#~ "support for file capabilities (VFS capability support).  This support is "
#~ "currently a compile time option (added in kernel 2.6.24)."
#~ msgstr ""
#~ "これらのシステムコールの挙動に影響があるもう一つの変更点は、 ファイルケー"
#~ "パビリティ (file capabilities) のカーネルによるサポート (VFS ケーパビリ"
#~ "ティのサポート) である。 VFS ケーパビリティのサポートは現在のところコンパ"
#~ "イル時のオプションである (カーネル 2.6.24 で追加された)。"

#~ msgid ""
#~ "B<getppid>()  returns the process ID of the parent of the calling process."
#~ msgstr ""
#~ "B<getppid>()  は呼び出し元のプロセスの親プロセスのプロセス ID を返す。"

#~ msgid ""
#~ "The caller attempted to lower a process priority, but did not have the "
#~ "required privilege (on Linux: did not have the B<CAP_SYS_NICE> "
#~ "capability).  Since Linux 2.6.12, this error occurs only if the caller "
#~ "attempts to set a process priority outside the range of the "
#~ "B<RLIMIT_NICE> soft resource limit of the target process; see "
#~ "B<getrlimit>(2)  for details."
#~ msgstr ""
#~ "呼び出し元がプロセスの優先度を下げようとしたが、必要な特権を 持っていな"
#~ "かった (Linux の場合、 B<CAP_SYS_NICE> ケーパビリティがなかった)。 Linux "
#~ "2.6.12 以降では、呼び出し元が、あるプロセスの優先度を、 変更対象のプロセス"
#~ "のリソース B<RLIMIT_NICE> のソフトリミットの範囲外に設定しようとした場合に"
#~ "のみ、 このエラーが発生する。詳細は B<getrlimit>(2)  を参照。"

#~ msgid ""
#~ "SVr4, 4.4BSD (these function calls first appeared in 4.2BSD), "
#~ "POSIX.1-2001."
#~ msgstr ""
#~ "SVr4, 4.4BSD (これらの関数は 4.2BSD で最初に登場した), POSIX.1-2001."

#~ msgid ""
#~ "The degree to which their relative nice value affects the scheduling of "
#~ "processes varies across UNIX systems, and, on Linux, across kernel "
#~ "versions.  Starting with kernel 2.6.23, Linux adopted an algorithm that "
#~ "causes relative differences in nice values to have a much stronger "
#~ "effect.  This causes very low nice values (+19) to truly provide little "
#~ "CPU to a process whenever there is any other higher priority load on the "
#~ "system, and makes high nice values (-20) deliver most of the CPU to "
#~ "applications that require it (e.g., some audio applications)."
#~ msgstr ""
#~ "相対的な nice 値の違いがプロセス間のスケジューリングにどの程度影響を与える"
#~ "か は、UNIX システム間で異なり、Linux ではカーネルバージョンにより異な"
#~ "る。 Linux は、カーネル 2.6.23 以降で、nice 値の相対的な違いが、非常に強い"
#~ "影響を 与えるアルゴリズムを採用した。このアルゴリズムでは、 他に優先度の高"
#~ "いものがシステムに存在する時には、 非常に低い nice 値 (+19) ではプロセスに"
#~ "本当にほとんど CPU が割り当てられない。 また、高い nice 値 (-20) では CPU "
#~ "を必要とするアプリケーション (例えば オーディオアプリケーション) に CPU の"
#~ "ほとんどが割り当てられる。"

#~ msgid ""
#~ "The actual priority range varies between kernel versions.  Linux before "
#~ "1.3.36 had -infinity..15.  Since kernel 1.3.43, Linux has the range "
#~ "-20..19.  On some other systems, the range of nice values is -20..20."
#~ msgstr ""
#~ "実際の優先度の範囲はカーネルのバージョンにより異なる。 バージョン 1.3.36 "
#~ "より前の Linux では -infinity(マイナス無限大)..15 である。 カーネル "
#~ "1.3.43 以降の Linux では、 -20..19 である。 他のいくつかのシステムでは、こ"
#~ "の範囲が -20..20 である。"

#~ msgid ""
#~ "The maximum number of processes (or, more precisely on Linux, threads)  "
#~ "that can be created for the real user ID of the calling process.  Upon "
#~ "encountering this limit, B<fork>(2)  fails with the error B<EAGAIN>.  "
#~ "This limit is not enforced for processes that have either the "
#~ "B<CAP_SYS_ADMIN> or the B<CAP_SYS_RESOURCE> capability."
#~ msgstr ""
#~ "呼び出したプロセスの実ユーザー ID で作成できる最大プロセス数 (より正確に"
#~ "は Linux ではスレッド数)。 この上限に達すると、 B<fork>(2)  はエラー "
#~ "B<EAGAIN> で失敗する。 この上限値は、ケーパビリティ B<CAP_SYS_ADMIN> か "
#~ "B<CAP_SYS_RESOURCE> のどちらかを持つプロセスには適用されない。"

#~ msgid "C library/ kernel ABI differences"
#~ msgstr "C ライブラリとカーネル ABI の違い"

#~ msgid ""
#~ "This problem was addressed in Linux 2.6.36 with two principal changes:"
#~ msgstr "この問題は Linux 2.6.36 での以下の主な変更により解決された。"

#~ msgid ""
#~ "the addition of a new kernel representation of resource limits that uses "
#~ "64 bits, even on 32-bit platforms;"
#~ msgstr ""
#~ "32 ビットプラットフォームであっても 64 ビットを使用するリソース上限の新し"
#~ "いカーネルでの表現方法の追加。"

#~ msgid ""
#~ "the addition of the B<prlimit>()  system call, which employs 64-bit "
#~ "values for its resource limit arguments."
#~ msgstr ""
#~ "リソース上限の引数として 64 ビット値を取る B<prlimit>() システムコールの"
#~ "追加。"

#~ msgid ""
#~ "This call is necessary to allow 8514-compatible X servers to run under "
#~ "Linux.  Since these X servers require access to all 65536 I/O ports, the "
#~ "B<ioperm>(2)  call is not sufficient."
#~ msgstr ""
#~ "この関数は 8514 互換の X サーバを Linux で動作させるために必要である。 な"
#~ "ぜならこの X サーバは 65536 個の I/O ポート全てへのアクセスを要求するので "
#~ "B<ioperm>(2)  関数では不十分だからである。"

#~ msgid "Permissions are inherited by B<fork>(2)  and B<execve>(2)."
#~ msgstr "B<fork>(2)  や B<exec>(2)  を行った場合、特権は継承される。"

#~ msgid "namespaces - overview of Linux namespaces"
#~ msgstr "namespaces - Linux 名前空間の概要"

#~ msgid ""
#~ "A namespace wraps a global system resource in an abstraction that makes "
#~ "it appear to the processes within the namespace that they have their own "
#~ "isolated instance of the global resource.  Changes to the global resource "
#~ "are visible to other processes that are members of the namespace, but are "
#~ "invisible to other processes.  One use of namespaces is to implement "
#~ "containers."
#~ msgstr ""
#~ "名前空間は、 グローバルシステムリソースを抽象化層で覆うことで、 名前空間内"
#~ "のプロセスに対して、 自分たちが専用の分離されたグローバルリソースを持って"
#~ "いるかのように見せる仕組みである。 グローバルリソースへの変更は、 名前空間"
#~ "のメンバーである他のプロセスには見えるが、 それ以外のプロセスには見えな"
#~ "い。 名前空間の一つの利用方法はコンテナーの実装である。"

#~ msgid "Linux provides the following namespaces:"
#~ msgstr "Linux では以下の名前空間が提供される。"

#~ msgid "Namespace"
#~ msgstr "名前空間"

#~ msgid "Constant"
#~ msgstr "定数"

#~ msgid "Network devices, stacks, ports, etc."
#~ msgstr "ネットワークデバイス、スタック、ポートなど"

#~ msgid "Mount points"
#~ msgstr "マウントポイント"

#~ msgid "User and group IDs"
#~ msgstr "ユーザー ID とグループ ID"

#~ msgid "Hostname and NIS domain name"
#~ msgstr "ホスト名と NIS ドメイン名"

#
#~ msgid ""
#~ "This page describes the various namespaces and the associated I</proc> "
#~ "files, and summarizes the APIs for working with namespaces."
#~ msgstr ""
#~ "このページでは、各種の名前空間と関連する I</proc> ファイルの説明と、名前空"
#~ "間とともに動作する API の概要を紹介する。"

#~ msgid "The namespaces API"
#~ msgstr "名前空間 API"

#~ msgid ""
#~ "As well as various I</proc> files described below, the namespaces API "
#~ "includes the following system calls:"
#~ msgstr ""
#~ "後で説明する種々の I</proc> ファイル以外に、名前空間 API として以下のシス"
#~ "テムコールがある。"

#~ msgid ""
#~ "The B<clone>(2)  system call creates a new process.  If the I<flags> "
#~ "argument of the call specifies one or more of the B<CLONE_NEW*> flags "
#~ "listed below, then new namespaces are created for each flag, and the "
#~ "child process is made a member of those namespaces.  (This system call "
#~ "also implements a number of features unrelated to namespaces.)"
#~ msgstr ""
#~ "B<clone>(2) システムコールは新しいプロセスを作成する。 呼び出し時に "
#~ "I<flags> 引数で以下のリストにある B<CLONE_NEW*> のフラグを一つ以上指定す"
#~ "ると、 各フラグに対応する新しい名前空間が作成され、 子プロセスはこれらの名"
#~ "前空間のメンバーになる。 (このシステムコールは名前空間とは関係のない機能も"
#~ "多数実装している。)"

#~ msgid ""
#~ "The B<setns>(2)  system call allows the calling process to join an "
#~ "existing namespace.  The namespace to join is specified via a file "
#~ "descriptor that refers to one of the I</proc/[pid]/ns> files described "
#~ "below."
#~ msgstr ""
#~ "B<setns>(2) システムコールを使うと、呼び出したプロセスを既存の名前空間に参"
#~ "加させることができる。 参加する名前空間は、 以下で説明する I</proc/[pid]/"
#~ "ns> ファイルのいずれか一つを参照するファイルディスクリプターを使って指定す"
#~ "る。"

#~ msgid ""
#~ "The B<unshare>(2)  system call moves the calling process to a new "
#~ "namespace.  If the I<flags> argument of the call specifies one or more of "
#~ "the B<CLONE_NEW*> flags listed below, then new namespaces are created for "
#~ "each flag, and the calling process is made a member of those namespaces.  "
#~ "(This system call also implements a number of features unrelated to "
#~ "namespaces.)"
#~ msgstr ""
#~ "B<unshare>(2) システムコールは、 呼び出したプロセスを新しい名前空間に移動"
#~ "する。 呼び出し時の I<flags> 引数に以下のリストにある B<CLONE_NEW*> フラ"
#~ "グを一つ以上指定すると、 各フラグに対応する新しい名前空間が作成され、 呼び"
#~ "出したプロセスがこれらの名前空間のメンバーになる。 (このシステムコールは名"
#~ "前空間とは関係のない機能も多数実装している。)"

#
#~ msgid ""
#~ "Creation of new namespaces using B<clone>(2)  and B<unshare>(2)  in most "
#~ "cases requires the B<CAP_SYS_ADMIN> capability.  User namespaces are the "
#~ "exception: since Linux 3.8, no privilege is required to create a user "
#~ "namespace."
#~ msgstr ""
#~ "B<clone>(2) と B<unshare>(2) を使った新しい名前空間の作成のほとんどの場合"
#~ "で B<CAP_SYS_ADMIN> ケーパビリティが必要である。 ユーザー名前空間は例外"
#~ "で、 Linux 3.8 以降ではユーザー名前空間を作成するのに特権が不要である。"

#~ msgid ""
#~ "Each process has a I</proc/[pid]/ns/> subdirectory containing one entry "
#~ "for each namespace that supports being manipulated by B<setns>(2):"
#~ msgstr ""
#~ "各プロセスには I</proc/[pid]/ns/> サブディレクトリがあり、 このサブディレ"
#~ "クトリには B<setns>(2) での操作がサポートされている名前空間単位にエント"
#~ "リーが存在する。"

#~ msgid ""
#~ "Bind mounting (see B<mount>(2))  one of the files in this directory to "
#~ "somewhere else in the filesystem keeps the corresponding namespace of the "
#~ "process specified by I<pid> alive even if all processes currently in the "
#~ "namespace terminate."
#~ msgstr ""
#~ "このディレクトリ内のファイルのいずれかをファイルシステムの他のどこかにバイ"
#~ "ンドマウント (B<mount>(2) 参照) することで、 その名前空間のすべてのプロセ"
#~ "スが終了した場合でも、 I<pid> で指定したプロセスの対応する名前空間を保持す"
#~ "ることができる。"

#~ msgid ""
#~ "Opening one of the files in this directory (or a file that is bind "
#~ "mounted to one of these files)  returns a file handle for the "
#~ "corresponding namespace of the process specified by I<pid>.  As long as "
#~ "this file descriptor remains open, the namespace will remain alive, even "
#~ "if all processes in the namespace terminate.  The file descriptor can be "
#~ "passed to B<setns>(2)."
#~ msgstr ""
#~ "このディレクトリ内のファイルのいずれか (またはこれらのファイルのいずれかに"
#~ "バインドマウントされたファイル) をオープンすると、 I<pid> で指定されたプロ"
#~ "セスの対応する名前空間に対するファイルハンドルが返される。 このファイル"
#~ "ディスクリプターがオープンされている限り、 その名前空間のすべてのプロセス"
#~ "が終了した場合であっても、 その名前空間は存在し続ける。 このファイルディス"
#~ "クリプターは B<setns>(2) に渡すことができる。"

#~ msgid ""
#~ "In Linux 3.7 and earlier, these files were visible as hard links.  Since "
#~ "Linux 3.8, they appear as symbolic links.  If two processes are in the "
#~ "same namespace, then the inode numbers of their I</proc/[pid]/ns/xxx> "
#~ "symbolic links will be the same; an application can check this using the "
#~ "I<stat.st_ino> field returned by B<stat>(2).  The content of this "
#~ "symbolic link is a string containing the namespace type and inode number "
#~ "as in the following example:"
#~ msgstr ""
#~ "Linux 3.7 以前では、これらのファイルはハードリンクとして見えていた。 "
#~ "Linux 3.8 以降では、これらはシンボリックリンクとして見える。 2 つのプロセ"
#~ "スが同じ名前空間に所属している場合、 これらのプロセスの I</proc/[pid]/ns/"
#~ "xxx> シンボリックリンクの inode 番号は同じになる。 アプリケーションは、 "
#~ "B<stat>(2) が返す I<stat.st_ino> フィールドを使ってこれを確認することがで"
#~ "きる。 シンボリックリンクの内容は、 以下の例にあるように、名前空間種別と "
#~ "inode 番号を含む文字列である。"

#~ msgid "This file is a handle for the IPC namespace of the process."
#~ msgstr "このファイルはそのプロセスの IPC 名前空間の操作用である。"

#~ msgid "This file is a handle for the mount namespace of the process."
#~ msgstr "このファイルはそのプロセスのマウント名前空間の操作用である。"

#~ msgid "This file is a handle for the network namespace of the process."
#~ msgstr "このファイルはそのプロセスのネットワーク名前空間の操作用である。"

#~ msgid "This file is a handle for the PID namespace of the process."
#~ msgstr "このファイルはそのプロセスの PID 名前空間の操作用である。"

#~ msgid "This file is a handle for the user namespace of the process."
#~ msgstr "このファイルはそのプロセスのユーザー名前空間の操作用である。"

#
#~ msgid "This file is a handle for the UTS namespace of the process."
#~ msgstr "このファイルはそのプロセスの UTS 名前空間の操作用である。"

#~ msgid ""
#~ "IPC namespaces isolate certain IPC resources, namely, System V IPC "
#~ "objects (see B<svipc>(7))  and (since Linux 2.6.30)  POSIX message queues "
#~ "(see B<mq_overview>(7)).  The common characteristic of these IPC "
#~ "mechanisms is that IPC objects are identified by mechanisms other than "
#~ "filesystem pathnames."
#~ msgstr ""
#~ "IPC 名前空間は、 特定の IPC リソース、すなわち、System V IPC オブジェクト "
#~ "(B<svipc>(7) 参照)、(Linux 2.6.30 以降では) POSIX メッセージキュー "
#~ "(B<mq_overview>(7) 参照) を分離する。 これらの IPC 機構に共通の特徴は、 "
#~ "IPC オブジェクトがファイルシステムのパス名以外の方法で識別されるという点で"
#~ "ある。"

#~ msgid ""
#~ "Each IPC namespace has its own set of System V IPC identifiers and its "
#~ "own POSIX message queue filesystem.  Objects created in an IPC namespace "
#~ "are visible to all other processes that are members of that namespace, "
#~ "but are not visible to processes in other IPC namespaces."
#~ msgstr ""
#~ "各 IPC 名前空間はそれぞれ、 独自の System V IPC 識別子の集合と独自の "
#~ "POSIX メッセージキューファイルシステムを持つ。 IPC 名前空間に作成されたオ"
#~ "ブジェクトは、 その名前空間のメンバーの他のすべてのプロセスにも見えるが、 "
#~ "他の IPC 名前空間のプロセスには見えない。"

#~ msgid ""
#~ "The following I</proc> interfaces are distinct in each IPC namespace:"
#~ msgstr "以下の I</proc> インターフェースは各 IPC 名前空間で別のものとなる。"

#~ msgid "The POSIX message queue interfaces in I</proc/sys/fs/mqueue>."
#~ msgstr "I</proc/sys/fs/mqueue> の POSIX メッセージキューインターフェース。"

#~ msgid ""
#~ "The System V IPC interfaces in I</proc/sys/kernel>, namely: I<msgmax>, "
#~ "I<msgmnb>, I<msgmni>, I<sem>, I<shmall>, I<shmmax>, I<shmmni>, and "
#~ "I<shm_rmid_forced>."
#~ msgstr ""
#~ "I</proc/sys/kernel> の System V IPC インターフェース。 すなわち、 "
#~ "I<msgmax>, I<msgmnb>, I<msgmni>, I<sem>, I<shmall>, I<shmmax>, I<shmmni>, "
#~ "I<shm_rmid_forced>。"

#~ msgid "The System V IPC interfaces in I</proc/sysvipc>."
#~ msgstr "I</proc/sysvipc> の System V IPC インターフェース。"

#~ msgid ""
#~ "When an IPC namespace is destroyed (i.e., when the last process that is a "
#~ "member of the namespace terminates), all IPC objects in the namespace are "
#~ "automatically destroyed."
#~ msgstr ""
#~ "IPC 名前空間が破棄されたときに (すなわち、その名前空間のメンバーの最後のプ"
#~ "ロセスが終了したときに)、 その名前空間内のすべての IPC オブジェクトが自動"
#~ "的に破棄される。"

#
#~ msgid ""
#~ "Use of IPC namespaces requires a kernel that is configured with the "
#~ "B<CONFIG_IPC_NS> option."
#~ msgstr ""
#~ "IPC 名前空間を使用するには、設定 B<CONFIG_IPC_NS> が有効になったカーネルが"
#~ "必要である。"

#~ msgid "Network namespaces (CLONE_NEWNET)"
#~ msgstr "ネットワーク名前空間 (CLONE_NEWNET)"

#~ msgid ""
#~ "Network namespaces provide isolation of the system resources associated "
#~ "with networking: network devices, IPv4 and IPv6 protocol stacks, IP "
#~ "routing tables, firewalls, the I</proc/net> directory, the I</sys/class/"
#~ "net> directory, port numbers (sockets), and so on.  A physical network "
#~ "device can live in exactly one network namespace.  A virtual network "
#~ "device (\"veth\") pair provides a pipe-like abstraction that can be used "
#~ "to create tunnels between network namespaces, and can be used to create a "
#~ "bridge to a physical network device in another namespace."
#~ msgstr ""
#~ "ネットワーク名前空間は、 ネットワークに関連するシステムリソースの分離を提"
#~ "供する。 分離されるリソースは、 ネットワークデバイス、 IPv4 と IPv6 のプロ"
#~ "トコルスタック、 IP ルーティングテーブル、 ファイアウォール、 I</proc/"
#~ "net> ディレクトリ、 I</sys/class/net> ディレクトリ、 (ソケットの) ポート番"
#~ "号などである。 物理ネットワークデバイスは 1 つのネットワーク名前空間にのみ"
#~ "属すことができる。 仮想ネットワークデバイス (\"veth\") ペアは、 ネットワー"
#~ "ク名前空間間のトンネルを作成するのに使うことができるパイプ風の抽象概念"
#~ "で、 別の名前空間に属す物理ネットワークデバイスへのブリッジを作成するのに"
#~ "使用できる。"

#~ msgid ""
#~ "When a network namespace is freed (i.e., when the last process in the "
#~ "namespace terminates), its physical network devices are moved back to the "
#~ "initial network namespace (not to the parent of the process)."
#~ msgstr ""
#~ "ネットワーク名前空間が解放されたときに (すなわち、その名前空間の最後のプロ"
#~ "セスがしゅうりょうしたときに)、 その名前空間に属していた物理ネットワークデ"
#~ "バイスは初期ネットワーク名前空間に戻される (プロセスの親プロセスに戻される"
#~ "わけではない)。"

#
#~ msgid ""
#~ "Use of network namespaces requires a kernel that is configured with the "
#~ "B<CONFIG_NET_NS> option."
#~ msgstr ""
#~ "ネットワーク名前空間を使用するには、設定 B<CONFIG_NET_NS> が有効になった"
#~ "カーネルが必要である。"

#~ msgid "Mount namespaces (CLONE_NEWNS)"
#~ msgstr "マウント名前空間 (CLONE_NEWNS)"

#~ msgid ""
#~ "Mount namespaces isolate the set of filesystem mount points, meaning that "
#~ "processes in different mount namespaces can have different views of the "
#~ "filesystem hierarchy.  The set of mounts in a mount namespace is modified "
#~ "using B<mount>(2)  and B<umount>(2)."
#~ msgstr ""
#~ "マウント名前空間はファイルシステムのマウントポイントの集合を分離する。 つ"
#~ "まり、別のマウント名前空間のプロセスには別のファイルシステム階層が見えると"
#~ "いうことである。 マウント名前空間内のマウントの集合は B<mount>(2) と "
#~ "B<umount>(2) で変更される。"

#~ msgid ""
#~ "The I</proc/[pid]/mounts> file (present since Linux 2.4.19)  lists all "
#~ "the filesystems currently mounted in the process's mount namespace.  The "
#~ "format of this file is documented in B<fstab>(5).  Since kernel version "
#~ "2.6.15, this file is pollable: after opening the file for reading, a "
#~ "change in this file (i.e., a filesystem mount or unmount) causes "
#~ "B<select>(2)  to mark the file descriptor as readable, and B<poll>(2)  "
#~ "and B<epoll_wait>(2)  mark the file as having an error condition."
#~ msgstr ""
#~ "I</proc/[pid]/mounts> ファイル (Linux 2.4.19 以降に存在) は、 そのプロセス"
#~ "のマウント名前空間で現在マウントされている全ファイルシステムの一覧を表示す"
#~ "る。 このファイルのフォーマットは B<fstab>(5) に記載されている。 カーネル"
#~ "バージョン 2.6.15 以降では、このファイルをポーリングすることができる。 す"
#~ "なわち、このファイルを読み出し用にオープンした後、 このファイルの変化 "
#~ "(ファイルシステムのマウントやアンマウント) が発生すると、 B<select>(2) は"
#~ "ファイルディスクリプターが読み出し可能になったと印を付け、 B<poll>(2) や "
#~ "B<epoll_wait>(2) はファイルがエラー状態になったかのように印を付ける。"

#~ msgid ""
#~ "The I</proc/[pid]/mountstats> file (present since Linux 2.6.17)  exports "
#~ "information (statistics, configuration information)  about the mount "
#~ "points in the process's mount namespace.  This file is readable only by "
#~ "the owner of the process.  Lines in this file have the form:"
#~ msgstr ""
#~ "I</proc/[pid]/mountstats> ファイル (Linux 2.6.17 以降に存在) は、 そのプロ"
#~ "セスのマウントポイントに関する情報 (統計情報、設定情報) を公開する。 この"
#~ "ファイルはプロセスの所有者だけが読み出し可能である。 このファイルの各行は"
#~ "以下の形式である。"

#~ msgid "The fields in each line are:"
#~ msgstr "各行のフィールドは以下のとおりである。"

#~ msgid ""
#~ "The name of the mounted device (or \"nodevice\" if there is no "
#~ "corresponding device)."
#~ msgstr ""
#~ "マウントされているデバイス名 (もしくは、対応するデバイスがない場合は "
#~ "\"nodevice\")。"

#~ msgid "The mount point within the filesystem tree."
#~ msgstr "ファイルシステムツリー内のマウントポイント。"

#~ msgid "The filesystem type."
#~ msgstr "ファイルシステム種別"

#~ msgid ""
#~ "Optional statistics and configuration information.  Currently (as at "
#~ "Linux 2.6.26), only NFS filesystems export information via this field."
#~ msgstr ""
#~ "統計情報と設定情報。 オプションフィールドである。 現在のところ (Linux "
#~ "2.6.26 時点)、NFS ファイルシステムだけがこのフィールドで情報を公開してい"
#~ "る。"

#
#~ msgid "PID namespaces (CLONE_NEWPID)"
#~ msgstr "PID 名前空間 (CLONE_NEWPID)"

#
#~ msgid "See B<pid_namespaces>(7)."
#~ msgstr "B<pid_namespaces>(7) 参照。"

#~ msgid "User namespaces (CLONE_NEWUSER)"
#~ msgstr "ユーザー名前空間 (CLONE_NEWUSER)"

#~ msgid "See B<user_namespaces>(7)."
#~ msgstr "B<user_namespaces>(7) 参照。"

#~ msgid "UTS namespaces (CLONE_NEWUTS)"
#~ msgstr "UTS 名前空間 (CLONE_NEWUTS)"

#~ msgid ""
#~ "UTS namespaces provide isolation of two system identifiers: the hostname "
#~ "and the NIS domain name.  These identifiers are set using "
#~ "B<sethostname>(2)  and B<setdomainname>(2), and can be retrieved using "
#~ "B<uname>(2), B<gethostname>(2), and B<getdomainname>(2)."
#~ msgstr ""
#~ "UTS 名前空間は、 ホスト名と NIS ドメイン名の 2 つのシステム識別子を分離す"
#~ "る。 これらの識別子は B<sethostname>(2) と B<setdomainname>(2) を使って設"
#~ "定でき、 B<uname>(2), B<gethostname>(2), B<getdomainname>(2) を使って取得"
#~ "できる。"

#~ msgid ""
#~ "Use of UTS namespaces requires a kernel that is configured with the "
#~ "B<CONFIG_UTS_NS> option."
#~ msgstr ""
#~ "UTS 名前空間を使用するには、設定 B<CONFIG_UTS_NS> が有効になったカーネルが"
#~ "必要である。"

#~ msgid "Namespaces are a Linux-specific feature."
#~ msgstr "名前空間は Linux 独自の機能である。"

#~ msgid "pid_namespaces - overview of Linux PID namespaces"
#~ msgstr "pid_namespaces - Linux PID 名前空間の概要"

#~ msgid "For an overview of namespaces, see B<namespaces>(7)."
#~ msgstr "名前空間の概要については B<namespaces>(7) を参照。"

#~ msgid ""
#~ "PID namespaces isolate the process ID number space, meaning that "
#~ "processes in different PID namespaces can have the same PID.  PID "
#~ "namespaces allow containers to provide functionality such as suspending/"
#~ "resuming the set of processes in the container and migrating the "
#~ "container to a new host while the processes inside the container maintain "
#~ "the same PIDs."
#~ msgstr ""
#~ "PID 名前空間はプロセス ID 番号空間を分離する。 これは、異なる PID 名前空間"
#~ "のプロセスは同じ PID を持つことができることを意味する。 PID 名前空間を使う"
#~ "ことで、コンテナー内のプロセス群を中断、再開したり、 コンテナー内のプロセ"
#~ "スの PID を保持したままコンテナーを新しいホストに移行したりするといった機"
#~ "能をコンテナーが提供することが可能になる。"

#~ msgid ""
#~ "PIDs in a new PID namespace start at 1, somewhat like a standalone "
#~ "system, and calls to B<fork>(2), B<vfork>(2), or B<clone>(2)  will "
#~ "produce processes with PIDs that are unique within the namespace."
#~ msgstr ""
#~ "新しい PID 名前空間の PID は、 独立したシステムであるかのように、 1 から始"
#~ "まる。 B<fork>(2), B<vfork>(2), B<clone>(2) を呼び出すと、 その名前空間内"
#~ "で一意な PID でプロセスが生成される。"

#
#~ msgid ""
#~ "Use of PID namespaces requires a kernel that is configured with the "
#~ "B<CONFIG_PID_NS> option."
#~ msgstr ""
#~ "PID 名前空間を使用するには、設定 B<CONFIG_PID_NS> が有効になったカーネルが"
#~ "必要である。"

#~ msgid "The namespace init process"
#~ msgstr "名前空間の init プロセス"

#~ msgid ""
#~ "The first process created in a new namespace (i.e., the process created "
#~ "using B<clone>(2)  with the B<CLONE_NEWPID> flag, or the first child "
#~ "created by a process after a call to B<unshare>(2)  using the "
#~ "B<CLONE_NEWPID> flag) has the PID 1, and is the \"init\" process for the "
#~ "namespace (see B<init>(1)).  A child process that is orphaned within the "
#~ "namespace will be reparented to this process rather than B<init>(1)  "
#~ "(unless one of the ancestors of the child in the same PID namespace "
#~ "employed the B<prctl>(2)  B<PR_SET_CHILD_SUBREAPER> command to mark "
#~ "itself as the reaper of orphaned descendant processes)."
#~ msgstr ""
#~ "新しい名前空間で作成される最初のプロセス (すなわち、B<CLONE_NEWPID> フラグ"
#~ "で B<clone>(2) を使って作成されたプロセスや、 B<CLONE_NEWPID> フラグで "
#~ "B<unshare>(2) を呼び出した後のプロセスによって作成された最初のプロセス) "
#~ "は PID 1 を持ち、 そのプロセスはその名前空間の \"init\" プロセスとなる "
#~ "(B<init>(1) 参照)。 名前空間内でみなしごになった (親プロセスがいなくなっ"
#~ "た) 子プロセスは、 B<init>(1) ではなくこのプロセスが親プロセスになる (ただ"
#~ "し、 同じ PID 名前空間内のその子プロセスの先祖が、 B<prctl>(2) の "
#~ "B<PR_SET_CHILD_SUBREAPER> コマンドを使って、 自分自身をみなしごとなった子"
#~ "孫のプロセスの引き取り手になっている場合はこの限りではなく)。"

#~ msgid ""
#~ "If the \"init\" process of a PID namespace terminates, the kernel "
#~ "terminates all of the processes in the namespace via a B<SIGKILL> "
#~ "signal.  This behavior reflects the fact that the \"init\" process is "
#~ "essential for the correct operation of a PID namespace.  In this case, a "
#~ "subsequent B<fork>(2)  into this PID namespace will fail with the error "
#~ "B<ENOMEM>; it is not possible to create a new processes in a PID "
#~ "namespace whose \"init\" process has terminated.  Such scenarios can "
#~ "occur when, for example, a process uses an open file descriptor for a I</"
#~ "proc/[pid]/ns/pid> file corresponding to a process that was in a "
#~ "namespace to B<setns>(2)  into that namespace after the \"init\" process "
#~ "has terminated.  Another possible scenario can occur after a call to "
#~ "B<unshare>(2): if the first child subsequently created by a B<fork>(2)  "
#~ "terminates, then subsequent calls to B<fork>(2)  will fail with B<ENOMEM>."
#~ msgstr ""
#~ "PID 名前空間の \"init\" プロセスが終了すると、 カーネルはその名前空間の全"
#~ "プロセスを B<SIGKILL> シグナルで終了する。 この動作は、 PID 名前空間の正し"
#~ "い操作のためには \"init\" プロセスは不可欠であるという事実を反映したもので"
#~ "ある。 この場合、 その PID 名前空間へのそれ以降の B<fork>(2) はエラー "
#~ "B<ENOMEM> で失敗する。 \"init\" プロセスが終了している PID 名前空間に新し"
#~ "いプロセスを作成することはできない。 このような状況は、 例えば、 名前空間"
#~ "にいたプロセスに対応する I</proc/[pid]/ns/pid> ファイルに対してオープンし"
#~ "たファイルディスクリプターを使って、 \"init\" プロセスが終了した後にその名"
#~ "前空間に B<setns>(2) を行った場合に起こり得る。 B<unshare>(2) を呼び出した"
#~ "後にも、この状況は起こり得る。 それ以降に B<fork>(2) で作成された最初の子"
#~ "プロセスが終了すると、 それ以降の B<fork>(2) の呼び出しは B<NOMEM> で失敗"
#~ "する。"

#~ msgid ""
#~ "Only signals for which the \"init\" process has established a signal "
#~ "handler can be sent to the \"init\" process by other members of the PID "
#~ "namespace.  This restriction applies even to privileged processes, and "
#~ "prevents other members of the PID namespace from accidentally killing the "
#~ "\"init\" process."
#~ msgstr ""
#~ "PID 名前空間の他のメンバーは、 \"init\" プロセスがシグナルハンドラーを設定"
#~ "したシグナルだけを、 \"init\" プロセスに送信することができる。 この制限は"
#~ "特権プロセスに対しても適用される。 この制限により、 PID 名前空間の他のメン"
#~ "バーがうっかり \"init\" プロセスを殺してしまうのを防ぐことができる。"

#~ msgid ""
#~ "Likewise, a process in an ancestor namespace can\\(emsubject to the usual "
#~ "permission checks described in B<kill>(2)\\(emsend signals to the \"init"
#~ "\" process of a child PID namespace only if the \"init\" process has "
#~ "established a handler for that signal.  (Within the handler, the "
#~ "I<siginfo_t> I<si_pid> field described in B<sigaction>(2)  will be "
#~ "zero.)  B<SIGKILL> or B<SIGSTOP> are treated exceptionally: these signals "
#~ "are forcibly delivered when sent from an ancestor PID namespace.  Neither "
#~ "of these signals can be caught by the \"init\" process, and so will "
#~ "result in the usual actions associated with those signals (respectively, "
#~ "terminating and stopping the process)."
#~ msgstr ""
#~ "同様に、 先祖の名前空間のプロセスは、 \"init\" プロセスがそのシグナルに対"
#~ "するハンドラーを設定している場合にのみ、 B<kill>(2) で説明されている通常の"
#~ "アクセス許可のチェックを経た上で、 子供の PID 名前空間の \"init\" プロセス"
#~ "にシグナルを送信できる。 (ハンドラー内では、 I<sigaction>(2) に説明がある "
#~ "I<siginfo_t> の I<si_pid> フィールドは 0 になる。) B<SIGKILL> と "
#~ "B<SIGSTOP> は例外として扱われ、 これらのシグナルが先祖の PID 名前空間から"
#~ "送信された場合には強制的に配送される。 これらのシグナルはどちらも \"init"
#~ "\" プロセルが捕捉することはできない。 そのため、これらのシグナルに関連付け"
#~ "られた通常のアクション (それぞれ、プロセスの終了とプロセスの強制停止) が実"
#~ "行される。"

#
#~ msgid ""
#~ "Starting with Linux 3.4, the B<reboot>(2)  system call causes a signal to "
#~ "be sent to the namespace \"init\" process.  See B<reboot>(2)  for more "
#~ "details."
#~ msgstr ""
#~ "Linux 3.4 以降では、 B<reboot>(2) システムコールを呼び出すと、 シグナルが"
#~ "その名前空間の \"init\" プロセスに送信される。 詳細は B<reboot>(2) を参"
#~ "照。"

#~ msgid "Nesting PID namespaces"
#~ msgstr "ネストされた PID 名前空間"

#~ msgid ""
#~ "PID namespaces can be nested: each PID namespace has a parent, except for "
#~ "the initial (\"root\") PID namespace.  The parent of a PID namespace is "
#~ "the PID namespace of the process that created the namespace using "
#~ "B<clone>(2)  or B<unshare>(2).  PID namespaces thus form a tree, with all "
#~ "namespaces ultimately tracing their ancestry to the root namespace."
#~ msgstr ""
#~ "PID 名前空間は入れ子にすることができる。 最初の (\"root\") PID 名前空間以"
#~ "外の各 PID 名前空間は親を持つ。 PID 名前空間の親は B<clone>(2) や "
#~ "B<unshare>(2) を使ってその名前空間を作成したプロセスの PID 名前空間であ"
#~ "る。 したがって、 PID 名前空間は木構造を構成し、 すべての名前空間は親を"
#~ "辿って行くと、最終的には root 名前空間に辿り着く。"

#~ msgid ""
#~ "A process is visible to other processes in its PID namespace, and to the "
#~ "processes in each direct ancestor PID namespace going back to the root "
#~ "PID namespace.  In this context, \"visible\" means that one process can "
#~ "be the target of operations by another process using system calls that "
#~ "specify a process ID.  Conversely, the processes in a child PID namespace "
#~ "can't see processes in the parent and further removed ancestor "
#~ "namespaces.  More succinctly: a process can see (e.g., send signals with "
#~ "B<kill>(2), set nice values with B<setpriority>(2), etc.) only processes "
#~ "contained in its own PID namespace and in descendants of that namespace."
#~ msgstr ""
#~ "プロセスは、所属する PID 名前空間の他のプロセスから見える。また、 root "
#~ "PID 名前空間に向かう直径の先祖の各 PID 名前空間のプロセスからも見える。 こ"
#~ "の場合、「見える」とは、 あるプロセスが、 他のプロセスがプロセス ID を指定"
#~ "するシステムコールを使う際に操作の対象にできることを意味する。 逆に、子供 "
#~ "PID 名前空間のプロセスから親や先祖の名前空間のプロセスは見えない。 あるプ"
#~ "ロセスは自分自身の PID 名前空間とその子孫の名前空間のプロセスだけが見える "
#~ "(例えば、B<kill>(2) でシグナルを送信したり、 B<setpriority>(2) で nice 値"
#~ "を設定したり、など)。"

#~ msgid ""
#~ "A process has one process ID in each of the layers of the PID namespace "
#~ "hierarchy in which is visible, and walking back though each direct "
#~ "ancestor namespace through to the root PID namespace.  System calls that "
#~ "operate on process IDs always operate using the process ID that is "
#~ "visible in the PID namespace of the caller.  A call to B<getpid>(2)  "
#~ "always returns the PID associated with the namespace in which the process "
#~ "was created."
#~ msgstr ""
#~ "プロセスは、そのプロセスが見える PID 名前空間の階層の各層においてプロセス "
#~ "ID を一つ持ち、 直接の先祖の名前空間を辿ることで通って root PID 名前空間に"
#~ "至ることができる。 プロセス ID に対して操作を行うシステムコールは、常に、"
#~ "呼び出し元プロセスの PID 名前空間で見えるプロセス ID を使って操作を行う。 "
#~ "B<getpid>(2) の呼び出しでは、 常に、 プロセスが作成された名前空間に関連付"
#~ "けられた PID を返す。"

#
#~ msgid ""
#~ "Some processes in a PID namespace may have parents that are outside of "
#~ "the namespace.  For example, the parent of the initial process in the "
#~ "namespace (i.e., the B<init>(1)  process with PID 1) is necessarily in "
#~ "another namespace.  Likewise, the direct children of a process that uses "
#~ "B<setns>(2)  to cause its children to join a PID namespace are in a "
#~ "different PID namespace from the caller of B<setns>(2).  Calls to "
#~ "B<getppid>(2)  for such processes return 0."
#~ msgstr ""
#~ "PID 名前空間内のプロセスは名前空間の外部に親プロセスを持つことができる。 "
#~ "例えば、その名前空間の初期プロセス (すなわち PID 1 を持つ B<init>(1) プロ"
#~ "セス) の親プロセスは必然的に別の名前空間に属すことになる。 同様に、 あるプ"
#~ "ロセスが B<setns>(2) を使って子プロセスを PID 名前空間に参加させた場合、 "
#~ "子プロセスは B<setns>(2) の呼び出し元とは異なる PID 名前空間に属す。 子プ"
#~ "ロセスで B<getppid>(2) を呼び出すと 0 が返される。"

#
#~ msgid ""
#~ "While processes may freely descend into child PID namespaces (e.g., using "
#~ "B<setns>(2)  with B<CLONE_NEWPID>), they may not move in the other "
#~ "direction.  That is to say, processes may not enter any ancestor "
#~ "namespaces (parent, grandparent, etc.).  Changing PID namespaces is a one "
#~ "way operation."
#~ msgstr ""
#~ "プロセスは (B<setns>(2) を B<CLONE_NEWPID> で使うなどで) 子供の PID 名前空"
#~ "間に自由に入ることができるが、 逆の方向には移動できない。 つまり、 プロセ"
#~ "スは先祖の名前空間 (親、親の親など) に入ることはできない。 PID 名前空間の"
#~ "変更は一方向の操作である。"

#~ msgid "setns(2) and unshare(2) semantics"
#~ msgstr "setns(2) と unshare(2) の動作"

#~ msgid ""
#~ "Calls to B<setns>(2)  that specify a PID namespace file descriptor and "
#~ "calls to B<unshare>(2)  with the B<CLONE_NEWPID> flag cause children "
#~ "subsequently created by the caller to be placed in a different PID "
#~ "namespace from the caller.  These calls do not, however, change the PID "
#~ "namespace of the calling process, because doing so would change the "
#~ "caller's idea of its own PID (as reported by B<getpid>()), which would "
#~ "break many applications and libraries."
#~ msgstr ""
#~ "PID 名前空間のファイルディスクリプターを指定して B<setns>(2) を呼び出した"
#~ "り、 B<CLONE_NEWPID> フラグ付きで B<unshare>(2) を呼び出したりすると、 そ"
#~ "の結果作成された子プロセスは呼び出し元とは異なる PID 名前空間に置かれる。 "
#~ "しかし、これらの呼び出しでは呼び出し元プロセスの PID 名前空間は変更されな"
#~ "い。 なぜなら、PID 名前空間を変更してしまうと、 呼び出し元が認識する "
#~ "(B<getpid>() が返す) 自分の PID が変わってしまい、 多くのアプリケーション"
#~ "やライブラリが正しく動作しなくなるからである。"

#~ msgid ""
#~ "To put things another way: a process's PID namespace membership is "
#~ "determined when the process is created and cannot be changed thereafter.  "
#~ "Among other things, this means that the parental relationship between "
#~ "processes mirrors the parental relationship between PID namespaces: the "
#~ "parent of a process is either in the same namespace or resides in the "
#~ "immediate parent PID namespace."
#~ msgstr ""
#~ "別の言い方をすると、 あるプロセスがどの PID 名前空間に所属するかは、 その"
#~ "プロセスが作成されたときに決定され、 それ以降は変更されることはない。 いろ"
#~ "いろあるが、プロセス間の親子関係には、PID 名前空間の親子関係がそのまま反映"
#~ "されるということだ。 プロセスの親プロセスは、同じ名前空間にいるか、もしく"
#~ "は直接の親 PID 名前空間にいるかのいずれかである。"

#~ msgid "Compatibility of CLONE_NEWPID with other CLONE_* flags"
#~ msgstr "CLONE_NEWPID の他の CLONE_* フラグとの互換性"

#~ msgid "B<CLONE_NEWPID> can't be combined with some other B<CLONE_*> flags:"
#~ msgstr ""
#~ "B<CLONE_NEWPID> はいくつかの他の B<CLONE_*> フラグと組み合わせることができ"
#~ "ない。"

#~ msgid ""
#~ "B<CLONE_THREAD> requires being in the same PID namespace in order that "
#~ "the threads in a process can send signals to each other.  Similarly, it "
#~ "must be possible to see all of the threads of a processes in the "
#~ "B<proc>(5)  filesystem."
#~ msgstr ""
#~ "B<CLONE_THREAD> は、 プロセス内のスレッド間で互いにシグナルを送信できるよ"
#~ "うにするため、 同じ PID 名前空間に属している必要がある。 同様に、 プロセス"
#~ "内の全スレッドが B<proc>(5) ファイルシステムで見える必要がある。"

#~ msgid ""
#~ "B<CLONE_SIGHAND> requires being in the same PID namespace; otherwise the "
#~ "process ID of the process sending a signal could not be meaningfully "
#~ "encoded when a signal is sent (see the description of the I<siginfo_t> "
#~ "type in B<sigaction>(2)).  A signal queue shared by processes in multiple "
#~ "PID namespaces will defeat that."
#~ msgstr ""
#~ "B<CLONE_SIGHAND> は、同じ PID 名前空間である必要がある。 さもなければ、 シ"
#~ "グナルが送信された際に、シグナルを送信したプロセスのプロセス ID を意味のあ"
#~ "る形でエンコードすることができない (B<sigaction>(2) の I<siginfo_t> 型の説"
#~ "明を参照)。 複数の PID 名前空間に属するプロセス間で一つのシグナルキューを"
#~ "共有すると、うまく動かなくなる。"

#~ msgid ""
#~ "B<CLONE_VM> requires all of the threads to be in the same PID namespace, "
#~ "because, from the point of view of a core dump, if two processes share "
#~ "the same address space then they are threads and will be core dumped "
#~ "together.  When a core dump is written, the PID of each thread is written "
#~ "into the core dump.  Writing the process IDs could not meaningfully "
#~ "succeed if some of the process IDs were in a parent PID namespace."
#~ msgstr ""
#~ "B<CLONE_VM> は、全スレッドが同じ PID 名前空間に属している必要がある。 なぜ"
#~ "なら、 コアダンプの観点から見ると、 2 つのプロセスが同じアドレス空間を共有"
#~ "していれば、 これらはスレッドであり、コアダンプが一緒に行われるからであ"
#~ "る。 コアダンプが書き込まれる際に、 各スレッドの PID がコアダンプに書き込"
#~ "まれる。 もしプロセス ID のいくつかが親 PID 名前空間に属していたとする"
#~ "と、 プロセス ID の書き込みは意味を持たなくなってしまう。"

#~ msgid ""
#~ "To summarize: there is a technical requirement for each of "
#~ "B<CLONE_THREAD>, B<CLONE_SIGHAND>, and B<CLONE_VM> to share a PID "
#~ "namespace.  (Note furthermore that in B<clone>(2)  requires B<CLONE_VM> "
#~ "to be specified if B<CLONE_THREAD> or B<CLONE_SIGHAND> is specified.)  "
#~ "Thus, call sequences such as the following will fail (with the error "
#~ "B<EINVAL>):"
#~ msgstr ""
#~ "まとめると、 B<CLONE_THREAD>, B<CLONE_SIGHAND>, B<CLONE_VM> では技術的な要"
#~ "件として PID 名前空間が共有されている点がある。 (さらに B<clone>(2) では "
#~ "B<CLONE_THREAD> か B<CLONE_SIGHAND> が指定された際には B<CLONE_VM> が指定"
#~ "されている必要がある点にも注意。) したがって、以下のような順序で呼び出しを"
#~ "行うと (エラー B<EINVAL> で) 失敗する。"

#~ msgid ""
#~ "    unshare(CLONE_NEWPID);\n"
#~ "    clone(..., CLONE_VM, ...);    /* Fails */\n"
#~ msgstr ""
#~ "    unshare(CLONE_NEWPID);\n"
#~ "    clone(..., CLONE_VM, ...);    /* Fails */\n"

#~ msgid ""
#~ "    setns(fd, CLONE_NEWPID);\n"
#~ "    clone(..., CLONE_VM, ...);    /* Fails */\n"
#~ msgstr ""
#~ "    setns(fd, CLONE_NEWPID);\n"
#~ "    clone(..., CLONE_VM, ...);    /* Fails */\n"

#~ msgid ""
#~ "    clone(..., CLONE_VM, ...);\n"
#~ "    setns(fd, CLONE_NEWPID);      /* Fails */\n"
#~ msgstr ""
#~ "    clone(..., CLONE_VM, ...);\n"
#~ "    setns(fd, CLONE_NEWPID);      /* Fails */\n"

#~ msgid ""
#~ "    clone(..., CLONE_VM, ...);\n"
#~ "    unshare(CLONE_NEWPID);        /* Fails */\n"
#~ msgstr ""
#~ "    clone(..., CLONE_VM, ...);\n"
#~ "    unshare(CLONE_NEWPID);        /* Fails */\n"

#~ msgid ""
#~ "A I</proc> filesystem shows (in the I</proc/PID> directories) only "
#~ "processes visible in the PID namespace of the process that performed the "
#~ "mount, even if the I</proc> filesystem is viewed from processes in other "
#~ "namespaces."
#~ msgstr ""
#~ "I</proc> ファイルシステムは、I</proc> のマウントを行ったプロセスの PID 名"
#~ "前空間で見えるプロセスだけを表示する。 たとえ、 その I</proc> ファイルシス"
#~ "テムが他の名前空間のプロセスから参照されたとしても、そうである。"

#~ msgid ""
#~ "After creating a new PID namespace, it is useful for the child to change "
#~ "its root directory and mount a new procfs instance at I</proc> so that "
#~ "tools such as B<ps>(1)  work correctly.  If a new mount namespace is "
#~ "simultaneously created by including B<CLONE_NEWNS> in the I<flags> "
#~ "argument of B<clone>(2)  or B<unshare>(2), then it isn't necessary to "
#~ "change the root directory: a new procfs instance can be mounted directly "
#~ "over I</proc>."
#~ msgstr ""
#~ "新しい PID 名前空間を作成した後、 子プロセスが、自身の root ディレクトリを"
#~ "変更し、新しい procfs インスタンスを I</proc> にマウントするのは B<ps>(1) "
#~ "などのツールが正しく動作するためにも有用である。 B<clone>(2) の I<flags> "
#~ "引数に B<CLONE_NEWNS> も指定されて新しいマウント名前空間が同時に作成され"
#~ "た場合は、 root ディレクトリを変更する必要はない。 新しい procfs インスタ"
#~ "ンスを I</proc> にそのままマウントすることができる。"

#~ msgid "From a shell, the command to mount I</proc> is:"
#~ msgstr ""
#~ "シェルから、コマンドで I</proc> のマウントを行うには次のようにする。"

#~ msgid "    $ mount -t proc proc /proc\n"
#~ msgstr "    $ mount -t proc proc /proc\n"

#
#~ msgid ""
#~ "Calling B<readlink>(2)  on the path I</proc/self> yields the process ID "
#~ "of the caller in the PID namespace of the procfs mount (i.e., the PID "
#~ "namespace of the process that mounted the procfs).  This can be useful "
#~ "for introspection purposes, when a process wants to discover its PID in "
#~ "other namespaces."
#~ msgstr ""
#~ "パス I</proc/self> に対して B<readlink>(2) を呼び出すと、 procfs のマウン"
#~ "トを行ったプロセスの PID 名前空間におけるプロセス ID が得られる。 これは調"
#~ "査目的でプロセスが他の名前空間で自身の PID を知りたい場合などに役立つ。"

#~ msgid "Miscellaneous"
#~ msgstr "その他"

#~ msgid ""
#~ "When a process ID is passed over a UNIX domain socket to a process in a "
#~ "different PID namespace (see the description of B<SCM_CREDENTIALS> in "
#~ "B<unix>(7)), it is translated into the corresponding PID value in the "
#~ "receiving process's PID namespace."
#~ msgstr ""
#~ "プロセス ID が UNIX ドメインソケット経由で別の PID 名前空間のプロセスに渡"
#~ "される場合 (B<unix>(7) の B<SCM_CREDENTIALS> の説明を参照)、 プロセス ID "
#~ "は受信プロセスの PID 名前空間での対応する PID 値に翻訳される。"

#~ msgid ""
#~ "_BSD_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ "
#~ "E<gt>=\\ 600"
#~ msgstr ""
#~ "_BSD_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ "
#~ "E<gt>=\\ 600"

#~ msgid ""
#~ "The calling process is not privileged (Linux: does not have the "
#~ "B<CAP_SETUID> capability in the case of B<seteuid>(), or the "
#~ "B<CAP_SETGID> capability in the case of B<setegid>())  and I<euid> "
#~ "(respectively, I<egid>)  is not the real user (group) ID, the effective "
#~ "user (group) ID, or the saved set-user-ID (saved set-group-ID)."
#~ msgstr ""
#~ "呼び出し元のプロセスに特権がなく、 I<euid> (I<egid>)  が実ユーザー (グルー"
#~ "プ) ID、または実効ユーザー (グループ) ID、 保存 set-user-ID (保存 set-"
#~ "group-ID) のいずれでもではない (Linux においては、 B<seteuid>()  では "
#~ "B<CAP_SETUID> ケーパビリティ (capability) が、 B<setegid>()  では "
#~ "B<CAP_SETGID> ケーパビリティがない場合に、特権がないと判断される)。"

#~ msgid "4.3BSD, POSIX.1-2001."
#~ msgstr "4.3BSD, POSIX.1-2001."

#~ msgid ""
#~ "The system call B<setfsgid>()  changes the value of the caller's "
#~ "filesystem group ID\\(emthe group ID that the Linux kernel uses to check "
#~ "for all accesses to the filesystem.  Normally, the value of the "
#~ "filesystem group ID will shadow the value of the effective group ID.  In "
#~ "fact, whenever the effective group ID is changed, the filesystem group ID "
#~ "will also be changed to the new value of the effective group ID."
#~ msgstr ""
#~ "システムコール B<setfsgid>() は、 呼び出し元のファイルシステムグループ ID "
#~ "\\(em ファイルシステムへの全てのアクセスのチェックにおいて Linux カーネル"
#~ "が使用するグループ ID \\(em の値を変更する。通常はファイルシステムグルー"
#~ "プ ID の値は実効 (effective) グループ ID と同じになる。実際、 実効グルー"
#~ "プ ID が変更される度にファイルシステムグループ ID もまた新しい実効グルー"
#~ "プ ID の値に変更される。"

#~ msgid ""
#~ "Explicit calls to B<setfsuid>(2)  and B<setfsgid>()  are usually used "
#~ "only by programs such as the Linux NFS server that need to change what "
#~ "user and group ID is used for file access without a corresponding change "
#~ "in the real and effective user and group IDs.  A change in the normal "
#~ "user IDs for a program such as the NFS server is a security hole that can "
#~ "expose it to unwanted signals.  (But see below.)"
#~ msgstr ""
#~ "通常、 B<setfsuid>()  や B<setfsgid>() を明示的に呼び出すのは、Linux NFS "
#~ "サーバー のように、 ファイルアクセスに用いるユーザーID / グループID を変更"
#~ "しなければならないが、 対応する実(real)/実効(effective) ユーザーID / グ"
#~ "ループID は変更したくないような プログラムに限られる。 NFS サーバーのよう"
#~ "なプログラムで、通常のユーザーID を変更すると、 プロセスを望まないシグナル"
#~ "にさらす可能性があり、 セキュリティホールになる。(下記参照)"

#~ msgid ""
#~ "The system call B<setfsuid>()  changes the value of the caller's "
#~ "filesystem user ID\\(emthe user ID that the Linux kernel uses to check "
#~ "for all accesses to the filesystem.  Normally, the value of the "
#~ "filesystem user ID will shadow the value of the effective user ID.  In "
#~ "fact, whenever the effective user ID is changed, the filesystem user ID "
#~ "will also be changed to the new value of the effective user ID."
#~ msgstr ""
#~ "B<setfsuid>()  は、 呼び出し元のファイルシステムユーザー ID \\(em ファイル"
#~ "システムへの全てのアクセスのチェックにおいて Linux カーネルが使用するユー"
#~ "ザー ID \\(em の値を変更する。通常はファイルシステムユーザー ID の値は実"
#~ "効 (effective) ユーザーID と同じになる。実際、 実効ユーザーID が変更される"
#~ "度にファイルシステムユーザー ID もまた新しい実効ユーザー ID の値に変更され"
#~ "る。"

#~ msgid "2014-01-07"
#~ msgstr "2014-01-07"

#~ msgid ""
#~ "    _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 ||\n"
#~ "    _XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED\n"
#~ msgstr ""
#~ "    _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 ||\n"
#~ "    _XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED\n"

#~ msgid "    || /* Since glibc 2.19: */ _BSD_SOURCE\n"
#~ msgstr "    || /* glibc 2.19 以降: */ _BSD_SOURCE\n"

#~ msgid ""
#~ "_BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ "
#~ "_XOPEN_SOURCE_EXTENDED"
#~ msgstr ""
#~ "_BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ "
#~ "_XOPEN_SOURCE_EXTENDED"

#~ msgid ""
#~ "B<#include E<lt>sys/msg.hE<gt>>\n"
#~ "B<#include E<lt>sys/sem.hE<gt>>\n"
#~ "B<#include E<lt>sys/shm.hE<gt>>\n"
#~ msgstr ""
#~ "B<#include E<lt>sys/msg.hE<gt>>\n"
#~ "B<#include E<lt>sys/sem.hE<gt>>\n"
#~ "B<#include E<lt>sys/shm.hE<gt>>\n"

#~ msgid ""
#~ "This manual page refers to the Linux implementation of the System V "
#~ "interprocess communication (IPC) mechanisms: message queues, semaphore "
#~ "sets, and shared memory segments.  In the following, the word I<resource> "
#~ "means an instantiation of one among such mechanisms."
#~ msgstr ""
#~ "このマニュアルページは System V プロセス間通信 (interprocess "
#~ "communication; IPC) 機構の Linux に おける実装を説明する。 このプロセス間"
#~ "通信機構には、 メッセージキュー (message queue)、セマフォー集合 "
#~ "(semaphore set)、 共有メモリーセグメント (shared memory segment) などがあ"
#~ "る。以下で I<資源 (resource)> という用語を使用した場合にはこれらの機構のど"
#~ "れかを意味する。"

#~ msgid "Resource access permissions"
#~ msgstr "資源へのアクセス許可"

#~ msgid ""
#~ "For each resource, the system uses a common structure of type I<struct "
#~ "ipc_perm> to store information needed in determining permissions to "
#~ "perform an IPC operation.  The I<ipc_perm> structure includes the "
#~ "following members:"
#~ msgstr ""
#~ "システムのそれぞれの資源は、IPC への操作を許可するかどうかを決定する ため"
#~ "の情報を共通の構造体 I<struct ipc_perm> に格納して使用する。 I<ipc_perm> "
#~ "構造体には以下のメンバーが定義されている:"

#~ msgid ""
#~ "struct ipc_perm {\n"
#~ "    uid_t          cuid;   /* creator user ID */\n"
#~ "    gid_t          cgid;   /* creator group ID */\n"
#~ "    uid_t          uid;    /* owner user ID */\n"
#~ "    gid_t          gid;    /* owner group ID */\n"
#~ "    unsigned short mode;   /* r/w permissions */\n"
#~ "};\n"
#~ msgstr ""
#~ "struct ipc_perm {\n"
#~ "    uid_t          cuid;   /* 作成者のユーザーID */\n"
#~ "    gid_t          cgid;   /* 作成者のグループID */\n"
#~ "    uid_t          uid;    /* 所有者のユーザーID */\n"
#~ "    gid_t          gid;    /* 所有者のグループID */\n"
#~ "    unsigned short mode;   /* 読み書きの許可 */\n"
#~ "};\n"

#~ msgid ""
#~ "The I<mode> member of the I<ipc_perm> structure defines, with its lower 9 "
#~ "bits, the access permissions to the resource for a process executing an "
#~ "IPC system call.  The permissions are interpreted as follows:"
#~ msgstr ""
#~ "I<ipc_perm> 構造体の I<mode> メンバーは以下の 9 ビットで、プロセスの IPC "
#~ "システムコール による資源へのアクセス許可を定義する。 許可は以下のように解"
#~ "釈される:"

#~ msgid ""
#~ "    0400    Read by user.\n"
#~ "    0200    Write by user.\n"
#~ msgstr ""
#~ "    0400    ユーザーによる読み込み。\n"
#~ "    0200    ユーザーによる書き込み。\n"

#~ msgid ""
#~ "    0040    Read by group.\n"
#~ "    0020    Write by group.\n"
#~ msgstr ""
#~ "    0040    グループによる読み込み。\n"
#~ "    0020    グループによる書き込み。\n"

#~ msgid ""
#~ "    0004    Read by others.\n"
#~ "    0002    Write by others.\n"
#~ msgstr ""
#~ "    0004    他人による読み込み。\n"
#~ "    0002    他人による書き込み。\n"

#~ msgid ""
#~ "Bits 0100, 0010, and 0001 (the execute bits) are unused by the system.  "
#~ "Furthermore, \"write\" effectively means \"alter\" for a semaphore set."
#~ msgstr ""
#~ "システムはビット 0100, 0010, 0001 (実行ビット) は使用しない。 さらに、セマ"
#~ "フォーの場合には \"書き込み(write)\" は実際には \"変更(alter)\" を意味す"
#~ "る。"

#~ msgid ""
#~ "The same system header file also defines the following symbolic constants:"
#~ msgstr "同じヘッダーファイルには以下のシンボルの定義が含まれている:"

#~ msgid "B<IPC_CREAT>"
#~ msgstr "B<IPC_CREAT>"

#~ msgid "Create entry if key doesn't exist."
#~ msgstr "キー(key)が存在しない場合には新たなエントリーを作成する。"

#~ msgid "B<IPC_EXCL>"
#~ msgstr "B<IPC_EXCL>"

#~ msgid "Fail if key exists."
#~ msgstr "キー(key)が存在する場合には失敗する。"

#~ msgid "B<IPC_NOWAIT>"
#~ msgstr "B<IPC_NOWAIT>"

#~ msgid "Error if request must wait."
#~ msgstr "要求が待たされる場合にはエラーになる。"

#~ msgid "B<IPC_PRIVATE>"
#~ msgstr "B<IPC_PRIVATE>"

#~ msgid "Private key."
#~ msgstr "プライベートキー。"

#~ msgid "B<IPC_RMID>"
#~ msgstr "B<IPC_RMID>"

#~ msgid "Remove resource."
#~ msgstr "資源を削除する。"

#~ msgid "B<IPC_SET>"
#~ msgstr "B<IPC_SET>"

#~ msgid "Set resource options."
#~ msgstr "資源にオプションを設定する。"

#~ msgid "B<IPC_STAT>"
#~ msgstr "B<IPC_STAT>"

#~ msgid "Get resource options."
#~ msgstr "資源のオプションを取得する。"

#~ msgid ""
#~ "Note that B<IPC_PRIVATE> is a I<key_t> type, while all the other symbolic "
#~ "constants are flag fields and can be OR'ed into an I<int> type variable."
#~ msgstr ""
#~ "B<IPC_PRIVATE> は I<key_t> 型である。その他の全てのシンボルはフラグフィー"
#~ "ルドとして I<int> 変数に OR 演算で格納することができる。"

#~ msgid ""
#~ "A message queue is uniquely identified by a positive integer (its "
#~ "I<msqid>)  and has an associated data structure of type I<struct "
#~ "msqid_ds>, defined in I<E<lt>sys/msg.hE<gt>>, containing the following "
#~ "members:"
#~ msgstr ""
#~ "メッセージキューは正の整数 (I<msqid>)  によって識別され、 I<E<lt>sys/msg."
#~ "hE<gt>> に定義されている構造体 I<struct msqid_ds> に結びつけられている。 "
#~ "この構造体は以下のメンバーを含んでいる:"

#~ msgid ""
#~ "struct msqid_ds {\n"
#~ "    struct ipc_perm msg_perm;\n"
#~ "    msgqnum_t       msg_qnum;    /* no of messages on queue */\n"
#~ "    msglen_t        msg_qbytes;  /* bytes max on a queue */\n"
#~ "    pid_t           msg_lspid;   /* PID of last msgsnd(2) call */\n"
#~ "    pid_t           msg_lrpid;   /* PID of last msgrcv(2) call */\n"
#~ "    time_t          msg_stime;   /* last msgsnd(2) time */\n"
#~ "    time_t          msg_rtime;   /* last msgrcv(2) time */\n"
#~ "    time_t          msg_ctime;   /* last change time */\n"
#~ "};\n"
#~ msgstr ""
#~ "struct msqid_ds {\n"
#~ "    struct ipc_perm msg_perm;\n"
#~ "    msgqnum_t       msg_qnum;    /* キューにあるメッセージの数 */\n"
#~ "    msglen_t        msg_qbytes;  /* キューの最大バイト数 */\n"
#~ "    pid_t           msg_lspid;   /* 最後に msgsnd(2) をした PID */\n"
#~ "    pid_t           msg_lrpid;   /* 最後に msgrcv(2) をした PID */\n"
#~ "    time_t          msg_stime;   /* 最後に msgsnd(2) をした時間 */\n"
#~ "    time_t          msg_rtime;   /* 最後に msgrcv(2) をした時間 */\n"
#~ "    time_t          msg_ctime;   /* 最後に変更された時間 */\n"
#~ "};\n"

#~ msgid "I<msg_perm>"
#~ msgstr "I<msg_perm>"

#~ msgid ""
#~ "I<ipc_perm> structure that specifies the access permissions on the "
#~ "message queue."
#~ msgstr "メッセージキューへのアクセス許可を指定する I<ipc_perm> 構造体。"

#~ msgid "I<msg_qnum>"
#~ msgstr "I<msg_qnum>"

#~ msgid "Number of messages currently on the message queue."
#~ msgstr "現在、このメッセージキューにあるメッセージの数。"

#~ msgid "I<msg_qbytes>"
#~ msgstr "I<msg_qbytes>"

#~ msgid ""
#~ "Maximum number of bytes of message text allowed on the message queue."
#~ msgstr "メッセージキューに入れることができるメッセージの最大バイト数。"

#~ msgid "I<msg_lspid>"
#~ msgstr "I<msg_lspid>"

#~ msgid "ID of the process that performed the last B<msgsnd>(2)  system call."
#~ msgstr "最後に B<msgsnd>(2)  システムコールを行なったプロセスの ID。"

#~ msgid "I<msg_lrpid>"
#~ msgstr "I<msg_lrpid>"

#~ msgid "ID of the process that performed the last B<msgrcv>(2)  system call."
#~ msgstr "最後に B<msgrcv>(2)  システムコールを行なったプロセスの ID。"

#~ msgid "I<msg_stime>"
#~ msgstr "I<msg_stime>"

#~ msgid "Time of the last B<msgsnd>(2)  system call."
#~ msgstr "最後に B<msgsnd>(2)  システムコールを行なった時間。"

#~ msgid "I<msg_rtime>"
#~ msgstr "I<msg_rtime>"

#~ msgid "Time of the last B<msgrcv>(2)  system call."
#~ msgstr "最後に B<msgrcv>(2)  を行なった時間。"

#~ msgid "I<msg_ctime>"
#~ msgstr "I<msg_ctime>"

#~ msgid ""
#~ "Time of the last system call that changed a member of the I<msqid_ds> "
#~ "structure."
#~ msgstr "最後に I<msqid_ds> 構造体のメンバーが変更された時間。"

#~ msgid ""
#~ "A semaphore set is uniquely identified by a positive integer (its "
#~ "I<semid>)  and has an associated data structure of type I<struct "
#~ "semid_ds>, defined in I<E<lt>sys/sem.hE<gt>>, containing the following "
#~ "members:"
#~ msgstr ""
#~ "セマフォー集合は正の整数 (I<semid>)  によって識別され、 I<E<lt>sys/sem."
#~ "hE<gt>> に定義されている構造体 I<struct semid_ds> に結びつけられている。 "
#~ "この構造体は以下のメンバーを含んでいる:"

#~ msgid ""
#~ "struct semid_ds {\n"
#~ "    struct ipc_perm sem_perm;\n"
#~ "    time_t          sem_otime;   /* last operation time */\n"
#~ "    time_t          sem_ctime;   /* last change time */\n"
#~ "    unsigned long   sem_nsems;   /* count of sems in set */\n"
#~ "};\n"
#~ msgstr ""
#~ "struct semid_ds {\n"
#~ "    struct ipc_perm sem_perm;\n"
#~ "    time_t          sem_otime;   /* 最後に操作した時間 */\n"
#~ "    time_t          sem_ctime;   /* 最後に変更した時間 */\n"
#~ "    unsigned long   sem_nsems;   /* 集合の中にあるセマフォー数 */\n"
#~ "};\n"

#~ msgid "I<sem_perm>"
#~ msgstr "I<sem_perm>"

#~ msgid ""
#~ "I<ipc_perm> structure that specifies the access permissions on the "
#~ "semaphore set."
#~ msgstr "セマフォー集合へのアクセス許可を指定する I<ipc_perm> 構造体。"

#~ msgid "I<sem_otime>"
#~ msgstr "I<sem_otime>"

#~ msgid "Time of last B<semop>(2)  system call."
#~ msgstr "最後に B<semop>(2)  システムコールを行なった時間。"

#~ msgid "I<sem_ctime>"
#~ msgstr "I<sem_ctime>"

#~ msgid ""
#~ "Time of last B<semctl>(2)  system call that changed a member of the above "
#~ "structure or of one semaphore belonging to the set."
#~ msgstr ""
#~ "最後に B<semctl>(2)  を行なって上記の構造体のメンバーを変更するか、セマ"
#~ "フォー集合に属する セマフォーを変更した時間。"

#~ msgid "I<sem_nsems>"
#~ msgstr "I<sem_nsems>"

#~ msgid ""
#~ "Number of semaphores in the set.  Each semaphore of the set is referenced "
#~ "by a nonnegative integer ranging from B<0> to I<sem_nsems-1>."
#~ msgstr ""
#~ "セマフォー集合の中にあるセマフォーの数。 集合の中にあるそれぞれのセマ"
#~ "フォーは負でない整数によって参照され、 B<0> から I<sem_nsems-1> までの番号"
#~ "を持つ。"

#~ msgid ""
#~ "A semaphore is a data structure of type I<struct sem> containing the "
#~ "following members:"
#~ msgstr ""
#~ "セマフォーは I<struct sem> 型のデータ構造体であり、以下のメンバーを含んで"
#~ "いる:"

#~ msgid ""
#~ "struct sem {\n"
#~ "    int semval;  /* semaphore value */\n"
#~ "    int sempid;  /* PID for last operation */\n"
#~ "};\n"
#~ msgstr ""
#~ "struct sem {\n"
#~ "    int semval;  /* セマフォーの値 */\n"
#~ "    int sempid;  /* 最後に操作したプロセス ID */\n"
#~ "};\n"

#~ msgid "I<semval>"
#~ msgstr "I<semval>"

#~ msgid "Semaphore value: a nonnegative integer."
#~ msgstr "セマフォー値: 負でない整数。"

#~ msgid "I<sempid>"
#~ msgstr "I<sempid>"

#~ msgid ""
#~ "ID of the last process that performed a semaphore operation on this "
#~ "semaphore."
#~ msgstr "このセマフォーを最後に操作したプロセスの ID。"

#~ msgid ""
#~ "A shared memory segment is uniquely identified by a positive integer (its "
#~ "I<shmid>)  and has an associated data structure of type I<struct "
#~ "shmid_ds>, defined in I<E<lt>sys/shm.hE<gt>>, containing the following "
#~ "members:"
#~ msgstr ""
#~ "共有メモリーセグメントは正の整数 (I<shmid>)  によって識別され、 "
#~ "I<E<lt>sys/shm.hE<gt>> に定義されている I<struct shmid_ds> 構造体に結びつ"
#~ "けられている。 この構造体は以下のメンバーを含んでいる:"

#~ msgid ""
#~ "struct shmid_ds {\n"
#~ "    struct ipc_perm shm_perm;\n"
#~ "    size_t          shm_segsz;   /* size of segment */\n"
#~ "    pid_t           shm_cpid;    /* PID of creator */\n"
#~ "    pid_t           shm_lpid;    /* PID, last operation */\n"
#~ "    shmatt_t        shm_nattch;  /* no. of current attaches */\n"
#~ "    time_t          shm_atime;   /* time of last attach */\n"
#~ "    time_t          shm_dtime;   /* time of last detach */\n"
#~ "    time_t          shm_ctime;   /* time of last change */\n"
#~ "};\n"
#~ msgstr ""
#~ "struct shmid_ds {\n"
#~ "    struct ipc_perm shm_perm;\n"
#~ "    size_t          shm_segsz;   /* セグメントのサイズ */\n"
#~ "    pid_t           shm_cpid;    /* 作成者のプロセス ID */\n"
#~ "    pid_t           shm_lpid;    /* 最後に操作したプロセス ID */\n"
#~ "    shmatt_t        shm_nattch;  /* 現在、付加している数 */\n"
#~ "    time_t          shm_atime;   /* 最後に付加した時間 */\n"
#~ "    time_t          shm_dtime;   /* 最後に分離した時間 */\n"
#~ "    time_t          shm_ctime;   /* 最後に変更した時間 */\n"
#~ "};\n"

#~ msgid "I<shm_perm>"
#~ msgstr "I<shm_perm>"

#~ msgid ""
#~ "I<ipc_perm> structure that specifies the access permissions on the shared "
#~ "memory segment."
#~ msgstr ""
#~ "共有メモリーセグメントへのアクセス許可を指定した I<ipc_perm> 構造体。"

#~ msgid "I<shm_segsz>"
#~ msgstr "I<shm_segsz>"

#~ msgid "Size in bytes of the shared memory segment."
#~ msgstr "共有メモリーセグメントのバイト数。"

#~ msgid "I<shm_cpid>"
#~ msgstr "I<shm_cpid>"

#~ msgid "ID of the process that created the shared memory segment."
#~ msgstr "共有メモリーセグメントを作成したプロセスの ID。"

#~ msgid "I<shm_lpid>"
#~ msgstr "I<shm_lpid>"

#~ msgid ""
#~ "ID of the last process that executed a B<shmat>(2)  or B<shmdt>(2)  "
#~ "system call."
#~ msgstr ""
#~ "最後に B<shmat>(2)  または B<shmdt>(2)  システムコールを実行したプロセス"
#~ "の ID。"

#~ msgid "I<shm_nattch>"
#~ msgstr "I<shm_nattch>"

#~ msgid "Number of current alive attaches for this shared memory segment."
#~ msgstr ""
#~ "この共有メモリーセグメントをメモリーに付加 (attach) しているプロセスの数。"

#~ msgid "I<shm_atime>"
#~ msgstr "I<shm_atime>"

#~ msgid "Time of the last B<shmat>(2)  system call."
#~ msgstr "最後に B<shmat>(2)  システムコールを行なった時間。"

#~ msgid "I<shm_dtime>"
#~ msgstr "I<shm_dtime>"

#~ msgid "Time of the last B<shmdt>(2)  system call."
#~ msgstr "最後に B<shmdt>(2)  システムコールを行なった時間。"

#~ msgid "I<shm_ctime>"
#~ msgstr "I<shm_ctime>"

#~ msgid "Time of the last B<shmctl>(2)  system call that changed I<shmid_ds>."
#~ msgstr ""
#~ "最後に B<shmctl>(2)  システムコールを行なって、 I<shmid_ds> 構造体を変更し"
#~ "た時間。"

#~ msgid "2008-08-06"
#~ msgstr "2008-08-06"

#~ msgid "USER_NAMESPACES"
#~ msgstr "USER_NAMESPACES"

#~ msgid "user_namespaces - overview of Linux user namespaces"
#~ msgstr "user_namespaces - Linux ユーザー名前空間の概要"

#
#~ msgid ""
#~ "User namespaces isolate security-related identifiers and attributes, in "
#~ "particular, user IDs and group IDs (see B<credentials>(7)), the root "
#~ "directory, keys (see B<keyctl>(2)), and capabilities (see "
#~ "B<capabilities>(7)).  A process's user and group IDs can be different "
#~ "inside and outside a user namespace.  In particular, a process can have a "
#~ "normal unprivileged user ID outside a user namespace while at the same "
#~ "time having a user ID of 0 inside the namespace; in other words, the "
#~ "process has full privileges for operations inside the user namespace, but "
#~ "is unprivileged for operations outside the namespace."
#~ msgstr ""
#~ "ユーザー名前空間は、 セキュリティに関連する識別子や属性、 特にユーザー ID "
#~ "やグループ ID (B<credentials>(7) 参照)、 root ディレクトリ、 キー "
#~ "(B<keyctl>(2) 参照)、 ケーパビリティを分離する。 プロセスのユーザー ID と"
#~ "グループ ID はユーザー名前空間の内部と外部で異なる場合がある。 特に、 ある"
#~ "プロセスがユーザー名前空間の外部では通常の非特権ユーザー ID を持つが、 同"
#~ "時にユーザー名前空間の内部ではユーザー ID 0 を持つという場合がある。 言い"
#~ "換えると、 そのプロセスはそのユーザー名前空間の内部での操作に対してすべて"
#~ "の特権を持つが、 名前空間の外部での操作では特権を持たない。"

#~ msgid "Nested namespaces, namespace membership"
#~ msgstr "ネストされた名前空間、名前空間のメンバー"

#~ msgid ""
#~ "User namespaces can be nested; that is, each user namespace\\(emexcept "
#~ "the initial (\"root\")  namespace\\(emhas a parent user namespace, and "
#~ "can have zero or more child user namespaces.  The parent user namespace "
#~ "is the user namespace of the process that creates the user namespace via "
#~ "a call to B<unshare>(2)  or B<clone>(2)  with the B<CLONE_NEWUSER> flag."
#~ msgstr ""
#~ "ユーザー名前空間は入れ子にすることができる。 つまり、 最初の (\"root\") 名"
#~ "前空間以外の各名前空間は親のユーザー名前空間を持ち、 0 個以上のユーザー名"
#~ "前空間を持つということである。 親のユーザー名前空間は、 B<CLONE_NEWUSER> "
#~ "フラグを指定して B<unshare>(2) や B<clone>(2) を呼び出してユーザー名前空間"
#~ "を作成したプロセスのユーザー名前空間である。"

#~ msgid ""
#~ "The kernel imposes (since version 3.11) a limit of 32 nested levels of "
#~ "user namespaces.  Calls to B<unshare>(2)  or B<clone>(2)  that would "
#~ "cause this limit to be exceeded fail with the error B<EUSERS>."
#~ msgstr ""
#~ "カーネルにより (バージョン 3.11 以降では) ユーザー名前空間のネスト数に 32 "
#~ "という上限が課される。 B<unshare>(2) や B<clone>(2) の呼び出しでこの上限を"
#~ "超えてしまう場合はエラー B<EUSERS> で失敗する。"

#~ msgid ""
#~ "Each process is a member of exactly one user namespace.  A process "
#~ "created via B<fork>(2)  or B<clone>(2)  without the B<CLONE_NEWUSER> flag "
#~ "is a member of the same user namespace as its parent.  A single-threaded "
#~ "process can join another user namespace with B<setns>(2)  if it has the "
#~ "B<CAP_SYS_ADMIN> in that namespace; upon doing so, it gains a full set of "
#~ "capabilities in that namespace."
#~ msgstr ""
#~ "各プロセスは必ず 1 個のユーザー名前空間のメンバーとなる。 "
#~ "B<CLONE_NEWUSER> フラグを指定せずに B<fork>(2) や B<clone>(2) でプロセスを"
#~ "作成した場合、 そのプロセスは親プロセスと同じユーザー名前空間のメンバーと"
#~ "なる。 シングルスレッドのプログラムは、 変更先のユーザー名前空間で "
#~ "B<CAP_SYS_ADMIN> を持っていれば、 B<setns>(2) を使って別のユーザー名前空間"
#~ "に参加することができる。 変更時に、 変更後の名前空間ですべてのケーパビリ"
#~ "ティを獲得する。"

#
#~ msgid ""
#~ "A call to B<clone>(2)  or B<unshare>(2)  with the B<CLONE_NEWUSER> flag "
#~ "makes the new child process (for B<clone>(2))  or the caller (for "
#~ "B<unshare>(2))  a member of the new user namespace created by the call."
#~ msgstr ""
#~ "B<CLONE_NEWUSER> を指定して B<clone>(2) や B<unshare>(2) を呼び出すと、 新"
#~ "しいプロセス (B<clone>(2) の場合) や呼び出したプロセス (B<unshare>(2) の場"
#~ "合) がその呼び出しで作成された新しいユーザー名前空間のメンバーとなる。"

#~ msgid "Capabilities"
#~ msgstr "ケーパビリティ"

#~ msgid ""
#~ "The child process created by B<clone>(2)  with the B<CLONE_NEWUSER> flag "
#~ "starts out with a complete set of capabilities in the new user "
#~ "namespace.  Likewise, a process that creates a new user namespace using "
#~ "B<unshare>(2)  or joins an existing user namespace using B<setns>(2)  "
#~ "gains a full set of capabilities in that namespace.  On the other hand, "
#~ "that process has no capabilities in the parent (in the case of "
#~ "B<clone>(2))  or previous (in the case of B<unshare>(2)  and "
#~ "B<setns>(2))  user namespace, even if the new namespace is created or "
#~ "joined by the root user (i.e., a process with user ID 0 in the root "
#~ "namespace)."
#~ msgstr ""
#~ "B<CLONE_NEWUSER> フラグが指定された B<clone>(2) で作成された子プロセス"
#~ "は、 新しい名前空間ですべてのケーパビリティを持った状態で開始される。 同様"
#~ "に、 B<unshare>(2) を使って新しいユーザー名前空間を作成したり、 "
#~ "B<setns>(2) を使って既存のユーザー名前空間に参加したりしたプロセスは、 そ"
#~ "の名前空間ですべてのケーパビリティを獲得する。 一方、 そのプロセスは、親の"
#~ "ユーザー名前空間 (B<clone>(2) の場合) や直前のユーザー名前空間 "
#~ "(B<unshare>(2) や B<setns>(2) の場合) では、 root ユーザー (root 名前空間"
#~ "のユーザー ID 0 のプロセス) により新しい名前空間の作成や参加が行われた場合"
#~ "であっても、 ケーパビリティを全く持たない。"

#~ msgid ""
#~ "Note that a call to B<execve>(2)  will cause a process's capabilities to "
#~ "be recalculated in the usual way (see B<capabilities>(7)), so that "
#~ "usually, unless it has a user ID of 0 within the namespace or the "
#~ "executable file has a nonempty inheritable capabilities mask, it will "
#~ "lose all capabilities.  See the discussion of user and group ID mappings, "
#~ "below."
#~ msgstr ""
#~ "B<execve>(2) の呼び出しでは、 プロセスのケーパビリティは通常の方法 "
#~ "(B<capabilities>(7) 参照) で再計算され、 通常は、 名前空間内でユーザー ID "
#~ "0 を持つ場合や実行ファイルが空でない継承可能ケーパビリティマスクを持ってい"
#~ "る場合を除くと、 すべてのケーパビリティを失うことになる。 下記の、ユー"
#~ "ザー ID やグループ ID のマッピングの議論を参照。"

#~ msgid ""
#~ "A call to B<clone>(2), B<unshare>(2), or B<setns>(2)  using the "
#~ "B<CLONE_NEWUSER> flag sets the \"securebits\" flags (see "
#~ "B<capabilities>(7))  to their default values (all flags disabled) in the "
#~ "child (for B<clone>(2))  or caller (for B<unshare>(2), or B<setns>(2)).  "
#~ "Note that because the caller no longer has capabilities in its original "
#~ "user namespace after a call to B<setns>(2), it is not possible for a "
#~ "process to reset its \"securebits\" flags while retaining its user "
#~ "namespace membership by using a pair of B<setns>(2)  calls to move to "
#~ "another user namespace and then return to its original user namespace."
#~ msgstr ""
#~ "B<CLONE_NEWUSER> フラグを使って B<clone>(2), B<unshare>(2), B<setns>(2) を"
#~ "呼び出すと、 子プロセス (B<clone>(2) の場合) や呼び出し元 (B<unshare>(2) "
#~ "や B<setns>(2) の場合) では \"securebits\" フラグ (B<capabilities>(7) 参"
#~ "照) がデフォルト値に設定される。 呼び出し元は B<setns>(2) の呼び出し後は元"
#~ "のユーザー名前空間ではケーパビリティを持たないので、 B<setns>(2) を 2 回呼"
#~ "び出して一度別のユーザー名前空間に移動して元のユーザー名前空間に戻ること"
#~ "で、 プロセスが元のユーザー名前空間にとどまりつつ自身の \"securebits\" フ"
#~ "ラグを再設定することはできない。"

#~ msgid ""
#~ "Having a capability inside a user namespace permits a process to perform "
#~ "operations (that require privilege)  only on resources governed by that "
#~ "namespace.  The rules for determining whether or not a process has a "
#~ "capability in a particular user namespace are as follows:"
#~ msgstr ""
#~ "ユーザー名前空間内部でケーパビリティを持つというのは、 そのプロセスがその"
#~ "名前空間の支配下にあるリソースに対してのみ (特権を必要とする) 操作を実行で"
#~ "きるということである。 プロセスが特定のユーザー名前空間でケーパビリティを"
#~ "持つかどうかを判定するルールは以下の通りである。"

#~ msgid ""
#~ "A process has a capability inside a user namespace if it is a member of "
#~ "that namespace and it has the capability in its effective capability "
#~ "set.  A process can gain capabilities in its effective capability set in "
#~ "various ways.  For example, it may execute a set-user-ID program or an "
#~ "executable with associated file capabilities.  In addition, a process may "
#~ "gain capabilities via the effect of B<clone>(2), B<unshare>(2), or "
#~ "B<setns>(2), as already described."
#~ msgstr ""
#~ "プロセスがその名前空間のメンバーで、実効ケーパビリティセットにそのケーパビ"
#~ "リティがあれば、 そのプロセスはユーザー名前空間内でケーパビリティを持つ。 "
#~ "プロセスが実効ケーパビリティセットでケーパビリティを得るにはいくつかの方法"
#~ "がある。 例えば、 set-user-ID プログラムや関連するファイルケーパビリティを"
#~ "持った実行ファイルを実行する。 また、 すでに説明したとおり、 プロセスは "
#~ "B<clone>(2), B<unshare>(2), B<setns>(2) の結果としてケーパビリティを獲得す"
#~ "ることもできる。"

#~ msgid ""
#~ "If a process has a capability in a user namespace, then it has that "
#~ "capability in all child (and further removed descendant)  namespaces as "
#~ "well."
#~ msgstr ""
#~ "プロセスがユーザー名前空間でケーパビリティを持っている場合、 そのプロセス"
#~ "はすべての子供の名前空間 (および削除された子孫の名前空間) でケーパビリティ"
#~ "を持つ。"

#
#~ msgid ""
#~ "When a user namespace is created, the kernel records the effective user "
#~ "ID of the creating process as being the \"owner\" of the namespace.  A "
#~ "process that resides in the parent of the user namespace and whose "
#~ "effective user ID matches the owner of the namespace has all capabilities "
#~ "in the namespace.  By virtue of the previous rule, this means that the "
#~ "process has all capabilities in all further removed descendant user "
#~ "namespaces as well."
#~ msgstr ""
#~ "ユーザー名前空間が作成された際、 カーネルはその名前空間の「所有者」として"
#~ "作成したプロセスの実効ユーザー ID を記録する。 親のユーザー名前空間に属す"
#~ "るプロセスで、 そのプロセスの実効ユーザー ID が名前空間の所有者と一致する"
#~ "場合、 そのプロセスはその名前空間ですべてのケーパビリティを持つ。 一つ前の"
#~ "ルールも合わせて考えると、 このプロセスはすべての削除された子孫のユーザー"
#~ "名前空間ですべてのケーパビリティを持つことを意味する。"

#~ msgid "Interaction of user namespaces and other types of namespaces"
#~ msgstr "ユーザー名前空間と他の名前空間の関係"

#~ msgid ""
#~ "Starting in Linux 3.8, unprivileged processes can create user namespaces, "
#~ "and mount, PID, IPC, network, and UTS namespaces can be created with just "
#~ "the B<CAP_SYS_ADMIN> capability in the caller's user namespace."
#~ msgstr ""
#~ "Linux 3.8 以降では、 非特権プロセスがユーザー名前空間を作成することができ"
#~ "る。 また、 呼び出し元のユーザー名前空間で B<CAP_SYS_ADMIN> ケーパビリティ"
#~ "を持っているだけで、 マウント名前空間、 PID 名前空間、 IPC 名前空間、 ネッ"
#~ "トワーク名前空間、 UTS 名前空間を作成できる。"

#~ msgid ""
#~ "When a non-user-namespace is created, it is owned by the user namespace "
#~ "in which the creating process was a member at the time of the creation of "
#~ "the namespace.  Actions on the non-user-namespace require capabilities in "
#~ "the corresponding user namespace."
#~ msgstr ""
#~ "ユーザー名前空間以外の名前空間が作成された場合、 その名前空間は呼び出した"
#~ "プロセスが名前空間の作成時にメンバーであったユーザー名前空間により所有され"
#~ "る。 ユーザー名前空間以外の名前空間における操作には、 対応するユーザー名前"
#~ "空間でのケーパビリティが必要である。"

#~ msgid ""
#~ "If B<CLONE_NEWUSER> is specified along with other B<CLONE_NEW*> flags in "
#~ "a single B<clone>(2)  or B<unshare>(2)  call, the user namespace is "
#~ "guaranteed to be created first, giving the child (B<clone>(2))  or caller "
#~ "(B<unshare>(2))  privileges over the remaining namespaces created by the "
#~ "call.  Thus, it is possible for an unprivileged caller to specify this "
#~ "combination of flags."
#~ msgstr ""
#~ "一つの B<clone>(2) や B<unshare>(2) の呼び出しで B<CLONE_NEWUSER> が他の "
#~ "B<CLONE_NEW*> フラグと一緒に指定された場合、 そのユーザー名前空間が最初に"
#~ "作成されることが保証され、 子プロセス (B<clone>(2) の場合) や呼び出し元 "
#~ "(B<unshare>(2) の場合) はその呼び出しで作成される残りの名前空間で特権を持"
#~ "つ。 したがって、 特権を持たない呼び出し元がフラグを組み合わせて指定するこ"
#~ "とができる。"

#
#~ msgid ""
#~ "When a new IPC, mount, network, PID, or UTS namespace is created via "
#~ "B<clone>(2)  or B<unshare>(2), the kernel records the user namespace of "
#~ "the creating process against the new namespace.  (This association can't "
#~ "be changed.)  When a process in the new namespace subsequently performs "
#~ "privileged operations that operate on global resources isolated by the "
#~ "namespace, the permission checks are performed according to the process's "
#~ "capabilities in the user namespace that the kernel associated with the "
#~ "new namespace."
#~ msgstr ""
#~ "新しい IPC 名前空間、 マウント名前空間、 ネットワーク名前空間、 PID 名前空"
#~ "間、 UTS 名前空間が B<clone>(2) や B<unshare>(2) で作成される際、 カーネル"
#~ "は新しい名前空間に対して作成したプロセスのユーザー名前空間を記録する (この"
#~ "関連付けは変更できない)。 その新しい名前空間のプロセスがその後名前空間で分"
#~ "離されたグローバルリソースに対して特権操作を行う場合、 カーネルが新しい名"
#~ "前空間に対して関連付けたユーザー名前空間でのプロセスのケーパビリティに基づ"
#~ "いてアクセス許可のチェックが行われる。"

#~ msgid "Restrictions on mount namespaces"
#~ msgstr "マウント名前空間における制限"

#~ msgid "Note the following points with respect to mount namespaces:"
#~ msgstr "マウント名前空間に関しては以下の点に注意すること。"

#~ msgid ""
#~ "A mount namespace has an owner user namespace.  A mount namespace whose "
#~ "owner user namespace is different from the owner user namespace of its "
#~ "parent mount namespace is considered a less privileged mount namespace."
#~ msgstr ""
#~ "マウント名前空間は所有者のユーザー名前空間を持つ。 所有者のユーザー名前空"
#~ "間が親のマウント名前空間の所有者のユーザー名前空間と異なるマウント名前空間"
#~ "は、 特権が少ないマウント名前空間 (less privileged mount namespace) であ"
#~ "る。"

#~ msgid ""
#~ "When creating a less privileged mount namespace, shared mounts are "
#~ "reduced to slave mounts.  This ensures that mappings performed in less "
#~ "privileged mount namespaces will not propagate to more privileged mount "
#~ "namespaces."
#~ msgstr ""
#~ "特権が少ないマウント名前空間を作成する場合、 共有マウントは slave マウント"
#~ "に縮小される。 これにより、 特権の少ないマウント名前空間で実行されるマッピ"
#~ "ングが、 より特権を持つマウント名前空間 (more privileged mount namespace) "
#~ "に伝搬しないことが保証される。"

#~ msgid ""
#~ "Mounts that come as a single unit from more privileged mount are locked "
#~ "together and may not be separated in a less privileged mount namespace.  "
#~ "(The B<unshare>(2)  B<CLONE_NEWNS> operation brings across all of the "
#~ "mounts from the original mount namespace as a single unit, and recursive "
#~ "mounts that propagate between mount namespaces propagate as a single "
#~ "unit.)"
#~ msgstr ""
#~ "より特権を持つマウントで一つのまとまりとして行われたマウントは一つにまと"
#~ "まったままとなり、 特権が少ないマウント名前空間で分割することはできない。 "
#~ "(B<unshare>(2) の B<CLONE_NEWNS> 操作では、 元のマウント名前空間のすべての"
#~ "マウントは一つのまとまりとして扱われ、 マウント名前空間間で伝わる再帰的な"
#~ "マウントでは一つのまとまりとして伝わる。)"

#
#~ msgid ""
#~ "The B<mount>(2)  flags B<MS_RDONLY>, B<MS_NOSUID>, B<MS_NOEXEC>, and the "
#~ "\"atime\" flags (B<MS_NOATIME>, B<MS_NODIRATIME>, B<MS_RELATIME>)  "
#~ "settings become locked when propagated from a more privileged to a less "
#~ "privileged mount namespace, and may not be changed in the less privileged "
#~ "mount namespace."
#~ msgstr ""
#~ "より特権を持つマウント名前空間から特権の少ないマウント名前空間に伝わる際"
#~ "に、 B<mount>(2) の B<MS_RDONLY>, B<MS_NOSUID>, B<MS_NOEXEC> フラグと "
#~ "\"atime\" フラグ (B<MS_NOATIME>, B<MS_NODIRATIME>, B<MS_REALTIME>) 設定は"
#~ "ロックされ、 特権の少ないマウント名前空間では変更することはできない。"

#~ msgid ""
#~ "A file or directory that is a mount point in one namespace that is not a "
#~ "mount point in another namespace, may be renamed, unlinked, or removed "
#~ "(B<rmdir>(2))  in the mount namespace in which it is not a mount point "
#~ "(subject to the usual permission checks)."
#~ msgstr ""
#~ "ある名前空間でマウントポイントとなっているが別の名前空間でのマウントポイン"
#~ "トになっていないファイルやディレクトリは、 マウントポイントになっていない"
#~ "マウント名前空間では (通常のアクセス許可チェックにもとづいて) rename, "
#~ "unlink, remove (B<rmdir>(2)) を行うことができる。"

#
#~ msgid ""
#~ "Previously, attempting to unlink, rename, or remove a file or directory "
#~ "that was a mount point in another mount namespace would result in the "
#~ "error B<EBUSY>.  That behavior had technical problems of enforcement (e."
#~ "g., for NFS)  and permitted denial-of-service attacks against more "
#~ "privileged users.  (i.e., preventing individual files from being updated "
#~ "by bind mounting on top of them)."
#~ msgstr ""
#~ "以前は、 別のマウント名前空間でマウントポイントとなっていたファイルやディ"
#~ "レクトリを rename, unlink, remove しようとすると、 エラー B<EBUSY> が返さ"
#~ "れていた。 この動作は、 (NFS などで) 適用にあたっての技術的な問題があると"
#~ "ともに、 より特権を持つユーザーに対してサービス不能攻撃 (denial-of-"
#~ "service attack) を許してしまっていた (ファイルをバインドマウントで更新する"
#~ "ことができなくなっていた)。"

#~ msgid "User and group ID mappings: uid_map and gid_map"
#~ msgstr "ユーザー ID とグループ ID のマッピング: uid_map と gid_map"

#~ msgid ""
#~ "When a user namespace is created, it starts out without a mapping of user "
#~ "IDs (group IDs)  to the parent user namespace.  The I</proc/[pid]/"
#~ "uid_map> and I</proc/[pid]/gid_map> files (available since Linux 3.5)  "
#~ "expose the mappings for user and group IDs inside the user namespace for "
#~ "the process I<pid>.  These files can be read to view the mappings in a "
#~ "user namespace and written to (once) to define the mappings."
#~ msgstr ""
#~ "ユーザー名前空間が作成された際、 その名前空間は親のユーザー名前空間への"
#~ "ユーザー ID (とグループ ID) のマッピングを行わずに開始される。 ファイル "
#~ "I</proc/[pid]/uid_map> と I</proc/[pid]/gid_map> (Linux 3.5 以降で利用可"
#~ "能) でプロセス I<pid> のユーザー名前空間内でのユーザー ID とグループ ID の"
#~ "マッピングにアクセスできる。 これらのファイルを読み出してユーザー名前空間"
#~ "内のマッピングを参照したり、 これらのファイルに書き込んでマッピングを (一"
#~ "度だけ) 定義することができる。"

#~ msgid ""
#~ "The description in the following paragraphs explains the details for "
#~ "I<uid_map>; I<gid_map> is exactly the same, but each instance of \"user ID"
#~ "\" is replaced by \"group ID\"."
#~ msgstr ""
#~ "以下の段落で I<uid_map> の詳細を説明する。 I<gid_map> に関しても全く同じで"
#~ "ある。 \"user ID\" という部分を \"group ID\" に置き換えればよい。"

#~ msgid ""
#~ "The I<uid_map> file exposes the mapping of user IDs from the user "
#~ "namespace of the process I<pid> to the user namespace of the process that "
#~ "opened I<uid_map> (but see a qualification to this point below).  In "
#~ "other words, processes that are in different user namespaces will "
#~ "potentially see different values when reading from a particular "
#~ "I<uid_map> file, depending on the user ID mappings for the user "
#~ "namespaces of the reading processes."
#~ msgstr ""
#~ "I<uid_map> ファイルで、 プロセス I<pid> のユーザー名前空間から I<uid_map> "
#~ "をオープンしたプロセスのユーザー名前空間にユーザー ID のマッピングが公開さ"
#~ "れる (公開するポリシーの条件については下記を参照)。 言い換えると、 別の"
#~ "ユーザー名前空間のプロセスでは、 特定の I<uid_map> ファイルを読み出した際"
#~ "に潜在的には別の値が見えることがあるということである。 見える値は読み出し"
#~ "たプロセスのユーザー名前空間のユーザー ID マッピングに依存する。"

#~ msgid ""
#~ "Each line in the I<uid_map> file specifies a 1-to-1 mapping of a range of "
#~ "contiguous user IDs between two user namespaces.  (When a user namespace "
#~ "is first created, this file is empty.)  The specification in each line "
#~ "takes the form of three numbers delimited by white space.  The first two "
#~ "numbers specify the starting user ID in each of the two user namespaces.  "
#~ "The third number specifies the length of the mapped range.  In detail, "
#~ "the fields are interpreted as follows:"
#~ msgstr ""
#~ "I<uid_map> ファイルの各行は 2 つのユーザー名前空間間の連続するユーザー ID "
#~ "の範囲の 1 対 1 マッピングを指定する (ユーザー名前空間が最初に作成された際"
#~ "にはこのファイルは空である)。 各行の指定の形式はホワイトスペース区切りの "
#~ "3 つの数字である。 最初の 2 つの数字は 2 つの ユーザー名前空間それぞれの開"
#~ "始ユーザー ID を指定する。 3 つ目の数字はマッピングされる範囲の長さを指定"
#~ "する。 詳しくは、各フィールドは以下のように解釈される。"

#~ msgid ""
#~ "The start of the range of user IDs in the user namespace of the process "
#~ "I<pid>."
#~ msgstr ""
#~ "プロセス I<pid> のユーザー名前空間におけるユーザー ID の範囲の開始値。"

#~ msgid ""
#~ "The start of the range of user IDs to which the user IDs specified by "
#~ "field one map.  How field two is interpreted depends on whether the "
#~ "process that opened I<uid_map> and the process I<pid> are in the same "
#~ "user namespace, as follows:"
#~ msgstr ""
#~ "1 番目のフィールドで指定されたユーザー ID がマッピングされる先のユーザー "
#~ "ID の範囲の開始値。 2 番目のフィールドがどのように解釈されるかは、 "
#~ "I<uid_map> をオープンしたプロセスとプロセス I<pid> が同じユーザー名前空間"
#~ "かどうかに依存する。 以下のとおり。"

#~ msgid ""
#~ "If the two processes are in different user namespaces: field two is the "
#~ "start of a range of user IDs in the user namespace of the process that "
#~ "opened I<uid_map>."
#~ msgstr ""
#~ "2 つのプロセスが異なるユーザー名前空間に属す場合、 2 番目のフィールドは "
#~ "I<uid_map> をオープンしたプロセスのユーザー名前空間におけるユーザー ID の"
#~ "範囲の開始値である。"

#~ msgid ""
#~ "If the two processes are in the same user namespace: field two is the "
#~ "start of the range of user IDs in the parent user namespace of the "
#~ "process I<pid>.  This case enables the opener of I<uid_map> (the common "
#~ "case here is opening I</proc/self/uid_map>)  to see the mapping of user "
#~ "IDs into the user namespace of the process that created this user "
#~ "namespace."
#~ msgstr ""
#~ "2 つのプロセスが同じユーザー名前空間に属す場合、 2 番目のフィールドはプロ"
#~ "セス I<pid> の親のユーザー名前空間におけるユーザー ID の範囲の開始値であ"
#~ "る。 この場合、 I<uid_map> をオープンしたプロセス (よくあるのは I</proc/"
#~ "self/uid_map> をオープンした場合である) は、 このユーザー名前空間を作成し"
#~ "たプロセスのユーザー名前空間に対するユーザー ID マッピングを参照することが"
#~ "できる。"

#~ msgid ""
#~ "The length of the range of user IDs that is mapped between the two user "
#~ "namespaces."
#~ msgstr ""
#~ "2 つのユーザー名前空間間でマッピングされるユーザー ID の範囲の長さ。"

#~ msgid ""
#~ "System calls that return user IDs (group IDs)\\(emfor example, "
#~ "B<getuid>(2), B<getgid>(2), and the credential fields in the structure "
#~ "returned by B<stat>(2)\\(emreturn the user ID (group ID) mapped into the "
#~ "caller's user namespace."
#~ msgstr ""
#~ "ユーザー ID (グループ ID) を返すシステムコール、例えば B<getuid>(2), "
#~ "B<getgid>(2) や B<stat>(2) が返す構造体の credential フィールド、は呼び出"
#~ "し元のユーザー名前空間にマッピングされたユーザー ID (グループ ID) を返す。"

#~ msgid ""
#~ "When a process accesses a file, its user and group IDs are mapped into "
#~ "the initial user namespace for the purpose of permission checking and "
#~ "assigning IDs when creating a file.  When a process retrieves file user "
#~ "and group IDs via B<stat>(2), the IDs are mapped in the opposite "
#~ "direction, to produce values relative to the process user and group ID "
#~ "mappings."
#~ msgstr ""
#~ "プロセスがファイルにアクセスする場合、 アクセス許可のチェックやファイル作"
#~ "成時の ID 割り当てのために、 そのユーザー ID とグループ ID は初期ユーザー"
#~ "名前空間にマッピングされる。 プロセスが B<stat>(2) を使ってファイルのユー"
#~ "ザー ID やグループ ID を取得する際には、 上記の反対方向に ID のマッピング"
#~ "が行われ、 プロセスにおける相対的なユーザー ID とグループ ID の値が生成さ"
#~ "れる。"

#~ msgid ""
#~ "The initial user namespace has no parent namespace, but, for consistency, "
#~ "the kernel provides dummy user and group ID mapping files for this "
#~ "namespace.  Looking at the I<uid_map> file (I<gid_map> is the same) from "
#~ "a shell in the initial namespace shows:"
#~ msgstr ""
#~ "初期ユーザー名前空間は親の名前空間を持たないが、 一貫性を持たせるため、 "
#~ "カーネルは初期の名前空間に対してダミーのユーザー ID とグループ ID のマッピ"
#~ "ングを提供する。 初期の名前空間のシェルから I<uid_map> ファイル "
#~ "(I<gid_map> も同じ) を参照するには以下のようにする。"

#~ msgid ""
#~ "$ B<cat /proc/$$/uid_map>\n"
#~ "         0          0 4294967295\n"
#~ msgstr ""
#~ "$ B<cat /proc/$$/uid_map>\n"
#~ "         0          0 4294967295\n"

#
#~ msgid ""
#~ "This mapping tells us that the range starting at user ID 0 in this "
#~ "namespace maps to a range starting at 0 in the (nonexistent) parent "
#~ "namespace, and the length of the range is the largest 32-bit unsigned "
#~ "integer.  (This deliberately leaves 4294967295 (the 32-bit signed -1 "
#~ "value) unmapped.  This is deliberate: I<(uid_t)\\ -\\1> is used in "
#~ "several interfaces (e.g., B<setreuid>(2))  as a way to specify \"no user "
#~ "ID\".  Leaving I<(uid_t)\\ -\\1> unmapped and unusable guarantees that "
#~ "there will be no confusion when using these interfaces."
#~ msgstr ""
#~ "このマッピングは、 この名前空間のユーザー ID 0 から始まる範囲が (実際には"
#~ "存在しない) 親の名前空間の 0 から始まる範囲にマッピングされ、 範囲の流さ"
#~ "は 32 ビットの unsigned integer の最大値である、 と言っている。 (ここで "
#~ "4294967295 (32 ビットの符号付き -1 の値) は意図的にマッピングされていな"
#~ "い。 I<(uid_t)\\ -\\1> は (B<setreuid>(2) など) いくつかのインターフェース"
#~ "で \"no user ID\" (ユーザー ID なし) を示す手段として使用されているので、 "
#~ "意図的にこのようになっている。 I<(uid_t)\\ -\\1> をマッピングせず、 利用で"
#~ "きないようにすることで、 これらのインターフェースを使った際に混乱が起こら"
#~ "ないように保証している。)"

#~ msgid "Defining user and group ID mappings: writing to uid_map and gid_map"
#~ msgstr "ユーザー ID とグループ ID のマッピングの定義: uid_map と gid_map への書き込み"

#~ msgid ""
#~ "After the creation of a new user namespace, the I<uid_map> file of I<one> "
#~ "of the processes in the namespace may be written to I<once> to define the "
#~ "mapping of user IDs in the new user namespace.  An attempt to write more "
#~ "than once to a I<uid_map> file in a user namespace fails with the error "
#~ "B<EPERM>.  Similar rules apply for I<gid_map> files."
#~ msgstr ""
#~ "新しいユーザー名前空間を作成した後、 新しいユーザー名前空間におけるユー"
#~ "ザー ID のマッピングを定義するため、 その名前空間のプロセスの「一つ」の "
#~ "I<uid_map> ファイルに「一度だけ」書き込みを行うことができる。 ユーザー名前"
#~ "空間の I<uid_map> ファイルに二度目以降の書き込みを行おうとすると、 エラー "
#~ "B<EPERM> で失敗する。 I<gid_map> ファイルについては同じルールが適用され"
#~ "る。"

#~ msgid ""
#~ "The lines written to I<uid_map> (I<gid_map>)  must conform to the "
#~ "following rules:"
#~ msgstr ""
#~ "I<uid_map> (I<gid_map>) に書き込む行は以下のルールに従っていなければならな"
#~ "い。"

#~ msgid ""
#~ "The three fields must be valid numbers, and the last field must be "
#~ "greater than 0."
#~ msgstr ""
#~ "3 のフィールドは有効な数字でなければならず、最後のフィールドは 0 より大き"
#~ "くなければならない。"

#~ msgid "Lines are terminated by newline characters."
#~ msgstr "行は改行文字で終了しなければならない。"

#~ msgid ""
#~ "There is an (arbitrary) limit on the number of lines in the file.  As at "
#~ "Linux 3.8, the limit is five lines.  In addition, the number of bytes "
#~ "written to the file must be less than the system page size, and the write "
#~ "must be performed at the start of the file (i.e., B<lseek>(2)  and "
#~ "B<pwrite>(2)  can't be used to write to nonzero offsets in the file)."
#~ msgstr ""
#~ "ファイルの行数には上限がある。 Linux 3.8 時点では、上限は 5 行である。 さ"
#~ "らに、 ファイルに書き込むバイト数はシステムページサイズより小さくなければ"
#~ "ならず、 書き込みはファイルの先頭に対して行わなければならない (つまり、 "
#~ "B<lseek>(2) や B<pwrite>(2) を使って 0 以外のファイルオフセットに書き込む"
#~ "ことはできない)。"

#~ msgid ""
#~ "The range of user IDs (group IDs)  specified in each line cannot overlap "
#~ "with the ranges in any other lines.  In the initial implementation (Linux "
#~ "3.8), this requirement was satisfied by a simplistic implementation that "
#~ "imposed the further requirement that the values in both field 1 and field "
#~ "2 of successive lines must be in ascending numerical order, which "
#~ "prevented some otherwise valid maps from being created.  Linux 3.9 and "
#~ "later fix this limitation, allowing any valid set of nonoverlapping maps."
#~ msgstr ""
#~ "各行で指定されるユーザー ID (グループ ID) の範囲は他の行が指定する範囲と重"
#~ "なってはならない。 最初の実装 (Linux 3.8) では、 この要件は、 後続行の"
#~ "フィールド 1 とフィールド 2 の両方の値が昇順になっていなければならないとい"
#~ "う追加の要件を設け、 これが満たされなかった場合は有効なマッピングは作成さ"
#~ "れない、 という単純な実装により満たされていた。 Linux 3.9 以降ではこの制限"
#~ "は修正され、 重複がない有効なマッピングであればどんな組み合わせでも指定で"
#~ "きるようになった。"

#~ msgid "Writes that violate the above rules fail with the error B<EINVAL>."
#~ msgstr "上記のルールを満たさない書き込みはエラー B<EINVAL> で失敗する。"

#~ msgid ""
#~ "In order for a process to write to the I</proc/[pid]/uid_map> (I</proc/"
#~ "[pid]/gid_map>)  file, all of the following requirements must be met:"
#~ msgstr ""
#~ "プロセスが I</proc/[pid]/uid_map> (I</proc/[pid]/gid_map>) ファイルに書き"
#~ "込むためには、 以下の要件がすべて満たされる必要がある。"

#~ msgid ""
#~ "The writing process must have the B<CAP_SETUID> (B<CAP_SETGID>)  "
#~ "capability in the user namespace of the process I<pid>."
#~ msgstr ""
#~ "書き込みプロセスは、 プロセス I<pid> のユーザー名前空間で B<CAP_SETUID> "
#~ "(B<CAP_SETGID>) ケーパビリティを持っていなければならない。"

#~ msgid ""
#~ "The mapped user IDs (group IDs) must in turn have a mapping in the parent "
#~ "user namespace."
#~ msgstr ""
#~ "マッピングされたユーザー ID (グループ ID) は親のユーザー名前空間にマッピン"
#~ "グを持っていなければならない。"

#~ msgid "One of the following is true:"
#~ msgstr "以下のいずれか一つが真である。"

#~ msgid ""
#~ "The data written to I<uid_map> (I<gid_map>)  consists of a single line "
#~ "that maps the writing process's filesystem user ID (group ID) in the "
#~ "parent user namespace to a user ID (group ID)  in the user namespace.  "
#~ "The usual case here is that this single line provides a mapping for user "
#~ "ID of the process that created the namespace."
#~ msgstr ""
#~ "I<uid_map> (I<gid_map>) に書き込まれるデータは、 書き込みを行うプロセスの"
#~ "親のユーザー名前空間でのファイルシステムユーザー ID (グループ ID) をその"
#~ "ユーザー名前空間でのユーザー ID (グループ ID) にマッピングする 1 行で構成"
#~ "されている。"

#~ msgid ""
#~ "The opening process has the B<CAP_SETUID> (B<CAP_SETGID>)  capability in "
#~ "the parent user namespace.  Thus, a privileged process can make mappings "
#~ "to arbitrary user IDs (group IDs)  in the parent user namespace."
#~ msgstr ""
#~ "オープンしたプロセスが親のユーザー名前空間で B<CAP_SETUID> "
#~ "(B<CAP_SETGID>) ケーパビリティを持っている。 したがって、 特権プロセスは親"
#~ "のユーザー名前空間の任意のユーザー ID (グループ ID) に対するマッピングを作"
#~ "成できる。"

#
#~ msgid "Writes that violate the above rules fail with the error B<EPERM>."
#~ msgstr "上記のルールを満たさない書き込みはエラー B<EPERM> で失敗する。"

#~ msgid ""
#~ "There are various places where an unmapped user ID (group ID)  may be "
#~ "exposed to user space.  For example, the first process in a new user "
#~ "namespace may call B<getuid>()  before a user ID mapping has been defined "
#~ "for the namespace.  In most such cases, an unmapped user ID is converted "
#~ "to the overflow user ID (group ID); the default value for the overflow "
#~ "user ID (group ID) is 65534.  See the descriptions of I</proc/sys/kernel/"
#~ "overflowuid> and I</proc/sys/kernel/overflowgid> in B<proc>(5)."
#~ msgstr ""
#~ "マッピングされていないユーザー ID (グループ ID) がユーザー空間に公開される"
#~ "場合はいろいろある。\n"
#~ "例えば、 新しいユーザー名前空間の最初のプロセスが、 その名前空間に対する"
#~ "ユーザー ID マッピングが定義される前に B<getuid>() を呼び出すなどである。 "
#~ "このようなほとんどの場合で、 マッピングされていないユーザー ID はオーバー"
#~ "フローユーザー ID (グループ ID)に変換される。 デフォルトのオーバーフロー"
#~ "ユーザー ID (グループ ID) は 65534 である。 B<proc>(5) の I</proc/sys/"
#~ "kernel/overflowuid> と I</proc/sys/kernel/overflowgid> の説明を参照。"

#~ msgid ""
#~ "The cases where unmapped IDs are mapped in this fashion include system "
#~ "calls that return user IDs (B<getuid>(2), B<getgid>(2), and similar), "
#~ "credentials passed over a UNIX domain socket, credentials returned by "
#~ "B<stat>(2), B<waitid>(2), and the System V IPC \"ctl\" B<IPC_STAT> "
#~ "operations, credentials exposed by I</proc/PID/status> and the files in "
#~ "I</proc/sysvipc/*>, credentials returned via the I<si_uid> field in the "
#~ "I<siginfo_t> received with a signal (see B<sigaction>(2)), credentials "
#~ "written to the process accounting file (see B<acct>(5)), and credentials "
#~ "returned with POSIX message queue notifications (see B<mq_notify>(3))."
#~ msgstr ""
#~ "マッピングされていない ID がこのようにマッピングされる場合としては、 ユー"
#~ "ザー ID を返すシステムコール (B<getuid>(2), B<getgid>(2) やその同類)、 "
#~ "UNIX ドメインソケットで渡される ID 情報 (credential)、 B<stat>(2) が返す "
#~ "ID 情報、 B<waitid>(2)、 System V IPC \"ctl\" B<IPC_STAT> 操作、 I</proc/"
#~ "PID/status> や I</proc/sysvipc/*> 内のファイルで公開される ID 情報、 シグ"
#~ "ナル受信時の I<siginfo_t> の I<si_uid> フィールドで返される ID 情報 "
#~ "(B<sigaction>(2) 参照)、 プロセスアカウンティングファイルに書き込まれる "
#~ "ID 情報 (B<acct>(5) 参照)、 POSIX メッセージキュー通知で返される ID 情報 "
#~ "(B<mq_notify>(3) 参照) がある。"

#
#~ msgid ""
#~ "There is one notable case where unmapped user and group IDs are I<not> "
#~ "converted to the corresponding overflow ID value.  When viewing a "
#~ "I<uid_map> or I<gid_map> file in which there is no mapping for the second "
#~ "field, that field is displayed as 4294967295 (-1 as an unsigned integer);"
#~ msgstr ""
#~ "マッピングされていないユーザー ID やグループ ID が対応するオーバーフロー "
#~ "ID 値に変換され「ない」重要な場合が一つある。 2 番目のフィールドにマッピン"
#~ "グがない I<uid_map> や I<gid_map> ファイルを参照した際、 そのフィールドは "
#~ "4294967295 (unsigned integer では -1) が表示される。"

#
#~ msgid ""
#~ "When a process inside a user namespace executes a set-user-ID (set-group-"
#~ "ID) program, the process's effective user (group) ID inside the namespace "
#~ "is changed to whatever value is mapped for the user (group) ID of the "
#~ "file.  However, if either the user I<or> the group ID of the file has no "
#~ "mapping inside the namespace, the set-user-ID (set-group-ID) bit is "
#~ "silently ignored: the new program is executed, but the process's "
#~ "effective user (group) ID is left unchanged.  (This mirrors the semantics "
#~ "of executing a set-user-ID or set-group-ID program that resides on a "
#~ "filesystem that was mounted with the B<MS_NOSUID> flag, as described in "
#~ "B<mount>(2).)"
#~ msgstr ""
#~ "ユーザー名前空間内のプロセスが set-user-ID (set-group-ID) されたプログラム"
#~ "を実行した場合、 そのプロセスの名前空間内の実効ユーザー ID (実効グループ "
#~ "ID) は、 そのファイルのユーザー ID (グループ ID) にマッピングされる。 しか"
#~ "し、 そのファイルのユーザー ID 「か」グループ ID が名前空間内のマッピング"
#~ "にない場合、 set-user-ID (set-group-ID) ビットは黙って無視される。 新しい"
#~ "プログラムは実行されるが、 そのプロセスの実効ユーザー ID (実効グループ "
#~ "ID) は変更されないままとなる。 (これは B<MS_NOSUID> フラグ付きでマウントさ"
#~ "れたファイルシステム上にある set-user-ID/set-group-ID プログラムを実行した"
#~ "場合の動作を反映したものである。 B<mount>(2) を参照。)"

#~ msgid ""
#~ "When a process's user and group IDs are passed over a UNIX domain socket "
#~ "to a process in a different user namespace (see the description of "
#~ "B<SCM_CREDENTIALS> in B<unix>(7)), they are translated into the "
#~ "corresponding values as per the receiving process's user and group ID "
#~ "mappings."
#~ msgstr ""
#~ "プロセスのユーザー ID とグループ ID が UNIX ドメインソケットを通して別の"
#~ "ユーザー名前空間のプロセスに渡された場合 (B<unix>(7) の "
#~ "B<SCM_CREDENTIALS> の説明を参照)、 ユーザー ID とグループ ID は受信プロセ"
#~ "スのユーザー ID とグループ ID のマッピングに基づき対応する値に翻訳される。"

#
#~ msgid ""
#~ "Over the years, there have been a lot of features that have been added to "
#~ "the Linux kernel that have been made available only to privileged users "
#~ "because of their potential to confuse set-user-ID-root applications.  In "
#~ "general, it becomes safe to allow the root user in a user namespace to "
#~ "use those features because it is impossible, while in a user namespace, "
#~ "to gain more privilege than the root user of a user namespace has."
#~ msgstr ""
#~ "長年にわたり、Linux カーネルには特権ユーザーに対してだけ利用できる機能が多"
#~ "く追加されて来た。 これは set-user-ID-root アプリケーションを混乱させる潜"
#~ "在的な可能性を考慮してである。 一般的には、 ユーザー名前空間の root ユー"
#~ "ザーにだけこれらの機能の使用を許可するのが安全である。 なぜなら、ユーザー"
#~ "名前空間の中にいる間は、 ユーザー名前空間の root ユーザーが持っている以上"
#~ "の特権を得ることはできないからである。"

#~ msgid "Availability"
#~ msgstr "可用性"

#~ msgid ""
#~ "Use of user namespaces requires a kernel that is configured with the "
#~ "B<CONFIG_USER_NS> option.  User namespaces require support in a range of "
#~ "subsystems across the kernel.  When an unsupported subsystem is "
#~ "configured into the kernel, it is not possible to configure user "
#~ "namespaces support."
#~ msgstr ""
#~ "ユーザー名前空間を使用するには、 B<CONFIG_USER_NS> オプションが有効になっ"
#~ "たカーネルが必要である。 ユーザー名前空間をカーネルの様々なサブシステムの"
#~ "サポートを必要とする。 サポートされていないサブシステムがカーネルに組み込"
#~ "まれている場合、 ユーザー名前空間のサポートを有効にすることはできない。"

#~ msgid ""
#~ "As at Linux 3.8, most relevant subsystems supported user namespaces, but "
#~ "a number of filesystems did not have the infrastructure needed to map "
#~ "user and group IDs between user namespaces.  Linux 3.9 added the required "
#~ "infrastructure support for many of the remaining unsupported filesystems "
#~ "(Plan 9 (9P), Andrew File System (AFS), Ceph, CIFS, CODA, NFS, and "
#~ "OCFS2).  Linux 3.11 added support the last of the unsupported major "
#~ "filesystems, XFS."
#~ msgstr ""
#~ "Linux 3.8 時点では、 ほとんどの関連するサブシステムはユーザー名前空間に対"
#~ "応しているが、 多くのファイルシステムにユーザー名前空間間でユーザー ID や"
#~ "グループ ID のマッピングを行うのに必要な基盤がなかった。 Linux 3.9 では、 "
#~ "残りの未サポートのファイルシステムの多くで必要な基盤のサポートが追加され"
#~ "た (Plan 9 (9P), Andrew File System (AFS), Ceph, CIFS, CODA, NFS, "
#~ "OCFS2)。 Linux 3.11 では、最後の主要な未サポートのファイルシステムであっ"
#~ "た XFS のサポートが追加された。"

#~ msgid ""
#~ "The program below is designed to allow experimenting with user "
#~ "namespaces, as well as other types of namespaces.  It creates namespaces "
#~ "as specified by command-line options and then executes a command inside "
#~ "those namespaces.  The comments and I<usage()> function inside the "
#~ "program provide a full explanation of the program.  The following shell "
#~ "session demonstrates its use."
#~ msgstr ""
#~ "以下のプログラムは、ユーザー名前空間で実験を行えるように設計されている。 "
#~ "他の種類の名前空間も扱える。 このプログラムはコマンドライン引数で指定さ"
#~ "れた名前空間を作成し、作成した名前空間内でコマンドを実行する。 コメントと"
#~ "プログラム内の I<usage()> 関数に、プログラムの詳しい説明が書かれている。 "
#~ "以下のシェルセッションに実行例を示す。"

#~ msgid "First, we look at the run-time environment:"
#~ msgstr "まず最初に、実行環境を確認しておく。"

#~ msgid ""
#~ "$ B<uname -rs>     # Need Linux 3.8 or later\n"
#~ "Linux 3.8.0\n"
#~ "$ B<id -u>         # Running as unprivileged user\n"
#~ "1000\n"
#~ "$ B<id -g>\n"
#~ "1000\n"
#~ msgstr ""
#~ "$ B<uname -rs>     # Linux 3.8 以降が必要\n"
#~ "Linux 3.8.0\n"
#~ "$ B<id -u>         # 非特権ユーザーで実行する\n"
#~ "1000\n"
#~ "$ B<id -g>\n"
#~ "1000\n"

#~ msgid ""
#~ "Now start a new shell in new user (I<-U>), mount (I<-m>), and PID (I<-"
#~ "p>)  namespaces, with user ID (I<-M>)  and group ID (I<-G>)  1000 mapped "
#~ "to 0 inside the user namespace:"
#~ msgstr ""
#~ "新しいユーザー名前空間 (I<-U>), マウント名前空間 (I<-m>), PID 名前空間 "
#~ "(I<-p>) で新しいシェルを開始する。ユーザー ID (I<-M>) 1000 とグループ ID "
#~ "(I<-G>) 1000 をユーザー名前空間内で 0 にマッピングしている。"

#~ msgid "$ B<./userns_child_exec -p -m -U -M '0 1000 1' -G '0 1000 1' bash>\n"
#~ msgstr "$ B<./userns_child_exec -p -m -U -M '0 1000 1' -G '0 1000 1' bash>\n"

#~ msgid ""
#~ "The shell has PID 1, because it is the first process in the new PID "
#~ "namespace:"
#~ msgstr ""
#~ "シェルは PID 1 を持つ。このシェルは新しい PID 名前空間の最初のプロセスだか"
#~ "らである。"

#~ msgid ""
#~ "bash$ B<echo $$>\n"
#~ "1\n"
#~ msgstr ""
#~ "bash$ B<echo $$>\n"
#~ "1\n"

#~ msgid ""
#~ "Inside the user namespace, the shell has user and group ID 0, and a full "
#~ "set of permitted and effective capabilities:"
#~ msgstr ""
#~ "ユーザー名前空間内では、シェルのユーザー ID とグループ ID ともに 0 で、す"
#~ "べての許可ケーパビリティと実効ケーパビリティが有効になっている。"

#~ msgid ""
#~ "bash$ B<cat /proc/$$/status | egrep '^[UG]id'>\n"
#~ "Uid:\t0\t0\t0\t0\n"
#~ "Gid:\t0\t0\t0\t0\n"
#~ "bash$ B<cat /proc/$$/status | egrep '^Cap(Prm|Inh|Eff)'>\n"
#~ "CapInh:\t0000000000000000\n"
#~ "CapPrm:\t0000001fffffffff\n"
#~ "CapEff:\t0000001fffffffff\n"
#~ msgstr ""
#~ "bash$ B<cat /proc/$$/status | egrep '^[UG]id'>\n"
#~ "Uid:\t0\t0\t0\t0\n"
#~ "Gid:\t0\t0\t0\t0\n"
#~ "bash$ B<cat /proc/$$/status | egrep '^Cap(Prm|Inh|Eff)'>\n"
#~ "CapInh:\t0000000000000000\n"
#~ "CapPrm:\t0000001fffffffff\n"
#~ "CapEff:\t0000001fffffffff\n"

#~ msgid ""
#~ "Mounting a new I</proc> filesystem and listing all of the processes "
#~ "visible in the new PID namespace shows that the shell can't see any "
#~ "processes outside the PID namespace:"
#~ msgstr ""
#~ "I</proc> ファイルシステムをマウントし、新しい PID 名前空間で見えるプロセス"
#~ "一覧を表示すると、 シェルからは PID 名前空間外のプロセスが見えないことが分"
#~ "かる。"

#~ msgid ""
#~ "bash$ B<mount -t proc proc /proc>\n"
#~ "bash$ B<ps ax>\n"
#~ "  PID TTY      STAT   TIME COMMAND\n"
#~ "    1 pts/3    S      0:00 bash\n"
#~ "   22 pts/3    R+     0:00 ps ax\n"
#~ msgstr ""
#~ "bash$ B<mount -t proc proc /proc>\n"
#~ "bash$ B<ps ax>\n"
#~ "  PID TTY      STAT   TIME COMMAND\n"
#~ "    1 pts/3    S      0:00 bash\n"
#~ "   22 pts/3    R+     0:00 ps ax\n"

#~ msgid "/* userns_child_exec.c\n"
#~ msgstr "/* userns_child_exec.c\n"

#~ msgid "   Licensed under GNU General Public License v2 or later\n"
#~ msgstr "   GNU General Public License v2 以降の元でライセンスされる\n"

#~ msgid ""
#~ "   Create a child process that executes a shell command in new\n"
#~ "   namespace(s); allow UID and GID mappings to be specified when\n"
#~ "   creating a user namespace.\n"
#~ "*/\n"
#~ "#define _GNU_SOURCE\n"
#~ "#include E<lt>sched.hE<gt>\n"
#~ "#include E<lt>unistd.hE<gt>\n"
#~ "#include E<lt>stdlib.hE<gt>\n"
#~ "#include E<lt>sys/wait.hE<gt>\n"
#~ "#include E<lt>signal.hE<gt>\n"
#~ "#include E<lt>fcntl.hE<gt>\n"
#~ "#include E<lt>stdio.hE<gt>\n"
#~ "#include E<lt>string.hE<gt>\n"
#~ "#include E<lt>limits.hE<gt>\n"
#~ "#include E<lt>errno.hE<gt>\n"
#~ msgstr ""
#~ "   新しい名前空間でシェルコマンドを実行する子プロセスを作成する。\n"
#~ "   ユーザー名前空間を作成する際に UID と GID のマッピングを\n"
#~ "   指定することができる。\n"
#~ "*/\n"
#~ "#define _GNU_SOURCE\n"
#~ "#include E<lt>sched.hE<gt>\n"
#~ "#include E<lt>unistd.hE<gt>\n"
#~ "#include E<lt>stdlib.hE<gt>\n"
#~ "#include E<lt>sys/wait.hE<gt>\n"
#~ "#include E<lt>signal.hE<gt>\n"
#~ "#include E<lt>fcntl.hE<gt>\n"
#~ "#include E<lt>stdio.hE<gt>\n"
#~ "#include E<lt>string.hE<gt>\n"
#~ "#include E<lt>limits.hE<gt>\n"
#~ "#include E<lt>errno.hE<gt>\n"

#~ msgid ""
#~ "/* A simple error-handling function: print an error message based\n"
#~ "   on the value in \\(aqerrno\\(aq and terminate the calling process */\n"
#~ msgstr ""
#~ "/* 簡単なエラー処理関数: \\\\(aqerrno\\\\(aq の値に基づいて\n"
#~ "   エラーメッセージを出力し、呼び出し元プロセスを終了する。 */\n"

#~ msgid ""
#~ "struct child_args {\n"
#~ "    char **argv;        /* Command to be executed by child, with args */\n"
#~ "    int    pipe_fd[2];  /* Pipe used to synchronize parent and child */\n"
#~ "};\n"
#~ msgstr ""
#~ "struct child_args {\n"
#~ "    char **argv;        /* 子プロセスが実行するコマンドと引数 */\n"
#~ "    int    pipe_fd[2];  /* 親プロセスと子プロセスを同期するためのパイプ */\n"
#~ "};\n"

#~ msgid ""
#~ "/* Update the mapping file \\(aqmap_file\\(aq, with the value provided in\n"
#~ "   \\(aqmapping\\(aq, a string that defines a UID or GID mapping. A UID or\n"
#~ "   GID mapping consists of one or more newline-delimited records\n"
#~ "   of the form:\n"
#~ msgstr ""
#~ "/* マッピングファイル \\(aqmap_file\\(aq を \\(aqmapping\\(aq で指定\n"
#~ "   された値で更新する。 \\(aqmapping\\(aq は UID や GID マッピングを\n"
#~ "   定義する文字列である。 UID や GID マッピングは以下の形式の改行\n"
#~ "   で区切られた 1 つ以上のレコードである。\n"

#~ msgid "       ID_inside-ns    ID-outside-ns   length\n"
#~ msgstr "       NS 内 ID        NS 外 ID        長さ\n"

#~ msgid ""
#~ "   Requiring the user to supply a string that contains newlines is\n"
#~ "   of course inconvenient for command-line use. Thus, we permit the\n"
#~ "   use of commas to delimit records in this string, and replace them\n"
#~ "   with newlines before writing the string to the file. */\n"
#~ msgstr ""
#~ "   ユーザーに改行を含む文字列を指定するのを求めるのは、\n"
#~ "   コマンドラインを使う場合にはもちろん不便なことである。\n"
#~ "   そのため、 この文字列でレコードを区切るのにカンマを\n"
#~ "   使えるようにして、ファイルにこの文字列を書き込む前に\n"
#~ "   カンマを改行に置換する。 */\n"

#~ msgid "    /* Replace commas in mapping string with newlines */\n"
#~ msgstr "    /* マッピング文字列内のカンマを改行で置換する */\n"

#~ msgid ""
#~ "static int              /* Start function for cloned child */\n"
#~ "childFunc(void *arg)\n"
#~ "{\n"
#~ "    struct child_args *args = (struct child_args *) arg;\n"
#~ "    char ch;\n"
#~ msgstr ""
#~ "static int              /* クローンされた子プロセスの開始関数 */\n"
#~ "childFunc(void *arg)\n"
#~ "{\n"
#~ "    struct child_args *args = (struct child_args *) arg;\n"
#~ "    char ch;\n"

#~ msgid ""
#~ "    /* Wait until the parent has updated the UID and GID mappings.\n"
#~ "       See the comment in main(). We wait for end of file on a\n"
#~ "       pipe that will be closed by the parent process once it has\n"
#~ "       updated the mappings. */\n"
#~ msgstr ""
#~ "    /* 親プロセスが UID と GID マッピングを更新するまで待つ。\n"
#~ "       main() のコメントを参照。 パイプの end of file を待つ。\n"
#~ "       親プロセスが一旦マッピングを更新すると、\n"
#~ "       パイプはクローズされる。 */\n"

#~ msgid ""
#~ "    close(args-E<gt>pipe_fd[1]);    /* Close our descriptor for the write\n"
#~ "                                   end of the pipe so that we see EOF\n"
#~ "                                   when parent closes its descriptor */\n"
#~ "    if (read(args-E<gt>pipe_fd[0], &ch, 1) != 0) {\n"
#~ "        fprintf(stderr,\n"
#~ "                \"Failure in child: read from pipe returned != 0\\en\");\n"
#~ "        exit(EXIT_FAILURE);\n"
#~ "    }\n"
#~ msgstr ""
#~ "    close(args-E<gt>pipe_fd[1]);    /* パイプのこちら側の書き込み端のディスク\n"
#~ "                                       リプターをクローズする。これにより\n"
#~ "                                       親プロセスがディスクリプターをクローズ\n"
#~ "                                       すると EOF が見えるようになる。 */\n"
#~ "    if (read(args-E<gt>pipe_fd[0], &ch, 1) != 0) {\n"
#~ "        fprintf(stderr,\n"
#~ "                \"Failure in child: read from pipe returned != 0\\en\");\n"
#~ "        exit(EXIT_FAILURE);\n"
#~ "    }\n"

#~ msgid "    /* Execute a shell command */\n"
#~ msgstr "    /* シェルコマンドを実行する */\n"

#~ msgid "#define STACK_SIZE (1024 * 1024)\n"
#~ msgstr "#define STACK_SIZE (1024 * 1024)\n"

#~ msgid "static char child_stack[STACK_SIZE];    /* Space for child\\(aqs stack */\n"
#~ msgstr "static char child_stack[STACK_SIZE];    /* 子プロセスのスタック空間 */\n"

#~ msgid ""
#~ "    /* Parse command-line options. The initial \\(aq+\\(aq character in\n"
#~ "       the final getopt() argument prevents GNU-style permutation\n"
#~ "       of command-line options. That\\(aqs useful, since sometimes\n"
#~ "       the \\(aqcommand\\(aq to be executed by this program itself\n"
#~ "       has command-line options. We don\\(aqt want getopt() to treat\n"
#~ "       those as options to this program. */\n"
#~ msgstr ""
#~ "    /* コマンドラインオプションを解析する。\n"
#~ "       最後の getopt() 引数の最初の \\(aq+\\(aq 文字は\n"
#~ "       GNU 風のコマンドラインオプションの並び換えを防止する。\n"
#~ "       このプログラム自身が実行する「コマンド」にコマンドライン\n"
#~ "       オプションが含まれる場合があるからである。\n"
#~ "       getopt() にこれらをこのプログラムのオプションとして\n"
#~ "       扱ってほしくはないのだ。 */\n"

#~ msgid "    /* -M or -G without -U is nonsensical */\n"
#~ msgstr "    /* -U なしの -M や -G の指定は意味がない */\n"

#~ msgid ""
#~ "    /* We use a pipe to synchronize the parent and child, in order to\n"
#~ "       ensure that the parent sets the UID and GID maps before the child\n"
#~ "       calls execve(). This ensures that the child maintains its\n"
#~ "       capabilities during the execve() in the common case where we\n"
#~ "       want to map the child\\(aqs effective user ID to 0 in the new user\n"
#~ "       namespace. Without this synchronization, the child would lose\n"
#~ "       its capabilities if it performed an execve() with nonzero\n"
#~ "       user IDs (see the capabilities(7) man page for details of the\n"
#~ "       transformation of a process\\(aqs capabilities during execve()). */\n"
#~ msgstr ""
#~ "    /* 親プログラムと子プロセスを同期するためにパイプを使っている。\n"
#~ "       これは、子プロセスが execve() を呼び出す前に、親プロセスにより\n"
#~ "       UID と GID マップが設定されることを保証するためである。\n"
#~ "       これにより、新しいユーザー名前空間において子プロセスの実効\n"
#~ "       ユーザー ID を 0 にマッピングしたいという通常の状況で、\n"
#~ "       子プロセスが execve() 実行中にそのケーパビリティを維持する\n"
#~ "       ことができる。 この同期を行わないと、 0 以外のユーザー ID で\n"
#~ "       execve() を実行した際に、子プロセスがそのケーパビリティを失う\n"
#~ "       ことになる (execve() 実行中のプロセスのケーパビリティの変化の\n"
#~ "       詳細については capabilities(7) マニュアルページを参照)。 */\n"

#~ msgid "    /* Parent falls through to here */\n"
#~ msgstr "    /* 親プロセスはここを実行する */\n"

#~ msgid "    /* Update the UID and GID maps in the child */\n"
#~ msgstr "    /* 子プロセスの UID と GID のマッピングを更新する */\n"

#~ msgid ""
#~ "    /* Close the write end of the pipe, to signal to the child that we\n"
#~ "       have updated the UID and GID maps */\n"
#~ msgstr ""
#~ "    /* パイプの書き込み端をクローズし、子プロセスに UID と GID の\n"
#~ "       マッピングが更新されたことを知らせる */\n"
