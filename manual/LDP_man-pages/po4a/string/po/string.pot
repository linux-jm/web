# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-03-12 14:00+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man3/bcmp.3:31
#, no-wrap
msgid "BCMP"
msgstr ""

#. type: TH
#: build/C/man3/bcmp.3:31 build/C/man3/bcopy.3:33 build/C/man3/memfrob.3:30 build/C/man3/memmem.3:30 build/C/man3/memmove.3:30 build/C/man3/memset.3:30
#, no-wrap
msgid "2017-03-13"
msgstr ""

#. type: TH
#: build/C/man3/bcmp.3:31 build/C/man3/bcopy.3:33 build/C/man3/bzero.3:25
#, no-wrap
msgid "Linux"
msgstr ""

#. type: TH
#: build/C/man3/bcmp.3:31 build/C/man3/bcopy.3:33 build/C/man3/bstring.3:32 build/C/man3/bzero.3:25 build/C/man3/ffs.3:33 build/C/man3/index.3:31 build/C/man3/memccpy.3:30 build/C/man3/memchr.3:32 build/C/man3/memcmp.3:30 build/C/man3/memcpy.3:31 build/C/man3/memfrob.3:30 build/C/man3/memmem.3:30 build/C/man3/memmove.3:30 build/C/man3/mempcpy.3:10 build/C/man3/memset.3:30 build/C/man3/stpcpy.3:25 build/C/man3/stpncpy.3:14 build/C/man3/strcasecmp.3:30 build/C/man3/strcat.3:32 build/C/man3/strchr.3:33 build/C/man3/strcmp.3:33 build/C/man3/strcoll.3:30 build/C/man3/strcpy.3:35 build/C/man3/strdup.3:31 build/C/man3/strerror.3:39 build/C/man3/strfry.3:30 build/C/man3/string.3:30 build/C/man3/strlen.3:30 build/C/man3/strnlen.3:13 build/C/man3/strpbrk.3:30 build/C/man3/strsep.3:33 build/C/man3/strsignal.3:31 build/C/man3/strspn.3:30 build/C/man3/strstr.3:33 build/C/man3/strtok.3:32 build/C/man3/strverscmp.3:26 build/C/man3/strxfrm.3:30
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr ""

#. type: SH
#: build/C/man3/bcmp.3:32 build/C/man3/bcopy.3:34 build/C/man3/bstring.3:33 build/C/man3/bzero.3:26 build/C/man3/ffs.3:34 build/C/man3/index.3:32 build/C/man3/memccpy.3:31 build/C/man3/memchr.3:33 build/C/man3/memcmp.3:31 build/C/man3/memcpy.3:32 build/C/man3/memfrob.3:31 build/C/man3/memmem.3:31 build/C/man3/memmove.3:31 build/C/man3/mempcpy.3:11 build/C/man3/memset.3:31 build/C/man3/stpcpy.3:26 build/C/man3/stpncpy.3:15 build/C/man3/strcasecmp.3:31 build/C/man3/strcat.3:33 build/C/man3/strchr.3:34 build/C/man3/strcmp.3:34 build/C/man3/strcoll.3:31 build/C/man3/strcpy.3:36 build/C/man3/strdup.3:32 build/C/man3/strerror.3:40 build/C/man3/strfry.3:31 build/C/man3/string.3:31 build/C/man3/strlen.3:31 build/C/man3/strnlen.3:14 build/C/man3/strpbrk.3:31 build/C/man3/strsep.3:34 build/C/man3/strsignal.3:32 build/C/man3/strspn.3:31 build/C/man3/strstr.3:34 build/C/man3/strtok.3:33 build/C/man3/strverscmp.3:27 build/C/man3/strxfrm.3:31
#, no-wrap
msgid "NAME"
msgstr ""

#. type: Plain text
#: build/C/man3/bcmp.3:34
msgid "bcmp - compare byte sequences"
msgstr ""

#. type: SH
#: build/C/man3/bcmp.3:34 build/C/man3/bcopy.3:36 build/C/man3/bstring.3:36 build/C/man3/bzero.3:28 build/C/man3/ffs.3:36 build/C/man3/index.3:34 build/C/man3/memccpy.3:33 build/C/man3/memchr.3:35 build/C/man3/memcmp.3:33 build/C/man3/memcpy.3:34 build/C/man3/memfrob.3:33 build/C/man3/memmem.3:33 build/C/man3/memmove.3:33 build/C/man3/mempcpy.3:13 build/C/man3/memset.3:33 build/C/man3/stpcpy.3:28 build/C/man3/stpncpy.3:17 build/C/man3/strcasecmp.3:33 build/C/man3/strcat.3:35 build/C/man3/strchr.3:36 build/C/man3/strcmp.3:36 build/C/man3/strcoll.3:33 build/C/man3/strcpy.3:38 build/C/man3/strdup.3:34 build/C/man3/strerror.3:42 build/C/man3/strfry.3:33 build/C/man3/string.3:36 build/C/man3/strlen.3:33 build/C/man3/strnlen.3:16 build/C/man3/strpbrk.3:33 build/C/man3/strsep.3:36 build/C/man3/strsignal.3:34 build/C/man3/strspn.3:33 build/C/man3/strstr.3:36 build/C/man3/strtok.3:35 build/C/man3/strverscmp.3:29 build/C/man3/strxfrm.3:33
#, no-wrap
msgid "SYNOPSIS"
msgstr ""

#. type: Plain text
#: build/C/man3/bcmp.3:37 build/C/man3/bcopy.3:39 build/C/man3/bzero.3:31 build/C/man3/ffs.3:39 build/C/man3/index.3:37 build/C/man3/strcasecmp.3:36
#, no-wrap
msgid "B<#include E<lt>strings.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/bcmp.3:39 build/C/man3/bstring.3:41
#, no-wrap
msgid "B<int bcmp(const void *>I<s1>B<, const void *>I<s2>B<, size_t >I<n>B<);>\n"
msgstr ""

#. type: SH
#: build/C/man3/bcmp.3:40 build/C/man3/bcopy.3:42 build/C/man3/bstring.3:63 build/C/man3/bzero.3:38 build/C/man3/ffs.3:84 build/C/man3/index.3:42 build/C/man3/memccpy.3:39 build/C/man3/memchr.3:54 build/C/man3/memcmp.3:39 build/C/man3/memcpy.3:40 build/C/man3/memfrob.3:40 build/C/man3/memmem.3:41 build/C/man3/memmove.3:39 build/C/man3/mempcpy.3:25 build/C/man3/memset.3:39 build/C/man3/stpcpy.3:53 build/C/man3/stpncpy.3:42 build/C/man3/strcasecmp.3:41 build/C/man3/strcat.3:43 build/C/man3/strchr.3:49 build/C/man3/strcmp.3:44 build/C/man3/strcoll.3:39 build/C/man3/strcpy.3:46 build/C/man3/strdup.3:75 build/C/man3/strerror.3:80 build/C/man3/strfry.3:40 build/C/man3/string.3:204 build/C/man3/strlen.3:39 build/C/man3/strnlen.3:41 build/C/man3/strpbrk.3:39 build/C/man3/strsep.3:53 build/C/man3/strsignal.3:76 build/C/man3/strspn.3:41 build/C/man3/strstr.3:48 build/C/man3/strtok.3:54 build/C/man3/strverscmp.3:36 build/C/man3/strxfrm.3:39
#, no-wrap
msgid "DESCRIPTION"
msgstr ""

#. type: Plain text
#: build/C/man3/bcmp.3:56
msgid ""
"The B<bcmp>()  function compares the two byte sequences I<s1> and I<s2> of "
"length I<n> each.  If they are equal, and in particular if I<n> is zero, "
"B<bcmp>()  returns 0.  Otherwise, it returns a nonzero result."
msgstr ""

#. type: SH
#: build/C/man3/bcmp.3:56 build/C/man3/bcopy.3:52 build/C/man3/bzero.3:55 build/C/man3/ffs.3:97 build/C/man3/index.3:55 build/C/man3/memccpy.3:55 build/C/man3/memchr.3:105 build/C/man3/memcmp.3:45 build/C/man3/memcpy.3:49 build/C/man3/memfrob.3:53 build/C/man3/memmem.3:54 build/C/man3/memmove.3:57 build/C/man3/mempcpy.3:51 build/C/man3/memset.3:49 build/C/man3/stpcpy.3:63 build/C/man3/stpncpy.3:82 build/C/man3/strcasecmp.3:65 build/C/man3/strcat.3:123 build/C/man3/strchr.3:81 build/C/man3/strcmp.3:83 build/C/man3/strcoll.3:58 build/C/man3/strcpy.3:108 build/C/man3/strdup.3:109 build/C/man3/strerror.3:187 build/C/man3/strfry.3:48 build/C/man3/strlen.3:45 build/C/man3/strnlen.3:58 build/C/man3/strpbrk.3:47 build/C/man3/strsep.3:76 build/C/man3/strsignal.3:116 build/C/man3/strspn.3:57 build/C/man3/strstr.3:62 build/C/man3/strtok.3:163 build/C/man3/strverscmp.3:81 build/C/man3/strxfrm.3:62
#, no-wrap
msgid "RETURN VALUE"
msgstr ""

#. type: Plain text
#: build/C/man3/bcmp.3:61
msgid ""
"The B<bcmp>()  function returns 0 if the byte sequences are equal, otherwise "
"a nonzero result is returned."
msgstr ""

#. type: SH
#: build/C/man3/bcmp.3:61 build/C/man3/bcopy.3:54 build/C/man3/bzero.3:60 build/C/man3/ffs.3:101 build/C/man3/index.3:62 build/C/man3/memccpy.3:70 build/C/man3/memchr.3:124 build/C/man3/memcmp.3:64 build/C/man3/memcpy.3:53 build/C/man3/memfrob.3:58 build/C/man3/memmem.3:59 build/C/man3/memmove.3:62 build/C/man3/mempcpy.3:58 build/C/man3/memset.3:54 build/C/man3/stpcpy.3:71 build/C/man3/stpncpy.3:91 build/C/man3/strcasecmp.3:77 build/C/man3/strcat.3:130 build/C/man3/strchr.3:105 build/C/man3/strcmp.3:96 build/C/man3/strcoll.3:69 build/C/man3/strcpy.3:116 build/C/man3/strdup.3:121 build/C/man3/strerror.3:242 build/C/man3/strfry.3:53 build/C/man3/strlen.3:50 build/C/man3/strnlen.3:71 build/C/man3/strpbrk.3:56 build/C/man3/strsep.3:82 build/C/man3/strsignal.3:143 build/C/man3/strspn.3:74 build/C/man3/strstr.3:65 build/C/man3/strtok.3:170 build/C/man3/strverscmp.3:90 build/C/man3/strxfrm.3:76
#, no-wrap
msgid "ATTRIBUTES"
msgstr ""

#. type: Plain text
#: build/C/man3/bcmp.3:64 build/C/man3/bcopy.3:57 build/C/man3/bzero.3:63 build/C/man3/ffs.3:104 build/C/man3/index.3:65 build/C/man3/memccpy.3:73 build/C/man3/memchr.3:127 build/C/man3/memcmp.3:67 build/C/man3/memcpy.3:56 build/C/man3/memfrob.3:61 build/C/man3/memmem.3:62 build/C/man3/memmove.3:65 build/C/man3/mempcpy.3:61 build/C/man3/memset.3:57 build/C/man3/stpcpy.3:74 build/C/man3/stpncpy.3:94 build/C/man3/strcasecmp.3:80 build/C/man3/strcat.3:133 build/C/man3/strchr.3:108 build/C/man3/strcmp.3:99 build/C/man3/strcoll.3:72 build/C/man3/strcpy.3:119 build/C/man3/strdup.3:124 build/C/man3/strerror.3:245 build/C/man3/strfry.3:56 build/C/man3/strlen.3:53 build/C/man3/strnlen.3:74 build/C/man3/strpbrk.3:59 build/C/man3/strsep.3:85 build/C/man3/strsignal.3:146 build/C/man3/strspn.3:77 build/C/man3/strstr.3:68 build/C/man3/strtok.3:173 build/C/man3/strverscmp.3:93 build/C/man3/strxfrm.3:79
msgid "For an explanation of the terms used in this section, see B<attributes>(7)."
msgstr ""

#. type: tbl table
#: build/C/man3/bcmp.3:68 build/C/man3/bcopy.3:61 build/C/man3/bzero.3:67 build/C/man3/ffs.3:108 build/C/man3/index.3:69 build/C/man3/memccpy.3:77 build/C/man3/memchr.3:131 build/C/man3/memcmp.3:71 build/C/man3/memcpy.3:60 build/C/man3/memfrob.3:65 build/C/man3/memmem.3:66 build/C/man3/memmove.3:69 build/C/man3/mempcpy.3:65 build/C/man3/memset.3:61 build/C/man3/stpcpy.3:78 build/C/man3/stpncpy.3:98 build/C/man3/strcasecmp.3:84 build/C/man3/strcat.3:137 build/C/man3/strchr.3:112 build/C/man3/strcmp.3:103 build/C/man3/strcoll.3:76 build/C/man3/strcpy.3:123 build/C/man3/strdup.3:128 build/C/man3/strerror.3:249 build/C/man3/strfry.3:60 build/C/man3/strlen.3:57 build/C/man3/strnlen.3:78 build/C/man3/strpbrk.3:63 build/C/man3/strsep.3:89 build/C/man3/strsignal.3:150 build/C/man3/strspn.3:81 build/C/man3/strstr.3:72 build/C/man3/strtok.3:177 build/C/man3/strverscmp.3:97 build/C/man3/strxfrm.3:83
#, no-wrap
msgid "Interface"
msgstr ""

#. type: tbl table
#: build/C/man3/bcmp.3:68 build/C/man3/bcopy.3:61 build/C/man3/bzero.3:67 build/C/man3/ffs.3:108 build/C/man3/index.3:69 build/C/man3/memccpy.3:77 build/C/man3/memchr.3:131 build/C/man3/memcmp.3:71 build/C/man3/memcpy.3:60 build/C/man3/memfrob.3:65 build/C/man3/memmem.3:66 build/C/man3/memmove.3:69 build/C/man3/mempcpy.3:65 build/C/man3/memset.3:61 build/C/man3/stpcpy.3:78 build/C/man3/stpncpy.3:98 build/C/man3/strcasecmp.3:84 build/C/man3/strcat.3:137 build/C/man3/strchr.3:112 build/C/man3/strcmp.3:103 build/C/man3/strcoll.3:76 build/C/man3/strcpy.3:123 build/C/man3/strdup.3:128 build/C/man3/strerror.3:249 build/C/man3/strfry.3:60 build/C/man3/strlen.3:57 build/C/man3/strnlen.3:78 build/C/man3/strpbrk.3:63 build/C/man3/strsep.3:89 build/C/man3/strsignal.3:150 build/C/man3/strspn.3:81 build/C/man3/strstr.3:72 build/C/man3/strtok.3:177 build/C/man3/strverscmp.3:97 build/C/man3/strxfrm.3:83
#, no-wrap
msgid "Attribute"
msgstr ""

#. type: tbl table
#: build/C/man3/bcmp.3:68 build/C/man3/bcopy.3:61 build/C/man3/bzero.3:67 build/C/man3/ffs.3:108 build/C/man3/index.3:69 build/C/man3/memccpy.3:77 build/C/man3/memchr.3:131 build/C/man3/memcmp.3:71 build/C/man3/memcpy.3:60 build/C/man3/memfrob.3:65 build/C/man3/memmem.3:66 build/C/man3/memmove.3:69 build/C/man3/mempcpy.3:65 build/C/man3/memset.3:61 build/C/man3/stpcpy.3:78 build/C/man3/stpncpy.3:98 build/C/man3/strcasecmp.3:84 build/C/man3/strcat.3:137 build/C/man3/strchr.3:112 build/C/man3/strcmp.3:103 build/C/man3/strcoll.3:76 build/C/man3/strcpy.3:123 build/C/man3/strdup.3:128 build/C/man3/strerror.3:249 build/C/man3/strfry.3:60 build/C/man3/strlen.3:57 build/C/man3/strnlen.3:78 build/C/man3/strpbrk.3:63 build/C/man3/strsep.3:89 build/C/man3/strsignal.3:150 build/C/man3/strspn.3:81 build/C/man3/strstr.3:72 build/C/man3/strtok.3:177 build/C/man3/strverscmp.3:97 build/C/man3/strxfrm.3:83
#, no-wrap
msgid "Value"
msgstr ""

#. type: tbl table
#: build/C/man3/bcmp.3:71
#, no-wrap
msgid "B<bcmp>()"
msgstr ""

#. type: tbl table
#: build/C/man3/bcmp.3:71 build/C/man3/bcopy.3:64 build/C/man3/bzero.3:72 build/C/man3/ffs.3:113 build/C/man3/index.3:73 build/C/man3/memccpy.3:80 build/C/man3/memchr.3:136 build/C/man3/memcmp.3:74 build/C/man3/memcpy.3:63 build/C/man3/memfrob.3:68 build/C/man3/memmem.3:69 build/C/man3/memmove.3:72 build/C/man3/mempcpy.3:69 build/C/man3/memset.3:64 build/C/man3/stpcpy.3:81 build/C/man3/stpncpy.3:101 build/C/man3/strcasecmp.3:88 build/C/man3/strcat.3:141 build/C/man3/strchr.3:117 build/C/man3/strcmp.3:107 build/C/man3/strcoll.3:79 build/C/man3/strcpy.3:127 build/C/man3/strdup.3:135 build/C/man3/strerror.3:252 build/C/man3/strerror.3:256 build/C/man3/strerror.3:261 build/C/man3/strfry.3:63 build/C/man3/strlen.3:60 build/C/man3/strnlen.3:81 build/C/man3/strpbrk.3:66 build/C/man3/strsep.3:92 build/C/man3/strsignal.3:153 build/C/man3/strsignal.3:157 build/C/man3/strspn.3:85 build/C/man3/strstr.3:75 build/C/man3/strstr.3:78 build/C/man3/strtok.3:180 build/C/man3/strtok.3:183 build/C/man3/strverscmp.3:100 build/C/man3/strxfrm.3:86
#, no-wrap
msgid "Thread safety"
msgstr ""

#. type: tbl table
#: build/C/man3/bcmp.3:71 build/C/man3/bcopy.3:64 build/C/man3/bzero.3:72 build/C/man3/ffs.3:113 build/C/man3/index.3:73 build/C/man3/memccpy.3:80 build/C/man3/memchr.3:136 build/C/man3/memcmp.3:74 build/C/man3/memcpy.3:63 build/C/man3/memfrob.3:68 build/C/man3/memmem.3:69 build/C/man3/memmove.3:72 build/C/man3/mempcpy.3:69 build/C/man3/memset.3:64 build/C/man3/stpcpy.3:81 build/C/man3/stpncpy.3:101 build/C/man3/strcat.3:141 build/C/man3/strchr.3:117 build/C/man3/strcmp.3:107 build/C/man3/strcpy.3:127 build/C/man3/strdup.3:135 build/C/man3/strerror.3:256 build/C/man3/strerror.3:261 build/C/man3/strfry.3:63 build/C/man3/strlen.3:60 build/C/man3/strnlen.3:81 build/C/man3/strpbrk.3:66 build/C/man3/strsep.3:92 build/C/man3/strsignal.3:157 build/C/man3/strspn.3:85 build/C/man3/strstr.3:75 build/C/man3/strtok.3:183 build/C/man3/strverscmp.3:100
#, no-wrap
msgid "MT-Safe"
msgstr ""

#. type: SH
#: build/C/man3/bcmp.3:73 build/C/man3/bcopy.3:66 build/C/man3/bzero.3:74 build/C/man3/ffs.3:115 build/C/man3/index.3:75 build/C/man3/memccpy.3:82 build/C/man3/memchr.3:138 build/C/man3/memcmp.3:76 build/C/man3/memcpy.3:65 build/C/man3/memfrob.3:70 build/C/man3/memmem.3:71 build/C/man3/memmove.3:74 build/C/man3/mempcpy.3:71 build/C/man3/memset.3:66 build/C/man3/stpcpy.3:83 build/C/man3/stpncpy.3:103 build/C/man3/strcasecmp.3:90 build/C/man3/strcat.3:143 build/C/man3/strchr.3:119 build/C/man3/strcmp.3:109 build/C/man3/strcoll.3:82 build/C/man3/strcpy.3:129 build/C/man3/strdup.3:138 build/C/man3/strerror.3:263 build/C/man3/strfry.3:65 build/C/man3/strlen.3:62 build/C/man3/strnlen.3:83 build/C/man3/strpbrk.3:68 build/C/man3/strsep.3:94 build/C/man3/strsignal.3:160 build/C/man3/strspn.3:87 build/C/man3/strstr.3:80 build/C/man3/strtok.3:185 build/C/man3/strverscmp.3:112 build/C/man3/strxfrm.3:88
#, no-wrap
msgid "CONFORMING TO"
msgstr ""

#. type: Plain text
#: build/C/man3/bcmp.3:80
msgid ""
"4.3BSD.  This function is deprecated (marked as LEGACY in POSIX.1-2001): use "
"B<memcmp>(3)  in new programs.  POSIX.1-2008 removes the specification of "
"B<bcmp>()."
msgstr ""

#. type: SH
#: build/C/man3/bcmp.3:80 build/C/man3/bcopy.3:80 build/C/man3/bstring.3:82 build/C/man3/bzero.3:172 build/C/man3/ffs.3:127 build/C/man3/index.3:86 build/C/man3/memccpy.3:84 build/C/man3/memchr.3:149 build/C/man3/memcmp.3:88 build/C/man3/memcpy.3:109 build/C/man3/memfrob.3:75 build/C/man3/memmem.3:99 build/C/man3/memmove.3:76 build/C/man3/mempcpy.3:84 build/C/man3/memset.3:68 build/C/man3/stpcpy.3:122 build/C/man3/stpncpy.3:107 build/C/man3/strcasecmp.3:117 build/C/man3/strcat.3:226 build/C/man3/strchr.3:126 build/C/man3/strcmp.3:210 build/C/man3/strcoll.3:93 build/C/man3/strcpy.3:233 build/C/man3/strdup.3:148 build/C/man3/strerror.3:314 build/C/man3/strfry.3:70 build/C/man3/string.3:208 build/C/man3/strlen.3:64 build/C/man3/strnlen.3:85 build/C/man3/strpbrk.3:70 build/C/man3/strsep.3:114 build/C/man3/strsignal.3:177 build/C/man3/strspn.3:89 build/C/man3/strstr.3:87 build/C/man3/strtok.3:282 build/C/man3/strverscmp.3:154 build/C/man3/strxfrm.3:90
#, no-wrap
msgid "SEE ALSO"
msgstr ""

#. type: Plain text
#: build/C/man3/bcmp.3:88
msgid ""
"B<bstring>(3), B<memcmp>(3), B<strcasecmp>(3), B<strcmp>(3), B<strcoll>(3), "
"B<strncasecmp>(3), B<strncmp>(3)"
msgstr ""

#. type: SH
#: build/C/man3/bcmp.3:88 build/C/man3/bcopy.3:87 build/C/man3/bstring.3:94 build/C/man3/bzero.3:176 build/C/man3/ffs.3:129 build/C/man3/index.3:96 build/C/man3/memccpy.3:91 build/C/man3/memchr.3:162 build/C/man3/memcmp.3:97 build/C/man3/memcpy.3:118 build/C/man3/memfrob.3:78 build/C/man3/memmem.3:102 build/C/man3/memmove.3:84 build/C/man3/mempcpy.3:89 build/C/man3/memset.3:73 build/C/man3/stpcpy.3:131 build/C/man3/stpncpy.3:110 build/C/man3/strcasecmp.3:126 build/C/man3/strcat.3:235 build/C/man3/strchr.3:139 build/C/man3/strcmp.3:221 build/C/man3/strcoll.3:101 build/C/man3/strcpy.3:244 build/C/man3/strdup.3:156 build/C/man3/strerror.3:321 build/C/man3/strfry.3:73 build/C/man3/string.3:233 build/C/man3/strlen.3:69 build/C/man3/strnlen.3:87 build/C/man3/strpbrk.3:81 build/C/man3/strsep.3:124 build/C/man3/strsignal.3:180 build/C/man3/strspn.3:101 build/C/man3/strstr.3:100 build/C/man3/strtok.3:293 build/C/man3/strverscmp.3:159 build/C/man3/strxfrm.3:98
#, no-wrap
msgid "COLOPHON"
msgstr ""

#. type: Plain text
#: build/C/man3/bcmp.3:96 build/C/man3/bcopy.3:95 build/C/man3/bstring.3:102 build/C/man3/bzero.3:184 build/C/man3/ffs.3:137 build/C/man3/index.3:104 build/C/man3/memccpy.3:99 build/C/man3/memchr.3:170 build/C/man3/memcmp.3:105 build/C/man3/memcpy.3:126 build/C/man3/memfrob.3:86 build/C/man3/memmem.3:110 build/C/man3/memmove.3:92 build/C/man3/mempcpy.3:97 build/C/man3/memset.3:81 build/C/man3/stpcpy.3:139 build/C/man3/stpncpy.3:118 build/C/man3/strcasecmp.3:134 build/C/man3/strcat.3:243 build/C/man3/strchr.3:147 build/C/man3/strcmp.3:229 build/C/man3/strcoll.3:109 build/C/man3/strcpy.3:252 build/C/man3/strdup.3:164 build/C/man3/strerror.3:329 build/C/man3/strfry.3:81 build/C/man3/string.3:241 build/C/man3/strlen.3:77 build/C/man3/strnlen.3:95 build/C/man3/strpbrk.3:89 build/C/man3/strsep.3:132 build/C/man3/strsignal.3:188 build/C/man3/strspn.3:109 build/C/man3/strstr.3:108 build/C/man3/strtok.3:301 build/C/man3/strverscmp.3:167 build/C/man3/strxfrm.3:106
msgid ""
"This page is part of release 5.10 of the Linux I<man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at "
"\\%https://www.kernel.org/doc/man-pages/."
msgstr ""

#. type: TH
#: build/C/man3/bcopy.3:33
#, no-wrap
msgid "BCOPY"
msgstr ""

#. type: Plain text
#: build/C/man3/bcopy.3:36
msgid "bcopy - copy byte sequence"
msgstr ""

#. type: Plain text
#: build/C/man3/bcopy.3:41 build/C/man3/bstring.3:43
#, no-wrap
msgid "B<void bcopy(const void *>I<src>B<, void *>I<dest>B<, size_t >I<n>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/bcopy.3:52
msgid ""
"The B<bcopy>()  function copies I<n> bytes from I<src> to I<dest>.  The "
"result is correct, even when both areas overlap."
msgstr ""

#. type: Plain text
#: build/C/man3/bcopy.3:54 build/C/man3/bzero.3:57
msgid "None."
msgstr ""

#. type: tbl table
#: build/C/man3/bcopy.3:64
#, no-wrap
msgid "B<bcopy>()"
msgstr ""

#. type: Plain text
#: build/C/man3/bcopy.3:80
msgid ""
"4.3BSD.  This function is deprecated (marked as LEGACY in POSIX.1-2001): use "
"B<memcpy>(3)  or B<memmove>(3)  in new programs.  Note that the first two "
"arguments are interchanged for B<memcpy>(3)  and B<memmove>(3).  "
"POSIX.1-2008 removes the specification of B<bcopy>()."
msgstr ""

#. type: Plain text
#: build/C/man3/bcopy.3:87
msgid ""
"B<bstring>(3), B<memccpy>(3), B<memcpy>(3), B<memmove>(3), B<strcpy>(3), "
"B<strncpy>(3)"
msgstr ""

#. type: TH
#: build/C/man3/bstring.3:32
#, no-wrap
msgid "BSTRING"
msgstr ""

#. type: TH
#: build/C/man3/bstring.3:32 build/C/man3/strnlen.3:13
#, no-wrap
msgid "2020-12-21"
msgstr ""

#. type: Plain text
#: build/C/man3/bstring.3:36
msgid ""
"bcmp, bcopy, bzero, memccpy, memchr, memcmp, memcpy, memfrob, memmem, "
"memmove, memset - byte string operations"
msgstr ""

#. type: Plain text
#: build/C/man3/bstring.3:39 build/C/man3/bzero.3:35 build/C/man3/ffs.3:43 build/C/man3/memccpy.3:36 build/C/man3/memchr.3:38 build/C/man3/memcmp.3:36 build/C/man3/memcpy.3:37 build/C/man3/memmove.3:36 build/C/man3/memset.3:36 build/C/man3/stpcpy.3:31 build/C/man3/stpncpy.3:20 build/C/man3/strcat.3:38 build/C/man3/strchr.3:39 build/C/man3/strcmp.3:39 build/C/man3/strcoll.3:36 build/C/man3/strcpy.3:41 build/C/man3/strdup.3:37 build/C/man3/strerror.3:45 build/C/man3/strlen.3:36 build/C/man3/strnlen.3:19 build/C/man3/strpbrk.3:36 build/C/man3/strsep.3:39 build/C/man3/strsignal.3:37 build/C/man3/strspn.3:36 build/C/man3/strstr.3:39 build/C/man3/strstr.3:45 build/C/man3/strtok.3:38 build/C/man3/strxfrm.3:36
#, no-wrap
msgid "B<#include E<lt>string.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/bstring.3:45 build/C/man3/bzero.3:33
#, no-wrap
msgid "B<void bzero(void *>I<s>B<, size_t >I<n>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/bstring.3:47 build/C/man3/memccpy.3:38
#, no-wrap
msgid ""
"B<void *memccpy(void *>I<dest>B<, const void *>I<src>B<, int >I<c>B<, size_t "
">I<n>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/bstring.3:49 build/C/man3/memchr.3:40
#, no-wrap
msgid "B<void *memchr(const void *>I<s>B<, int >I<c>B<, size_t >I<n>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/bstring.3:51 build/C/man3/memcmp.3:38
#, no-wrap
msgid "B<int memcmp(const void *>I<s1>B<, const void *>I<s2>B<, size_t >I<n>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/bstring.3:53 build/C/man3/memcpy.3:39
#, no-wrap
msgid "B<void *memcpy(void *>I<dest>B<, const void *>I<src>B<, size_t >I<n>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/bstring.3:55 build/C/man3/memfrob.3:39
#, no-wrap
msgid "B<void *memfrob(void *>I<s>B<, size_t >I<n>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/bstring.3:58 build/C/man3/memmem.3:40
#, no-wrap
msgid ""
"B<void *memmem(const void *>I<haystack>B<, size_t >I<haystacklen>B<,>\n"
"B<             const void *>I<needle>B<, size_t >I<needlelen>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/bstring.3:60 build/C/man3/memmove.3:38
#, no-wrap
msgid "B<void *memmove(void *>I<dest>B<, const void *>I<src>B<, size_t >I<n>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/bstring.3:62 build/C/man3/memset.3:38
#, no-wrap
msgid "B<void *memset(void *>I<s>B<, int >I<c>B<, size_t >I<n>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/bstring.3:68
msgid ""
"The byte string functions perform operations on strings (byte arrays)  that "
"are not necessarily null-terminated.  See the individual man pages for "
"descriptions of each function."
msgstr ""

#. type: SH
#: build/C/man3/bstring.3:68 build/C/man3/bzero.3:93 build/C/man3/ffs.3:124 build/C/man3/memcmp.3:78 build/C/man3/memcpy.3:67 build/C/man3/strcasecmp.3:92 build/C/man3/strcat.3:145 build/C/man3/strcmp.3:111 build/C/man3/strcoll.3:84 build/C/man3/strcpy.3:131 build/C/man3/strerror.3:302 build/C/man3/strsep.3:96 build/C/man3/strsignal.3:172 build/C/man3/strtok.3:192
#, no-wrap
msgid "NOTES"
msgstr ""

#.  The old functions are not even available on some non-GNU/Linux systems.
#. type: Plain text
#: build/C/man3/bstring.3:82
msgid ""
"The functions B<bcmp>(), B<bcopy>(), and B<bzero>()  are obsolete.  Use "
"B<memcmp>(), B<memcpy>(), and B<memset>()  instead."
msgstr ""

#. type: Plain text
#: build/C/man3/bstring.3:94
msgid ""
"B<bcmp>(3), B<bcopy>(3), B<bzero>(3), B<memccpy>(3), B<memchr>(3), "
"B<memcmp>(3), B<memcpy>(3), B<memfrob>(3), B<memmem>(3), B<memmove>(3), "
"B<memset>(3)"
msgstr ""

#. type: TH
#: build/C/man3/bzero.3:25
#, no-wrap
msgid "BZERO"
msgstr ""

#. type: TH
#: build/C/man3/bzero.3:25 build/C/man3/index.3:31 build/C/man3/memchr.3:32 build/C/man3/stpncpy.3:14 build/C/man3/strchr.3:33 build/C/man3/strcpy.3:35 build/C/man3/strdup.3:31 build/C/man3/strfry.3:30 build/C/man3/string.3:30 build/C/man3/strlen.3:30 build/C/man3/strsep.3:33 build/C/man3/strstr.3:33 build/C/man3/strxfrm.3:30
#, no-wrap
msgid "2019-03-06"
msgstr ""

#. type: Plain text
#: build/C/man3/bzero.3:28
msgid "bzero, explicit_bzero - zero a byte string"
msgstr ""

#. type: Plain text
#: build/C/man3/bzero.3:37
#, no-wrap
msgid "B<void explicit_bzero(void *>I<s>B<, size_t >I<n>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/bzero.3:46
msgid ""
"The B<bzero>()  function erases the data in the I<n> bytes of the memory "
"starting at the location pointed to by I<s>, by writing zeros (bytes "
"containing \\(aq\\e0\\(aq) to that area."
msgstr ""

#. type: Plain text
#: build/C/man3/bzero.3:55
msgid ""
"The B<explicit_bzero>()  function performs the same task as B<bzero>().  It "
"differs from B<bzero>()  in that it guarantees that compiler optimizations "
"will not remove the erase operation if the compiler deduces that the "
"operation is \"unnecessary\"."
msgstr ""

#. type: SH
#: build/C/man3/bzero.3:57 build/C/man3/memchr.3:118 build/C/man3/mempcpy.3:55 build/C/man3/strchr.3:102 build/C/man3/strerror.3:238 build/C/man3/strsignal.3:132
#, no-wrap
msgid "VERSIONS"
msgstr ""

#. type: Plain text
#: build/C/man3/bzero.3:60
msgid "B<explicit_bzero>()  first appeared in glibc 2.25."
msgstr ""

#. type: tbl table
#: build/C/man3/bzero.3:70
#, no-wrap
msgid "B<bzero>(),\n"
msgstr ""

#. type: tbl table
#: build/C/man3/bzero.3:70 build/C/man3/strdup.3:133 build/C/man3/strerror.3:259
#, no-wrap
msgid ".br\n"
msgstr ""

#. type: tbl table
#: build/C/man3/bzero.3:72
#, no-wrap
msgid "B<explicit_bzero>()"
msgstr ""

#. type: Plain text
#: build/C/man3/bzero.3:85
msgid ""
"The B<bzero>()  function is deprecated (marked as LEGACY in POSIX.1-2001); "
"use B<memset>(3)  in new programs.  POSIX.1-2008 removes the specification "
"of B<bzero>().  The B<bzero>()  function first appeared in 4.3BSD."
msgstr ""

#. type: Plain text
#: build/C/man3/bzero.3:93
msgid ""
"The B<explicit_bzero>()  function is a nonstandard extension that is also "
"present on some of the BSDs.  Some other implementations have a similar "
"function, such as B<memset_explicit>()  or B<memset_s>()."
msgstr ""

#. type: Plain text
#: build/C/man3/bzero.3:113
msgid ""
"The B<explicit_bzero>()  function addresses a problem that "
"security-conscious applications may run into when using B<bzero>(): if the "
"compiler can deduce that the location to zeroed will never again be touched "
"by a I<correct> program, then it may remove the B<bzero>()  call "
"altogether.  This is a problem if the intent of the B<bzero>()  call was to "
"erase sensitive data (e.g., passwords)  to prevent the possibility that the "
"data was leaked by an incorrect or compromised program.  Calls to "
"B<explicit_bzero>()  are never optimized away by the compiler."
msgstr ""

#. type: Plain text
#: build/C/man3/bzero.3:117
msgid ""
"The B<explicit_bzero>()  function does not solve all problems associated "
"with erasing sensitive data:"
msgstr ""

#. type: IP
#: build/C/man3/bzero.3:117
#, no-wrap
msgid "1."
msgstr ""

#. type: Plain text
#: build/C/man3/bzero.3:130
msgid ""
"The B<explicit_bzero>()  function does I<not> guarantee that sensitive data "
"is completely erased from memory.  (The same is true of B<bzero>().)  For "
"example, there may be copies of the sensitive data in a register and in "
"\"scratch\" stack areas.  The B<explicit_bzero>()  function is not aware of "
"these copies, and can't erase them."
msgstr ""

#. type: IP
#: build/C/man3/bzero.3:130
#, no-wrap
msgid "2."
msgstr ""

#. type: Plain text
#: build/C/man3/bzero.3:152
msgid ""
"In some circumstances, B<explicit_bzero>()  can I<decrease> security.  If "
"the compiler determined that the variable containing the sensitive data "
"could be optimized to be stored in a register (because it is small enough to "
"fit in a register, and no operation other than the B<explicit_bzero>()  call "
"would need to take the address of the variable), then the "
"B<explicit_bzero>()  call will force the data to be copied from the register "
"to a location in RAM that is then immediately erased (while the copy in the "
"register remains unaffected).  The problem here is that data in RAM is more "
"likely to be exposed by a bug than data in a register, and thus the "
"B<explicit_bzero>()  call creates a brief time window where the sensitive "
"data is more vulnerable than it would otherwise have been if no attempt had "
"been made to erase the data."
msgstr ""

#. type: Plain text
#: build/C/man3/bzero.3:162
msgid ""
"Note that declaring the sensitive variable with the B<volatile> qualifier "
"does I<not> eliminate the above problems.  Indeed, it will make them worse, "
"since, for example, it may force a variable that would otherwise have been "
"optimized into a register to instead be maintained in (more vulnerable)  RAM "
"for its entire lifetime."
msgstr ""

#. type: Plain text
#: build/C/man3/bzero.3:172
msgid ""
"Notwithstanding the above details, for security-conscious applications, "
"using B<explicit_bzero>()  is generally preferable to not using it.  The "
"developers of B<explicit_bzero>()  anticipate that future compilers will "
"recognize calls to B<explicit_bzero>()  and take steps to ensure that all "
"copies of the sensitive data are erased, including copies in registers or in "
"\"scratch\" stack areas."
msgstr ""

#. type: Plain text
#: build/C/man3/bzero.3:176
msgid "B<bstring>(3), B<memset>(3), B<swab>(3)"
msgstr ""

#. type: TH
#: build/C/man3/ffs.3:33
#, no-wrap
msgid "FFS"
msgstr ""

#. type: TH
#: build/C/man3/ffs.3:33 build/C/man3/strcat.3:32 build/C/man3/strerror.3:39 build/C/man3/strsignal.3:31 build/C/man3/strtok.3:32
#, no-wrap
msgid "2020-11-01"
msgstr ""

#. type: TH
#: build/C/man3/ffs.3:33 build/C/man3/index.3:31 build/C/man3/memccpy.3:30 build/C/man3/memfrob.3:30 build/C/man3/memmem.3:30 build/C/man3/memmove.3:30 build/C/man3/mempcpy.3:10 build/C/man3/memset.3:30 build/C/man3/stpcpy.3:25 build/C/man3/stpncpy.3:14 build/C/man3/strcat.3:32 build/C/man3/strchr.3:33 build/C/man3/strcoll.3:30 build/C/man3/strcpy.3:35 build/C/man3/strdup.3:31 build/C/man3/strfry.3:30 build/C/man3/strlen.3:30 build/C/man3/strnlen.3:13 build/C/man3/strsep.3:33 build/C/man3/strsignal.3:31 build/C/man3/strstr.3:33 build/C/man3/strtok.3:32 build/C/man3/strverscmp.3:26 build/C/man3/strxfrm.3:30
#, no-wrap
msgid "GNU"
msgstr ""

#. type: Plain text
#: build/C/man3/ffs.3:36
msgid "ffs, ffsl, ffsll - find first bit set in a word"
msgstr ""

#. type: Plain text
#: build/C/man3/ffs.3:41
#, no-wrap
msgid "B<int ffs(int >I<i>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/ffs.3:45
#, no-wrap
msgid "B<int ffsl(long >I<i>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/ffs.3:47
#, no-wrap
msgid "B<int ffsll(long long >I<i>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/ffs.3:52 build/C/man3/memchr.3:49 build/C/man3/stpcpy.3:38 build/C/man3/stpncpy.3:27 build/C/man3/strdup.3:48 build/C/man3/strerror.3:62 build/C/man3/strnlen.3:26 build/C/man3/strsep.3:46 build/C/man3/strsignal.3:48 build/C/man3/strtok.3:47
msgid "Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr ""

#. type: Plain text
#: build/C/man3/ffs.3:57
msgid "B<ffs>():"
msgstr ""

#. type: TP
#: build/C/man3/ffs.3:58
#, no-wrap
msgid "Since glibc 2.12:"
msgstr ""

#. type: Plain text
#: build/C/man3/ffs.3:64
#, no-wrap
msgid ""
"    _XOPEN_SOURCE E<gt>= 700\n"
"    || ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200809L)\n"
"    || /* Glibc since 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""

#. type: TP
#: build/C/man3/ffs.3:64
#, no-wrap
msgid "Before glibc 2.12:"
msgstr ""

#. type: Plain text
#: build/C/man3/ffs.3:67
msgid "none"
msgstr ""

#. type: Plain text
#: build/C/man3/ffs.3:71
msgid "B<ffsl>(), B<ffsll>():"
msgstr ""

#. type: TP
#: build/C/man3/ffs.3:73
#, no-wrap
msgid "Since glibc 2.27:"
msgstr ""

#.  glibc commit 68fe16dd327c895c08b9ee443b234c49c13b36e9
#. type: Plain text
#: build/C/man3/ffs.3:77
#, no-wrap
msgid "    _DEFAULT_SOURCE\n"
msgstr ""

#. type: TP
#: build/C/man3/ffs.3:77
#, no-wrap
msgid "Before glibc 2.27:"
msgstr ""

#. type: Plain text
#: build/C/man3/ffs.3:80
#, no-wrap
msgid "    _GNU_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man3/ffs.3:97
msgid ""
"The B<ffs>()  function returns the position of the first (least significant) "
"bit set in the word I<i>.  The least significant bit is position 1 and the "
"most significant position is, for example, 32 or 64.  The functions "
"B<ffsll>()  and B<ffsl>()  do the same but take arguments of possibly "
"different size."
msgstr ""

#. type: Plain text
#: build/C/man3/ffs.3:101
msgid ""
"These functions return the position of the first bit set, or 0 if no bits "
"are set in I<i>."
msgstr ""

#. type: tbl table
#: build/C/man3/ffs.3:113
#, no-wrap
msgid ""
"B<ffs>(),\n"
"B<ffsl>(),\n"
"B<ffsll>()"
msgstr ""

#. type: Plain text
#: build/C/man3/ffs.3:118
msgid "B<ffs>(): POSIX.1-2001, POSIX.1-2008, 4.3BSD."
msgstr ""

#. type: Plain text
#: build/C/man3/ffs.3:124
msgid "The B<ffsl>()  and B<ffsll>()  functions are glibc extensions."
msgstr ""

#. type: Plain text
#: build/C/man3/ffs.3:127
msgid "BSD systems have a prototype in I<E<lt>string.hE<gt>>."
msgstr ""

#. type: Plain text
#: build/C/man3/ffs.3:129
msgid "B<memchr>(3)"
msgstr ""

#. type: TH
#: build/C/man3/index.3:31
#, no-wrap
msgid "INDEX"
msgstr ""

#. type: Plain text
#: build/C/man3/index.3:34
msgid "index, rindex - locate character in string"
msgstr ""

#. type: Plain text
#: build/C/man3/index.3:39
#, no-wrap
msgid "B<char *index(const char *>I<s>B<, int >I<c>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/index.3:41
#, no-wrap
msgid "B<char *rindex(const char *>I<s>B<, int >I<c>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/index.3:47
msgid ""
"The B<index>()  function returns a pointer to the first occurrence of the "
"character I<c> in the string I<s>."
msgstr ""

#. type: Plain text
#: build/C/man3/index.3:52
msgid ""
"The B<rindex>()  function returns a pointer to the last occurrence of the "
"character I<c> in the string I<s>."
msgstr ""

#. type: Plain text
#: build/C/man3/index.3:55
msgid ""
"The terminating null byte (\\(aq\\e0\\(aq) is considered to be a part of the "
"strings."
msgstr ""

#. type: Plain text
#: build/C/man3/index.3:62
msgid ""
"The B<index>()  and B<rindex>()  functions return a pointer to the matched "
"character or NULL if the character is not found."
msgstr ""

#. type: tbl table
#: build/C/man3/index.3:73
#, no-wrap
msgid ""
"B<index>(),\n"
"B<rindex>()"
msgstr ""

#. type: Plain text
#: build/C/man3/index.3:86
msgid ""
"4.3BSD; marked as LEGACY in POSIX.1-2001.  POSIX.1-2008 removes the "
"specifications of B<index>()  and B<rindex>(), recommending B<strchr>(3)  "
"and B<strrchr>(3)  instead."
msgstr ""

#. type: Plain text
#: build/C/man3/index.3:96
msgid ""
"B<memchr>(3), B<strchr>(3), B<string>(3), B<strpbrk>(3), B<strrchr>(3), "
"B<strsep>(3), B<strspn>(3), B<strstr>(3), B<strtok>(3)"
msgstr ""

#. type: TH
#: build/C/man3/memccpy.3:30
#, no-wrap
msgid "MEMCCPY"
msgstr ""

#. type: TH
#: build/C/man3/memccpy.3:30 build/C/man3/memcmp.3:30 build/C/man3/memcpy.3:31 build/C/man3/strcasecmp.3:30 build/C/man3/strcoll.3:30
#, no-wrap
msgid "2017-09-15"
msgstr ""

#. type: Plain text
#: build/C/man3/memccpy.3:33
msgid "memccpy - copy memory area"
msgstr ""

#. type: Plain text
#: build/C/man3/memccpy.3:53
msgid ""
"The B<memccpy>()  function copies no more than I<n> bytes from memory area "
"I<src> to memory area I<dest>, stopping when the character I<c> is found."
msgstr ""

#. type: Plain text
#: build/C/man3/memccpy.3:55
msgid "If the memory areas overlap, the results are undefined."
msgstr ""

#. type: Plain text
#: build/C/man3/memccpy.3:70
msgid ""
"The B<memccpy>()  function returns a pointer to the next character in "
"I<dest> after I<c>, or NULL if I<c> was not found in the first I<n> "
"characters of I<src>."
msgstr ""

#. type: tbl table
#: build/C/man3/memccpy.3:80
#, no-wrap
msgid "B<memccpy>()"
msgstr ""

#. type: Plain text
#: build/C/man3/memccpy.3:84
msgid "POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD."
msgstr ""

#. type: Plain text
#: build/C/man3/memccpy.3:91
msgid ""
"B<bcopy>(3), B<bstring>(3), B<memcpy>(3), B<memmove>(3), B<strcpy>(3), "
"B<strncpy>(3)"
msgstr ""

#. type: TH
#: build/C/man3/memchr.3:32
#, no-wrap
msgid "MEMCHR"
msgstr ""

#. type: Plain text
#: build/C/man3/memchr.3:35
msgid "memchr, memrchr, rawmemchr - scan memory for a character"
msgstr ""

#. type: Plain text
#: build/C/man3/memchr.3:42
#, no-wrap
msgid "B<void *memrchr(const void *>I<s>B<, int >I<c>B<, size_t >I<n>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/memchr.3:44
#, no-wrap
msgid "B<void *rawmemchr(const void *>I<s>B<, int >I<c>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/memchr.3:54
msgid "B<memrchr>(), B<rawmemchr>(): _GNU_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man3/memchr.3:70
msgid ""
"The B<memchr>()  function scans the initial I<n> bytes of the memory area "
"pointed to by I<s> for the first instance of I<c>.  Both I<c> and the bytes "
"of the memory area pointed to by I<s> are interpreted as I<unsigned char>."
msgstr ""

#. type: Plain text
#: build/C/man3/memchr.3:81
msgid ""
"The B<memrchr>()  function is like the B<memchr>()  function, except that it "
"searches backward from the end of the I<n> bytes pointed to by I<s> instead "
"of forward from the beginning."
msgstr ""

#. type: Plain text
#: build/C/man3/memchr.3:99
msgid ""
"The B<rawmemchr>()  function is similar to B<memchr>(): it assumes (i.e., "
"the programmer knows for certain)  that an instance of I<c> lies somewhere "
"in the memory area starting at the location pointed to by I<s>, and so "
"performs an optimized search for I<c> (i.e., no use of a count argument to "
"limit the range of the search).  If an instance of I<c> is not found, the "
"results are unpredictable.  The following call is a fast means of locating a "
"string's terminating null byte:"
msgstr ""

#. type: Plain text
#: build/C/man3/memchr.3:103
#, no-wrap
msgid "char *p = rawmemchr(s,\\ \\(aq\\e0\\(aq);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/memchr.3:113
msgid ""
"The B<memchr>()  and B<memrchr>()  functions return a pointer to the "
"matching byte or NULL if the character does not occur in the given memory "
"area."
msgstr ""

#. type: Plain text
#: build/C/man3/memchr.3:118
msgid ""
"The B<rawmemchr>()  function returns a pointer to the matching byte, if one "
"is found.  If no matching byte is found, the result is unspecified."
msgstr ""

#. type: Plain text
#: build/C/man3/memchr.3:121
msgid "B<rawmemchr>()  first appeared in glibc in version 2.1."
msgstr ""

#. type: Plain text
#: build/C/man3/memchr.3:124
msgid "B<memrchr>()  first appeared in glibc in version 2.2."
msgstr ""

#. type: tbl table
#: build/C/man3/memchr.3:136
#, no-wrap
msgid ""
"B<memchr>(),\n"
"B<memrchr>(),\n"
"B<rawmemchr>()"
msgstr ""

#. type: Plain text
#: build/C/man3/memchr.3:141
msgid "B<memchr>(): POSIX.1-2001, POSIX.1-2008, C89, C99, SVr4, 4.3BSD."
msgstr ""

#. type: Plain text
#: build/C/man3/memchr.3:145
msgid "The B<memrchr>()  function is a GNU extension, available since glibc 2.1.91."
msgstr ""

#. type: Plain text
#: build/C/man3/memchr.3:149
msgid "The B<rawmemchr>()  function is a GNU extension, available since glibc 2.1."
msgstr ""

#. type: Plain text
#: build/C/man3/memchr.3:162
msgid ""
"B<bstring>(3), B<ffs>(3), B<index>(3), B<memmem>(3), B<rindex>(3), "
"B<strchr>(3), B<strpbrk>(3), B<strrchr>(3), B<strsep>(3), B<strspn>(3), "
"B<strstr>(3), B<wmemchr>(3)"
msgstr ""

#. type: TH
#: build/C/man3/memcmp.3:30
#, no-wrap
msgid "MEMCMP"
msgstr ""

#. type: Plain text
#: build/C/man3/memcmp.3:33
msgid "memcmp - compare memory areas"
msgstr ""

#. type: Plain text
#: build/C/man3/memcmp.3:45
msgid ""
"The B<memcmp>()  function compares the first I<n> bytes (each interpreted as "
"I<unsigned char>)  of the memory areas I<s1> and I<s2>."
msgstr ""

#. type: Plain text
#: build/C/man3/memcmp.3:52
msgid ""
"The B<memcmp>()  function returns an integer less than, equal to, or greater "
"than zero if the first I<n> bytes of I<s1> is found, respectively, to be "
"less than, to match, or be greater than the first I<n> bytes of I<s2>."
msgstr ""

#. type: Plain text
#: build/C/man3/memcmp.3:60
msgid ""
"For a nonzero return value, the sign is determined by the sign of the "
"difference between the first pair of bytes (interpreted as I<unsigned char>)  "
"that differ in I<s1> and I<s2>."
msgstr ""

#. type: Plain text
#: build/C/man3/memcmp.3:64
msgid "If I<n> is zero, the return value is zero."
msgstr ""

#. type: tbl table
#: build/C/man3/memcmp.3:74
#, no-wrap
msgid "B<memcmp>()"
msgstr ""

#. type: Plain text
#: build/C/man3/memcmp.3:78 build/C/man3/memcpy.3:67 build/C/man3/memmove.3:76 build/C/man3/memset.3:68 build/C/man3/strcat.3:145 build/C/man3/strcmp.3:111 build/C/man3/strcoll.3:84 build/C/man3/strcpy.3:131 build/C/man3/strpbrk.3:70 build/C/man3/strspn.3:89 build/C/man3/strtok.3:189 build/C/man3/strxfrm.3:90
msgid "POSIX.1-2001, POSIX.1-2008, C89, C99, SVr4, 4.3BSD."
msgstr ""

#. type: Plain text
#: build/C/man3/memcmp.3:88
msgid ""
"Do not use B<memcmp>()  to compare security critical data, such as "
"cryptographic secrets, because the required CPU time depends on the number "
"of equal bytes.  Instead, a function that performs comparisons in constant "
"time is required.  Some operating systems provide such a function (e.g., "
"NetBSD's B<consttime_memequal>()), but no such function is specified in "
"POSIX.  On Linux, it may be necessary to implement such a function oneself."
msgstr ""

#. type: Plain text
#: build/C/man3/memcmp.3:97
msgid ""
"B<bcmp>(3), B<bstring>(3), B<strcasecmp>(3), B<strcmp>(3), B<strcoll>(3), "
"B<strncasecmp>(3), B<strncmp>(3), B<wmemcmp>(3)"
msgstr ""

#. type: TH
#: build/C/man3/memcpy.3:31
#, no-wrap
msgid "MEMCPY"
msgstr ""

#. type: Plain text
#: build/C/man3/memcpy.3:34
msgid "memcpy - copy memory area"
msgstr ""

#. type: Plain text
#: build/C/man3/memcpy.3:49
msgid ""
"The B<memcpy>()  function copies I<n> bytes from memory area I<src> to "
"memory area I<dest>.  The memory areas must not overlap.  Use B<memmove>(3)  "
"if the memory areas do overlap."
msgstr ""

#. type: Plain text
#: build/C/man3/memcpy.3:53
msgid "The B<memcpy>()  function returns a pointer to I<dest>."
msgstr ""

#. type: tbl table
#: build/C/man3/memcpy.3:63
#, no-wrap
msgid "B<memcpy>()"
msgstr ""

#.  glibc commit 6fb8cbcb58a29fff73eb2101b34caa19a7f88eba
#.  From forward copying to backward copying
#. type: Plain text
#: build/C/man3/memcpy.3:83
msgid ""
"Failure to observe the requirement that the memory areas do not overlap has "
"been the source of significant bugs.  (POSIX and the C standards are "
"explicit that employing B<memcpy>()  with overlapping areas produces "
"undefined behavior.)  Most notably, in glibc 2.13 a performance optimization "
"of B<memcpy>()  on some platforms (including x86-64) included changing the "
"order in which bytes were copied from I<src> to I<dest>."
msgstr ""

#.  Adobe Flash player was the highest profile example:
#.    https://bugzilla.redhat.com/show_bug.cgi?id=638477
#.    Reported: 2010-09-29 02:35 EDT by JCHuynh
#.    Bug 638477 - Strange sound on mp3 flash website
#
#.    https://sourceware.org/bugzilla/show_bug.cgi?id=12518
#.    Bug 12518 - memcpy acts randomly (and differently) with overlapping areas
#.    Reported:       2011-02-25 02:26 UTC by Linus Torvalds
#
#.  glibc commit 0354e355014b7bfda32622e0255399d859862fcd
#. type: Plain text
#: build/C/man3/memcpy.3:109
msgid ""
"This change revealed breakages in a number of applications that performed "
"copying with overlapping areas.  Under the previous implementation, the "
"order in which the bytes were copied had fortuitously hidden the bug, which "
"was revealed when the copying order was reversed.  In glibc 2.14, a "
"versioned symbol was added so that old binaries (i.e., those linked against "
"glibc versions earlier than 2.14)  employed a B<memcpy>()  implementation "
"that safely handles the overlapping buffers case (by providing an \"older\" "
"B<memcpy>()  implementation that was aliased to B<memmove>(3))."
msgstr ""

#. type: Plain text
#: build/C/man3/memcpy.3:118
msgid ""
"B<bcopy>(3), B<bstring>(3), B<memccpy>(3), B<memmove>(3), B<mempcpy>(3), "
"B<strcpy>(3), B<strncpy>(3), B<wmemcpy>(3)"
msgstr ""

#. type: TH
#: build/C/man3/memfrob.3:30
#, no-wrap
msgid "MEMFROB"
msgstr ""

#. type: Plain text
#: build/C/man3/memfrob.3:33
msgid "memfrob - frobnicate (encrypt) a memory area"
msgstr ""

#. type: Plain text
#: build/C/man3/memfrob.3:37
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>string.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/memfrob.3:50
msgid ""
"The B<memfrob>()  function encrypts the first I<n> bytes of the memory area "
"I<s> by exclusive-ORing each character with the number 42.  The effect can "
"be reversed by using B<memfrob>()  on the encrypted memory area."
msgstr ""

#. type: Plain text
#: build/C/man3/memfrob.3:53
msgid ""
"Note that this function is not a proper encryption routine as the XOR "
"constant is fixed, and is suitable only for hiding strings."
msgstr ""

#. type: Plain text
#: build/C/man3/memfrob.3:58
msgid "The B<memfrob>()  function returns a pointer to the encrypted memory area."
msgstr ""

#. type: tbl table
#: build/C/man3/memfrob.3:68
#, no-wrap
msgid "B<memfrob>()"
msgstr ""

#. type: Plain text
#: build/C/man3/memfrob.3:75
msgid "The B<memfrob>()  function is unique to the GNU C Library."
msgstr ""

#. type: Plain text
#: build/C/man3/memfrob.3:78
msgid "B<bstring>(3), B<strfry>(3)"
msgstr ""

#. type: TH
#: build/C/man3/memmem.3:30
#, no-wrap
msgid "MEMMEM"
msgstr ""

#. type: Plain text
#: build/C/man3/memmem.3:33
msgid "memmem - locate a substring"
msgstr ""

#. type: Plain text
#: build/C/man3/memmem.3:37 build/C/man3/mempcpy.3:17 build/C/man3/strchr.3:46 build/C/man3/strfry.3:37 build/C/man3/strverscmp.3:33
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>string.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/memmem.3:54
msgid ""
"The B<memmem>()  function finds the start of the first occurrence of the "
"substring I<needle> of length I<needlelen> in the memory area I<haystack> of "
"length I<haystacklen>."
msgstr ""

#. type: Plain text
#: build/C/man3/memmem.3:59
msgid ""
"The B<memmem>()  function returns a pointer to the beginning of the "
"substring, or NULL if the substring is not found."
msgstr ""

#. type: tbl table
#: build/C/man3/memmem.3:69
#, no-wrap
msgid "B<memmem>()"
msgstr ""

#. type: Plain text
#: build/C/man3/memmem.3:74
msgid ""
"This function is not specified in POSIX.1, but is present on a number of "
"other systems."
msgstr ""

#. type: SH
#: build/C/man3/memmem.3:74 build/C/man3/stpcpy.3:92 build/C/man3/strcpy.3:222 build/C/man3/strsep.3:105 build/C/man3/strtok.3:200
#, no-wrap
msgid "BUGS"
msgstr ""

#.  This function was broken in Linux libraries up to and including libc 5.0.9;
#.  there the
#.  .IR needle
#.  and
#.  .I haystack
#.  arguments were interchanged,
#.  and a pointer to the end of the first occurrence of
#.  .I needle
#.  was returned.
#
#.  Both old and new libc's have the bug that if
#.  .I needle
#.  is empty,
#.  .I haystack\-1
#.  (instead of
#.  .IR haystack )
#.  is returned.
#. type: Plain text
#: build/C/man3/memmem.3:99
msgid ""
"In glibc 2.0, if I<needle> is empty, B<memmem>()  returns a pointer to the "
"last byte of I<haystack>.  This is fixed in glibc 2.1."
msgstr ""

#. type: Plain text
#: build/C/man3/memmem.3:102
msgid "B<bstring>(3), B<strstr>(3)"
msgstr ""

#. type: TH
#: build/C/man3/memmove.3:30
#, no-wrap
msgid "MEMMOVE"
msgstr ""

#. type: Plain text
#: build/C/man3/memmove.3:33
msgid "memmove - copy memory area"
msgstr ""

#. type: Plain text
#: build/C/man3/memmove.3:57
msgid ""
"The B<memmove>()  function copies I<n> bytes from memory area I<src> to "
"memory area I<dest>.  The memory areas may overlap: copying takes place as "
"though the bytes in I<src> are first copied into a temporary array that does "
"not overlap I<src> or I<dest>, and the bytes are then copied from the "
"temporary array to I<dest>."
msgstr ""

#. type: Plain text
#: build/C/man3/memmove.3:62
msgid "The B<memmove>()  function returns a pointer to I<dest>."
msgstr ""

#. type: tbl table
#: build/C/man3/memmove.3:72
#, no-wrap
msgid "B<memmove>()"
msgstr ""

#. type: Plain text
#: build/C/man3/memmove.3:84
msgid ""
"B<bcopy>(3), B<bstring>(3), B<memccpy>(3), B<memcpy>(3), B<strcpy>(3), "
"B<strncpy>(3), B<wmemmove>(3)"
msgstr ""

#. type: TH
#: build/C/man3/mempcpy.3:10
#, no-wrap
msgid "MEMPCPY"
msgstr ""

#. type: TH
#: build/C/man3/mempcpy.3:10 build/C/man3/stpcpy.3:25 build/C/man3/strverscmp.3:26
#, no-wrap
msgid "2020-06-09"
msgstr ""

#. type: Plain text
#: build/C/man3/mempcpy.3:13
msgid "mempcpy, wmempcpy - copy memory area"
msgstr ""

#. type: Plain text
#: build/C/man3/mempcpy.3:19
#, no-wrap
msgid "B<void *mempcpy(void *>I<dest>B<, const void *>I<src>B<, size_t >I<n>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mempcpy.3:22
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>wchar.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mempcpy.3:24
#, no-wrap
msgid ""
"B<wchar_t *wmempcpy(wchar_t *>I<dest>B<, const wchar_t *>I<src>B<, size_t "
">I<n>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mempcpy.3:40
msgid ""
"The B<mempcpy>()  function is nearly identical to the B<memcpy>(3)  "
"function.  It copies I<n> bytes from the object beginning at I<src> into the "
"object pointed to by I<dest>.  But instead of returning the value of I<dest> "
"it returns a pointer to the byte following the last written byte."
msgstr ""

#. type: Plain text
#: build/C/man3/mempcpy.3:43
msgid ""
"This function is useful in situations where a number of objects shall be "
"copied to consecutive memory positions."
msgstr ""

#. type: Plain text
#: build/C/man3/mempcpy.3:51
msgid ""
"The B<wmempcpy>()  function is identical but takes I<wchar_t> type arguments "
"and copies I<n> wide characters."
msgstr ""

#. type: Plain text
#: build/C/man3/mempcpy.3:55
msgid "I<dest> + I<n>."
msgstr ""

#. type: Plain text
#: build/C/man3/mempcpy.3:58
msgid "B<mempcpy>()  first appeared in glibc in version 2.1."
msgstr ""

#. type: tbl table
#: build/C/man3/mempcpy.3:69
#, no-wrap
msgid ""
"B<mempcpy>(),\n"
"B<wmempcpy>()"
msgstr ""

#. type: Plain text
#: build/C/man3/mempcpy.3:73 build/C/man3/strverscmp.3:114
msgid "This function is a GNU extension."
msgstr ""

#. type: SH
#: build/C/man3/mempcpy.3:73 build/C/man3/stpcpy.3:95 build/C/man3/strcat.3:183 build/C/man3/strcmp.3:129 build/C/man3/strtok.3:216 build/C/man3/strverscmp.3:114
#, no-wrap
msgid "EXAMPLES"
msgstr ""

#. type: Plain text
#: build/C/man3/mempcpy.3:83
#, no-wrap
msgid ""
"void *\n"
"combine(void *o1, size_t s1, void *o2, size_t s2)\n"
"{\n"
"    void *result = malloc(s1 + s2);\n"
"    if (result != NULL)\n"
"        mempcpy(mempcpy(result, o1, s1), o2, s2);\n"
"    return result;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mempcpy.3:89
msgid "B<memccpy>(3), B<memcpy>(3), B<memmove>(3), B<wmemcpy>(3)"
msgstr ""

#. type: TH
#: build/C/man3/memset.3:30
#, no-wrap
msgid "MEMSET"
msgstr ""

#. type: Plain text
#: build/C/man3/memset.3:33
msgid "memset - fill memory with a constant byte"
msgstr ""

#. type: Plain text
#: build/C/man3/memset.3:49
msgid ""
"The B<memset>()  function fills the first I<n> bytes of the memory area "
"pointed to by I<s> with the constant byte I<c>."
msgstr ""

#. type: Plain text
#: build/C/man3/memset.3:54
msgid "The B<memset>()  function returns a pointer to the memory area I<s>."
msgstr ""

#. type: tbl table
#: build/C/man3/memset.3:64
#, no-wrap
msgid "B<memset>()"
msgstr ""

#. type: Plain text
#: build/C/man3/memset.3:73
msgid "B<bstring>(3), B<bzero>(3), B<swab>(3), B<wmemset>(3)"
msgstr ""

#. type: TH
#: build/C/man3/stpcpy.3:25
#, no-wrap
msgid "STPCPY"
msgstr ""

#. type: Plain text
#: build/C/man3/stpcpy.3:28
msgid "stpcpy - copy a string returning a pointer to its end"
msgstr ""

#. type: Plain text
#: build/C/man3/stpcpy.3:33
#, no-wrap
msgid "B<char *stpcpy(char *>I<dest>B<, const char *>I<src>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/stpcpy.3:41
msgid "B<stpcpy>():"
msgstr ""

#. type: TP
#: build/C/man3/stpcpy.3:44 build/C/man3/stpncpy.3:33 build/C/man3/strdup.3:62 build/C/man3/strnlen.3:32
#, no-wrap
msgid "Since glibc 2.10:"
msgstr ""

#. type: Plain text
#: build/C/man3/stpcpy.3:47 build/C/man3/stpncpy.3:36 build/C/man3/strdup.3:65 build/C/man3/strnlen.3:35 build/C/man3/strsignal.3:64
msgid "_POSIX_C_SOURCE\\ E<gt>=\\ 200809L"
msgstr ""

#. type: TP
#: build/C/man3/stpcpy.3:47 build/C/man3/stpncpy.3:36 build/C/man3/strdup.3:65 build/C/man3/strnlen.3:35 build/C/man3/strsignal.3:64
#, no-wrap
msgid "Before glibc 2.10:"
msgstr ""

#. type: Plain text
#: build/C/man3/stpcpy.3:50 build/C/man3/stpncpy.3:39 build/C/man3/strdup.3:68 build/C/man3/strnlen.3:38 build/C/man3/strsignal.3:55 build/C/man3/strsignal.3:67
#, no-wrap
msgid "_GNU_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man3/stpcpy.3:63
msgid ""
"The B<stpcpy>()  function copies the string pointed to by I<src> (including "
"the terminating null byte (\\(aq\\e0\\(aq)) to the array pointed to by "
"I<dest>.  The strings may not overlap, and the destination string I<dest> "
"must be large enough to receive the copy."
msgstr ""

#. type: Plain text
#: build/C/man3/stpcpy.3:71
msgid ""
"B<stpcpy>()  returns a pointer to the B<end> of the string I<dest> (that is, "
"the address of the terminating null byte)  rather than the beginning."
msgstr ""

#. type: tbl table
#: build/C/man3/stpcpy.3:81
#, no-wrap
msgid "B<stpcpy>()"
msgstr ""

#. type: Plain text
#: build/C/man3/stpcpy.3:92
msgid ""
"This function was added to POSIX.1-2008.  Before that, it was not part of "
"the C or POSIX.1 standards, nor customary on UNIX systems.  It first "
"appeared at least as early as 1986, in the Lattice C AmigaDOS compiler, then "
"in the GNU fileutils and GNU textutils in 1989, and in the GNU C library by "
"1992.  It is also present on the BSDs."
msgstr ""

#. type: Plain text
#: build/C/man3/stpcpy.3:95
msgid "This function may overrun the buffer I<dest>."
msgstr ""

#. type: Plain text
#: build/C/man3/stpcpy.3:105
msgid ""
"For example, this program uses B<stpcpy>()  to concatenate B<foo> and B<bar> "
"to produce B<foobar>, which it then prints."
msgstr ""

#. type: Plain text
#: build/C/man3/stpcpy.3:110
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/stpcpy.3:116
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    char buffer[20];\n"
"    char *to = buffer;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/stpcpy.3:121
#, no-wrap
msgid ""
"    to = stpcpy(to, \"foo\");\n"
"    to = stpcpy(to, \"bar\");\n"
"    printf(\"%s\\en\", buffer);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/stpcpy.3:131
msgid ""
"B<bcopy>(3), B<memccpy>(3), B<memcpy>(3), B<memmove>(3), B<stpncpy>(3), "
"B<strcpy>(3), B<string>(3), B<wcpcpy>(3)"
msgstr ""

#. type: TH
#: build/C/man3/stpncpy.3:14
#, no-wrap
msgid "STPNCPY"
msgstr ""

#. type: Plain text
#: build/C/man3/stpncpy.3:17
msgid "stpncpy - copy a fixed-size string, returning a pointer to its end"
msgstr ""

#. type: Plain text
#: build/C/man3/stpncpy.3:22
#, no-wrap
msgid "B<char *stpncpy(char *>I<dest>B<, const char *>I<src>B<, size_t >I<n>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/stpncpy.3:30
msgid "B<stpncpy>():"
msgstr ""

#. type: Plain text
#: build/C/man3/stpncpy.3:74
msgid ""
"The B<stpncpy>()  function copies at most I<n> characters from the string "
"pointed to by I<src>, including the terminating null byte (\\(aq\\e0\\(aq), "
"to the array pointed to by I<dest>.  Exactly I<n> characters are written at "
"I<dest>.  If the length I<strlen(src)> is smaller than I<n>, the remaining "
"characters in the array pointed to by I<dest> are filled with null bytes "
"(\\(aq\\e0\\(aq), If the length I<strlen(src)> is greater than or equal to "
"I<n>, the string pointed to by I<dest> will not be null-terminated."
msgstr ""

#. type: Plain text
#: build/C/man3/stpncpy.3:76
msgid "The strings may not overlap."
msgstr ""

#. type: Plain text
#: build/C/man3/stpncpy.3:82
msgid ""
"The programmer must ensure that there is room for at least I<n> characters "
"at I<dest>."
msgstr ""

#. type: Plain text
#: build/C/man3/stpncpy.3:91
msgid ""
"B<stpncpy>()  returns a pointer to the terminating null byte in I<dest>, or, "
"if I<dest> is not null-terminated, I<dest>+I<n>."
msgstr ""

#. type: tbl table
#: build/C/man3/stpncpy.3:101
#, no-wrap
msgid "B<stpncpy>()"
msgstr ""

#. type: Plain text
#: build/C/man3/stpncpy.3:107
msgid ""
"This function was added to POSIX.1-2008.  Before that, it was a GNU "
"extension.  It first appeared in version 1.07 of the GNU C library in 1993."
msgstr ""

#. type: Plain text
#: build/C/man3/stpncpy.3:110
msgid "B<strncpy>(3), B<wcpncpy>(3)"
msgstr ""

#. type: TH
#: build/C/man3/strcasecmp.3:30
#, no-wrap
msgid "STRCASECMP"
msgstr ""

#. type: Plain text
#: build/C/man3/strcasecmp.3:33
msgid "strcasecmp, strncasecmp - compare two strings ignoring case"
msgstr ""

#. type: Plain text
#: build/C/man3/strcasecmp.3:38
#, no-wrap
msgid "B<int strcasecmp(const char *>I<s1>B<, const char *>I<s2>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strcasecmp.3:40
#, no-wrap
msgid ""
"B<int strncasecmp(const char *>I<s1>B<, const char *>I<s2>B<, size_t "
">I<n>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strcasecmp.3:55
msgid ""
"The B<strcasecmp>()  function performs a byte-by-byte comparison of the "
"strings I<s1> and I<s2>, ignoring the case of the characters.  It returns an "
"integer less than, equal to, or greater than zero if I<s1> is found, "
"respectively, to be less than, to match, or be greater than I<s2>."
msgstr ""

#. type: Plain text
#: build/C/man3/strcasecmp.3:65
msgid ""
"The B<strncasecmp>()  function is similar, except that it compares no more "
"than I<n> bytes of I<s1> and I<s2>."
msgstr ""

#. type: Plain text
#: build/C/man3/strcasecmp.3:77
msgid ""
"The B<strcasecmp>()  and B<strncasecmp>()  functions return an integer less "
"than, equal to, or greater than zero if I<s1> is, after ignoring case, found "
"to be less than, to match, or be greater than I<s2>, respectively."
msgstr ""

#. type: tbl table
#: build/C/man3/strcasecmp.3:88
#, no-wrap
msgid ""
"B<strcasecmp>(),\n"
"B<strncasecmp>()"
msgstr ""

#. type: tbl table
#: build/C/man3/strcasecmp.3:88 build/C/man3/strcoll.3:79 build/C/man3/strstr.3:78 build/C/man3/strxfrm.3:86
#, no-wrap
msgid "MT-Safe locale"
msgstr ""

#. type: Plain text
#: build/C/man3/strcasecmp.3:92
msgid "4.4BSD, POSIX.1-2001, POSIX.1-2008."
msgstr ""

#. type: Plain text
#: build/C/man3/strcasecmp.3:106
msgid ""
"The B<strcasecmp>()  and B<strncasecmp>()  functions first appeared in "
"4.4BSD, where they were declared in I<E<lt>string.hE<gt>>.  Thus, for "
"reasons of historical compatibility, the glibc I<E<lt>string.hE<gt>> header "
"file also declares these functions, if the B<_DEFAULT_SOURCE> (or, in glibc "
"2.19 and earlier, B<_BSD_SOURCE>)  feature test macro is defined."
msgstr ""

#. type: Plain text
#: build/C/man3/strcasecmp.3:108
msgid "The POSIX.1-2008 standard says of these functions:"
msgstr ""

#. type: Plain text
#: build/C/man3/strcasecmp.3:116
msgid ""
"When the B<LC_CTYPE> category of the locale being used is from the POSIX "
"locale, these functions shall behave as if the strings had been converted to "
"lowercase and then a byte comparison performed.  Otherwise, the results are "
"unspecified."
msgstr ""

#. type: Plain text
#: build/C/man3/strcasecmp.3:126
msgid ""
"B<bcmp>(3), B<memcmp>(3), B<strcmp>(3), B<strcoll>(3), B<string>(3), "
"B<strncmp>(3), B<wcscasecmp>(3), B<wcsncasecmp>(3)"
msgstr ""

#. type: TH
#: build/C/man3/strcat.3:32
#, no-wrap
msgid "STRCAT"
msgstr ""

#. type: Plain text
#: build/C/man3/strcat.3:35
msgid "strcat, strncat - concatenate two strings"
msgstr ""

#. type: Plain text
#: build/C/man3/strcat.3:40
#, no-wrap
msgid "B<char *strcat(char *>I<dest>B<, const char *>I<src>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strcat.3:42
#, no-wrap
msgid "B<char *strncat(char *>I<dest>B<, const char *>I<src>B<, size_t >I<n>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strcat.3:62
msgid ""
"The B<strcat>()  function appends the I<src> string to the I<dest> string, "
"overwriting the terminating null byte (\\(aq\\e0\\(aq) at the end of "
"I<dest>, and then adds a terminating null byte.  The strings may not "
"overlap, and the I<dest> string must have enough space for the result.  If "
"I<dest> is not large enough, program behavior is unpredictable; I<buffer "
"overruns are a favorite avenue for attacking secure programs>."
msgstr ""

#. type: Plain text
#: build/C/man3/strcat.3:66
msgid "The B<strncat>()  function is similar, except that"
msgstr ""

#. type: IP
#: build/C/man3/strcat.3:66 build/C/man3/strcat.3:72 build/C/man3/strsep.3:108 build/C/man3/strsep.3:110 build/C/man3/strsep.3:112 build/C/man3/strtok.3:203 build/C/man3/strtok.3:205 build/C/man3/strtok.3:207 build/C/man3/strtok.3:209
#, no-wrap
msgid "*"
msgstr ""

#. type: Plain text
#: build/C/man3/strcat.3:72
msgid "it will use at most I<n> bytes from I<src>; and"
msgstr ""

#. type: Plain text
#: build/C/man3/strcat.3:77
msgid ""
"I<src> does not need to be null-terminated if it contains I<n> or more "
"bytes."
msgstr ""

#. type: Plain text
#: build/C/man3/strcat.3:83
msgid ""
"As with B<strcat>(), the resulting string in I<dest> is always "
"null-terminated."
msgstr ""

#. type: Plain text
#: build/C/man3/strcat.3:102
msgid ""
"If I<src> contains I<n> or more bytes, B<strncat>()  writes I<n+1> bytes to "
"I<dest> (I<n> from I<src> plus the terminating null byte).  Therefore, the "
"size of I<dest> must be at least I<strlen(dest)+n+1>."
msgstr ""

#. type: Plain text
#: build/C/man3/strcat.3:106
msgid "A simple implementation of B<strncat>()  might be:"
msgstr ""

#. type: Plain text
#: build/C/man3/strcat.3:114
#, no-wrap
msgid ""
"char *\n"
"strncat(char *dest, const char *src, size_t n)\n"
"{\n"
"    size_t dest_len = strlen(dest);\n"
"    size_t i;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strcat.3:118
#, no-wrap
msgid ""
"    for (i = 0 ; i E<lt> n && src[i] != \\(aq\\e0\\(aq ; i++)\n"
"        dest[dest_len + i] = src[i];\n"
"    dest[dest_len + i] = \\(aq\\e0\\(aq;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strcat.3:121 build/C/man3/strcpy.3:106
#, no-wrap
msgid ""
"    return dest;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strcat.3:130
msgid ""
"The B<strcat>()  and B<strncat>()  functions return a pointer to the "
"resulting string I<dest>."
msgstr ""

#. type: tbl table
#: build/C/man3/strcat.3:141
#, no-wrap
msgid ""
"B<strcat>(),\n"
"B<strncat>()"
msgstr ""

#. type: Plain text
#: build/C/man3/strcat.3:147 build/C/man3/strcpy.3:185
msgid "Some systems (the BSDs, Solaris, and others) provide the following function:"
msgstr ""

#. type: Plain text
#: build/C/man3/strcat.3:149
#, no-wrap
msgid "    size_t strlcat(char *dest, const char *src, size_t size);\n"
msgstr ""

#.  https://lwn.net/Articles/506530/
#. type: Plain text
#: build/C/man3/strcat.3:183
msgid ""
"This function appends the null-terminated string I<src> to the string "
"I<dest>, copying at most I<size-strlen(dest)-1> from I<src>, and adds a "
"terminating null byte to the result, I<unless> I<size> is less than "
"I<strlen(dest)>.  This function fixes the buffer overrun problem of "
"B<strcat>(), but the caller must still handle the possibility of data loss "
"if I<size> is too small.  The function returns the length of the string "
"B<strlcat>()  tried to create; if the return value is greater than or equal "
"to I<size>, data loss occurred.  If data loss matters, the caller I<must> "
"either check the arguments before the call, or test the function return "
"value.  B<strlcat>()  is not present in glibc and is not standardized by "
"POSIX, but is available on Linux via the I<libbsd> library."
msgstr ""

#. type: Plain text
#: build/C/man3/strcat.3:200
msgid ""
"Because B<strcat>()  and B<strncat>()  must find the null byte that "
"terminates the string I<dest> using a search that starts at the beginning of "
"the string, the execution time of these functions scales according to the "
"length of the string I<dest>.  This can be demonstrated by running the "
"program below.  (If the goal is to concatenate many strings to one target, "
"then manually copying the bytes from each source string while maintaining a "
"pointer to the end of the target string will provide better performance.)"
msgstr ""

#. type: SS
#: build/C/man3/strcat.3:200 build/C/man3/strcmp.3:170 build/C/man3/strtok.3:241 build/C/man3/strverscmp.3:128
#, no-wrap
msgid "Program source"
msgstr ""

#. type: Plain text
#: build/C/man3/strcat.3:207
#, no-wrap
msgid ""
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strcat.3:214
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"#define LIM 4000000\n"
"    char p[LIM + 1];    /* +1 for terminating null byte */\n"
"    time_t base;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strcat.3:217
#, no-wrap
msgid ""
"    base = time(NULL);\n"
"    p[0] = \\(aq\\e0\\(aq;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strcat.3:224
#, no-wrap
msgid ""
"    for (int j = 0; j E<lt> LIM; j++) {\n"
"        if ((j % 10000) == 0)\n"
"            printf(\"%d %jd\\en\", j, (intmax_t) (time(NULL) - base));\n"
"        strcat(p, \"a\");\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strcat.3:235
msgid ""
"B<bcopy>(3), B<memccpy>(3), B<memcpy>(3), B<strcpy>(3), B<string>(3), "
"B<strncpy>(3), B<wcscat>(3), B<wcsncat>(3)"
msgstr ""

#. type: TH
#: build/C/man3/strchr.3:33
#, no-wrap
msgid "STRCHR"
msgstr ""

#. type: Plain text
#: build/C/man3/strchr.3:36
msgid "strchr, strrchr, strchrnul - locate character in string"
msgstr ""

#. type: Plain text
#: build/C/man3/strchr.3:41
#, no-wrap
msgid "B<char *strchr(const char *>I<s>B<, int >I<c>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strchr.3:43
#, no-wrap
msgid "B<char *strrchr(const char *>I<s>B<, int >I<c>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strchr.3:48
#, no-wrap
msgid "B<char *strchrnul(const char *>I<s>B<, int >I<c>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strchr.3:57
msgid ""
"The B<strchr>()  function returns a pointer to the first occurrence of the "
"character I<c> in the string I<s>."
msgstr ""

#. type: Plain text
#: build/C/man3/strchr.3:65
msgid ""
"The B<strrchr>()  function returns a pointer to the last occurrence of the "
"character I<c> in the string I<s>."
msgstr ""

#. type: Plain text
#: build/C/man3/strchr.3:78
msgid ""
"The B<strchrnul>()  function is like B<strchr>()  except that if I<c> is not "
"found in I<s>, then it returns a pointer to the null byte at the end of "
"I<s>, rather than NULL."
msgstr ""

#. type: Plain text
#: build/C/man3/strchr.3:81
msgid ""
"Here \"character\" means \"byte\"; these functions do not work with wide or "
"multibyte characters."
msgstr ""

#. type: Plain text
#: build/C/man3/strchr.3:93
msgid ""
"The B<strchr>()  and B<strrchr>()  functions return a pointer to the matched "
"character or NULL if the character is not found.  The terminating null byte "
"is considered part of the string, so that if I<c> is specified as "
"\\(aq\\e0\\(aq, these functions return a pointer to the terminator."
msgstr ""

#. type: Plain text
#: build/C/man3/strchr.3:102
msgid ""
"The B<strchrnul>()  function returns a pointer to the matched character, or "
"a pointer to the null byte at the end of I<s> (i.e., I<s+strlen(s)>)  if the "
"character is not found."
msgstr ""

#. type: Plain text
#: build/C/man3/strchr.3:105
msgid "B<strchrnul>()  first appeared in glibc in version 2.1.1."
msgstr ""

#. type: tbl table
#: build/C/man3/strchr.3:117
#, no-wrap
msgid ""
"B<strchr>(),\n"
"B<strrchr>(),\n"
"B<strchrnul>()"
msgstr ""

#. type: Plain text
#: build/C/man3/strchr.3:123
msgid ""
"B<strchr>(), B<strrchr>(): POSIX.1-2001, POSIX.1-2008, C89, C99, SVr4, "
"4.3BSD."
msgstr ""

#. type: Plain text
#: build/C/man3/strchr.3:126
msgid "B<strchrnul>()  is a GNU extension."
msgstr ""

#. type: Plain text
#: build/C/man3/strchr.3:139
msgid ""
"B<index>(3), B<memchr>(3), B<rindex>(3), B<string>(3), B<strlen>(3), "
"B<strpbrk>(3), B<strsep>(3), B<strspn>(3), B<strstr>(3), B<strtok>(3), "
"B<wcschr>(3), B<wcsrchr>(3)"
msgstr ""

#. type: TH
#: build/C/man3/strcmp.3:33
#, no-wrap
msgid "STRCMP"
msgstr ""

#. type: TH
#: build/C/man3/strcmp.3:33
#, no-wrap
msgid "2020-04-11"
msgstr ""

#. type: Plain text
#: build/C/man3/strcmp.3:36
msgid "strcmp, strncmp - compare two strings"
msgstr ""

#. type: Plain text
#: build/C/man3/strcmp.3:41
#, no-wrap
msgid "B<int strcmp(const char *>I<s1>B<, const char *>I<s2>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strcmp.3:43
#, no-wrap
msgid ""
"B<int strncmp(const char *>I<s1>B<, const char *>I<s2>B<, size_t "
">I<n>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strcmp.3:54
msgid ""
"The B<strcmp>()  function compares the two strings I<s1> and I<s2>.  The "
"locale is not taken into account (for a locale-aware comparison, see "
"B<strcoll>(3)).  The comparison is done using unsigned characters."
msgstr ""

#. type: Plain text
#: build/C/man3/strcmp.3:57
msgid ""
"B<strcmp>()  returns an integer indicating the result of the comparison, as "
"follows:"
msgstr ""

#. type: IP
#: build/C/man3/strcmp.3:57 build/C/man3/strcmp.3:63 build/C/man3/strcmp.3:68
#, no-wrap
msgid "\\(bu"
msgstr ""

#. type: Plain text
#: build/C/man3/strcmp.3:63
msgid "0, if the I<s1> and I<s2> are equal;"
msgstr ""

#. type: Plain text
#: build/C/man3/strcmp.3:68
msgid "a negative value if I<s1> is less than I<s2>;"
msgstr ""

#. type: Plain text
#: build/C/man3/strcmp.3:73
msgid "a positive value if I<s1> is greater than I<s2>."
msgstr ""

#. type: Plain text
#: build/C/man3/strcmp.3:83
msgid ""
"The B<strncmp>()  function is similar, except it compares only the first (at "
"most)  I<n> bytes of I<s1> and I<s2>."
msgstr ""

#. type: Plain text
#: build/C/man3/strcmp.3:96
msgid ""
"The B<strcmp>()  and B<strncmp>()  functions return an integer less than, "
"equal to, or greater than zero if I<s1> (or the first I<n> bytes thereof) is "
"found, respectively, to be less than, to match, or be greater than I<s2>."
msgstr ""

#. type: tbl table
#: build/C/man3/strcmp.3:107
#, no-wrap
msgid ""
"B<strcmp>(),\n"
"B<strncmp>()"
msgstr ""

#. type: Plain text
#: build/C/man3/strcmp.3:113
msgid "POSIX.1 specifies only that:"
msgstr ""

#. type: Plain text
#: build/C/man3/strcmp.3:120
msgid ""
"The sign of a nonzero return value shall be determined by the sign of the "
"difference between the values of the first pair of bytes (both interpreted "
"as type I<unsigned char>)  that differ in the strings being compared."
msgstr ""

#. type: Plain text
#: build/C/man3/strcmp.3:129
msgid ""
"In glibc, as in most other implementations, the return value is the "
"arithmetic result of subtracting the last compared byte in I<s2> from the "
"last compared byte in I<s1>.  (If the two characters are equal, this "
"difference is 0.)"
msgstr ""

#. type: Plain text
#: build/C/man3/strcmp.3:137
msgid ""
"The program below can be used to demonstrate the operation of B<strcmp>()  "
"(when given two arguments) and B<strncmp>()  (when given three arguments).  "
"First, some examples using B<strcmp>():"
msgstr ""

#. type: Plain text
#: build/C/man3/strcmp.3:150
#, no-wrap
msgid ""
"$ B<./string_comp ABC ABC>\n"
"E<lt>str1E<gt> and E<lt>str2E<gt> are equal\n"
"$ B<./string_comp ABC AB>      # \\(aqC\\(aq is ASCII 67; \\(aqC\\(aq - "
"\\(aq\\0\\(aq = 67\n"
"E<lt>str1E<gt> is greater than E<lt>str2E<gt> (67)\n"
"$ B<./string_comp ABA ABZ>     # \\(aqA\\(aq is ASCII 65; \\(aqZ\\(aq is "
"ASCII 90\n"
"E<lt>str1E<gt> is less than E<lt>str2E<gt> (-25)\n"
"$ B<./string_comp ABJ ABC>\n"
"E<lt>str1E<gt> is greater than E<lt>str2E<gt> (7)\n"
"$ .B</string_comp $\\(aq\\e201\\(aq A>   # 0201 - 0101 = 0100 (or 64 "
"decimal)\n"
"E<lt>str1E<gt> is greater than E<lt>str2E<gt> (64)\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strcmp.3:158
msgid ""
"The last example uses B<bash>(1)-specific syntax to produce a string "
"containing an 8-bit ASCII code; the result demonstrates that the string "
"comparison uses unsigned characters."
msgstr ""

#. type: Plain text
#: build/C/man3/strcmp.3:161
msgid "And then some examples using B<strncmp>():"
msgstr ""

#. type: Plain text
#: build/C/man3/strcmp.3:168
#, no-wrap
msgid ""
"$ B<./string_comp ABC AB 3>\n"
"E<lt>str1E<gt> is greater than E<lt>str2E<gt> (67)\n"
"$ B<./string_comp ABC AB 2>\n"
"E<lt>str1E<gt> and E<lt>str2E<gt> are equal in the first 2 bytes\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strcmp.3:174
#, no-wrap
msgid "/* string_comp.c\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strcmp.3:180
#, no-wrap
msgid ""
"   Licensed under GNU General Public License v2 or later.\n"
"*/\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strcmp.3:185 build/C/man3/strverscmp.3:140
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int res;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strcmp.3:190
#, no-wrap
msgid ""
"    if (argc E<lt> 3) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>str1E<gt> E<lt>str2E<gt> "
"[E<lt>lenE<gt>]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strcmp.3:195
#, no-wrap
msgid ""
"    if (argc == 3)\n"
"        res = strcmp(argv[1], argv[2]);\n"
"    else\n"
"        res = strncmp(argv[1], argv[2], atoi(argv[3]));\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strcmp.3:206
#, no-wrap
msgid ""
"    if (res == 0) {\n"
"        printf(\"E<lt>str1E<gt> and E<lt>str2E<gt> are equal\");\n"
"        if (argc E<gt> 3)\n"
"            printf(\" in the first %d bytes\\en\", atoi(argv[3]));\n"
"        printf(\"\\en\");\n"
"    } else if (res E<lt> 0) {\n"
"        printf(\"E<lt>str1E<gt> is less than E<lt>str2E<gt> (%d)\\en\", "
"res);\n"
"    } else {\n"
"        printf(\"E<lt>str1E<gt> is greater than E<lt>str2E<gt> (%d)\\en\", "
"res);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strcmp.3:209 build/C/man3/strtok.3:276 build/C/man3/strverscmp.3:153
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strcmp.3:221
msgid ""
"B<bcmp>(3), B<memcmp>(3), B<strcasecmp>(3), B<strcoll>(3), B<string>(3), "
"B<strncasecmp>(3), B<strverscmp>(3), B<wcscmp>(3), B<wcsncmp>(3), "
"B<ascii>(7)"
msgstr ""

#. type: TH
#: build/C/man3/strcoll.3:30
#, no-wrap
msgid "STRCOLL"
msgstr ""

#. type: Plain text
#: build/C/man3/strcoll.3:33
msgid "strcoll - compare two strings using the current locale"
msgstr ""

#. type: Plain text
#: build/C/man3/strcoll.3:38
#, no-wrap
msgid "B<int strcoll(const char *>I<s1>B<, const char *>I<s2>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strcoll.3:58
msgid ""
"The B<strcoll>()  function compares the two strings I<s1> and I<s2>.  It "
"returns an integer less than, equal to, or greater than zero if I<s1> is "
"found, respectively, to be less than, to match, or be greater than I<s2>.  "
"The comparison is based on strings interpreted as appropriate for the "
"program's current locale for category B<LC_COLLATE>.  (See B<setlocale>(3).)"
msgstr ""

#. type: Plain text
#: build/C/man3/strcoll.3:69
msgid ""
"The B<strcoll>()  function returns an integer less than, equal to, or "
"greater than zero if I<s1> is found, respectively, to be less than, to "
"match, or be greater than I<s2>, when both are interpreted as appropriate "
"for the current locale."
msgstr ""

#. type: tbl table
#: build/C/man3/strcoll.3:79
#, no-wrap
msgid "B<strcoll>()"
msgstr ""

#. type: Plain text
#: build/C/man3/strcoll.3:93
msgid "In the I<POSIX> or I<C> locales B<strcoll>()  is equivalent to B<strcmp>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/strcoll.3:101
msgid ""
"B<bcmp>(3), B<memcmp>(3), B<setlocale>(3), B<strcasecmp>(3), B<strcmp>(3), "
"B<string>(3), B<strxfrm>(3)"
msgstr ""

#. type: TH
#: build/C/man3/strcpy.3:35
#, no-wrap
msgid "STRCPY"
msgstr ""

#. type: Plain text
#: build/C/man3/strcpy.3:38
msgid "strcpy, strncpy - copy a string"
msgstr ""

#. type: Plain text
#: build/C/man3/strcpy.3:43
#, no-wrap
msgid "B<char *strcpy(char *>I<dest>B<, const char *>I<src>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strcpy.3:45
#, no-wrap
msgid "B<char *strncpy(char *>I<dest>B<, const char *>I<src>B<, size_t >I<n>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strcpy.3:59
msgid ""
"The B<strcpy>()  function copies the string pointed to by I<src>, including "
"the terminating null byte (\\(aq\\e0\\(aq), to the buffer pointed to by "
"I<dest>.  The strings may not overlap, and the destination string I<dest> "
"must be large enough to receive the copy.  I<Beware of buffer overruns!> "
"(See BUGS.)"
msgstr ""

#. type: Plain text
#: build/C/man3/strcpy.3:76
msgid ""
"The B<strncpy>()  function is similar, except that at most I<n> bytes of "
"I<src> are copied.  B<Warning>: If there is no null byte among the first "
"I<n> bytes of I<src>, the string placed in I<dest> will not be "
"null-terminated."
msgstr ""

#. type: Plain text
#: build/C/man3/strcpy.3:87
msgid ""
"If the length of I<src> is less than I<n>, B<strncpy>()  writes additional "
"null bytes to I<dest> to ensure that a total of I<n> bytes are written."
msgstr ""

#. type: Plain text
#: build/C/man3/strcpy.3:91
msgid "A simple implementation of B<strncpy>()  might be:"
msgstr ""

#. type: Plain text
#: build/C/man3/strcpy.3:98
#, no-wrap
msgid ""
"char *\n"
"strncpy(char *dest, const char *src, size_t n)\n"
"{\n"
"    size_t i;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strcpy.3:103
#, no-wrap
msgid ""
"    for (i = 0; i E<lt> n && src[i] != \\(aq\\e0\\(aq; i++)\n"
"        dest[i] = src[i];\n"
"    for ( ; i E<lt> n; i++)\n"
"        dest[i] = \\(aq\\e0\\(aq;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strcpy.3:116
msgid ""
"The B<strcpy>()  and B<strncpy>()  functions return a pointer to the "
"destination string I<dest>."
msgstr ""

#. type: tbl table
#: build/C/man3/strcpy.3:127
#, no-wrap
msgid ""
"B<strcpy>(),\n"
"B<strncpy>()"
msgstr ""

#. type: Plain text
#: build/C/man3/strcpy.3:144
msgid ""
"Some programmers consider B<strncpy>()  to be inefficient and error prone.  "
"If the programmer knows (i.e., includes code to test!)  that the size of "
"I<dest> is greater than the length of I<src>, then B<strcpy>()  can be used."
msgstr ""

#. type: Plain text
#: build/C/man3/strcpy.3:153
msgid ""
"One valid (and intended) use of B<strncpy>()  is to copy a C string to a "
"fixed-length buffer while ensuring both that the buffer is not overflowed "
"and that unused bytes in the destination buffer are zeroed out (perhaps to "
"prevent information leaks if the buffer is to be written to media or "
"transmitted to another process via an interprocess communication technique)."
msgstr ""

#. type: Plain text
#: build/C/man3/strcpy.3:166
msgid ""
"If there is no terminating null byte in the first I<n> bytes of I<src>, "
"B<strncpy>()  produces an unterminated string in I<dest>.  If I<buf> has "
"length I<buflen>, you can force termination using something like the "
"following:"
msgstr ""

#. type: Plain text
#: build/C/man3/strcpy.3:173
#, no-wrap
msgid ""
"if (buflen E<gt> 0) {\n"
"    strncpy(buf, str, buflen - 1);\n"
"    buf[buflen - 1]= \\(aq\\e0\\(aq;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strcpy.3:183
msgid ""
"(Of course, the above technique ignores the fact that, if I<src> contains "
"more than I<buflen\\ -\\ 1> bytes, information is lost in the copying to "
"I<dest>.)"
msgstr ""

#. type: SS
#: build/C/man3/strcpy.3:183
#, no-wrap
msgid "strlcpy()"
msgstr ""

#. type: Plain text
#: build/C/man3/strcpy.3:187
#, no-wrap
msgid "    size_t strlcpy(char *dest, const char *src, size_t size);\n"
msgstr ""

#.  http://static.usenix.org/event/usenix99/full_papers/millert/millert_html/index.html
#.      "strlcpy and strlcat - consistent, safe, string copy and concatenation"
#.      1999 USENIX Annual Technical Conference
#.  https://lwn.net/Articles/506530/
#. type: Plain text
#: build/C/man3/strcpy.3:222
msgid ""
"This function is similar to B<strncpy>(), but it copies at most I<size-1> "
"bytes to I<dest>, always adds a terminating null byte, and does not pad the "
"destination with (further) null bytes.  This function fixes some of the "
"problems of B<strcpy>()  and B<strncpy>(), but the caller must still handle "
"the possibility of data loss if I<size> is too small.  The return value of "
"the function is the length of I<src>, which allows truncation to be easily "
"detected: if the return value is greater than or equal to I<size>, "
"truncation occurred.  If loss of data matters, the caller I<must> either "
"check the arguments before the call, or test the function return value.  "
"B<strlcpy>()  is not present in glibc and is not standardized by POSIX, but "
"is available on Linux via the I<libbsd> library."
msgstr ""

#. type: Plain text
#: build/C/man3/strcpy.3:233
msgid ""
"If the destination string of a B<strcpy>()  is not large enough, then "
"anything might happen.  Overflowing fixed-length string buffers is a "
"favorite cracker technique for taking complete control of the machine.  Any "
"time a program reads or copies data into a buffer, the program first needs "
"to check that there's enough space.  This may be unnecessary if you can show "
"that overflow is impossible, but be careful: programs can get changed over "
"time, in ways that may make the impossible possible."
msgstr ""

#. type: Plain text
#: build/C/man3/strcpy.3:244
msgid ""
"B<bcopy>(3), B<memccpy>(3), B<memcpy>(3), B<memmove>(3), B<stpcpy>(3), "
"B<stpncpy>(3), B<strdup>(3), B<string>(3), B<wcscpy>(3), B<wcsncpy>(3)"
msgstr ""

#. type: TH
#: build/C/man3/strdup.3:31
#, no-wrap
msgid "STRDUP"
msgstr ""

#. type: Plain text
#: build/C/man3/strdup.3:34
msgid "strdup, strndup, strdupa, strndupa - duplicate a string"
msgstr ""

#. type: Plain text
#: build/C/man3/strdup.3:39
#, no-wrap
msgid "B<char *strdup(const char *>I<s>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strdup.3:43
#, no-wrap
msgid ""
"B<char *strndup(const char *>I<s>B<, size_t >I<n>B<);>\n"
"B<char *strdupa(const char *>I<s>B<);>\n"
"B<char *strndupa(const char *>I<s>B<, size_t >I<n>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strdup.3:53
msgid "B<strdup>():"
msgstr ""

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: build/C/man3/strdup.3:58
#, no-wrap
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* Since glibc 2.12: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strdup.3:61
msgid "B<strndup>():"
msgstr ""

#. type: Plain text
#: build/C/man3/strdup.3:73
msgid "B<strdupa>(), B<strndupa>(): _GNU_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man3/strdup.3:86
msgid ""
"The B<strdup>()  function returns a pointer to a new string which is a "
"duplicate of the string I<s>.  Memory for the new string is obtained with "
"B<malloc>(3), and can be freed with B<free>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/strdup.3:99
msgid ""
"The B<strndup>()  function is similar, but copies at most I<n> bytes.  If "
"I<s> is longer than I<n>, only I<n> bytes are copied, and a terminating null "
"byte (\\(aq\\e0\\(aq) is added."
msgstr ""

#. type: Plain text
#: build/C/man3/strdup.3:109
msgid ""
"B<strdupa>()  and B<strndupa>()  are similar, but use B<alloca>(3)  to "
"allocate the buffer.  They are available only when using the GNU GCC suite, "
"and suffer from the same limitations described in B<alloca>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/strdup.3:117
msgid ""
"On success, the B<strdup>()  function returns a pointer to the duplicated "
"string.  It returns NULL if insufficient memory was available, with I<errno> "
"set to indicate the cause of the error."
msgstr ""

#. type: SH
#: build/C/man3/strdup.3:117 build/C/man3/strerror.3:229
#, no-wrap
msgid "ERRORS"
msgstr ""

#. type: TP
#: build/C/man3/strdup.3:118
#, no-wrap
msgid "B<ENOMEM>"
msgstr ""

#. type: Plain text
#: build/C/man3/strdup.3:121
msgid "Insufficient memory available to allocate duplicate string."
msgstr ""

#. type: tbl table
#: build/C/man3/strdup.3:133
#, no-wrap
msgid ""
"B<strdup>(),\n"
"B<strndup>(),\n"
"B<strdupa>(),\n"
msgstr ""

#. type: tbl table
#: build/C/man3/strdup.3:135
#, no-wrap
msgid "B<strndupa>()"
msgstr ""

#.  4.3BSD-Reno, not (first) 4.3BSD.
#. type: Plain text
#: build/C/man3/strdup.3:148
msgid ""
"B<strdup>()  conforms to SVr4, 4.3BSD, POSIX.1-2001.  B<strndup>()  conforms "
"to POSIX.1-2008.  B<strdupa>()  and B<strndupa>()  are GNU extensions."
msgstr ""

#. type: Plain text
#: build/C/man3/strdup.3:156
msgid ""
"B<alloca>(3), B<calloc>(3), B<free>(3), B<malloc>(3), B<realloc>(3), "
"B<string>(3), B<wcsdup>(3)"
msgstr ""

#. type: TH
#: build/C/man3/strerror.3:39
#, no-wrap
msgid "STRERROR"
msgstr ""

#. type: Plain text
#: build/C/man3/strerror.3:42
msgid ""
"strerror, strerrorname_np, strerrordesc_np, strerror_r, strerror_l - return "
"string describing error number"
msgstr ""

#. type: Plain text
#: build/C/man3/strerror.3:49
#, no-wrap
msgid ""
"B<char *strerror(int >I<errnum>B<);>\n"
"B<const char *strerrorname_np(int >I<errnum>B<);>\n"
"B<const char *strerrordesc_np(int >I<errnum>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strerror.3:52
#, no-wrap
msgid ""
"B<int strerror_r(int >I<errnum>B<, char *>I<buf>B<, size_t >I<buflen>B<);>\n"
"            /* XSI-compliant */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strerror.3:55
#, no-wrap
msgid ""
"B<char *strerror_r(int >I<errnum>B<, char *>I<buf>B<, size_t "
">I<buflen>B<);>\n"
"            /* GNU-specific */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strerror.3:57
#, no-wrap
msgid "B<char *strerror_l(int >I<errnum>B<, locale_t >I<locale>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strerror.3:69
#, no-wrap
msgid ""
"B<strerrorname_np>(),\n"
"B<strerrordesc_np>():\n"
"    _GNU_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strerror.3:71
msgid "B<strerror_r>():"
msgstr ""

#. type: Plain text
#: build/C/man3/strerror.3:73
msgid "The XSI-compliant version is provided if:"
msgstr ""

#. type: Plain text
#: build/C/man3/strerror.3:75
msgid "(_POSIX_C_SOURCE\\ E<gt>=\\ 200112L) && ! \\ _GNU_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man3/strerror.3:77
msgid "Otherwise, the GNU-specific version is provided."
msgstr ""

#. type: Plain text
#: build/C/man3/strerror.3:102
msgid ""
"The B<strerror>()  function returns a pointer to a string that describes the "
"error code passed in the argument I<errnum>, possibly using the "
"B<LC_MESSAGES> part of the current locale to select the appropriate "
"language.  (For example, if I<errnum> is B<EINVAL>, the returned description "
"will be \"Invalid argument\".)  This string must not be modified by the "
"application, but may be modified by a subsequent call to B<strerror>()  or "
"B<strerror_l>().  No other library function, including B<perror>(3), will "
"modify this string."
msgstr ""

#. type: Plain text
#: build/C/man3/strerror.3:112
msgid ""
"Like B<strerror>(), the B<strerrordesc_np>()  function returns a pointer to "
"a string that describes the error code passed in the argument I<errnum>, "
"with the difference that the returned string is not translated according to "
"the current locale."
msgstr ""

#. type: Plain text
#: build/C/man3/strerror.3:122
msgid ""
"The B<strerrorname_np>()  function returns a pointer to a string containing "
"the name of the error code passed in the argument I<errnum>.  For example, "
"given B<EPERM> as an argument, this function returns a pointer to the string "
"\"EPERM\"."
msgstr ""

#. type: SS
#: build/C/man3/strerror.3:122
#, no-wrap
msgid "strerror_r()"
msgstr ""

#. type: Plain text
#: build/C/man3/strerror.3:143
msgid ""
"The B<strerror_r>()  function is similar to B<strerror>(), but is thread "
"safe.  This function is available in two versions: an XSI-compliant version "
"specified in POSIX.1-2001 (available since glibc 2.3.4, but not "
"POSIX-compliant until glibc 2.13), and a GNU-specific version (available "
"since glibc 2.0).  The XSI-compliant version is provided with the feature "
"test macros settings shown in the SYNOPSIS; otherwise the GNU-specific "
"version is provided.  If no feature test macros are explicitly defined, then "
"(since glibc 2.4)  B<_POSIX_C_SOURCE> is defined by default with the value "
"200112L, so that the XSI-compliant version of B<strerror_r>()  is provided "
"by default."
msgstr ""

#. type: Plain text
#: build/C/man3/strerror.3:151
msgid ""
"The XSI-compliant B<strerror_r>()  is preferred for portable applications.  "
"It returns the error string in the user-supplied buffer I<buf> of length "
"I<buflen>."
msgstr ""

#. type: Plain text
#: build/C/man3/strerror.3:172
msgid ""
"The GNU-specific B<strerror_r>()  returns a pointer to a string containing "
"the error message.  This may be either a pointer to a string that the "
"function stores in I<buf>, or a pointer to some (immutable) static string "
"(in which case I<buf> is unused).  If the function stores a string in "
"I<buf>, then at most I<buflen> bytes are stored (the string may be truncated "
"if I<buflen> is too small and I<errnum> is unknown).  The string always "
"includes a terminating null byte (\\(aq\\e0\\(aq)."
msgstr ""

#. type: SS
#: build/C/man3/strerror.3:172
#, no-wrap
msgid "strerror_l()"
msgstr ""

#. type: Plain text
#: build/C/man3/strerror.3:187
msgid ""
"B<strerror_l>()  is like B<strerror>(), but maps I<errnum> to a "
"locale-dependent error message in the locale specified by I<locale>.  The "
"behavior of B<strerror_l>()  is undefined if I<locale> is the special locale "
"object B<LC_GLOBAL_LOCALE> or is not a valid locale object handle."
msgstr ""

#. type: Plain text
#: build/C/man3/strerror.3:196
msgid ""
"The B<strerror>(), B<strerror_l>(), and the GNU-specific B<strerror_r>()  "
"functions return the appropriate error description string, or an \"Unknown "
"error nnn\" message if the error number is unknown."
msgstr ""

#. type: Plain text
#: build/C/man3/strerror.3:205
msgid ""
"On success, B<strerrorname_np>()  and B<strerrordesc_np>()  return the "
"appropriate error description string.  If I<errnum> is an invalid error "
"number, these functions return NULL."
msgstr ""

#. type: Plain text
#: build/C/man3/strerror.3:214
msgid ""
"The XSI-compliant B<strerror_r>()  function returns 0 on success.  On error, "
"a (positive) error number is returned (since glibc 2.13), or -1 is returned "
"and I<errno> is set to indicate the error (glibc versions before 2.13)."
msgstr ""

#. type: Plain text
#: build/C/man3/strerror.3:229
msgid ""
"POSIX.1-2001 and POSIX.1-2008 require that a successful call to "
"B<strerror>()  or B<strerror_l>()  shall leave I<errno> unchanged, and note "
"that, since no function return value is reserved to indicate an error, an "
"application that wishes to check for errors should initialize I<errno> to "
"zero before the call, and then check I<errno> after the call."
msgstr ""

#. type: TP
#: build/C/man3/strerror.3:230
#, no-wrap
msgid "B<EINVAL>"
msgstr ""

#. type: Plain text
#: build/C/man3/strerror.3:235
msgid "The value of I<errnum> is not a valid error number."
msgstr ""

#. type: TP
#: build/C/man3/strerror.3:235
#, no-wrap
msgid "B<ERANGE>"
msgstr ""

#. type: Plain text
#: build/C/man3/strerror.3:238
msgid "Insufficient storage was supplied to contain the error description string."
msgstr ""

#. type: Plain text
#: build/C/man3/strerror.3:242
msgid "The B<strerror_l>()  function first appeared in glibc 2.6."
msgstr ""

#. type: tbl table
#: build/C/man3/strerror.3:252
#, no-wrap
msgid "B<strerror>()"
msgstr ""

#. type: tbl table
#: build/C/man3/strerror.3:252
#, no-wrap
msgid "MT-Unsafe race:strerror"
msgstr ""

#. type: tbl table
#: build/C/man3/strerror.3:256
#, no-wrap
msgid ""
"B<strerrorname_np>(),\n"
"B<strerrordesc_np>()"
msgstr ""

#. type: tbl table
#: build/C/man3/strerror.3:259
#, no-wrap
msgid "B<strerror_r>(),\n"
msgstr ""

#. type: tbl table
#: build/C/man3/strerror.3:261
#, no-wrap
msgid "B<strerror_l>()"
msgstr ""

#.  FIXME . for later review when Issue 8 is one day released...
#.  A future POSIX.1 may remove strerror_r()
#.  http://austingroupbugs.net/tag_view_page.php?tag_id=8
#.  http://austingroupbugs.net/view.php?id=508
#. type: Plain text
#: build/C/man3/strerror.3:272
msgid ""
"B<strerror>()  is specified by POSIX.1-2001, POSIX.1-2008, C89, and C99.  "
"B<strerror_r>()  is specified by POSIX.1-2001 and POSIX.1-2008."
msgstr ""

#. type: Plain text
#: build/C/man3/strerror.3:275
msgid "B<strerror_l>()  is specified in POSIX.1-2008."
msgstr ""

#. type: Plain text
#: build/C/man3/strerror.3:282
msgid ""
"The GNU-specific functions B<strerror_r>(), B<strerrorname_np>(), and "
"B<strerrordesc_np>()  are nonstandard extensions."
msgstr ""

#.  e.g., Solaris 8, HP-UX 11
#.  e.g., FreeBSD 5.4, Tru64 5.1B
#. type: Plain text
#: build/C/man3/strerror.3:302
msgid ""
"POSIX.1-2001 permits B<strerror>()  to set I<errno> if the call encounters "
"an error, but does not specify what value should be returned as the function "
"result in the event of an error.  On some systems, B<strerror>()  returns "
"NULL if the error number is unknown.  On other systems, B<strerror>()  "
"returns a string something like \"Error nnn occurred\" and sets I<errno> to "
"B<EINVAL> if the error number is unknown.  C99 and POSIX.1-2008 require the "
"return value to be non-NULL."
msgstr ""

#. type: Plain text
#: build/C/man3/strerror.3:309
msgid ""
"The GNU C Library uses a buffer of 1024 characters for B<strerror>().  This "
"buffer size therefore should be sufficient to avoid an B<ERANGE> error when "
"calling B<strerror_r>()."
msgstr ""

#. type: Plain text
#: build/C/man3/strerror.3:314
msgid ""
"B<strerrorname_np>()  and B<strerrordesc_np>()  are thread-safe and "
"async-signal-safe."
msgstr ""

#. type: Plain text
#: build/C/man3/strerror.3:321
msgid ""
"B<err>(3), B<errno>(3), B<error>(3), B<perror>(3), B<strsignal>(3), "
"B<locale>(7)"
msgstr ""

#. type: TH
#: build/C/man3/strfry.3:30
#, no-wrap
msgid "STRFRY"
msgstr ""

#. type: Plain text
#: build/C/man3/strfry.3:33
msgid "strfry - randomize a string"
msgstr ""

#. type: Plain text
#: build/C/man3/strfry.3:39
#, no-wrap
msgid "B<char *strfry(char *>I<string>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strfry.3:48
msgid ""
"The B<strfry>()  function randomizes the contents of I<string> by randomly "
"swapping characters in the string.  The result is an anagram of I<string>."
msgstr ""

#. type: Plain text
#: build/C/man3/strfry.3:53
msgid "The B<strfry>()  functions returns a pointer to the randomized string."
msgstr ""

#. type: tbl table
#: build/C/man3/strfry.3:63
#, no-wrap
msgid "B<strfry>()"
msgstr ""

#. type: Plain text
#: build/C/man3/strfry.3:70
msgid "The B<strfry>()  function is unique to the GNU C Library."
msgstr ""

#. type: Plain text
#: build/C/man3/strfry.3:73
msgid "B<memfrob>(3), B<string>(3)"
msgstr ""

#. type: TH
#: build/C/man3/string.3:30
#, no-wrap
msgid "STRING"
msgstr ""

#. type: Plain text
#: build/C/man3/string.3:36
msgid ""
"stpcpy, strcasecmp, strcat, strchr, strcmp, strcoll, strcpy, strcspn, "
"strdup, strfry, strlen, strncat, strncmp, strncpy, strncasecmp, strpbrk, "
"strrchr, strsep, strspn, strstr, strtok, strxfrm, index, rindex - string "
"operations"
msgstr ""

#. type: Plain text
#: build/C/man3/string.3:38
msgid "B<#include E<lt>strings.hE<gt>>"
msgstr ""

#. type: TP
#: build/C/man3/string.3:38
#, no-wrap
msgid "B<int strcasecmp(const char *>I<s1>B<, const char *>I<s2>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/string.3:45
msgid "Compare the strings I<s1> and I<s2> ignoring case."
msgstr ""

#. type: TP
#: build/C/man3/string.3:45
#, no-wrap
msgid ""
"B<int strncasecmp(const char *>I<s1>B<, const char *>I<s2>B<, size_t "
">I<n>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/string.3:54
msgid "Compare the first I<n> bytes of the strings I<s1> and I<s2> ignoring case."
msgstr ""

#. type: TP
#: build/C/man3/string.3:54
#, no-wrap
msgid "B<char *index(const char *>I<s>B<, int >I<c>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/string.3:60 build/C/man3/string.3:90
msgid ""
"Return a pointer to the first occurrence of the character I<c> in the string "
"I<s>."
msgstr ""

#. type: TP
#: build/C/man3/string.3:60
#, no-wrap
msgid "B<char *rindex(const char *>I<s>B<, int >I<c>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/string.3:66 build/C/man3/string.3:171
msgid ""
"Return a pointer to the last occurrence of the character I<c> in the string "
"I<s>."
msgstr ""

#. type: TP
#: build/C/man3/string.3:66
#, no-wrap
msgid "B<#include E<lt>string.hE<gt>>"
msgstr ""

#. type: TP
#: build/C/man3/string.3:68
#, no-wrap
msgid "B<char *stpcpy(char *>I<dest>B<, const char *>I<src>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/string.3:76
msgid ""
"Copy a string from I<src> to I<dest>, returning a pointer to the end of the "
"resulting string at I<dest>."
msgstr ""

#. type: TP
#: build/C/man3/string.3:76
#, no-wrap
msgid "B<char *strcat(char *>I<dest>B<, const char *>I<src>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/string.3:84
msgid "Append the string I<src> to the string I<dest>, returning a pointer I<dest>."
msgstr ""

#. type: TP
#: build/C/man3/string.3:84
#, no-wrap
msgid "B<char *strchr(const char *>I<s>B<, int >I<c>B<);>"
msgstr ""

#. type: TP
#: build/C/man3/string.3:90
#, no-wrap
msgid "B<int strcmp(const char *>I<s1>B<, const char *>I<s2>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/string.3:96
msgid "Compare the strings I<s1> with I<s2>."
msgstr ""

#. type: TP
#: build/C/man3/string.3:96
#, no-wrap
msgid "B<int strcoll(const char *>I<s1>B<, const char *>I<s2>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/string.3:103
msgid "Compare the strings I<s1> with I<s2> using the current locale."
msgstr ""

#. type: TP
#: build/C/man3/string.3:103
#, no-wrap
msgid "B<char *strcpy(char *>I<dest>B<, const char *>I<src>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/string.3:111
msgid ""
"Copy the string I<src> to I<dest>, returning a pointer to the start of "
"I<dest>."
msgstr ""

#. type: TP
#: build/C/man3/string.3:111
#, no-wrap
msgid "B<size_t strcspn(const char *>I<s>B<, const char *>I<reject>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/string.3:117
msgid ""
"Calculate the length of the initial segment of the string I<s> which does "
"not contain any of bytes in the string I<reject>,"
msgstr ""

#. type: TP
#: build/C/man3/string.3:117
#, no-wrap
msgid "B<char *strdup(const char *>I<s>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/string.3:123
msgid ""
"Return a duplicate of the string I<s> in memory allocated using "
"B<malloc>(3)."
msgstr ""

#. type: TP
#: build/C/man3/string.3:123
#, no-wrap
msgid "B<char *strfry(char *>I<string>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/string.3:127
msgid "Randomly swap the characters in I<string>."
msgstr ""

#. type: TP
#: build/C/man3/string.3:127
#, no-wrap
msgid "B<size_t strlen(const char *>I<s>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/string.3:131
msgid "Return the length of the string I<s>."
msgstr ""

#. type: TP
#: build/C/man3/string.3:131
#, no-wrap
msgid "B<char *strncat(char *>I<dest>B<, const char *>I<src>B<, size_t >I<n>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/string.3:141
msgid ""
"Append at most I<n> bytes from the string I<src> to the string I<dest>, "
"returning a pointer to I<dest>."
msgstr ""

#. type: TP
#: build/C/man3/string.3:141
#, no-wrap
msgid "B<int strncmp(const char *>I<s1>B<, const char *>I<s2>B<, size_t >I<n>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/string.3:149
msgid "Compare at most I<n> bytes of the strings I<s1> and I<s2>."
msgstr ""

#. type: TP
#: build/C/man3/string.3:149
#, no-wrap
msgid "B<char *strncpy(char *>I<dest>B<, const char *>I<src>B<, size_t >I<n>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/string.3:159
msgid ""
"Copy at most I<n> bytes from string I<src> to I<dest>, returning a pointer "
"to the start of I<dest>."
msgstr ""

#. type: TP
#: build/C/man3/string.3:159
#, no-wrap
msgid "B<char *strpbrk(const char *>I<s>B<, const char *>I<accept>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/string.3:165
msgid ""
"Return a pointer to the first occurrence in the string I<s> of one of the "
"bytes in the string I<accept>."
msgstr ""

#. type: TP
#: build/C/man3/string.3:165
#, no-wrap
msgid "B<char *strrchr(const char *>I<s>B<, int >I<c>B<);>"
msgstr ""

#. type: TP
#: build/C/man3/string.3:171
#, no-wrap
msgid "B<char *strsep(char **>I<stringp>B<, const char *>I<delim>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/string.3:177
msgid ""
"Extract the initial token in I<stringp> that is delimited by one of the "
"bytes in I<delim>."
msgstr ""

#. type: TP
#: build/C/man3/string.3:177
#, no-wrap
msgid "B<size_t strspn(const char *>I<s>B<, const char *>I<accept>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/string.3:183
msgid ""
"Calculate the length of the starting segment in the string I<s> that "
"consists entirely of bytes in I<accept>."
msgstr ""

#. type: TP
#: build/C/man3/string.3:183
#, no-wrap
msgid "B<char *strstr(const char *>I<haystack>B<, const char *>I<needle>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/string.3:190
msgid ""
"Find the first occurrence of the substring I<needle> in the string "
"I<haystack>, returning a pointer to the found substring."
msgstr ""

#. type: TP
#: build/C/man3/string.3:190
#, no-wrap
msgid "B<char *strtok(char *>I<s>B<, const char *>I<delim>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/string.3:196
msgid ""
"Extract tokens from the string I<s> that are delimited by one of the bytes "
"in I<delim>."
msgstr ""

#. type: TP
#: build/C/man3/string.3:196
#, no-wrap
msgid "B<size_t strxfrm(char *>I<dest>B<, const char *>I<src>B<, size_t >I<n>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/string.3:204
msgid ""
"Transforms I<src> to the current locale and copies the first I<n> bytes to "
"I<dest>."
msgstr ""

#. type: Plain text
#: build/C/man3/string.3:208
msgid ""
"The string functions perform operations on null-terminated strings.  See the "
"individual man pages for descriptions of each function."
msgstr ""

#. type: Plain text
#: build/C/man3/string.3:233
msgid ""
"B<index>(3), B<rindex>(3), B<stpcpy>(3), B<strcasecmp>(3), B<strcat>(3), "
"B<strchr>(3), B<strcmp>(3), B<strcoll>(3), B<strcpy>(3), B<strcspn>(3), "
"B<strdup>(3), B<strfry>(3), B<strlen>(3), B<strncasecmp>(3), B<strncat>(3), "
"B<strncmp>(3), B<strncpy>(3), B<strpbrk>(3), B<strrchr>(3), B<strsep>(3), "
"B<strspn>(3), B<strstr>(3), B<strtok>(3), B<strxfrm>(3)"
msgstr ""

#. type: TH
#: build/C/man3/strlen.3:30
#, no-wrap
msgid "STRLEN"
msgstr ""

#. type: Plain text
#: build/C/man3/strlen.3:33
msgid "strlen - calculate the length of a string"
msgstr ""

#. type: Plain text
#: build/C/man3/strlen.3:38
#, no-wrap
msgid "B<size_t strlen(const char *>I<s>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strlen.3:45
msgid ""
"The B<strlen>()  function calculates the length of the string pointed to by "
"I<s>, excluding the terminating null byte (\\(aq\\e0\\(aq)."
msgstr ""

#. type: Plain text
#: build/C/man3/strlen.3:50
msgid ""
"The B<strlen>()  function returns the number of bytes in the string pointed "
"to by I<s>."
msgstr ""

#. type: tbl table
#: build/C/man3/strlen.3:60
#, no-wrap
msgid "B<strlen>()"
msgstr ""

#. type: Plain text
#: build/C/man3/strlen.3:64
msgid "POSIX.1-2001, POSIX.1-2008, C89, C99, C11, SVr4, 4.3BSD."
msgstr ""

#. type: Plain text
#: build/C/man3/strlen.3:69
msgid "B<string>(3), B<strnlen>(3), B<wcslen>(3), B<wcsnlen>(3)"
msgstr ""

#. type: TH
#: build/C/man3/strnlen.3:13
#, no-wrap
msgid "STRNLEN"
msgstr ""

#. type: Plain text
#: build/C/man3/strnlen.3:16
msgid "strnlen - determine the length of a fixed-size string"
msgstr ""

#. type: Plain text
#: build/C/man3/strnlen.3:21
#, no-wrap
msgid "B<size_t strnlen(const char *>I<s>B<, size_t >I<maxlen>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strnlen.3:29
msgid "B<strnlen>():"
msgstr ""

#. type: Plain text
#: build/C/man3/strnlen.3:58
msgid ""
"The B<strnlen>()  function returns the number of bytes in the string pointed "
"to by I<s>, excluding the terminating null byte (\\(aq\\e0\\(aq), but at "
"most I<maxlen>.  In doing this, B<strnlen>()  looks only at the first "
"I<maxlen> characters in the string pointed to by I<s> and never beyond "
"I<s[maxlen-1]>."
msgstr ""

#. type: Plain text
#: build/C/man3/strnlen.3:71
msgid ""
"The B<strnlen>()  function returns I<strlen(s)>, if that is less than "
"I<maxlen>, or I<maxlen> if there is no null terminating (\\(aq\\e0\\(aq) "
"among the first I<maxlen> characters pointed to by I<s>."
msgstr ""

#. type: tbl table
#: build/C/man3/strnlen.3:81
#, no-wrap
msgid "B<strnlen>()"
msgstr ""

#. type: Plain text
#: build/C/man3/strnlen.3:85
msgid "POSIX.1-2008."
msgstr ""

#. type: Plain text
#: build/C/man3/strnlen.3:87
msgid "B<strlen>(3)"
msgstr ""

#. type: TH
#: build/C/man3/strpbrk.3:30
#, no-wrap
msgid "STRPBRK"
msgstr ""

#. type: TH
#: build/C/man3/strpbrk.3:30 build/C/man3/strspn.3:30
#, no-wrap
msgid "2015-08-08"
msgstr ""

#. type: Plain text
#: build/C/man3/strpbrk.3:33
msgid "strpbrk - search a string for any of a set of bytes"
msgstr ""

#. type: Plain text
#: build/C/man3/strpbrk.3:38
#, no-wrap
msgid "B<char *strpbrk(const char *>I<s>B<, const char *>I<accept>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strpbrk.3:47
msgid ""
"The B<strpbrk>()  function locates the first occurrence in the string I<s> "
"of any of the bytes in the string I<accept>."
msgstr ""

#. type: Plain text
#: build/C/man3/strpbrk.3:56
msgid ""
"The B<strpbrk>()  function returns a pointer to the byte in I<s> that "
"matches one of the bytes in I<accept>, or NULL if no such byte is found."
msgstr ""

#. type: tbl table
#: build/C/man3/strpbrk.3:66
#, no-wrap
msgid "B<strpbrk>()"
msgstr ""

#. type: Plain text
#: build/C/man3/strpbrk.3:81
msgid ""
"B<index>(3), B<memchr>(3), B<rindex>(3), B<strchr>(3), B<string>(3), "
"B<strsep>(3), B<strspn>(3), B<strstr>(3), B<strtok>(3), B<wcspbrk>(3)"
msgstr ""

#. type: TH
#: build/C/man3/strsep.3:33
#, no-wrap
msgid "STRSEP"
msgstr ""

#. type: Plain text
#: build/C/man3/strsep.3:36
msgid "strsep - extract token from string"
msgstr ""

#. type: Plain text
#: build/C/man3/strsep.3:41
#, no-wrap
msgid "B<char *strsep(char **>I<stringp>B<, const char *>I<delim>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strsep.3:53
#, no-wrap
msgid ""
"B<strsep>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strsep.3:76
msgid ""
"If I<*stringp> is NULL, the B<strsep>()  function returns NULL and does "
"nothing else.  Otherwise, this function finds the first token in the string "
"I<*stringp>, that is delimited by one of the bytes in the string I<delim>.  "
"This token is terminated by overwriting the delimiter with a null byte "
"(\\(aq\\e0\\(aq), and I<*stringp> is updated to point past the token.  In "
"case no delimiter was found, the token is taken to be the entire string "
"I<*stringp>, and I<*stringp> is made NULL."
msgstr ""

#. type: Plain text
#: build/C/man3/strsep.3:82
msgid ""
"The B<strsep>()  function returns a pointer to the token, that is, it "
"returns the original value of I<*stringp>."
msgstr ""

#. type: tbl table
#: build/C/man3/strsep.3:92
#, no-wrap
msgid "B<strsep>()"
msgstr ""

#. type: Plain text
#: build/C/man3/strsep.3:96
msgid "4.4BSD."
msgstr ""

#. type: Plain text
#: build/C/man3/strsep.3:105
msgid ""
"The B<strsep>()  function was introduced as a replacement for B<strtok>(3), "
"since the latter cannot handle empty fields.  However, B<strtok>(3)  "
"conforms to C89/C99 and hence is more portable."
msgstr ""

#. type: Plain text
#: build/C/man3/strsep.3:108
msgid "Be cautious when using this function.  If you do use it, note that:"
msgstr ""

#. type: Plain text
#: build/C/man3/strsep.3:110
msgid "This function modifies its first argument."
msgstr ""

#. type: Plain text
#: build/C/man3/strsep.3:112
msgid "This function cannot be used on constant strings."
msgstr ""

#. type: Plain text
#: build/C/man3/strsep.3:114
msgid "The identity of the delimiting character is lost."
msgstr ""

#. type: Plain text
#: build/C/man3/strsep.3:124
msgid ""
"B<index>(3), B<memchr>(3), B<rindex>(3), B<strchr>(3), B<string>(3), "
"B<strpbrk>(3), B<strspn>(3), B<strstr>(3), B<strtok>(3)"
msgstr ""

#. type: TH
#: build/C/man3/strsignal.3:31
#, no-wrap
msgid "STRSIGNAL"
msgstr ""

#. type: Plain text
#: build/C/man3/strsignal.3:34
msgid ""
"strsignal, sigdescr_np, sigdescr_np, sys_siglist - return string describing "
"signal"
msgstr ""

#. type: Plain text
#: build/C/man3/strsignal.3:41
#, no-wrap
msgid ""
"B<char *strsignal(int >I<sig>B<);>\n"
"B<char *sigdescr_np(int >I<sig>B<);>\n"
"B<char *sigabbrev_np(int >I<sig>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strsignal.3:43
#, no-wrap
msgid "B<extern const char * const >I<sys_siglist>B<[];>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strsignal.3:52
msgid "B<sigabbrev_np>(), B<sigdescr_np>():"
msgstr ""

#. type: Plain text
#: build/C/man3/strsignal.3:59
msgid "B<strsignal>():"
msgstr ""

#. type: TP
#: build/C/man3/strsignal.3:61
#, no-wrap
msgid "From glibc 2.10 to 2.31:"
msgstr ""

#. type: Plain text
#: build/C/man3/strsignal.3:74
#, no-wrap
msgid ""
"I<sys_siglist>:\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strsignal.3:89
msgid ""
"The B<strsignal>()  function returns a string describing the signal number "
"passed in the argument I<sig>.  The string can be used only until the next "
"call to B<strsignal>().  The string returned by B<strsignal>()  is localized "
"according to the B<LC_MESSAGES> category in the current locale."
msgstr ""

#. type: Plain text
#: build/C/man3/strsignal.3:98
msgid ""
"The B<sigdescr_np>()  function returns a string describing the signal number "
"passed in the argument I<sig>.  Unlike B<strsignal>()  this string is not "
"influenced by the current locale."
msgstr ""

#. type: Plain text
#: build/C/man3/strsignal.3:106
msgid ""
"The B<sigabbrev_np>()  function returns the abbreviated name of the signal, "
"I<sig>.  For example, given the value B<SIGINT>, it returns the string "
"\"INT\"."
msgstr ""

#. type: Plain text
#: build/C/man3/strsignal.3:116
msgid ""
"The (deprecated) array I<sys_siglist> holds the signal description strings "
"indexed by signal number.  The B<strsignal>()  or the B<sigdescr_np>()  "
"function should be used instead of this array; see also VERSIONS."
msgstr ""

#. type: Plain text
#: build/C/man3/strsignal.3:123
msgid ""
"The B<strsignal>()  function returns the appropriate description string, or "
"an unknown signal message if the signal number is invalid.  On some systems "
"(but not on Linux), NULL may instead be returned for an invalid signal "
"number."
msgstr ""

#. type: Plain text
#: build/C/man3/strsignal.3:132
msgid ""
"The B<sigdescr_np>()  and B<sigdabbrev_np>()  functions return the "
"appropriate description string.  The returned string is statically allocated "
"and valid for the lifetime of the program.  These functions return NULL for "
"an invalid signal number."
msgstr ""

#. type: Plain text
#: build/C/man3/strsignal.3:137
msgid "B<sigdescr_np>()  and B<sigdabbrev_np>()  first appeared in glibc 2.32."
msgstr ""

#.  glibc commit b1ccfc061feee9ce616444ded8e1cd5acf9fa97f
#. type: Plain text
#: build/C/man3/strsignal.3:143
msgid ""
"Starting with version 2.32, the I<sys_siglist> symbol is no longer exported "
"by glibc."
msgstr ""

#. type: tbl table
#: build/C/man3/strsignal.3:153
#, no-wrap
msgid "B<strsignal>()"
msgstr ""

#. type: tbl table
#: build/C/man3/strsignal.3:153
#, no-wrap
msgid "MT-Unsafe race:strsignal locale"
msgstr ""

#. type: tbl table
#: build/C/man3/strsignal.3:157
#, no-wrap
msgid ""
"B<sigdescr_np>(),\n"
"B<sigabbrev_np>()"
msgstr ""

#. type: Plain text
#: build/C/man3/strsignal.3:164
msgid "B<strsignal>(): POSIX.1-2008.  Present on Solaris and the BSDs."
msgstr ""

#. type: Plain text
#: build/C/man3/strsignal.3:169
msgid "B<sigdescr_np>()  and B<sigdabbrev_np>()  are GNU extensions."
msgstr ""

#. type: Plain text
#: build/C/man3/strsignal.3:172
msgid "I<sys_siglist> is nonstandard, but present on many other systems."
msgstr ""

#. type: Plain text
#: build/C/man3/strsignal.3:177
msgid ""
"B<sigdescr_np>()  and B<sigdabbrev_np>()  are thread-safe and "
"async-signal-safe."
msgstr ""

#. type: Plain text
#: build/C/man3/strsignal.3:180
msgid "B<psignal>(3), B<strerror>(3)"
msgstr ""

#. type: TH
#: build/C/man3/strspn.3:30
#, no-wrap
msgid "STRSPN"
msgstr ""

#. type: Plain text
#: build/C/man3/strspn.3:33
msgid "strspn, strcspn - get length of a prefix substring"
msgstr ""

#. type: Plain text
#: build/C/man3/strspn.3:38
#, no-wrap
msgid "B<size_t strspn(const char *>I<s>B<, const char *>I<accept>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strspn.3:40
#, no-wrap
msgid "B<size_t strcspn(const char *>I<s>B<, const char *>I<reject>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strspn.3:49
msgid ""
"The B<strspn>()  function calculates the length (in bytes) of the initial "
"segment of I<s> which consists entirely of bytes in I<accept>."
msgstr ""

#. type: Plain text
#: build/C/man3/strspn.3:57
msgid ""
"The B<strcspn>()  function calculates the length of the initial segment of "
"I<s> which consists entirely of bytes not in I<reject>."
msgstr ""

#. type: Plain text
#: build/C/man3/strspn.3:66
msgid ""
"The B<strspn>()  function returns the number of bytes in the initial segment "
"of I<s> which consist only of bytes from I<accept>."
msgstr ""

#. type: Plain text
#: build/C/man3/strspn.3:74
msgid ""
"The B<strcspn>()  function returns the number of bytes in the initial "
"segment of I<s> which are not in the string I<reject>."
msgstr ""

#. type: tbl table
#: build/C/man3/strspn.3:85
#, no-wrap
msgid ""
"B<strspn>(),\n"
"B<strcspn>()"
msgstr ""

#. type: Plain text
#: build/C/man3/strspn.3:101
msgid ""
"B<index>(3), B<memchr>(3), B<rindex>(3), B<strchr>(3), B<string>(3), "
"B<strpbrk>(3), B<strsep>(3), B<strstr>(3), B<strtok>(3), B<wcscspn>(3), "
"B<wcsspn>(3)"
msgstr ""

#. type: TH
#: build/C/man3/strstr.3:33
#, no-wrap
msgid "STRSTR"
msgstr ""

#. type: Plain text
#: build/C/man3/strstr.3:36
msgid "strstr, strcasestr - locate a substring"
msgstr ""

#. type: Plain text
#: build/C/man3/strstr.3:41
#, no-wrap
msgid "B<char *strstr(const char *>I<haystack>B<, const char *>I<needle>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strstr.3:43
#, no-wrap
msgid "B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strstr.3:47
#, no-wrap
msgid "B<char *strcasestr(const char *>I<haystack>B<, const char *>I<needle>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strstr.3:56
msgid ""
"The B<strstr>()  function finds the first occurrence of the substring "
"I<needle> in the string I<haystack>.  The terminating null bytes "
"(\\(aq\\e0\\(aq) are not compared."
msgstr ""

#. type: Plain text
#: build/C/man3/strstr.3:62
msgid ""
"The B<strcasestr>()  function is like B<strstr>(), but ignores the case of "
"both arguments."
msgstr ""

#. type: Plain text
#: build/C/man3/strstr.3:65
msgid ""
"These functions return a pointer to the beginning of the located substring, "
"or NULL if the substring is not found."
msgstr ""

#. type: tbl table
#: build/C/man3/strstr.3:75
#, no-wrap
msgid "B<strstr>()"
msgstr ""

#. type: tbl table
#: build/C/man3/strstr.3:78
#, no-wrap
msgid "B<strcasestr>()"
msgstr ""

#. type: Plain text
#: build/C/man3/strstr.3:83
msgid "B<strstr>(): POSIX.1-2001, POSIX.1-2008, C89, C99."
msgstr ""

#. type: Plain text
#: build/C/man3/strstr.3:87
msgid "The B<strcasestr>()  function is a nonstandard extension."
msgstr ""

#. type: Plain text
#: build/C/man3/strstr.3:100
msgid ""
"B<index>(3), B<memchr>(3), B<memmem>(3), B<rindex>(3), B<strcasecmp>(3), "
"B<strchr>(3), B<string>(3), B<strpbrk>(3), B<strsep>(3), B<strspn>(3), "
"B<strtok>(3), B<wcsstr>(3)"
msgstr ""

#. type: TH
#: build/C/man3/strtok.3:32
#, no-wrap
msgid "STRTOK"
msgstr ""

#. type: Plain text
#: build/C/man3/strtok.3:35
msgid "strtok, strtok_r - extract tokens from strings"
msgstr ""

#. type: Plain text
#: build/C/man3/strtok.3:40
#, no-wrap
msgid "B<char *strtok(char *>I<str>B<, const char *>I<delim>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strtok.3:42
#, no-wrap
msgid ""
"B<char *strtok_r(char *>I<str>B<, const char *>I<delim>B<, char "
"**>I<saveptr>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strtok.3:53
#, no-wrap
msgid ""
"B<strtok_r>():\n"
"_POSIX_C_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strtok.3:66
msgid ""
"The B<strtok>()  function breaks a string into a sequence of zero or more "
"nonempty tokens.  On the first call to B<strtok>(), the string to be parsed "
"should be specified in I<str>.  In each subsequent call that should parse "
"the same string, I<str> must be NULL."
msgstr ""

#. type: Plain text
#: build/C/man3/strtok.3:75
msgid ""
"The I<delim> argument specifies a set of bytes that delimit the tokens in "
"the parsed string.  The caller may specify different strings in I<delim> in "
"successive calls that parse the same string."
msgstr ""

#. type: Plain text
#: build/C/man3/strtok.3:84
msgid ""
"Each call to B<strtok>()  returns a pointer to a null-terminated string "
"containing the next token.  This string does not include the delimiting "
"byte.  If no more tokens are found, B<strtok>()  returns NULL."
msgstr ""

#. type: Plain text
#: build/C/man3/strtok.3:104
msgid ""
"A sequence of calls to B<strtok>()  that operate on the same string "
"maintains a pointer that determines the point from which to start searching "
"for the next token.  The first call to B<strtok>()  sets this pointer to "
"point to the first byte of the string.  The start of the next token is "
"determined by scanning forward for the next nondelimiter byte in I<str>.  If "
"such a byte is found, it is taken as the start of the next token.  If no "
"such byte is found, then there are no more tokens, and B<strtok>()  returns "
"NULL.  (A string that is empty or that contains only delimiters will thus "
"cause B<strtok>()  to return NULL on the first call.)"
msgstr ""

#. type: Plain text
#: build/C/man3/strtok.3:117
msgid ""
"The end of each token is found by scanning forward until either the next "
"delimiter byte is found or until the terminating null byte (\\(aq\\e0\\(aq) "
"is encountered.  If a delimiter byte is found, it is overwritten with a null "
"byte to terminate the current token, and B<strtok>()  saves a pointer to the "
"following byte; that pointer will be used as the starting point when "
"searching for the next token.  In this case, B<strtok>()  returns a pointer "
"to the start of the found token."
msgstr ""

#. type: Plain text
#: build/C/man3/strtok.3:131
msgid ""
"From the above description, it follows that a sequence of two or more "
"contiguous delimiter bytes in the parsed string is considered to be a single "
"delimiter, and that delimiter bytes at the start or end of the string are "
"ignored.  Put another way: the tokens returned by B<strtok>()  are always "
"nonempty strings.  Thus, for example, given the string \"I<aaa;;bbb,>\", "
"successive calls to B<strtok>()  that specify the delimiter string \"I<;,>\" "
"would return the strings \"I<aaa>\" and \"I<bbb>\", and then a null pointer."
msgstr ""

#. type: Plain text
#: build/C/man3/strtok.3:144
msgid ""
"The B<strtok_r>()  function is a reentrant version of B<strtok>().  The "
"I<saveptr> argument is a pointer to a I<char\\ *> variable that is used "
"internally by B<strtok_r>()  in order to maintain context between successive "
"calls that parse the same string."
msgstr ""

#. type: Plain text
#: build/C/man3/strtok.3:157
msgid ""
"On the first call to B<strtok_r>(), I<str> should point to the string to be "
"parsed, and the value of I<*saveptr> is ignored (but see NOTES).  In "
"subsequent calls, I<str> should be NULL, and I<saveptr> (and the buffer that "
"it points to)  should be unchanged since the previous call."
msgstr ""

#. type: Plain text
#: build/C/man3/strtok.3:163
msgid ""
"Different strings may be parsed concurrently using sequences of calls to "
"B<strtok_r>()  that specify different I<saveptr> arguments."
msgstr ""

#. type: Plain text
#: build/C/man3/strtok.3:170
msgid ""
"The B<strtok>()  and B<strtok_r>()  functions return a pointer to the next "
"token, or NULL if there are no more tokens."
msgstr ""

#. type: TP
#: build/C/man3/strtok.3:180 build/C/man3/strtok.3:186
#, no-wrap
msgid "B<strtok>()"
msgstr ""

#. type: tbl table
#: build/C/man3/strtok.3:180
#, no-wrap
msgid "MT-Unsafe race:strtok"
msgstr ""

#. type: TP
#: build/C/man3/strtok.3:183 build/C/man3/strtok.3:189
#, no-wrap
msgid "B<strtok_r>()"
msgstr ""

#. type: Plain text
#: build/C/man3/strtok.3:192
msgid "POSIX.1-2001, POSIX.1-2008."
msgstr ""

#.  Tru64, according to its manual page
#. type: Plain text
#: build/C/man3/strtok.3:200
msgid ""
"On some implementations, I<*saveptr> is required to be NULL on the first "
"call to B<strtok_r>()  that is being used to parse I<str>."
msgstr ""

#. type: Plain text
#: build/C/man3/strtok.3:203
msgid "Be cautious when using these functions.  If you do use them, note that:"
msgstr ""

#. type: Plain text
#: build/C/man3/strtok.3:205
msgid "These functions modify their first argument."
msgstr ""

#. type: Plain text
#: build/C/man3/strtok.3:207
msgid "These functions cannot be used on constant strings."
msgstr ""

#. type: Plain text
#: build/C/man3/strtok.3:209
msgid "The identity of the delimiting byte is lost."
msgstr ""

#. type: Plain text
#: build/C/man3/strtok.3:216
msgid ""
"The B<strtok>()  function uses a static buffer while parsing, so it's not "
"thread safe.  Use B<strtok_r>()  if this matters to you."
msgstr ""

#. type: Plain text
#: build/C/man3/strtok.3:225
msgid ""
"The program below uses nested loops that employ B<strtok_r>()  to break a "
"string into a two-level hierarchy of tokens.  The first command-line "
"argument specifies the string to be parsed.  The second argument specifies "
"the delimiter byte(s)  to be used to separate that string into \"major\" "
"tokens.  The third argument specifies the delimiter byte(s)  to be used to "
"separate the \"major\" tokens into subtokens."
msgstr ""

#. type: Plain text
#: build/C/man3/strtok.3:227
msgid "An example of the output produced by this program is the following:"
msgstr ""

#. type: Plain text
#: build/C/man3/strtok.3:239
#, no-wrap
msgid ""
"$B< ./a.out \\(aqa/bbb///cc;xxx:yyy:\\(aq \\(aq:;\\(aq \\(aq/\\(aq>\n"
"1: a/bbb///cc\n"
"         --E<gt> a\n"
"         --E<gt> bbb\n"
"         --E<gt> cc\n"
"2: xxx\n"
"         --E<gt> xxx\n"
"3: yyy\n"
"         --E<gt> yyy\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strtok.3:247
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strtok.3:253
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *str1, *str2, *token, *subtoken;\n"
"    char *saveptr1, *saveptr2;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strtok.3:259
#, no-wrap
msgid ""
"    if (argc != 4) {\n"
"        fprintf(stderr, \"Usage: %s string delim subdelim\\en\",\n"
"                argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strtok.3:265
#, no-wrap
msgid ""
"    for (int j = 1, str1 = argv[1]; ; j++, str1 = NULL) {\n"
"        token = strtok_r(str1, argv[2], &saveptr1);\n"
"        if (token == NULL)\n"
"            break;\n"
"        printf(\"%d: %s\\en\", j, token);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strtok.3:273
#, no-wrap
msgid ""
"        for (str2 = token; ; str2 = NULL) {\n"
"            subtoken = strtok_r(str2, argv[3], &saveptr2);\n"
"            if (subtoken == NULL)\n"
"                break;\n"
"            printf(\"\\t --E<gt> %s\\en\", subtoken);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strtok.3:282
msgid ""
"Another example program using B<strtok>()  can be found in "
"B<getaddrinfo_a>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/strtok.3:293
msgid ""
"B<index>(3), B<memchr>(3), B<rindex>(3), B<strchr>(3), B<string>(3), "
"B<strpbrk>(3), B<strsep>(3), B<strspn>(3), B<strstr>(3), B<wcstok>(3)"
msgstr ""

#. type: TH
#: build/C/man3/strverscmp.3:26
#, no-wrap
msgid "STRVERSCMP"
msgstr ""

#. type: Plain text
#: build/C/man3/strverscmp.3:29
msgid "strverscmp - compare two version strings"
msgstr ""

#. type: Plain text
#: build/C/man3/strverscmp.3:35
#, no-wrap
msgid "B<int strverscmp(const char *>I<s1>B<, const char *>I<s2>B<);>\n"
msgstr ""

#.  classical solution: "rename jan jan0 jan?"
#. type: Plain text
#: build/C/man3/strverscmp.3:52
msgid ""
"Often one has files I<jan1>, I<jan2>, ..., I<jan9>, I<jan10>, ...  and it "
"feels wrong when B<ls>(1)  orders them I<jan1>, I<jan10>, ..., I<jan2>, ..., "
"I<jan9>.  In order to rectify this, GNU introduced the I<-v> option to "
"B<ls>(1), which is implemented using B<versionsort>(3), which again uses "
"B<strverscmp>()."
msgstr ""

#. type: Plain text
#: build/C/man3/strverscmp.3:63
msgid ""
"Thus, the task of B<strverscmp>()  is to compare two strings and find the "
"\"right\" order, while B<strcmp>(3)  finds only the lexicographic order.  "
"This function does not use the locale category B<LC_COLLATE>, so is meant "
"mostly for situations where the strings are expected to be in ASCII."
msgstr ""

#. type: Plain text
#: build/C/man3/strverscmp.3:81
msgid ""
"What this function does is the following.  If both strings are equal, return "
"0.  Otherwise, find the position between two bytes with the property that "
"before it both strings are equal, while directly after it there is a "
"difference.  Find the largest consecutive digit strings containing (or "
"starting at, or ending at) this position.  If one or both of these is empty, "
"then return what B<strcmp>(3)  would have returned (numerical ordering of "
"byte values).  Otherwise, compare both digit strings numerically, where "
"digit strings with one or more leading zeros are interpreted as if they have "
"a decimal point in front (so that in particular digit strings with more "
"leading zeros come before digit strings with fewer leading zeros).  Thus, "
"the ordering is I<000>, I<00>, I<01>, I<010>, I<09>, I<0>, I<1>, I<9>, "
"I<10>."
msgstr ""

#. type: Plain text
#: build/C/man3/strverscmp.3:90
msgid ""
"The B<strverscmp>()  function returns an integer less than, equal to, or "
"greater than zero if I<s1> is found, respectively, to be earlier than, equal "
"to, or later than I<s2>."
msgstr ""

#. type: tbl table
#: build/C/man3/strverscmp.3:100
#, no-wrap
msgid "B<strverscmp>()"
msgstr ""

#. type: Plain text
#: build/C/man3/strverscmp.3:121
msgid ""
"The program below can be used to demonstrate the behavior of "
"B<strverscmp>().  It uses B<strverscmp>()  to compare the two strings given "
"as its command-line arguments.  An example of its use is the following:"
msgstr ""

#. type: Plain text
#: build/C/man3/strverscmp.3:126
#, no-wrap
msgid ""
"$ B<./a.out jan1 jan10>\n"
"jan1 E<lt> jan10\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strverscmp.3:135
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strverscmp.3:145
#, no-wrap
msgid ""
"    if (argc != 3) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>string1E<gt> "
"E<lt>string2E<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strverscmp.3:147
#, no-wrap
msgid "    res = strverscmp(argv[1], argv[2]);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strverscmp.3:150
#, no-wrap
msgid ""
"    printf(\"%s %s %s\\en\", argv[1],\n"
"            (res E<lt> 0) ? \"E<lt>\" : (res == 0) ? \"==\" : \"E<gt>\", "
"argv[2]);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strverscmp.3:159
msgid "B<rename>(1), B<strcasecmp>(3), B<strcmp>(3), B<strcoll>(3)"
msgstr ""

#. type: TH
#: build/C/man3/strxfrm.3:30
#, no-wrap
msgid "STRXFRM"
msgstr ""

#. type: Plain text
#: build/C/man3/strxfrm.3:33
msgid "strxfrm - string transformation"
msgstr ""

#. type: Plain text
#: build/C/man3/strxfrm.3:38
#, no-wrap
msgid ""
"B<size_t strxfrm(char *>I<dest>B<, const char *>I<src>B<, size_t "
">I<n>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/strxfrm.3:62
msgid ""
"The B<strxfrm>()  function transforms the I<src> string into a form such "
"that the result of B<strcmp>(3)  on two strings that have been transformed "
"with B<strxfrm>()  is the same as the result of B<strcoll>(3)  on the two "
"strings before their transformation.  The first I<n> bytes of the "
"transformed string are placed in I<dest>.  The transformation is based on "
"the program's current locale for category B<LC_COLLATE>.  (See "
"B<setlocale>(3))."
msgstr ""

#. type: Plain text
#: build/C/man3/strxfrm.3:76
msgid ""
"The B<strxfrm>()  function returns the number of bytes required to store the "
"transformed string in I<dest> excluding the terminating null byte "
"(\\(aq\\e0\\(aq).  If the value returned is I<n> or more, the contents of "
"I<dest> are indeterminate."
msgstr ""

#. type: tbl table
#: build/C/man3/strxfrm.3:86
#, no-wrap
msgid "B<strxfrm>()"
msgstr ""

#. type: Plain text
#: build/C/man3/strxfrm.3:98
msgid ""
"B<bcmp>(3), B<memcmp>(3), B<setlocale>(3), B<strcasecmp>(3), B<strcmp>(3), "
"B<strcoll>(3), B<string>(3)"
msgstr ""
