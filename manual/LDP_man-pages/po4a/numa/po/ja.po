# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-03-12 14:00+0900\n"
"PO-Revision-Date: 2021-07-14 00:33+0900\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man2/get_mempolicy.2:27
#, no-wrap
msgid "GET_MEMPOLICY"
msgstr "GET_MEMPOLICY"

#. type: TH
#: build/C/man2/get_mempolicy.2:27
#, no-wrap
msgid "2017-09-15"
msgstr "2017-09-15"

#. type: TH
#: build/C/man2/get_mempolicy.2:27 build/C/man2/getcpu.2:12
#: build/C/man2/mbind.2:35 build/C/man2/migrate_pages.2:18
#: build/C/man2/move_pages.2:20 build/C/man7/numa.7:29
#: build/C/man2/set_mempolicy.2:27
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#: build/C/man2/get_mempolicy.2:27 build/C/man2/getcpu.2:12
#: build/C/man2/mbind.2:35 build/C/man2/migrate_pages.2:18
#: build/C/man2/move_pages.2:20 build/C/man7/numa.7:29
#: build/C/man2/set_mempolicy.2:27
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux Programmer's Manual"

#. type: SH
#: build/C/man2/get_mempolicy.2:28 build/C/man2/getcpu.2:13
#: build/C/man2/mbind.2:36 build/C/man2/migrate_pages.2:19
#: build/C/man2/move_pages.2:21 build/C/man7/numa.7:30
#: build/C/man2/set_mempolicy.2:28
#, no-wrap
msgid "NAME"
msgstr "名前"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:30
msgid "get_mempolicy - retrieve NUMA memory policy for a thread"
msgstr "get_mempolicy - スレッドの NUMA メモリーのポリシーを取得する"

#. type: SH
#: build/C/man2/get_mempolicy.2:30 build/C/man2/getcpu.2:15
#: build/C/man2/mbind.2:38 build/C/man2/migrate_pages.2:21
#: build/C/man2/move_pages.2:23 build/C/man2/set_mempolicy.2:30
#, no-wrap
msgid "SYNOPSIS"
msgstr "書式"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:32
msgid "B<#include E<lt>numaif.hE<gt>>"
msgstr "B<#include E<lt>numaif.hE<gt>>"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:37
#, no-wrap
msgid ""
"B<long get_mempolicy(int *>I<mode>B<, unsigned long *>I<nodemask>B<,>\n"
"B<                  unsigned long >I<maxnode>B<, void *>I<addr>B<,>\n"
"B<                  unsigned long >I<flags>B<);>\n"
msgstr ""
"B<long get_mempolicy(int *>I<mode>B<, unsigned long *>I<nodemask>B<,>\n"
"B<                  unsigned long >I<maxnode>B<, void *>I<addr>B<,>\n"
"B<                  unsigned long >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:39 build/C/man2/mbind.2:47
#: build/C/man2/set_mempolicy.2:38
#, no-wrap
msgid "Link with I<-lnuma>.\n"
msgstr "I<-lnuma> でリンクする。\n"

#. type: SH
#: build/C/man2/get_mempolicy.2:40 build/C/man2/getcpu.2:22
#: build/C/man2/mbind.2:48 build/C/man2/migrate_pages.2:31
#: build/C/man2/move_pages.2:32 build/C/man7/numa.7:32
#: build/C/man2/set_mempolicy.2:39
#, no-wrap
msgid "DESCRIPTION"
msgstr "説明"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:45
msgid ""
"B<get_mempolicy>()  retrieves the NUMA policy of the calling thread or of a "
"memory address, depending on the setting of I<flags>."
msgstr "B<get_mempolicy>() は、呼び出し元スレッドもしくは指定されたメモリーアドレスの NUMA ポリシーを I<flags> の設定に従って取得する。"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:50 build/C/man2/set_mempolicy.2:54
msgid ""
"A NUMA machine has different memory controllers with different distances to "
"specific CPUs.  The memory policy defines from which node memory is "
"allocated for the thread."
msgstr "NUMA (非対称メモリーアクセス) マシンでは、CPU により メモリーコントローラーが異なり、距離も異なっている。 メモリーポリシーは、どのノードからメモリーをそのスレッドに 割り当てるかを定めるものである。"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:72
#, fuzzy
#| msgid ""
#| "If I<flags> is specified as 0, then information about the calling "
#| "process's default policy (as set by B<set_mempolicy>(2))  is returned.  "
#| "The policy returned [I<mode> and I<nodemask>] may be used to restore the "
#| "process's policy to its state at the time of the call to "
#| "B<get_mempolicy>()  using B<set_mempolicy>(2)."
msgid ""
"If I<flags> is specified as 0, then information about the calling thread's "
"default policy (as set by B<set_mempolicy>(2))  is returned, in the buffers "
"pointed to by I<mode> and I<nodemask>.  The value returned in these "
"arguments may be used to restore the thread's policy to its state at the "
"time of the call to B<get_mempolicy>()  using B<set_mempolicy>(2).  When "
"I<flags> is 0, I<addr> must be specified as NULL."
msgstr ""
"I<flags> に 0 が指定された場合、 (B<set_mempolicy>(2)  で設定された)  呼び出"
"し元プロセスのデフォルトポリシーに関する情報を返す。 返されたポリシー "
"[I<mode> と I<nodemask>] を B<set_mempolicy>(2)  に渡すことで、そのプロセスの"
"ポリシーを B<get_mempolicy>()  を呼び出した時点の状態に戻すことができる。"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:94
msgid ""
"If I<flags> specifies B<MPOL_F_MEMS_ALLOWED> (available since Linux 2.6.24), "
"the I<mode> argument is ignored and the set of nodes (memories) that the "
"thread is allowed to specify in subsequent calls to B<mbind>(2)  or "
"B<set_mempolicy>(2)  (in the absence of any I<mode flags>)  is returned in "
"I<nodemask>.  It is not permitted to combine B<MPOL_F_MEMS_ALLOWED> with "
"either B<MPOL_F_ADDR> or B<MPOL_F_NODE>."
msgstr "I<flags> に B<MPOL_F_MEMS_ALLOWED> (Linux 2.6.24 以降で利用可能) を指定すると、 I<mode> 引数は無視され、 そのスレッドがその後の B<mbind>(2)  や B<set_mempolicy>(2)  で (I<モードフラグ> が指定されていない場合に) 指定できるノード (メモリー) の集合が I<nodemask> に返される。 B<MPOL_F_MEMS_ALLOWED> を、 B<MPOL_F_ADDR> や B<MPOL_F_NODE> と同時に指定することはできない。"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:108
msgid ""
"If I<flags> specifies B<MPOL_F_ADDR>, then information is returned about the "
"policy governing the memory address given in I<addr>.  This policy may be "
"different from the thread's default policy if B<mbind>(2)  or one of the "
"helper functions described in B<numa>(3)  has been used to establish a "
"policy for the memory range containing I<addr>."
msgstr "I<flags> に B<MPOL_F_ADDR> が指定された場合、 I<addr> で指定されたメモリーアドレスに適用されているポリシーに関する情報を返す。 B<mbind>(2)  や B<numa>(3)  で説明されているヘルパー関数を使って、 I<addr> を含むメモリー領域に対するポリシーが設定されていた場合には、 返されるポリシーはスレッドのデフォルトポリシーと違うことがある。"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:129
msgid ""
"If the I<mode> argument is not NULL, then B<get_mempolicy>()  will store the "
"policy mode and any optional I<mode flags> of the requested NUMA policy in "
"the location pointed to by this argument.  If I<nodemask> is not NULL, then "
"the nodemask associated with the policy will be stored in the location "
"pointed to by this argument.  I<maxnode> specifies the number of node IDs "
"that can be stored into I<nodemask>\\(emthat is, the maximum node ID plus "
"one.  The value specified by I<maxnode> is always rounded to a multiple of "
"I<sizeof(unsigned\\ long)*8>."
msgstr "I<mode> 引数が NULL でない場合、 B<get_mempolicy>()  は要求された NUMA ポリシーのモードと追加の I<モードフラグ> を I<mode> が指す場所に格納する。 I<nodemask> が NULL 以外の場合、そのポリシーに対応するノードマスクを この引数が指す場所に格納する。 I<maxnode> には I<nodemask> に格納できるノード ID の数、つまり最大ノード ID に 1 を足した値を指定する。 I<maxnode> で指定された値は常に I<sizeof(unsigned\\ long)*8> の倍数に切り上げられる。"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:146
msgid ""
"If I<flags> specifies both B<MPOL_F_NODE> and B<MPOL_F_ADDR>, "
"B<get_mempolicy>()  will return the node ID of the node on which the address "
"I<addr> is allocated into the location pointed to by I<mode>.  If no page "
"has yet been allocated for the specified address, B<get_mempolicy>()  will "
"allocate a page as if the thread had performed a read (load) access to that "
"address, and return the ID of the node where that page was allocated."
msgstr "I<flags> で B<MPOL_F_NODE> と B<MPOL_F_ADDR> の両方が指定された場合、 B<get_mempolicy>()  はアドレス I<addr> が割り当てられているノードのノード ID を I<mode> が指す場所に入れて返す。 指定されたアドレスにどのページもまだ割り当てられていない場合、 B<get_mempolicy>()  は、あたかもそのスレッドがそのアドレスに対して読み込みアクセスを 実行したかのようにページの割り当てを行い、ページが割り当てられた ノードの ID を返す。"

#.  Note:  code returns next interleave node via 'mode' argument -Lee Schermerhorn
#. type: Plain text
#: build/C/man2/get_mempolicy.2:171
msgid ""
"If I<flags> specifies B<MPOL_F_NODE>, but not B<MPOL_F_ADDR>, and the "
"thread's current policy is B<MPOL_INTERLEAVE>, then B<get_mempolicy>()  will "
"return in the location pointed to by a non-NULL I<mode> argument, the node "
"ID of the next node that will be used for interleaving of internal kernel "
"pages allocated on behalf of the thread.  These allocations include pages "
"for memory-mapped files in process memory ranges mapped using the "
"B<mmap>(2)  call with the B<MAP_PRIVATE> flag for read accesses, and in "
"memory ranges mapped with the B<MAP_SHARED> flag for all accesses."
msgstr "I<flags> で B<MPOL_F_NODE> は指定されたが、 B<MPOL_F_ADDR> は指定されていない場合で、かつ そのスレッドの現在のポリシーが B<MPOL_INTERLEAVE> の場合、 B<get_mempolicy>()  は、そのスレッドに対して割り当てられたカーネルの内部ページで 次にインターリーブ用に使用されるノードのノード ID を、 NULL でない I<mode> 引数が指す場所に入れて返す。これには、読み込みアクセス用として B<MAP_PRIVATE> フラグ付きで B<mmap>(2) したプロセスメモリー領域や、 任意のアクセス用として B<MAP_SHARED> フラグ付きで B<mmap>(2)  したメモリー領域の、メモリーマップされたファイルに対するページも含まれる。"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:173
msgid "Other flag values are reserved."
msgstr "他のフラグは予約されている。"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:176
msgid "For an overview of the possible policies see B<set_mempolicy>(2)."
msgstr "設定可能なポリシーの概要については B<set_mempolicy>(2)  を参照。"

#. type: SH
#: build/C/man2/get_mempolicy.2:176 build/C/man2/getcpu.2:58
#: build/C/man2/mbind.2:328 build/C/man2/migrate_pages.2:88
#: build/C/man2/move_pages.2:162 build/C/man2/set_mempolicy.2:244
#, no-wrap
msgid "RETURN VALUE"
msgstr "返り値"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:183
msgid ""
"On success, B<get_mempolicy>()  returns 0; on error, -1 is returned and "
"I<errno> is set to indicate the error."
msgstr ""
"成功すると、 B<get_mempolicy>()  は 0 を返す。エラーの場合、-1 を返し、 "
"I<errno> にエラーを示す値を設定する。"

#. type: SH
#: build/C/man2/get_mempolicy.2:183 build/C/man2/getcpu.2:63
#: build/C/man2/mbind.2:336 build/C/man2/migrate_pages.2:96
#: build/C/man2/move_pages.2:173 build/C/man2/set_mempolicy.2:251
#, no-wrap
msgid "ERRORS"
msgstr "エラー"

#. type: TP
#: build/C/man2/get_mempolicy.2:184 build/C/man2/getcpu.2:64
#: build/C/man2/mbind.2:338 build/C/man2/migrate_pages.2:97
#: build/C/man2/move_pages.2:190 build/C/man2/set_mempolicy.2:252
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:191 build/C/man2/set_mempolicy.2:259
msgid ""
"Part of all of the memory range specified by I<nodemask> and I<maxnode> "
"points outside your accessible address space."
msgstr ""
"I<nodemask> と I<maxnode> で指定されたメモリー領域の一部または全部が、 呼び出"
"し元がアクセス可能なアドレス空間外を指している。"

#. type: TP
#: build/C/man2/get_mempolicy.2:191 build/C/man2/mbind.2:349
#: build/C/man2/migrate_pages.2:104 build/C/man2/move_pages.2:193
#: build/C/man2/set_mempolicy.2:259
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:235
msgid ""
"The value specified by I<maxnode> is less than the number of node IDs "
"supported by the system.  Or I<flags> specified values other than "
"B<MPOL_F_NODE> or B<MPOL_F_ADDR>; or I<flags> specified B<MPOL_F_ADDR> and "
"I<addr> is NULL, or I<flags> did not specify B<MPOL_F_ADDR> and I<addr> is "
"not NULL.  Or, I<flags> specified B<MPOL_F_NODE> but not B<MPOL_F_ADDR> and "
"the current thread policy is not B<MPOL_INTERLEAVE>.  Or, I<flags> specified "
"B<MPOL_F_MEMS_ALLOWED> with either B<MPOL_F_ADDR> or B<MPOL_F_NODE>.  (And "
"there are other B<EINVAL> cases.)"
msgstr "I<maxnode> で指定された値がシステムがサポートするノード ID の数よりも少ない。 または、 I<flags> に B<MPOL_F_NODE> でも B<MPOL_F_ADDR> でもない値が指定された。 または、 I<flags> に B<MPOL_F_ADDR> が指定されており、 I<addr> が NULL である。 または、 I<flags> に B<MPOL_F_ADDR> がされておらず、 I<addr> が NULL でない。 または、 I<flags> に B<MPOL_F_NODE> が指定されており、 B<MPOL_F_ADDR> が指定されておらず、 スレッドの現在のポリシーが B<MPOL_INTERLEAVE> でない。 または、 I<flags> に B<MPOL_F_MEMS_ALLOWED> が指定されており、さらに B<MPOL_F_ADDR> か B<MPOL_F_NODE> のいずれかが指定されている。 (他にも B<EINVAL> となる場合がある。)"

#. type: SH
#: build/C/man2/get_mempolicy.2:235 build/C/man2/getcpu.2:67
#: build/C/man2/mbind.2:421 build/C/man2/migrate_pages.2:136
#: build/C/man2/move_pages.2:215 build/C/man2/set_mempolicy.2:299
#, no-wrap
msgid "VERSIONS"
msgstr "バージョン"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:239
msgid ""
"The B<get_mempolicy>()  system call was added to the Linux kernel in version "
"2.6.7."
msgstr ""
"B<get_mempolicy>()  システムコールはバージョン 2.6.7 で Linux カーネルに追加"
"された。"

#. type: SH
#: build/C/man2/get_mempolicy.2:239 build/C/man2/getcpu.2:74
#: build/C/man2/mbind.2:425 build/C/man2/migrate_pages.2:140
#: build/C/man2/move_pages.2:218 build/C/man7/numa.7:148
#: build/C/man2/set_mempolicy.2:303
#, no-wrap
msgid "CONFORMING TO"
msgstr "準拠"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:241 build/C/man2/mbind.2:427
#: build/C/man2/migrate_pages.2:142 build/C/man2/move_pages.2:220
#: build/C/man2/set_mempolicy.2:305
msgid "This system call is Linux-specific."
msgstr "このシステムコールは Linux 固有である。"

#. type: SH
#: build/C/man2/get_mempolicy.2:241 build/C/man2/getcpu.2:77
#: build/C/man2/mbind.2:427 build/C/man2/migrate_pages.2:142
#: build/C/man2/move_pages.2:220 build/C/man7/numa.7:150
#: build/C/man2/set_mempolicy.2:305
#, no-wrap
msgid "NOTES"
msgstr "注意"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:244 build/C/man2/mbind.2:430
#: build/C/man2/migrate_pages.2:145 build/C/man2/move_pages.2:223
#: build/C/man2/set_mempolicy.2:313
msgid "For information on library support, see B<numa>(7)."
msgstr "ライブラリによるサポートについては B<numa>(7)  を参照。"

#. type: SH
#: build/C/man2/get_mempolicy.2:244 build/C/man2/getcpu.2:136
#: build/C/man2/mbind.2:483 build/C/man2/migrate_pages.2:172
#: build/C/man2/move_pages.2:250 build/C/man7/numa.7:183
#: build/C/man2/set_mempolicy.2:313
#, no-wrap
msgid "SEE ALSO"
msgstr "関連項目"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:252
msgid ""
"B<getcpu>(2), B<mbind>(2), B<mmap>(2), B<set_mempolicy>(2), B<numa>(3), "
"B<numa>(7), B<numactl>(8)"
msgstr ""
"B<getcpu>(2), B<mbind>(2), B<mmap>(2), B<set_mempolicy>(2), B<numa>(3), "
"B<numa>(7), B<numactl>(8)"

#. type: SH
#: build/C/man2/get_mempolicy.2:252 build/C/man2/getcpu.2:143
#: build/C/man2/mbind.2:494 build/C/man2/migrate_pages.2:185
#: build/C/man2/move_pages.2:260 build/C/man7/numa.7:191
#: build/C/man2/set_mempolicy.2:322
#, no-wrap
msgid "COLOPHON"
msgstr "この文書について"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:260 build/C/man2/getcpu.2:151
#: build/C/man2/mbind.2:502 build/C/man2/migrate_pages.2:193
#: build/C/man2/move_pages.2:268 build/C/man7/numa.7:199
#: build/C/man2/set_mempolicy.2:330
msgid ""
"This page is part of release 5.10 of the Linux I<man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at \\%https://www.kernel.org/doc/man-"
"pages/."
msgstr "この man ページは Linux I<man-pages> プロジェクトのリリース 5.10 の一部である。プロジェクトの説明とバグ報告に関する情報は \\%https://www.kernel.org/doc/man-pages/ に書かれている。"

#. type: TH
#: build/C/man2/getcpu.2:12
#, no-wrap
msgid "GETCPU"
msgstr "GETCPU"

#. type: TH
#: build/C/man2/getcpu.2:12 build/C/man2/migrate_pages.2:18
#, no-wrap
msgid "2019-03-06"
msgstr "2019-03-06"

#. type: Plain text
#: build/C/man2/getcpu.2:15
msgid ""
"getcpu - determine CPU and NUMA node on which the calling thread is running"
msgstr "getcpu - 呼び出し元スレッドが動作している CPU と NUMA ノードを判定する"

#. type: Plain text
#: build/C/man2/getcpu.2:18
#, no-wrap
msgid "B<#include E<lt>linux/getcpu.hE<gt>>\n"
msgstr "B<#include E<lt>linux/getcpu.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/getcpu.2:21
#, no-wrap
msgid "B<int getcpu(unsigned *>I<cpu>B<, unsigned *>I<node>B<, struct getcpu_cache *>I<tcache>B<);>\n"
msgstr "B<int getcpu(unsigned *>I<cpu>B<, unsigned *>I<node>B<, struct getcpu_cache *>I<tcache>B<);>\n"

#. type: Plain text
#: build/C/man2/getcpu.2:39
msgid ""
"The B<getcpu>()  system call identifies the processor and node on which the "
"calling thread or process is currently running and writes them into the "
"integers pointed to by the I<cpu> and I<node> arguments.  The processor is a "
"unique small integer identifying a CPU.  The node is a unique small "
"identifier identifying a NUMA node.  When either I<cpu> or I<node> is NULL "
"nothing is written to the respective pointer."
msgstr ""
"B<getcpu>() システムコールは、呼び出し元のスレッドやプロセスが\n"
"現在動作しているプロセッサやノードの情報を特定し、\n"
"それぞれ引数 I<cpu> と I<node> が指す整数に書き込む。\n"
"プロセッサ情報は CPU を識別するための一意な小さな整数である。\n"
"ノード情報は NUMAノードを識別するための一意な小さな整数である。\n"
"I<cpu> か I<node> のいずれかが NULL であれば、\n"
"その引数に対応する情報の書き込みは行われない。"

#. type: Plain text
#: build/C/man2/getcpu.2:43
msgid ""
"The third argument to this system call is nowadays unused, and should be "
"specified as NULL unless portability to Linux 2.6.23 or earlier is required "
"(see NOTES)."
msgstr ""
"このシステムコールの 3 番目の引数は現在は使われておらず、 Linux 2.6.23 以前"
"への移植性が必要な場合以外は NULL を渡すべきである (「注意」を参照)。"

#. type: Plain text
#: build/C/man2/getcpu.2:58
msgid ""
"The information placed in I<cpu> is guaranteed to be current only at the "
"time of the call: unless the CPU affinity has been fixed using "
"B<sched_setaffinity>(2), the kernel might change the CPU at any time.  "
"(Normally this does not happen because the scheduler tries to minimize "
"movements between CPUs to keep caches hot, but it is possible.)  The caller "
"must allow for the possibility that the information returned in I<cpu> and "
"I<node> is no longer current by the time the call returns."
msgstr ""
"I<cpu> に格納された情報が最新だと保証できるのは、システムコールが呼ばれ\n"
"た時点だけである。B<sched_setaffinity>(2) を使って CPU affinity が固定\n"
"されていない限り、カーネルはいつでも CPU を変更してもよい (スケジューラ\n"
"はキャッシュが有効に働くように CPU の移動を最小限にしようとするので、\n"
"通常は CPU が変更されることはないが、起きる可能性はある)。\n"
"I<cpu> や I<node> で返された情報が呼び出しが返った時点ですでに\n"
"最新の状況と異なる可能性があり、呼び出し元はこの可能性を考慮して\n"
"おかなければならない。"

#. type: Plain text
#: build/C/man2/getcpu.2:63
msgid ""
"On success, 0 is returned.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""
"成功すると、0 を返す。\n"
"エラーの場合、-1 を返し、 I<errno> にエラーを示す値を設定する。"

#. type: Plain text
#: build/C/man2/getcpu.2:67
msgid "Arguments point outside the calling process's address space."
msgstr "引数が呼び出したプロセスのアドレス空間外を指している。"

#. type: Plain text
#: build/C/man2/getcpu.2:74
msgid ""
"B<getcpu>()  was added in kernel 2.6.19 for x86-64 and i386.  Library "
"support was added in glibc 2.29 (Earlier glibc versions did not provide a "
"wrapper for this system call, necessitating the use of B<syscall>(2).)"
msgstr ""

#. type: Plain text
#: build/C/man2/getcpu.2:77
msgid "B<getcpu>()  is Linux-specific."
msgstr "B<getcpu>() は Linux 固有である。"

#. type: Plain text
#: build/C/man2/getcpu.2:85
#, fuzzy
#| msgid ""
#| "Linux makes a best effort to make this call as fast possible.  The "
#| "intention of B<getcpu>()  is to allow programs to make optimizations with "
#| "per-CPU data or for NUMA optimization."
msgid ""
"Linux makes a best effort to make this call as fast as possible.  (On some "
"architectures, this is done via an implementation in the B<vdso>(7).)  The "
"intention of B<getcpu>()  is to allow programs to make optimizations with "
"per-CPU data or for NUMA optimization."
msgstr ""
"Linux はこのシステムコールを可能な限り早く実行しようとする。\n"
"B<getcpu>() は、CPU 毎のデータに対する最適化や NUMA 環境での最適化を\n"
"プログラムが行えるようにすることを目的として実装されているからである。"

#.  commit 4307d1e5ada595c87f9a4d16db16ba5edb70dcb1
#.  Author: Ingo Molnar <mingo@elte.hu>
#.  Date:   Wed Nov 7 18:37:48 2007 +0100
#.  x86: ignore the sys_getcpu() tcache parameter
#.  ===== Before kernel 2.6.24: =====
#.  .I tcache
#.  is a pointer to a
#.  .IR "struct getcpu_cache"
#.  that is used as a cache by
#.  .BR getcpu ().
#.  The caller should put the cache into a thread-local variable
#.  if the process is multithreaded,
#.  because the cache cannot be shared between different threads.
#.  .I tcache
#.  can be NULL.
#.  If it is not NULL
#.  .BR getcpu ()
#.  will use it to speed up operation.
#.  The information inside the cache is private to the system call
#.  and should not be accessed by the user program.
#.  The information placed in the cache can change between kernel releases.
#.  When no cache is specified
#.  .BR getcpu ()
#.  will be slower,
#.  but always retrieve the current CPU and node information.
#.  With a cache
#.  .BR getcpu ()
#.  is faster.
#.  However, the cached information is updated only once per jiffy (see
#.  .BR time (7)).
#.  This means that the information could theoretically be out of date,
#.  although in practice the scheduler's attempt to maintain
#.  soft CPU affinity means that the information is unlikely to change
#.  over the course of the caching interval.
#. type: Plain text
#: build/C/man2/getcpu.2:136
msgid ""
"The I<tcache> argument is unused since Linux 2.6.24.  In earlier kernels, if "
"this argument was non-NULL, then it specified a pointer to a caller-"
"allocated buffer in thread-local storage that was used to provide a caching "
"mechanism for B<getcpu>().  Use of the cache could speed B<getcpu>()  calls, "
"at the cost that there was a very small chance that the returned information "
"would be out of date.  The caching mechanism was considered to cause "
"problems when migrating threads between CPUs, and so the argument is now "
"ignored."
msgstr ""
"I<tcache> 引数は Linux 2.6.24 以降では使用されない。以前のバージョン\n"
"のカーネルでは、この引数が NULL 以外の場合、この引数には、呼び出し\n"
"元が割り当てたスレッド専用の記憶領域 (thread-local storage) 内のバッファー\n"
"を指すポインターが指定され、このバッファーは B<getcpu>() 用のキャッシュ機構\n"
"を提供するために利用されていた。非常に低い確率だが古い情報を返してしま\n"
"うデメリットはあるものの、このキャッシュを使うことで B<getcpu>() システ\n"
"ムコールを高速化できた。このキャッシュ機構はCPU 間でのスレッドの移動時\n"
"に問題になると考えられ、この引数は今では無視されるようになっている。"

#. type: Plain text
#: build/C/man2/getcpu.2:143
msgid ""
"B<mbind>(2), B<sched_setaffinity>(2), B<set_mempolicy>(2), "
"B<sched_getcpu>(3), B<cpuset>(7), B<vdso>(7)"
msgstr "B<mbind>(2), B<sched_setaffinity>(2), B<set_mempolicy>(2), B<sched_getcpu>(3), B<cpuset>(7), B<vdso>(7)"

#. type: TH
#: build/C/man2/mbind.2:35
#, no-wrap
msgid "MBIND"
msgstr "MBIND"

#. type: TH
#: build/C/man2/mbind.2:35 build/C/man2/move_pages.2:20
#, no-wrap
msgid "2020-06-09"
msgstr "2020-06-09"

#. type: Plain text
#: build/C/man2/mbind.2:38
msgid "mbind - set memory policy for a memory range"
msgstr "mbind - メモリー領域に対してメモリーポリシーを設定する"

#. type: Plain text
#: build/C/man2/mbind.2:41 build/C/man2/migrate_pages.2:24
#: build/C/man2/move_pages.2:26 build/C/man2/set_mempolicy.2:33
#, no-wrap
msgid "B<#include E<lt>numaif.hE<gt>>\n"
msgstr "B<#include E<lt>numaif.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/mbind.2:45
#, no-wrap
msgid ""
"B<long mbind(void *>I<addr>B<, unsigned long >I<len>B<, int >I<mode>B<,>\n"
"B<           const unsigned long *>I<nodemask>B<, unsigned long >I<maxnode>B<,>\n"
"B<           unsigned >I<flags>B<);>\n"
msgstr ""
"B<long mbind(void *>I<addr>B<, unsigned long >I<len>B<, int >I<mode>B<,>\n"
"B<           const unsigned long *>I<nodemask>B<, unsigned long >I<maxnode>B<,>\n"
"B<           unsigned >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man2/mbind.2:58
msgid ""
"B<mbind>()  sets the NUMA memory policy, which consists of a policy mode and "
"zero or more nodes, for the memory range starting with I<addr> and "
"continuing for I<len> bytes.  The memory policy defines from which node "
"memory is allocated."
msgstr ""
"B<mbind>()  は、 I<addr> から始まる長さ I<len> バイトの範囲のメモリーに NUMA "
"メモリーポリシーを設定する。 NUMA ポリシーはポリシーモードと 0 個以上のノード"
"から構成される。 メモリーポリシーはどのノードからメモリーを割り当てるかを決定"
"する。"

#. type: Plain text
#: build/C/man2/mbind.2:80
msgid ""
"If the memory range specified by the I<addr> and I<len> arguments includes "
"an \"anonymous\" region of memory\\(emthat is a region of memory created "
"using the B<mmap>(2)  system call with the B<MAP_ANONYMOUS>\\(emor a memory-"
"mapped file, mapped using the B<mmap>(2)  system call with the "
"B<MAP_PRIVATE> flag, pages will be allocated only according to the specified "
"policy when the application writes (stores) to the page.  For anonymous "
"regions, an initial read access will use a shared page in the kernel "
"containing all zeros.  For a file mapped with B<MAP_PRIVATE>, an initial "
"read access will allocate pages according to the memory policy of the thread "
"that causes the page to be allocated.  This may not be the thread that "
"called B<mbind>()."
msgstr "I<addr> と I<len> で指定されたメモリー範囲に、 メモリーの「無名」領域 \\(em B<MAP_ANONYMOUS> 付きの B<mmap>(2)  システムコールを使って作成されたメモリー領域 \\(em や B<MAP_PRIVATE> 付きの B<mmap>(2)  を使ってマップされたメモリーマップファイルが含まれている場合、アプリケーションがそのページへの書き込み (データの格納) を行った時には指定されたポリシーのみに基づいてページが割り当てられる。無名領域の場合、最初の読み出しアクセスの際には カーネル内の全データが 0 である共有ページが使用される。 B<MAP_PRIVATE> でマップされたファイルの場合、最初の読み出しアクセスがあると、 ページ割り当てが発生するきっかけとなったスレッドのメモリポリシーにしたがってページの割り当てが行われる。 ページ割り当てのきっかけとなったスレッドは、 B<mbind>() を呼び出したスレッドと同じとは限らない。"

#. type: Plain text
#: build/C/man2/mbind.2:88
msgid ""
"The specified policy will be ignored for any B<MAP_SHARED> mappings in the "
"specified memory range.  Rather the pages will be allocated according to the "
"memory policy of the thread that caused the page to be allocated.  Again, "
"this may not be the thread that called B<mbind>()."
msgstr "指定されたメモリー範囲内にある B<MAP_SHARED> のマッピングでは指定されたポリシーは無視され、 ページ割り当てが発生するきっかけとなったスレッドのメモリポリシーに したがってページの割り当てが行われることになる。 繰り返しになるが、ページ割り当てのきっかけとなったスレッドは、 B<mbind>()  を呼び出したスレッドと同じとは限らない。"

#. type: Plain text
#: build/C/man2/mbind.2:105
msgid ""
"If the specified memory range includes a shared memory region created using "
"the B<shmget>(2)  system call and attached using the B<shmat>(2)  system "
"call, pages allocated for the anonymous or shared memory region will be "
"allocated according to the policy specified, regardless of which process "
"attached to the shared memory segment causes the allocation.  If, however, "
"the shared memory region was created with the B<SHM_HUGETLB> flag, the huge "
"pages will be allocated according to the policy specified only if the page "
"allocation is caused by the process that calls B<mbind>()  for that region."
msgstr ""
"指定されたメモリー範囲に、 B<shmget>(2)  システムコールを使って作成された"
"り、 B<shmat>(2)  システムコールを使って付加 (attach) されたりした共有メモ"
"リー領域が 含まれる場合、無名メモリー領域や共有メモリー領域に対するページ割り"
"当ては、 共有メモリーセグメントへポリシーの設定を行ったプロセスがページ割り当"
"て のきっかけとなったかに関わらず、指定されたポリシーにしたがって割り当て が"
"行われる。 しかしながら、共有メモリー領域が B<SHM_HUGETLB> フラグを指定して作"
"成された場合には、ヒュージページ (huge page) の割り当てが 指定されたポリシー"
"にしたがって行われるのは、その領域に対して B<mbind>()  を呼び出したプロセスが"
"ページ割り当てのきっかけとなった場合のみである。"

#. type: Plain text
#: build/C/man2/mbind.2:116
msgid ""
"By default, B<mbind>()  has an effect only for new allocations; if the pages "
"inside the range have been already touched before setting the policy, then "
"the policy has no effect.  This default behavior may be overridden by the "
"B<MPOL_MF_MOVE> and B<MPOL_MF_MOVE_ALL> flags described below."
msgstr ""
"デフォルトでは、 B<mbind>()  は新規のメモリー割り当てに対してのみ効果を持"
"つ。 ポリシーが設定される前にすでに使用されている範囲内のページに対しては、 "
"ポリシーは影響しない。 このデフォルトの動作は、以下で説明するフラグ "
"B<MPOL_MF_MOVE> や B<MPOL_MF_MOVE_ALL> により上書きされる可能性がある。"

#. type: Plain text
#: build/C/man2/mbind.2:133
msgid ""
"The I<mode> argument must specify one of B<MPOL_DEFAULT>, B<MPOL_BIND>, "
"B<MPOL_INTERLEAVE>, B<MPOL_PREFERRED>, or B<MPOL_LOCAL> (which are described "
"in detail below).  All policy modes except B<MPOL_DEFAULT> require the "
"caller to specify the node or nodes to which the mode applies, via the "
"I<nodemask> argument."
msgstr "I<mode> 引数には、 B<MPOL_DEFAULT>, B<MPOL_BIND>, B<MPOL_INTERLEAVE>, B<MPOL_PREFERRED>, B<MPOL_LOCAL> (詳細は下記参照) のいずれか一つを指定しなければならない。 B<MPOL_DEFAULT> 以外のポリシーモードの場合、呼び出し元は I<nodemask> 引数でそのポリシーモードを適用するノードを指定する必要がある。"

#. type: Plain text
#: build/C/man2/mbind.2:141 build/C/man2/set_mempolicy.2:100
msgid ""
"The I<mode> argument may also include an optional I<mode flag>.  The "
"supported I<mode flags> are:"
msgstr ""
"I<mode> 引数には、追加で I<モードフラグ> を含めることもできる。 サポートさ"
"れている I<モードフラグ> は以下の通りである。"

#. type: TP
#: build/C/man2/mbind.2:141
#, no-wrap
msgid "B<MPOL_F_STATIC_NODES> (since Linux-2.6.26)"
msgstr "B<MPOL_F_STATIC_NODES> (Linux-2.6.26 以降)"

#. type: Plain text
#: build/C/man2/mbind.2:151
msgid ""
"A nonempty I<nodemask> specifies physical node IDs.  Linux does not remap "
"the I<nodemask> when the thread moves to a different cpuset context, nor "
"when the set of nodes allowed by the thread's current cpuset context changes."
msgstr "空でない I<nodemask> は、物理ノード ID である。 Linux では、そのスレッドが異なる CPU 集合コンテキスト (cpuset context)  に移動した場合でも、そのスレッドの現在の CPU 集合コンテキストで 許可されているノード集合が変化した場合でも、 I<nodemask> をマッピングし直すことはない。"

#. type: TP
#: build/C/man2/mbind.2:151
#, no-wrap
msgid "B<MPOL_F_RELATIVE_NODES> (since Linux-2.6.26)"
msgstr "B<MPOL_F_RELATIVE_NODES> (Linux-2.6.26 以降)"

#. type: Plain text
#: build/C/man2/mbind.2:157
msgid ""
"A nonempty I<nodemask> specifies node IDs that are relative to the set of "
"node IDs allowed by the thread's current cpuset."
msgstr "空でない I<nodemask> は、そのスレッドの現在の CPU 集合で許可されているノード ID 集合 における相対的なノード ID である。"

#. type: Plain text
#: build/C/man2/mbind.2:185
msgid ""
"I<nodemask> points to a bit mask of nodes containing up to I<maxnode> bits.  "
"The bit mask size is rounded to the next multiple of I<sizeof(unsigned "
"long)>, but the kernel will use bits only up to I<maxnode>.  A NULL value of "
"I<nodemask> or a I<maxnode> value of zero specifies the empty set of nodes.  "
"If the value of I<maxnode> is zero, the I<nodemask> argument is ignored.  "
"Where a I<nodemask> is required, it must contain at least one node that is "
"on-line, allowed by the thread's current cpuset context (unless the "
"B<MPOL_F_STATIC_NODES> mode flag is specified), and contains memory."
msgstr "I<nodemask> は、最大で I<maxnode> ビットから構成されるノードのビットマスクを指す。 ビットマスクの大きさは、直近の I<sizeof(unsigned long)> の倍数に切り上げられるが、カーネルが使用するのは I<maxnode> 個までのビットだけである。 NULL 値の I<nodemask> もしくは値が 0 の I<maxnode> はノードの空集合を表す。 I<maxnode> の値が 0 の場合、 I<nodemask> 引数は無視される。 I<nodemask> が必須の場面では、 I<nodemask> に、オンラインで、そのスレッドの現在の CPU 集合コンテキストで 許可されており (B<MPOL_F_STATIC_NODES> モードフラグが指定されていない場合)、メモリーがあるノードが 少なくとも一つ入っていなければならない。"

#. type: Plain text
#: build/C/man2/mbind.2:189 build/C/man2/set_mempolicy.2:161
msgid "The I<mode> argument must include one of the following values:"
msgstr "I<mode> 引数には、以下の値のいずれかひとつを含めなければならない。"

#. type: TP
#: build/C/man2/mbind.2:189 build/C/man2/set_mempolicy.2:161
#, no-wrap
msgid "B<MPOL_DEFAULT>"
msgstr "B<MPOL_DEFAULT>"

#. type: Plain text
#: build/C/man2/mbind.2:210
msgid ""
"This mode requests that any nondefault policy be removed, restoring default "
"behavior.  When applied to a range of memory via B<mbind>(), this means to "
"use the thread memory policy, which may have been set with "
"B<set_mempolicy>(2).  If the mode of the thread memory policy is also "
"B<MPOL_DEFAULT>, the system-wide default policy will be used.  The system-"
"wide default policy allocates pages on the node of the CPU that triggers the "
"allocation.  For B<MPOL_DEFAULT>, the I<nodemask> and I<maxnode> arguments "
"must be specify the empty set of nodes."
msgstr "このモードはデフォルトではないメモリーポリシーを削除し、 デフォルトの動作に戻すことを指定するものである。 B<mbind>()  経由で、あるメモリー領域に対して B<MPOL_DEFAULT> が適用された場合、スレッドのメモリポリシーを使用することを意味する。 スレッドのメモリポリシーは、 B<set_mempolicy>(2)  で変更されているかもしれない。 スレッドのメモリポリシーのモードも B<MPOL_DEFAULT> の場合、システム全体のデフォルトポリシーが使用される。 システム全体のデフォルトポリシーでは、割り当てのきっかけとなった CPU のノードからページの割り当てを行う。 B<MPOL_DEFAULT> では、引数 I<nodemask> と I<maxnode> にノードの空集合を指定しなければならない。"

#. type: TP
#: build/C/man2/mbind.2:210 build/C/man2/set_mempolicy.2:171
#, no-wrap
msgid "B<MPOL_BIND>"
msgstr "B<MPOL_BIND>"

#.  commit 19770b32609b6bf97a3dece2529089494cbfc549
#. type: Plain text
#: build/C/man2/mbind.2:231
#, fuzzy
#| msgid ""
#| "The B<MPOL_BIND> mode specifies a strict policy that restricts memory "
#| "allocation to the nodes specified in I<nodemask>.  If I<nodemask> "
#| "specifies more than one node, page allocations will come from the node "
#| "with the lowest numeric node ID first, until that node contains no free "
#| "memory.  Allocations will then come from the node with the next highest "
#| "node ID specified in I<nodemask> and so forth, until none of the "
#| "specified nodes contain free memory.  Pages will not be allocated from "
#| "any node not specified in the I<nodemask>."
msgid ""
"This mode specifies a strict policy that restricts memory allocation to the "
"nodes specified in I<nodemask>.  If I<nodemask> specifies more than one "
"node, page allocations will come from the node with sufficient free memory "
"that is closest to the node where the allocation takes place.  Pages will "
"not be allocated from any node not specified in the IR nodemask .  (Before "
"Linux 2.6.26, page allocations came from the node with the lowest numeric "
"node ID first, until that node contained no free memory.  Allocations then "
"came from the node with the next highest node ID specified in I<nodemask> "
"and so forth, until none of the specified nodes contained free memory.)"
msgstr ""
"B<MPOL_BIND> は厳しいポリシーで、メモリー割り当ては I<nodemask> に指定された"
"ノードに限定される。 他のノードへの割り当ては行われない。 I<nodemask> に 2 個"
"以上のノードが指定された場合、ページの割り当ては ノード ID が数字として最小の"
"ノードから開始され、 そのノードに空きメモリーがなくなるまでそのノードから "
"ページ割り当てが行われる。そのノードに空きメモリーがなくなったら、 次に小さな"
"ノード ID を持つノードからページ割り当てが行われる。 これを、 I<nodemask> で"
"指定された全てのノードで空きメモリーがなくなるまで繰り返す。 I<nodemask> で指"
"定された以外のノードからはページの割り当ては行われない。"

#. type: TP
#: build/C/man2/mbind.2:231 build/C/man2/set_mempolicy.2:187
#, no-wrap
msgid "B<MPOL_INTERLEAVE>"
msgstr "B<MPOL_INTERLEAVE>"

#. type: Plain text
#: build/C/man2/mbind.2:243
msgid ""
"This mode specifies that page allocations be interleaved across the set of "
"nodes specified in I<nodemask>.  This optimizes for bandwidth instead of "
"latency by spreading out pages and memory accesses to those pages across "
"multiple nodes.  To be effective the memory area should be fairly large, at "
"least 1\\ MB or bigger with a fairly uniform access pattern.  Accesses to a "
"single page of the area will still be limited to the memory bandwidth of a "
"single node."
msgstr "このモードは、メモリー割り当てが I<nodemask> に指定されたノード間で交互に行われることを指定するものである。 このポリシーでは、複数のノードにページを広げて配置し、これらのページへの メモリーアクセスを分散することで、遅延ではなく、帯域を最適化する。 効果を得るには、メモリー領域をある程度大きくすべきであり、 メモリーアクセスのパターンがかなり均一な場合でも 少なくとも 1\\ MB 以上にすべきである。 このモードでも、一つのページへのアクセスに関しては 一つのノードのメモリー帯域が上限となることは変わりない。"

#. type: TP
#: build/C/man2/mbind.2:243 build/C/man2/set_mempolicy.2:201
#, no-wrap
msgid "B<MPOL_PREFERRED>"
msgstr "B<MPOL_PREFERRED>"

#. type: Plain text
#: build/C/man2/mbind.2:259
msgid ""
"This mode sets the preferred node for allocation.  The kernel will try to "
"allocate pages from this node first and fall back to other nodes if the "
"preferred nodes is low on free memory.  If I<nodemask> specifies more than "
"one node ID, the first node in the mask will be selected as the preferred "
"node.  If the I<nodemask> and I<maxnode> arguments specify the empty set, "
"then the memory is allocated on the node of the CPU that triggered the "
"allocation."
msgstr "このモードは、割り当て時に優先されるノードを設定する。 カーネルはまず優先ノードにページ割り当てを行おうとし、 優先ノードに空きメモリーが少ない場合に他のノードに割り当てを行う。 I<nodemask> に複数のノード ID が指定された場合は、 I<nodemask> 内の最初のノードが優先ノードとして選択される。 引数 I<nodemask>, I<maxnode> で空集合が指定された場合は、割り当てのきっかけとなった CPU のノードに メモリー割り当てが行われる。"

#. type: TP
#: build/C/man2/mbind.2:259 build/C/man2/set_mempolicy.2:218
#, no-wrap
msgid "B<MPOL_LOCAL> (since Linux 3.8)"
msgstr "B<MPOL_LOCAL> (Linux 3.8 以降)"

#.  commit 479e2802d09f1e18a97262c4c6f8f17ae5884bd8
#.  commit f2a07f40dbc603c15f8b06e6ec7f768af67b424f
#. type: Plain text
#: build/C/man2/mbind.2:283
msgid ""
"This mode specifies \"local allocation\"; the memory is allocated on the "
"node of the CPU that triggered the allocation (the \"local node\").  The "
"I<nodemask> and I<maxnode> arguments must specify the empty set.  If the "
"\"local node\" is low on free memory, the kernel will try to allocate memory "
"from other nodes.  The kernel will allocate memory from the \"local node\" "
"whenever memory for this node is available.  If the \"local node\" is not "
"allowed by the thread's current cpuset context, the kernel will try to "
"allocate memory from other nodes.  The kernel will allocate memory from the "
"\"local node\" whenever it becomes allowed by the thread's current cpuset "
"context.  By contrast, B<MPOL_DEFAULT> reverts to the memory policy of the "
"thread (which may be set via B<set_mempolicy>(2)); that policy may be "
"something other than \"local allocation\"."
msgstr ""

#.  According to the kernel code, the following is not true
#.  --Lee Schermerhorn
#.  In 2.6.16 or later the kernel will also try to move pages
#.  to the requested node with this flag.
#. type: Plain text
#: build/C/man2/mbind.2:299
msgid ""
"If B<MPOL_MF_STRICT> is passed in I<flags> and I<mode> is not "
"B<MPOL_DEFAULT>, then the call fails with the error B<EIO> if the existing "
"pages in the memory range don't follow the policy."
msgstr ""
"I<flags> に B<MPOL_MF_STRICT> が 指定され、 I<mode> が B<MPOL_DEFAULT> でない"
"場合、 指定されたポリシーに従っていないメモリー領域にページが存在すると、 "
"B<mbind>()  はエラー B<EIO> で失敗する。"

#. type: Plain text
#: build/C/man2/mbind.2:312
msgid ""
"If B<MPOL_MF_MOVE> is specified in I<flags>, then the kernel will attempt to "
"move all the existing pages in the memory range so that they follow the "
"policy.  Pages that are shared with other processes will not be moved.  If "
"B<MPOL_MF_STRICT> is also specified, then the call fails with the error "
"B<EIO> if some pages could not be moved."
msgstr ""
"I<flags> に B<MPOL_MF_MOVE> が指定されると、カーネルはそのメモリー領域内の既"
"存の全てのページを移動し、 指定されたポリシーに従うようにしようとする。 他の"
"プロセスと共有されているページは移動されない。 B<MPOL_MF_STRICT> も指定された"
"場合、移動できなかったページがあると、 B<mbind>()  はエラー B<EIO> で失敗す"
"る。"

#.  ---------------------------------------------------------------
#. type: Plain text
#: build/C/man2/mbind.2:328
msgid ""
"If B<MPOL_MF_MOVE_ALL> is passed in I<flags>, then the kernel will attempt "
"to move all existing pages in the memory range regardless of whether other "
"processes use the pages.  The calling thread must be privileged "
"(B<CAP_SYS_NICE>)  to use this flag.  If B<MPOL_MF_STRICT> is also "
"specified, then the call fails with the error B<EIO> if some pages could not "
"be moved."
msgstr "I<flags> に B<MPOL_MF_MOVE_ALL> が指定されると、カーネルはそのメモリー領域内の既存の全てのページを、 他のプロセスがページを使用しているかどうかに関わらず移動する。 このフラグを使用するには、呼び出し元のスレッドは特権 (B<CAP_SYS_NICE>)  を持っていなければならない。 B<MPOL_MF_STRICT> も指定された場合、移動できなかったページがあると、 B<mbind>()  はエラー B<EIO> で失敗する。"

#.  ---------------------------------------------------------------
#. type: Plain text
#: build/C/man2/mbind.2:336
msgid ""
"On success, B<mbind>()  returns 0; on error, -1 is returned and I<errno> is "
"set to indicate the error."
msgstr ""
"成功すると、 B<mbind>()  は 0 を返す。エラーの場合、-1 を返し、 I<errno> にエ"
"ラーを示す値を設定する。"

#. type: Plain text
#: build/C/man2/mbind.2:349
msgid ""
"Part or all of the memory range specified by I<nodemask> and I<maxnode> "
"points outside your accessible address space.  Or, there was an unmapped "
"hole in the specified memory range specified by I<addr> and I<len>."
msgstr ""
"I<nodemask> と I<maxnode> で指定されたメモリー領域の一部または全部が、 呼び出"
"し元がアクセス可能なアドレス空間外を指している。 もしくは I<addr> と I<len> "
"で指定されたメモリー領域にマップされていない部分 (unmapped hole)  があった、"

#.  As at 2.6.23, this limit is "a page worth of bits", e.g.,
#.  8 * 4096 bits, assuming a 4kB page size.
#. type: Plain text
#: build/C/man2/mbind.2:397
msgid ""
"An invalid value was specified for I<flags> or I<mode>; or I<addr + len> was "
"less than I<addr>; or I<addr> is not a multiple of the system page size.  "
"Or, I<mode> is B<MPOL_DEFAULT> and I<nodemask> specified a nonempty set; or "
"I<mode> is B<MPOL_BIND> or B<MPOL_INTERLEAVE> and I<nodemask> is empty.  Or, "
"I<maxnode> exceeds a kernel-imposed limit.  Or, I<nodemask> specifies one or "
"more node IDs that are greater than the maximum supported node ID.  Or, none "
"of the node IDs specified by I<nodemask> are on-line and allowed by the "
"thread's current cpuset context, or none of the specified nodes contain "
"memory.  Or, the I<mode> argument specified both B<MPOL_F_STATIC_NODES> and "
"B<MPOL_F_RELATIVE_NODES>."
msgstr "I<flags> や I<mode> に不正な値が指定された。 I<addr + len> が I<addr> より小さい。 I<addr> がシステムのページサイズの倍数になっていない。 または I<mode> が B<MPOL_DEFAULT> で I<nodemask> に空でない集合が指定された。 I<mode> が B<MPOL_BIND> か B<MPOL_INTERLEAVE> で I<nodemask> が空であった。 I<maxnode> がカーネルに適用された上限を超えている。 I<nodemask> に、サポートされている最大ノード ID より大きいノードが指定された。 I<nodemask> に、オンラインで、かつそのスレッドの現在の CPU 集合コンテキストで 許可されているノードが一つも含まれていないか、 メモリーを含むノードが一つも指定されていない。 I<mode> 引数に B<MPOL_F_STATIC_NODES> と B<MPOL_F_RELATIVE_NODES> の両方が指定された。"

#. type: TP
#: build/C/man2/mbind.2:397
#, no-wrap
msgid "B<EIO>"
msgstr "B<EIO>"

#. type: Plain text
#: build/C/man2/mbind.2:408
msgid ""
"B<MPOL_MF_STRICT> was specified and an existing page was already on a node "
"that does not follow the policy; or B<MPOL_MF_MOVE> or B<MPOL_MF_MOVE_ALL> "
"was specified and the kernel was unable to move all existing pages in the "
"range."
msgstr ""
"B<MPOL_MF_STRICT> が指定されたが、このポリシーに従っていないノードに すでに"
"ページが存在していた。 もしくは B<MPOL_MF_MOVE> か B<MPOL_MF_MOVE_ALL> が指定"
"されたが、カーネルが指定された領域内の既存の全てのページを 移動することができ"
"なかった。"

#. type: TP
#: build/C/man2/mbind.2:408 build/C/man2/set_mempolicy.2:296
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
#: build/C/man2/mbind.2:411 build/C/man2/set_mempolicy.2:299
msgid "Insufficient kernel memory was available."
msgstr "利用可能なカーネルメモリーが十分でなかった。"

#. type: TP
#: build/C/man2/mbind.2:411 build/C/man2/migrate_pages.2:121
#: build/C/man2/move_pages.2:203
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#.  ---------------------------------------------------------------
#. type: Plain text
#: build/C/man2/mbind.2:421
msgid ""
"The I<flags> argument included the B<MPOL_MF_MOVE_ALL> flag and the caller "
"does not have the B<CAP_SYS_NICE> privilege."
msgstr ""
"I<flags> 引数に B<MPOL_MF_MOVE_ALL> フラグが含まれているが、呼び出し元が "
"B<CAP_SYS_NICE> 特権を持たない。"

#. type: Plain text
#: build/C/man2/mbind.2:425
msgid ""
"The B<mbind>()  system call was added to the Linux kernel in version 2.6.7."
msgstr ""
"B<mbind>()  システムコールはバージョン 2.6.7 で Linux カーネルに追加された。"

#. type: Plain text
#: build/C/man2/mbind.2:435
msgid ""
"NUMA policy is not supported on a memory-mapped file range that was mapped "
"with the B<MAP_SHARED> flag."
msgstr ""
"NUMA ポリシーは、 B<MAP_SHARED> フラグが指定されてマップされたメモリーマップ"
"ファイルの領域では サポートされていない。"

#. type: Plain text
#: build/C/man2/mbind.2:469
msgid ""
"The B<MPOL_DEFAULT> mode can have different effects for B<mbind>()  and "
"B<set_mempolicy>(2).  When B<MPOL_DEFAULT> is specified for "
"B<set_mempolicy>(2), the thread's memory policy reverts to the system "
"default policy or local allocation.  When B<MPOL_DEFAULT> is specified for a "
"range of memory using B<mbind>(), any pages subsequently allocated for that "
"range will use the thread's memory policy, as set by B<set_mempolicy>(2).  "
"This effectively removes the explicit policy from the specified range, "
"\"falling back\" to a possibly nondefault policy.  To select explicit "
"\"local allocation\" for a memory range, specify a I<mode> of B<MPOL_LOCAL> "
"or B<MPOL_PREFERRED> with an empty set of nodes.  This method will work for "
"B<set_mempolicy>(2), as well."
msgstr "B<MPOL_DEFAULT> モードは、 B<mbind>()  と B<set_mempolicy>(2)  で異なる効果を持つことができる。 B<set_mempolicy>(2)  で B<MPOL_DEFAULT> が指定された場合、そのスレッドのメモリポリシーはシステムの デフォルトポリシー、すなわちローカルからの割り当て、に戻る。 B<mbind>()  を使ってメモリーのある領域に B<MPOL_DEFAULT> が指定された場合、その範囲に対してそれ以降に行われるページの割り当てでは、 B<set_mempolicy>(2)  で設定したのと同じように、そのスレッドのメモリポリシーが適用される。 これにより、特定のメモリー領域についてだけ明示的なポリシーを削除し、 デフォルトのポリシーに「戻す」ことができる。 あるメモリー領域に対して「ローカルからの割り当て」を明示的に設定するには、 I<mode> に B<MPOL_LOCAL> か B<MPOL_PREFERRED> を指定し、 I<nodemask> に空集合のノードを指定すればよい。 この方法は B<set_mempolicy>(2)  でも通用する。"

#. type: Plain text
#: build/C/man2/mbind.2:473
msgid ""
"Support for huge page policy was added with 2.6.16.  For interleave policy "
"to be effective on huge page mappings the policied memory needs to be tens "
"of megabytes or larger."
msgstr ""
"2.6.16 でヒュージページポリシーへの対応が追加された。 インターリーブポリシー"
"がヒュージページのマッピングで効果を持つには、 ポリシーが適用されるメモリーが"
"数十メガバイト以上である必要がある。"

#.  commit dcf1763546d76c372f3136c8d6b2b6e77f140cf0
#. type: Plain text
#: build/C/man2/mbind.2:478
msgid "Before Linux 5.7.  B<MPOL_MF_STRICT> was ignored on huge page mappings."
msgstr "Linux 5.7 より前では、 B<MPOL_MF_STRICT> はヒュージページのマッピングでは無視されていた。"

#. type: Plain text
#: build/C/man2/mbind.2:483
msgid ""
"B<MPOL_MF_MOVE> and B<MPOL_MF_MOVE_ALL> are available only on Linux 2.6.16 "
"and later."
msgstr ""
"B<MPOL_MF_MOVE> と B<MPOL_MF_MOVE_ALL> は Linux 2.6.16 以降でのみ利用可能であ"
"る。"

#. type: Plain text
#: build/C/man2/mbind.2:494
msgid ""
"B<get_mempolicy>(2), B<getcpu>(2), B<mmap>(2), B<set_mempolicy>(2), "
"B<shmat>(2), B<shmget>(2), B<numa>(3), B<cpuset>(7), B<numa>(7), "
"B<numactl>(8)"
msgstr ""
"B<get_mempolicy>(2), B<getcpu>(2), B<mmap>(2), B<set_mempolicy>(2),\n"
"B<shmat>(2), B<shmget>(2), B<numa>(3), B<cpuset>(7), B<numa>(7),\n"
"B<numactl>(8)"

#. type: TH
#: build/C/man2/migrate_pages.2:18
#, no-wrap
msgid "MIGRATE_PAGES"
msgstr "MIGRATE_PAGES"

#. type: Plain text
#: build/C/man2/migrate_pages.2:21
msgid "migrate_pages - move all pages in a process to another set of nodes"
msgstr "migrate_pages - プロセスの全ページを別のノード集合に移動する"

#. type: Plain text
#: build/C/man2/migrate_pages.2:28
#, no-wrap
msgid ""
"B<long migrate_pages(int >I<pid>B<, unsigned long >I<maxnode,>\n"
"B<                   const unsigned long *>I<old_nodes,>\n"
"B<                   const unsigned long *>I<new_nodes>B<);>\n"
msgstr ""
"B<long migrate_pages(int >I<pid>B<, unsigned long >I<maxnode,>\n"
"B<                   const unsigned long *>I<old_nodes,>\n"
"B<                   const unsigned long *>I<new_nodes>B<);>\n"

#. type: Plain text
#: build/C/man2/migrate_pages.2:31 build/C/man2/move_pages.2:32
msgid "Link with I<-lnuma>."
msgstr "I<-lnuma> とリンクする。"

#. type: Plain text
#: build/C/man2/migrate_pages.2:47
msgid ""
"B<migrate_pages>()  attempts to move all pages of the process I<pid> that "
"are in memory nodes I<old_nodes> to the memory nodes in I<new_nodes>.  Pages "
"not located in any node in I<old_nodes> will not be migrated.  As far as "
"possible, the kernel maintains the relative topology relationship inside "
"I<old_nodes> during the migration to I<new_nodes>."
msgstr ""
"B<MIGRATE_PAGES>() は、メモリーノード I<old_nodes> にあるプロセス I<pid>\n"
"の全ページを、メモリーノード I<new_nodes> に移動しようとする。I<old_nodes> "
"で\n"
"指定されたメモリーノードに置かれていないページは移動されない。\n"
"カーネルは、 I<new_nodes> への移動の際に、 I<old_nodes> 内の相対的な\n"
"トポロジー関係を可能な限り維持しようとする。"

#. type: Plain text
#: build/C/man2/migrate_pages.2:69
msgid ""
"The I<old_nodes> and I<new_nodes> arguments are pointers to bit masks of "
"node numbers, with up to I<maxnode> bits in each mask.  These masks are "
"maintained as arrays of unsigned I<long> integers (in the last I<long> "
"integer, the bits beyond those specified by I<maxnode> are ignored).  The "
"I<maxnode> argument is the maximum node number in the bit mask plus one "
"(this is the same as in B<mbind>(2), but different from B<select>(2))."
msgstr ""
"引数 I<old_nodes> と I<new_nodes> は、最大で I<maxnode> ビットから\n"
"構成されるノード番号のビットマスクへのポインターである。\n"
"各ビットマスクは符号なし I<long> 整数の配列として管理される\n"
"(I<maxnode> で指定された長さを越えた部分のビットは無視される)。\n"
"引数 I<maxnode> は最大ノード番号であり、ビットマスクの長さに 1 を\n"
"加えた値となる (これは B<mbind>(2) と同じだが、 B<select>(2) とは違う)。"

#. type: Plain text
#: build/C/man2/migrate_pages.2:83
msgid ""
"The I<pid> argument is the ID of the process whose pages are to be moved.  "
"To move pages in another process, the caller must be privileged "
"(B<CAP_SYS_NICE>)  or the real or effective user ID of the calling process "
"must match the real or saved-set user ID of the target process.  If I<pid> "
"is 0, then B<migrate_pages>()  moves pages of the calling process."
msgstr ""
"引数 I<pid> は、移動を行うページの所有者のプロセス ID である。\n"
"別のプロセスのページを移動するには、呼び出したプロセスが特権\n"
"(B<CAP_SYS_NICE>) を持っているか、呼び出したプロセスの実ユーザー ID か\n"
"実効ユーザー ID がページ移動の対象プロセスの実ユーザー ID か saved-set \n"
"ユーザー ID と一致していなければならない。I<pid> が 0 の場合、\n"
"B<migrate_pages>() は呼び出したプロセスのページを移動する。"

#. type: Plain text
#: build/C/man2/migrate_pages.2:88
msgid ""
"Pages shared with another process will be moved only if the initiating "
"process has the B<CAP_SYS_NICE> privilege."
msgstr ""
"別のプロセスと共有しているページは、呼び出したプロセスが\n"
"B<CAP_SYS_NICE> 特権を持っている場合にのみ移動される。"

#. type: Plain text
#: build/C/man2/migrate_pages.2:96
msgid ""
"On success B<migrate_pages>()  returns the number of pages that could not be "
"moved (i.e., a return of zero means that all pages were successfully "
"moved).  On error, it returns -1, and sets I<errno> to indicate the error."
msgstr ""
"B<migrate_pages>() は、移動できなかったページ数を返す\n"
"(つまり、移動に成功した場合は返り値は 0 となる)。\n"
"エラーの場合、 -1 を返し、 I<errno> にエラーを示す値を設定する。"

#. type: Plain text
#: build/C/man2/migrate_pages.2:104
msgid ""
"Part or all of the memory range specified by I<old_nodes>/I<new_nodes> and "
"I<maxnode> points outside your accessible address space."
msgstr "I<old_nodes>/I<new_nodes> と I<maxnode> で指定されたメモリー領域の一部または全部が、 呼び出し元がアクセス可能なアドレス空間外を指している。"

#.  As at 3.5, this limit is "a page worth of bits", e.g.,
#.  8 * 4096 bits, assuming a 4kB page size.
#. type: Plain text
#: build/C/man2/migrate_pages.2:121
#, fuzzy
#| msgid ""
#| "I<mode> is invalid.  Or, I<mode> is B<MPOL_DEFAULT> and I<nodemask> is "
#| "nonempty, or I<mode> is B<MPOL_BIND> or B<MPOL_INTERLEAVE> and "
#| "I<nodemask> is empty.  Or, I<maxnode> specifies more than a page worth of "
#| "bits.  Or, I<nodemask> specifies one or more node IDs that are greater "
#| "than the maximum supported node ID.  Or, none of the node IDs specified "
#| "by I<nodemask> are on-line and allowed by the process's current cpuset "
#| "context, or none of the specified nodes contain memory.  Or, the I<mode> "
#| "argument specified both B<MPOL_F_STATIC_NODES> and "
#| "B<MPOL_F_RELATIVE_NODES>."
msgid ""
"The value specified by I<maxnode> exceeds a kernel-imposed limit.  Or, "
"I<old_nodes> or I<new_nodes> specifies one or more node IDs that are greater "
"than the maximum supported node ID.  Or, none of the node IDs specified by "
"I<new_nodes> are on-line and allowed by the process's current cpuset "
"context, or none of the specified nodes contain memory."
msgstr ""
"I<mode> が不正である。 I<mode> が B<MPOL_DEFAULT> で、 I<nodemask> が空ではな"
"い。 I<mode> が B<MPOL_BIND> か B<MPOL_INTERLEAVE> で、 I<nodemask> が空であ"
"る。 I<maxnode> で実際に意味があるビット数より多くのビット数が指定された。 "
"I<nodemask> に、サポートされている最大ノード ID より大きいノードが指定され"
"た。 I<nodemask> に、オンラインで、かつそのプロセスの現在の CPU 集合コンテキ"
"ストで 許可されているノードが一つも含まれていないか、 メモリーを含むノードが"
"一つも指定されていない。 I<mode> 引数に B<MPOL_F_STATIC_NODES> と "
"B<MPOL_F_RELATIVE_NODES> の両方が指定された。"

#. type: Plain text
#: build/C/man2/migrate_pages.2:130
msgid ""
"Insufficient privilege (B<CAP_SYS_NICE>)  to move pages of the process "
"specified by I<pid>, or insufficient privilege (B<CAP_SYS_NICE>)  to access "
"the specified target nodes."
msgstr ""
"I<pid> で指定されたプロセスのページを移動するのに必要な特権\n"
"(B<CAP_SYS_NICE>) がなかった。または、指定された対象ノードにアクセス\n"
"するのに必要な権限 (B<CAP_SYS_NICE>) がなかった。"

#. type: TP
#: build/C/man2/migrate_pages.2:130 build/C/man2/move_pages.2:212
#, no-wrap
msgid "B<ESRCH>"
msgstr "B<ESRCH>"

#.  FIXME Document the other errors that can occur for migrate_pages()
#. type: Plain text
#: build/C/man2/migrate_pages.2:136
msgid "No process matching I<pid> could be found."
msgstr "プロセス ID が I<pid> のプロセスが見つからなかった。"

#. type: Plain text
#: build/C/man2/migrate_pages.2:140
msgid ""
"The B<migrate_pages>()  system call first appeared on Linux in version "
"2.6.16."
msgstr "B<migrate_pages>() システムコールは Linux 2.6.16 で初めて登場した。"

#. type: Plain text
#: build/C/man2/migrate_pages.2:154
msgid ""
"Use B<get_mempolicy>(2)  with the B<MPOL_F_MEMS_ALLOWED> flag to obtain the "
"set of nodes that are allowed by the calling process's cpuset.  Note that "
"this information is subject to change at any time by manual or automatic "
"reconfiguration of the cpuset."
msgstr ""
"呼び出し元プロセスの CPU 集合で許可されているノード集合を取得するには、\n"
"B<MPOL_F_MEMS_ALLOWED> フラグを付けて B<get_mempolicy>(2) を使うこと。\n"
"この情報は、手動/自動に限らず CPU 集合の再構成によりいつでも\n"
"変更されることがある点に注意してほしい。"

#. type: Plain text
#: build/C/man2/migrate_pages.2:166
msgid ""
"Use of B<migrate_pages>()  may result in pages whose location (node) "
"violates the memory policy established for the specified addresses (see "
"B<mbind>(2))  and/or the specified process (see B<set_mempolicy>(2)).  That "
"is, memory policy does not constrain the destination nodes used by "
"B<migrate_pages>()."
msgstr ""
"B<migrate_pages> を使用すると、ページが置かれる場所 (ノード) が、指定\n"
"されたアドレスに対して設定されたメモリーポリシー (B<mbind>(2) 参照) や\n"
"指定されたプロセスに対して設定されたメモリーポリシー\n"
"(B<set_mempolicy>(2) 参照) に違反する状況になる可能性がある。\n"
"すなわち、メモリーポリシーによる制約は B<migrate_pages>() による移動先\n"
"ノードの選択には適用されないということである。"

#. type: Plain text
#: build/C/man2/migrate_pages.2:172 build/C/man2/move_pages.2:250
msgid ""
"The I<E<lt>numaif.hE<gt>> header is not included with glibc, but requires "
"installing I<libnuma-devel> or a similar package."
msgstr ""
"ヘッダーファイル I<E<lt>numaif.hE<gt>> は glibc には含まれておらず、 "
"I<libnuma-devel> か同様のパッケージをインストールする必要がある。"

#. type: Plain text
#: build/C/man2/migrate_pages.2:182 build/C/man2/move_pages.2:260
msgid ""
"B<get_mempolicy>(2), B<mbind>(2), B<set_mempolicy>(2), B<numa>(3), "
"B<numa_maps>(5), B<cpuset>(7), B<numa>(7), B<migratepages>(8), B<numastat>(8)"
msgstr ""
"B<get_mempolicy>(2), B<mbind>(2), B<set_mempolicy>(2), B<numa>(3), "
"B<numa_maps>(5), B<cpuset>(7), B<numa>(7), B<migratepages>(8), B<numastat>(8)"

#. type: Plain text
#: build/C/man2/migrate_pages.2:185
msgid "I<Documentation/vm/page_migration.rst> in the Linux kernel source tree"
msgstr "Linux カーネルソースの I<Documentation/vm/page_migration.rst>"

#. type: TH
#: build/C/man2/move_pages.2:20
#, no-wrap
msgid "MOVE_PAGES"
msgstr "MOVE_PAGES"

#. type: Plain text
#: build/C/man2/move_pages.2:23
msgid "move_pages - move individual pages of a process to another node"
msgstr "move_pages - あるプロセスの個々のページを別のノードに移動する"

#. type: Plain text
#: build/C/man2/move_pages.2:29
#, no-wrap
msgid ""
"B<long move_pages(int >I<pid>B<, unsigned long count, void **>I<pages>B<,>\n"
"B<                const int *>I<nodes>B<, int *>I<status>B<, int >I<flags>B<);>\n"
msgstr ""
"B<long move_pages(int >I<pid>B<, unsigned long count, void **>I<pages>B<,>\n"
"B<                const int *>I<nodes>B<, int *>I<status>B<, int >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man2/move_pages.2:45
msgid ""
"B<move_pages>()  moves the specified I<pages> of the process I<pid> to the "
"memory nodes specified by I<nodes>.  The result of the move is reflected in "
"I<status>.  The I<flags> indicate constraints on the pages to be moved."
msgstr ""
"B<move_pages>()  は、プロセス I<pid> の指定されたページ I<pages> を I<nodes> "
"で指定されたメモリーノードに移動する。 移動の結果は I<status> に反映される。 "
"I<flags> では移動されるページに関する制約を指定する。"

#. type: Plain text
#: build/C/man2/move_pages.2:53
msgid ""
"I<pid> is the ID of the process in which pages are to be moved.  If I<pid> "
"is 0, then B<move_pages>()  moves pages of the calling process."
msgstr ""

#. type: Plain text
#: build/C/man2/move_pages.2:55
msgid "To move pages in another process requires the following privileges:"
msgstr ""

#. type: IP
#: build/C/man2/move_pages.2:55 build/C/man2/move_pages.2:61
#, no-wrap
msgid "*"
msgstr "*"

#. type: Plain text
#: build/C/man2/move_pages.2:61
msgid ""
"In kernels up to and including Linux 4.12: the caller must be privileged "
"(B<CAP_SYS_NICE>)  or the real or effective user ID of the calling process "
"must match the real or saved-set user ID of the target process."
msgstr "Linux 4.12 以前のカーネルでは、呼び出し元が特権 (B<CAP_SYS_NICE>)  を持っているか、呼び出したプロセスの実ユーザー ID か実効ユーザー ID が ページ移動対象のプロセスの実ユーザー ID か保存 set-user-ID のどちらかと一致しなければならない。"

#.  commit 197e7e521384a23b9e585178f3f11c9fa08274b9
#. type: Plain text
#: build/C/man2/move_pages.2:73
msgid ""
"The older rules allowed the caller to discover various virtual address "
"choices made by the kernel that could lead to the defeat of address-space-"
"layout randomization for a process owned by the same UID as the caller, the "
"rules were changed starting with Linux 4.13.  Since Linux 4.13, permission "
"is governed by a ptrace access mode B<PTRACE_MODE_READ_REALCREDS> check with "
"respect to the target process; see B<ptrace>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/move_pages.2:81
msgid ""
"I<count> is the number of pages to move.  It defines the size of the three "
"arrays I<pages>, I<nodes>, and I<status>."
msgstr ""
"I<count> は移動するページ数である。 I<count> により I<pages>, I<nodes>, "
"I<status> の 3 つの配列の大きさが定義される。"

#.  FIXME Describe the result if pointers in the 'pages' array are
#.  not aligned to page boundaries
#. type: Plain text
#: build/C/man2/move_pages.2:89
msgid ""
"I<pages> is an array of pointers to the pages that should be moved.  These "
"are pointers that should be aligned to page boundaries.  Addresses are "
"specified as seen by the process specified by I<pid>."
msgstr ""
"I<pages> は、移動すべきページへのポインターの配列であり、 各ポインターはペー"
"ジ境界に揃えた値を指定すべきである。 I<pid> で指定されたプロセスで見えるアド"
"レスを指定する。"

#. type: Plain text
#: build/C/man2/move_pages.2:102
msgid ""
"I<nodes> is an array of integers that specify the desired location for each "
"page.  Each element in the array is a node number.  I<nodes> can also be "
"NULL, in which case B<move_pages>()  does not move any pages but instead "
"will return the node where each page currently resides, in the I<status> "
"array.  Obtaining the status of each page may be necessary to determine "
"pages that need to be moved."
msgstr ""
"I<nodes> は、各ページの希望の移動場所を示す整数値の配列であり、 配列の各要素"
"はノード番号である。 I<nodes> には NULL を指定することもでき、この場合には "
"B<move_pages>()  はどのページも移動しないが、各ページが現在配置されているノー"
"ドを配列 I<status> に格納して返す。どのページを移動する必要があるかを判断する"
"ために、 各ページの状態の取得が必要な場合もある。"

#. type: Plain text
#: build/C/man2/move_pages.2:111
#, fuzzy
#| msgid ""
#| "I<status> is an array of integers that return the status of each page.  "
#| "The array contains valid values only if B<move_pages>()  did not return "
#| "an error."
msgid ""
"I<status> is an array of integers that return the status of each page.  The "
"array contains valid values only if B<move_pages>()  did not return an "
"error.  Preinitialization of the array to a value which cannot represent a "
"real numa node or valid error of status array could help to identify pages "
"that have been migrated."
msgstr ""
"I<status> は、各ページの状態を表す整数値の配列である。 この配列に有効な値が格"
"納されるのは、 B<move_pages>()  がエラーを返さなかった場合だけである。"

#. type: Plain text
#: build/C/man2/move_pages.2:123
msgid ""
"I<flags> specify what types of pages to move.  B<MPOL_MF_MOVE> means that "
"only pages that are in exclusive use by the process are to be moved.  "
"B<MPOL_MF_MOVE_ALL> means that pages shared between multiple processes can "
"also be moved.  The process must be privileged (B<CAP_SYS_NICE>)  to use "
"B<MPOL_MF_MOVE_ALL>."
msgstr ""
"I<flags> には、どの種類のページを移動するかを指定する。 B<MPOL_MF_MOVE> は、"
"そのプロセスが排他的に使用しているページだけを移動することを意味する。 "
"B<MPOL_MF_MOVE_ALL> は、複数のプロセス間で共有されているページも移動できるこ"
"とを意味する。 B<MPOL_MF_MOVE_ALL> を使用するためには、そのプロセスが特権 "
"(B<CAP_SYS_NICE>)  を持っていなければならない。"

#. type: SS
#: build/C/man2/move_pages.2:123
#, no-wrap
msgid "Page states in the status array"
msgstr "status 配列に格納されるページ状態"

#. type: Plain text
#: build/C/man2/move_pages.2:127
msgid ""
"The following values can be returned in each element of the I<status> array."
msgstr "I<status> 配列の各要素として、以下の値が返される。"

#. type: TP
#: build/C/man2/move_pages.2:127
#, no-wrap
msgid "B<0..MAX_NUMNODES>"
msgstr "B<0..MAX_NUMNODES>"

#. type: Plain text
#: build/C/man2/move_pages.2:130
msgid "Identifies the node on which the page resides."
msgstr "そのページが配置されているノードを示す。"

#. type: TP
#: build/C/man2/move_pages.2:130
#, no-wrap
msgid "B<-EACCES>"
msgstr "B<-EACCES>"

#. type: Plain text
#: build/C/man2/move_pages.2:135
msgid ""
"The page is mapped by multiple processes and can be moved only if "
"B<MPOL_MF_MOVE_ALL> is specified."
msgstr ""
"そのページは複数のプロセスによりマップされており、 B<MPOL_MF_MOVE_ALL> が指定"
"された場合にのみ移動できる。"

#. type: TP
#: build/C/man2/move_pages.2:135
#, no-wrap
msgid "B<-EBUSY>"
msgstr "B<-EBUSY>"

#. type: Plain text
#: build/C/man2/move_pages.2:141
msgid ""
"The page is currently busy and cannot be moved.  Try again later.  This "
"occurs if a page is undergoing I/O or another kernel subsystem is holding a "
"reference to the page."
msgstr ""
"そのページが現在ビジーであり、移動できない。後でもう一度試すこと。 この状況"
"は、ページが I/O の実行中であったり、カーネルの他のサブシステム がそのページ"
"への参照を保持している場合に発生する。"

#. type: TP
#: build/C/man2/move_pages.2:141
#, no-wrap
msgid "B<-EFAULT>"
msgstr "B<-EFAULT>"

#. type: Plain text
#: build/C/man2/move_pages.2:144
msgid "This is a zero page or the memory area is not mapped by the process."
msgstr ""
"そのページが zero page であるか、そのメモリー領域はそのプロセスにより マップ"
"されていない。"

#. type: TP
#: build/C/man2/move_pages.2:144
#, no-wrap
msgid "B<-EIO>"
msgstr "B<-EIO>"

#. type: Plain text
#: build/C/man2/move_pages.2:151
msgid ""
"Unable to write back a page.  The page has to be written back in order to "
"move it since the page is dirty and the filesystem does not provide a "
"migration function that would allow the move of dirty pages."
msgstr ""
"ページを書き戻す (write back) ことができない。 ページが dirty で、ファイルシ"
"ステムが dirty なページを移動できるような 移動機能を提供していないため、その"
"ページを移動するためにはページを 書き戻さなければならない。"

#. type: TP
#: build/C/man2/move_pages.2:151
#, no-wrap
msgid "B<-EINVAL>"
msgstr "B<-EINVAL>"

#. type: Plain text
#: build/C/man2/move_pages.2:156
msgid ""
"A dirty page cannot be moved.  The filesystem does not provide a migration "
"function and has no ability to write back pages."
msgstr ""
"dirty なページを移動できない。 ファイルシステムが dirty なページを移動するた"
"めの機能を提供しておらず、 ページを書き戻す能力もない。"

#. type: TP
#: build/C/man2/move_pages.2:156
#, no-wrap
msgid "B<-ENOENT>"
msgstr "B<-ENOENT>"

#. type: Plain text
#: build/C/man2/move_pages.2:159
msgid "The page is not present."
msgstr "ページが存在しない。"

#. type: TP
#: build/C/man2/move_pages.2:159
#, no-wrap
msgid "B<-ENOMEM>"
msgstr "B<-ENOMEM>"

#. type: Plain text
#: build/C/man2/move_pages.2:162
msgid "Unable to allocate memory on target node."
msgstr "移動先のノードでメモリーを確保することができない。"

#.  FIXME . Is the following quite true: does the wrapper in numactl
#.  do the right thing?
#. type: Plain text
#: build/C/man2/move_pages.2:173
#, fuzzy
#| msgid ""
#| "On success B<move_pages>()  returns zero.  On error, it returns -1, and "
#| "sets I<errno> to indicate the error."
msgid ""
"On success B<move_pages>()  returns zero.  On error, it returns -1, and sets "
"I<errno> to indicate the error.  If positive value is returned, it is the "
"number of nonmigrated pages."
msgstr ""
"成功すると、 B<move_pages>()  は 0 を返す。 エラーの場合、-1 を返し、 "
"I<errno> にエラーを示す値を設定する。"

#. type: TP
#: build/C/man2/move_pages.2:174
#, no-wrap
msgid "B<Positive value>"
msgstr ""

#.  commit a49bd4d7163707de377aee062f17befef6da891b
#.  commit 3140a2273009c01c27d316f35ab76a37e105fdd8
#. type: Plain text
#: build/C/man2/move_pages.2:185
msgid ""
"The number of nonmigrated pages if they were the result of nonfatal reasons "
"(since Linux 4.17).  B<E2BIG> Too many pages to move.  Since Linux 2.6.29, "
"the kernel no longer generates this error."
msgstr ""

#. type: TP
#: build/C/man2/move_pages.2:185
#, no-wrap
msgid "B<EACCES>"
msgstr "B<EACCES>"

#.  FIXME Clarify "current cpuset" in the description of the EACCES error.
#.  Is that the cpuset of the caller or the target?
#. type: Plain text
#: build/C/man2/move_pages.2:190
msgid "One of the target nodes is not allowed by the current cpuset."
msgstr "移動先のノードのいずれかが現在の CPU 集合では許可されていない。"

#. type: Plain text
#: build/C/man2/move_pages.2:193
msgid "Parameter array could not be accessed."
msgstr "パラメーター配列にアクセスできなかった。"

#. type: Plain text
#: build/C/man2/move_pages.2:200
msgid ""
"Flags other than B<MPOL_MF_MOVE> and B<MPOL_MF_MOVE_ALL> was specified or an "
"attempt was made to migrate pages of a kernel thread."
msgstr ""
"I<flags> に B<MPOL_MF_MOVE> でも B<MPOL_MF_MOVE_ALL> でもない値が指定された"
"か、カーネルスレッドのページを移動させようとした。"

#. type: TP
#: build/C/man2/move_pages.2:200
#, no-wrap
msgid "B<ENODEV>"
msgstr "B<ENODEV>"

#. type: Plain text
#: build/C/man2/move_pages.2:203
msgid "One of the target nodes is not online."
msgstr "移動先のノードのいずれかがオンラインでない。"

#. type: Plain text
#: build/C/man2/move_pages.2:212
msgid ""
"The caller specified B<MPOL_MF_MOVE_ALL> without sufficient privileges "
"(B<CAP_SYS_NICE>).  Or, the caller attempted to move pages of a process "
"belonging to another user but did not have privilege to do so "
"(B<CAP_SYS_NICE>)."
msgstr ""
"呼び出し元は B<MPOL_MF_MOVE_ALL> を指定したが、十分な特権 (B<CAP_SYS_NICE>)  "
"を持っていない。 または、呼び出し元が他のユーザーに属するプロセスのページを移"
"動しようとしたが、 それを行えるだけの特権 (B<CAP_SYS_NICE>)  を持っていなかっ"
"た。"

#. type: Plain text
#: build/C/man2/move_pages.2:215
msgid "Process does not exist."
msgstr "プロセスが存在しない。"

#. type: Plain text
#: build/C/man2/move_pages.2:218
msgid "B<move_pages>()  first appeared on Linux in version 2.6.18."
msgstr "B<move_pages>()  は、バージョン 2.6.18 で初めて Linux に登場した。"

#.  FIXME Clarify "current cpuset".  Is that the cpuset of the caller
#.  or the target?
#. type: Plain text
#: build/C/man2/move_pages.2:234
msgid ""
"Use B<get_mempolicy>(2)  with the B<MPOL_F_MEMS_ALLOWED> flag to obtain the "
"set of nodes that are allowed by the current cpuset.  Note that this "
"information is subject to change at any time by manual or automatic "
"reconfiguration of the cpuset."
msgstr ""
"現在の CPU 集合で許可されているノードの集合を取得するには、フラグ "
"B<MPOL_F_MEMS_ALLOWED> を指定して B<get_mempolicy>(2)  を使用すればよい。 取"
"得した情報は、CPU 集合の手動または自動での再構成により いつ何時変化してしまう"
"か分からない。"

#. type: Plain text
#: build/C/man2/move_pages.2:244
msgid ""
"Use of this function may result in pages whose location (node) violates the "
"memory policy established for the specified addresses (See B<mbind>(2))  and/"
"or the specified process (See B<set_mempolicy>(2)).  That is, memory policy "
"does not constrain the destination nodes used by B<move_pages>()."
msgstr ""
"この関数を使用すると、ページの位置 (ノード) が 指定されたアドレスに対して設定"
"されたメモリーポリシー (B<mbind>(2)  参照) や指定されたプロセスに対して設定さ"
"れたメモリーポリシー (B<set_mempolicy>(2)  参照) に違反してしまう可能性があ"
"る。 つまり、メモリーポリシーは B<move_pages>()  で使われる移動先ノードを制限"
"しないということである。"

#. type: TH
#: build/C/man7/numa.7:29
#, no-wrap
msgid "NUMA"
msgstr "NUMA"

#. type: TH
#: build/C/man7/numa.7:29
#, no-wrap
msgid "2012-08-05"
msgstr "2012-08-05"

#. type: Plain text
#: build/C/man7/numa.7:32
msgid "numa - overview of Non-Uniform Memory Architecture"
msgstr "numa - 非対称型メモリーアーキテクチャーの概要"

#. type: Plain text
#: build/C/man7/numa.7:43
msgid ""
"Non-Uniform Memory Access (NUMA) refers to multiprocessor systems whose "
"memory is divided into multiple memory nodes.  The access time of a memory "
"node depends on the relative locations of the accessing CPU and the accessed "
"node.  (This contrasts with a symmetric multiprocessor system, where the "
"access time for all of the memory is the same for all CPUs.)  Normally, each "
"CPU on a NUMA system has a local memory node whose contents can be accessed "
"faster than the memory in the node local to another CPU or the memory on a "
"bus shared by all CPUs."
msgstr ""
"非対称型メモリーアクセス (Non-Uniform Memory Access; NUMA) は、\n"
"メモリーが複数のメモリーノードに分割されているマルチプロセッサシステム\n"
"のことである。メモリーノードへのアクセス時間は、アクセス元の CPU と\n"
"アクセス先のノードの相対的な位置関係に依存する\n"
"(これに対し、対称型マルチプロセッサシステムでは、どの CPU から\n"
"どのメモリーへのアクセス時間も同じである)。\n"
"通常は、 NUMA システムの各 CPU にはローカルのメモリーノードがあり、\n"
"そのメモリーノードには、他の CPU のローカルノードや全ての CPU で\n"
"共有されるバス上のメモリーよりも早くアクセスすることができる。"

#. type: SS
#: build/C/man7/numa.7:43
#, no-wrap
msgid "NUMA system calls"
msgstr "NUMA システムコール"

#. type: Plain text
#: build/C/man7/numa.7:54
msgid ""
"The Linux kernel implements the following NUMA-related system calls: "
"B<get_mempolicy>(2), B<mbind>(2), B<migrate_pages>(2), B<move_pages>(2), and "
"B<set_mempolicy>(2).  However, applications should normally use the "
"interface provided by I<libnuma>; see \"Library Support\" below."
msgstr ""
"Linux カーネルには、次に示す NUMA 関連のシステムコールが実装されている:\n"
"B<get_mempolicy>(2), B<mbind>(2), B<migrate_pages>(2),\n"
"B<move_pages>(2), B<set_mempolicy>(2).\n"
"ただし、アプリケーションは通常は I<libnuma> が提供するインターフェース\n"
"を使用すべきである。下記の「ライブラリによるサポート」を参照。"

#. type: SS
#: build/C/man7/numa.7:54
#, no-wrap
msgid "/proc/[number]/numa_maps (since Linux 2.6.14)"
msgstr "/proc/[number]/numa_maps (Linux 2.6.14 以降)"

#.  See also Changelog-2.6.14
#. type: Plain text
#: build/C/man7/numa.7:58
msgid ""
"This file displays information about a process's NUMA memory policy and "
"allocation."
msgstr ""
"このファイルは、プロセスの NUMA メモリーポリシーと割り当てに関する\n"
"情報を表示する。"

#. type: Plain text
#: build/C/man7/numa.7:62
msgid ""
"Each line contains information about a memory range used by the process, "
"displaying\\(emamong other information\\(emthe effective memory policy for "
"that memory range and on which nodes the pages have been allocated."
msgstr ""
"各行に、そのプロセスが使用しているメモリー領域に関する情報が表示される。その"
"他の情報 \\(em そのメモリー領域に適用されているメモリーポリシーや、そのページ"
"がどのノード上に割り当てられているか、など \\(em もあわせて表示される。"

#. type: Plain text
#: build/C/man7/numa.7:70
msgid ""
"I<numa_maps> is a read-only file.  When I</proc/E<lt>pidE<gt>/numa_maps> is "
"read, the kernel will scan the virtual address space of the process and "
"report how memory is used.  One line is displayed for each unique memory "
"range of the process."
msgstr ""
"I<numa_maps> は読み出し専用のファイルである。 I</proc/E<lt>pidE<gt>/"
"numa_maps> から読み出しが行われると、 カーネルはそのプロセスの仮想アドレス空"
"間をスキャンし、 メモリーの使用状況を報告する。\n"
"プロセスのメモリー領域の情報が 1 行に 1 領域で表示される。"

#. type: Plain text
#: build/C/man7/numa.7:77
msgid ""
"The first field of each line shows the starting address of the memory "
"range.  This field allows a correlation with the contents of the I</proc/"
"E<lt>pidE<gt>/maps> file, which contains the end address of the range and "
"other information, such as the access permissions and sharing."
msgstr ""
"各行の最初のフィールドはメモリー領域の開始アドレスを示す。 このフィールドは "
"I</proc/E<lt>pidE<gt>/maps> ファイルの内容と対応している。 I</proc/"
"E<lt>pidE<gt>/maps> には、メモリー領域の末尾のアドレスや、アクセス許可や共有"
"といった他の情報も含まれる。"

#. type: Plain text
#: build/C/man7/numa.7:85
msgid ""
"The second field shows the memory policy currently in effect for the memory "
"range.  Note that the effective policy is not necessarily the policy "
"installed by the process for that memory range.  Specifically, if the "
"process installed a \"default\" policy for that range, the effective policy "
"for that range will be the process policy, which may or may not be \"default"
"\"."
msgstr ""
"2 番目のフィールドは、 そのメモリー領域に現在適用されているメモリーポリシーを"
"示す。 適用されているポリシーは、 必ずしもそのプロセスがこのメモリー領域に対"
"して設定したポリシーとは限らない点に注意すること。\n"
"特に、 プロセスがその領域に対して「デフォルト」ポリシーを設定した場合、その領"
"域に適用されるポリシーはプロセスのポリシーとなり、それが「デフォルト」ポリ"
"シーとなる場合もあればそうでない場合もある。"

#. type: Plain text
#: build/C/man7/numa.7:88
msgid ""
"The rest of the line contains information about the pages allocated in the "
"memory range, as follows:"
msgstr ""
"行の残りの部分には、そのメモリー領域に割り当てられたページに関する情報が入"
"る。以下に詳細を示す。"

#. type: TP
#: build/C/man7/numa.7:88
#, no-wrap
msgid "I<NE<lt>nodeE<gt>=E<lt>nr_pagesE<gt>>"
msgstr "I<NE<lt>nodeE<gt>=E<lt>nr_pagesE<gt>>"

#. type: Plain text
#: build/C/man7/numa.7:101
msgid ""
"The number of pages allocated on I<E<lt>nodeE<gt>>.  I<E<lt>nr_pagesE<gt>> "
"includes only pages currently mapped by the process.  Page migration and "
"memory reclaim may have temporarily unmapped pages associated with this "
"memory range.  These pages may show up again only after the process has "
"attempted to reference them.  If the memory range represents a shared memory "
"area or file mapping, other processes may currently have additional pages "
"mapped in a corresponding memory range."
msgstr ""
"I<E<lt>nodeE<gt>> に割り当てられているページ数。 I<E<lt>nr_pagesE<gt>> に"
"は、 そのプロセスが現在マッピングしているページだけが含まれる。 ページの移動"
"やメモリーの再利用により、 このメモリー領域に関連付けられているが、 一時的に"
"マッピングされていないページが存在する場合がある。 プロセスがそれらのページを"
"参照しようとした後には、 これらのページは再び現れる可能性がある。 メモリー領"
"域が共有メモリーやファイルマッピングの場合には、 そのメモリー領域内に別のペー"
"ジを他のプロセスがマッピングしている場合もある。"

#. type: TP
#: build/C/man7/numa.7:101
#, no-wrap
msgid "I<file=E<lt>filenameE<gt>>"
msgstr "I<file=E<lt>filenameE<gt>>"

#. type: Plain text
#: build/C/man7/numa.7:107
msgid ""
"The file backing the memory range.  If the file is mapped as private, write "
"accesses may have generated COW (Copy-On-Write) pages in this memory range.  "
"These pages are displayed as anonymous pages."
msgstr ""
"そのメモリー領域に関連付けられているファイル。 ファイルがプライベート (非公"
"開) でマッピングされている場合、 書き込みアクセスがあると、 このメモリー領域"
"に書き込み時コピー (Copy-On-Write) ページが生成されることがある。 これらの"
"ページは無名ページ (anonymous page) として表示される。"

#. type: TP
#: build/C/man7/numa.7:107
#, no-wrap
msgid "I<heap>"
msgstr "I<heap>"

#. type: Plain text
#: build/C/man7/numa.7:110
msgid "Memory range is used for the heap."
msgstr "ヒープに使用されているメモリー範囲。"

#. type: TP
#: build/C/man7/numa.7:110
#, no-wrap
msgid "I<stack>"
msgstr "I<stack>"

#. type: Plain text
#: build/C/man7/numa.7:113
msgid "Memory range is used for the stack."
msgstr "スタックに使用されているメモリー範囲。"

#. type: TP
#: build/C/man7/numa.7:113
#, no-wrap
msgid "I<huge>"
msgstr "I<huge>"

#. type: Plain text
#: build/C/man7/numa.7:117
msgid ""
"Huge memory range.  The page counts shown are huge pages and not regular "
"sized pages."
msgstr ""
"ヒュージメモリーの範囲。表示されるページ数は、\n"
"通常の大きさのページではなく、ヒュージページの数である。"

#. type: TP
#: build/C/man7/numa.7:117
#, no-wrap
msgid "I<anon=E<lt>pagesE<gt>>"
msgstr "I<anon=E<lt>pagesE<gt>>"

#. type: Plain text
#: build/C/man7/numa.7:120
msgid "The number of anonymous page in the range."
msgstr "メモリー範囲内の無名ページ (anonymous page) の数。"

#. type: TP
#: build/C/man7/numa.7:120
#, no-wrap
msgid "I<dirty=E<lt>pagesE<gt>>"
msgstr "I<dirty=E<lt>pagesE<gt>>"

#. type: Plain text
#: build/C/man7/numa.7:123
msgid "Number of dirty pages."
msgstr "dirty (変更された) ページの数。"

#. type: TP
#: build/C/man7/numa.7:123
#, no-wrap
msgid "I<mapped=E<lt>pagesE<gt>>"
msgstr "I<mapped=E<lt>pagesE<gt>>"

#. type: Plain text
#: build/C/man7/numa.7:130
msgid ""
"Total number of mapped pages, if different from I<dirty> and I<anon> pages."
msgstr ""
"マッピングされているページ数。 I<dirty> および I<anon> のページ数と異なる値の"
"場合に表示される。"

#. type: TP
#: build/C/man7/numa.7:130
#, no-wrap
msgid "I<mapmax=E<lt>countE<gt>>"
msgstr "I<mapmax=E<lt>countE<gt>>"

#. type: Plain text
#: build/C/man7/numa.7:136
msgid ""
"Maximum mapcount (number of processes mapping a single page) encountered "
"during the scan.  This may be used as an indicator of the degree of sharing "
"occurring in a given memory range."
msgstr ""
"スキャン中に検出した mapcount (一つのページをマッピングしているプロセス数) の"
"最大値。 この値は、 そのメモリー領域でどの程度の共有が行われているかの指標と"
"して使うことができる。"

#. type: TP
#: build/C/man7/numa.7:136
#, no-wrap
msgid "I<swapcache=E<lt>countE<gt>>"
msgstr "I<swapcache=E<lt>countE<gt>>"

#. type: Plain text
#: build/C/man7/numa.7:139
msgid "Number of pages that have an associated entry on a swap device."
msgstr "スワップデバイスに対応するエントリーが存在するページ数。"

#. type: TP
#: build/C/man7/numa.7:139
#, no-wrap
msgid "I<active=E<lt>pagesE<gt>>"
msgstr "I<active=E<lt>pagesE<gt>>"

#. type: Plain text
#: build/C/man7/numa.7:145
msgid ""
"The number of pages on the active list.  This field is shown only if "
"different from the number of pages in this range.  This means that some "
"inactive pages exist in the memory range that may be removed from memory by "
"the swapper soon."
msgstr ""
"アクティブリストに入っているページ数。 このフィールドが表示されるのは、 値が"
"このメモリー領域のページ数と異なる場合だけである。このフィールドが表示される"
"ということは、 このメモリー領域に、まもなくスワッパ (swapper) によりこの領域"
"から削除される可能性がある inactive なページが存在することを意味する。"

#. type: TP
#: build/C/man7/numa.7:145
#, no-wrap
msgid "I<writeback=E<lt>pagesE<gt>>"
msgstr "I<writeback=E<lt>pagesE<gt>>"

#. type: Plain text
#: build/C/man7/numa.7:148
msgid "Number of pages that are currently being written out to disk."
msgstr "現在ディスクに書き出されているページ数。"

#. type: Plain text
#: build/C/man7/numa.7:150
msgid "No standards govern NUMA interfaces."
msgstr "NUMA インターフェースについて規定している標準はない。"

#. type: Plain text
#: build/C/man7/numa.7:157
msgid ""
"The Linux NUMA system calls and I</proc> interface are available only if the "
"kernel was configured and built with the B<CONFIG_NUMA> option."
msgstr ""
"Linux の NUMA システムコールと I</proc> インターフェースは、カーネルが\n"
"設定オプション B<CONFIG_NUMA> を有効にして作成されている場合のみ、利用\n"
"可能である。"

#. type: SS
#: build/C/man7/numa.7:157
#, no-wrap
msgid "Library support"
msgstr "ライブラリによるサポート"

#. type: Plain text
#: build/C/man7/numa.7:166
msgid ""
"Link with I<-lnuma> to get the system call definitions.  I<libnuma> and the "
"required I<E<lt>numaif.hE<gt>> header are available in the I<numactl> "
"package."
msgstr ""
"システムコールの定義を得るには I<-lnuma> でリンクすること。\n"
"I<libnuma> と必要なヘッダーファイル I<E<lt>numaif.hE<gt>> は\n"
"I<numactl> パッケージで提供されている。"

#. type: Plain text
#: build/C/man7/numa.7:183
msgid ""
"However, applications should not use these system calls directly.  Instead, "
"the higher level interface provided by the B<numa>(3)  functions in the "
"I<numactl> package is recommended.  The I<numactl> package is available at "
"E<.UR ftp://oss.sgi.com\\:/www\\:/projects\\:/libnuma\\:/download/> E<.UE .> "
"The package is also included in some Linux distributions.  Some "
"distributions include the development library and header in the separate "
"I<numactl-devel> package."
msgstr ""
"ただし、アプリケーションはこれらのシステムコールを直接利用すべきでない。\n"
"推奨される方法は、I<numactl> パッケージの B<numa>(3) の関数群が提供する\n"
"高レベルインターフェースの利用である。 I<numactl> パッケージは\n"
"E<.UR ftp://oss.sgi.com\\:/www\\:/projects\\:/libnuma\\:/download/> E<.UE> で"
"入手できる。\n"
"このパッケージが収録されている Linux ディストリビューションもある。\n"
"ディストリビューションによっては、開発用のライブラリとヘッダーファイルは\n"
"別パッケージ I<numactl-devel> で提供されている。"

#. type: Plain text
#: build/C/man7/numa.7:191
msgid ""
"B<get_mempolicy>(2), B<mbind>(2), B<move_pages>(2), B<set_mempolicy>(2), "
"B<numa>(3), B<cpuset>(7), B<numactl>(8)"
msgstr ""
"B<get_mempolicy>(2), B<mbind>(2), B<move_pages>(2), B<set_mempolicy>(2), "
"B<numa>(3), B<cpuset>(7), B<numactl>(8)"

#. type: TH
#: build/C/man2/set_mempolicy.2:27
#, no-wrap
msgid "SET_MEMPOLICY"
msgstr "SET_MEMPOLICY"

#. type: TH
#: build/C/man2/set_mempolicy.2:27
#, no-wrap
msgid "2020-12-21"
msgstr "2020-12-21"

#. type: Plain text
#: build/C/man2/set_mempolicy.2:30
msgid ""
"set_mempolicy - set default NUMA memory policy for a thread and its children"
msgstr "set_mempolicy - スレッドとその子スレッドの NUMA メモリーの デフォルトポリシーを設定する"

#. type: Plain text
#: build/C/man2/set_mempolicy.2:36
#, no-wrap
msgid ""
"B<long set_mempolicy(int >I<mode>B<, const unsigned long *>I<nodemask>B<,>\n"
"B<                   unsigned long >I<maxnode>B<);>\n"
msgstr ""
"B<long set_mempolicy(int >I<mode>B<, const unsigned long *>I<nodemask>B<,>\n"
"B<                   unsigned long >I<maxnode>B<);>\n"

#. type: Plain text
#: build/C/man2/set_mempolicy.2:49
msgid ""
"B<set_mempolicy>()  sets the NUMA memory policy of the calling thread, which "
"consists of a policy mode and zero or more nodes, to the values specified by "
"the I<mode>, I<nodemask>, and I<maxnode> arguments."
msgstr "B<set_mempolicy>()  は、呼び出し元スレッドの NUMA ポリシーを I<policy> に設定する。 NUMA ポリシーはポリシーモードと 0 個以上のノードから構成され、 設定内容は引数 I<mode>, I<nodemask>, I<maxnode> により指定される。"

#. type: Plain text
#: build/C/man2/set_mempolicy.2:75
msgid ""
"This system call defines the default policy for the thread.  The thread "
"policy governs allocation of pages in the process's address space outside of "
"memory ranges controlled by a more specific policy set by B<mbind>(2).  The "
"thread default policy also controls allocation of any pages for memory-"
"mapped files mapped using the B<mmap>(2)  call with the B<MAP_PRIVATE> flag "
"and that are only read (loaded) from by the thread and of memory-mapped "
"files mapped using the B<mmap>(2)  call with the B<MAP_SHARED> flag, "
"regardless of the access type.  The policy is applied only when a new page "
"is allocated for the thread.  For anonymous memory this is when the page is "
"first touched by the thread."
msgstr "B<set_mempolicy>()  は、スレッドのデフォルトポリシーを定める。スレッドのポリシーは、 B<mbind>(2)  で設定される特定のポリシーにより制御されるメモリー領域以外のスレッドのアドレス空間におけるページの割り当てに適用される。 スレッドのデフォルトポリシーは、 B<MAP_PRIVATE> フラグを指定した B<mmap>(2)  を使ってマップされたメモリーマップファイルに対する読み出し専用 (ロードされるだけ) のページの割り当てにも適用される。 また、 B<MAP_SHARED> フラグを指定した B<mmap>(2)  を使ってマップされたメモリーマップファイルに対するページの割り当てにも 適用される (この場合はページのアクセス種別に関わらず適用される) 。 設定したポリシーは、スレッドに新規のページが割り当てられるときにのみ 適用される。無名メモリー (anonymous memory) の場合、新規ページの割り当ては アプリケーションが初めてページにアクセスした際に行われる。"

#. type: Plain text
#: build/C/man2/set_mempolicy.2:92
msgid ""
"The I<mode> argument must specify one of B<MPOL_DEFAULT>, B<MPOL_BIND>, "
"B<MPOL_INTERLEAVE>, B<MPOL_PREFERRED>, or B<MPOL_LOCAL> (which are described "
"in detail below).  All modes except B<MPOL_DEFAULT> require the caller to "
"specify the node or nodes to which the mode applies, via the I<nodemask> "
"argument."
msgstr "I<mode> 引数には、 B<MPOL_DEFAULT>, B<MPOL_BIND>, B<MPOL_INTERLEAVE>, B<MPOL_PREFERRED>, B<MPOL_LOCAL> (詳細は下記参照) のいずれか一つを指定しなければならない。 B<MPOL_DEFAULT> 以外のポリシーモードの場合、呼び出し元は I<nodemask> 引数でそのポリシーモードを適用するノードを指定する必要がある。"

#. type: TP
#: build/C/man2/set_mempolicy.2:100
#, no-wrap
msgid "B<MPOL_F_STATIC_NODES> (since Linux 2.6.26)"
msgstr "B<MPOL_F_STATIC_NODES> (Linux 2.6.26 以降)"

#. type: Plain text
#: build/C/man2/set_mempolicy.2:110
msgid ""
"A nonempty I<nodemask> specifies physical node IDs.  Linux will not remap "
"the I<nodemask> when the process moves to a different cpuset context, nor "
"when the set of nodes allowed by the process's current cpuset context "
"changes."
msgstr ""
"空でない I<nodemask> は、物理ノード ID である。 Linux では、そのプロセスが異"
"なる CPU 集合コンテキスト (cpuset context)  に移動した場合でも、そのプロセス"
"の現在の CPU 集合コンテキストで 許可されているノード集合が変化した場合でも、 "
"I<nodemask> をマッピングし直すことはない。"

#. type: TP
#: build/C/man2/set_mempolicy.2:110
#, no-wrap
msgid "B<MPOL_F_RELATIVE_NODES> (since Linux 2.6.26)"
msgstr "B<MPOL_F_RELATIVE_NODES> (Linux 2.6.26 以降)"

#. type: Plain text
#: build/C/man2/set_mempolicy.2:116
msgid ""
"A nonempty I<nodemask> specifies node IDs that are relative to the set of "
"node IDs allowed by the process's current cpuset."
msgstr ""
"空でない I<nodemask> は、そのプロセスの現在の CPU 集合で許可されているノード "
"ID 集合 における相対的なノード ID である。"

#. type: Plain text
#: build/C/man2/set_mempolicy.2:136
msgid ""
"I<nodemask> points to a bit mask of node IDs that contains up to I<maxnode> "
"bits.  The bit mask size is rounded to the next multiple of "
"I<sizeof(unsigned long)>, but the kernel will use bits only up to "
"I<maxnode>.  A NULL value of I<nodemask> or a I<maxnode> value of zero "
"specifies the empty set of nodes.  If the value of I<maxnode> is zero, the "
"I<nodemask> argument is ignored."
msgstr ""
"I<nodemask> は、最大で I<maxnode> ビットから構成されるノード ID のビットマス"
"クを指す。 ビットマスクの大きさは、直近の I<sizeof(unsigned long)> の倍数に切"
"り上げられるが、カーネルが使用するのは I<maxnode> 個までのビットだけである。 "
"NULL 値の I<nodemask> もしくは値が 0 の I<maxnode> はノードの空集合を表す。 "
"I<maxnode> の値が 0 の場合、 I<nodemask> 引数は無視される。"

#. type: Plain text
#: build/C/man2/set_mempolicy.2:157
msgid ""
"Where a I<nodemask> is required, it must contain at least one node that is "
"on-line, allowed by the process's current cpuset context, (unless the "
"B<MPOL_F_STATIC_NODES> mode flag is specified), and contains memory.  If the "
"B<MPOL_F_STATIC_NODES> is set in I<mode> and a required I<nodemask> contains "
"no nodes that are allowed by the process's current cpuset context, the "
"memory policy reverts to I<local allocation>.  This effectively overrides "
"the specified policy until the process's cpuset context includes one or more "
"of the nodes specified by I<nodemask>."
msgstr ""
"I<nodemask> が必須の場面では、 I<nodemask> に、オンラインで、そのプロセスの現"
"在の CPU 集合コンテキストで 許可されており (B<MPOL_F_STATIC_NODES> モードフラ"
"グが指定されていない場合)、メモリーがあるノードが 少なくとも一つ入っていなけ"
"ればならない。 I<mode> に B<MPOL_F_STATIC_NODES> がセットされ、 I<nodemask> "
"が必須の場面で、 I<nodemask> に、そのプロセスの現在の CPU 集合コンテキストで"
"許可されたノードが 一つも含まれていない場合には、メモリーのポリシーとしてデ"
"フォルトの 「ローカルから割り当て (local allocation)」が適用される。 そのプロ"
"セスの CPU 集合コンテキストが I<nodemask> で指定されたノードを少なくとも一つ"
"含むようになるまでは、 結果的に指定された動作が上書きされることになる。"

#. type: Plain text
#: build/C/man2/set_mempolicy.2:171
msgid ""
"This mode specifies that any nondefault thread memory policy be removed, so "
"that the memory policy \"falls back\" to the system default policy.  The "
"system default policy is \"local allocation\"\\(emthat is, allocate memory "
"on the node of the CPU that triggered the allocation.  I<nodemask> must be "
"specified as NULL.  If the \"local node\" contains no free memory, the "
"system will attempt to allocate memory from a \"near by\" node."
msgstr "このモードは、デフォルトではないスレッドのメモリーポリシーを削除することを 指定するものである。これにより、メモリーポリシーはシステムの デフォルトポリシーに「戻る」ことになる。 システムのデフォルトポリシーは「ローカルからの割り当て (local allocation)」、 つまりメモリー割り当てのきっかけとなった CPU のノードのメモリーが割り当てられる。 I<nodemask> には NULL を指定しなければならない。 「自ノード (local node)」に空きメモリーが全くない場合、システムは 「近くの (near by) ノード」からメモリーを割り当てようと試みる。"

#. type: Plain text
#: build/C/man2/set_mempolicy.2:187
msgid ""
"This mode defines a strict policy that restricts memory allocation to the "
"nodes specified in I<nodemask>.  If I<nodemask> specifies more than one "
"node, page allocations will come from the node with the lowest numeric node "
"ID first, until that node contains no free memory.  Allocations will then "
"come from the node with the next highest node ID specified in I<nodemask> "
"and so forth, until none of the specified nodes contain free memory.  Pages "
"will not be allocated from any node not specified in the I<nodemask>."
msgstr "このモードは厳密なポリシーで、メモリー割り当ては I<nodemask> に指定されたノードに限定される。 I<nodemask> に 2 個以上のノードが指定された場合、ページの割り当ては ノード ID が数字として最小のノードから開始され、 そのノードに空きメモリーがなくなるまでそのノードから ページ割り当てが行われる。そのノードに空きメモリーがなくなったら、 次に小さなノード ID を持つノードからページ割り当てが行われる。 これを、 I<nodemask> で指定された全てのノードで空きメモリーがなくなるまで繰り返す。 I<nodemask> で指定された以外のノードからはページの割り当ては行われない。"

#.  NOTE:  the following sentence doesn't make sense in the context
#.  of set_mempolicy() -- no memory area specified.
#.  To be effective the memory area should be fairly large,
#.  at least 1 MB or bigger.
#. type: Plain text
#: build/C/man2/set_mempolicy.2:201
msgid ""
"This mode interleaves page allocations across the nodes specified in "
"I<nodemask> in numeric node ID order.  This optimizes for bandwidth instead "
"of latency by spreading out pages and memory accesses to those pages across "
"multiple nodes.  However, accesses to a single page will still be limited to "
"the memory bandwidth of a single node."
msgstr "このモードでは、ページ割り当てを I<nodemask> に指定されたノードの間でノード ID の数字順で交互に行う。 このポリシーでは、複数のノードにページを広げて配置し、これらのページへのメモリー アクセスを分散することで、遅延ではなく、帯域を最適化する。 ただし、一つのページへのアクセスに関しては依然として一つのノードのメモリー帯域 が上限となる。"

#. type: Plain text
#: build/C/man2/set_mempolicy.2:218
msgid ""
"This mode sets the preferred node for allocation.  The kernel will try to "
"allocate pages from this node first and fall back to \"near by\" nodes if "
"the preferred node is low on free memory.  If I<nodemask> specifies more "
"than one node ID, the first node in the mask will be selected as the "
"preferred node.  If the I<nodemask> and I<maxnode> arguments specify the "
"empty set, then the policy specifies \"local allocation\" (like the system "
"default policy discussed above)."
msgstr "このモードは、割り当て時に優先されるノード (preferred node) を設定する。 カーネルはまず優先ノードからページ割り当てを行おうとし、 優先ノードに空きメモリーが少ない場合に「近くの (near by)」ノードから 割り当てを行う。 I<nodemask> に複数のノード ID が指定された場合は、 I<nodemask> 内の最初のノードが優先ノードとして選択される。 引数 I<nodemask>, I<maxnode> で空集合が指定された場合は、ポリシーは (上述のシステムの デフォルトポリシーと同様に) 「ローカルからの割り当て」となる。"

#.  commit 479e2802d09f1e18a97262c4c6f8f17ae5884bd8
#.  commit f2a07f40dbc603c15f8b06e6ec7f768af67b424f
#. type: Plain text
#: build/C/man2/set_mempolicy.2:237
msgid ""
"This mode specifies \"local allocation\"; the memory is allocated on the "
"node of the CPU that triggered the allocation (the \"local node\").  The "
"I<nodemask> and I<maxnode> arguments must specify the empty set.  If the "
"\"local node\" is low on free memory, the kernel will try to allocate memory "
"from other nodes.  The kernel will allocate memory from the \"local node\" "
"whenever memory for this node is available.  If the \"local node\" is not "
"allowed by the process's current cpuset context, the kernel will try to "
"allocate memory from other nodes.  The kernel will allocate memory from the "
"\"local node\" whenever it becomes allowed by the process's current cpuset "
"context."
msgstr ""

#. type: Plain text
#: build/C/man2/set_mempolicy.2:244
msgid ""
"The thread memory policy is preserved across an B<execve>(2), and is "
"inherited by child threads created using B<fork>(2)  or B<clone>(2)."
msgstr "スレッドのメモリーポリシーは B<execve>(2)  の前後で保持され、 B<fork>(2)  や B<clone>(2)  を使って作成された子スレッドに継承される。"

#. type: Plain text
#: build/C/man2/set_mempolicy.2:251
msgid ""
"On success, B<set_mempolicy>()  returns 0; on error, -1 is returned and "
"I<errno> is set to indicate the error."
msgstr ""
"成功すると、 B<set_mempolicy>()  は 0 を返す。エラーの場合、-1 を返し、 "
"I<errno> にエラーを示す値を設定する。"

#. type: Plain text
#: build/C/man2/set_mempolicy.2:296
msgid ""
"I<mode> is invalid.  Or, I<mode> is B<MPOL_DEFAULT> and I<nodemask> is "
"nonempty, or I<mode> is B<MPOL_BIND> or B<MPOL_INTERLEAVE> and I<nodemask> "
"is empty.  Or, I<maxnode> specifies more than a page worth of bits.  Or, "
"I<nodemask> specifies one or more node IDs that are greater than the maximum "
"supported node ID.  Or, none of the node IDs specified by I<nodemask> are on-"
"line and allowed by the process's current cpuset context, or none of the "
"specified nodes contain memory.  Or, the I<mode> argument specified both "
"B<MPOL_F_STATIC_NODES> and B<MPOL_F_RELATIVE_NODES>."
msgstr ""
"I<mode> が不正である。 I<mode> が B<MPOL_DEFAULT> で、 I<nodemask> が空ではな"
"い。 I<mode> が B<MPOL_BIND> か B<MPOL_INTERLEAVE> で、 I<nodemask> が空であ"
"る。 I<maxnode> で実際に意味があるビット数より多くのビット数が指定された。 "
"I<nodemask> に、サポートされている最大ノード ID より大きいノードが指定され"
"た。 I<nodemask> に、オンラインで、かつそのプロセスの現在の CPU 集合コンテキ"
"ストで 許可されているノードが一つも含まれていないか、 メモリーを含むノードが"
"一つも指定されていない。 I<mode> 引数に B<MPOL_F_STATIC_NODES> と "
"B<MPOL_F_RELATIVE_NODES> の両方が指定された。"

#. type: Plain text
#: build/C/man2/set_mempolicy.2:303
msgid ""
"The B<set_mempolicy>()  system call was added to the Linux kernel in version "
"2.6.7."
msgstr "B<set_mempolicy>() システムコールはバージョン 2.6.7 で Linux カーネルに追加された。"

#. type: Plain text
#: build/C/man2/set_mempolicy.2:310
msgid ""
"Memory policy is not remembered if the page is swapped out.  When such a "
"page is paged back in, it will use the policy of the thread or memory range "
"that is in effect at the time the page is allocated."
msgstr "ページがスワップアウトされる場合には、 メモリポリシーの設定は推奨されない。 スワップアウトされたページがページインする際にも、 ページ割り当て時に適用されるスレッドのポリシーやメモリー領域ポリシーが 使用される。"

#. type: Plain text
#: build/C/man2/set_mempolicy.2:322
msgid ""
"B<get_mempolicy>(2), B<getcpu>(2), B<mbind>(2), B<mmap>(2), B<numa>(3), "
"B<cpuset>(7), B<numa>(7), B<numactl>(8)"
msgstr ""
"B<get_mempolicy>(2), B<getcpu>(2), B<mbind>(2), B<mmap>(2), B<numa>(3), "
"B<cpuset>(7), B<numa>(7), B<numactl>(8)"

#~ msgid "B<getcpu>()  was added in kernel 2.6.19 for x86_64 and i386."
#~ msgstr "B<getcpu>() はカーネル 2.6.19 で x86_64 と i386 向けに追加された."

#~ msgid ""
#~ "Glibc does not provide a wrapper for this system call; call it using "
#~ "B<syscall>(2); or use B<sched_getcpu>(3)  instead."
#~ msgstr ""
#~ "glibc はこのシステムコールに対するラッパー関数を提供していない。\n"
#~ "B<syscall>(2) を使って呼び出すか、\n"
#~ "代わりに B<sched_getcpu>(3) を使用すること。"

#~ msgid ""
#~ "The I<mode> argument may also include an optional I<mode flag >.  The "
#~ "supported I<mode flags> are:"
#~ msgstr ""
#~ "I<mode> 引数には、追加で I<モードフラグ> を含めることもできる。 サポート"
#~ "されている I<モードフラグ> は以下の通りである。"

#~ msgid "Too many pages to move."
#~ msgstr "移動すべきページが多過ぎる。"

#~ msgid ""
#~ "No pages were found that require moving.  All pages are either already on "
#~ "the target node, not present, had an invalid address or could not be "
#~ "moved because they were mapped by multiple processes."
#~ msgstr ""
#~ "移動が必要なページが全く見つからなかった。 指定された全てのページが、すで"
#~ "に移動先のノードに存在するか、存在しないか、 無効なアドレスであったか、複"
#~ "数のプロセスによってマップされていて移動でき なかったか、のいずれかであっ"
#~ "た。"

#~ msgid ""
#~ "The I<mode> argument must specify one of B<MPOL_DEFAULT>, B<MPOL_BIND>, "
#~ "B<MPOL_INTERLEAVE>, or B<MPOL_PREFERRED>.  All modes except "
#~ "B<MPOL_DEFAULT> require the caller to specify via the I<nodemask> "
#~ "argument one or more nodes."
#~ msgstr ""
#~ "I<mode> 引数には B<MPOL_DEFAULT>, B<MPOL_BIND>, B<MPOL_INTERLEAVE>, "
#~ "B<MPOL_PREFERRED> のいずれか一つを指定してしなければならない。 "
#~ "B<MPOL_DEFAULT> 以外のポリシーの場合、呼び出し元は I<nodemask> 引数で一"
#~ "つ以上のノードを指定する必要がある。"
