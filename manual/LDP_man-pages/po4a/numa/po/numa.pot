# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-03-12 14:00+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man2/get_mempolicy.2:27
#, no-wrap
msgid "GET_MEMPOLICY"
msgstr ""

#. type: TH
#: build/C/man2/get_mempolicy.2:27
#, no-wrap
msgid "2017-09-15"
msgstr ""

#. type: TH
#: build/C/man2/get_mempolicy.2:27 build/C/man2/getcpu.2:12 build/C/man2/mbind.2:35 build/C/man2/migrate_pages.2:18 build/C/man2/move_pages.2:20 build/C/man7/numa.7:29 build/C/man2/set_mempolicy.2:27
#, no-wrap
msgid "Linux"
msgstr ""

#. type: TH
#: build/C/man2/get_mempolicy.2:27 build/C/man2/getcpu.2:12 build/C/man2/mbind.2:35 build/C/man2/migrate_pages.2:18 build/C/man2/move_pages.2:20 build/C/man7/numa.7:29 build/C/man2/set_mempolicy.2:27
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr ""

#. type: SH
#: build/C/man2/get_mempolicy.2:28 build/C/man2/getcpu.2:13 build/C/man2/mbind.2:36 build/C/man2/migrate_pages.2:19 build/C/man2/move_pages.2:21 build/C/man7/numa.7:30 build/C/man2/set_mempolicy.2:28
#, no-wrap
msgid "NAME"
msgstr ""

#. type: Plain text
#: build/C/man2/get_mempolicy.2:30
msgid "get_mempolicy - retrieve NUMA memory policy for a thread"
msgstr ""

#. type: SH
#: build/C/man2/get_mempolicy.2:30 build/C/man2/getcpu.2:15 build/C/man2/mbind.2:38 build/C/man2/migrate_pages.2:21 build/C/man2/move_pages.2:23 build/C/man2/set_mempolicy.2:30
#, no-wrap
msgid "SYNOPSIS"
msgstr ""

#. type: Plain text
#: build/C/man2/get_mempolicy.2:32
msgid "B<#include E<lt>numaif.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man2/get_mempolicy.2:37
#, no-wrap
msgid ""
"B<long get_mempolicy(int *>I<mode>B<, unsigned long *>I<nodemask>B<,>\n"
"B<                  unsigned long >I<maxnode>B<, void *>I<addr>B<,>\n"
"B<                  unsigned long >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/get_mempolicy.2:39 build/C/man2/mbind.2:47 build/C/man2/set_mempolicy.2:38
#, no-wrap
msgid "Link with I<-lnuma>.\n"
msgstr ""

#. type: SH
#: build/C/man2/get_mempolicy.2:40 build/C/man2/getcpu.2:22 build/C/man2/mbind.2:48 build/C/man2/migrate_pages.2:31 build/C/man2/move_pages.2:32 build/C/man7/numa.7:32 build/C/man2/set_mempolicy.2:39
#, no-wrap
msgid "DESCRIPTION"
msgstr ""

#. type: Plain text
#: build/C/man2/get_mempolicy.2:45
msgid ""
"B<get_mempolicy>()  retrieves the NUMA policy of the calling thread or of a "
"memory address, depending on the setting of I<flags>."
msgstr ""

#. type: Plain text
#: build/C/man2/get_mempolicy.2:50 build/C/man2/set_mempolicy.2:54
msgid ""
"A NUMA machine has different memory controllers with different distances to "
"specific CPUs.  The memory policy defines from which node memory is "
"allocated for the thread."
msgstr ""

#. type: Plain text
#: build/C/man2/get_mempolicy.2:72
msgid ""
"If I<flags> is specified as 0, then information about the calling thread's "
"default policy (as set by B<set_mempolicy>(2))  is returned, in the buffers "
"pointed to by I<mode> and I<nodemask>.  The value returned in these "
"arguments may be used to restore the thread's policy to its state at the "
"time of the call to B<get_mempolicy>()  using B<set_mempolicy>(2).  When "
"I<flags> is 0, I<addr> must be specified as NULL."
msgstr ""

#. type: Plain text
#: build/C/man2/get_mempolicy.2:94
msgid ""
"If I<flags> specifies B<MPOL_F_MEMS_ALLOWED> (available since Linux 2.6.24), "
"the I<mode> argument is ignored and the set of nodes (memories) that the "
"thread is allowed to specify in subsequent calls to B<mbind>(2)  or "
"B<set_mempolicy>(2)  (in the absence of any I<mode flags>)  is returned in "
"I<nodemask>.  It is not permitted to combine B<MPOL_F_MEMS_ALLOWED> with "
"either B<MPOL_F_ADDR> or B<MPOL_F_NODE>."
msgstr ""

#. type: Plain text
#: build/C/man2/get_mempolicy.2:108
msgid ""
"If I<flags> specifies B<MPOL_F_ADDR>, then information is returned about the "
"policy governing the memory address given in I<addr>.  This policy may be "
"different from the thread's default policy if B<mbind>(2)  or one of the "
"helper functions described in B<numa>(3)  has been used to establish a "
"policy for the memory range containing I<addr>."
msgstr ""

#. type: Plain text
#: build/C/man2/get_mempolicy.2:129
msgid ""
"If the I<mode> argument is not NULL, then B<get_mempolicy>()  will store the "
"policy mode and any optional I<mode flags> of the requested NUMA policy in "
"the location pointed to by this argument.  If I<nodemask> is not NULL, then "
"the nodemask associated with the policy will be stored in the location "
"pointed to by this argument.  I<maxnode> specifies the number of node IDs "
"that can be stored into I<nodemask>\\(emthat is, the maximum node ID plus "
"one.  The value specified by I<maxnode> is always rounded to a multiple of "
"I<sizeof(unsigned\\ long)*8>."
msgstr ""

#. type: Plain text
#: build/C/man2/get_mempolicy.2:146
msgid ""
"If I<flags> specifies both B<MPOL_F_NODE> and B<MPOL_F_ADDR>, "
"B<get_mempolicy>()  will return the node ID of the node on which the address "
"I<addr> is allocated into the location pointed to by I<mode>.  If no page "
"has yet been allocated for the specified address, B<get_mempolicy>()  will "
"allocate a page as if the thread had performed a read (load) access to that "
"address, and return the ID of the node where that page was allocated."
msgstr ""

#.  Note:  code returns next interleave node via 'mode' argument -Lee Schermerhorn
#. type: Plain text
#: build/C/man2/get_mempolicy.2:171
msgid ""
"If I<flags> specifies B<MPOL_F_NODE>, but not B<MPOL_F_ADDR>, and the "
"thread's current policy is B<MPOL_INTERLEAVE>, then B<get_mempolicy>()  will "
"return in the location pointed to by a non-NULL I<mode> argument, the node "
"ID of the next node that will be used for interleaving of internal kernel "
"pages allocated on behalf of the thread.  These allocations include pages "
"for memory-mapped files in process memory ranges mapped using the B<mmap>(2)  "
"call with the B<MAP_PRIVATE> flag for read accesses, and in memory ranges "
"mapped with the B<MAP_SHARED> flag for all accesses."
msgstr ""

#. type: Plain text
#: build/C/man2/get_mempolicy.2:173
msgid "Other flag values are reserved."
msgstr ""

#. type: Plain text
#: build/C/man2/get_mempolicy.2:176
msgid "For an overview of the possible policies see B<set_mempolicy>(2)."
msgstr ""

#. type: SH
#: build/C/man2/get_mempolicy.2:176 build/C/man2/getcpu.2:58 build/C/man2/mbind.2:328 build/C/man2/migrate_pages.2:88 build/C/man2/move_pages.2:162 build/C/man2/set_mempolicy.2:244
#, no-wrap
msgid "RETURN VALUE"
msgstr ""

#. type: Plain text
#: build/C/man2/get_mempolicy.2:183
msgid ""
"On success, B<get_mempolicy>()  returns 0; on error, -1 is returned and "
"I<errno> is set to indicate the error."
msgstr ""

#. type: SH
#: build/C/man2/get_mempolicy.2:183 build/C/man2/getcpu.2:63 build/C/man2/mbind.2:336 build/C/man2/migrate_pages.2:96 build/C/man2/move_pages.2:173 build/C/man2/set_mempolicy.2:251
#, no-wrap
msgid "ERRORS"
msgstr ""

#. type: TP
#: build/C/man2/get_mempolicy.2:184 build/C/man2/getcpu.2:64 build/C/man2/mbind.2:338 build/C/man2/migrate_pages.2:97 build/C/man2/move_pages.2:190 build/C/man2/set_mempolicy.2:252
#, no-wrap
msgid "B<EFAULT>"
msgstr ""

#. type: Plain text
#: build/C/man2/get_mempolicy.2:191 build/C/man2/set_mempolicy.2:259
msgid ""
"Part of all of the memory range specified by I<nodemask> and I<maxnode> "
"points outside your accessible address space."
msgstr ""

#. type: TP
#: build/C/man2/get_mempolicy.2:191 build/C/man2/mbind.2:349 build/C/man2/migrate_pages.2:104 build/C/man2/move_pages.2:193 build/C/man2/set_mempolicy.2:259
#, no-wrap
msgid "B<EINVAL>"
msgstr ""

#. type: Plain text
#: build/C/man2/get_mempolicy.2:235
msgid ""
"The value specified by I<maxnode> is less than the number of node IDs "
"supported by the system.  Or I<flags> specified values other than "
"B<MPOL_F_NODE> or B<MPOL_F_ADDR>; or I<flags> specified B<MPOL_F_ADDR> and "
"I<addr> is NULL, or I<flags> did not specify B<MPOL_F_ADDR> and I<addr> is "
"not NULL.  Or, I<flags> specified B<MPOL_F_NODE> but not B<MPOL_F_ADDR> and "
"the current thread policy is not B<MPOL_INTERLEAVE>.  Or, I<flags> specified "
"B<MPOL_F_MEMS_ALLOWED> with either B<MPOL_F_ADDR> or B<MPOL_F_NODE>.  (And "
"there are other B<EINVAL> cases.)"
msgstr ""

#. type: SH
#: build/C/man2/get_mempolicy.2:235 build/C/man2/getcpu.2:67 build/C/man2/mbind.2:421 build/C/man2/migrate_pages.2:136 build/C/man2/move_pages.2:215 build/C/man2/set_mempolicy.2:299
#, no-wrap
msgid "VERSIONS"
msgstr ""

#. type: Plain text
#: build/C/man2/get_mempolicy.2:239
msgid ""
"The B<get_mempolicy>()  system call was added to the Linux kernel in version "
"2.6.7."
msgstr ""

#. type: SH
#: build/C/man2/get_mempolicy.2:239 build/C/man2/getcpu.2:74 build/C/man2/mbind.2:425 build/C/man2/migrate_pages.2:140 build/C/man2/move_pages.2:218 build/C/man7/numa.7:148 build/C/man2/set_mempolicy.2:303
#, no-wrap
msgid "CONFORMING TO"
msgstr ""

#. type: Plain text
#: build/C/man2/get_mempolicy.2:241 build/C/man2/mbind.2:427 build/C/man2/migrate_pages.2:142 build/C/man2/move_pages.2:220 build/C/man2/set_mempolicy.2:305
msgid "This system call is Linux-specific."
msgstr ""

#. type: SH
#: build/C/man2/get_mempolicy.2:241 build/C/man2/getcpu.2:77 build/C/man2/mbind.2:427 build/C/man2/migrate_pages.2:142 build/C/man2/move_pages.2:220 build/C/man7/numa.7:150 build/C/man2/set_mempolicy.2:305
#, no-wrap
msgid "NOTES"
msgstr ""

#. type: Plain text
#: build/C/man2/get_mempolicy.2:244 build/C/man2/mbind.2:430 build/C/man2/migrate_pages.2:145 build/C/man2/move_pages.2:223 build/C/man2/set_mempolicy.2:313
msgid "For information on library support, see B<numa>(7)."
msgstr ""

#. type: SH
#: build/C/man2/get_mempolicy.2:244 build/C/man2/getcpu.2:136 build/C/man2/mbind.2:483 build/C/man2/migrate_pages.2:172 build/C/man2/move_pages.2:250 build/C/man7/numa.7:183 build/C/man2/set_mempolicy.2:313
#, no-wrap
msgid "SEE ALSO"
msgstr ""

#. type: Plain text
#: build/C/man2/get_mempolicy.2:252
msgid ""
"B<getcpu>(2), B<mbind>(2), B<mmap>(2), B<set_mempolicy>(2), B<numa>(3), "
"B<numa>(7), B<numactl>(8)"
msgstr ""

#. type: SH
#: build/C/man2/get_mempolicy.2:252 build/C/man2/getcpu.2:143 build/C/man2/mbind.2:494 build/C/man2/migrate_pages.2:185 build/C/man2/move_pages.2:260 build/C/man7/numa.7:191 build/C/man2/set_mempolicy.2:322
#, no-wrap
msgid "COLOPHON"
msgstr ""

#. type: Plain text
#: build/C/man2/get_mempolicy.2:260 build/C/man2/getcpu.2:151 build/C/man2/mbind.2:502 build/C/man2/migrate_pages.2:193 build/C/man2/move_pages.2:268 build/C/man7/numa.7:199 build/C/man2/set_mempolicy.2:330
msgid ""
"This page is part of release 5.10 of the Linux I<man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at "
"\\%https://www.kernel.org/doc/man-pages/."
msgstr ""

#. type: TH
#: build/C/man2/getcpu.2:12
#, no-wrap
msgid "GETCPU"
msgstr ""

#. type: TH
#: build/C/man2/getcpu.2:12 build/C/man2/migrate_pages.2:18
#, no-wrap
msgid "2019-03-06"
msgstr ""

#. type: Plain text
#: build/C/man2/getcpu.2:15
msgid "getcpu - determine CPU and NUMA node on which the calling thread is running"
msgstr ""

#. type: Plain text
#: build/C/man2/getcpu.2:18
#, no-wrap
msgid "B<#include E<lt>linux/getcpu.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/getcpu.2:21
#, no-wrap
msgid ""
"B<int getcpu(unsigned *>I<cpu>B<, unsigned *>I<node>B<, struct getcpu_cache "
"*>I<tcache>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/getcpu.2:39
msgid ""
"The B<getcpu>()  system call identifies the processor and node on which the "
"calling thread or process is currently running and writes them into the "
"integers pointed to by the I<cpu> and I<node> arguments.  The processor is a "
"unique small integer identifying a CPU.  The node is a unique small "
"identifier identifying a NUMA node.  When either I<cpu> or I<node> is NULL "
"nothing is written to the respective pointer."
msgstr ""

#. type: Plain text
#: build/C/man2/getcpu.2:43
msgid ""
"The third argument to this system call is nowadays unused, and should be "
"specified as NULL unless portability to Linux 2.6.23 or earlier is required "
"(see NOTES)."
msgstr ""

#. type: Plain text
#: build/C/man2/getcpu.2:58
msgid ""
"The information placed in I<cpu> is guaranteed to be current only at the "
"time of the call: unless the CPU affinity has been fixed using "
"B<sched_setaffinity>(2), the kernel might change the CPU at any time.  "
"(Normally this does not happen because the scheduler tries to minimize "
"movements between CPUs to keep caches hot, but it is possible.)  The caller "
"must allow for the possibility that the information returned in I<cpu> and "
"I<node> is no longer current by the time the call returns."
msgstr ""

#. type: Plain text
#: build/C/man2/getcpu.2:63
msgid ""
"On success, 0 is returned.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/getcpu.2:67
msgid "Arguments point outside the calling process's address space."
msgstr ""

#. type: Plain text
#: build/C/man2/getcpu.2:74
msgid ""
"B<getcpu>()  was added in kernel 2.6.19 for x86-64 and i386.  Library "
"support was added in glibc 2.29 (Earlier glibc versions did not provide a "
"wrapper for this system call, necessitating the use of B<syscall>(2).)"
msgstr ""

#. type: Plain text
#: build/C/man2/getcpu.2:77
msgid "B<getcpu>()  is Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man2/getcpu.2:85
msgid ""
"Linux makes a best effort to make this call as fast as possible.  (On some "
"architectures, this is done via an implementation in the B<vdso>(7).)  The "
"intention of B<getcpu>()  is to allow programs to make optimizations with "
"per-CPU data or for NUMA optimization."
msgstr ""

#.  commit 4307d1e5ada595c87f9a4d16db16ba5edb70dcb1
#.  Author: Ingo Molnar <mingo@elte.hu>
#.  Date:   Wed Nov 7 18:37:48 2007 +0100
#.  x86: ignore the sys_getcpu() tcache parameter
#
#.  ===== Before kernel 2.6.24: =====
#.  .I tcache
#.  is a pointer to a
#.  .IR "struct getcpu_cache"
#.  that is used as a cache by
#.  .BR getcpu ().
#.  The caller should put the cache into a thread-local variable
#.  if the process is multithreaded,
#.  because the cache cannot be shared between different threads.
#.  .I tcache
#.  can be NULL.
#.  If it is not NULL
#.  .BR getcpu ()
#.  will use it to speed up operation.
#.  The information inside the cache is private to the system call
#.  and should not be accessed by the user program.
#.  The information placed in the cache can change between kernel releases.
#
#.  When no cache is specified
#.  .BR getcpu ()
#.  will be slower,
#.  but always retrieve the current CPU and node information.
#.  With a cache
#.  .BR getcpu ()
#.  is faster.
#.  However, the cached information is updated only once per jiffy (see
#.  .BR time (7)).
#.  This means that the information could theoretically be out of date,
#.  although in practice the scheduler's attempt to maintain
#.  soft CPU affinity means that the information is unlikely to change
#.  over the course of the caching interval.
#. type: Plain text
#: build/C/man2/getcpu.2:136
msgid ""
"The I<tcache> argument is unused since Linux 2.6.24.  In earlier kernels, if "
"this argument was non-NULL, then it specified a pointer to a "
"caller-allocated buffer in thread-local storage that was used to provide a "
"caching mechanism for B<getcpu>().  Use of the cache could speed B<getcpu>()  "
"calls, at the cost that there was a very small chance that the returned "
"information would be out of date.  The caching mechanism was considered to "
"cause problems when migrating threads between CPUs, and so the argument is "
"now ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/getcpu.2:143
msgid ""
"B<mbind>(2), B<sched_setaffinity>(2), B<set_mempolicy>(2), "
"B<sched_getcpu>(3), B<cpuset>(7), B<vdso>(7)"
msgstr ""

#. type: TH
#: build/C/man2/mbind.2:35
#, no-wrap
msgid "MBIND"
msgstr ""

#. type: TH
#: build/C/man2/mbind.2:35 build/C/man2/move_pages.2:20
#, no-wrap
msgid "2020-06-09"
msgstr ""

#. type: Plain text
#: build/C/man2/mbind.2:38
msgid "mbind - set memory policy for a memory range"
msgstr ""

#. type: Plain text
#: build/C/man2/mbind.2:41 build/C/man2/migrate_pages.2:24 build/C/man2/move_pages.2:26 build/C/man2/set_mempolicy.2:33
#, no-wrap
msgid "B<#include E<lt>numaif.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mbind.2:45
#, no-wrap
msgid ""
"B<long mbind(void *>I<addr>B<, unsigned long >I<len>B<, int >I<mode>B<,>\n"
"B<           const unsigned long *>I<nodemask>B<, unsigned long "
">I<maxnode>B<,>\n"
"B<           unsigned >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mbind.2:58
msgid ""
"B<mbind>()  sets the NUMA memory policy, which consists of a policy mode and "
"zero or more nodes, for the memory range starting with I<addr> and "
"continuing for I<len> bytes.  The memory policy defines from which node "
"memory is allocated."
msgstr ""

#. type: Plain text
#: build/C/man2/mbind.2:80
msgid ""
"If the memory range specified by the I<addr> and I<len> arguments includes "
"an \"anonymous\" region of memory\\(emthat is a region of memory created "
"using the B<mmap>(2)  system call with the B<MAP_ANONYMOUS>\\(emor a "
"memory-mapped file, mapped using the B<mmap>(2)  system call with the "
"B<MAP_PRIVATE> flag, pages will be allocated only according to the specified "
"policy when the application writes (stores) to the page.  For anonymous "
"regions, an initial read access will use a shared page in the kernel "
"containing all zeros.  For a file mapped with B<MAP_PRIVATE>, an initial "
"read access will allocate pages according to the memory policy of the thread "
"that causes the page to be allocated.  This may not be the thread that "
"called B<mbind>()."
msgstr ""

#. type: Plain text
#: build/C/man2/mbind.2:88
msgid ""
"The specified policy will be ignored for any B<MAP_SHARED> mappings in the "
"specified memory range.  Rather the pages will be allocated according to the "
"memory policy of the thread that caused the page to be allocated.  Again, "
"this may not be the thread that called B<mbind>()."
msgstr ""

#. type: Plain text
#: build/C/man2/mbind.2:105
msgid ""
"If the specified memory range includes a shared memory region created using "
"the B<shmget>(2)  system call and attached using the B<shmat>(2)  system "
"call, pages allocated for the anonymous or shared memory region will be "
"allocated according to the policy specified, regardless of which process "
"attached to the shared memory segment causes the allocation.  If, however, "
"the shared memory region was created with the B<SHM_HUGETLB> flag, the huge "
"pages will be allocated according to the policy specified only if the page "
"allocation is caused by the process that calls B<mbind>()  for that region."
msgstr ""

#. type: Plain text
#: build/C/man2/mbind.2:116
msgid ""
"By default, B<mbind>()  has an effect only for new allocations; if the pages "
"inside the range have been already touched before setting the policy, then "
"the policy has no effect.  This default behavior may be overridden by the "
"B<MPOL_MF_MOVE> and B<MPOL_MF_MOVE_ALL> flags described below."
msgstr ""

#. type: Plain text
#: build/C/man2/mbind.2:133
msgid ""
"The I<mode> argument must specify one of B<MPOL_DEFAULT>, B<MPOL_BIND>, "
"B<MPOL_INTERLEAVE>, B<MPOL_PREFERRED>, or B<MPOL_LOCAL> (which are described "
"in detail below).  All policy modes except B<MPOL_DEFAULT> require the "
"caller to specify the node or nodes to which the mode applies, via the "
"I<nodemask> argument."
msgstr ""

#. type: Plain text
#: build/C/man2/mbind.2:141 build/C/man2/set_mempolicy.2:100
msgid ""
"The I<mode> argument may also include an optional I<mode flag>.  The "
"supported I<mode flags> are:"
msgstr ""

#. type: TP
#: build/C/man2/mbind.2:141
#, no-wrap
msgid "B<MPOL_F_STATIC_NODES> (since Linux-2.6.26)"
msgstr ""

#. type: Plain text
#: build/C/man2/mbind.2:151
msgid ""
"A nonempty I<nodemask> specifies physical node IDs.  Linux does not remap "
"the I<nodemask> when the thread moves to a different cpuset context, nor "
"when the set of nodes allowed by the thread's current cpuset context "
"changes."
msgstr ""

#. type: TP
#: build/C/man2/mbind.2:151
#, no-wrap
msgid "B<MPOL_F_RELATIVE_NODES> (since Linux-2.6.26)"
msgstr ""

#. type: Plain text
#: build/C/man2/mbind.2:157
msgid ""
"A nonempty I<nodemask> specifies node IDs that are relative to the set of "
"node IDs allowed by the thread's current cpuset."
msgstr ""

#. type: Plain text
#: build/C/man2/mbind.2:185
msgid ""
"I<nodemask> points to a bit mask of nodes containing up to I<maxnode> bits.  "
"The bit mask size is rounded to the next multiple of I<sizeof(unsigned "
"long)>, but the kernel will use bits only up to I<maxnode>.  A NULL value of "
"I<nodemask> or a I<maxnode> value of zero specifies the empty set of nodes.  "
"If the value of I<maxnode> is zero, the I<nodemask> argument is ignored.  "
"Where a I<nodemask> is required, it must contain at least one node that is "
"on-line, allowed by the thread's current cpuset context (unless the "
"B<MPOL_F_STATIC_NODES> mode flag is specified), and contains memory."
msgstr ""

#. type: Plain text
#: build/C/man2/mbind.2:189 build/C/man2/set_mempolicy.2:161
msgid "The I<mode> argument must include one of the following values:"
msgstr ""

#. type: TP
#: build/C/man2/mbind.2:189 build/C/man2/set_mempolicy.2:161
#, no-wrap
msgid "B<MPOL_DEFAULT>"
msgstr ""

#. type: Plain text
#: build/C/man2/mbind.2:210
msgid ""
"This mode requests that any nondefault policy be removed, restoring default "
"behavior.  When applied to a range of memory via B<mbind>(), this means to "
"use the thread memory policy, which may have been set with "
"B<set_mempolicy>(2).  If the mode of the thread memory policy is also "
"B<MPOL_DEFAULT>, the system-wide default policy will be used.  The "
"system-wide default policy allocates pages on the node of the CPU that "
"triggers the allocation.  For B<MPOL_DEFAULT>, the I<nodemask> and "
"I<maxnode> arguments must be specify the empty set of nodes."
msgstr ""

#. type: TP
#: build/C/man2/mbind.2:210 build/C/man2/set_mempolicy.2:171
#, no-wrap
msgid "B<MPOL_BIND>"
msgstr ""

#.  commit 19770b32609b6bf97a3dece2529089494cbfc549
#. type: Plain text
#: build/C/man2/mbind.2:231
msgid ""
"This mode specifies a strict policy that restricts memory allocation to the "
"nodes specified in I<nodemask>.  If I<nodemask> specifies more than one "
"node, page allocations will come from the node with sufficient free memory "
"that is closest to the node where the allocation takes place.  Pages will "
"not be allocated from any node not specified in the IR nodemask .  (Before "
"Linux 2.6.26, page allocations came from the node with the lowest numeric "
"node ID first, until that node contained no free memory.  Allocations then "
"came from the node with the next highest node ID specified in I<nodemask> "
"and so forth, until none of the specified nodes contained free memory.)"
msgstr ""

#. type: TP
#: build/C/man2/mbind.2:231 build/C/man2/set_mempolicy.2:187
#, no-wrap
msgid "B<MPOL_INTERLEAVE>"
msgstr ""

#. type: Plain text
#: build/C/man2/mbind.2:243
msgid ""
"This mode specifies that page allocations be interleaved across the set of "
"nodes specified in I<nodemask>.  This optimizes for bandwidth instead of "
"latency by spreading out pages and memory accesses to those pages across "
"multiple nodes.  To be effective the memory area should be fairly large, at "
"least 1\\ MB or bigger with a fairly uniform access pattern.  Accesses to a "
"single page of the area will still be limited to the memory bandwidth of a "
"single node."
msgstr ""

#. type: TP
#: build/C/man2/mbind.2:243 build/C/man2/set_mempolicy.2:201
#, no-wrap
msgid "B<MPOL_PREFERRED>"
msgstr ""

#. type: Plain text
#: build/C/man2/mbind.2:259
msgid ""
"This mode sets the preferred node for allocation.  The kernel will try to "
"allocate pages from this node first and fall back to other nodes if the "
"preferred nodes is low on free memory.  If I<nodemask> specifies more than "
"one node ID, the first node in the mask will be selected as the preferred "
"node.  If the I<nodemask> and I<maxnode> arguments specify the empty set, "
"then the memory is allocated on the node of the CPU that triggered the "
"allocation."
msgstr ""

#. type: TP
#: build/C/man2/mbind.2:259 build/C/man2/set_mempolicy.2:218
#, no-wrap
msgid "B<MPOL_LOCAL> (since Linux 3.8)"
msgstr ""

#.  commit 479e2802d09f1e18a97262c4c6f8f17ae5884bd8
#.  commit f2a07f40dbc603c15f8b06e6ec7f768af67b424f
#. type: Plain text
#: build/C/man2/mbind.2:283
msgid ""
"This mode specifies \"local allocation\"; the memory is allocated on the "
"node of the CPU that triggered the allocation (the \"local node\").  The "
"I<nodemask> and I<maxnode> arguments must specify the empty set.  If the "
"\"local node\" is low on free memory, the kernel will try to allocate memory "
"from other nodes.  The kernel will allocate memory from the \"local node\" "
"whenever memory for this node is available.  If the \"local node\" is not "
"allowed by the thread's current cpuset context, the kernel will try to "
"allocate memory from other nodes.  The kernel will allocate memory from the "
"\"local node\" whenever it becomes allowed by the thread's current cpuset "
"context.  By contrast, B<MPOL_DEFAULT> reverts to the memory policy of the "
"thread (which may be set via B<set_mempolicy>(2)); that policy may be "
"something other than \"local allocation\"."
msgstr ""

#.  According to the kernel code, the following is not true
#.  --Lee Schermerhorn
#.  In 2.6.16 or later the kernel will also try to move pages
#.  to the requested node with this flag.
#. type: Plain text
#: build/C/man2/mbind.2:299
msgid ""
"If B<MPOL_MF_STRICT> is passed in I<flags> and I<mode> is not "
"B<MPOL_DEFAULT>, then the call fails with the error B<EIO> if the existing "
"pages in the memory range don't follow the policy."
msgstr ""

#. type: Plain text
#: build/C/man2/mbind.2:312
msgid ""
"If B<MPOL_MF_MOVE> is specified in I<flags>, then the kernel will attempt to "
"move all the existing pages in the memory range so that they follow the "
"policy.  Pages that are shared with other processes will not be moved.  If "
"B<MPOL_MF_STRICT> is also specified, then the call fails with the error "
"B<EIO> if some pages could not be moved."
msgstr ""

#.  ---------------------------------------------------------------
#. type: Plain text
#: build/C/man2/mbind.2:328
msgid ""
"If B<MPOL_MF_MOVE_ALL> is passed in I<flags>, then the kernel will attempt "
"to move all existing pages in the memory range regardless of whether other "
"processes use the pages.  The calling thread must be privileged "
"(B<CAP_SYS_NICE>)  to use this flag.  If B<MPOL_MF_STRICT> is also "
"specified, then the call fails with the error B<EIO> if some pages could not "
"be moved."
msgstr ""

#.  ---------------------------------------------------------------
#. type: Plain text
#: build/C/man2/mbind.2:336
msgid ""
"On success, B<mbind>()  returns 0; on error, -1 is returned and I<errno> is "
"set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/mbind.2:349
msgid ""
"Part or all of the memory range specified by I<nodemask> and I<maxnode> "
"points outside your accessible address space.  Or, there was an unmapped "
"hole in the specified memory range specified by I<addr> and I<len>."
msgstr ""

#.  As at 2.6.23, this limit is "a page worth of bits", e.g.,
#.  8 * 4096 bits, assuming a 4kB page size.
#. type: Plain text
#: build/C/man2/mbind.2:397
msgid ""
"An invalid value was specified for I<flags> or I<mode>; or I<addr + len> was "
"less than I<addr>; or I<addr> is not a multiple of the system page size.  "
"Or, I<mode> is B<MPOL_DEFAULT> and I<nodemask> specified a nonempty set; or "
"I<mode> is B<MPOL_BIND> or B<MPOL_INTERLEAVE> and I<nodemask> is empty.  Or, "
"I<maxnode> exceeds a kernel-imposed limit.  Or, I<nodemask> specifies one or "
"more node IDs that are greater than the maximum supported node ID.  Or, none "
"of the node IDs specified by I<nodemask> are on-line and allowed by the "
"thread's current cpuset context, or none of the specified nodes contain "
"memory.  Or, the I<mode> argument specified both B<MPOL_F_STATIC_NODES> and "
"B<MPOL_F_RELATIVE_NODES>."
msgstr ""

#. type: TP
#: build/C/man2/mbind.2:397
#, no-wrap
msgid "B<EIO>"
msgstr ""

#. type: Plain text
#: build/C/man2/mbind.2:408
msgid ""
"B<MPOL_MF_STRICT> was specified and an existing page was already on a node "
"that does not follow the policy; or B<MPOL_MF_MOVE> or B<MPOL_MF_MOVE_ALL> "
"was specified and the kernel was unable to move all existing pages in the "
"range."
msgstr ""

#. type: TP
#: build/C/man2/mbind.2:408 build/C/man2/set_mempolicy.2:296
#, no-wrap
msgid "B<ENOMEM>"
msgstr ""

#. type: Plain text
#: build/C/man2/mbind.2:411 build/C/man2/set_mempolicy.2:299
msgid "Insufficient kernel memory was available."
msgstr ""

#. type: TP
#: build/C/man2/mbind.2:411 build/C/man2/migrate_pages.2:121 build/C/man2/move_pages.2:203
#, no-wrap
msgid "B<EPERM>"
msgstr ""

#.  ---------------------------------------------------------------
#. type: Plain text
#: build/C/man2/mbind.2:421
msgid ""
"The I<flags> argument included the B<MPOL_MF_MOVE_ALL> flag and the caller "
"does not have the B<CAP_SYS_NICE> privilege."
msgstr ""

#. type: Plain text
#: build/C/man2/mbind.2:425
msgid "The B<mbind>()  system call was added to the Linux kernel in version 2.6.7."
msgstr ""

#. type: Plain text
#: build/C/man2/mbind.2:435
msgid ""
"NUMA policy is not supported on a memory-mapped file range that was mapped "
"with the B<MAP_SHARED> flag."
msgstr ""

#. type: Plain text
#: build/C/man2/mbind.2:469
msgid ""
"The B<MPOL_DEFAULT> mode can have different effects for B<mbind>()  and "
"B<set_mempolicy>(2).  When B<MPOL_DEFAULT> is specified for "
"B<set_mempolicy>(2), the thread's memory policy reverts to the system "
"default policy or local allocation.  When B<MPOL_DEFAULT> is specified for a "
"range of memory using B<mbind>(), any pages subsequently allocated for that "
"range will use the thread's memory policy, as set by B<set_mempolicy>(2).  "
"This effectively removes the explicit policy from the specified range, "
"\"falling back\" to a possibly nondefault policy.  To select explicit "
"\"local allocation\" for a memory range, specify a I<mode> of B<MPOL_LOCAL> "
"or B<MPOL_PREFERRED> with an empty set of nodes.  This method will work for "
"B<set_mempolicy>(2), as well."
msgstr ""

#. type: Plain text
#: build/C/man2/mbind.2:473
msgid ""
"Support for huge page policy was added with 2.6.16.  For interleave policy "
"to be effective on huge page mappings the policied memory needs to be tens "
"of megabytes or larger."
msgstr ""

#.  commit dcf1763546d76c372f3136c8d6b2b6e77f140cf0
#. type: Plain text
#: build/C/man2/mbind.2:478
msgid "Before Linux 5.7.  B<MPOL_MF_STRICT> was ignored on huge page mappings."
msgstr ""

#. type: Plain text
#: build/C/man2/mbind.2:483
msgid ""
"B<MPOL_MF_MOVE> and B<MPOL_MF_MOVE_ALL> are available only on Linux 2.6.16 "
"and later."
msgstr ""

#. type: Plain text
#: build/C/man2/mbind.2:494
msgid ""
"B<get_mempolicy>(2), B<getcpu>(2), B<mmap>(2), B<set_mempolicy>(2), "
"B<shmat>(2), B<shmget>(2), B<numa>(3), B<cpuset>(7), B<numa>(7), "
"B<numactl>(8)"
msgstr ""

#. type: TH
#: build/C/man2/migrate_pages.2:18
#, no-wrap
msgid "MIGRATE_PAGES"
msgstr ""

#. type: Plain text
#: build/C/man2/migrate_pages.2:21
msgid "migrate_pages - move all pages in a process to another set of nodes"
msgstr ""

#. type: Plain text
#: build/C/man2/migrate_pages.2:28
#, no-wrap
msgid ""
"B<long migrate_pages(int >I<pid>B<, unsigned long >I<maxnode,>\n"
"B<                   const unsigned long *>I<old_nodes,>\n"
"B<                   const unsigned long *>I<new_nodes>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/migrate_pages.2:31 build/C/man2/move_pages.2:32
msgid "Link with I<-lnuma>."
msgstr ""

#. type: Plain text
#: build/C/man2/migrate_pages.2:47
msgid ""
"B<migrate_pages>()  attempts to move all pages of the process I<pid> that "
"are in memory nodes I<old_nodes> to the memory nodes in I<new_nodes>.  Pages "
"not located in any node in I<old_nodes> will not be migrated.  As far as "
"possible, the kernel maintains the relative topology relationship inside "
"I<old_nodes> during the migration to I<new_nodes>."
msgstr ""

#. type: Plain text
#: build/C/man2/migrate_pages.2:69
msgid ""
"The I<old_nodes> and I<new_nodes> arguments are pointers to bit masks of "
"node numbers, with up to I<maxnode> bits in each mask.  These masks are "
"maintained as arrays of unsigned I<long> integers (in the last I<long> "
"integer, the bits beyond those specified by I<maxnode> are ignored).  The "
"I<maxnode> argument is the maximum node number in the bit mask plus one "
"(this is the same as in B<mbind>(2), but different from B<select>(2))."
msgstr ""

#. type: Plain text
#: build/C/man2/migrate_pages.2:83
msgid ""
"The I<pid> argument is the ID of the process whose pages are to be moved.  "
"To move pages in another process, the caller must be privileged "
"(B<CAP_SYS_NICE>)  or the real or effective user ID of the calling process "
"must match the real or saved-set user ID of the target process.  If I<pid> "
"is 0, then B<migrate_pages>()  moves pages of the calling process."
msgstr ""

#. type: Plain text
#: build/C/man2/migrate_pages.2:88
msgid ""
"Pages shared with another process will be moved only if the initiating "
"process has the B<CAP_SYS_NICE> privilege."
msgstr ""

#. type: Plain text
#: build/C/man2/migrate_pages.2:96
msgid ""
"On success B<migrate_pages>()  returns the number of pages that could not be "
"moved (i.e., a return of zero means that all pages were successfully "
"moved).  On error, it returns -1, and sets I<errno> to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/migrate_pages.2:104
msgid ""
"Part or all of the memory range specified by I<old_nodes>/I<new_nodes> and "
"I<maxnode> points outside your accessible address space."
msgstr ""

#.  As at 3.5, this limit is "a page worth of bits", e.g.,
#.  8 * 4096 bits, assuming a 4kB page size.
#. type: Plain text
#: build/C/man2/migrate_pages.2:121
msgid ""
"The value specified by I<maxnode> exceeds a kernel-imposed limit.  Or, "
"I<old_nodes> or I<new_nodes> specifies one or more node IDs that are greater "
"than the maximum supported node ID.  Or, none of the node IDs specified by "
"I<new_nodes> are on-line and allowed by the process's current cpuset "
"context, or none of the specified nodes contain memory."
msgstr ""

#. type: Plain text
#: build/C/man2/migrate_pages.2:130
msgid ""
"Insufficient privilege (B<CAP_SYS_NICE>)  to move pages of the process "
"specified by I<pid>, or insufficient privilege (B<CAP_SYS_NICE>)  to access "
"the specified target nodes."
msgstr ""

#. type: TP
#: build/C/man2/migrate_pages.2:130 build/C/man2/move_pages.2:212
#, no-wrap
msgid "B<ESRCH>"
msgstr ""

#.  FIXME Document the other errors that can occur for migrate_pages()
#. type: Plain text
#: build/C/man2/migrate_pages.2:136
msgid "No process matching I<pid> could be found."
msgstr ""

#. type: Plain text
#: build/C/man2/migrate_pages.2:140
msgid ""
"The B<migrate_pages>()  system call first appeared on Linux in version "
"2.6.16."
msgstr ""

#. type: Plain text
#: build/C/man2/migrate_pages.2:154
msgid ""
"Use B<get_mempolicy>(2)  with the B<MPOL_F_MEMS_ALLOWED> flag to obtain the "
"set of nodes that are allowed by the calling process's cpuset.  Note that "
"this information is subject to change at any time by manual or automatic "
"reconfiguration of the cpuset."
msgstr ""

#. type: Plain text
#: build/C/man2/migrate_pages.2:166
msgid ""
"Use of B<migrate_pages>()  may result in pages whose location (node) "
"violates the memory policy established for the specified addresses (see "
"B<mbind>(2))  and/or the specified process (see B<set_mempolicy>(2)).  That "
"is, memory policy does not constrain the destination nodes used by "
"B<migrate_pages>()."
msgstr ""

#. type: Plain text
#: build/C/man2/migrate_pages.2:172 build/C/man2/move_pages.2:250
msgid ""
"The I<E<lt>numaif.hE<gt>> header is not included with glibc, but requires "
"installing I<libnuma-devel> or a similar package."
msgstr ""

#. type: Plain text
#: build/C/man2/migrate_pages.2:182 build/C/man2/move_pages.2:260
msgid ""
"B<get_mempolicy>(2), B<mbind>(2), B<set_mempolicy>(2), B<numa>(3), "
"B<numa_maps>(5), B<cpuset>(7), B<numa>(7), B<migratepages>(8), "
"B<numastat>(8)"
msgstr ""

#. type: Plain text
#: build/C/man2/migrate_pages.2:185
msgid "I<Documentation/vm/page_migration.rst> in the Linux kernel source tree"
msgstr ""

#. type: TH
#: build/C/man2/move_pages.2:20
#, no-wrap
msgid "MOVE_PAGES"
msgstr ""

#. type: Plain text
#: build/C/man2/move_pages.2:23
msgid "move_pages - move individual pages of a process to another node"
msgstr ""

#. type: Plain text
#: build/C/man2/move_pages.2:29
#, no-wrap
msgid ""
"B<long move_pages(int >I<pid>B<, unsigned long count, void **>I<pages>B<,>\n"
"B<                const int *>I<nodes>B<, int *>I<status>B<, int "
">I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/move_pages.2:45
msgid ""
"B<move_pages>()  moves the specified I<pages> of the process I<pid> to the "
"memory nodes specified by I<nodes>.  The result of the move is reflected in "
"I<status>.  The I<flags> indicate constraints on the pages to be moved."
msgstr ""

#. type: Plain text
#: build/C/man2/move_pages.2:53
msgid ""
"I<pid> is the ID of the process in which pages are to be moved.  If I<pid> "
"is 0, then B<move_pages>()  moves pages of the calling process."
msgstr ""

#. type: Plain text
#: build/C/man2/move_pages.2:55
msgid "To move pages in another process requires the following privileges:"
msgstr ""

#. type: IP
#: build/C/man2/move_pages.2:55 build/C/man2/move_pages.2:61
#, no-wrap
msgid "*"
msgstr ""

#. type: Plain text
#: build/C/man2/move_pages.2:61
msgid ""
"In kernels up to and including Linux 4.12: the caller must be privileged "
"(B<CAP_SYS_NICE>)  or the real or effective user ID of the calling process "
"must match the real or saved-set user ID of the target process."
msgstr ""

#.  commit 197e7e521384a23b9e585178f3f11c9fa08274b9
#. type: Plain text
#: build/C/man2/move_pages.2:73
msgid ""
"The older rules allowed the caller to discover various virtual address "
"choices made by the kernel that could lead to the defeat of "
"address-space-layout randomization for a process owned by the same UID as "
"the caller, the rules were changed starting with Linux 4.13.  Since Linux "
"4.13, permission is governed by a ptrace access mode "
"B<PTRACE_MODE_READ_REALCREDS> check with respect to the target process; see "
"B<ptrace>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/move_pages.2:81
msgid ""
"I<count> is the number of pages to move.  It defines the size of the three "
"arrays I<pages>, I<nodes>, and I<status>."
msgstr ""

#.  FIXME Describe the result if pointers in the 'pages' array are
#.  not aligned to page boundaries
#. type: Plain text
#: build/C/man2/move_pages.2:89
msgid ""
"I<pages> is an array of pointers to the pages that should be moved.  These "
"are pointers that should be aligned to page boundaries.  Addresses are "
"specified as seen by the process specified by I<pid>."
msgstr ""

#. type: Plain text
#: build/C/man2/move_pages.2:102
msgid ""
"I<nodes> is an array of integers that specify the desired location for each "
"page.  Each element in the array is a node number.  I<nodes> can also be "
"NULL, in which case B<move_pages>()  does not move any pages but instead "
"will return the node where each page currently resides, in the I<status> "
"array.  Obtaining the status of each page may be necessary to determine "
"pages that need to be moved."
msgstr ""

#. type: Plain text
#: build/C/man2/move_pages.2:111
msgid ""
"I<status> is an array of integers that return the status of each page.  The "
"array contains valid values only if B<move_pages>()  did not return an "
"error.  Preinitialization of the array to a value which cannot represent a "
"real numa node or valid error of status array could help to identify pages "
"that have been migrated."
msgstr ""

#. type: Plain text
#: build/C/man2/move_pages.2:123
msgid ""
"I<flags> specify what types of pages to move.  B<MPOL_MF_MOVE> means that "
"only pages that are in exclusive use by the process are to be moved.  "
"B<MPOL_MF_MOVE_ALL> means that pages shared between multiple processes can "
"also be moved.  The process must be privileged (B<CAP_SYS_NICE>)  to use "
"B<MPOL_MF_MOVE_ALL>."
msgstr ""

#. type: SS
#: build/C/man2/move_pages.2:123
#, no-wrap
msgid "Page states in the status array"
msgstr ""

#. type: Plain text
#: build/C/man2/move_pages.2:127
msgid "The following values can be returned in each element of the I<status> array."
msgstr ""

#. type: TP
#: build/C/man2/move_pages.2:127
#, no-wrap
msgid "B<0..MAX_NUMNODES>"
msgstr ""

#. type: Plain text
#: build/C/man2/move_pages.2:130
msgid "Identifies the node on which the page resides."
msgstr ""

#. type: TP
#: build/C/man2/move_pages.2:130
#, no-wrap
msgid "B<-EACCES>"
msgstr ""

#. type: Plain text
#: build/C/man2/move_pages.2:135
msgid ""
"The page is mapped by multiple processes and can be moved only if "
"B<MPOL_MF_MOVE_ALL> is specified."
msgstr ""

#. type: TP
#: build/C/man2/move_pages.2:135
#, no-wrap
msgid "B<-EBUSY>"
msgstr ""

#. type: Plain text
#: build/C/man2/move_pages.2:141
msgid ""
"The page is currently busy and cannot be moved.  Try again later.  This "
"occurs if a page is undergoing I/O or another kernel subsystem is holding a "
"reference to the page."
msgstr ""

#. type: TP
#: build/C/man2/move_pages.2:141
#, no-wrap
msgid "B<-EFAULT>"
msgstr ""

#. type: Plain text
#: build/C/man2/move_pages.2:144
msgid "This is a zero page or the memory area is not mapped by the process."
msgstr ""

#. type: TP
#: build/C/man2/move_pages.2:144
#, no-wrap
msgid "B<-EIO>"
msgstr ""

#. type: Plain text
#: build/C/man2/move_pages.2:151
msgid ""
"Unable to write back a page.  The page has to be written back in order to "
"move it since the page is dirty and the filesystem does not provide a "
"migration function that would allow the move of dirty pages."
msgstr ""

#. type: TP
#: build/C/man2/move_pages.2:151
#, no-wrap
msgid "B<-EINVAL>"
msgstr ""

#. type: Plain text
#: build/C/man2/move_pages.2:156
msgid ""
"A dirty page cannot be moved.  The filesystem does not provide a migration "
"function and has no ability to write back pages."
msgstr ""

#. type: TP
#: build/C/man2/move_pages.2:156
#, no-wrap
msgid "B<-ENOENT>"
msgstr ""

#. type: Plain text
#: build/C/man2/move_pages.2:159
msgid "The page is not present."
msgstr ""

#. type: TP
#: build/C/man2/move_pages.2:159
#, no-wrap
msgid "B<-ENOMEM>"
msgstr ""

#. type: Plain text
#: build/C/man2/move_pages.2:162
msgid "Unable to allocate memory on target node."
msgstr ""

#.  FIXME . Is the following quite true: does the wrapper in numactl
#.  do the right thing?
#. type: Plain text
#: build/C/man2/move_pages.2:173
msgid ""
"On success B<move_pages>()  returns zero.  On error, it returns -1, and sets "
"I<errno> to indicate the error.  If positive value is returned, it is the "
"number of nonmigrated pages."
msgstr ""

#. type: TP
#: build/C/man2/move_pages.2:174
#, no-wrap
msgid "B<Positive value>"
msgstr ""

#.  commit a49bd4d7163707de377aee062f17befef6da891b
#.  commit 3140a2273009c01c27d316f35ab76a37e105fdd8
#. type: Plain text
#: build/C/man2/move_pages.2:185
msgid ""
"The number of nonmigrated pages if they were the result of nonfatal reasons "
"(since Linux 4.17).  B<E2BIG> Too many pages to move.  Since Linux 2.6.29, "
"the kernel no longer generates this error."
msgstr ""

#. type: TP
#: build/C/man2/move_pages.2:185
#, no-wrap
msgid "B<EACCES>"
msgstr ""

#.  FIXME Clarify "current cpuset" in the description of the EACCES error.
#.  Is that the cpuset of the caller or the target?
#. type: Plain text
#: build/C/man2/move_pages.2:190
msgid "One of the target nodes is not allowed by the current cpuset."
msgstr ""

#. type: Plain text
#: build/C/man2/move_pages.2:193
msgid "Parameter array could not be accessed."
msgstr ""

#. type: Plain text
#: build/C/man2/move_pages.2:200
msgid ""
"Flags other than B<MPOL_MF_MOVE> and B<MPOL_MF_MOVE_ALL> was specified or an "
"attempt was made to migrate pages of a kernel thread."
msgstr ""

#. type: TP
#: build/C/man2/move_pages.2:200
#, no-wrap
msgid "B<ENODEV>"
msgstr ""

#. type: Plain text
#: build/C/man2/move_pages.2:203
msgid "One of the target nodes is not online."
msgstr ""

#. type: Plain text
#: build/C/man2/move_pages.2:212
msgid ""
"The caller specified B<MPOL_MF_MOVE_ALL> without sufficient privileges "
"(B<CAP_SYS_NICE>).  Or, the caller attempted to move pages of a process "
"belonging to another user but did not have privilege to do so "
"(B<CAP_SYS_NICE>)."
msgstr ""

#. type: Plain text
#: build/C/man2/move_pages.2:215
msgid "Process does not exist."
msgstr ""

#. type: Plain text
#: build/C/man2/move_pages.2:218
msgid "B<move_pages>()  first appeared on Linux in version 2.6.18."
msgstr ""

#.  FIXME Clarify "current cpuset".  Is that the cpuset of the caller
#.  or the target?
#. type: Plain text
#: build/C/man2/move_pages.2:234
msgid ""
"Use B<get_mempolicy>(2)  with the B<MPOL_F_MEMS_ALLOWED> flag to obtain the "
"set of nodes that are allowed by the current cpuset.  Note that this "
"information is subject to change at any time by manual or automatic "
"reconfiguration of the cpuset."
msgstr ""

#. type: Plain text
#: build/C/man2/move_pages.2:244
msgid ""
"Use of this function may result in pages whose location (node) violates the "
"memory policy established for the specified addresses (See B<mbind>(2))  "
"and/or the specified process (See B<set_mempolicy>(2)).  That is, memory "
"policy does not constrain the destination nodes used by B<move_pages>()."
msgstr ""

#. type: TH
#: build/C/man7/numa.7:29
#, no-wrap
msgid "NUMA"
msgstr ""

#. type: TH
#: build/C/man7/numa.7:29
#, no-wrap
msgid "2012-08-05"
msgstr ""

#. type: Plain text
#: build/C/man7/numa.7:32
msgid "numa - overview of Non-Uniform Memory Architecture"
msgstr ""

#. type: Plain text
#: build/C/man7/numa.7:43
msgid ""
"Non-Uniform Memory Access (NUMA) refers to multiprocessor systems whose "
"memory is divided into multiple memory nodes.  The access time of a memory "
"node depends on the relative locations of the accessing CPU and the accessed "
"node.  (This contrasts with a symmetric multiprocessor system, where the "
"access time for all of the memory is the same for all CPUs.)  Normally, each "
"CPU on a NUMA system has a local memory node whose contents can be accessed "
"faster than the memory in the node local to another CPU or the memory on a "
"bus shared by all CPUs."
msgstr ""

#. type: SS
#: build/C/man7/numa.7:43
#, no-wrap
msgid "NUMA system calls"
msgstr ""

#. type: Plain text
#: build/C/man7/numa.7:54
msgid ""
"The Linux kernel implements the following NUMA-related system calls: "
"B<get_mempolicy>(2), B<mbind>(2), B<migrate_pages>(2), B<move_pages>(2), and "
"B<set_mempolicy>(2).  However, applications should normally use the "
"interface provided by I<libnuma>; see \"Library Support\" below."
msgstr ""

#. type: SS
#: build/C/man7/numa.7:54
#, no-wrap
msgid "/proc/[number]/numa_maps (since Linux 2.6.14)"
msgstr ""

#.  See also Changelog-2.6.14
#. type: Plain text
#: build/C/man7/numa.7:58
msgid ""
"This file displays information about a process's NUMA memory policy and "
"allocation."
msgstr ""

#. type: Plain text
#: build/C/man7/numa.7:62
msgid ""
"Each line contains information about a memory range used by the process, "
"displaying\\(emamong other information\\(emthe effective memory policy for "
"that memory range and on which nodes the pages have been allocated."
msgstr ""

#. type: Plain text
#: build/C/man7/numa.7:70
msgid ""
"I<numa_maps> is a read-only file.  When I</proc/E<lt>pidE<gt>/numa_maps> is "
"read, the kernel will scan the virtual address space of the process and "
"report how memory is used.  One line is displayed for each unique memory "
"range of the process."
msgstr ""

#. type: Plain text
#: build/C/man7/numa.7:77
msgid ""
"The first field of each line shows the starting address of the memory "
"range.  This field allows a correlation with the contents of the "
"I</proc/E<lt>pidE<gt>/maps> file, which contains the end address of the "
"range and other information, such as the access permissions and sharing."
msgstr ""

#. type: Plain text
#: build/C/man7/numa.7:85
msgid ""
"The second field shows the memory policy currently in effect for the memory "
"range.  Note that the effective policy is not necessarily the policy "
"installed by the process for that memory range.  Specifically, if the "
"process installed a \"default\" policy for that range, the effective policy "
"for that range will be the process policy, which may or may not be "
"\"default\"."
msgstr ""

#. type: Plain text
#: build/C/man7/numa.7:88
msgid ""
"The rest of the line contains information about the pages allocated in the "
"memory range, as follows:"
msgstr ""

#. type: TP
#: build/C/man7/numa.7:88
#, no-wrap
msgid "I<NE<lt>nodeE<gt>=E<lt>nr_pagesE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man7/numa.7:101
msgid ""
"The number of pages allocated on I<E<lt>nodeE<gt>>.  I<E<lt>nr_pagesE<gt>> "
"includes only pages currently mapped by the process.  Page migration and "
"memory reclaim may have temporarily unmapped pages associated with this "
"memory range.  These pages may show up again only after the process has "
"attempted to reference them.  If the memory range represents a shared memory "
"area or file mapping, other processes may currently have additional pages "
"mapped in a corresponding memory range."
msgstr ""

#. type: TP
#: build/C/man7/numa.7:101
#, no-wrap
msgid "I<file=E<lt>filenameE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man7/numa.7:107
msgid ""
"The file backing the memory range.  If the file is mapped as private, write "
"accesses may have generated COW (Copy-On-Write) pages in this memory range.  "
"These pages are displayed as anonymous pages."
msgstr ""

#. type: TP
#: build/C/man7/numa.7:107
#, no-wrap
msgid "I<heap>"
msgstr ""

#. type: Plain text
#: build/C/man7/numa.7:110
msgid "Memory range is used for the heap."
msgstr ""

#. type: TP
#: build/C/man7/numa.7:110
#, no-wrap
msgid "I<stack>"
msgstr ""

#. type: Plain text
#: build/C/man7/numa.7:113
msgid "Memory range is used for the stack."
msgstr ""

#. type: TP
#: build/C/man7/numa.7:113
#, no-wrap
msgid "I<huge>"
msgstr ""

#. type: Plain text
#: build/C/man7/numa.7:117
msgid ""
"Huge memory range.  The page counts shown are huge pages and not regular "
"sized pages."
msgstr ""

#. type: TP
#: build/C/man7/numa.7:117
#, no-wrap
msgid "I<anon=E<lt>pagesE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man7/numa.7:120
msgid "The number of anonymous page in the range."
msgstr ""

#. type: TP
#: build/C/man7/numa.7:120
#, no-wrap
msgid "I<dirty=E<lt>pagesE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man7/numa.7:123
msgid "Number of dirty pages."
msgstr ""

#. type: TP
#: build/C/man7/numa.7:123
#, no-wrap
msgid "I<mapped=E<lt>pagesE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man7/numa.7:130
msgid "Total number of mapped pages, if different from I<dirty> and I<anon> pages."
msgstr ""

#. type: TP
#: build/C/man7/numa.7:130
#, no-wrap
msgid "I<mapmax=E<lt>countE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man7/numa.7:136
msgid ""
"Maximum mapcount (number of processes mapping a single page) encountered "
"during the scan.  This may be used as an indicator of the degree of sharing "
"occurring in a given memory range."
msgstr ""

#. type: TP
#: build/C/man7/numa.7:136
#, no-wrap
msgid "I<swapcache=E<lt>countE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man7/numa.7:139
msgid "Number of pages that have an associated entry on a swap device."
msgstr ""

#. type: TP
#: build/C/man7/numa.7:139
#, no-wrap
msgid "I<active=E<lt>pagesE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man7/numa.7:145
msgid ""
"The number of pages on the active list.  This field is shown only if "
"different from the number of pages in this range.  This means that some "
"inactive pages exist in the memory range that may be removed from memory by "
"the swapper soon."
msgstr ""

#. type: TP
#: build/C/man7/numa.7:145
#, no-wrap
msgid "I<writeback=E<lt>pagesE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man7/numa.7:148
msgid "Number of pages that are currently being written out to disk."
msgstr ""

#. type: Plain text
#: build/C/man7/numa.7:150
msgid "No standards govern NUMA interfaces."
msgstr ""

#. type: Plain text
#: build/C/man7/numa.7:157
msgid ""
"The Linux NUMA system calls and I</proc> interface are available only if the "
"kernel was configured and built with the B<CONFIG_NUMA> option."
msgstr ""

#. type: SS
#: build/C/man7/numa.7:157
#, no-wrap
msgid "Library support"
msgstr ""

#. type: Plain text
#: build/C/man7/numa.7:166
msgid ""
"Link with I<-lnuma> to get the system call definitions.  I<libnuma> and the "
"required I<E<lt>numaif.hE<gt>> header are available in the I<numactl> "
"package."
msgstr ""

#. type: Plain text
#: build/C/man7/numa.7:183
msgid ""
"However, applications should not use these system calls directly.  Instead, "
"the higher level interface provided by the B<numa>(3)  functions in the "
"I<numactl> package is recommended.  The I<numactl> package is available at "
"E<.UR ftp://oss.sgi.com\\:/www\\:/projects\\:/libnuma\\:/download/> E<.UE .> "
"The package is also included in some Linux distributions.  Some "
"distributions include the development library and header in the separate "
"I<numactl-devel> package."
msgstr ""

#. type: Plain text
#: build/C/man7/numa.7:191
msgid ""
"B<get_mempolicy>(2), B<mbind>(2), B<move_pages>(2), B<set_mempolicy>(2), "
"B<numa>(3), B<cpuset>(7), B<numactl>(8)"
msgstr ""

#. type: TH
#: build/C/man2/set_mempolicy.2:27
#, no-wrap
msgid "SET_MEMPOLICY"
msgstr ""

#. type: TH
#: build/C/man2/set_mempolicy.2:27
#, no-wrap
msgid "2020-12-21"
msgstr ""

#. type: Plain text
#: build/C/man2/set_mempolicy.2:30
msgid "set_mempolicy - set default NUMA memory policy for a thread and its children"
msgstr ""

#. type: Plain text
#: build/C/man2/set_mempolicy.2:36
#, no-wrap
msgid ""
"B<long set_mempolicy(int >I<mode>B<, const unsigned long *>I<nodemask>B<,>\n"
"B<                   unsigned long >I<maxnode>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/set_mempolicy.2:49
msgid ""
"B<set_mempolicy>()  sets the NUMA memory policy of the calling thread, which "
"consists of a policy mode and zero or more nodes, to the values specified by "
"the I<mode>, I<nodemask>, and I<maxnode> arguments."
msgstr ""

#. type: Plain text
#: build/C/man2/set_mempolicy.2:75
msgid ""
"This system call defines the default policy for the thread.  The thread "
"policy governs allocation of pages in the process's address space outside of "
"memory ranges controlled by a more specific policy set by B<mbind>(2).  The "
"thread default policy also controls allocation of any pages for "
"memory-mapped files mapped using the B<mmap>(2)  call with the "
"B<MAP_PRIVATE> flag and that are only read (loaded) from by the thread and "
"of memory-mapped files mapped using the B<mmap>(2)  call with the "
"B<MAP_SHARED> flag, regardless of the access type.  The policy is applied "
"only when a new page is allocated for the thread.  For anonymous memory this "
"is when the page is first touched by the thread."
msgstr ""

#. type: Plain text
#: build/C/man2/set_mempolicy.2:92
msgid ""
"The I<mode> argument must specify one of B<MPOL_DEFAULT>, B<MPOL_BIND>, "
"B<MPOL_INTERLEAVE>, B<MPOL_PREFERRED>, or B<MPOL_LOCAL> (which are described "
"in detail below).  All modes except B<MPOL_DEFAULT> require the caller to "
"specify the node or nodes to which the mode applies, via the I<nodemask> "
"argument."
msgstr ""

#. type: TP
#: build/C/man2/set_mempolicy.2:100
#, no-wrap
msgid "B<MPOL_F_STATIC_NODES> (since Linux 2.6.26)"
msgstr ""

#. type: Plain text
#: build/C/man2/set_mempolicy.2:110
msgid ""
"A nonempty I<nodemask> specifies physical node IDs.  Linux will not remap "
"the I<nodemask> when the process moves to a different cpuset context, nor "
"when the set of nodes allowed by the process's current cpuset context "
"changes."
msgstr ""

#. type: TP
#: build/C/man2/set_mempolicy.2:110
#, no-wrap
msgid "B<MPOL_F_RELATIVE_NODES> (since Linux 2.6.26)"
msgstr ""

#. type: Plain text
#: build/C/man2/set_mempolicy.2:116
msgid ""
"A nonempty I<nodemask> specifies node IDs that are relative to the set of "
"node IDs allowed by the process's current cpuset."
msgstr ""

#. type: Plain text
#: build/C/man2/set_mempolicy.2:136
msgid ""
"I<nodemask> points to a bit mask of node IDs that contains up to I<maxnode> "
"bits.  The bit mask size is rounded to the next multiple of "
"I<sizeof(unsigned long)>, but the kernel will use bits only up to "
"I<maxnode>.  A NULL value of I<nodemask> or a I<maxnode> value of zero "
"specifies the empty set of nodes.  If the value of I<maxnode> is zero, the "
"I<nodemask> argument is ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/set_mempolicy.2:157
msgid ""
"Where a I<nodemask> is required, it must contain at least one node that is "
"on-line, allowed by the process's current cpuset context, (unless the "
"B<MPOL_F_STATIC_NODES> mode flag is specified), and contains memory.  If the "
"B<MPOL_F_STATIC_NODES> is set in I<mode> and a required I<nodemask> contains "
"no nodes that are allowed by the process's current cpuset context, the "
"memory policy reverts to I<local allocation>.  This effectively overrides "
"the specified policy until the process's cpuset context includes one or more "
"of the nodes specified by I<nodemask>."
msgstr ""

#. type: Plain text
#: build/C/man2/set_mempolicy.2:171
msgid ""
"This mode specifies that any nondefault thread memory policy be removed, so "
"that the memory policy \"falls back\" to the system default policy.  The "
"system default policy is \"local allocation\"\\(emthat is, allocate memory "
"on the node of the CPU that triggered the allocation.  I<nodemask> must be "
"specified as NULL.  If the \"local node\" contains no free memory, the "
"system will attempt to allocate memory from a \"near by\" node."
msgstr ""

#. type: Plain text
#: build/C/man2/set_mempolicy.2:187
msgid ""
"This mode defines a strict policy that restricts memory allocation to the "
"nodes specified in I<nodemask>.  If I<nodemask> specifies more than one "
"node, page allocations will come from the node with the lowest numeric node "
"ID first, until that node contains no free memory.  Allocations will then "
"come from the node with the next highest node ID specified in I<nodemask> "
"and so forth, until none of the specified nodes contain free memory.  Pages "
"will not be allocated from any node not specified in the I<nodemask>."
msgstr ""

#.  NOTE:  the following sentence doesn't make sense in the context
#.  of set_mempolicy() -- no memory area specified.
#.  To be effective the memory area should be fairly large,
#.  at least 1 MB or bigger.
#. type: Plain text
#: build/C/man2/set_mempolicy.2:201
msgid ""
"This mode interleaves page allocations across the nodes specified in "
"I<nodemask> in numeric node ID order.  This optimizes for bandwidth instead "
"of latency by spreading out pages and memory accesses to those pages across "
"multiple nodes.  However, accesses to a single page will still be limited to "
"the memory bandwidth of a single node."
msgstr ""

#. type: Plain text
#: build/C/man2/set_mempolicy.2:218
msgid ""
"This mode sets the preferred node for allocation.  The kernel will try to "
"allocate pages from this node first and fall back to \"near by\" nodes if "
"the preferred node is low on free memory.  If I<nodemask> specifies more "
"than one node ID, the first node in the mask will be selected as the "
"preferred node.  If the I<nodemask> and I<maxnode> arguments specify the "
"empty set, then the policy specifies \"local allocation\" (like the system "
"default policy discussed above)."
msgstr ""

#.  commit 479e2802d09f1e18a97262c4c6f8f17ae5884bd8
#.  commit f2a07f40dbc603c15f8b06e6ec7f768af67b424f
#. type: Plain text
#: build/C/man2/set_mempolicy.2:237
msgid ""
"This mode specifies \"local allocation\"; the memory is allocated on the "
"node of the CPU that triggered the allocation (the \"local node\").  The "
"I<nodemask> and I<maxnode> arguments must specify the empty set.  If the "
"\"local node\" is low on free memory, the kernel will try to allocate memory "
"from other nodes.  The kernel will allocate memory from the \"local node\" "
"whenever memory for this node is available.  If the \"local node\" is not "
"allowed by the process's current cpuset context, the kernel will try to "
"allocate memory from other nodes.  The kernel will allocate memory from the "
"\"local node\" whenever it becomes allowed by the process's current cpuset "
"context."
msgstr ""

#. type: Plain text
#: build/C/man2/set_mempolicy.2:244
msgid ""
"The thread memory policy is preserved across an B<execve>(2), and is "
"inherited by child threads created using B<fork>(2)  or B<clone>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/set_mempolicy.2:251
msgid ""
"On success, B<set_mempolicy>()  returns 0; on error, -1 is returned and "
"I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/set_mempolicy.2:296
msgid ""
"I<mode> is invalid.  Or, I<mode> is B<MPOL_DEFAULT> and I<nodemask> is "
"nonempty, or I<mode> is B<MPOL_BIND> or B<MPOL_INTERLEAVE> and I<nodemask> "
"is empty.  Or, I<maxnode> specifies more than a page worth of bits.  Or, "
"I<nodemask> specifies one or more node IDs that are greater than the maximum "
"supported node ID.  Or, none of the node IDs specified by I<nodemask> are "
"on-line and allowed by the process's current cpuset context, or none of the "
"specified nodes contain memory.  Or, the I<mode> argument specified both "
"B<MPOL_F_STATIC_NODES> and B<MPOL_F_RELATIVE_NODES>."
msgstr ""

#. type: Plain text
#: build/C/man2/set_mempolicy.2:303
msgid ""
"The B<set_mempolicy>()  system call was added to the Linux kernel in version "
"2.6.7."
msgstr ""

#. type: Plain text
#: build/C/man2/set_mempolicy.2:310
msgid ""
"Memory policy is not remembered if the page is swapped out.  When such a "
"page is paged back in, it will use the policy of the thread or memory range "
"that is in effect at the time the page is allocated."
msgstr ""

#. type: Plain text
#: build/C/man2/set_mempolicy.2:322
msgid ""
"B<get_mempolicy>(2), B<getcpu>(2), B<mbind>(2), B<mmap>(2), B<numa>(3), "
"B<cpuset>(7), B<numa>(7), B<numactl>(8)"
msgstr ""
