# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-03-12 14:01+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man3/fnmatch.3:28
#, no-wrap
msgid "FNMATCH"
msgstr ""

#. type: TH
#: build/C/man3/fnmatch.3:28
#, no-wrap
msgid "2019-03-06"
msgstr ""

#. type: TH
#: build/C/man3/fnmatch.3:28 build/C/man3/glob.3:34 build/C/man3/re_comp.3:27 build/C/man3/regex.3:30
#, no-wrap
msgid "GNU"
msgstr ""

#. type: TH
#: build/C/man3/fnmatch.3:28 build/C/man3/glob.3:34 build/C/man7/glob.7:26 build/C/man3/re_comp.3:27 build/C/man3/regex.3:30 build/C/man7/regex.7:37 build/C/man3/wordexp.3:24
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr ""

#. type: SH
#: build/C/man3/fnmatch.3:29 build/C/man3/glob.3:35 build/C/man7/glob.7:27 build/C/man3/re_comp.3:28 build/C/man3/regex.3:31 build/C/man7/regex.7:38 build/C/man3/wordexp.3:25
#, no-wrap
msgid "NAME"
msgstr ""

#. type: Plain text
#: build/C/man3/fnmatch.3:31
msgid "fnmatch - match filename or pathname"
msgstr ""

#. type: SH
#: build/C/man3/fnmatch.3:31 build/C/man3/glob.3:37 build/C/man3/re_comp.3:30 build/C/man3/regex.3:33 build/C/man3/wordexp.3:27
#, no-wrap
msgid "SYNOPSIS"
msgstr ""

#. type: Plain text
#: build/C/man3/fnmatch.3:34
#, no-wrap
msgid "B<#include E<lt>fnmatch.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fnmatch.3:36
#, no-wrap
msgid ""
"B<int fnmatch(const char *>I<pattern>B<, const char *>I<string>B<, int "
">I<flags>B<);>\n"
msgstr ""

#. type: SH
#: build/C/man3/fnmatch.3:37 build/C/man3/glob.3:46 build/C/man7/glob.7:29 build/C/man3/re_comp.3:40 build/C/man3/regex.3:48 build/C/man7/regex.7:40 build/C/man3/wordexp.3:42
#, no-wrap
msgid "DESCRIPTION"
msgstr ""

#. type: Plain text
#: build/C/man3/fnmatch.3:46
msgid ""
"The B<fnmatch>()  function checks whether the I<string> argument matches the "
"I<pattern> argument, which is a shell wildcard pattern (see B<glob>(7))."
msgstr ""

#. type: Plain text
#: build/C/man3/fnmatch.3:51
msgid ""
"The I<flags> argument modifies the behavior; it is the bitwise OR of zero or "
"more of the following flags:"
msgstr ""

#. type: TP
#: build/C/man3/fnmatch.3:51
#, no-wrap
msgid "B<FNM_NOESCAPE>"
msgstr ""

#. type: Plain text
#: build/C/man3/fnmatch.3:55
msgid ""
"If this flag is set, treat backslash as an ordinary character, instead of an "
"escape character."
msgstr ""

#. type: TP
#: build/C/man3/fnmatch.3:55
#, no-wrap
msgid "B<FNM_PATHNAME>"
msgstr ""

#. type: Plain text
#: build/C/man3/fnmatch.3:63
msgid ""
"If this flag is set, match a slash in I<string> only with a slash in "
"I<pattern> and not by an asterisk (*) or a question mark (?) metacharacter, "
"nor by a bracket expression ([]) containing a slash."
msgstr ""

#. type: TP
#: build/C/man3/fnmatch.3:63
#, no-wrap
msgid "B<FNM_PERIOD>"
msgstr ""

#. type: Plain text
#: build/C/man3/fnmatch.3:74
msgid ""
"If this flag is set, a leading period in I<string> has to be matched exactly "
"by a period in I<pattern>.  A period is considered to be leading if it is "
"the first character in I<string>, or if both B<FNM_PATHNAME> is set and the "
"period immediately follows a slash."
msgstr ""

#. type: TP
#: build/C/man3/fnmatch.3:74
#, no-wrap
msgid "B<FNM_FILE_NAME>"
msgstr ""

#. type: Plain text
#: build/C/man3/fnmatch.3:78
msgid "This is a GNU synonym for B<FNM_PATHNAME>."
msgstr ""

#. type: TP
#: build/C/man3/fnmatch.3:78
#, no-wrap
msgid "B<FNM_LEADING_DIR>"
msgstr ""

#. type: Plain text
#: build/C/man3/fnmatch.3:86
msgid ""
"If this flag (a GNU extension) is set, the pattern is considered to be "
"matched if it matches an initial segment of I<string> which is followed by a "
"slash.  This flag is mainly for the internal use of glibc and is implemented "
"only in certain cases."
msgstr ""

#. type: TP
#: build/C/man3/fnmatch.3:86
#, no-wrap
msgid "B<FNM_CASEFOLD>"
msgstr ""

#. type: Plain text
#: build/C/man3/fnmatch.3:90
msgid ""
"If this flag (a GNU extension) is set, the pattern is matched "
"case-insensitively."
msgstr ""

#. type: TP
#: build/C/man3/fnmatch.3:90
#, no-wrap
msgid "B<FNM_EXTMATCH>"
msgstr ""

#. type: Plain text
#: build/C/man3/fnmatch.3:96
msgid ""
"If this flag (a GNU extension) is set, extended patterns are supported, as "
"introduced by \\&'ksh' and now supported by other shells.  The extended "
"format is as follows, with I<pattern-list> being a \\&'|' separated list of "
"patterns."
msgstr ""

#. type: TP
#: build/C/man3/fnmatch.3:96
#, no-wrap
msgid "\\&'?(I<pattern-list>)'"
msgstr ""

#. type: Plain text
#: build/C/man3/fnmatch.3:100
msgid ""
"The pattern matches if zero or one occurrences of any of the patterns in the "
"I<pattern-list> match the input I<string>."
msgstr ""

#. type: TP
#: build/C/man3/fnmatch.3:100
#, no-wrap
msgid "\\&'*(I<pattern-list>)'"
msgstr ""

#. type: Plain text
#: build/C/man3/fnmatch.3:104
msgid ""
"The pattern matches if zero or more occurrences of any of the patterns in "
"the I<pattern-list> match the input I<string>."
msgstr ""

#. type: TP
#: build/C/man3/fnmatch.3:104
#, no-wrap
msgid "\\&'+(I<pattern-list>)'"
msgstr ""

#. type: Plain text
#: build/C/man3/fnmatch.3:108
msgid ""
"The pattern matches if one or more occurrences of any of the patterns in the "
"I<pattern-list> match the input I<string>."
msgstr ""

#. type: TP
#: build/C/man3/fnmatch.3:108
#, no-wrap
msgid "\\&'@(I<pattern-list>)'"
msgstr ""

#. type: Plain text
#: build/C/man3/fnmatch.3:112
msgid ""
"The pattern matches if exactly one occurrence of any of the patterns in the "
"I<pattern-list> match the input I<string>."
msgstr ""

#. type: TP
#: build/C/man3/fnmatch.3:112
#, no-wrap
msgid "\\&'!(I<pattern-list>)'"
msgstr ""

#. type: Plain text
#: build/C/man3/fnmatch.3:116
msgid ""
"The pattern matches if the input I<string> cannot be matched with any of the "
"patterns in the I<pattern-list>."
msgstr ""

#. type: SH
#: build/C/man3/fnmatch.3:116 build/C/man3/glob.3:258 build/C/man3/re_comp.3:58 build/C/man3/regex.3:262 build/C/man3/wordexp.3:157
#, no-wrap
msgid "RETURN VALUE"
msgstr ""

#. type: Plain text
#: build/C/man3/fnmatch.3:123
msgid ""
"Zero if I<string> matches I<pattern>, B<FNM_NOMATCH> if there is no match or "
"another nonzero value if there is an error."
msgstr ""

#. type: SH
#: build/C/man3/fnmatch.3:123 build/C/man3/glob.3:272 build/C/man3/re_comp.3:66 build/C/man3/regex.3:319 build/C/man3/wordexp.3:187
#, no-wrap
msgid "ATTRIBUTES"
msgstr ""

#. type: Plain text
#: build/C/man3/fnmatch.3:126 build/C/man3/glob.3:275 build/C/man3/re_comp.3:69 build/C/man3/regex.3:322 build/C/man3/wordexp.3:190
msgid "For an explanation of the terms used in this section, see B<attributes>(7)."
msgstr ""

#. type: tbl table
#: build/C/man3/fnmatch.3:130 build/C/man3/glob.3:279 build/C/man3/re_comp.3:73 build/C/man3/regex.3:326 build/C/man3/wordexp.3:194
#, no-wrap
msgid "Interface"
msgstr ""

#. type: tbl table
#: build/C/man3/fnmatch.3:130 build/C/man3/glob.3:279 build/C/man3/re_comp.3:73 build/C/man3/regex.3:326 build/C/man3/wordexp.3:194
#, no-wrap
msgid "Attribute"
msgstr ""

#. type: tbl table
#: build/C/man3/fnmatch.3:130 build/C/man3/glob.3:279 build/C/man3/re_comp.3:73 build/C/man3/regex.3:326 build/C/man3/wordexp.3:194
#, no-wrap
msgid "Value"
msgstr ""

#. type: tbl table
#: build/C/man3/fnmatch.3:133
#, no-wrap
msgid "B<fnmatch>()"
msgstr ""

#. type: tbl table
#: build/C/man3/fnmatch.3:133 build/C/man3/glob.3:282 build/C/man3/glob.3:289 build/C/man3/re_comp.3:77 build/C/man3/regex.3:330 build/C/man3/regex.3:333 build/C/man3/regex.3:336 build/C/man3/wordexp.3:197 build/C/man3/wordexp.3:204
#, no-wrap
msgid "Thread safety"
msgstr ""

#. type: tbl table
#: build/C/man3/fnmatch.3:133
#, no-wrap
msgid "MT-Safe env locale"
msgstr ""

#. type: SH
#: build/C/man3/fnmatch.3:135 build/C/man3/glob.3:306 build/C/man3/re_comp.3:79 build/C/man3/regex.3:338 build/C/man3/wordexp.3:221
#, no-wrap
msgid "CONFORMING TO"
msgstr ""

#. type: Plain text
#: build/C/man3/fnmatch.3:140
msgid ""
"POSIX.1-2001, POSIX.1-2008, POSIX.2.  The B<FNM_FILE_NAME>, "
"B<FNM_LEADING_DIR>, and B<FNM_CASEFOLD> flags are GNU extensions."
msgstr ""

#. type: SH
#: build/C/man3/fnmatch.3:140 build/C/man3/glob.3:351 build/C/man7/glob.7:208 build/C/man3/re_comp.3:85 build/C/man3/regex.3:383 build/C/man7/regex.7:287 build/C/man3/wordexp.3:246
#, no-wrap
msgid "SEE ALSO"
msgstr ""

#. type: Plain text
#: build/C/man3/fnmatch.3:146
msgid "B<sh>(1), B<glob>(3), B<scandir>(3), B<wordexp>(3), B<glob>(7)"
msgstr ""

#. type: SH
#: build/C/man3/fnmatch.3:146 build/C/man3/glob.3:362 build/C/man7/glob.7:214 build/C/man3/re_comp.3:89 build/C/man3/regex.3:389 build/C/man7/regex.7:292 build/C/man3/wordexp.3:249
#, no-wrap
msgid "COLOPHON"
msgstr ""

#. type: Plain text
#: build/C/man3/fnmatch.3:154 build/C/man3/glob.3:370 build/C/man7/glob.7:222 build/C/man3/re_comp.3:97 build/C/man3/regex.3:397 build/C/man7/regex.7:300 build/C/man3/wordexp.3:257
msgid ""
"This page is part of release 5.10 of the Linux I<man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at "
"\\%https://www.kernel.org/doc/man-pages/."
msgstr ""

#. type: TH
#: build/C/man3/glob.3:34 build/C/man7/glob.7:26
#, no-wrap
msgid "GLOB"
msgstr ""

#. type: TH
#: build/C/man3/glob.3:34
#, no-wrap
msgid "2020-06-09"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:37
msgid "glob, globfree - find pathnames matching a pattern, free memory from glob()"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:40
#, no-wrap
msgid "B<#include E<lt>glob.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:45
#, no-wrap
msgid ""
"B<int glob(const char *>I<pattern>B<, int >I<flags>B<,>\n"
"B<         int (*>I<errfunc>B<) (const char *>I<epath>B<, int "
">I<eerrno>B<),>\n"
"B<         glob_t *>I<pglob>B<);>\n"
"B<void globfree(glob_t *>I<pglob>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:56
msgid ""
"The B<glob>()  function searches for all the pathnames matching I<pattern> "
"according to the rules used by the shell (see B<glob>(7)).  No tilde "
"expansion or parameter substitution is done; if you want these, use "
"B<wordexp>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:62
msgid ""
"The B<globfree>()  function frees the dynamically allocated storage from an "
"earlier call to B<glob>()."
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:73
msgid ""
"The results of a B<glob>()  call are stored in the structure pointed to by "
"I<pglob>.  This structure is of type I<glob_t> (declared in "
"I<E<lt>glob.hE<gt>>)  and includes the following elements defined by POSIX.2 "
"(more may be present as an extension):"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:81
#, no-wrap
msgid ""
"typedef struct {\n"
"    size_t   gl_pathc;    /* Count of paths matched so far  */\n"
"    char   **gl_pathv;    /* List of matched pathnames.  */\n"
"    size_t   gl_offs;     /* Slots to reserve in I<gl_pathv>.  */\n"
"} glob_t;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:85
msgid "Results are stored in dynamically allocated storage."
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:91
msgid ""
"The argument I<flags> is made up of the bitwise OR of zero or more the "
"following symbolic constants, which modify the behavior of B<glob>():"
msgstr ""

#. type: TP
#: build/C/man3/glob.3:91
#, no-wrap
msgid "B<GLOB_ERR>"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:99
msgid ""
"Return upon a read error (because a directory does not have read permission, "
"for example).  By default, B<glob>()  attempts carry on despite errors, "
"reading all of the directories that it can."
msgstr ""

#. type: TP
#: build/C/man3/glob.3:99
#, no-wrap
msgid "B<GLOB_MARK>"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:102
msgid "Append a slash to each path which corresponds to a directory."
msgstr ""

#. type: TP
#: build/C/man3/glob.3:102
#, no-wrap
msgid "B<GLOB_NOSORT>"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:107
msgid ""
"Don't sort the returned pathnames.  The only reason to do this is to save "
"processing time.  By default, the returned pathnames are sorted."
msgstr ""

#. type: TP
#: build/C/man3/glob.3:107
#, no-wrap
msgid "B<GLOB_DOOFFS>"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:114
msgid ""
"Reserve I<pglob-E<gt>gl_offs> slots at the beginning of the list of strings "
"in I<pglob-E<gt>pathv>.  The reserved slots contain null pointers."
msgstr ""

#. type: TP
#: build/C/man3/glob.3:114
#, no-wrap
msgid "B<GLOB_NOCHECK>"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:122
msgid ""
"If no pattern matches, return the original pattern.  By default, B<glob>()  "
"returns B<GLOB_NOMATCH> if there are no matches."
msgstr ""

#. type: TP
#: build/C/man3/glob.3:122
#, no-wrap
msgid "B<GLOB_APPEND>"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:129
msgid ""
"Append the results of this call to the vector of results returned by a "
"previous call to B<glob>().  Do not set this flag on the first invocation of "
"B<glob>()."
msgstr ""

#. type: TP
#: build/C/man3/glob.3:129
#, no-wrap
msgid "B<GLOB_NOESCAPE>"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:136
msgid ""
"Don't allow backslash (\\(aq\\e\\(aq) to be used as an escape character.  "
"Normally, a backslash can be used to quote the following character, "
"providing a mechanism to turn off the special meaning metacharacters."
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:140
msgid ""
"I<flags> may also include any of the following, which are GNU extensions and "
"not defined by POSIX.2:"
msgstr ""

#. type: TP
#: build/C/man3/glob.3:140
#, no-wrap
msgid "B<GLOB_PERIOD>"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:144
msgid ""
"Allow a leading period to be matched by metacharacters.  By default, "
"metacharacters can't match a leading period."
msgstr ""

#. type: TP
#: build/C/man3/glob.3:144
#, no-wrap
msgid "B<GLOB_ALTDIRFUNC>"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:154
msgid ""
"Use alternative functions I<pglob-E<gt>gl_closedir>, "
"I<pglob-E<gt>gl_readdir>, I<pglob-E<gt>gl_opendir>, I<pglob-E<gt>gl_lstat>, "
"and I<pglob-E<gt>gl_stat> for filesystem access instead of the normal "
"library functions."
msgstr ""

#. type: TP
#: build/C/man3/glob.3:154
#, no-wrap
msgid "B<GLOB_BRACE>"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:170
msgid ""
"Expand B<csh>(1)  style brace expressions of the form B<{a,b}>.  Brace "
"expressions can be nested.  Thus, for example, specifying the pattern "
"\"{foo/{,cat,dog},bar}\" would return the same results as four separate "
"B<glob>()  calls using the strings: \"foo/\", \"foo/cat\", \"foo/dog\", and "
"\"bar\"."
msgstr ""

#. type: TP
#: build/C/man3/glob.3:170
#, no-wrap
msgid "B<GLOB_NOMAGIC>"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:175
msgid ""
"If the pattern contains no metacharacters, then it should be returned as the "
"sole matching word, even if there is no file with that name."
msgstr ""

#. type: TP
#: build/C/man3/glob.3:175
#, no-wrap
msgid "B<GLOB_TILDE>"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:187
msgid ""
"Carry out tilde expansion.  If a tilde (\\(aq\\(ti\\(aq) is the only "
"character in the pattern, or an initial tilde is followed immediately by a "
"slash (\\(aq/\\(aq), then the home directory of the caller is substituted "
"for the tilde.  If an initial tilde is followed by a username (e.g., "
"\"\\(tiandrea/bin\"), then the tilde and username are substituted by the "
"home directory of that user.  If the username is invalid, or the home "
"directory cannot be determined, then no substitution is performed."
msgstr ""

#. type: TP
#: build/C/man3/glob.3:187
#, no-wrap
msgid "B<GLOB_TILDE_CHECK>"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:198
msgid ""
"This provides behavior similar to that of B<GLOB_TILDE>.  The difference is "
"that if the username is invalid, or the home directory cannot be determined, "
"then instead of using the pattern itself as the name, B<glob>()  returns "
"B<GLOB_NOMATCH> to indicate an error."
msgstr ""

#. type: TP
#: build/C/man3/glob.3:198
#, no-wrap
msgid "B<GLOB_ONLYDIR>"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:211
msgid ""
"This is a I<hint> to B<glob>()  that the caller is interested only in "
"directories that match the pattern.  If the implementation can easily "
"determine file-type information, then nondirectory files are not returned to "
"the caller.  However, the caller must still check that returned files are "
"directories.  (The purpose of this flag is merely to optimize performance "
"when the caller is interested only in directories.)"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:234
msgid ""
"If I<errfunc> is not NULL, it will be called in case of an error with the "
"arguments I<epath>, a pointer to the path which failed, and I<eerrno>, the "
"value of I<errno> as returned from one of the calls to B<opendir>(3), "
"B<readdir>(3), or B<stat>(2).  If I<errfunc> returns nonzero, or if "
"B<GLOB_ERR> is set, B<glob>()  will terminate after the call to I<errfunc>."
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:241
msgid ""
"Upon successful return, I<pglob-E<gt>gl_pathc> contains the number of "
"matched pathnames and I<pglob-E<gt>gl_pathv> contains a pointer to the list "
"of pointers to matched pathnames.  The list of pointers is terminated by a "
"null pointer."
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:250
msgid ""
"It is possible to call B<glob>()  several times.  In that case, the "
"B<GLOB_APPEND> flag has to be set in I<flags> on the second and later "
"invocations."
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:258
msgid ""
"As a GNU extension, I<pglob-E<gt>gl_flags> is set to the flags specified, "
"B<or>ed with B<GLOB_MAGCHAR> if any metacharacters were found."
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:263
msgid ""
"On successful completion, B<glob>()  returns zero.  Other possible returns "
"are:"
msgstr ""

#. type: TP
#: build/C/man3/glob.3:263
#, no-wrap
msgid "B<GLOB_NOSPACE>"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:266
msgid "for running out of memory,"
msgstr ""

#. type: TP
#: build/C/man3/glob.3:266
#, no-wrap
msgid "B<GLOB_ABORTED>"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:269
msgid "for a read error, and"
msgstr ""

#. type: TP
#: build/C/man3/glob.3:269
#, no-wrap
msgid "B<GLOB_NOMATCH>"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:272
msgid "for no found matches."
msgstr ""

#. type: tbl table
#: build/C/man3/glob.3:282
#, no-wrap
msgid "B<glob>()"
msgstr ""

#. type: tbl table
#: build/C/man3/glob.3:284
#, no-wrap
msgid "MT-Unsafe race:utent env\n"
msgstr ""

#. type: tbl table
#: build/C/man3/glob.3:284 build/C/man3/wordexp.3:199
#, no-wrap
msgid ".br\n"
msgstr ""

#. type: tbl table
#: build/C/man3/glob.3:286
#, no-wrap
msgid "sig:ALRM timer locale"
msgstr ""

#. type: tbl table
#: build/C/man3/glob.3:289
#, no-wrap
msgid "B<globfree>()"
msgstr ""

#. type: tbl table
#: build/C/man3/glob.3:289 build/C/man3/regex.3:336 build/C/man3/wordexp.3:204
#, no-wrap
msgid "MT-Safe"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:306
msgid ""
"In the above table, I<utent> in I<race:utent> signifies that if any of the "
"functions B<setutent>(3), B<getutent>(3), or B<endutent>(3)  are used in "
"parallel in different threads of a program, then data races could occur.  "
"B<glob>()  calls those functions, so we use race:utent to remind users."
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:308
msgid "POSIX.1-2001, POSIX.1-2008, POSIX.2."
msgstr ""

#. type: SH
#: build/C/man3/glob.3:308 build/C/man7/glob.7:142 build/C/man3/re_comp.3:81
#, no-wrap
msgid "NOTES"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:319
msgid ""
"The structure elements I<gl_pathc> and I<gl_offs> are declared as I<size_t> "
"in glibc 2.1, as they should be according to POSIX.2, but are declared as "
"I<int> in glibc 2.0."
msgstr ""

#. type: SH
#: build/C/man3/glob.3:319 build/C/man7/regex.7:260
#, no-wrap
msgid "BUGS"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:328
msgid ""
"The B<glob>()  function may fail due to failure of underlying function "
"calls, such as B<malloc>(3)  or B<opendir>(3).  These will store their error "
"code in I<errno>."
msgstr ""

#. type: SH
#: build/C/man3/glob.3:328 build/C/man3/regex.3:340 build/C/man3/wordexp.3:223
#, no-wrap
msgid "EXAMPLES"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:330
msgid "One example of use is the following code, which simulates typing"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:334
#, no-wrap
msgid "ls -l *.c ../*.c\n"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:338
msgid "in the shell:"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:342
#, no-wrap
msgid "glob_t globbuf;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:349
#, no-wrap
msgid ""
"globbuf.gl_offs = 2;\n"
"glob(\"*.c\", GLOB_DOOFFS, NULL, &globbuf);\n"
"glob(\"../*.c\", GLOB_DOOFFS | GLOB_APPEND, NULL, &globbuf);\n"
"globbuf.gl_pathv[0] = \"ls\";\n"
"globbuf.gl_pathv[1] = \"-l\";\n"
"execvp(\"ls\", &globbuf.gl_pathv[0]);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:362
msgid ""
"B<ls>(1), B<sh>(1), B<stat>(2), B<exec>(3), B<fnmatch>(3), B<malloc>(3), "
"B<opendir>(3), B<readdir>(3), B<wordexp>(3), B<glob>(7)"
msgstr ""

#. type: TH
#: build/C/man7/glob.7:26 build/C/man3/regex.3:30 build/C/man7/regex.7:37
#, no-wrap
msgid "2020-08-13"
msgstr ""

#. type: TH
#: build/C/man7/glob.7:26
#, no-wrap
msgid "Linux"
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:29
msgid "glob - globbing pathnames"
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:34
msgid ""
"Long ago, in UNIX\\ V6, there was a program I</etc/glob> that would expand "
"wildcard patterns.  Soon afterward this became a shell built-in."
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:38
msgid ""
"These days there is also a library routine B<glob>(3)  that will perform "
"this function for a user program."
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:40
msgid "The rules are as follows (POSIX.2, 3.13)."
msgstr ""

#. type: SS
#: build/C/man7/glob.7:40
#, no-wrap
msgid "Wildcard matching"
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:47
msgid ""
"A string is a wildcard pattern if it contains one of the characters "
"\\(aq?\\(aq, \\(aq*\\(aq or \\(aq[\\(aq.  Globbing is the operation that "
"expands a wildcard pattern into the list of pathnames matching the pattern.  "
"Matching is defined by:"
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:49
msgid "A \\(aq?\\(aq (not between brackets) matches any single character."
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:52
msgid ""
"A \\(aq*\\(aq (not between brackets) matches any string, including the empty "
"string."
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:54
msgid "B<Character classes>"
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:63
msgid ""
"An expression \"I<[...]>\" where the first character after the leading "
"\\(aq[\\(aq is not an \\(aq!\\(aq matches a single character, namely any of "
"the characters enclosed by the brackets.  The string enclosed by the "
"brackets cannot be empty; therefore \\(aq]\\(aq can be allowed between the "
"brackets, provided that it is the first character.  (Thus, \"I<[][!]>\" "
"matches the three characters \\(aq[\\(aq, \\(aq]\\(aq and \\(aq!\\(aq.)"
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:65
msgid "B<Ranges>"
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:76
msgid ""
"There is one special convention: two characters separated by \\(aq-\\(aq "
"denote a range.  (Thus, \"I<[A-Fa-f0-9]>\" is equivalent to "
"\"I<[ABCDEFabcdef0123456789]>\".)  One may include \\(aq-\\(aq in its "
"literal meaning by making it the first or last character between the "
"brackets.  (Thus, \"I<[]-]>\" matches just the two characters \\(aq]\\(aq "
"and \\(aq-\\(aq, and \"I<[--0]>\" matches the three characters \\(aq-\\(aq, "
"\\(aq.\\(aq, \\(aq0\\(aq, since \\(aq/\\(aq cannot be matched.)"
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:78
msgid "B<Complementation>"
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:84
msgid ""
"An expression \"I<[!...]>\" matches a single character, namely any character "
"that is not matched by the expression obtained by removing the first "
"\\(aq!\\(aq from it.  (Thus, \"I<[!]a-]>\" matches any single character "
"except \\(aq]\\(aq, \\(aqa\\(aq and \\(aq-\\(aq.)"
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:91
msgid ""
"One can remove the special meaning of \\(aq?\\(aq, \\(aq*\\(aq and "
"\\(aq[\\(aq by preceding them by a backslash, or, in case this is part of a "
"shell command line, enclosing them in quotes.  Between brackets these "
"characters stand for themselves.  Thus, \"I<[[?*\\e]>\" matches the four "
"characters \\(aq[\\(aq, \\(aq?\\(aq, \\(aq*\\(aq and \\(aq\\e\\(aq."
msgstr ""

#. type: SS
#: build/C/man7/glob.7:91
#, no-wrap
msgid "Pathnames"
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:98
msgid ""
"Globbing is applied on each of the components of a pathname separately.  A "
"\\(aq/\\(aq in a pathname cannot be matched by a \\(aq?\\(aq or \\(aq*\\(aq "
"wildcard, or by a range like \"I<[.-0]>\".  A range containing an explicit "
"\\(aq/\\(aq character is syntactically incorrect.  (POSIX requires that "
"syntactically incorrect patterns are left unchanged.)"
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:103
msgid ""
"If a filename starts with a \\(aq.\\(aq, this character must be matched "
"explicitly.  (Thus, I<rm\\ *> will not remove .profile, and I<tar\\ c\\ *> "
"will not archive all your files; I<tar\\ c\\ .> is better.)"
msgstr ""

#. type: SS
#: build/C/man7/glob.7:103
#, no-wrap
msgid "Empty lists"
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:109
msgid ""
"The nice and simple rule given above: \"expand a wildcard pattern into the "
"list of matching pathnames\" was the original UNIX definition.  It allowed "
"one to have patterns that expand into an empty list, as in"
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:112
#, no-wrap
msgid "    xv -wait 0 *.gif *.jpg\n"
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:122
msgid ""
"where perhaps no *.gif files are present (and this is not an error).  "
"However, POSIX requires that a wildcard pattern is left unchanged when it is "
"syntactically incorrect, or the list of matching pathnames is empty.  With "
"I<bash> one can force the classical behavior using this command:"
msgstr ""

#.  In Bash v1, by setting allow_null_glob_expansion=true
#. type: Plain text
#: build/C/man7/glob.7:125
#, no-wrap
msgid "    shopt -s nullglob\n"
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:128
msgid "(Similar problems occur elsewhere.  For example, where old scripts have"
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:131
#, no-wrap
msgid "    rm \\`find . -name \"*\\(ti\"\\`\n"
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:134
msgid "new scripts require"
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:137
#, no-wrap
msgid "    rm -f nosuchfile \\`find . -name \"*\\(ti\"\\`\n"
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:142
msgid "to avoid error messages from I<rm> called with an empty argument list.)"
msgstr ""

#. type: SS
#: build/C/man7/glob.7:143
#, no-wrap
msgid "Regular expressions"
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:150
msgid ""
"Note that wildcard patterns are not regular expressions, although they are a "
"bit similar.  First of all, they match filenames, rather than text, and "
"secondly, the conventions are not the same: for example, in a regular "
"expression \\(aq*\\(aq means zero or more copies of the preceding thing."
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:154
msgid ""
"Now that regular expressions have bracket expressions where the negation is "
"indicated by a \\(aq\\(ha\\(aq, POSIX has declared the effect of a wildcard "
"pattern \"I<[\\(ha...]>\" to be undefined."
msgstr ""

#. type: SS
#: build/C/man7/glob.7:154
#, no-wrap
msgid "Character classes and internationalization"
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:172
msgid ""
"Of course ranges were originally meant to be ASCII ranges, so that \"I<[\\ "
"-%]>\" stands for \"I<[\\ !\"#$%]>\" and \"I<[a-z]>\" stands for \"any "
"lowercase letter\".  Some UNIX implementations generalized this so that a "
"range X-Y stands for the set of characters with code between the codes for X "
"and for Y.  However, this requires the user to know the character coding in "
"use on the local system, and moreover, is not convenient if the collating "
"sequence for the local alphabet differs from the ordering of the character "
"codes.  Therefore, POSIX extended the bracket notation greatly, both for "
"wildcard patterns and for regular expressions.  In the above we saw three "
"types of items that can occur in a bracket expression: namely (i) the "
"negation, (ii) explicit single characters, and (iii) ranges.  POSIX "
"specifies ranges in an internationally more useful way and adds three more "
"types:"
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:178
msgid ""
"(iii) Ranges X-Y comprise all characters that fall between X and Y "
"(inclusive) in the current collating sequence as defined by the "
"B<LC_COLLATE> category in the current locale."
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:180
msgid "(iv) Named character classes, like"
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:185
#, no-wrap
msgid ""
"[:alnum:]  [:alpha:]  [:blank:]  [:cntrl:]\n"
"[:digit:]  [:graph:]  [:lower:]  [:print:]\n"
"[:punct:]  [:space:]  [:upper:]  [:xdigit:]\n"
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:194
msgid ""
"so that one can say \"I<[[:lower:]]>\" instead of \"I<[a-z]>\", and have "
"things work in Denmark, too, where there are three letters past \\(aqz\\(aq "
"in the alphabet.  These character classes are defined by the B<LC_CTYPE> "
"category in the current locale."
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:200
msgid ""
"(v) Collating symbols, like \"I<[.ch.]>\" or \"I<[.a-acute.]>\", where the "
"string between \"I<[.>\" and \"I<.]>\" is a collating element defined for "
"the current locale.  Note that this may be a multicharacter element."
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:208
msgid ""
"(vi) Equivalence class expressions, like \"I<[=a=]>\", where the string "
"between \"I<[=>\" and \"I<=]>\" is any collating element from its "
"equivalence class, as defined for the current locale.  For example, "
"\"I<[[=a=]]>\" might be equivalent to \"I<[a\\('a\\(\\`a\\(:a\\(^a]>\", that "
"is, to \"I<[a[.a-acute.][.a-grave.][.a-umlaut.][.a-circumflex.]]>\"."
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:214
msgid "B<sh>(1), B<fnmatch>(3), B<glob>(3), B<locale>(7), B<regex>(7)"
msgstr ""

#. type: TH
#: build/C/man3/re_comp.3:27
#, no-wrap
msgid "RE_COMP"
msgstr ""

#. type: TH
#: build/C/man3/re_comp.3:27
#, no-wrap
msgid "2017-09-15"
msgstr ""

#. type: Plain text
#: build/C/man3/re_comp.3:30
msgid "re_comp, re_exec - BSD regex functions"
msgstr ""

#. type: Plain text
#: build/C/man3/re_comp.3:32
msgid "B<#define _REGEX_RE_COMP>"
msgstr ""

#. type: Plain text
#: build/C/man3/re_comp.3:34
msgid "B<#include E<lt>sys/types.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man3/re_comp.3:36
msgid "B<#include E<lt>regex.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man3/re_comp.3:38
msgid "B<char *re_comp(const char *>I<regex>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/re_comp.3:40
msgid "B<int re_exec(const char *>I<string>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/re_comp.3:52
msgid ""
"B<re_comp>()  is used to compile the null-terminated regular expression "
"pointed to by I<regex>.  The compiled pattern occupies a static area, the "
"pattern buffer, which is overwritten by subsequent use of B<re_comp>().  If "
"I<regex> is NULL, no operation is performed and the pattern buffer's "
"contents are not altered."
msgstr ""

#. type: Plain text
#: build/C/man3/re_comp.3:58
msgid ""
"B<re_exec>()  is used to assess whether the null-terminated string pointed "
"to by I<string> matches the previously compiled I<regex>."
msgstr ""

#. type: Plain text
#: build/C/man3/re_comp.3:63
msgid ""
"B<re_comp>()  returns NULL on successful compilation of I<regex> otherwise "
"it returns a pointer to an appropriate error message."
msgstr ""

#. type: Plain text
#: build/C/man3/re_comp.3:66
msgid "B<re_exec>()  returns 1 for a successful match, zero for failure."
msgstr ""

#. type: tbl table
#: build/C/man3/re_comp.3:77
#, no-wrap
msgid ""
"B<re_comp>(),\n"
"B<re_exec>()"
msgstr ""

#. type: tbl table
#: build/C/man3/re_comp.3:77
#, no-wrap
msgid "MT-Unsafe"
msgstr ""

#. type: Plain text
#: build/C/man3/re_comp.3:81
msgid "4.3BSD."
msgstr ""

#. type: Plain text
#: build/C/man3/re_comp.3:85
msgid ""
"These functions are obsolete; the functions documented in B<regcomp>(3)  "
"should be used instead."
msgstr ""

#. type: Plain text
#: build/C/man3/re_comp.3:89
msgid "B<regcomp>(3), B<regex>(7), GNU regex manual"
msgstr ""

#. type: TH
#: build/C/man3/regex.3:30 build/C/man7/regex.7:37
#, no-wrap
msgid "REGEX"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:33
msgid "regcomp, regexec, regerror, regfree - POSIX regex functions"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:36
#, no-wrap
msgid "B<#include E<lt>regex.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:38
#, no-wrap
msgid ""
"B<int regcomp(regex_t *>I<preg>B<, const char *>I<regex>B<, int "
">I<cflags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:42
#, no-wrap
msgid ""
"B<int regexec(const regex_t *>I<preg>B<, const char *>I<string>B<, size_t "
">I<nmatch>B<,>\n"
"B<            regmatch_t >I<pmatch[]>B<, int >I<eflags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:45
#, no-wrap
msgid ""
"B<size_t regerror(int >I<errcode>B<, const regex_t *>I<preg>B<, char "
"*>I<errbuf>B<,>\n"
"B<                size_t >I<errbuf_size>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:47
#, no-wrap
msgid "B<void regfree(regex_t *>I<preg>B<);>\n"
msgstr ""

#. type: SS
#: build/C/man3/regex.3:49
#, no-wrap
msgid "POSIX regex compiling"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:55
msgid ""
"B<regcomp>()  is used to compile a regular expression into a form that is "
"suitable for subsequent B<regexec>()  searches."
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:64
msgid ""
"B<regcomp>()  is supplied with I<preg>, a pointer to a pattern buffer "
"storage area; I<regex>, a pointer to the null-terminated string and "
"I<cflags>, flags used to determine the type of compilation."
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:71
msgid ""
"All regular expression searching must be done via a compiled pattern buffer, "
"thus B<regexec>()  must always be supplied with the address of a "
"B<regcomp>()  initialized pattern buffer."
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:76
msgid "I<cflags> is the bitwise-B<or> of zero or more of the following:"
msgstr ""

#. type: TP
#: build/C/man3/regex.3:76
#, no-wrap
msgid "B<REG_EXTENDED>"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:85
msgid ""
"Use B<POSIX> Extended Regular Expression syntax when interpreting I<regex>.  "
"If not set, B<POSIX> Basic Regular Expression syntax is used."
msgstr ""

#. type: TP
#: build/C/man3/regex.3:85
#, no-wrap
msgid "B<REG_ICASE>"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:91
msgid ""
"Do not differentiate case.  Subsequent B<regexec>()  searches using this "
"pattern buffer will be case insensitive."
msgstr ""

#. type: TP
#: build/C/man3/regex.3:91
#, no-wrap
msgid "B<REG_NOSUB>"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:101
msgid ""
"Do not report position of matches.  The I<nmatch> and I<pmatch> arguments to "
"B<regexec>()  are ignored if the pattern buffer supplied was compiled with "
"this flag set."
msgstr ""

#. type: TP
#: build/C/man3/regex.3:101
#, no-wrap
msgid "B<REG_NEWLINE>"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:104
msgid "Match-any-character operators don't match a newline."
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:108
msgid ""
"A nonmatching list (B<[\\(ha...]>)  not containing a newline does not match "
"a newline."
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:118
msgid ""
"Match-beginning-of-line operator (B<\\(ha>)  matches the empty string "
"immediately after a newline, regardless of whether I<eflags>, the execution "
"flags of B<regexec>(), contains B<REG_NOTBOL>."
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:126
msgid ""
"Match-end-of-line operator (B<$>)  matches the empty string immediately "
"before a newline, regardless of whether I<eflags> contains B<REG_NOTEOL>."
msgstr ""

#. type: SS
#: build/C/man3/regex.3:126
#, no-wrap
msgid "POSIX regex matching"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:139
msgid ""
"B<regexec>()  is used to match a null-terminated string against the "
"precompiled pattern buffer, I<preg>.  I<nmatch> and I<pmatch> are used to "
"provide information regarding the location of any matches.  I<eflags> is the "
"bitwise-B<or> of zero or more of the following flags:"
msgstr ""

#. type: TP
#: build/C/man3/regex.3:139
#, no-wrap
msgid "B<REG_NOTBOL>"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:149
msgid ""
"The match-beginning-of-line operator always fails to match (but see the "
"compilation flag B<REG_NEWLINE> above).  This flag may be used when "
"different portions of a string are passed to B<regexec>()  and the beginning "
"of the string should not be interpreted as the beginning of the line."
msgstr ""

#. type: TP
#: build/C/man3/regex.3:149
#, no-wrap
msgid "B<REG_NOTEOL>"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:155
msgid ""
"The match-end-of-line operator always fails to match (but see the "
"compilation flag B<REG_NEWLINE> above)."
msgstr ""

#. type: TP
#: build/C/man3/regex.3:155
#, no-wrap
msgid "B<REG_STARTEND>"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:175
msgid ""
"Use I<pmatch[0]> on the input string, starting at byte I<pmatch[0].rm_so> "
"and ending before byte I<pmatch[0].rm_eo>.  This allows matching embedded "
"NUL bytes and avoids a B<strlen>(3)  on large strings.  It does not use "
"I<nmatch> on input, and does not change B<REG_NOTBOL> or B<REG_NEWLINE> "
"processing.  This flag is a BSD extension, not present in POSIX."
msgstr ""

#. type: SS
#: build/C/man3/regex.3:175
#, no-wrap
msgid "Byte offsets"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:200
msgid ""
"Unless B<REG_NOSUB> was set for the compilation of the pattern buffer, it is "
"possible to obtain match addressing information.  I<pmatch> must be "
"dimensioned to have at least I<nmatch> elements.  These are filled in by "
"B<regexec>()  with substring match addresses.  The offsets of the "
"subexpression starting at the I<i>th open parenthesis are stored in "
"I<pmatch[i]>.  The entire regular expression's match addresses are stored in "
"I<pmatch[0]>.  (Note that to return the offsets of I<N> subexpression "
"matches, I<nmatch> must be at least I<N+1>.)  Any unused structure elements "
"will contain the value -1."
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:207
msgid ""
"The I<regmatch_t> structure which is the type of I<pmatch> is defined in "
"I<E<lt>regex.hE<gt>>."
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:214
#, no-wrap
msgid ""
"typedef struct {\n"
"    regoff_t rm_so;\n"
"    regoff_t rm_eo;\n"
"} regmatch_t;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:225
msgid ""
"Each I<rm_so> element that is not -1 indicates the start offset of the next "
"largest substring match within the string.  The relative I<rm_eo> element "
"indicates the end offset of the match, which is the offset of the first "
"character after the matching text."
msgstr ""

#. type: SS
#: build/C/man3/regex.3:225
#, no-wrap
msgid "POSIX error reporting"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:232
msgid ""
"B<regerror>()  is used to turn the error codes that can be returned by both "
"B<regcomp>()  and B<regexec>()  into error message strings."
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:254
msgid ""
"B<regerror>()  is passed the error code, I<errcode>, the pattern buffer, "
"I<preg>, a pointer to a character string buffer, I<errbuf>, and the size of "
"the string buffer, I<errbuf_size>.  It returns the size of the I<errbuf> "
"required to contain the null-terminated error message string.  If both "
"I<errbuf> and I<errbuf_size> are nonzero, I<errbuf> is filled in with the "
"first I<errbuf_size - 1> characters of the error message and a terminating "
"null byte (\\(aq\\e0\\(aq)."
msgstr ""

#. type: SS
#: build/C/man3/regex.3:254
#, no-wrap
msgid "POSIX pattern buffer freeing"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:262
msgid ""
"Supplying B<regfree>()  with a precompiled pattern buffer, I<preg> will free "
"the memory allocated to the pattern buffer by the compiling process, "
"B<regcomp>()."
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:265
msgid ""
"B<regcomp>()  returns zero for a successful compilation or an error code for "
"failure."
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:270
msgid ""
"B<regexec>()  returns zero for a successful match or B<REG_NOMATCH> for "
"failure."
msgstr ""

#. type: SH
#: build/C/man3/regex.3:270
#, no-wrap
msgid "ERRORS"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:273
msgid "The following errors can be returned by B<regcomp>():"
msgstr ""

#. type: TP
#: build/C/man3/regex.3:273
#, no-wrap
msgid "B<REG_BADBR>"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:276
msgid "Invalid use of back reference operator."
msgstr ""

#. type: TP
#: build/C/man3/regex.3:276
#, no-wrap
msgid "B<REG_BADPAT>"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:279
msgid "Invalid use of pattern operators such as group or list."
msgstr ""

#. type: TP
#: build/C/man3/regex.3:279
#, no-wrap
msgid "B<REG_BADRPT>"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:283
msgid ""
"Invalid use of repetition operators such as using \\(aq*\\(aq as the first "
"character."
msgstr ""

#. type: TP
#: build/C/man3/regex.3:283
#, no-wrap
msgid "B<REG_EBRACE>"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:286
msgid "Un-matched brace interval operators."
msgstr ""

#. type: TP
#: build/C/man3/regex.3:286
#, no-wrap
msgid "B<REG_EBRACK>"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:289
msgid "Un-matched bracket list operators."
msgstr ""

#. type: TP
#: build/C/man3/regex.3:289
#, no-wrap
msgid "B<REG_ECOLLATE>"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:292
msgid "Invalid collating element."
msgstr ""

#. type: TP
#: build/C/man3/regex.3:292
#, no-wrap
msgid "B<REG_ECTYPE>"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:295
msgid "Unknown character class name."
msgstr ""

#. type: TP
#: build/C/man3/regex.3:295
#, no-wrap
msgid "B<REG_EEND>"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:299
msgid "Nonspecific error.  This is not defined by POSIX.2."
msgstr ""

#. type: TP
#: build/C/man3/regex.3:299
#, no-wrap
msgid "B<REG_EESCAPE>"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:302
msgid "Trailing backslash."
msgstr ""

#. type: TP
#: build/C/man3/regex.3:302
#, no-wrap
msgid "B<REG_EPAREN>"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:305
msgid "Un-matched parenthesis group operators."
msgstr ""

#. type: TP
#: build/C/man3/regex.3:305
#, no-wrap
msgid "B<REG_ERANGE>"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:309
msgid ""
"Invalid use of the range operator; for example, the ending point of the "
"range occurs prior to the starting point."
msgstr ""

#. type: TP
#: build/C/man3/regex.3:309
#, no-wrap
msgid "B<REG_ESIZE>"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:313
msgid ""
"Compiled regular expression requires a pattern buffer larger than 64\\ kB.  "
"This is not defined by POSIX.2."
msgstr ""

#. type: TP
#: build/C/man3/regex.3:313
#, no-wrap
msgid "B<REG_ESPACE>"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:316
msgid "The regex routines ran out of memory."
msgstr ""

#. type: TP
#: build/C/man3/regex.3:316
#, no-wrap
msgid "B<REG_ESUBREG>"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:319
msgid "Invalid back reference to a subexpression."
msgstr ""

#. type: tbl table
#: build/C/man3/regex.3:330
#, no-wrap
msgid ""
"B<regcomp>(),\n"
"B<regexec>()"
msgstr ""

#. type: tbl table
#: build/C/man3/regex.3:330
#, no-wrap
msgid "MT-Safe locale"
msgstr ""

#. type: tbl table
#: build/C/man3/regex.3:333
#, no-wrap
msgid "B<regerror>()"
msgstr ""

#. type: tbl table
#: build/C/man3/regex.3:333
#, no-wrap
msgid "MT-Safe env"
msgstr ""

#. type: tbl table
#: build/C/man3/regex.3:336
#, no-wrap
msgid "B<regfree>()"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:340 build/C/man3/wordexp.3:223
msgid "POSIX.1-2001, POSIX.1-2008."
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:346
#, no-wrap
msgid ""
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>regex.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:348
#, no-wrap
msgid "#define ARRAY_SIZE(arr) (sizeof((arr)) / sizeof((arr)[0]))\n"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:352
#, no-wrap
msgid ""
"static const char *const str =\n"
"        \"1) John Driverhacker;\\en2) John Doe;\\en3) John Foo;\\en\";\n"
"static const char *const re = \"John.*o\";\n"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:359
#, no-wrap
msgid ""
"int main(void)\n"
"{\n"
"    static const char *s = str;\n"
"    regex_t     regex;\n"
"    regmatch_t  pmatch[1];\n"
"    regoff_t    off, len;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:362
#, no-wrap
msgid ""
"    if (regcomp(&regex, re, REG_NEWLINE))\n"
"        exit(EXIT_FAILURE);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:365
#, no-wrap
msgid ""
"    printf(\"String = \\e\"%s\\e\"\\en\", str);\n"
"    printf(\"Matches:\\en\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:369
#, no-wrap
msgid ""
"    for (int i = 0; ; i++) {\n"
"        if (regexec(&regex, s, ARRAY_SIZE(pmatch), pmatch, 0))\n"
"            break;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:376
#, no-wrap
msgid ""
"        off = pmatch[0].rm_so + (s - str);\n"
"        len = pmatch[0].rm_eo - pmatch[0].rm_so;\n"
"        printf(\"#%d:\\en\", i);\n"
"        printf(\"offset = %jd; length = %jd\\en\", (intmax_t) off,\n"
"                (intmax_t) len);\n"
"        printf(\"substring = \\e\"%.*s\\e\"\\en\", len, s + "
"pmatch[0].rm_so);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:379
#, no-wrap
msgid ""
"        s += pmatch[0].rm_eo;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:382
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:386
msgid "B<grep>(1), B<regex>(7)"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:389
msgid "The glibc manual section, I<Regular Expressions>"
msgstr ""

#. type: Plain text
#: build/C/man7/regex.7:40
msgid "regex - POSIX.2 regular expressions"
msgstr ""

#. type: Plain text
#: build/C/man7/regex.7:54
msgid ""
"Regular expressions (\"RE\"s), as defined in POSIX.2, come in two forms: "
"modern REs (roughly those of I<egrep>; POSIX.2 calls these \"extended\" REs)  "
"and obsolete REs (roughly those of B<ed>(1); POSIX.2 \"basic\" REs).  "
"Obsolete REs mostly exist for backward compatibility in some old programs; "
"they will be discussed at the end.  POSIX.2 leaves some aspects of RE syntax "
"and semantics open; \"\\*(dg\" marks decisions on these aspects that may not "
"be fully portable to other POSIX.2 implementations."
msgstr ""

#. type: Plain text
#: build/C/man7/regex.7:58
msgid ""
"A (modern) RE is one\\*(dg or more nonempty\\*(dg I<branches>, separated by "
"\\(aq|\\(aq.  It matches anything that matches one of the branches."
msgstr ""

#. type: Plain text
#: build/C/man7/regex.7:62
msgid ""
"A branch is one\\*(dg or more I<pieces>, concatenated.  It matches a match "
"for the first, followed by a match for the second, and so on."
msgstr ""

#. type: Plain text
#: build/C/man7/regex.7:71
msgid ""
"A piece is an I<atom> possibly followed by a single\\*(dg \\(aq*\\(aq, "
"\\(aq+\\(aq, \\(aq?\\(aq, or I<bound>.  An atom followed by \\(aq*\\(aq "
"matches a sequence of 0 or more matches of the atom.  An atom followed by "
"\\(aq+\\(aq matches a sequence of 1 or more matches of the atom.  An atom "
"followed by \\(aq?\\(aq matches a sequence of 0 or 1 matches of the atom."
msgstr ""

#. type: Plain text
#: build/C/man7/regex.7:89
msgid ""
"A I<bound> is \\(aq{\\(aq followed by an unsigned decimal integer, possibly "
"followed by \\(aq,\\(aq possibly followed by another unsigned decimal "
"integer, always followed by \\(aq}\\(aq.  The integers must lie between 0 "
"and B<RE_DUP_MAX> (255\\*(dg) inclusive, and if there are two of them, the "
"first may not exceed the second.  An atom followed by a bound containing one "
"integer I<i> and no comma matches a sequence of exactly I<i> matches of the "
"atom.  An atom followed by a bound containing one integer I<i> and a comma "
"matches a sequence of I<i> or more matches of the atom.  An atom followed by "
"a bound containing two integers I<i> and I<j> matches a sequence of I<i> "
"through I<j> (inclusive) matches of the atom."
msgstr ""

#. type: Plain text
#: build/C/man7/regex.7:106
msgid ""
"An atom is a regular expression enclosed in \"I<()>\" (matching a match for "
"the regular expression), an empty set of \"I<()>\" (matching the null "
"string)\\*(dg, a I<bracket expression> (see below), \\(aq.\\(aq (matching "
"any single character), \\(aq\\(ha\\(aq (matching the null string at the "
"beginning of a line), \\(aq$\\(aq (matching the null string at the end of a "
"line), a \\(aq\\e\\(aq followed by one of the characters "
"\"I<\\(ha.[$()|*+?{\\e>\" (matching that character taken as an ordinary "
"character), a \\(aq\\e\\(aq followed by any other character\\*(dg (matching "
"that character taken as an ordinary character, as if the \\(aq\\e\\(aq had "
"not been present\\*(dg), or a single character with no other significance "
"(matching that character).  A \\(aq{\\(aq followed by a character other than "
"a digit is an ordinary character, not the beginning of a bound\\*(dg.  It is "
"illegal to end an RE with \\(aq\\e\\(aq."
msgstr ""

#. type: Plain text
#: build/C/man7/regex.7:120
msgid ""
"A I<bracket expression> is a list of characters enclosed in \"I<[]>\".  It "
"normally matches any single character from the list (but see below).  If the "
"list begins with \\(aq\\(ha\\(aq, it matches any single character (but see "
"below) I<not> from the rest of the list.  If two characters in the list are "
"separated by \\(aq-\\(aq, this is shorthand for the full I<range> of "
"characters between those two (inclusive) in the collating sequence, for "
"example, \"I<[0-9]>\" in ASCII matches any decimal digit.  It is "
"illegal\\*(dg for two ranges to share an endpoint, for example, "
"\"I<a-c-e>\".  Ranges are very collating-sequence-dependent, and portable "
"programs should avoid relying on them."
msgstr ""

#. type: Plain text
#: build/C/man7/regex.7:131
msgid ""
"To include a literal \\(aq]\\(aq in the list, make it the first character "
"(following a possible \\(aq\\(ha\\(aq).  To include a literal \\(aq-\\(aq, "
"make it the first or last character, or the second endpoint of a range.  To "
"use a literal \\(aq-\\(aq as the first endpoint of a range, enclose it in "
"\"I<[.>\" and \"I<.]>\" to make it a collating element (see below).  With "
"the exception of these and some combinations using \\(aq[\\(aq (see next "
"paragraphs), all other special characters, including \\(aq\\e\\(aq, lose "
"their special significance within a bracket expression."
msgstr ""

#. type: Plain text
#: build/C/man7/regex.7:143
msgid ""
"Within a bracket expression, a collating element (a character, a "
"multicharacter sequence that collates as if it were a single character, or a "
"collating-sequence name for either)  enclosed in \"I<[.>\" and \"I<.]>\" "
"stands for the sequence of characters of that collating element.  The "
"sequence is a single element of the bracket expression's list.  A bracket "
"expression containing a multicharacter collating element can thus match more "
"than one character, for example, if the collating sequence includes a \"ch\" "
"collating element, then the RE \"I<[[.ch.]]*c>\" matches the first five "
"characters of \"chchcc\"."
msgstr ""

#. type: Plain text
#: build/C/man7/regex.7:155
msgid ""
"Within a bracket expression, a collating element enclosed in \"I<[=>\" and "
"\"I<=]>\" is an equivalence class, standing for the sequences of characters "
"of all collating elements equivalent to that one, including itself.  (If "
"there are no other equivalent collating elements, the treatment is as if the "
"enclosing delimiters were \"I<[.>\" and \"I<.]>\".)  For example, if o and "
"\\o'o\\(ha' are the members of an equivalence class, then \"I<[[=o=]]>\", "
"\"I<[[=\\o'o\\(ha'=]]>\", and \"I<[o\\o'o\\(ha']>\" are all synonymous.  An "
"equivalence class may not\\*(dg be an endpoint of a range."
msgstr ""

#. type: Plain text
#: build/C/man7/regex.7:161
msgid ""
"Within a bracket expression, the name of a I<character class> enclosed in "
"\"I<[:>\" and \"I<:]>\" stands for the list of all characters belonging to "
"that class.  Standard character class names are:"
msgstr ""

#. type: tbl table
#: build/C/man7/regex.7:165
#, no-wrap
msgid "alnum"
msgstr ""

#. type: tbl table
#: build/C/man7/regex.7:165
#, no-wrap
msgid "digit"
msgstr ""

#. type: tbl table
#: build/C/man7/regex.7:165
#, no-wrap
msgid "punct"
msgstr ""

#. type: tbl table
#: build/C/man7/regex.7:166
#, no-wrap
msgid "alpha"
msgstr ""

#. type: tbl table
#: build/C/man7/regex.7:166
#, no-wrap
msgid "graph"
msgstr ""

#. type: tbl table
#: build/C/man7/regex.7:166
#, no-wrap
msgid "space"
msgstr ""

#. type: tbl table
#: build/C/man7/regex.7:167
#, no-wrap
msgid "blank"
msgstr ""

#. type: tbl table
#: build/C/man7/regex.7:167
#, no-wrap
msgid "lower"
msgstr ""

#. type: tbl table
#: build/C/man7/regex.7:167
#, no-wrap
msgid "upper"
msgstr ""

#. type: tbl table
#: build/C/man7/regex.7:168
#, no-wrap
msgid "cntrl"
msgstr ""

#. type: tbl table
#: build/C/man7/regex.7:168
#, no-wrap
msgid "print"
msgstr ""

#. type: tbl table
#: build/C/man7/regex.7:168
#, no-wrap
msgid "xdigit"
msgstr ""

#.  As per http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=295666
#.  The following does not seem to apply in the glibc implementation
#.  .PP
#.  There are two special cases\*(dg of bracket expressions:
#.  the bracket expressions "\fI[[:<:]]\fP" and "\fI[[:>:]]\fP" match
#.  the null string at the beginning and end of a word respectively.
#.  A word is defined as a sequence of
#.  word characters
#.  which is neither preceded nor followed by
#.  word characters.
#.  A word character is an
#.  .I alnum
#.  character (as defined by
#.  .BR wctype (3))
#.  or an underscore.
#.  This is an extension,
#.  compatible with but not specified by POSIX.2,
#.  and should be used with
#.  caution in software intended to be portable to other systems.
#. type: Plain text
#: build/C/man7/regex.7:195
msgid ""
"These stand for the character classes defined in B<wctype>(3).  A locale may "
"provide others.  A character class may not be used as an endpoint of a "
"range."
msgstr ""

#. type: Plain text
#: build/C/man7/regex.7:207
msgid ""
"In the event that an RE could match more than one substring of a given "
"string, the RE matches the one starting earliest in the string.  If the RE "
"could match more than one substring starting at that point, it matches the "
"longest.  Subexpressions also match the longest possible substrings, subject "
"to the constraint that the whole match be as long as possible, with "
"subexpressions starting earlier in the RE taking priority over ones starting "
"later.  Note that higher-level subexpressions thus take priority over their "
"lower-level component subexpressions."
msgstr ""

#. type: Plain text
#: build/C/man7/regex.7:219
msgid ""
"Match lengths are measured in characters, not collating elements.  A null "
"string is considered longer than no match at all.  For example, \"I<bb*>\" "
"matches the three middle characters of \"abbbc\", "
"\"I<(wee|week)(knights|nights)>\" matches all ten characters of "
"\"weeknights\", when \"I<(.*).*>\" is matched against \"abc\" the "
"parenthesized subexpression matches all three characters, and when "
"\"I<(a*)*>\" is matched against \"bc\" both the whole RE and the "
"parenthesized subexpression match the null string."
msgstr ""

#. type: Plain text
#: build/C/man7/regex.7:230
msgid ""
"If case-independent matching is specified, the effect is much as if all case "
"distinctions had vanished from the alphabet.  When an alphabetic that exists "
"in multiple cases appears as an ordinary character outside a bracket "
"expression, it is effectively transformed into a bracket expression "
"containing both cases, for example, \\(aqx\\(aq becomes \"I<[xX]>\".  When "
"it appears inside a bracket expression, all case counterparts of it are "
"added to the bracket expression, so that, for example, \"I<[x]>\" becomes "
"\"I<[xX]>\" and \"I<[\\(hax]>\" becomes \"I<[\\(haxX]>\"."
msgstr ""

#. type: Plain text
#: build/C/man7/regex.7:236
msgid ""
"No particular limit is imposed on the length of REs\\*(dg.  Programs "
"intended to be portable should not employ REs longer than 256 bytes, as an "
"implementation can refuse to accept such REs and remain POSIX-compliant."
msgstr ""

#. type: Plain text
#: build/C/man7/regex.7:252
msgid ""
"Obsolete (\"basic\") regular expressions differ in several respects.  "
"\\(aq|\\(aq, \\(aq+\\(aq, and \\(aq?\\(aq are ordinary characters and there "
"is no equivalent for their functionality.  The delimiters for bounds are "
"\"I<\\e{>\" and \"I<\\e}>\", with \\(aq{\\(aq and \\(aq}\\(aq by themselves "
"ordinary characters.  The parentheses for nested subexpressions are "
"\"I<\\e(>\" and \"I<\\e)>\", with \\(aq(\\(aq and \\(aq)\\(aq by themselves "
"ordinary characters.  \\(aq\\(ha\\(aq is an ordinary character except at the "
"beginning of the RE or\\*(dg the beginning of a parenthesized subexpression, "
"\\(aq$\\(aq is an ordinary character except at the end of the RE or\\*(dg "
"the end of a parenthesized subexpression, and \\(aq*\\(aq is an ordinary "
"character if it appears at the beginning of the RE or the beginning of a "
"parenthesized subexpression (after a possible leading \\(aq\\(ha\\(aq)."
msgstr ""

#. type: Plain text
#: build/C/man7/regex.7:260
msgid ""
"Finally, there is one new type of atom, a I<back reference>: \\(aq\\e\\(aq "
"followed by a nonzero decimal digit I<d> matches the same sequence of "
"characters matched by the I<d>th parenthesized subexpression (numbering "
"subexpressions by the positions of their opening parentheses, left to "
"right), so that, for example, \"I<\\e([bc]\\e)\\e1>\" matches \"bb\" or "
"\"cc\" but not \"bc\"."
msgstr ""

#. type: Plain text
#: build/C/man7/regex.7:262
msgid "Having two kinds of REs is a botch."
msgstr ""

#. type: Plain text
#: build/C/man7/regex.7:268
msgid ""
"The current POSIX.2 spec says that \\(aq)\\(aq is an ordinary character in "
"the absence of an unmatched \\(aq(\\(aq; this was an unintentional result of "
"a wording error, and change is likely.  Avoid relying on it."
msgstr ""

#. type: Plain text
#: build/C/man7/regex.7:275
msgid ""
"Back references are a dreadful botch, posing major problems for efficient "
"implementations.  They are also somewhat vaguely defined (does "
"\"I<a\\e(\\e(b\\e)*\\e2\\e)*d>\" match \"abbbd\"?).  Avoid using them."
msgstr ""

#.  As per http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=295666
#.  The following does not seem to apply in the glibc implementation
#.  .PP
#.  The syntax for word boundaries is incredibly ugly.
#. type: Plain text
#: build/C/man7/regex.7:283
msgid ""
"POSIX.2's specification of case-independent matching is vague.  The \"one "
"case implies all cases\" definition given above is current consensus among "
"implementors as to the right interpretation."
msgstr ""

#. type: SH
#: build/C/man7/regex.7:283
#, no-wrap
msgid "AUTHOR"
msgstr ""

#.  Sigh... The page license means we must have the author's name
#.  in the formatted output.
#. type: Plain text
#: build/C/man7/regex.7:287
msgid "This page was taken from Henry Spencer's regex package."
msgstr ""

#. type: Plain text
#: build/C/man7/regex.7:290
msgid "B<grep>(1), B<regex>(3)"
msgstr ""

#. type: Plain text
#: build/C/man7/regex.7:292
msgid "POSIX.2, section 2.8 (Regular Expression Notation)."
msgstr ""

#. type: TH
#: build/C/man3/wordexp.3:24
#, no-wrap
msgid "WORDEXP"
msgstr ""

#. type: TH
#: build/C/man3/wordexp.3:24
#, no-wrap
msgid "2020-11-01"
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:27
msgid "wordexp, wordfree - perform word expansion like a posix-shell"
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:29
msgid "B<#include E<lt>wordexp.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:31
msgid "B<int wordexp(const char *>I<s>B<, wordexp_t *>I<p>B<, int >I<flags>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:33
msgid "B<void wordfree(wordexp_t *>I<p>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:37
msgid "Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:42
msgid "B<wordexp>(), B<wordfree>(): _XOPEN_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:76
msgid ""
"The function B<wordexp>()  performs a shell-like expansion of the string "
"I<s> and returns the result in the structure pointed to by I<p>.  The data "
"type I<wordexp_t> is a structure that at least has the fields I<we_wordc>, "
"I<we_wordv>, and I<we_offs>.  The field I<we_wordc> is a I<size_t> that "
"gives the number of words in the expansion of I<s>.  The field I<we_wordv> "
"is a I<char\\ **> that points to the array of words found.  The field "
"I<we_offs> of type I<size_t> is sometimes (depending on I<flags>, see below) "
"used to indicate the number of initial elements in the I<we_wordv> array "
"that should be filled with NULLs."
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:84
msgid ""
"The function B<wordfree>()  frees the allocated memory again.  More "
"precisely, it does not free its argument, but it frees the array I<we_wordv> "
"and the strings that points to."
msgstr ""

#. type: SS
#: build/C/man3/wordexp.3:84
#, no-wrap
msgid "The string argument"
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:94
msgid ""
"Since the expansion is the same as the expansion by the shell (see B<sh>(1))  "
"of the parameters to a command, the string I<s> must not contain characters "
"that would be illegal in shell command parameters.  In particular, there "
"must not be any unescaped newline or |, &, ;, E<lt>, E<gt>, (, ), {, } "
"characters outside a command substitution or parameter substitution context."
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:100
msgid ""
"If the argument I<s> contains a word that starts with an unquoted comment "
"character #, then it is unspecified whether that word and all following "
"words are ignored, or the # is treated as a non-comment character."
msgstr ""

#. type: SS
#: build/C/man3/wordexp.3:100
#, no-wrap
msgid "The expansion"
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:107
msgid ""
"The expansion done consists of the following stages: tilde expansion "
"(replacing \\(tiuser by user's home directory), variable substitution "
"(replacing $FOO by the value of the environment variable FOO), command "
"substitution (replacing $(command) or \\`command\\` by the output of "
"command), arithmetic expansion, field splitting, wildcard expansion, quote "
"removal."
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:110
msgid ""
"The result of expansion of special parameters ($@, $*, $#, $?, $-, $$, $!, "
"$0) is unspecified."
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:113
msgid ""
"Field splitting is done using the environment variable $IFS.  If it is not "
"set, the field separators are space, tab and newline."
msgstr ""

#. type: SS
#: build/C/man3/wordexp.3:113
#, no-wrap
msgid "The output array"
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:117
msgid "The array I<we_wordv> contains the words found, followed by a NULL."
msgstr ""

#. type: SS
#: build/C/man3/wordexp.3:117
#, no-wrap
msgid "The flags argument"
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:121
msgid "The I<flag> argument is a bitwise inclusive OR of the following values:"
msgstr ""

#. type: TP
#: build/C/man3/wordexp.3:121
#, no-wrap
msgid "B<WRDE_APPEND>"
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:124
msgid "Append the words found to the array resulting from a previous call."
msgstr ""

#. type: TP
#: build/C/man3/wordexp.3:124
#, no-wrap
msgid "B<WRDE_DOOFFS>"
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:132
msgid ""
"Insert I<we_offs> initial NULLs in the array I<we_wordv>.  (These are not "
"counted in the returned I<we_wordc>.)"
msgstr ""

#. type: TP
#: build/C/man3/wordexp.3:132
#, no-wrap
msgid "B<WRDE_NOCMD>"
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:135
msgid "Don't do command substitution."
msgstr ""

#. type: TP
#: build/C/man3/wordexp.3:135
#, no-wrap
msgid "B<WRDE_REUSE>"
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:145
msgid ""
"The argument I<p> resulted from a previous call to B<wordexp>(), and "
"B<wordfree>()  was not called.  Reuse the allocated storage."
msgstr ""

#. type: TP
#: build/C/man3/wordexp.3:145
#, no-wrap
msgid "B<WRDE_SHOWERR>"
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:154
msgid ""
"Normally during command substitution I<stderr> is redirected to "
"I</dev/null>.  This flag specifies that I<stderr> is not to be redirected."
msgstr ""

#. type: TP
#: build/C/man3/wordexp.3:154
#, no-wrap
msgid "B<WRDE_UNDEF>"
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:157
msgid "Consider it an error if an undefined shell variable is expanded."
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:161
msgid ""
"In case of success 0 is returned.  In case of error one of the following "
"five values is returned."
msgstr ""

#. type: TP
#: build/C/man3/wordexp.3:161
#, no-wrap
msgid "B<WRDE_BADCHAR>"
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:164
msgid "Illegal occurrence of newline or one of |, &, ;, E<lt>, E<gt>, (, ), {, }."
msgstr ""

#. type: TP
#: build/C/man3/wordexp.3:164
#, no-wrap
msgid "B<WRDE_BADVAL>"
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:170
msgid ""
"An undefined shell variable was referenced, and the B<WRDE_UNDEF> flag told "
"us to consider this an error."
msgstr ""

#. type: TP
#: build/C/man3/wordexp.3:170
#, no-wrap
msgid "B<WRDE_CMDSUB>"
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:175
msgid ""
"Command substitution requested, but the B<WRDE_NOCMD> flag told us to "
"consider this an error."
msgstr ""

#. type: TP
#: build/C/man3/wordexp.3:175
#, no-wrap
msgid "B<WRDE_NOSPACE>"
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:178
msgid "Out of memory."
msgstr ""

#. type: TP
#: build/C/man3/wordexp.3:178
#, no-wrap
msgid "B<WRDE_SYNTAX>"
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:182
msgid "Shell syntax error, such as unbalanced parentheses or unmatched quotes."
msgstr ""

#. type: SH
#: build/C/man3/wordexp.3:182
#, no-wrap
msgid "VERSIONS"
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:187
msgid "B<wordexp>()  and B<wordfree>()  are provided in glibc since version 2.1."
msgstr ""

#. type: tbl table
#: build/C/man3/wordexp.3:197
#, no-wrap
msgid "B<wordexp>()"
msgstr ""

#. type: tbl table
#: build/C/man3/wordexp.3:199
#, no-wrap
msgid "MT-Unsafe race:utent const:env\n"
msgstr ""

#. type: tbl table
#: build/C/man3/wordexp.3:201
#, no-wrap
msgid "env sig:ALRM timer locale"
msgstr ""

#. type: tbl table
#: build/C/man3/wordexp.3:204
#, no-wrap
msgid "B<wordfree>()"
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:221
msgid ""
"In the above table, I<utent> in I<race:utent> signifies that if any of the "
"functions B<setutent>(3), B<getutent>(3), or B<endutent>(3)  are used in "
"parallel in different threads of a program, then data races could occur.  "
"B<wordexp>()  calls those functions, so we use race:utent to remind users."
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:226
msgid ""
"The output of the following example program is approximately that of \"ls "
"[a-c]*.c\"."
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:231
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>wordexp.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:237
#, no-wrap
msgid ""
"int\n"
"main(int argc, char **argv)\n"
"{\n"
"    wordexp_t p;\n"
"    char **w;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:245
#, no-wrap
msgid ""
"    wordexp(\"[a-c]*.c\", &p, 0);\n"
"    w = p.we_wordv;\n"
"    for (int i = 0; i E<lt> p.we_wordc; i++)\n"
"        printf(\"%s\\en\", w[i]);\n"
"    wordfree(&p);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:249
msgid "B<fnmatch>(3), B<glob>(3)"
msgstr ""
