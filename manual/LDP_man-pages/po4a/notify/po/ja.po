# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-03-12 14:01+0900\n"
"PO-Revision-Date: 2021-07-19 09:02+0900\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man7/fanotify.7:25
#, no-wrap
msgid "FANOTIFY"
msgstr "FANOTIFY"

#. type: TH
#: build/C/man7/fanotify.7:25 build/C/man2/fanotify_init.2:24
#: build/C/man2/fanotify_mark.2:24 build/C/man7/inotify.7:26
#, no-wrap
msgid "2020-11-01"
msgstr ""

#. type: TH
#: build/C/man7/fanotify.7:25 build/C/man2/fanotify_init.2:24
#: build/C/man2/fanotify_mark.2:24 build/C/man7/inotify.7:26
#: build/C/man2/inotify_add_watch.2:28 build/C/man2/inotify_init.2:29
#: build/C/man2/inotify_rm_watch.2:27
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#: build/C/man7/fanotify.7:25 build/C/man2/fanotify_init.2:24
#: build/C/man2/fanotify_mark.2:24 build/C/man7/inotify.7:26
#: build/C/man2/inotify_add_watch.2:28 build/C/man2/inotify_init.2:29
#: build/C/man2/inotify_rm_watch.2:27
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux Programmer's Manual"

#. type: SH
#: build/C/man7/fanotify.7:26 build/C/man2/fanotify_init.2:25
#: build/C/man2/fanotify_mark.2:25 build/C/man7/inotify.7:27
#: build/C/man2/inotify_add_watch.2:29 build/C/man2/inotify_init.2:30
#: build/C/man2/inotify_rm_watch.2:28
#, no-wrap
msgid "NAME"
msgstr "名前"

#. type: Plain text
#: build/C/man7/fanotify.7:28
msgid "fanotify - monitoring filesystem events"
msgstr "fanotify - ファイルシステムイベントを監視する"

#. type: SH
#: build/C/man7/fanotify.7:28 build/C/man2/fanotify_init.2:33
#: build/C/man2/fanotify_mark.2:36 build/C/man7/inotify.7:29
#: build/C/man2/inotify_add_watch.2:35 build/C/man2/inotify_init.2:39
#: build/C/man2/inotify_rm_watch.2:36
#, no-wrap
msgid "DESCRIPTION"
msgstr "説明"

#. type: Plain text
#: build/C/man7/fanotify.7:38
#, fuzzy
#| msgid ""
#| "The fanotify API provides notification and interception of filesystem "
#| "events.  Use cases include virus scanning and hierarchical storage "
#| "management.  Currently, only a limited set of events is supported.  In "
#| "particular, there is no support for create, delete, and move events.  "
#| "(See B<inotify>(7)  for details of an API that does notify those events.)"
msgid ""
"The fanotify API provides notification and interception of filesystem "
"events.  Use cases include virus scanning and hierarchical storage "
"management.  In the original fanotify API, only a limited set of events was "
"supported.  In particular, there was no support for create, delete, and move "
"events.  The support for those events was added in Linux 5.1.  (See "
"B<inotify>(7)  for details of an API that did notify those events pre Linux "
"5.1.)"
msgstr ""
"fanotify API はファイルシステムイベントの通知と横取り機能 (interception) を提"
"供する。 ユースケースとしては、ウイルススキャンや階層型ストレージの管理などが"
"ある。 現在のところ、限定的なイベントのみがサポートされている。 特に、作成 "
"(create)、削除 (delete)、移動 (move) イベントがサポートされていない (これらの"
"イベントを通知する API の詳細については B<inotify>(7) を参照)。"

#. type: Plain text
#: build/C/man7/fanotify.7:45
msgid ""
"Additional capabilities compared to the B<inotify>(7)  API include the "
"ability to monitor all of the objects in a mounted filesystem, the ability "
"to make access permission decisions, and the possibility to read or modify "
"files before access by other applications."
msgstr ""
"B<inotify>(7) API と比較して追加されている機能としては、 マウントされたファイ"
"ルシステムの全オブジェクトを監視する機能、 アクセス許可の判定を行う機能、 他"
"のアプリケーションによるアクセスの前にファイルを読み出したり変更したりする機"
"能がある。"

#. type: Plain text
#: build/C/man7/fanotify.7:53
msgid ""
"The following system calls are used with this API: B<fanotify_init>(2), "
"B<fanotify_mark>(2), B<read>(2), B<write>(2), and B<close>(2)."
msgstr ""
"この API では以下のシステムコールを使用する: B<fanotify_init>(2), "
"B<fanotify_mark>(2), B<read>(2), B<write>(2), B<close>(2)。"

#. type: SS
#: build/C/man7/fanotify.7:53
#, no-wrap
msgid "fanotify_init(), fanotify_mark(), and notification groups"
msgstr "fanotify_init(), fanotify_mark() と通知グループ"

#. type: Plain text
#: build/C/man7/fanotify.7:58
msgid ""
"The B<fanotify_init>(2)  system call creates and initializes an fanotify "
"notification group and returns a file descriptor referring to it."
msgstr ""
"B<fanotify_init>(2) システムコールは fanotify 通知グループを作成、初期化し、 "
"この通知グループを参照するファイルディスクリプターを返す。"

#. type: Plain text
#: build/C/man7/fanotify.7:62
msgid ""
"An fanotify notification group is a kernel-internal object that holds a list "
"of files, directories, filesystems, and mount points for which events shall "
"be created."
msgstr "fanotify 通知グループはカーネル内部のオブジェクトで、 イベントが作成されるファイル、ディレクトリ、ファイルシステム、マウントポイントのリストを保持する。"

#. type: Plain text
#: build/C/man7/fanotify.7:73
msgid ""
"For each entry in an fanotify notification group, two bit masks exist: the "
"I<mark> mask and the I<ignore> mask.  The mark mask defines file activities "
"for which an event shall be created.  The ignore mask defines activities for "
"which no event shall be generated.  Having these two types of masks permits "
"a filesystem, mount point, or directory to be marked for receiving events, "
"while at the same time ignoring events for specific objects under a mount "
"point or directory."
msgstr "fanotify 通知グループの各エントリーには 2 つのビットマスクがある。 I<mark> マスクと I<ignore> マスクである。 mark マスクはどのファイル操作についてイベントを作成するかを定義する。 ignore マスクはどの操作についてイベントを作成しないかを定義する。 これらの 2 種類のマスクがあることで、 ファイルシステム、マウントポイント、ディレクトリに対してイベントの受信を mark しておきつつ、 同時にそのマウントポイントやディレクトリ配下の特定のオブジェクトに対するイベントを無視する、 といったことができる。"

#. type: Plain text
#: build/C/man7/fanotify.7:79
msgid ""
"The B<fanotify_mark>(2)  system call adds a file, directory, filesystem or "
"mount point to a notification group and specifies which events shall be "
"reported (or ignored), or removes or modifies such an entry."
msgstr "B<fanotify_mark>(2) システムコールは、ファイル、ディレクトリ、ファイルシステム、マウントポイントを通知グループに追加し、 どのイベントを報告 (もしくは無視) するかを指定する。 また、このようなエントリーの削除、変更も行う。"

#. type: Plain text
#: build/C/man7/fanotify.7:92
msgid ""
"A possible usage of the ignore mask is for a file cache.  Events of interest "
"for a file cache are modification of a file and closing of the same.  Hence, "
"the cached directory or mount point is to be marked to receive these "
"events.  After receiving the first event informing that a file has been "
"modified, the corresponding cache entry will be invalidated.  No further "
"modification events for this file are of interest until the file is closed.  "
"Hence, the modify event can be added to the ignore mask.  Upon receiving the "
"close event, the modify event can be removed from the ignore mask and the "
"file cache entry can be updated."
msgstr ""
"ignore マスクの考えられる使用方法はファイルキャッシュに対してである。 ファイ"
"ルキャッシュに関して興味のあるイベントは、ファイルの変更とファイルのクローズ"
"である。 それゆえ、 キャッシュされたディレクトリやマウントポイントは、 これら"
"のイベントを受信するようにマークされる。 ファイルが変更されたという最初のイベ"
"ントを受信した後は、 対応するキャッシュエントリーは無効化される。 そのファイ"
"ルがクローズされるまでは、 このファイルに対する変更イベントは興味のない情報と"
"なる。 したがって、 変更イベントを ignore マスクに追加することができる。 ク"
"ローズイベントを受信すると、 変更イベントを ignore イベントから削除し、 ファ"
"イルキャッシュエントリーを更新することができる。"

#. type: Plain text
#: build/C/man7/fanotify.7:99
#, fuzzy
#| msgid ""
#| "The entries in the fanotify notification groups refer to files and "
#| "directories via their inode number and to mounts via their mount ID.  If "
#| "files or directories are renamed or moved, the respective entries "
#| "survive.  If files or directories are deleted or mounts are unmounted, "
#| "the corresponding entries are deleted."
msgid ""
"The entries in the fanotify notification groups refer to files and "
"directories via their inode number and to mounts via their mount ID.  If "
"files or directories are renamed or moved within the same mount, the "
"respective entries survive.  If files or directories are deleted or moved to "
"another mount or if filesystems or mounts are unmounted, the corresponding "
"entries are deleted."
msgstr ""
"fanotify 通知グループのエントリーは、 ファイルやディレクトリでは inode 番号経"
"由で参照され、 マウントではマウント ID 経由で参照される。 ファイルやディレク"
"トリの名前が変更されたり、移動されたりした場合も、 関連するエントリーはそのま"
"ま残る。 ファイルやディレクトリが削除されたり、マウントがアンマウントされたり"
"した場合には、 対応するエントリーは削除される。"

#. type: SS
#: build/C/man7/fanotify.7:99
#, no-wrap
msgid "The event queue"
msgstr "イベントキュー"

#. type: Plain text
#: build/C/man7/fanotify.7:108
msgid ""
"As events occur on the filesystem objects monitored by a notification group, "
"the fanotify system generates events that are collected in a queue.  These "
"events can then be read (using B<read>(2)  or similar)  from the fanotify "
"file descriptor returned by B<fanotify_init>(2)."
msgstr ""
"通知グループにより監視されているファイルシステムオブジェクトでイベントが発生"
"すると、 fanotify システムはイベントを生成し、 そのイベントはキューにまとめら"
"れる。 これらのイベントは、 B<fanotify_init>(2) が返した fanotify ファイル"
"ディスクリプターから (B<read>(2) などを使って) 読み出すことができる。"

#. type: Plain text
#: build/C/man7/fanotify.7:121
#, fuzzy
#| msgid ""
#| "Two types of events are generated: I<notification> events and "
#| "I<permission> events.  Notification events are merely informative and "
#| "require no action to be taken by the receiving application except for "
#| "closing the file descriptor passed in the event (see below).  Permission "
#| "events are requests to the receiving application to decide whether "
#| "permission for a file access shall be granted.  For these events, the "
#| "recipient must write a response which decides whether access is granted "
#| "or not."
msgid ""
"Two types of events are generated: I<notification> events and I<permission> "
"events.  Notification events are merely informative and require no action to "
"be taken by the receiving application with one exception: if a valid file "
"descriptor is provided within a generic event, the file descriptor must be "
"closed.  Permission events are requests to the receiving application to "
"decide whether permission for a file access shall be granted.  For these "
"events, the recipient must write a response which decides whether access is "
"granted or not."
msgstr ""
"2 種類のイベントが生成される。 I<notification> (通知) イベントと "
"I<permission> (アクセス許可) イベントである。 通知イベントは単なる情報通知で"
"あり、 イベントで渡されたファイルディスクリプターをクローズする場合 (下記参"
"照) を除き、 受信したアプリケーションでアクションを取る必要はない。 アクセス"
"許可イベントは、 受信したアプリケーションがファイルアクセスの許可を承認するか"
"を判定する必要がある。 この場合、 受信者はアクセスが許可されたか否かを決定す"
"る応答を書き込まなければならない。"

#. type: Plain text
#: build/C/man7/fanotify.7:128
msgid ""
"An event is removed from the event queue of the fanotify group when it has "
"been read.  Permission events that have been read are kept in an internal "
"list of the fanotify group until either a permission decision has been taken "
"by writing to the fanotify file descriptor or the fanotify file descriptor "
"is closed."
msgstr ""
"イベントは、 読み出されると、 fanotify グループのイベントキューから削除され"
"る。 読み出されたアクセス許可イベントは、 fanotify ファイルディスクリプターに"
"アクセス許可の判定が書き込まれるか、 fanotify ファイルディスクリプターがク"
"ローズされるまで、 fanotify グループの内部のリストに保持される。"

#. type: SS
#: build/C/man7/fanotify.7:128
#, no-wrap
msgid "Reading fanotify events"
msgstr "fanotify イベントの読み出し"

#. type: Plain text
#: build/C/man7/fanotify.7:140
msgid ""
"Calling B<read>(2)  for the file descriptor returned by B<fanotify_init>(2)  "
"blocks (if the flag B<FAN_NONBLOCK> is not specified in the call to "
"B<fanotify_init>(2))  until either a file event occurs or the call is "
"interrupted by a signal (see B<signal>(7))."
msgstr ""
"B<fanotify_init>(2) が返したファイルディスクリプターに対する B<read>(2) を呼"
"び出しは、 (B<fanotify_init>(2) の呼び出しでフラグ B<FAN_NONBLOCK> を指定しな"
"かった場合) ファイルイベントが起こるか、呼び出しがシグナルによって割り込まれ"
"る (B<signal>(7) 参照) まで停止する。"

#. type: Plain text
#: build/C/man7/fanotify.7:150
msgid ""
"The use of one of the flags B<FAN_REPORT_FID>, B<FAN_REPORT_DIR_FID> in "
"B<fanotify_init>(2)  influences what data structures are returned to the "
"event listener for each event.  Events reported to a group initialized with "
"one of these flags will use file handles to identify filesystem objects "
"instead of file descriptors."
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:150
#, no-wrap
msgid "After a successful"
msgstr "B<read>(2) が成功すると、"

#. type: Plain text
#: build/C/man7/fanotify.7:154
msgid ""
"B<read>(2), the read buffer contains one or more of the following structures:"
msgstr "読み出しバッファーには以下の構造体が 1 つ以上格納される。"

#. type: Plain text
#: build/C/man7/fanotify.7:166
#, no-wrap
msgid ""
"struct fanotify_event_metadata {\n"
"    __u32 event_len;\n"
"    __u8 vers;\n"
"    __u8 reserved;\n"
"    __u16 metadata_len;\n"
"    __aligned_u64 mask;\n"
"    __s32 fd;\n"
"    __s32 pid;\n"
"};\n"
msgstr ""
"struct fanotify_event_metadata {\n"
"    __u32 event_len;\n"
"    __u8 vers;\n"
"    __u8 reserved;\n"
"    __u16 metadata_len;\n"
"    __aligned_u64 mask;\n"
"    __s32 fd;\n"
"    __s32 pid;\n"
"};\n"

#. type: Plain text
#: build/C/man7/fanotify.7:174
msgid ""
"In case of an fanotify group that identifies filesystem objects by file "
"handles, you should also expect to receive one or more additional "
"information records of the structure detailed below following the generic "
"I<fanotify_event_metadata> structure within the read buffer:"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:182
#, no-wrap
msgid ""
"struct fanotify_event_info_header {\n"
"    __u8 info_type;\n"
"    __u8 pad;\n"
"    __u16 len;\n"
"};\n"
msgstr ""
"struct fanotify_event_info_header {\n"
"    __u8 info_type;\n"
"    __u8 pad;\n"
"    __u16 len;\n"
"};\n"

#. type: Plain text
#: build/C/man7/fanotify.7:188
#, no-wrap
msgid ""
"struct fanotify_event_info_fid {\n"
"    struct fanotify_event_info_header hdr;\n"
"    __kernel_fsid_t fsid;\n"
"    unsigned char file_handle[0];\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:195
msgid ""
"For performance reasons, it is recommended to use a large buffer size (for "
"example, 4096 bytes), so that multiple events can be retrieved by a single "
"B<read>(2)."
msgstr ""
"性能上の理由から、複数のイベントを一度の B<read>(2) で取得できるように大きめ"
"のバッファーサイズ (例えば 4096 バイト) を使用することを推奨する。"

#. type: Plain text
#: build/C/man7/fanotify.7:200
msgid ""
"The return value of B<read>(2)  is the number of bytes placed in the buffer, "
"or -1 in case of an error (but see BUGS)."
msgstr ""
"B<read>(2) の返り値はバッファーに格納されたバイト数である。 エラーの場合は "
"-1 が返される (ただし、バグも参照)。"

#. type: Plain text
#: build/C/man7/fanotify.7:204
msgid "The fields of the I<fanotify_event_metadata> structure are as follows:"
msgstr "I<fanotify_event_metadata> 構造体のフィールドは以下のとおりである。"

#. type: TP
#: build/C/man7/fanotify.7:204
#, no-wrap
msgid "I<event_len>"
msgstr "I<event_len>"

#. type: Plain text
#: build/C/man7/fanotify.7:215
#, fuzzy
#| msgid ""
#| "This is the length of the data for the current event and the offset to "
#| "the next event in the buffer.  In the current implementation, the value "
#| "of I<event_len> is always B<FAN_EVENT_METADATA_LEN>.  However, the API is "
#| "designed to allow variable-length structures to be returned in the future."
msgid ""
"This is the length of the data for the current event and the offset to the "
"next event in the buffer.  Unless the group identifies filesystem objects by "
"file handles, the value of I<event_len> is always "
"B<FAN_EVENT_METADATA_LEN>.  For a group that identifies filesystem objects "
"by file handles, I<event_len> also includes the variable length file "
"identifier records."
msgstr ""
"これは、 このイベントのデータ長であり、バッファー内の次のイベントへのオフセッ"
"トである。 現在の実装では、 I<event_len> の値は常に "
"B<FAN_EVENT_METADATA_LEN> である。 しかしながら、 API は将来可変長の構造体を"
"返すことができるように設計されている。"

#. type: TP
#: build/C/man7/fanotify.7:215
#, no-wrap
msgid "I<vers>"
msgstr "I<vers>"

#. type: Plain text
#: build/C/man7/fanotify.7:224
msgid ""
"This field holds a version number for the structure.  It must be compared to "
"B<FANOTIFY_METADATA_VERSION> to verify that the structures returned at run "
"time match the structures defined at compile time.  In case of a mismatch, "
"the application should abandon trying to use the fanotify file descriptor."
msgstr ""
"このフィールドには構造体のバージョン番号が入る。 実行時に返された構造体がコン"
"パイル時の構造体と一致しているかを検査するには、 この値を "
"B<FANOTIFY_METADATA_VERSION> を比較すること。 一致しない場合、 アプリケーショ"
"ンはその fanotify ファイルディスクリプターを使用するのを諦めるべきである。"

#. type: TP
#: build/C/man7/fanotify.7:224
#, no-wrap
msgid "I<reserved>"
msgstr "I<reserved>"

#. type: Plain text
#: build/C/man7/fanotify.7:227
msgid "This field is not used."
msgstr "このフィールドは使用されない。"

#. type: TP
#: build/C/man7/fanotify.7:227
#, no-wrap
msgid "I<metadata_len>"
msgstr "I<metadata_len>"

#. type: Plain text
#: build/C/man7/fanotify.7:233
msgid ""
"This is the length of the structure.  The field was introduced to facilitate "
"the implementation of optional headers per event type.  No such optional "
"headers exist in the current implementation."
msgstr ""
"この構造体の長さである。 このフィールドは、 イベント種別単位のオプションヘッ"
"ダーの実装を扱うために導入された。 現在の実装ではこのようなオプションヘッダー"
"は存在しない。"

#. type: TP
#: build/C/man7/fanotify.7:233
#, no-wrap
msgid "I<mask>"
msgstr "I<mask>"

#. type: Plain text
#: build/C/man7/fanotify.7:236
msgid "This is a bit mask describing the event (see below)."
msgstr "イベントを示すビットマスクである (下記参照)"

#. type: TP
#: build/C/man7/fanotify.7:236 build/C/man7/fanotify.7:576
#, no-wrap
msgid "I<fd>"
msgstr "I<fd>"

#. type: Plain text
#: build/C/man7/fanotify.7:248
#, fuzzy
#| msgid ""
#| "This is an open file descriptor for the object being accessed, or "
#| "B<FAN_NOFD> if a queue overflow occurred.  The file descriptor can be "
#| "used to access the contents of the monitored file or directory.  The "
#| "reading application is responsible for closing this file descriptor."
msgid ""
"This is an open file descriptor for the object being accessed, or "
"B<FAN_NOFD> if a queue overflow occurred.  With an fanotify group that "
"identifies filesystem objects by file handles, applications should expect "
"this value to be set to B<FAN_NOFD> for each event that is received.  The "
"file descriptor can be used to access the contents of the monitored file or "
"directory.  The reading application is responsible for closing this file "
"descriptor."
msgstr ""
"これはアクセスされたオブジェクトに対するオープンされたファイルディスクリプ"
"ターである。 または、キューのオーバーフローが発生した場合には B<FAN_NOFD> が"
"入る。 ファイルディスクリプターは監視対象のファイルやディレクトリの内容にアク"
"セスするのに使用できる。 読み出したアプリケーションは責任を持ってこのファイル"
"ディスクリプターをクローズしなければならない。"

#. type: Plain text
#: build/C/man7/fanotify.7:261
msgid ""
"When calling B<fanotify_init>(2), the caller may specify (via the "
"I<event_f_flags> argument) various file status flags that are to be set on "
"the open file description that corresponds to this file descriptor.  In "
"addition, the (kernel-internal)  B<FMODE_NONOTIFY> file status flag is set "
"on the open file description.  This flag suppresses fanotify event "
"generation.  Hence, when the receiver of the fanotify event accesses the "
"notified file or directory using this file descriptor, no additional events "
"will be created."
msgstr ""
"B<fanotify_init>(2) を呼び出す際、 呼び出し元はこのファイルディスクリプターに"
"対応するオープンファイル記述にセットされた様々なファイル状態フラグを "
"(I<event_f_flags> 引数を使って) 指定することができる。 さらに、 (カーネル内"
"部の) B<FMODE_NONOTIFY> ファイル状態フラグがオープンファイル記述にセットされ"
"る。 このフラグは fanotify イベントの生成を抑制する。 したがって、 fanotify "
"イベントの受信者がこのファイルディスクリプターを使って通知されたファイルや"
"ディレクトリにアクセスした際に、 これ以上イベントが作成されなくなる。"

#. type: TP
#: build/C/man7/fanotify.7:261
#, no-wrap
msgid "I<pid>"
msgstr "I<pid>"

#. type: Plain text
#: build/C/man7/fanotify.7:269
msgid ""
"If flag B<FAN_REPORT_TID> was set in B<fanotify_init>(2), this is the TID of "
"the thread that caused the event.  Otherwise, this the PID of the process "
"that caused the event."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:275
msgid ""
"A program listening to fanotify events can compare this PID to the PID "
"returned by B<getpid>(2), to determine whether the event is caused by the "
"listener itself, or is due to a file access by another process."
msgstr "fanotify イベントを監視しているプログラムは、 この PID を B<getpid>(2) が返す PID と比較することで、 イベントが監視しているプログラム自身から発生したかどうか、 別のプロセスによるファイルアクセスにより発生したか、を判定できる。"

#. type: Plain text
#: build/C/man7/fanotify.7:285
msgid ""
"The bit mask in I<mask> indicates which events have occurred for a single "
"filesystem object.  Multiple bits may be set in this mask, if more than one "
"event occurred for the monitored filesystem object.  In particular, "
"consecutive events for the same filesystem object and originating from the "
"same process may be merged into a single event, with the exception that two "
"permission events are never merged into one queue entry."
msgstr ""
"I<mask> のビットマスクは、1 つのファイルシステムオブジェクトに対してどのイベ"
"ントが発生したかを示す。 監視対象のファイルシステムオブジェクトに複数のイベン"
"トが発生した場合は、 このマスクに複数のビットがセットされることがある。 特"
"に、 同じファイルシステムオブジェクトに対する連続するイベントが同じプロセスか"
"ら生成された場合には、 一つのイベントにまとめられることがある。 例外として、 "
"2 つのアクセス許可イベントが一つのキューエントリーにまとめられることは決して"
"ない。"

#. type: Plain text
#: build/C/man7/fanotify.7:289
msgid "The bits that may appear in I<mask> are as follows:"
msgstr "I<mask> でセットされている可能性のあるビットは以下のとおりである。"

#. type: TP
#: build/C/man7/fanotify.7:289 build/C/man2/fanotify_mark.2:170
#, no-wrap
msgid "B<FAN_ACCESS>"
msgstr "B<FAN_ACCESS>"

#. type: Plain text
#: build/C/man7/fanotify.7:292
msgid "A file or a directory (but see BUGS) was accessed (read)."
msgstr ""
"ファイルやディレクトリがアクセスされた (読み出しが行われた) (ただし、「バグ」"
"の節も参照)。"

#. type: TP
#: build/C/man7/fanotify.7:292 build/C/man2/fanotify_mark.2:182
#, no-wrap
msgid "B<FAN_OPEN>"
msgstr "B<FAN_OPEN>"

#. type: Plain text
#: build/C/man7/fanotify.7:295
msgid "A file or a directory was opened."
msgstr "ファイルやディレクトリがオープンされた。"

#. type: TP
#: build/C/man7/fanotify.7:295
#, no-wrap
msgid "B<FAN_OPEN_EXEC>"
msgstr "B<FAN_OPEN_EXEC>"

#. type: Plain text
#: build/C/man7/fanotify.7:301
msgid ""
"A file was opened with the intent to be executed.  See NOTES in "
"B<fanotify_mark>(2)  for additional details."
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:301
#, no-wrap
msgid "B<FAN_ATTRIB>"
msgstr "B<FAN_ATTRIB>"

#. type: Plain text
#: build/C/man7/fanotify.7:304
msgid "A file or directory metadata was changed."
msgstr "ファイルかディレクトリのメタデータが変更された。"

#. type: TP
#: build/C/man7/fanotify.7:304
#, no-wrap
msgid "B<FAN_CREATE>"
msgstr "B<FAN_CREATE>"

#. type: Plain text
#: build/C/man7/fanotify.7:307
#, fuzzy
#| msgid "A file or a directory was opened."
msgid "A child file or directory was created in a watched parent."
msgstr "ファイルやディレクトリがオープンされた。"

#. type: TP
#: build/C/man7/fanotify.7:307
#, no-wrap
msgid "B<FAN_DELETE>"
msgstr "B<FAN_DELETE>"

#. type: Plain text
#: build/C/man7/fanotify.7:310
#, fuzzy
#| msgid "File/directory deleted from watched directory."
msgid "A child file or directory was deleted in a watched parent."
msgstr "監視対象ディレクトリ内でファイルやディレクトリが削除された。"

#. type: TP
#: build/C/man7/fanotify.7:310
#, no-wrap
msgid "B<FAN_DELETE_SELF>"
msgstr "B<FAN_DELETE_SELF>"

#. type: Plain text
#: build/C/man7/fanotify.7:313
#, fuzzy
#| msgid "A file or a directory was opened."
msgid "A watched file or directory was deleted."
msgstr "ファイルやディレクトリがオープンされた。"

#. type: TP
#: build/C/man7/fanotify.7:313
#, no-wrap
msgid "B<FAN_MOVED_FROM>"
msgstr "B<FAN_MOVED_FROM>"

#. type: Plain text
#: build/C/man7/fanotify.7:316
#, fuzzy
#| msgid "File/directory deleted from watched directory."
msgid "A file or directory has been moved from a watched parent directory."
msgstr "監視対象ディレクトリ内でファイルやディレクトリが削除された。"

#. type: TP
#: build/C/man7/fanotify.7:316
#, no-wrap
msgid "B<FAN_MOVED_TO>"
msgstr "B<FAN_MOVED_TO>"

#. type: Plain text
#: build/C/man7/fanotify.7:319
#, fuzzy
#| msgid "File/directory deleted from watched directory."
msgid "A file or directory has been moved to a watched parent directory."
msgstr "監視対象ディレクトリ内でファイルやディレクトリが削除された。"

#. type: TP
#: build/C/man7/fanotify.7:319
#, no-wrap
msgid "B<FAN_MOVE_SELF>"
msgstr "B<FAN_MOVE_SELF>"

#. type: Plain text
#: build/C/man7/fanotify.7:322
msgid "A watched file or directory was moved."
msgstr "監視対象のディレクトリやファイルが移動された。"

#. type: TP
#: build/C/man7/fanotify.7:322 build/C/man2/fanotify_mark.2:173
#, no-wrap
msgid "B<FAN_MODIFY>"
msgstr "B<FAN_MODIFY>"

#. type: Plain text
#: build/C/man7/fanotify.7:325
msgid "A file was modified."
msgstr "ファイルが変更された。"

#. type: TP
#: build/C/man7/fanotify.7:325 build/C/man2/fanotify_mark.2:176
#, no-wrap
msgid "B<FAN_CLOSE_WRITE>"
msgstr "B<FAN_CLOSE_WRITE>"

#. type: Plain text
#: build/C/man7/fanotify.7:332
msgid ""
"A file that was opened for writing (B<O_WRONLY> or B<O_RDWR>)  was closed."
msgstr ""
"書き込み用 (B<O_WRONLY> か B<O_RDWR>) にオープンされたファイルがクローズされ"
"た。"

#. type: TP
#: build/C/man7/fanotify.7:332 build/C/man2/fanotify_mark.2:179
#, no-wrap
msgid "B<FAN_CLOSE_NOWRITE>"
msgstr "B<FAN_CLOSE_NOWRITE>"

#. type: Plain text
#: build/C/man7/fanotify.7:337
msgid ""
"A file or directory that was opened read-only (B<O_RDONLY>)  was closed."
msgstr "読み出し用 (B<O_RDONLY>) にオープンされたファイルがクローズされた。"

#. type: TP
#: build/C/man7/fanotify.7:337
#, no-wrap
msgid "B<FAN_Q_OVERFLOW>"
msgstr "B<FAN_Q_OVERFLOW>"

#. type: Plain text
#: build/C/man7/fanotify.7:344
msgid ""
"The event queue exceeded the limit of 16384 entries.  This limit can be "
"overridden by specifying the B<FAN_UNLIMITED_QUEUE> flag when calling "
"B<fanotify_init>(2)."
msgstr ""
"イベントキューが 16384 エントリーの上限を超過した。 この上限は "
"B<fanotify_init>(2) 呼び出し時に B<FAN_UNLIMITED_QUEUE> フラグを指定すること"
"で上書きできる。"

#. type: TP
#: build/C/man7/fanotify.7:344 build/C/man2/fanotify_mark.2:255
#, no-wrap
msgid "B<FAN_ACCESS_PERM>"
msgstr "B<FAN_ACCESS_PERM>"

#. type: Plain text
#: build/C/man7/fanotify.7:353
msgid ""
"An application wants to read a file or directory, for example using "
"B<read>(2)  or B<readdir>(2).  The reader must write a response (as "
"described below)  that determines whether the permission to access the "
"filesystem object shall be granted."
msgstr ""
"アプリケーションが例えば B<read>(2) や B<readdir>(2) などを使ってファイルや"
"ディレクトリを読み出そうとした。 このイベントを読み出したプログラムは、 その"
"ファイルシステムオブジェクトへのアクセス許可を承認するかを判定し (下記で説明"
"するとおり) 応答を書き込まなければならない。"

#. type: TP
#: build/C/man7/fanotify.7:353 build/C/man2/fanotify_mark.2:236
#, no-wrap
msgid "B<FAN_OPEN_PERM>"
msgstr "B<FAN_OPEN_PERM>"

#. type: Plain text
#: build/C/man7/fanotify.7:358
msgid ""
"An application wants to open a file or directory.  The reader must write a "
"response that determines whether the permission to open the filesystem "
"object shall be granted."
msgstr ""
"アプリケーションがファイルやディレクトリをオープンしようとした。 このイベント"
"を読み出したプログラムは、 そのファイルシステムオブジェクトのオープンを承認す"
"るかを判定し (下記で説明するとおり) 応答を書き込まなければならない。"

#. type: TP
#: build/C/man7/fanotify.7:358
#, no-wrap
msgid "B<FAN_OPEN_EXEC_PERM>"
msgstr "B<FAN_OPEN_EXEC_PERM>"

#. type: Plain text
#: build/C/man7/fanotify.7:366
#, fuzzy
#| msgid ""
#| "An application wants to open a file or directory.  The reader must write "
#| "a response that determines whether the permission to open the filesystem "
#| "object shall be granted."
msgid ""
"An application wants to open a file for execution.  The reader must write a "
"response that determines whether the permission to open the filesystem "
"object for execution shall be granted.  See NOTES in B<fanotify_mark>(2)  "
"for additional details."
msgstr ""
"アプリケーションがファイルやディレクトリをオープンしようとした。 このイベント"
"を読み出したプログラムは、 そのファイルシステムオブジェクトのオープンを承認す"
"るかを判定し (下記で説明するとおり) 応答を書き込まなければならない。"

#. type: Plain text
#: build/C/man7/fanotify.7:368
msgid "To check for any close event, the following bit mask may be used:"
msgstr "クローズイベントを確認するために以下のビットマスクを使うことができる。"

#. type: TP
#: build/C/man7/fanotify.7:368 build/C/man2/fanotify_mark.2:307
#, no-wrap
msgid "B<FAN_CLOSE>"
msgstr "B<FAN_CLOSE>"

#. type: Plain text
#: build/C/man7/fanotify.7:372
msgid "A file was closed.  This is a synonym for:"
msgstr "ファイルがクローズされた。 以下の同義語である。"

#. type: Plain text
#: build/C/man7/fanotify.7:374
#, no-wrap
msgid "    FAN_CLOSE_WRITE | FAN_CLOSE_NOWRITE\n"
msgstr "    FAN_CLOSE_WRITE | FAN_CLOSE_NOWRITE\n"

#. type: Plain text
#: build/C/man7/fanotify.7:376
msgid "To check for any move event, the following bit mask may be used:"
msgstr "移動イベントを確認するために以下のビットマスクを使うことができる。"

#. type: TP
#: build/C/man7/fanotify.7:376 build/C/man2/fanotify_mark.2:311
#, no-wrap
msgid "B<FAN_MOVE>"
msgstr "B<FAN_MOVE>"

#. type: Plain text
#: build/C/man7/fanotify.7:380
msgid "A file or directory was moved.  This is a synonym for:"
msgstr "ファイルやディレクトリが移動された。 以下の同義語である。"

#. type: Plain text
#: build/C/man7/fanotify.7:382
#, fuzzy, no-wrap
msgid "    FAN_MOVED_FROM | FAN_MOVED_TO\n"
msgstr "    FAN_MOVED_FROM | FAN_MOVED_TO\n"

#. type: Plain text
#: build/C/man7/fanotify.7:386
msgid ""
"The following bits may appear in I<mask> only in conjunction with other "
"event type bits:"
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:386 build/C/man2/fanotify_mark.2:263
#, no-wrap
msgid "B<FAN_ONDIR>"
msgstr "B<FAN_ONDIR>"

#. type: Plain text
#: build/C/man7/fanotify.7:399
msgid ""
"The events described in the I<mask> have occurred on a directory object.  "
"Reporting events on directories requires setting this flag in the mark "
"mask.  See B<fanotify_mark>(2)  for additional details.  The B<FAN_ONDIR> "
"flag is reported in an event mask only if the fanotify group identifies "
"filesystem objects by file handles."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:403
msgid "The fields of the I<fanotify_event_info_fid> structure are as follows:"
msgstr "I<fanotify_event_info_fid> 構造体のフィールドは以下のとおりである。"

#. type: TP
#: build/C/man7/fanotify.7:403
#, no-wrap
msgid "I<hdr>"
msgstr "I<hdr>"

#. type: Plain text
#: build/C/man7/fanotify.7:446
msgid ""
"This is a structure of type I<fanotify_event_info_header>.  It is a generic "
"header that contains information used to describe an additional information "
"record attached to the event.  For example, when an fanotify file descriptor "
"is created using B<FAN_REPORT_FID>, a single information record is expected "
"to be attached to the event with I<info_type> field value of "
"B<FAN_EVENT_INFO_TYPE_FID>.  When an fanotify file descriptor is created "
"using the combination of B<FAN_REPORT_FID> and B<FAN_REPORT_DIR_FID>, there "
"may be two information records attached to the event: one with I<info_type> "
"field value of B<FAN_EVENT_INFO_TYPE_DFID>, identifying a parent directory "
"object, and one with I<info_type> field value of B<FAN_EVENT_INFO_TYPE_FID>, "
"identifying a non-directory object.  The I<fanotify_event_info_header> "
"contains a I<len> field.  The value of I<len> is the size of the additional "
"information record including the I<fanotify_event_info_header> itself.  The "
"total size of all additional information records is not expected to be "
"bigger than ( I<event_len> - I<metadata_len> )."
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:446
#, no-wrap
msgid "I<fsid>"
msgstr "I<fsid>"

#. type: Plain text
#: build/C/man7/fanotify.7:456
msgid ""
"This is a unique identifier of the filesystem containing the object "
"associated with the event.  It is a structure of type I<__kernel_fsid_t> and "
"contains the same value as I<f_fsid> when calling B<statfs>(2)."
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:456
#, no-wrap
msgid "I<file_handle>"
msgstr "I<file_handle>"

#. type: Plain text
#: build/C/man7/fanotify.7:512
msgid ""
"This is a variable length structure of type struct file_handle.  It is an "
"opaque handle that corresponds to a specified object on a filesystem as "
"returned by B<name_to_handle_at>(2).  It can be used to uniquely identify a "
"file on a filesystem and can be passed as an argument to "
"B<open_by_handle_at>(2).  Note that for the directory entry modification "
"events B<FAN_CREATE>, B<FAN_DELETE>, and B<FAN_MOVE>, the I<file_handle> "
"identifies the modified directory and not the created/deleted/moved child "
"object.  If the value of I<info_type> field is "
"B<FAN_EVENT_INFO_TYPE_DFID_NAME>, the file handle is followed by a null "
"terminated string that identifies the created/deleted/moved directory entry "
"name.  For other events such as B<FAN_OPEN>, B<FAN_ATTRIB>, "
"B<FAN_DELETE_SELF>, and B<FAN_MOVE_SELF>, if the value of I<info_type> field "
"is B<FAN_EVENT_INFO_TYPE_FID>, the I<file_handle> identifies the object "
"correlated to the event.  If the value of I<info_type> field is "
"B<FAN_EVENT_INFO_TYPE_DFID>, the I<file_handle> identifies the directory "
"object correlated to the event or the parent directory of a non-directory "
"object correlated to the event.  If the value of I<info_type> field is "
"B<FAN_EVENT_INFO_TYPE_DFID_NAME>, the I<file_handle> identifies the same "
"directory object that would be reported with B<FAN_EVENT_INFO_TYPE_DFID> and "
"the file handle is followed by a null terminated string that identifies the "
"name of a directory entry in that directory, or '.' to identify the "
"directory object itself."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:517
msgid ""
"The following macros are provided to iterate over a buffer containing "
"fanotify event metadata returned by a B<read>(2)  from an fanotify file "
"descriptor:"
msgstr ""
"fanotify ファイルディスクリプターからの B<read>(2) が返した fanotify イベント"
"メタデータを含むバッファーに対して繰り返しを行うため、 以下のマクロが提供され"
"ている。"

#. type: TP
#: build/C/man7/fanotify.7:517
#, no-wrap
msgid "B<FAN_EVENT_OK(meta, len)>"
msgstr "B<FAN_EVENT_OK(meta, len)>"

#. type: Plain text
#: build/C/man7/fanotify.7:526
msgid ""
"This macro checks the remaining length I<len> of the buffer I<meta> against "
"the length of the metadata structure and the I<event_len> field of the first "
"metadata structure in the buffer."
msgstr ""
"このマクロは、 バッファー I<meta> の残りの長さ I<len> を、 メタデータ構造体の"
"長さとバッファーの最初のメタデータ構造体の I<event_len> フィールドと比較して"
"検査する。"

#. type: TP
#: build/C/man7/fanotify.7:526
#, no-wrap
msgid "B<FAN_EVENT_NEXT(meta, len)>"
msgstr "B<FAN_EVENT_NEXT(meta, len)>"

#. type: Plain text
#: build/C/man7/fanotify.7:545
#, fuzzy
#| msgid ""
#| "This macro uses the length indicated in the I<event_len> field of the "
#| "metadata structure pointed to by I<meta> to calculate the address of the "
#| "next metadata structure that follows I<meta>.  I<len> is the number of "
#| "bytes of metadata that currently remain in the buffer.  The macro returns "
#| "a pointer to the next metadata structure that follows I<meta>, and "
#| "reduces I<len> by the number of bytes in the the metadata structure that "
#| "has been skipped over (i.e., it subtracts I<meta-E<gt>event_len> from "
#| "I<len>)."
msgid ""
"This macro uses the length indicated in the I<event_len> field of the "
"metadata structure pointed to by I<meta> to calculate the address of the "
"next metadata structure that follows I<meta>.  I<len> is the number of bytes "
"of metadata that currently remain in the buffer.  The macro returns a "
"pointer to the next metadata structure that follows I<meta>, and reduces "
"I<len> by the number of bytes in the metadata structure that has been "
"skipped over (i.e., it subtracts I<meta-E<gt>event_len> from I<len>)."
msgstr ""
"このマクロは、 I<meta> が指すメタデータ構造体の I<event_len> フィールドで示さ"
"れた長さを使って、 I<meta> の次のメタデータ構造体のアドレスを計算する。 "
"I<len> はバッファーに現在残っているメタデータのバイト数である。 このマクロは "
"I<meta> の次のメタデータ構造体へのポインターを返し、 スキップされたメタデータ"
"構造体のバイト数だけ I<len> を減算する (つまり、 I<len> から I<meta-"
"E<gt>event_len> を引き算する)。"

#. type: Plain text
#: build/C/man7/fanotify.7:547
msgid "In addition, there is:"
msgstr "また、 以下のマクロも用意されている。"

#. type: TP
#: build/C/man7/fanotify.7:547
#, no-wrap
msgid "B<FAN_EVENT_METADATA_LEN>"
msgstr "B<FAN_EVENT_METADATA_LEN>"

#. type: Plain text
#: build/C/man7/fanotify.7:553
msgid ""
"This macro returns the size (in bytes) of the structure "
"I<fanotify_event_metadata>.  This is the minimum size (and currently the "
"only size) of any event metadata."
msgstr ""
"このマクロは I<fanotify_event_metadata> 構造体の (バイト単位の) サイズを返"
"す。 返される値はイベントメタデータの最小値である (現在のところ、これが唯一の"
"サイズである)。"

#. type: SS
#: build/C/man7/fanotify.7:553
#, no-wrap
msgid "Monitoring an fanotify file descriptor for events"
msgstr "fanotify ファイルディスクリプターのイベントを監視する"

#. type: Plain text
#: build/C/man7/fanotify.7:560
msgid ""
"When an fanotify event occurs, the fanotify file descriptor indicates as "
"readable when passed to B<epoll>(7), B<poll>(2), or B<select>(2)."
msgstr ""
"fanotify イベントが発生すると、 B<epoll>(7), B<poll>(2), B<select>(2) に "
"fanotify ファイルディスクリプターが渡された場合には、そのファイルディスクリプ"
"ターが読み出し可能であると通知される。"

#. type: SS
#: build/C/man7/fanotify.7:560
#, no-wrap
msgid "Dealing with permission events"
msgstr "アクセス許可イベントの取り扱い"

#. type: Plain text
#: build/C/man7/fanotify.7:565
msgid ""
"For permission events, the application must B<write>(2)  a structure of the "
"following form to the fanotify file descriptor:"
msgstr ""
"アクセス許可イベントでは、 アプリケーションは以下の形式の構造体を fanotify "
"ファイルディスクリプターに B<write>(2) しなければならない。"

#. type: Plain text
#: build/C/man7/fanotify.7:572
#, no-wrap
msgid ""
"struct fanotify_response {\n"
"    __s32 fd;\n"
"    __u32 response;\n"
"};\n"
msgstr ""
"struct fanotify_response {\n"
"    __s32 fd;\n"
"    __u32 response;\n"
"};\n"

#. type: Plain text
#: build/C/man7/fanotify.7:576
msgid "The fields of this structure are as follows:"
msgstr "この構造体のフィールドは以下のとおりである。"

#. type: Plain text
#: build/C/man7/fanotify.7:580
msgid ""
"This is the file descriptor from the structure I<fanotify_event_metadata>."
msgstr ""
"このフィールドは I<fanotify_event_metadata> 構造体で返されたファイルディスク"
"リプターである。"

#. type: TP
#: build/C/man7/fanotify.7:580
#, no-wrap
msgid "I<response>"
msgstr "I<response>"

#. type: Plain text
#: build/C/man7/fanotify.7:588
msgid ""
"This field indicates whether or not the permission is to be granted.  Its "
"value must be either B<FAN_ALLOW> to allow the file operation or B<FAN_DENY> "
"to deny the file operation."
msgstr ""
"このフィールドはアクセス許可を承認するかどうかを示す。 値は、このファイル操作"
"を許可する B<FAN_ALLOW> か、 このファイル操作を拒否する B<FAN_DENY> のいずれ"
"かでなければならない。"

#. type: Plain text
#: build/C/man7/fanotify.7:593
msgid ""
"If access is denied, the requesting application call will receive an "
"B<EPERM> error."
msgstr ""
"アクセスを拒否した場合、 アクセスを要求したアプリケーションは B<EPERM> エラー"
"を受け取ることになる。"

#. type: SS
#: build/C/man7/fanotify.7:593
#, no-wrap
msgid "Closing the fanotify file descriptor"
msgstr "fanotify ファイルディスクリプターのクローズ"

#. type: Plain text
#: build/C/man7/fanotify.7:600
msgid ""
"When all file descriptors referring to the fanotify notification group are "
"closed, the fanotify group is released and its resources are freed for reuse "
"by the kernel.  Upon B<close>(2), outstanding permission events will be set "
"to allowed."
msgstr ""
"fanotify 通知グループを参照するすべてのファイルディスクリプターがクローズされ"
"ると、 fanotify グループは解放され、 カーネルが再利用できるようにそのリソース"
"は解放される。 B<close>(2) の際に、 処理中であったアクセス許可イベントには許"
"可が設定される。"

#. type: SS
#: build/C/man7/fanotify.7:600
#, no-wrap
msgid "/proc/[pid]/fdinfo"
msgstr "/proc/[pid]/fdinfo"

#. type: Plain text
#: build/C/man7/fanotify.7:610
msgid ""
"The file I</proc/[pid]/fdinfo/[fd]> contains information about fanotify "
"marks for file descriptor I<fd> of process I<pid>.  See B<proc>(5)  for "
"details."
msgstr "ファイル I</proc/[pid]/fdinfo/[fd]> には、 プロセス I<pid> のファイルディスクリプター I<fd> の fanotify マークに関する情報が格納される。 詳細は B<proc>(5) を参照。"

#. type: SH
#: build/C/man7/fanotify.7:610 build/C/man2/fanotify_init.2:343
#: build/C/man2/fanotify_mark.2:368 build/C/man2/inotify_add_watch.2:84
#: build/C/man2/inotify_init.2:81 build/C/man2/inotify_rm_watch.2:55
#, no-wrap
msgid "ERRORS"
msgstr "エラー"

#. type: Plain text
#: build/C/man7/fanotify.7:615
msgid ""
"In addition to the usual errors for B<read>(2), the following errors can "
"occur when reading from the fanotify file descriptor:"
msgstr ""
"通常の B<read>(2) のエラーに加え、 fanotify ファイルディスクリプターから読み"
"出しを行った際に以下のエラーが発生することがある。"

#. type: TP
#: build/C/man7/fanotify.7:615 build/C/man7/fanotify.7:649
#: build/C/man2/fanotify_init.2:344 build/C/man2/fanotify_mark.2:373
#: build/C/man2/fanotify_mark.2:382 build/C/man2/inotify_add_watch.2:104
#: build/C/man2/inotify_init.2:82 build/C/man2/inotify_rm_watch.2:60
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#: build/C/man7/fanotify.7:618
msgid "The buffer is too small to hold the event."
msgstr "バッファーがイベントを保持するには小さすぎる。"

#. type: TP
#: build/C/man7/fanotify.7:618 build/C/man2/fanotify_init.2:355
#: build/C/man2/fanotify_init.2:358 build/C/man2/inotify_init.2:87
#: build/C/man2/inotify_init.2:90
#, no-wrap
msgid "B<EMFILE>"
msgstr "B<EMFILE>"

#. type: Plain text
#: build/C/man7/fanotify.7:625
msgid ""
"The per-process limit on the number of open files has been reached.  See the "
"description of B<RLIMIT_NOFILE> in B<getrlimit>(2)."
msgstr ""
"オープンしたファイル数のプロセス毎の上限に達した。 B<getrlimit>(2) の "
"B<RLIMIT_NOFILE> の説明を参照。"

#. type: TP
#: build/C/man7/fanotify.7:625 build/C/man2/inotify_init.2:93
#, no-wrap
msgid "B<ENFILE>"
msgstr "B<ENFILE>"

#. type: Plain text
#: build/C/man7/fanotify.7:632
msgid ""
"The system-wide limit on the total number of open files has been reached.  "
"See I</proc/sys/fs/file-max> in B<proc>(5)."
msgstr "オープンされたファイルの総数のシステム全体の上限に達した。 B<proc>(5) の I</proc/sys/fs/file-max> を参照。"

#. type: TP
#: build/C/man7/fanotify.7:632
#, no-wrap
msgid "B<ETXTBSY>"
msgstr "B<ETXTBSY>"

#. type: Plain text
#: build/C/man7/fanotify.7:645
msgid ""
"This error is returned by B<read>(2)  if B<O_RDWR> or B<O_WRONLY> was "
"specified in the I<event_f_flags> argument when calling B<fanotify_init>(2)  "
"and an event occurred for a monitored file that is currently being executed."
msgstr ""
"B<fanotify_init>(2) の呼び出し時に B<O_RDWR> か B<O_WRONLY> が "
"I<event_f_flags> 引数に指定されており、 現在実行中の監視対象のファイルに対"
"してイベントが発生した際に、 このエラーが B<read>(2) から返される。"

#. type: Plain text
#: build/C/man7/fanotify.7:649
msgid ""
"In addition to the usual errors for B<write>(2), the following errors can "
"occur when writing to the fanotify file descriptor:"
msgstr ""
"通常の B<write>(2) のエラーに加え、 fanotify ファイルディスクリプターに書き込"
"みを行った際に以下のエラーが発生することがある。"

#. type: Plain text
#: build/C/man7/fanotify.7:655
msgid ""
"Fanotify access permissions are not enabled in the kernel configuration or "
"the value of I<response> in the response structure is not valid."
msgstr ""
"fanotify アクセス許可がカーネルの設定で有効になっていない。 応答構造体の "
"I<response> 値が無効である。"

#. type: TP
#: build/C/man7/fanotify.7:655 build/C/man2/fanotify_mark.2:401
#: build/C/man2/inotify_add_watch.2:119
#, no-wrap
msgid "B<ENOENT>"
msgstr "B<ENOENT>"

#. type: Plain text
#: build/C/man7/fanotify.7:662
msgid ""
"The file descriptor I<fd> in the response structure is not valid.  This may "
"occur when a response for the permission event has already been written."
msgstr ""
"応答構造体のファイルディスクリプター I<fd> が無効である。 このエラーはアクセ"
"ス許可イベントに対する応答がすでに書き込まれている際に発生する。"

#. type: SH
#: build/C/man7/fanotify.7:662 build/C/man2/fanotify_init.2:375
#: build/C/man2/fanotify_mark.2:454 build/C/man7/inotify.7:594
#: build/C/man2/inotify_add_watch.2:139 build/C/man2/inotify_init.2:99
#: build/C/man2/inotify_rm_watch.2:67
#, no-wrap
msgid "VERSIONS"
msgstr "バージョン"

#. type: Plain text
#: build/C/man7/fanotify.7:666
msgid ""
"The fanotify API was introduced in version 2.6.36 of the Linux kernel and "
"enabled in version 2.6.37.  Fdinfo support was added in version 3.8."
msgstr ""
"fanotify API は Linux カーネルのバージョン 2.6.36 で導入され、 バージョン "
"2.6.37 で有効にされた。 fdinfo のサポートはバージョン 3.8 で追加された。"

#. type: SH
#: build/C/man7/fanotify.7:666 build/C/man2/fanotify_init.2:379
#: build/C/man2/fanotify_mark.2:458 build/C/man7/inotify.7:602
#: build/C/man2/inotify_add_watch.2:141 build/C/man2/inotify_init.2:106
#: build/C/man2/inotify_rm_watch.2:69
#, no-wrap
msgid "CONFORMING TO"
msgstr "準拠"

#. type: Plain text
#: build/C/man7/fanotify.7:668
msgid "The fanotify API is Linux-specific."
msgstr "fanotify API は Linux 独自のものである。"

#. type: SH
#: build/C/man7/fanotify.7:668 build/C/man2/fanotify_mark.2:460
#: build/C/man7/inotify.7:604
#, no-wrap
msgid "NOTES"
msgstr "注意"

#. type: Plain text
#: build/C/man7/fanotify.7:675
msgid ""
"The fanotify API is available only if the kernel was built with the "
"B<CONFIG_FANOTIFY> configuration option enabled.  In addition, fanotify "
"permission handling is available only if the "
"B<CONFIG_FANOTIFY_ACCESS_PERMISSIONS> configuration option is enabled."
msgstr ""
"fanotify API が利用できるのは、 カーネルが B<CONFIG_FANOTIFY> 設定オプション"
"を有効にして作成されている場合だけである。 また、 fanotify アクセス許可の処理"
"が利用できるのは B<CONFIG_FANOTIFY_ACCESS_PERMISSIONS> 設定オプションが有効に"
"なっている場合だけである。"

#. type: SS
#: build/C/man7/fanotify.7:675 build/C/man7/inotify.7:673
#, no-wrap
msgid "Limitations and caveats"
msgstr "制限と警告"

#. type: Plain text
#: build/C/man7/fanotify.7:680
msgid ""
"Fanotify reports only events that a user-space program triggers through the "
"filesystem API.  As a result, it does not catch remote events that occur on "
"network filesystems."
msgstr ""
"fanotify が報告するのはユーザー空間プログラムがファイルシステム API 経由で"
"行ったイベントだけである。 その結果、 fanotify ではネットワークファイルシステ"
"ム上で発生したリモートイベントは捕捉できない。"

#. type: Plain text
#: build/C/man7/fanotify.7:687
msgid ""
"The fanotify API does not report file accesses and modifications that may "
"occur because of B<mmap>(2), B<msync>(2), and B<munmap>(2)."
msgstr ""
"inotify API は B<mmap>(2), B<msync>(2), B<munmap>(2) により起こったファイルの"
"アクセスと変更を報告しない。"

#. type: Plain text
#: build/C/man7/fanotify.7:692
msgid ""
"Events for directories are created only if the directory itself is opened, "
"read, and closed.  Adding, removing, or changing children of a marked "
"directory does not create events for the monitored directory itself."
msgstr ""
"ディレクトリのイベントは、ディレクトリ自身がオープン、読み出し、クローズされ"
"た場合にしか作成されない。 マークされたディレクトリでの子要素の追加、削除、変"
"更では、監視対象のディレクトリ自身へのイベントは作成されない。"

#. type: Plain text
#: build/C/man7/fanotify.7:707
#, fuzzy
#| msgid ""
#| "Fanotify monitoring of directories is not recursive: to monitor "
#| "subdirectories under a directory, additional marks must be created.  (But "
#| "note that the fanotify API provides no way of detecting when a "
#| "subdirectory has been created under a marked directory, which makes "
#| "recursive monitoring difficult.)  Monitoring mounts offers the capability "
#| "to monitor a whole directory tree."
msgid ""
"Fanotify monitoring of directories is not recursive: to monitor "
"subdirectories under a directory, additional marks must be created.  The "
"B<FAN_CREATE> event can be used for detecting when a subdirectory has been "
"created under a marked directory.  An additional mark must then be set on "
"the newly created subdirectory.  This approach is racy, because it can lose "
"events that occurred inside the newly created subdirectory, before a mark is "
"added on that subdirectory.  Monitoring mounts offers the capability to "
"monitor a whole directory tree in a race-free manner.  Monitoring "
"filesystems offers the capability to monitor changes made from any mount of "
"a filesystem instance in a race-free manner."
msgstr ""
"fanotify のディレクトリの監視は再帰的ではない。 ディレクトリ内のサブディレク"
"トリを監視するには、 追加で監視用のマークを作成しなければならない。 (ただ"
"し、 fanotify API では、サブディレクトリが監視対象としてマークされているディ"
"レクトリに作成された際に検出する手段は提供されていない点に注意すること。) マ"
"ウントの監視を使うことで、 ディレクトリツリー全体を監視することができる。"

#. type: Plain text
#: build/C/man7/fanotify.7:710
msgid "The event queue can overflow.  In this case, events are lost."
msgstr ""
"ベントキューはオーバーフローすることがある。 この場合、 イベントは失われる。"

#. type: SH
#: build/C/man7/fanotify.7:710 build/C/man2/fanotify_init.2:381
#: build/C/man2/fanotify_mark.2:506 build/C/man7/inotify.7:811
#, no-wrap
msgid "BUGS"
msgstr "バグ"

#.  commit 820c12d5d6c0890bc93dd63893924a13041fdc35
#. type: Plain text
#: build/C/man7/fanotify.7:721
msgid ""
"Before Linux 3.19, B<fallocate>(2)  did not generate fanotify events.  Since "
"Linux 3.19, calls to B<fallocate>(2)  generate B<FAN_MODIFY> events."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:724
msgid "As of Linux 3.17, the following bugs exist:"
msgstr "Linux 3.17 時点では、 以下のバグが存在する。"

#. type: IP
#: build/C/man7/fanotify.7:724 build/C/man7/fanotify.7:733
#: build/C/man7/fanotify.7:742 build/C/man2/fanotify_init.2:383
#: build/C/man2/fanotify_init.2:391 build/C/man2/fanotify_mark.2:320
#: build/C/man2/fanotify_mark.2:326 build/C/man2/fanotify_mark.2:334
#: build/C/man2/fanotify_mark.2:340 build/C/man2/fanotify_mark.2:351
#: build/C/man2/fanotify_mark.2:508 build/C/man2/fanotify_mark.2:518
#: build/C/man2/fanotify_mark.2:524 build/C/man7/inotify.7:39
#: build/C/man7/inotify.7:50 build/C/man7/inotify.7:63
#: build/C/man7/inotify.7:69 build/C/man7/inotify.7:72
#: build/C/man7/inotify.7:278 build/C/man7/inotify.7:281
#, no-wrap
msgid "*"
msgstr "*"

#. type: Plain text
#: build/C/man7/fanotify.7:733
msgid ""
"On Linux, a filesystem object may be accessible through multiple paths, for "
"example, a part of a filesystem may be remounted using the I<--bind> option "
"of B<mount>(8).  A listener that marked a mount will be notified only of "
"events that were triggered for a filesystem object using the same mount.  "
"Any other event will pass unnoticed."
msgstr ""
"Linux では、ファイルシステムオブジェクトは複数のパスでアクセス可能である。 例"
"えば、 ファイルシステムの一部は B<mount>(8) の I<--bind> オプションを使って再"
"マウントされることがある。 マークされたマウントの監視者は、 同じマウントを"
"使ったファイルオブジェクトについてのみイベント通知を受ける。 それ以外のイベン"
"トは通知されない。"

#.  FIXME . A patch was proposed.
#. type: Plain text
#: build/C/man7/fanotify.7:742
msgid ""
"When an event is generated, no check is made to see whether the user ID of "
"the receiving process has authorization to read or write the file before "
"passing a file descriptor for that file.  This poses a security risk, when "
"the B<CAP_SYS_ADMIN> capability is set for programs executed by unprivileged "
"users."
msgstr ""
"イベントが生成された際に、 そのファイルのファイルディスクリプターを渡す前"
"に、 イベントを受信するプロセスのユーザー ID がそのファイルに対する読み出し／"
"書き込み許可があるかの確認は行われない。 非特権ユーザーによって実行されたプロ"
"グラムに B<CAP_SYS_ADMIN> ケーパビリティーがセットされている場合には、 このこ"
"とはセキュリティーリスクとなる。"

#. type: Plain text
#: build/C/man7/fanotify.7:752
msgid ""
"If a call to B<read>(2)  processes multiple events from the fanotify queue "
"and an error occurs, the return value will be the total length of the events "
"successfully copied to the user-space buffer before the error occurred.  The "
"return value will not be -1, and I<errno> will not be set.  Thus, the "
"reading application has no way to detect the error."
msgstr ""
"B<read>(2) の呼び出しが fanotify キューから複数のイベントを処理している際"
"に、 エラーが発生した場合、 返り値はエラーが発生する前までにユーザー空間バッ"
"ファーに正常にコピーされたイベントの合計長となる。 返り値は -1 にならず、 "
"I<errno> もセットされない。 したがって、 読み出しを行うアプリケーションではエ"
"ラーを検出する方法はない。"

#. type: SH
#: build/C/man7/fanotify.7:752 build/C/man7/inotify.7:879
#: build/C/man2/inotify_add_watch.2:143
#, no-wrap
msgid "EXAMPLES"
msgstr "例"

#. type: Plain text
#: build/C/man7/fanotify.7:754
msgid ""
"The two example programs below demonstrate the usage of the fanotify API."
msgstr ""

#. type: SS
#: build/C/man7/fanotify.7:754
#, no-wrap
msgid "Example program: fanotify_example.c"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:766
#, fuzzy
#| msgid ""
#| "The following program demonstrates the usage of the fanotify API.  It "
#| "marks the mount point passed as a command-line argument and waits for "
#| "events of type B<FAN_PERM_OPEN> and B<FAN_CLOSE_WRITE>.  When a "
#| "permission event occurs, a B<FAN_ALLOW> response is given."
msgid ""
"The first program is an example of fanotify being used with its event object "
"information passed in the form of a file descriptor.  The program marks the "
"mount point passed as a command-line argument and waits for events of type "
"B<FAN_OPEN_PERM> and B<FAN_CLOSE_WRITE>.  When a permission event occurs, a "
"B<FAN_ALLOW> response is given."
msgstr ""
"以下のプログラムは fanotify API の使用法を示すものである。 コマンドライン引"
"数で渡されたマウントポイントを監視し、 種別が B<FAN_PERM_OPEN> と "
"B<FAN_CLOSE_WRITE> のイベントを待つ。 アクセス許可イベントが発生には、 "
"B<FAN_ALLOW> 応答を返す。"

#. type: Plain text
#: build/C/man7/fanotify.7:778
#, fuzzy
#| msgid ""
#| "The following output was recorded while editing the file I</home/user/"
#| "temp/notes>.  Before the file was opened, a B<FAN_OPEN_PERM> event "
#| "occurred.  After the file was closed, a B<FAN_CLOSE_WRITE> event "
#| "occurred.  Execution of the program ends when the user presses the ENTER "
#| "key."
msgid ""
"The following shell session shows an example of running this program.  This "
"session involved editing the file I</home/user/temp/notes>.  Before the file "
"was opened, a B<FAN_OPEN_PERM> event occurred.  After the file was closed, a "
"B<FAN_CLOSE_WRITE> event occurred.  Execution of the program ends when the "
"user presses the ENTER key."
msgstr ""
"以下の出力例はファイル I</home/user/temp/notes> を編集した際に記録されたもの"
"である。 ファイルをオープンする前に B<FAN_OPEN_PERM> イベントが発生してい"
"る。 ファイルをクローズした後に B<FAN_CLOSE_WRITE> イベントが発生している。 "
"エンターキーをユーザーが押すと、 このプログラムの実行は終了する。"

#. type: Plain text
#: build/C/man7/fanotify.7:786
#, no-wrap
msgid ""
"# B<./fanotify_example /home>\n"
"Press enter key to terminate.\n"
"Listening for events.\n"
"FAN_OPEN_PERM: File /home/user/temp/notes\n"
"FAN_CLOSE_WRITE: File /home/user/temp/notes\n"
msgstr ""
"# B<./fanotify_example /home>\n"
"Press enter key to terminate.\n"
"Listening for events.\n"
"FAN_OPEN_PERM: File /home/user/temp/notes\n"
"FAN_CLOSE_WRITE: File /home/user/temp/notes\n"

#. type: Plain text
#: build/C/man7/fanotify.7:788 build/C/man7/inotify.7:914
#, no-wrap
msgid "Listening for events stopped.\n"
msgstr "Listening for events stopped.\n"

#. type: SS
#: build/C/man7/fanotify.7:790
#, no-wrap
msgid "Program source: fanotify_example.c"
msgstr "プログラムのソース: fanotify_example.c"

#. type: Plain text
#: build/C/man7/fanotify.7:802
#, no-wrap
msgid ""
"#define _GNU_SOURCE     /* Needed to get O_LARGEFILE definition */\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>limits.hE<gt>\n"
"#include E<lt>poll.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/fanotify.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE     /* O_LARGEFILE の定義を得るために必要 */\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>limits.hE<gt>\n"
"#include E<lt>poll.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/fanotify.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"

#. type: Plain text
#: build/C/man7/fanotify.7:804
#, no-wrap
msgid "/* Read all available fanotify events from the file descriptor \\(aqfd\\(aq */\n"
msgstr "/* ファイルディスクリプター \\(aqfd\\(aq から読み出しできる全 fanotify イベントを読み出す */\n"

#. type: Plain text
#: build/C/man7/fanotify.7:815
#, no-wrap
msgid ""
"static void\n"
"handle_events(int fd)\n"
"{\n"
"    const struct fanotify_event_metadata *metadata;\n"
"    struct fanotify_event_metadata buf[200];\n"
"    ssize_t len;\n"
"    char path[PATH_MAX];\n"
"    ssize_t path_len;\n"
"    char procfd_path[PATH_MAX];\n"
"    struct fanotify_response response;\n"
msgstr ""
"static void\n"
"handle_events(int fd)\n"
"{\n"
"    const struct fanotify_event_metadata *metadata;\n"
"    struct fanotify_event_metadata buf[200];\n"
"    ssize_t len;\n"
"    char path[PATH_MAX];\n"
"    ssize_t path_len;\n"
"    char procfd_path[PATH_MAX];\n"
"    struct fanotify_response response;\n"

#. type: Plain text
#: build/C/man7/fanotify.7:817
#, no-wrap
msgid "    /* Loop while events can be read from fanotify file descriptor */\n"
msgstr "    /* fanotify ファイルディスクリプターからイベントが読み出せる間はループする */\n"

#. type: Plain text
#: build/C/man7/fanotify.7:819 build/C/man7/inotify.7:950
#, no-wrap
msgid "    for (;;) {\n"
msgstr "    for (;;) {\n"

#. type: Plain text
#: build/C/man7/fanotify.7:821
#, no-wrap
msgid "        /* Read some events */\n"
msgstr "        /* イベントを読み出す */\n"

#. type: Plain text
#: build/C/man7/fanotify.7:827 build/C/man7/inotify.7:958
#, no-wrap
msgid ""
"        len = read(fd, buf, sizeof(buf));\n"
"        if (len == -1 && errno != EAGAIN) {\n"
"            perror(\"read\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""
"        len = read(fd, buf, sizeof(buf));\n"
"        if (len == -1 && errno != EAGAIN) {\n"
"            perror(\"read\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"

#. type: Plain text
#: build/C/man7/fanotify.7:829
#, no-wrap
msgid "        /* Check if end of available data reached */\n"
msgstr "        /* 読み出せるデータの最後に達しているかチェックする */\n"

#. type: Plain text
#: build/C/man7/fanotify.7:832 build/C/man7/inotify.7:965
#, no-wrap
msgid ""
"        if (len E<lt>= 0)\n"
"            break;\n"
msgstr ""
"        if (len E<lt>= 0)\n"
"            break;\n"

#. type: Plain text
#: build/C/man7/fanotify.7:834
#, no-wrap
msgid "        /* Point to the first event in the buffer */\n"
msgstr "        /* バッファーの最初のイベントを参照する */\n"

#. type: Plain text
#: build/C/man7/fanotify.7:836
#, no-wrap
msgid "        metadata = buf;\n"
msgstr "        metadata = buf;\n"

#. type: Plain text
#: build/C/man7/fanotify.7:838 build/C/man7/inotify.7:967
#, no-wrap
msgid "        /* Loop over all events in the buffer */\n"
msgstr "        /* バッファー内の全イベントを処理する */\n"

#. type: Plain text
#: build/C/man7/fanotify.7:840
#, no-wrap
msgid "        while (FAN_EVENT_OK(metadata, len)) {\n"
msgstr "        while (FAN_EVENT_OK(metadata, len)) {\n"

#. type: Plain text
#: build/C/man7/fanotify.7:842
#, no-wrap
msgid "            /* Check that run-time and compile-time structures match */\n"
msgstr "            /* 実行時とコンパイル時の構造体が一致するか確認する */\n"

#. type: Plain text
#: build/C/man7/fanotify.7:848
#, no-wrap
msgid ""
"            if (metadata-E<gt>vers != FANOTIFY_METADATA_VERSION) {\n"
"                fprintf(stderr,\n"
"                        \"Mismatch of fanotify metadata version.\\en\");\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
msgstr ""
"            if (metadata-E<gt>vers != FANOTIFY_METADATA_VERSION) {\n"
"                fprintf(stderr,\n"
"                        \"Mismatch of fanotify metadata version.\\en\");\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"

#. type: Plain text
#: build/C/man7/fanotify.7:852
#, no-wrap
msgid ""
"            /* metadata-E<gt>fd contains either FAN_NOFD, indicating a\n"
"               queue overflow, or a file descriptor (a nonnegative\n"
"               integer). Here, we simply ignore queue overflow. */\n"
msgstr ""
"            /* metadata-E<gt>fd には、キューのオーバーフローを示す FAN_NOFD か、\n"
"               ファイルディスクリプター (負でない整数) のいずれかが入っている。\n"
"               ここではキューのオーバーフローは無視している。 */\n"

#. type: Plain text
#: build/C/man7/fanotify.7:854
#, no-wrap
msgid "            if (metadata-E<gt>fd E<gt>= 0) {\n"
msgstr "            if (metadata-E<gt>fd E<gt>= 0) {\n"

#. type: Plain text
#: build/C/man7/fanotify.7:856
#, no-wrap
msgid "                /* Handle open permission event */\n"
msgstr "                /* オープン許可イベントを処理する */\n"

#. type: Plain text
#: build/C/man7/fanotify.7:859
#, no-wrap
msgid ""
"                if (metadata-E<gt>mask & FAN_OPEN_PERM) {\n"
"                    printf(\"FAN_OPEN_PERM: \");\n"
msgstr ""
"                if (metadata-E<gt>mask & FAN_OPEN_PERM) {\n"
"                    printf(\"FAN_OPEN_PERM: \");\n"

#. type: Plain text
#: build/C/man7/fanotify.7:861
#, no-wrap
msgid "                    /* Allow file to be opened */\n"
msgstr "                    /* ファイルのオープンを許可する */\n"

#. type: Plain text
#: build/C/man7/fanotify.7:866
#, no-wrap
msgid ""
"                    response.fd = metadata-E<gt>fd;\n"
"                    response.response = FAN_ALLOW;\n"
"                    write(fd, &response, sizeof(response));\n"
"                }\n"
msgstr ""
"                    response.fd = metadata-E<gt>fd;\n"
"                    response.response = FAN_ALLOW;\n"
"                    write(fd, &response, sizeof(response));\n"
"                }\n"

#. type: Plain text
#: build/C/man7/fanotify.7:868
#, no-wrap
msgid "                /* Handle closing of writable file event */\n"
msgstr "                /* 書き込み可能ファイルのクローズイベントを処理する */\n"

#. type: Plain text
#: build/C/man7/fanotify.7:871
#, no-wrap
msgid ""
"                if (metadata-E<gt>mask & FAN_CLOSE_WRITE)\n"
"                    printf(\"FAN_CLOSE_WRITE: \");\n"
msgstr ""
"                if (metadata-E<gt>mask & FAN_CLOSE_WRITE)\n"
"                    printf(\"FAN_CLOSE_WRITE: \");\n"

#. type: Plain text
#: build/C/man7/fanotify.7:873
#, no-wrap
msgid "                /* Retrieve and print pathname of the accessed file */\n"
msgstr "                /* アクセスされたファイルのパス名を取得し表示する */\n"

#. type: Plain text
#: build/C/man7/fanotify.7:882
#, no-wrap
msgid ""
"                snprintf(procfd_path, sizeof(procfd_path),\n"
"                         \"/proc/self/fd/%d\", metadata-E<gt>fd);\n"
"                path_len = readlink(procfd_path, path,\n"
"                                    sizeof(path) - 1);\n"
"                if (path_len == -1) {\n"
"                    perror(\"readlink\");\n"
"                    exit(EXIT_FAILURE);\n"
"                }\n"
msgstr ""
"                snprintf(procfd_path, sizeof(procfd_path),\n"
"                         \"/proc/self/fd/%d\", metadata-E<gt>fd);\n"
"                path_len = readlink(procfd_path, path,\n"
"                                    sizeof(path) - 1);\n"
"                if (path_len == -1) {\n"
"                    perror(\"readlink\");\n"
"                    exit(EXIT_FAILURE);\n"
"                }\n"

#. type: Plain text
#: build/C/man7/fanotify.7:885
#, no-wrap
msgid ""
"                path[path_len] = \\(aq\\e0\\(aq;\n"
"                printf(\"File %s\\en\", path);\n"
msgstr ""
"                path[path_len] = \\(aq\\e0\\(aq;\n"
"                printf(\"File %s\\en\", path);\n"

#. type: Plain text
#: build/C/man7/fanotify.7:887
#, no-wrap
msgid "                /* Close the file descriptor of the event */\n"
msgstr "                /* イベントのファイルディスクリプターをクローズする */\n"

#. type: Plain text
#: build/C/man7/fanotify.7:890
#, no-wrap
msgid ""
"                close(metadata-E<gt>fd);\n"
"            }\n"
msgstr ""
"                close(metadata-E<gt>fd);\n"
"            }\n"

#. type: Plain text
#: build/C/man7/fanotify.7:892
#, no-wrap
msgid "            /* Advance to next event */\n"
msgstr "            /* 次のイベントに進む */\n"

#. type: Plain text
#: build/C/man7/fanotify.7:897
#, no-wrap
msgid ""
"            metadata = FAN_EVENT_NEXT(metadata, len);\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""
"            metadata = FAN_EVENT_NEXT(metadata, len);\n"
"        }\n"
"    }\n"
"}\n"

#. type: Plain text
#: build/C/man7/fanotify.7:905
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char buf;\n"
"    int fd, poll_num;\n"
"    nfds_t nfds;\n"
"    struct pollfd fds[2];\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char buf;\n"
"    int fd, poll_num;\n"
"    nfds_t nfds;\n"
"    struct pollfd fds[2];\n"

#. type: Plain text
#: build/C/man7/fanotify.7:907
#, no-wrap
msgid "    /* Check mount point is supplied */\n"
msgstr "    /* マウントポイントが指定されたか確認する */\n"

#. type: Plain text
#: build/C/man7/fanotify.7:912
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s MOUNT\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s MOUNT\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man7/fanotify.7:914
#, no-wrap
msgid "    printf(\"Press enter key to terminate.\\en\");\n"
msgstr "    printf(\"Press enter key to terminate.\\en\");\n"

#. type: Plain text
#: build/C/man7/fanotify.7:916
#, no-wrap
msgid "    /* Create the file descriptor for accessing the fanotify API */\n"
msgstr "    /* fanotify API にアクセスするためのファイルディスクリプターを作成する */\n"

#. type: Plain text
#: build/C/man7/fanotify.7:923
#, no-wrap
msgid ""
"    fd = fanotify_init(FAN_CLOEXEC | FAN_CLASS_CONTENT | FAN_NONBLOCK,\n"
"                       O_RDONLY | O_LARGEFILE);\n"
"    if (fd == -1) {\n"
"        perror(\"fanotify_init\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    fd = fanotify_init(FAN_CLOEXEC | FAN_CLASS_CONTENT | FAN_NONBLOCK,\n"
"                       O_RDONLY | O_LARGEFILE);\n"
"    if (fd == -1) {\n"
"        perror(\"fanotify_init\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man7/fanotify.7:928
#, no-wrap
msgid ""
"    /* Mark the mount for:\n"
"       - permission events before opening files\n"
"       - notification events after closing a write-enabled\n"
"         file descriptor */\n"
msgstr ""
"    /* 指定されたマウントに対して以下を監視するようにマークを付ける:\n"
"       - ファイルのオープン前のアクセス許可イベント\n"
"       - 書き込み可能なファイルディスクリプターのクローズ後の\n"
"         通知イベント */\n"

#. type: Plain text
#: build/C/man7/fanotify.7:935
#, no-wrap
msgid ""
"    if (fanotify_mark(fd, FAN_MARK_ADD | FAN_MARK_MOUNT,\n"
"                      FAN_OPEN_PERM | FAN_CLOSE_WRITE, AT_FDCWD,\n"
"                      argv[1]) == -1) {\n"
"        perror(\"fanotify_mark\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (fanotify_mark(fd, FAN_MARK_ADD | FAN_MARK_MOUNT,\n"
"                      FAN_OPEN_PERM | FAN_CLOSE_WRITE, AT_FDCWD,\n"
"                      argv[1]) == -1) {\n"
"        perror(\"fanotify_mark\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man7/fanotify.7:937 build/C/man7/inotify.7:1053
#, no-wrap
msgid "    /* Prepare for polling */\n"
msgstr "    /* ポーリングの準備 */\n"

#. type: Plain text
#: build/C/man7/fanotify.7:939 build/C/man7/inotify.7:1055
#, no-wrap
msgid "    nfds = 2;\n"
msgstr "    nfds = 2;\n"

#. type: Plain text
#: build/C/man7/fanotify.7:941 build/C/man7/inotify.7:1057
#, no-wrap
msgid "    /* Console input */\n"
msgstr "    /* コンソールの入力 */\n"

#. type: Plain text
#: build/C/man7/fanotify.7:944 build/C/man7/inotify.7:1060
#, no-wrap
msgid ""
"    fds[0].fd = STDIN_FILENO;\n"
"    fds[0].events = POLLIN;\n"
msgstr ""
"    fds[0].fd = STDIN_FILENO;\n"
"    fds[0].events = POLLIN;\n"

#. type: Plain text
#: build/C/man7/fanotify.7:946
#, no-wrap
msgid "    /* Fanotify input */\n"
msgstr "    /* fanotify の入力 */\n"

#. type: Plain text
#: build/C/man7/fanotify.7:949 build/C/man7/inotify.7:1065
#, no-wrap
msgid ""
"    fds[1].fd = fd;\n"
"    fds[1].events = POLLIN;\n"
msgstr ""
"    fds[1].fd = fd;\n"
"    fds[1].events = POLLIN;\n"

#. type: Plain text
#: build/C/man7/fanotify.7:951
#, no-wrap
msgid "    /* This is the loop to wait for incoming events */\n"
msgstr "    /* イベントの発生を待つループ */\n"

#. type: Plain text
#: build/C/man7/fanotify.7:953 build/C/man7/fanotify.7:1113
#, no-wrap
msgid "    printf(\"Listening for events.\\en\");\n"
msgstr "    printf(\"Listening for events.\\en\");\n"

#. type: Plain text
#: build/C/man7/fanotify.7:959
#, no-wrap
msgid ""
"    while (1) {\n"
"        poll_num = poll(fds, nfds, -1);\n"
"        if (poll_num == -1) {\n"
"            if (errno == EINTR)     /* Interrupted by a signal */\n"
"                continue;           /* Restart poll() */\n"
msgstr ""
"    while (1) {\n"
"        poll_num = poll(fds, nfds, -1);\n"
"        if (poll_num == -1) {\n"
"            if (errno == EINTR)     /* シグナルに割り込まれた場合 */\n"
"                continue;           /* poll() を再開する */\n"

#. type: Plain text
#: build/C/man7/fanotify.7:963
#, no-wrap
msgid ""
"            perror(\"poll\");         /* Unexpected error */\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""
"            perror(\"poll\");         /* 予期しないエラー */\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"

#. type: Plain text
#: build/C/man7/fanotify.7:966
#, no-wrap
msgid ""
"        if (poll_num E<gt> 0) {\n"
"            if (fds[0].revents & POLLIN) {\n"
msgstr ""
"        if (poll_num E<gt> 0) {\n"
"            if (fds[0].revents & POLLIN) {\n"

#. type: Plain text
#: build/C/man7/fanotify.7:968
#, no-wrap
msgid "                /* Console input is available: empty stdin and quit */\n"
msgstr "                /* コンソールからの入力がある場合: 空の標準入力であれば終了 */\n"

#. type: Plain text
#: build/C/man7/fanotify.7:973 build/C/man7/inotify.7:1088
#, no-wrap
msgid ""
"                while (read(STDIN_FILENO, &buf, 1) E<gt> 0 && buf != \\(aq\\en\\(aq)\n"
"                    continue;\n"
"                break;\n"
"            }\n"
msgstr ""
"                while (read(STDIN_FILENO, &buf, 1) E<gt> 0 && buf != \\(aq\\en\\(aq)\n"
"                    continue;\n"
"                break;\n"
"            }\n"

#. type: Plain text
#: build/C/man7/fanotify.7:975 build/C/man7/inotify.7:1090
#, no-wrap
msgid "            if (fds[1].revents & POLLIN) {\n"
msgstr "            if (fds[1].revents & POLLIN) {\n"

#. type: Plain text
#: build/C/man7/fanotify.7:977
#, no-wrap
msgid "                /* Fanotify events are available */\n"
msgstr "                /* fanotify イベントがある場合 */\n"

#. type: Plain text
#: build/C/man7/fanotify.7:982
#, no-wrap
msgid ""
"                handle_events(fd);\n"
"            }\n"
"        }\n"
"    }\n"
msgstr ""
"                handle_events(fd);\n"
"            }\n"
"        }\n"
"    }\n"

#. type: Plain text
#: build/C/man7/fanotify.7:986
#, no-wrap
msgid ""
"    printf(\"Listening for events stopped.\\en\");\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    printf(\"Listening for events stopped.\\en\");\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: SS
#: build/C/man7/fanotify.7:988
#, no-wrap
msgid "Example program: fanotify_fid.c"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:1000
msgid ""
"The second program is an example of fanotify being used with a group that "
"identifies objects by file handles.  The program marks the filesystem object "
"that is passed as a command-line argument and waits until an event of type "
"B<FAN_CREATE> has occurred.  The event mask indicates which type of "
"filesystem object\\(emeither a file or a directory\\(emwas created.  Once "
"all events have been read from the buffer and processed accordingly, the "
"program simply terminates."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:1003
msgid ""
"The following shell sessions show two different invocations of this program, "
"with different actions performed on a watched object."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:1014
msgid ""
"The first session shows a mark being placed on I</home/user>.  This is "
"followed by the creation of a regular file, I</home/user/testfile.txt>.  "
"This results in a B<FAN_CREATE> event being generated and reported against "
"the file's parent watched directory object and with the created file name.  "
"Program execution ends once all events captured within the buffer have been "
"processed."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:1023
#, no-wrap
msgid ""
"# B<./fanotify_fid /home/user>\n"
"Listening for events.\n"
"FAN_CREATE (file created):\n"
"        Directory /home/user has been modified.\n"
"        Entry \\(aqtestfile.txt\\(aq is not a subdirectory.\n"
"All events processed successfully. Program exiting.\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:1025
#, no-wrap
msgid "$ B<touch /home/user/testfile.txt>              # In another terminal\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:1037
msgid ""
"The second session shows a mark being placed on I</home/user>.  This is "
"followed by the creation of a directory, I</home/user/testdir>.  This "
"specific action results in a B<FAN_CREATE> event being generated and is "
"reported with the B<FAN_ONDIR> flag set and with the created directory name."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:1046
#, no-wrap
msgid ""
"# B<./fanotify_fid /home/user>\n"
"Listening for events.\n"
"FAN_CREATE | FAN_ONDIR (subdirectory created):\n"
"        Directory /home/user has been modified.\n"
"        Entry \\(aqtestdir\\(aq is a subdirectory.\n"
"All events processed successfully. Program exiting.\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:1048
#, no-wrap
msgid "$ B<mkdir -p /home/user/testdir>          # In another terminal\n"
msgstr "$ B<mkdir -p /home/user/testdir>          # In another terminal\n"

#. type: SS
#: build/C/man7/fanotify.7:1050
#, no-wrap
msgid "Program source: fanotify_fid.c"
msgstr "プログラムのソース: fanotify_fid.c"

#. type: Plain text
#: build/C/man7/fanotify.7:1063
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>limits.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>sys/fanotify.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>limits.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>sys/fanotify.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"

#. type: Plain text
#: build/C/man7/fanotify.7:1065
#, no-wrap
msgid "#define BUF_SIZE 256\n"
msgstr "#define BUF_SIZE 256\n"

#. type: Plain text
#: build/C/man7/fanotify.7:1079
#, no-wrap
msgid ""
"int\n"
"main(int argc, char **argv)\n"
"{\n"
"    int fd, ret, event_fd, mount_fd;\n"
"    ssize_t len, path_len;\n"
"    char path[PATH_MAX];\n"
"    char procfd_path[PATH_MAX];\n"
"    char events_buf[BUF_SIZE];\n"
"    struct file_handle *file_handle;\n"
"    struct fanotify_event_metadata *metadata;\n"
"    struct fanotify_event_info_fid *fid;\n"
"    const char *file_name;\n"
"    struct stat sb;\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:1084
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Invalid number of command line arguments.\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Invalid number of command line arguments.\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man7/fanotify.7:1090
#, no-wrap
msgid ""
"    mount_fd = open(argv[1], O_DIRECTORY | O_RDONLY);\n"
"    if (mount_fd == -1) {\n"
"        perror(argv[1]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    mount_fd = open(argv[1], O_DIRECTORY | O_RDONLY);\n"
"    if (mount_fd == -1) {\n"
"        perror(argv[1]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man7/fanotify.7:1095
#, no-wrap
msgid ""
"    /* Create an fanotify file descriptor with FAN_REPORT_DFID_NAME as\n"
"       a flag so that program can receive fid events with directory\n"
"       entry name. */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:1101
#, no-wrap
msgid ""
"    fd = fanotify_init(FAN_CLASS_NOTIF | FAN_REPORT_DFID_NAME, 0);\n"
"    if (fd == -1) {\n"
"        perror(\"fanotify_init\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    fd = fanotify_init(FAN_CLASS_NOTIF | FAN_REPORT_DFID_NAME, 0);\n"
"    if (fd == -1) {\n"
"        perror(\"fanotify_init\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man7/fanotify.7:1103
#, no-wrap
msgid "    /* Place a mark on the filesystem object supplied in argv[1]. */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:1111
#, no-wrap
msgid ""
"    ret = fanotify_mark(fd, FAN_MARK_ADD | FAN_MARK_ONLYDIR,\n"
"                        FAN_CREATE | FAN_ONDIR,\n"
"                        AT_FDCWD, argv[1]);\n"
"    if (ret == -1) {\n"
"        perror(\"fanotify_mark\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    ret = fanotify_mark(fd, FAN_MARK_ADD | FAN_MARK_ONLYDIR,\n"
"                        FAN_CREATE | FAN_ONDIR,\n"
"                        AT_FDCWD, argv[1]);\n"
"    if (ret == -1) {\n"
"        perror(\"fanotify_mark\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man7/fanotify.7:1115
#, fuzzy, no-wrap
#| msgid "        /* Point to the first event in the buffer */\n"
msgid "    /* Read events from the event queue into a buffer */\n"
msgstr "        /* バッファーの最初のイベントを参照する */\n"

#. type: Plain text
#: build/C/man7/fanotify.7:1121
#, no-wrap
msgid ""
"    len = read(fd, events_buf, sizeof(events_buf));\n"
"    if (len == -1 && errno != EAGAIN) {\n"
"        perror(\"read\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    len = read(fd, events_buf, sizeof(events_buf));\n"
"    if (len == -1 && errno != EAGAIN) {\n"
"        perror(\"read\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man7/fanotify.7:1123
#, no-wrap
msgid "    /* Process all events within the buffer */\n"
msgstr "        /* バッファー内の全イベントを処理する */\n"

#. type: Plain text
#: build/C/man7/fanotify.7:1129
#, no-wrap
msgid ""
"    for (metadata = (struct fanotify_event_metadata *) events_buf;\n"
"            FAN_EVENT_OK(metadata, len);\n"
"            metadata = FAN_EVENT_NEXT(metadata, len)) {\n"
"        fid = (struct fanotify_event_info_fid *) (metadata + 1);\n"
"        file_handle = (struct file_handle *) fid-E<gt>handle;\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:1131
#, fuzzy, no-wrap
#| msgid "        /* Point to the first event in the buffer */\n"
msgid "        /* Ensure that the event info is of the correct type */\n"
msgstr "        /* バッファーの最初のイベントを参照する */\n"

#. type: Plain text
#: build/C/man7/fanotify.7:1142
#, no-wrap
msgid ""
"        if (fid-E<gt>hdr.info_type == FAN_EVENT_INFO_TYPE_FID ||\n"
"            fid-E<gt>hdr.info_type == FAN_EVENT_INFO_TYPE_DFID) {\n"
"            file_name = NULL;\n"
"        } else if (fid-E<gt>hdr.info_type == FAN_EVENT_INFO_TYPE_DFID_NAME) {\n"
"            file_name = file_handle-E<gt>f_handle +\n"
"                        file_handle-E<gt>handle_bytes;\n"
"        } else {\n"
"            fprintf(stderr, \"Received unexpected event info type.\\en\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:1145
#, no-wrap
msgid ""
"        if (metadata-E<gt>mask == FAN_CREATE)\n"
"            printf(\"FAN_CREATE (file created):\\en\");\n"
msgstr ""
"        if (metadata-E<gt>mask == FAN_CREATE)\n"
"            printf(\"FAN_CREATE (file created):\\en\");\n"

#. type: Plain text
#: build/C/man7/fanotify.7:1148
#, no-wrap
msgid ""
"        if (metadata-E<gt>mask == (FAN_CREATE | FAN_ONDIR))\n"
"            printf(\"FAN_CREATE | FAN_ONDIR (subdirectory created):\\en\");\n"
msgstr ""
"        if (metadata-E<gt>mask == (FAN_CREATE | FAN_ONDIR))\n"
"            printf(\"FAN_CREATE | FAN_ONDIR (subdirectory created):\\en\");\n"

#. type: Plain text
#: build/C/man7/fanotify.7:1157
#, no-wrap
msgid ""
"\t/* metadata-E<gt>fd is set to FAN_NOFD when the group identifies\n"
"\t   objects by file handles.  To obtain a file descriptor for\n"
"\t   the file object corresponding to an event you can use the\n"
"\t   struct file_handle that\\(aqs provided within the\n"
"\t   fanotify_event_info_fid in conjunction with the\n"
"\t   open_by_handle_at(2) system call.  A check for ESTALE is\n"
"\t   done to accommodate for the situation where the file handle\n"
"\t   for the object was deleted prior to this system call. */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:1169
#, no-wrap
msgid ""
"        event_fd = open_by_handle_at(mount_fd, file_handle, O_RDONLY);\n"
"        if (event_fd == -1) {\n"
"            if (errno == ESTALE) {\n"
"                printf(\"File handle is no longer valid. \"\n"
"                        \"File has been deleted\\en\");\n"
"                continue;\n"
"            } else {\n"
"                perror(\"open_by_handle_at\");\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
"        }\n"
msgstr ""
"        event_fd = open_by_handle_at(mount_fd, file_handle, O_RDONLY);\n"
"        if (event_fd == -1) {\n"
"            if (errno == ESTALE) {\n"
"                printf(\"File handle is no longer valid. \"\n"
"                        \"File has been deleted\\en\");\n"
"                continue;\n"
"            } else {\n"
"                perror(\"open_by_handle_at\");\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
"        }\n"

#. type: Plain text
#: build/C/man7/fanotify.7:1172
#, no-wrap
msgid ""
"        snprintf(procfd_path, sizeof(procfd_path), \"/proc/self/fd/%d\",\n"
"                event_fd);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:1174
#, no-wrap
msgid "        /* Retrieve and print the path of the modified dentry */\n"
msgstr "                /* 変更された dentry のパスを取得し表示する */\n"

#. type: Plain text
#: build/C/man7/fanotify.7:1180
#, no-wrap
msgid ""
"        path_len = readlink(procfd_path, path, sizeof(path) - 1);\n"
"        if (path_len == -1) {\n"
"            perror(\"readlink\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""
"        path_len = readlink(procfd_path, path, sizeof(path) - 1);\n"
"        if (path_len == -1) {\n"
"            perror(\"readlink\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"

#. type: Plain text
#: build/C/man7/fanotify.7:1183
#, no-wrap
msgid ""
"        path[path_len] = \\(aq\\e0\\(aq;\n"
"        printf(\"\\etDirectory \\(aq%s\\(aq has been modified.\\en\", path);\n"
msgstr ""
"        path[path_len] = \\(aq\\e0\\(aq;\n"
"        printf(\"\\etDirectory \\(aq%s\\(aq has been modified.\\en\", path);\n"

#. type: Plain text
#: build/C/man7/fanotify.7:1199
#, no-wrap
msgid ""
"        if (file_name) {\n"
"            ret = fstatat(event_fd, file_name, &sb, 0);\n"
"            if (ret == -1) {\n"
"                if (errno != ENOENT) {\n"
"                    perror(\"fstatat\");\n"
"                    exit(EXIT_FAILURE);\n"
"                }\n"
"                printf(\"\\etEntry \\(aq%s\\(aq does not exist.\\en\", file_name);\n"
"            } else if ((sb.st_mode & S_IFMT) == S_IFDIR) {\n"
"                printf(\"\\etEntry \\(aq%s\\(aq is a subdirectory.\\en\", file_name);\n"
"            } else {\n"
"                printf(\"\\etEntry \\(aq%s\\(aq is not a subdirectory.\\en\",\n"
"                        file_name);\n"
"            }\n"
"        }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:1201
#, fuzzy, no-wrap
#| msgid "                /* Close the file descriptor of the event */\n"
msgid "        /* Close associated file descriptor for this event */\n"
msgstr "                /* イベントのファイルディスクリプターをクローズする */\n"

#. type: Plain text
#: build/C/man7/fanotify.7:1204
#, no-wrap
msgid ""
"        close(event_fd);\n"
"    }\n"
msgstr ""
"        close(event_fd);\n"
"    }\n"

#. type: Plain text
#: build/C/man7/fanotify.7:1208
#, no-wrap
msgid ""
"    printf(\"All events processed successfully. Program exiting.\\en\");\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    printf(\"All events processed successfully. Program exiting.\\en\");\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: SH
#: build/C/man7/fanotify.7:1209 build/C/man2/fanotify_init.2:401
#: build/C/man2/fanotify_mark.2:532 build/C/man7/inotify.7:1108
#: build/C/man2/inotify_add_watch.2:146 build/C/man2/inotify_init.2:108
#: build/C/man2/inotify_rm_watch.2:71
#, no-wrap
msgid "SEE ALSO"
msgstr "関連項目"

#. type: Plain text
#: build/C/man7/fanotify.7:1214
msgid "B<fanotify_init>(2), B<fanotify_mark>(2), B<inotify>(7)"
msgstr "B<fanotify_init>(2), B<fanotify_mark>(2), B<inotify>(7)"

#. type: SH
#: build/C/man7/fanotify.7:1214 build/C/man2/fanotify_init.2:404
#: build/C/man2/fanotify_mark.2:535 build/C/man7/inotify.7:1121
#: build/C/man2/inotify_add_watch.2:150 build/C/man2/inotify_init.2:112
#: build/C/man2/inotify_rm_watch.2:75
#, no-wrap
msgid "COLOPHON"
msgstr "この文書について"

#. type: Plain text
#: build/C/man7/fanotify.7:1222 build/C/man2/fanotify_init.2:412
#: build/C/man2/fanotify_mark.2:543 build/C/man7/inotify.7:1129
#: build/C/man2/inotify_add_watch.2:158 build/C/man2/inotify_init.2:120
#: build/C/man2/inotify_rm_watch.2:83
msgid ""
"This page is part of release 5.10 of the Linux I<man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at \\%https://www.kernel.org/doc/man-"
"pages/."
msgstr "この man ページは Linux I<man-pages> プロジェクトのリリース 5.10 の一部である。プロジェクトの説明とバグ報告に関する情報は \\%https://www.kernel.org/doc/man-pages/ に書かれている。"

#. type: TH
#: build/C/man2/fanotify_init.2:24
#, no-wrap
msgid "FANOTIFY_INIT"
msgstr "FANOTIFY_INIT"

#. type: Plain text
#: build/C/man2/fanotify_init.2:27
msgid "fanotify_init - create and initialize fanotify group"
msgstr "fanotify_init - fanotify グループを作成し、初期化する"

#. type: SH
#: build/C/man2/fanotify_init.2:27 build/C/man2/fanotify_mark.2:28
#: build/C/man2/inotify_add_watch.2:31 build/C/man2/inotify_init.2:32
#: build/C/man2/inotify_rm_watch.2:30
#, no-wrap
msgid "SYNOPSIS"
msgstr "書式"

#. type: Plain text
#: build/C/man2/fanotify_init.2:29
msgid "B<#include E<lt>fcntl.hE<gt>>"
msgstr "B<#include E<lt>fcntl.hE<gt>>"

#. type: Plain text
#: build/C/man2/fanotify_init.2:31
msgid "B<#include E<lt>sys/fanotify.hE<gt>>"
msgstr "B<#include E<lt>sys/fanotify.hE<gt>>"

#. type: Plain text
#: build/C/man2/fanotify_init.2:33
msgid ""
"B<int fanotify_init(unsigned int >I<flags>B<, unsigned int "
">I<event_f_flags>B<);>"
msgstr ""
"B<int fanotify_init(unsigned int >I<flags>B<, unsigned int "
">I<event_f_flags>B<);>"

#. type: Plain text
#: build/C/man2/fanotify_init.2:36 build/C/man2/fanotify_mark.2:39
msgid "For an overview of the fanotify API, see B<fanotify>(7)."
msgstr "fanotify API の概要については B<fanotify>(7) を参照。"

#. type: Plain text
#: build/C/man2/fanotify_init.2:40
msgid ""
"B<fanotify_init>()  initializes a new fanotify group and returns a file "
"descriptor for the event queue associated with the group."
msgstr ""
"B<fanotify_init>() は新しい fanotify グループを初期化し、 このグループに関連"
"付けられたイベントキューに対するファイルディスクリプターを返す。"

#. type: Plain text
#: build/C/man2/fanotify_init.2:51
msgid ""
"The file descriptor is used in calls to B<fanotify_mark>(2)  to specify the "
"files, directories, mounts or filesystems for which fanotify events shall be "
"created.  These events are received by reading from the file descriptor.  "
"Some events are only informative, indicating that a file has been accessed.  "
"Other events can be used to determine whether another application is "
"permitted to access a file or directory.  Permission to access filesystem "
"objects is granted by writing to the file descriptor."
msgstr "このファイルディスクリプターは、 B<fanotify_mark>(2) の呼び出しで fanotify イベントが作成されるファイル、 ディレクトリ、 マウント、ファイルシステムを指定するのに使用できる。 B<fanotify_mark>(2) で指定したファイル、 これらのイベントは、 このファイルディスクリプターからの読み出しで受信する。 いくつかのイベントは、 ファイルがアクセスされたことを示す単なる情報である。 他のいくつかのイベントは、 別のアプリケーションがファイルやディレクトリにアクセスする許可を与えるかを判定するのに使用される。 ファイルシステムオブジェクトへのアクセス許可イベントについては、 承認結果をこのファイルディスクリプターに書き込む。"

#. type: Plain text
#: build/C/man2/fanotify_init.2:54
msgid ""
"Multiple programs may be using the fanotify interface at the same time to "
"monitor the same files."
msgstr ""
"複数のプログラムが同時に fanotify インターフェースを使って同じファイルを同時"
"に監視することができる。"

#. type: Plain text
#: build/C/man2/fanotify_init.2:58
msgid ""
"In the current implementation, the number of fanotify groups per user is "
"limited to 128.  This limit cannot be overridden."
msgstr ""
"現在の実装では、 ユーザーあたりの fanotify グループ数は 128 に制限されてい"
"る。 この制限は上書きすることができない。"

#. type: Plain text
#: build/C/man2/fanotify_init.2:67
msgid ""
"Calling B<fanotify_init>()  requires the B<CAP_SYS_ADMIN> capability.  This "
"constraint might be relaxed in future versions of the API.  Therefore, "
"certain additional capability checks have been implemented as indicated "
"below."
msgstr ""
"B<fanotify_init>() を呼び出すには B<CAP_SYS_ADMIN> ケーパビリティーが必要であ"
"る。 この制約は将来のバージョンの API で緩和される可能性がある。 そのため、 "
"以下に示すケーパビリティーチェックのいくつかが実装されている。"

#. type: Plain text
#: build/C/man2/fanotify_init.2:73
msgid ""
"The I<flags> argument contains a multi-bit field defining the notification "
"class of the listening application and further single bit fields specifying "
"the behavior of the file descriptor."
msgstr ""
"I<flags> 引数は、 イベントを待つアプリケーションの通知クラスを定義する複数"
"ビットのフィールドである。 これに加えて、 このファイルディスクリプターの動作"
"を示す 1 ビットのフィールドがある。"

#. type: Plain text
#: build/C/man2/fanotify_init.2:77
msgid ""
"If multiple listeners for permission events exist, the notification class is "
"used to establish the sequence in which the listeners receive the events."
msgstr ""
"アクセス許可イベントを監視しているプログラムが複数いる場合、 通知クラスを使っ"
"て監視するプログラムのイベント受信順序が管理される。"

#. type: Plain text
#: build/C/man2/fanotify_init.2:80
msgid ""
"Only one of the following notification classes may be specified in I<flags>:"
msgstr "以下の通知クラスのいずれか一つだけを I<flags> に指定できる。"

#. type: TP
#: build/C/man2/fanotify_init.2:80
#, no-wrap
msgid "B<FAN_CLASS_PRE_CONTENT>"
msgstr "B<FAN_CLASS_PRE_CONTENT>"

#. type: Plain text
#: build/C/man2/fanotify_init.2:88
msgid ""
"This value allows the receipt of events notifying that a file has been "
"accessed and events for permission decisions if a file may be accessed.  It "
"is intended for event listeners that need to access files before they "
"contain their final data.  This notification class might be used by "
"hierarchical storage managers, for example."
msgstr ""
"この値は、 ファイルがアクセスされたことを通知するイベントと、 ファイルへのア"
"クセスするかの許可の判断を求めるイベントを受信することを示す。 これはイベント"
"受信者がファイルが最終的なデータを格納する前にそのファイルにアクセスする必要"
"がある場合に使用される。 この通知クラスは例えば階層型ストレージ管理などで使用"
"される。"

#. type: TP
#: build/C/man2/fanotify_init.2:88
#, no-wrap
msgid "B<FAN_CLASS_CONTENT>"
msgstr "B<FAN_CLASS_CONTENT>"

#. type: Plain text
#: build/C/man2/fanotify_init.2:96
msgid ""
"This value allows the receipt of events notifying that a file has been "
"accessed and events for permission decisions if a file may be accessed.  It "
"is intended for event listeners that need to access files when they already "
"contain their final content.  This notification class might be used by "
"malware detection programs, for example."
msgstr ""
"この値は、 ファイルがアクセスされたことを通知するイベントと、 ファイルへのア"
"クセスするかの許可の判断を求めるイベントを受信することを示す。 これはイベント"
"受信者がファイルに最終的なデータが格納された際にそのファイルにアクセスする必"
"要がある場合に使用される。 この通知クラスは例えばウイルス検知プログラムなどで"
"使用される。"

#. type: TP
#: build/C/man2/fanotify_init.2:96
#, no-wrap
msgid "B<FAN_CLASS_NOTIF>"
msgstr "B<FAN_CLASS_NOTIF>"

#. type: Plain text
#: build/C/man2/fanotify_init.2:103
msgid ""
"This is the default value.  It does not need to be specified.  This value "
"only allows the receipt of events notifying that a file has been accessed.  "
"Permission decisions before the file is accessed are not possible."
msgstr ""
"これはデフォルト値である。 この値を指定する必要はない。 この値は、 ファイルが"
"アクセスされたことを通知するイベントの受信だけを行うことを意味する。 ファイル"
"がアクセスする前にアクセス許可の判定を行うことはできない。"

#. type: Plain text
#: build/C/man2/fanotify_init.2:111
msgid ""
"Listeners with different notification classes will receive events in the "
"order B<FAN_CLASS_PRE_CONTENT>, B<FAN_CLASS_CONTENT>, B<FAN_CLASS_NOTIF>.  "
"The order of notification for listeners in the same notification class is "
"undefined."
msgstr ""
"異なる通知クラスの受信者は B<FAN_CLASS_PRE_CONTENT>, B<FAN_CLASS_CONTENT>, "
"B<FAN_CLASS_NOTIF> の順序でイベントを受信する。 同じ通知クラスの受信者での通"
"知順序は不定である。"

#. type: Plain text
#: build/C/man2/fanotify_init.2:114
msgid "The following bits can additionally be set in I<flags>:"
msgstr "I<flags> には以下のビットを追加でセットすることができる。"

#. type: TP
#: build/C/man2/fanotify_init.2:114
#, no-wrap
msgid "B<FAN_CLOEXEC>"
msgstr "B<FAN_CLOEXEC>"

#. type: Plain text
#: build/C/man2/fanotify_init.2:123
msgid ""
"Set the close-on-exec flag (B<FD_CLOEXEC>)  on the new file descriptor.  See "
"the description of the B<O_CLOEXEC> flag in B<open>(2)."
msgstr ""
"close-on-exec フラグ (B<FD_CLOEXEC>) を新しいファイルディスクリプターにセット"
"する。 B<open>(2) の B<O_CLOEXEC> フラグの説明を参照。"

#. type: TP
#: build/C/man2/fanotify_init.2:123
#, no-wrap
msgid "B<FAN_NONBLOCK>"
msgstr "B<FAN_NONBLOCK>"

#. type: Plain text
#: build/C/man2/fanotify_init.2:133
msgid ""
"Enable the nonblocking flag (B<O_NONBLOCK>)  for the file descriptor.  "
"Reading from the file descriptor will not block.  Instead, if no data is "
"available, B<read>(2)  fails with the error B<EAGAIN>."
msgstr ""
"ノンブロッキングフラグ (B<O_NONBLOCK>) をそのファイルディスクリプターで有効に"
"する。 このファイルディスクリプターからの読み出しは停止しない。 その代わり、 "
"読みだし可能なデータが何もない場合、 B<read>(2) はエラー B<EAGAIN> で失敗す"
"る。"

#. type: TP
#: build/C/man2/fanotify_init.2:133
#, no-wrap
msgid "B<FAN_UNLIMITED_QUEUE>"
msgstr "B<FAN_UNLIMITED_QUEUE>"

#. type: Plain text
#: build/C/man2/fanotify_init.2:139
msgid ""
"Remove the limit of 16384 events for the event queue.  Use of this flag "
"requires the B<CAP_SYS_ADMIN> capability."
msgstr ""
"そのイベントキューの 16384 イベントの上限を削除する。 このフラグを使用するに"
"は B<CAP_SYS_ADMIN> ケーパビリティーが必要である。"

#. type: TP
#: build/C/man2/fanotify_init.2:139
#, no-wrap
msgid "B<FAN_UNLIMITED_MARKS>"
msgstr "B<FAN_UNLIMITED_MARKS>"

#. type: Plain text
#: build/C/man2/fanotify_init.2:145
msgid ""
"Remove the limit of 8192 marks.  Use of this flag requires the "
"B<CAP_SYS_ADMIN> capability."
msgstr ""
"8192 マークの上限を削除する。 このフラグを使用するには B<CAP_SYS_ADMIN> ケー"
"パビリティーが必要である。"

#. type: TP
#: build/C/man2/fanotify_init.2:145
#, no-wrap
msgid "B<FAN_REPORT_TID> (since Linux 4.20)"
msgstr "B<FAN_REPORT_TID> (Linux 4.20 以降)"

#.  commit d0a6a87e40da49cfc7954c491d3065a25a641b29
#. type: Plain text
#: build/C/man2/fanotify_init.2:157
msgid ""
"Report thread ID (TID) instead of process ID (PID)  in the I<pid> field of "
"the I<struct fanotify_event_metadata> supplied to B<read>(2)  (see "
"B<fanotify>(7))."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_init.2:157
#, no-wrap
msgid "B<FAN_REPORT_FID> (since Linux 5.1)"
msgstr "B<FAN_REPORT_FID> (Linux 5.1 以降)"

#.  commit a8b13aa20afb69161b5123b4f1acc7ea0a03d360
#. type: Plain text
#: build/C/man2/fanotify_init.2:195
msgid ""
"This value allows the receipt of events which contain additional information "
"about the underlying filesystem object correlated to an event.  An "
"additional record of type B<FAN_EVENT_INFO_TYPE_FID> encapsulates the "
"information about the object and is included alongside the generic event "
"metadata structure.  The file descriptor that is used to represent the "
"object correlated to an event is instead substituted with a file handle.  It "
"is intended for applications that may find the use of a file handle to "
"identify an object more suitable than a file descriptor.  Additionally, it "
"may be used for applications monitoring a directory or a filesystem that are "
"interested in the directory entry modification events B<FAN_CREATE>, "
"B<FAN_DELETE>, and B<FAN_MOVE>, or in events such as B<FAN_ATTRIB>, "
"B<FAN_DELETE_SELF>, and B<FAN_MOVE_SELF>.  All the events above require an "
"fanotify group that identifies filesystem objects by file handles.  Note "
"that for the directory entry modification events the reported file handle "
"identifies the modified directory and not the created/deleted/moved child "
"object.  The use of B<FAN_CLASS_CONTENT> or B<FAN_CLASS_PRE_CONTENT> is not "
"permitted with this flag and will result in the error B<EINVAL>.  See "
"B<fanotify>(7)  for additional details."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_init.2:195
#, no-wrap
msgid "B<FAN_REPORT_DIR_FID> (since Linux 5.9)"
msgstr "B<FAN_REPORT_DIR_FID> (Linux 5.9 以降)"

#. type: Plain text
#: build/C/man2/fanotify_init.2:227
msgid ""
"Events for fanotify groups initialized with this flag will contain (see "
"exceptions below) additional information about a directory object correlated "
"to an event.  An additional record of type B<FAN_EVENT_INFO_TYPE_DFID> "
"encapsulates the information about the directory object and is included "
"alongside the generic event metadata structure.  For events that occur on a "
"non-directory object, the additional structure includes a file handle that "
"identifies the parent directory filesystem object.  Note that there is no "
"guarantee that the directory filesystem object will be found at the location "
"described by the file handle information at the time the event is received.  "
"When combined with the flag B<FAN_REPORT_FID>, two records may be reported "
"with events that occur on a non-directory object, one to identify the non-"
"directory object itself and one to identify the parent directory object.  "
"Note that in some cases, a filesystem object does not have a parent, for "
"example, when an event occurs on an unlinked but open file.  In that case, "
"with the B<FAN_REPORT_FID> flag, the event will be reported with only one "
"record to identify the non-directory object itself, because there is no "
"directory associated with the event.  Without the B<FAN_REPORT_FID> flag, no "
"event will be reported.  See B<fanotify>(7)  for additional details."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_init.2:227
#, no-wrap
msgid "B<FAN_REPORT_NAME> (since Linux 5.9)"
msgstr "B<FAN_REPORT_NAME> (Linux 5.9 以降)"

#. type: Plain text
#: build/C/man2/fanotify_init.2:277
msgid ""
"Events for fanotify groups initialized with this flag will contain "
"additional information about the name of the directory entry correlated to "
"an event.  This flag must be provided in conjunction with the flag "
"B<FAN_REPORT_DIR_FID>.  Providing this flag value without "
"B<FAN_REPORT_DIR_FID> will result in the error B<EINVAL>.  This flag may be "
"combined with the flag B<FAN_REPORT_FID>.  An additional record of type "
"B<FAN_EVENT_INFO_TYPE_DFID_NAME>, which encapsulates the information about "
"the directory entry, is included alongside the generic event metadata "
"structure and substitutes the additional information record of type "
"B<FAN_EVENT_INFO_TYPE_DFID>.  The additional record includes a file handle "
"that identifies a directory filesystem object followed by a name that "
"identifies an entry in that directory.  For the directory entry modification "
"events B<FAN_CREATE>, B<FAN_DELETE>, and B<FAN_MOVE>, the reported name is "
"that of the created/deleted/moved directory entry.  For other events that "
"occur on a directory object, the reported file handle is that of the "
"directory object itself and the reported name is '.'.  For other events that "
"occur on a non-directory object, the reported file handle is that of the "
"parent directory object and the reported name is the name of a directory "
"entry where the object was located at the time of the event.  The rationale "
"behind this logic is that the reported directory file handle can be passed "
"to B<open_by_handle_at>(2)  to get an open directory file descriptor and "
"that file descriptor along with the reported name can be used to call "
"B<fstatat>(2).  The same rule that applies to record type "
"B<FAN_EVENT_INFO_TYPE_DFID> also applies to record type "
"B<FAN_EVENT_INFO_TYPE_DFID_NAME>: if a non-directory object has no parent, "
"either the event will not be reported or it will be reported without the "
"directory entry information.  Note that there is no guarantee that the "
"filesystem object will be found at the location described by the directory "
"entry information at the time the event is received.  See B<fanotify>(7)  "
"for additional details."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_init.2:277
#, no-wrap
msgid "B<FAN_REPORT_DFID_NAME>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:281
msgid "This is a synonym for (B<FAN_REPORT_DIR_FID>|B<FAN_REPORT_NAME>)."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:294
msgid ""
"The I<event_f_flags> argument defines the file status flags that will be set "
"on the open file descriptions that are created for fanotify events.  For "
"details of these flags, see the description of the I<flags> values in "
"B<open>(2).  I<event_f_flags> includes a multi-bit field for the access "
"mode.  This field can take the following values:"
msgstr ""
"I<event_f_flags> 引数は fanotify イベントが作成されるオープンファイル記述に"
"セットされるファイル状態フラグを定義する。 これらのフラグの詳細については "
"B<open>(2) の I<flags> 値の説明を参照のこと。 I<event_f_flags> にはアクセス"
"モードのビットを複数入れることができる。 このフィールドには以下の値も指定する"
"ことができる。"

#. type: TP
#: build/C/man2/fanotify_init.2:294
#, no-wrap
msgid "B<O_RDONLY>"
msgstr "B<O_RDONLY>"

#. type: Plain text
#: build/C/man2/fanotify_init.2:297
msgid "This value allows only read access."
msgstr "読み出しアクセスのみを許可する。"

#. type: TP
#: build/C/man2/fanotify_init.2:297
#, no-wrap
msgid "B<O_WRONLY>"
msgstr "B<O_WRONLY>"

#. type: Plain text
#: build/C/man2/fanotify_init.2:300
msgid "This value allows only write access."
msgstr "書き込みアクセスのみを許可する。"

#. type: TP
#: build/C/man2/fanotify_init.2:300
#, no-wrap
msgid "B<O_RDWR>"
msgstr "B<O_RDWR>"

#. type: Plain text
#: build/C/man2/fanotify_init.2:303
msgid "This value allows read and write access."
msgstr "読み出しと書き込みの両方を許可する。"

#. type: Plain text
#: build/C/man2/fanotify_init.2:307
msgid ""
"Additional bits can be set in I<event_f_flags>.  The most useful values are:"
msgstr ""
"他のビットも I<event_f_flags> もセットすることができる。 役立つであろう値は以"
"下である。"

#. type: TP
#: build/C/man2/fanotify_init.2:307
#, no-wrap
msgid "B<O_LARGEFILE>"
msgstr "B<O_LARGEFILE>"

#. type: Plain text
#: build/C/man2/fanotify_init.2:314
msgid ""
"Enable support for files exceeding 2\\ GB.  Failing to set this flag will "
"result in an B<EOVERFLOW> error when trying to open a large file which is "
"monitored by an fanotify group on a 32-bit system."
msgstr "2\\ GB を超えるファイルのサポートを有効にする。 このフラグのセットに失敗すると、 32 ビットシステムで fanotify グループが監視するラージファイルをオープンしようとした際に B<EOVERFLOW> エラーとなる。"

#. type: TP
#: build/C/man2/fanotify_init.2:314
#, no-wrap
msgid "B<O_CLOEXEC> (since Linux 3.18)"
msgstr "B<O_CLOEXEC> (Linux 3.18 以降)"

#.  commit 0b37e097a648aa71d4db1ad108001e95b69a2da4
#. type: Plain text
#: build/C/man2/fanotify_init.2:323
msgid ""
"Enable the close-on-exec flag for the file descriptor.  See the description "
"of the B<O_CLOEXEC> flag in B<open>(2)  for reasons why this may be useful."
msgstr ""
"このファイルディスクリプターで close-on-exec フラグを有効にする。 このフラグ"
"が役立つ理由については B<open>(2) の B<O_CLOEXEC> フラグの説明を参照。"

#. type: Plain text
#: build/C/man2/fanotify_init.2:336
msgid ""
"The following are also allowable: B<O_APPEND>, B<O_DSYNC>, B<O_NOATIME>, "
"B<O_NONBLOCK>, and B<O_SYNC>.  Specifying any other flag in I<event_f_flags> "
"yields the error B<EINVAL> (but see BUGS)."
msgstr ""
"B<O_APPEND>, B<O_DSYNC>, B<O_NOATIME>, B<O_NONBLOCK>, B<O_SYNC> も指定するこ"
"とができる。 I<event_f_flags> にこれ以外のフラグを指定すると、 エラー "
"B<EINVAL> が起こる (ただし、バグを参照)。"

#. type: SH
#: build/C/man2/fanotify_init.2:336 build/C/man2/fanotify_mark.2:361
#: build/C/man2/inotify_add_watch.2:77 build/C/man2/inotify_init.2:76
#: build/C/man2/inotify_rm_watch.2:48
#, no-wrap
msgid "RETURN VALUE"
msgstr "返り値"

#. type: Plain text
#: build/C/man2/fanotify_init.2:343
msgid ""
"On success, B<fanotify_init>()  returns a new file descriptor.  On error, -1 "
"is returned, and I<errno> is set to indicate the error."
msgstr ""
"成功すると B<fanotify_init>() は新しいファイルディスクリプターを返す。 エラー"
"の場合、 -1 を返し、 I<errno> にエラーを示す値を設定する。"

#.  commit 23c9deeb3285d34fd243abb3d6b9f07db60c3cf4
#. type: Plain text
#: build/C/man2/fanotify_init.2:355
#, fuzzy
#| msgid ""
#| "An invalid value was passed in I<flags> or I<event_f_flags>.  "
#| "B<FAN_ALL_INIT_FLAGS> defines all allowable bits for I<flags>."
msgid ""
"An invalid value was passed in I<flags> or I<event_f_flags>.  "
"B<FAN_ALL_INIT_FLAGS> (deprecated since Linux kernel version 4.20)  defines "
"all allowable bits for I<flags>."
msgstr ""
"I<flags> か I<event_f_flags> に無効な値が渡された。 B<FAN_ALL_INIT_FLAGS> で "
"I<flags> に指定できる全ビットが定義されている。"

#. type: Plain text
#: build/C/man2/fanotify_init.2:358
msgid "The number of fanotify groups for this user exceeds 128."
msgstr "このユーザーの fanotify グループ数が 128 を超過した。"

#. type: Plain text
#: build/C/man2/fanotify_init.2:361 build/C/man2/inotify_init.2:93
#, fuzzy
#| msgid ""
#| "The system limit on the total number of file descriptors has been reached."
msgid ""
"The per-process limit on the number of open file descriptors has been "
"reached."
msgstr "inotify ファイルディスクリプターの総数がシステムの上限に達していた。"

#. type: TP
#: build/C/man2/fanotify_init.2:361 build/C/man2/fanotify_mark.2:410
#: build/C/man2/inotify_add_watch.2:124 build/C/man2/inotify_init.2:96
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
#: build/C/man2/fanotify_init.2:364
msgid "The allocation of memory for the notification group failed."
msgstr "通知グループへのメモリー割り当てが失敗した。"

#. type: TP
#: build/C/man2/fanotify_init.2:364 build/C/man2/fanotify_mark.2:419
#, no-wrap
msgid "B<ENOSYS>"
msgstr "B<ENOSYS>"

#. type: Plain text
#: build/C/man2/fanotify_init.2:370
msgid ""
"This kernel does not implement B<fanotify_init>().  The fanotify API is "
"available only if the kernel was configured with B<CONFIG_FANOTIFY>."
msgstr ""
"このカーネルは B<fanotify_init>() を実装していない。 fanotify API が利用でき"
"るのは、 カーネルが B<CONFIG_FANOTIFY> を有効にして作成されている場合だけであ"
"る。"

#. type: TP
#: build/C/man2/fanotify_init.2:370
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#. type: Plain text
#: build/C/man2/fanotify_init.2:375
msgid ""
"The operation is not permitted because the caller lacks the B<CAP_SYS_ADMIN> "
"capability."
msgstr ""
"呼び出し元が B<CAP_SYS_ADMIN> ケーパビリティーを持っていないので、操作が許可"
"されない。"

#. type: Plain text
#: build/C/man2/fanotify_init.2:379
msgid ""
"B<fanotify_init>()  was introduced in version 2.6.36 of the Linux kernel and "
"enabled in version 2.6.37."
msgstr ""
"B<fanotify_init>() は Linux カーネルのバージョン 2.6.36 で導入され、 バージョ"
"ン 2.6.37 で有効になった。"

#. type: Plain text
#: build/C/man2/fanotify_init.2:381 build/C/man2/fanotify_mark.2:460
#: build/C/man2/inotify_add_watch.2:143 build/C/man2/inotify_rm_watch.2:71
msgid "This system call is Linux-specific."
msgstr "このシステムコールは Linux 独自である。"

#. type: Plain text
#: build/C/man2/fanotify_init.2:383
#, fuzzy
#| msgid "The following bug was present in Linux kernels before version 3.14:"
msgid "The following bug was present in Linux kernels before version 3.18:"
msgstr "バージョン 3.14 より前の Linux カーネルには以下のバグが存在する。"

#.  Fixed by commit 0b37e097a648aa71d4db1ad108001e95b69a2da4
#. type: Plain text
#: build/C/man2/fanotify_init.2:389
msgid "The B<O_CLOEXEC> is ignored when passed in I<event_f_flags>."
msgstr "B<O_CLOEXEC> が I<event_f_flags> に指定された場合、 無視される。"

#. type: Plain text
#: build/C/man2/fanotify_init.2:391
msgid "The following bug was present in Linux kernels before version 3.14:"
msgstr "バージョン 3.14 より前の Linux カーネルには以下のバグが存在する。"

#.  Fixed by commit 48149e9d3a7e924010a0daab30a6197b7d7b6580
#. type: Plain text
#: build/C/man2/fanotify_init.2:401
msgid ""
"The I<event_f_flags> argument is not checked for invalid flags.  Flags that "
"are intended only for internal use, such as B<FMODE_EXEC>, can be set, and "
"will consequently be set for the file descriptors returned when reading from "
"the fanotify file descriptor."
msgstr ""
"I<event_f_flags> 引数に無効なフラグがないかのチェックが行われない。 "
"B<FMODE_EXEC> などの内部での使用のみが意図されたフラグを指定することができ、 "
"その場合 fanotify ファイルディスクリプターからの読み出し時に返されるファイル"
"ディスクリプターにそのフラグがセットされる。"

#. type: Plain text
#: build/C/man2/fanotify_init.2:404
msgid "B<fanotify_mark>(2), B<fanotify>(7)"
msgstr "B<fanotify_mark>(2), B<fanotify>(7)"

#. type: TH
#: build/C/man2/fanotify_mark.2:24
#, no-wrap
msgid "FANOTIFY_MARK"
msgstr "FANOTIFY_MARK"

#. type: Plain text
#: build/C/man2/fanotify_mark.2:28
msgid ""
"fanotify_mark - add, remove, or modify an fanotify mark on a filesystem "
"object"
msgstr ""
"fanotify_mark - ファイルシステムオブジェクトへの fanotify マークの追加、削"
"除、変更"

#. type: Plain text
#: build/C/man2/fanotify_mark.2:31
#, no-wrap
msgid "B<#include E<lt>sys/fanotify.hE<gt>>\n"
msgstr "B<#include E<lt>sys/fanotify.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/fanotify_mark.2:35
#, no-wrap
msgid ""
"B<int fanotify_mark(int >I<fanotify_fd>B<, unsigned int >I<flags>B<,>\n"
"B<                  uint64_t >I<mask>B<, int >I<dirfd>B<, const char *>I<pathname>B<);>\n"
msgstr ""
"B<int fanotify_mark(int >I<fanotify_fd>B<, unsigned int >I<flags>B<,>\n"
"B<                  uint64_t >I<mask>B<, int >I<dirfd>B<, const char *>I<pathname>B<);>\n"

#. type: Plain text
#: build/C/man2/fanotify_mark.2:44
msgid ""
"B<fanotify_mark>()  adds, removes, or modifies an fanotify mark on a "
"filesystem object.  The caller must have read permission on the filesystem "
"object that is to be marked."
msgstr "B<fanotify_mark>() はファイルシステムオブジェクトに対する fanotify マークの追加、削除、変更を行う。 呼び出し元はマークを付けるファイルシステムオブジェクトに対する読み出し許可を持っていなければならない。"

#. type: Plain text
#: build/C/man2/fanotify_mark.2:49
msgid ""
"The I<fanotify_fd> argument is a file descriptor returned by "
"B<fanotify_init>(2)."
msgstr ""
"I<fanotify_fd> 引数は B<fanotify_init>(2) で返されたファイルディスクリプ"
"ターである。"

#. type: Plain text
#: build/C/man2/fanotify_mark.2:53
msgid ""
"I<flags> is a bit mask describing the modification to perform.  It must "
"include exactly one of the following values:"
msgstr ""
"I<flags> は実行する操作内容を示すビットマスクである。 以下の値のいずれか一つ"
"だけを指定しなければならない。"

#. type: TP
#: build/C/man2/fanotify_mark.2:53
#, no-wrap
msgid "B<FAN_MARK_ADD>"
msgstr "B<FAN_MARK_ADD>"

#. type: Plain text
#: build/C/man2/fanotify_mark.2:62
msgid ""
"The events in I<mask> will be added to the mark mask (or to the ignore "
"mask).  I<mask> must be nonempty or the error B<EINVAL> will occur."
msgstr ""
"I<mask> のイベントを mark マスク (もしくは ignore マスク) に追加する。 "
"I<mask> は空であってはいけない。 空の場合はエラー B<EINVAL> が発生する。"

#. type: TP
#: build/C/man2/fanotify_mark.2:62
#, no-wrap
msgid "B<FAN_MARK_REMOVE>"
msgstr "B<FAN_MARK_REMOVE>"

#. type: Plain text
#: build/C/man2/fanotify_mark.2:71
msgid ""
"The events in argument I<mask> will be removed from the mark mask (or from "
"the ignore mask).  I<mask> must be nonempty or the error B<EINVAL> will "
"occur."
msgstr ""
"引数 I<mask> のイベントを mark マスク (もしくは ignore マスク) から削除す"
"る。 I<mask> は空であってはいけない。 空の場合はエラー B<EINVAL>が発生する。"

#. type: TP
#: build/C/man2/fanotify_mark.2:71
#, no-wrap
msgid "B<FAN_MARK_FLUSH>"
msgstr "B<FAN_MARK_FLUSH>"

#. type: Plain text
#: build/C/man2/fanotify_mark.2:94
#, fuzzy
#| msgid ""
#| "Remove either all mount or all non-mount marks from the fanotify group.  "
#| "If I<flags> contains B<FAN_MARK_MOUNT>, all marks for mounts are removed "
#| "from the group.  Otherwise, all marks for directories and files are "
#| "removed.  No flag other than B<FAN_MARK_MOUNT> can be used in conjunction "
#| "with B<FAN_MARK_FLUSH>.  I<mask> is ignored."
msgid ""
"Remove either all marks for filesystems, all marks for mounts, or all marks "
"for directories and files from the fanotify group.  If I<flags> contains "
"B<FAN_MARK_MOUNT>, all marks for mounts are removed from the group.  If "
"I<flags> contains B<FAN_MARK_FILESYSTEM>, all marks for filesystems are "
"removed from the group.  Otherwise, all marks for directories and files are "
"removed.  No flag other than and at most one of the flags B<FAN_MARK_MOUNT> "
"or B<FAN_MARK_FILESYSTEM> can be used in conjunction with "
"B<FAN_MARK_FLUSH>.  I<mask> is ignored."
msgstr ""
"fanotify グループから全てのマウント mark か全てのマウント以外の mark を削除す"
"る。 I<flag> に B<FAN_MARK_MOUNT> が含まれる場合、 マウントに対する全ての "
"mark がそのグループから削除される。 含まれない場合は、 ディレクトリとファイル"
"に対する全ての mark が削除される。 B<FAN_MARK_MOUNT> 以外のフラグを "
"B<FAN_MARK_FLUSH> と組み合わせて使うことはできない。 I<mask> は無視される。"

#. type: Plain text
#: build/C/man2/fanotify_mark.2:98
msgid ""
"If none of the values above is specified, or more than one is specified, the "
"call fails with the error B<EINVAL>."
msgstr ""
"上記のどの値も指定されなかった場合、 または 2 つ以上の値が指定された場合、 呼"
"び出しはエラー B<EINVAL> で失敗する。"

#. type: Plain text
#: build/C/man2/fanotify_mark.2:102
msgid ""
"In addition, zero or more of the following values may be ORed into I<flags>:"
msgstr ""
"これに加えて、 I<flags> に以下の値を 0 個以上ビット単位の論理和 (OR) で指定で"
"きる。"

#. type: TP
#: build/C/man2/fanotify_mark.2:102
#, no-wrap
msgid "B<FAN_MARK_DONT_FOLLOW>"
msgstr "B<FAN_MARK_DONT_FOLLOW>"

#. type: Plain text
#: build/C/man2/fanotify_mark.2:113
msgid ""
"If I<pathname> is a symbolic link, mark the link itself, rather than the "
"file to which it refers.  (By default, B<fanotify_mark>()  dereferences "
"I<pathname> if it is a symbolic link.)"
msgstr ""
"I<pathname> がシンボリックリンクの場合、 リンクが参照するファイルではなく、 "
"リンク自身にマークを付ける (デフォルトでは B<fanotify_mark>() は I<pathname> "
"がシンボリックリンクの場合シンボリックリンクの展開を行う)。"

#. type: TP
#: build/C/man2/fanotify_mark.2:113
#, no-wrap
msgid "B<FAN_MARK_ONLYDIR>"
msgstr "B<FAN_MARK_ONLYDIR>"

#. type: Plain text
#: build/C/man2/fanotify_mark.2:118
msgid ""
"If the filesystem object to be marked is not a directory, the error "
"B<ENOTDIR> shall be raised."
msgstr ""
"マークが付けられたファイルシステムオブジェクトがディレクトリでない場合、 エ"
"ラー B<ENOTDIR> が発生する。"

#. type: TP
#: build/C/man2/fanotify_mark.2:118
#, no-wrap
msgid "B<FAN_MARK_MOUNT>"
msgstr "B<FAN_MARK_MOUNT>"

#. type: Plain text
#: build/C/man2/fanotify_mark.2:145
#, fuzzy
#| msgid ""
#| "Mark the mount point specified by I<pathname>.  If I<pathname> is not "
#| "itself a mount point, the mount point containing I<pathname> will be "
#| "marked.  All directories, subdirectories, and the contained files of the "
#| "mount point will be monitored."
msgid ""
"Mark the mount point specified by I<pathname>.  If I<pathname> is not itself "
"a mount point, the mount point containing I<pathname> will be marked.  All "
"directories, subdirectories, and the contained files of the mount point will "
"be monitored.  The events which require that filesystem objects are "
"identified by file handles, such as B<FAN_CREATE>, B<FAN_ATTRIB>, "
"B<FAN_MOVE>, and B<FAN_DELETE_SELF>, cannot be provided as a I<mask> when "
"I<flags> contains B<FAN_MARK_MOUNT>.  Attempting to do so will result in the "
"error B<EINVAL> being returned."
msgstr ""
"I<pathname> で指定されたマウントポイントにマークを付ける。 I<pathname> がマウ"
"ントポイント自身ではない場合、 I<pathname> を含むマウントポイントがマークされ"
"る。 マウントポイントに含まれる全てのディレクトリ、 サブディレクトリ、 その中"
"のファイルが監視される。"

#. type: TP
#: build/C/man2/fanotify_mark.2:145
#, no-wrap
msgid "B<FAN_MARK_FILESYSTEM> (since Linux 4.20)"
msgstr "B<FAN_MARK_FILESYSTEM> (Linux 4.20 以降)"

#.  commit d54f4fba889b205e9cd8239182ca5d27d0ac3bc2
#. type: Plain text
#: build/C/man2/fanotify_mark.2:155
#, fuzzy
#| msgid ""
#| "Mark the mount point specified by I<pathname>.  If I<pathname> is not "
#| "itself a mount point, the mount point containing I<pathname> will be "
#| "marked.  All directories, subdirectories, and the contained files of the "
#| "mount point will be monitored."
msgid ""
"Mark the filesystem specified by I<pathname>.  The filesystem containing "
"I<pathname> will be marked.  All the contained files and directories of the "
"filesystem from any mount point will be monitored."
msgstr ""
"I<pathname> で指定されたマウントポイントにマークを付ける。 I<pathname> がマウ"
"ントポイント自身ではない場合、 I<pathname> を含むマウントポイントがマークされ"
"る。 マウントポイントに含まれる全てのディレクトリ、 サブディレクトリ、 その中"
"のファイルが監視される。"

#. type: TP
#: build/C/man2/fanotify_mark.2:155
#, no-wrap
msgid "B<FAN_MARK_IGNORED_MASK>"
msgstr "B<FAN_MARK_IGNORED_MASK>"

#. type: Plain text
#: build/C/man2/fanotify_mark.2:160
msgid ""
"The events in I<mask> shall be added to or removed from the ignore mask."
msgstr "I<mask> のイベントの ignore マスクへの追加、もしくは削除を行う。"

#. type: TP
#: build/C/man2/fanotify_mark.2:160
#, no-wrap
msgid "B<FAN_MARK_IGNORED_SURV_MODIFY>"
msgstr "B<FAN_MARK_IGNORED_SURV_MODIFY>"

#. type: Plain text
#: build/C/man2/fanotify_mark.2:166
msgid ""
"The ignore mask shall survive modify events.  If this flag is not set, the "
"ignore mask is cleared when a modify event occurs for the ignored file or "
"directory."
msgstr ""
"ignore マスクは変更イベントが発生しても残り続ける。 このフラグがセットされて"
"いない場合、 無視するファイルやディレクトリに対して変更イベントが発生した際"
"に ignore マスクはクリアされる。"

#. type: Plain text
#: build/C/man2/fanotify_mark.2:170
msgid ""
"I<mask> defines which events shall be listened for (or which shall be "
"ignored).  It is a bit mask composed of the following values:"
msgstr ""
"I<mask> はどのイベントに対して通知を受けるか (もしくはどのイベントを無視する"
"か) を定義する。  以下の値から構成されるビットマスクである。"

#. type: Plain text
#: build/C/man2/fanotify_mark.2:173
msgid ""
"Create an event when a file or directory (but see BUGS) is accessed (read)."
msgstr ""
"ファイルやディレクトリへのアクセス (読み出し) があった際にイベントを作成する "
"(「バグ」も参照)。"

#. type: Plain text
#: build/C/man2/fanotify_mark.2:176
msgid "Create an event when a file is modified (write)."
msgstr "ファイルが変更された (書き込み) 際にイベントを作成する。"

#. type: Plain text
#: build/C/man2/fanotify_mark.2:179
msgid "Create an event when a writable file is closed."
msgstr "書き込み可能ファイルがクローズされた際にイベントを作成する。"

#. type: Plain text
#: build/C/man2/fanotify_mark.2:182
msgid "Create an event when a read-only file or directory is closed."
msgstr ""
"読み出し専用のファイルやディレクトリがクローズされた際にイベントを作成する。"

#. type: Plain text
#: build/C/man2/fanotify_mark.2:185
msgid "Create an event when a file or directory is opened."
msgstr "ファイルやディレクトリがオープンされた際にイベントを作成する。"

#. type: TP
#: build/C/man2/fanotify_mark.2:185
#, no-wrap
msgid "B<FAN_OPEN_EXEC> (since Linux 5.0)"
msgstr "B<FAN_OPEN_EXEC> (Linux 5.0 以降)"

#.  commit 9b076f1c0f4869b838a1b7aa0edb5664d47ec8aa
#. type: Plain text
#: build/C/man2/fanotify_mark.2:190
msgid ""
"Create an event when a file is opened with the intent to be executed.  See "
"NOTES for additional details."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_mark.2:190
#, no-wrap
msgid "B<FAN_ATTRIB> (since Linux 5.1)"
msgstr "B<FAN_ATTRIB> (Linux 5.1 以降)"

#.  commit 235328d1fa4251c6dcb32351219bb553a58838d2
#. type: Plain text
#: build/C/man2/fanotify_mark.2:196
msgid ""
"Create an event when the metadata for a file or directory has changed.  An "
"fanotify group that identifies filesystem objects by file handles is "
"required."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_mark.2:196
#, no-wrap
msgid "B<FAN_CREATE> (since Linux 5.1)"
msgstr "B<FAN_CREATE> (Linux 5.1 以降)"

#.  commit 235328d1fa4251c6dcb32351219bb553a58838d2
#. type: Plain text
#: build/C/man2/fanotify_mark.2:203
msgid ""
"Create an event when a file or directory has been created in a marked parent "
"directory.  An fanotify group that identifies filesystem objects by file "
"handles is required."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_mark.2:203
#, no-wrap
msgid "B<FAN_DELETE> (since Linux 5.1)"
msgstr "B<FAN_DELETE> (Linux 5.1 以降)"

#.  commit 235328d1fa4251c6dcb32351219bb553a58838d2
#. type: Plain text
#: build/C/man2/fanotify_mark.2:210
msgid ""
"Create an event when a file or directory has been deleted in a marked parent "
"directory.  An fanotify group that identifies filesystem objects by file "
"handles is required."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_mark.2:210
#, no-wrap
msgid "B<FAN_DELETE_SELF> (since Linux 5.1)"
msgstr "B<FAN_DELETE_SELF> (Linux 5.1 以降)"

#.  commit 235328d1fa4251c6dcb32351219bb553a58838d2
#. type: Plain text
#: build/C/man2/fanotify_mark.2:216
msgid ""
"Create an event when a marked file or directory itself is deleted.  An "
"fanotify group that identifies filesystem objects by file handles is "
"required."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_mark.2:216
#, no-wrap
msgid "B<FAN_MOVED_FROM> (since Linux 5.1)"
msgstr "B<FAN_MOVED_FROM> (Linux 5.1 以降)"

#.  commit 235328d1fa4251c6dcb32351219bb553a58838d2
#. type: Plain text
#: build/C/man2/fanotify_mark.2:223
msgid ""
"Create an event when a file or directory has been moved from a marked parent "
"directory.  An fanotify group that identifies filesystem objects by file "
"handles is required."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_mark.2:223
#, no-wrap
msgid "B<FAN_MOVED_TO> (since Linux 5.1)"
msgstr "B<FAN_MOVED_TO> (Linux 5.1 以降)"

#.  commit 235328d1fa4251c6dcb32351219bb553a58838d2
#. type: Plain text
#: build/C/man2/fanotify_mark.2:230
msgid ""
"Create an event when a file or directory has been moved to a marked parent "
"directory.  An fanotify group that identifies filesystem objects by file "
"handles is required."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_mark.2:230
#, no-wrap
msgid "B<FAN_MOVE_SELF> (since Linux 5.1)"
msgstr "B<FAN_MOVE_SELF> (Linux 5.1 以降)"

#.  commit 235328d1fa4251c6dcb32351219bb553a58838d2
#. type: Plain text
#: build/C/man2/fanotify_mark.2:236
msgid ""
"Create an event when a marked file or directory itself has been moved.  An "
"fanotify group that identifies filesystem objects by file handles is "
"required."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:244
msgid ""
"Create an event when a permission to open a file or directory is requested.  "
"An fanotify file descriptor created with B<FAN_CLASS_PRE_CONTENT> or "
"B<FAN_CLASS_CONTENT> is required."
msgstr ""
"ファイルやディレクトリをオープンするアクセス許可が要求された際にイベントを作"
"成する。 fanotify ファイルディスクリプターが B<FAN_CLASS_PRE_CONTENT> か "
"B<FAN_CLASS_CONTENT> を指定されて作成されている必要がある。"

#. type: TP
#: build/C/man2/fanotify_mark.2:244
#, fuzzy, no-wrap
#| msgid "B<IN_ONLYDIR> (since Linux 2.6.15)"
msgid "B<FAN_OPEN_EXEC_PERM> (since Linux 5.0)"
msgstr "B<IN_ONLYDIR> (Linux 2.6.15 以降)"

#.  commit 66917a3130f218dcef9eeab4fd11a71cd00cd7c9
#. type: Plain text
#: build/C/man2/fanotify_mark.2:255
#, fuzzy
#| msgid ""
#| "Create an event when a permission to open a file or directory is "
#| "requested.  An fanotify file descriptor created with "
#| "B<FAN_CLASS_PRE_CONTENT> or B<FAN_CLASS_CONTENT> is required."
msgid ""
"Create an event when a permission to open a file for execution is "
"requested.  An fanotify file descriptor created with "
"B<FAN_CLASS_PRE_CONTENT> or B<FAN_CLASS_CONTENT> is required.  See NOTES for "
"additional details."
msgstr ""
"ファイルやディレクトリをオープンするアクセス許可が要求された際にイベントを作"
"成する。 fanotify ファイルディスクリプターが B<FAN_CLASS_PRE_CONTENT> か "
"B<FAN_CLASS_CONTENT> を指定されて作成されている必要がある。"

#. type: Plain text
#: build/C/man2/fanotify_mark.2:263
msgid ""
"Create an event when a permission to read a file or directory is requested.  "
"An fanotify file descriptor created with B<FAN_CLASS_PRE_CONTENT> or "
"B<FAN_CLASS_CONTENT> is required."
msgstr ""
"ファイルやディレクトリを読み出すアクセス許可が要求された際にイベントを作成す"
"る。 fanotify ファイルディスクリプターが B<FAN_CLASS_PRE_CONTENT> か "
"B<FAN_CLASS_CONTENT> を指定されて作成されている必要がある。"

#. type: Plain text
#: build/C/man2/fanotify_mark.2:284
msgid ""
"Create events for directories\\(emfor example, when B<opendir>(3), "
"B<readdir>(3)  (but see BUGS), and B<closedir>(3)  are called.  Without this "
"flag, events are created only for files.  In the context of directory entry "
"events, such as B<FAN_CREATE>, B<FAN_DELETE>, B<FAN_MOVED_FROM>, and "
"B<FAN_MOVED_TO>, specifying the flag B<FAN_ONDIR> is required in order to "
"create events when subdirectory entries are modified (i.e., B<mkdir>(2)/ "
"B<rmdir>(2))."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_mark.2:284
#, no-wrap
msgid "B<FAN_EVENT_ON_CHILD>"
msgstr "B<FAN_EVENT_ON_CHILD>"

#. type: Plain text
#: build/C/man2/fanotify_mark.2:305
#, fuzzy
#| msgid ""
#| "Events for the immediate children of marked directories shall be "
#| "created.  The flag has no effect when marking mounts.  Note that events "
#| "are not generated for children of the subdirectories of marked "
#| "directories.  To monitor complete directory trees it is necessary to mark "
#| "the relevant mount."
msgid ""
"Events for the immediate children of marked directories shall be created.  "
"The flag has no effect when marking mounts and filesystems.  Note that "
"events are not generated for children of the subdirectories of marked "
"directories.  More specifically, the directory entry modification events "
"B<FAN_CREATE>, B<FAN_DELETE>, B<FAN_MOVED_FROM>, and B<FAN_MOVED_TO> are not "
"generated for any entry modifications performed inside subdirectories of "
"marked directories.  Note that the events B<FAN_DELETE_SELF> and "
"B<FAN_MOVE_SELF> are not generated for children of marked directories.  To "
"monitor complete directory trees it is necessary to mark the relevant mount "
"or filesystem."
msgstr ""
"マークされたディレクトリの直下のエントリーに対してイベントを作成する。 このフ"
"ラグはマウントにマークを付ける際には効果はない。 マークされたディレクトリのサ"
"ブディレクトリのエントリーに対してはイベントが作成されない点に注意すること。 "
"ディレクトリツリー全体を監視するには、 関連するマウントにマークを付ける必要が"
"ある。"

#. type: Plain text
#: build/C/man2/fanotify_mark.2:307
#, fuzzy
#| msgid "The following composed value is defined:"
msgid "The following composed values are defined:"
msgstr "以下の組み合わせ値が定義されている。"

#. type: Plain text
#: build/C/man2/fanotify_mark.2:311
msgid "A file is closed (B<FAN_CLOSE_WRITE>|B<FAN_CLOSE_NOWRITE>)."
msgstr "ファイルがクローズされた (B<FAN_CLOSE_WRITE>|B<FAN_CLOSE_NOWRITE>)。"

#. type: Plain text
#: build/C/man2/fanotify_mark.2:315
#, fuzzy
#| msgid "A file is closed (B<FAN_CLOSE_WRITE>|B<FAN_CLOSE_NOWRITE>)."
msgid "A file or directory has been moved (B<FAN_MOVED_FROM>|B<FAN_MOVED_TO>)."
msgstr "ファイルがクローズされた (B<FAN_CLOSE_WRITE>|B<FAN_CLOSE_NOWRITE>)。"

#. type: Plain text
#: build/C/man2/fanotify_mark.2:320
msgid ""
"The filesystem object to be marked is determined by the file descriptor "
"I<dirfd> and the pathname specified in I<pathname>:"
msgstr ""
"マークを付けるファイルシステムオブジェクトは、 ファイルディスクリプター "
"I<dirfd> と I<pathname> で指定されたパス名から決定される。"

#. type: Plain text
#: build/C/man2/fanotify_mark.2:326
msgid ""
"If I<pathname> is NULL, I<dirfd> defines the filesystem object to be marked."
msgstr ""
"I<pathname> が NULL の場合、 I<dirfd> でマークを付けるファイルシステムオブ"
"ジェクトが定義される。"

#. type: Plain text
#: build/C/man2/fanotify_mark.2:334
msgid ""
"If I<pathname> is NULL, and I<dirfd> takes the special value B<AT_FDCWD>, "
"the current working directory is to be marked."
msgstr ""
"I<pathname> が NULL で、 I<dirfd> が特別な値 B<AT_FDCWD> の場合、 カレント"
"ワーキングディレクトリがマークされる。"

#. type: Plain text
#: build/C/man2/fanotify_mark.2:340
msgid ""
"If I<pathname> is absolute, it defines the filesystem object to be marked, "
"and I<dirfd> is ignored."
msgstr ""
"I<pathname> が絶対パスの場合、 そのパス名によりマークを付けるファイルシステム"
"オブジェクトが定義され、 I<dirfd> は無視される。"

#. type: Plain text
#: build/C/man2/fanotify_mark.2:351
msgid ""
"If I<pathname> is relative, and I<dirfd> does not have the value "
"B<AT_FDCWD>, then the filesystem object to be marked is determined by "
"interpreting I<pathname> relative the directory referred to by I<dirfd>."
msgstr ""
"I<pathname> が相対パスで、 I<dirfd> が B<AT_FDCWD> でない場合、 マークを付け"
"るファイルシステムオブジェクトは I<dirfd> が参照するディレクトリに対する相対"
"パス I<pathname> を解釈して決定される。"

#. type: Plain text
#: build/C/man2/fanotify_mark.2:361
msgid ""
"If I<pathname> is relative, and I<dirfd> has the value B<AT_FDCWD>, then the "
"filesystem object to be marked is determined by interpreting I<pathname> "
"relative the current working directory."
msgstr ""
"I<pathname> が相対パスで、 I<dirfd> が B<AT_FDCWD> の場合、 マークを付ける"
"ファイルシステムオブジェクトはカレントワーキングディレクトリに対する相対パス "
"I<pathname> を解釈して決定される。"

#. type: Plain text
#: build/C/man2/fanotify_mark.2:368
msgid ""
"On success, B<fanotify_mark>()  returns 0.  On error, -1 is returned, and "
"I<errno> is set to indicate the error."
msgstr ""
"成功すると B<fanotify_mark>() は 0 を返す。 エラーの場合、 -1 を返し、 "
"I<errno> にエラーの原因を示す値を設定する。"

#. type: TP
#: build/C/man2/fanotify_mark.2:369 build/C/man2/inotify_add_watch.2:88
#: build/C/man2/inotify_rm_watch.2:56
#, no-wrap
msgid "B<EBADF>"
msgstr "B<EBADF>"

#. type: Plain text
#: build/C/man2/fanotify_mark.2:373
msgid "An invalid file descriptor was passed in I<fanotify_fd>."
msgstr "無効なファイルディスクリプターが I<fanotify_fd> で渡された。"

#. type: Plain text
#: build/C/man2/fanotify_mark.2:382
msgid ""
"An invalid value was passed in I<flags> or I<mask>, or I<fanotify_fd> was "
"not an fanotify file descriptor."
msgstr ""
"無効な値が I<flags> か I<mask> に指定されたか、 I<fanotify_fd> が fanotify "
"ファイルディスクリプターでなかった。"

#. type: Plain text
#: build/C/man2/fanotify_mark.2:391
#, fuzzy
#| msgid ""
#| "The fanotify file descriptor was opened with B<FAN_CLASS_NOTIF> and mask "
#| "contains a flag for permission events (B<FAN_OPEN_PERM> or "
#| "B<FAN_ACCESS_PERM>)."
msgid ""
"The fanotify file descriptor was opened with B<FAN_CLASS_NOTIF> or the "
"fanotify group identifies filesystem objects by file handles and mask "
"contains a flag for permission events (B<FAN_OPEN_PERM> or "
"B<FAN_ACCESS_PERM>)."
msgstr ""
"fanotify ファイルディスクリプターが B<FAN_CLASS_NOTIF> でオープンされたが、 "
"アクセス許可イベント (B<FAN_OPEN_PERM> か B<FAN_ACCESS_PERM>) のフラグがマス"
"クに含まれている。"

#. type: TP
#: build/C/man2/fanotify_mark.2:391
#, no-wrap
msgid "B<ENODEV>"
msgstr "B<ENODEV>"

#. type: Plain text
#: build/C/man2/fanotify_mark.2:401
msgid ""
"The filesystem object indicated by I<pathname> is not associated with a "
"filesystem that supports I<fsid> (e.g., B<tmpfs>(5)).  This error can be "
"returned only with an fanotify group that identifies filesystem objects by "
"file handles."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:410
msgid ""
"The filesystem object indicated by I<dirfd> and I<pathname> does not exist.  "
"This error also occurs when trying to remove a mark from an object which is "
"not marked."
msgstr ""
"I<dirfd> と I<pathname> で指定されたファイルシステムオブジェクトが存在しな"
"い。 このエラーはマークされていないオブジェクトからマークを削除しようとした場"
"合にも発生する。"

#. type: Plain text
#: build/C/man2/fanotify_mark.2:413
msgid "The necessary memory could not be allocated."
msgstr "必要なメモリーを割り当てできなかった。"

#. type: TP
#: build/C/man2/fanotify_mark.2:413 build/C/man2/inotify_add_watch.2:127
#, no-wrap
msgid "B<ENOSPC>"
msgstr "B<ENOSPC>"

#. type: Plain text
#: build/C/man2/fanotify_mark.2:419
msgid ""
"The number of marks exceeds the limit of 8192 and the B<FAN_UNLIMITED_MARKS> "
"flag was not specified when the fanotify file descriptor was created with "
"B<fanotify_init>(2)."
msgstr ""
"マークの数が 8192 の上限を超過し、 B<fanotify_init>(2) で fanotify ファイル"
"ディスクリプターが作成された際に B<FAN_UNLIMITED_MARKS> フラグが指定されてい"
"なかった。"

#. type: Plain text
#: build/C/man2/fanotify_mark.2:425
msgid ""
"This kernel does not implement B<fanotify_mark>().  The fanotify API is "
"available only if the kernel was configured with B<CONFIG_FANOTIFY>."
msgstr ""
"このカーネルでは B<fanotify_mark>() が実装されていない。 fanotify API が利用"
"できるのは、 カーネルで B<CONFIG_FANOTIFY> が有効になっている場合だけである。"

#. type: TP
#: build/C/man2/fanotify_mark.2:425 build/C/man2/inotify_add_watch.2:131
#, no-wrap
msgid "B<ENOTDIR>"
msgstr "B<ENOTDIR>"

#. type: Plain text
#: build/C/man2/fanotify_mark.2:435
msgid ""
"I<flags> contains B<FAN_MARK_ONLYDIR>, and I<dirfd> and I<pathname> do not "
"specify a directory."
msgstr ""
"I<flags> に B<FAN_MARK_ONLYDIR> が含まれているが、 I<dirfd> と I<pathname> が"
"ディレクトリを指定していない。"

#. type: TP
#: build/C/man2/fanotify_mark.2:435
#, no-wrap
msgid "B<EOPNOTSUPP>"
msgstr "B<EOPNOTSUPP>"

#. type: Plain text
#: build/C/man2/fanotify_mark.2:443
msgid ""
"The object indicated by I<pathname> is associated with a filesystem that "
"does not support the encoding of file handles.  This error can be returned "
"only with an fanotify group that identifies filesystem objects by file "
"handles."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_mark.2:443
#, no-wrap
msgid "B<EXDEV>"
msgstr "B<EXDEV>"

#. type: Plain text
#: build/C/man2/fanotify_mark.2:454
msgid ""
"The filesystem object indicated by I<pathname> resides within a filesystem "
"subvolume (e.g., B<btrfs>(5))  which uses a different I<fsid> than its root "
"superblock.  This error can be returned only with an fanotify group that "
"identifies filesystem objects by file handles."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:458
msgid ""
"B<fanotify_mark>()  was introduced in version 2.6.36 of the Linux kernel and "
"enabled in version 2.6.37."
msgstr ""
"B<fanotify_mark>() は Linux カーネルのバージョン 2.6.36 で導入され、 バージョ"
"ン 2.6.37 で有効になった。"

#. type: SS
#: build/C/man2/fanotify_mark.2:461
#, no-wrap
msgid "FAN_OPEN_EXEC and FAN_OPEN_EXEC_PERM"
msgstr "FAN_OPEN_EXEC と FAN_OPEN_EXEC_PERM"

#. type: Plain text
#: build/C/man2/fanotify_mark.2:478
msgid ""
"When using either B<FAN_OPEN_EXEC> or B<FAN_OPEN_EXEC_PERM> within the "
"I<mask>, events of these types will be returned only when the direct "
"execution of a program occurs.  More specifically, this means that events of "
"these types will be generated for files that are opened using B<execve>(2), "
"B<execveat>(2), or B<uselib>(2).  Events of these types will not be raised "
"in the situation where an interpreter is passed (or reads) a file for "
"interpretation."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:485
msgid ""
"Additionally, if a mark has also been placed on the Linux dynamic linker, a "
"user should also expect to receive an event for it when an ELF object has "
"been successfully opened using B<execve>(2)  or B<execveat>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:489
msgid ""
"For example, if the following ELF binary were to be invoked and a "
"B<FAN_OPEN_EXEC> mark has been placed on /:"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:493
#, no-wrap
msgid "$ /bin/echo foo\n"
msgstr "$ /bin/echo foo\n"

#. type: Plain text
#: build/C/man2/fanotify_mark.2:499
msgid ""
"The listening application in this case would receive B<FAN_OPEN_EXEC> events "
"for both the ELF binary and interpreter, respectively:"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:504
#, no-wrap
msgid ""
"/bin/echo\n"
"/lib64/ld-linux-x86-64.so.2\n"
msgstr ""
"/bin/echo\n"
"/lib64/ld-linux-x86-64.so.2\n"

#. type: Plain text
#: build/C/man2/fanotify_mark.2:508
msgid "The following bugs were present in Linux kernels before version 3.16:"
msgstr "バージョン 3.16 より前の Linux カーネルでは以下のバグが存在した。"

#.  Fixed by commit 0a8dd2db579f7a0ac7033d6b857c3d5dbaa77563
#. type: Plain text
#: build/C/man2/fanotify_mark.2:518
msgid ""
"If I<flags> contains B<FAN_MARK_FLUSH>, I<dirfd>, and I<pathname> must "
"specify a valid filesystem object, even though this object is not used."
msgstr ""
"I<flags> に B<FAN_MARK_FLUSH> が指定されている場合、 たとえそのオブジェクトが"
"使用されない場合であっても、  I<dirfd> と I<pathname> には有効なファイルシス"
"テムオブジェクトを指定しなければならない。"

#.  Fixed by commit d4c7cf6cffb1bc711a833b5e304ba5bcfe76398b
#. type: Plain text
#: build/C/man2/fanotify_mark.2:524
msgid "B<readdir>(2)  does not generate a B<FAN_ACCESS> event."
msgstr "B<readdir>(2) は B<FAN_ACCESS> イベントを生成しない。"

#.  Fixed by commit cc299a98eb13a9853675a9cbb90b30b4011e1406
#. type: Plain text
#: build/C/man2/fanotify_mark.2:532
msgid ""
"If B<fanotify_mark>()  is called with B<FAN_MARK_FLUSH>, I<flags> is not "
"checked for invalid values."
msgstr "B<fanotify_mark>() が B<FAN_MARK_FLUSH> 付きで呼び出された場合、 I<flags> の値が無効かはチェックされない。"

#. type: Plain text
#: build/C/man2/fanotify_mark.2:535
msgid "B<fanotify_init>(2), B<fanotify>(7)"
msgstr "B<fanotify_init>(2), B<fanotify>(7)"

#. type: TH
#: build/C/man7/inotify.7:26
#, no-wrap
msgid "INOTIFY"
msgstr "INOTIFY"

#. type: Plain text
#: build/C/man7/inotify.7:29
msgid "inotify - monitoring filesystem events"
msgstr "inotify - ファイルシステムイベントを監視する"

#. type: Plain text
#: build/C/man7/inotify.7:37
msgid ""
"The I<inotify> API provides a mechanism for monitoring filesystem events.  "
"Inotify can be used to monitor individual files, or to monitor directories.  "
"When a directory is monitored, inotify will return events for the directory "
"itself, and for files inside the directory."
msgstr ""
"I<inotify> API はファイルシステムイベントを監視するための機構を提供する。 "
"inotify は個々のファイルやディレクトリを監視するのに使える。 ディレクトリを監"
"視する場合、inotify はディレクトリ自身と ディレクトリ内のファイルのイベントを"
"返す。"

#. type: Plain text
#: build/C/man7/inotify.7:39
msgid "The following system calls are used with this API:"
msgstr "この API では以下のシステムコールが使用される。"

#. type: Plain text
#: build/C/man7/inotify.7:50
msgid ""
"B<inotify_init>(2)  creates an inotify instance and returns a file "
"descriptor referring to the inotify instance.  The more recent "
"B<inotify_init1>(2)  is like B<inotify_init>(2), but has a I<flags> argument "
"that provides access to some extra functionality."
msgstr ""
"B<inotify_init>(2)  は inotify インスタンスを作成し、inotify インスタンスを参"
"照する ファイルディスクリプターを返す。 より新しい B<inotify_init1>(2)  も "
"B<inotify_init>(2)  と同様だが、 こちらにはいくつかの追加の機能を利用するため"
"の I<flags> 引数がある。"

#. type: Plain text
#: build/C/man7/inotify.7:63
msgid ""
"B<inotify_add_watch>(2)  manipulates the \"watch list\" associated with an "
"inotify instance.  Each item (\"watch\") in the watch list specifies the "
"pathname of a file or directory, along with some set of events that the "
"kernel should monitor for the file referred to by that pathname.  "
"B<inotify_add_watch>(2)  either creates a new watch item, or modifies an "
"existing watch.  Each watch has a unique \"watch descriptor\", an integer "
"returned by B<inotify_add_watch>(2)  when the watch is created."
msgstr ""
"B<inotify_add_watch>(2)  は inotify インスタンスに関連づけられた「監視対象 "
"(watch) リスト」を操作する。 監視対象リストの各アイテム (\"watch\") は、 ファ"
"イルまたはディレクトリのパス名と、 そのパス名で参照されるファイルに対して "
"カーネルが監視する複数のイベントの集合を指定する。 B<inotify_add_watch>(2)  "
"は新しい監視アイテムの作成や既存の監視対象の変更ができる。 各監視対象は一意の"
"「監視対象ディスクリプター」を持つ。 これは監視対象を作成したときに "
"B<inotify_add_watch>(2)  から返される整数である。"

#. type: Plain text
#: build/C/man7/inotify.7:69
msgid ""
"When events occur for monitored files and directories, those events are made "
"available to the application as structured data that can be read from the "
"inotify file descriptor using B<read>(2)  (see below)."
msgstr ""
"監視しているファイルやディレクトリでイベントが起こると、 それらのイベントはア"
"プリケーションから inotify ファイルディスクリプターから B<read>(2) を使って構"
"造化データとして読み出すことができる (下記参照)。"

#. type: Plain text
#: build/C/man7/inotify.7:72
msgid "B<inotify_rm_watch>(2)  removes an item from an inotify watch list."
msgstr ""
"B<inotify_rm_watch>(2)  は inotify の監視対象リストからアイテムを削除する。"

#. type: Plain text
#: build/C/man7/inotify.7:79
msgid ""
"When all file descriptors referring to an inotify instance have been closed "
"(using B<close>(2)), the underlying object and its resources are freed for "
"reuse by the kernel; all associated watches are automatically freed."
msgstr ""
"inotify インスタンスを指している 全てのファイルディスクリプターが "
"(B<close>(2) を使って) クローズされた場合、 その下層にあるオブジェクトとその"
"リソースは、 カーネルで再利用するために解放される。 関連が切られた監視対象は"
"自動的に解放される。"

#. type: Plain text
#: build/C/man7/inotify.7:88
msgid ""
"With careful programming, an application can use inotify to efficiently "
"monitor and cache the state of a set of filesystem objects.  However, robust "
"applications should allow for the fact that bugs in the monitoring logic or "
"races of the kind described below may leave the cache inconsistent with the "
"filesystem state.  It is probably wise to do some consistency checking, and "
"rebuild the cache when inconsistencies are detected."
msgstr ""
"注意深くプログラミングすることで、 アプリケーションは inotify を使ってファイ"
"ルシステムオブジェクトの集合の状態を効率的に監視しキャッシュしておくことがで"
"きる。 しかしながら、ロバストなアプリケーションでは、監視ロジックのバグや以下"
"に説明があるような種類の競合条件によりファイルシステムの状態とキャッシュが一"
"致しない状態になることがあるという事実も考慮に入れておくべきである。 おそらく"
"何らかの一貫性のチェックを行い、不一致が検出された場合にはキャッシュを再構築"
"するのが懸命だろう。"

#. type: SS
#: build/C/man7/inotify.7:88
#, no-wrap
msgid "Reading events from an inotify file descriptor"
msgstr "inotify ファイルディスクリプターからのイベントの読み出し"

#. type: Plain text
#: build/C/man7/inotify.7:101
msgid ""
"To determine what events have occurred, an application B<read>(2)s from the "
"inotify file descriptor.  If no events have so far occurred, then, assuming "
"a blocking file descriptor, B<read>(2)  will block until at least one event "
"occurs (unless interrupted by a signal, in which case the call fails with "
"the error B<EINTR>; see B<signal>(7))."
msgstr ""
"どのようなイベントが起こっていたかを知るには、 アプリケーションで inotify "
"ファイルディスクリプターを B<read>(2)  すればよい。 これまでに何もイベントが"
"起こっていない場合、 停止 (blocking) モードのファイルディスクリプターであれ"
"ば、 少なくとも 1 つのイベントが起こるまで B<read>(2)  は停止する (シグナルに"
"より割り込まれなかった場合。 シグナルによる割り込みがあった場合、呼び出しはエ"
"ラー B<EINTR> で失敗する。 B<signal>(7)  参照)。"

#. type: Plain text
#: build/C/man7/inotify.7:105
msgid ""
"Each successful B<read>(2)  returns a buffer containing one or more of the "
"following structures:"
msgstr ""
"B<read>(2)  が成功すると、以下の構造体を 1 つ以上含むバッファーが返される:"

#.  FIXME . The type of the 'wd' field should probably be "int32_t".
#.  I submitted a patch to fix this.  See the LKML thread
#.  "[patch] Fix type errors in inotify interfaces", 18 Nov 2008
#.  Glibc bug filed: http://sources.redhat.com/bugzilla/show_bug.cgi?id=7040
#. type: Plain text
#: build/C/man7/inotify.7:120
#, no-wrap
msgid ""
"struct inotify_event {\n"
"    int      wd;       /* Watch descriptor */\n"
"    uint32_t mask;     /* Mask describing event */\n"
"    uint32_t cookie;   /* Unique cookie associating related\n"
"                          events (for rename(2)) */\n"
"    uint32_t len;      /* Size of I<name> field */\n"
"    char     name[];   /* Optional null-terminated name */\n"
"};\n"
msgstr ""
"struct inotify_event {\n"
"    int      wd;       /* 監視対象ディスクリプター */\n"
"    uint32_t mask;     /* イベントを示すマスク */\n"
"    uint32_t cookie;   /* 関連するイベント群を関連づける\n"
"                          一意なクッキー (rename(2) 用) */\n"
"    uint32_t len;      /* \\(aqname\\(aq フィールドのサイズ */\n"
"    char     name[];   /* ヌルで終端された任意の名前 */\n"
"};\n"

#. type: Plain text
#: build/C/man7/inotify.7:127
msgid ""
"I<wd> identifies the watch for which this event occurs.  It is one of the "
"watch descriptors returned by a previous call to B<inotify_add_watch>(2)."
msgstr ""
"I<wd> はイベント発生の監視対象を指定する。 これは、前もって行われた "
"B<inotify_add_watch>(2)  呼び出しで返された監視対象ディスクリプターのうちの "
"1 つである。"

#. type: Plain text
#: build/C/man7/inotify.7:130
msgid ""
"I<mask> contains bits that describe the event that occurred (see below)."
msgstr ""
"I<mask> には発生したイベント (下記参照) を記述するためのビットが含まれる。"

#. type: Plain text
#: build/C/man7/inotify.7:142
msgid ""
"I<cookie> is a unique integer that connects related events.  Currently, this "
"is used only for rename events, and allows the resulting pair of "
"B<IN_MOVED_FROM> and B<IN_MOVED_TO> events to be connected by the "
"application.  For all other event types, I<cookie> is set to 0."
msgstr ""
"I<cookie> は関連するイベントを関連づけるための一意な整数である。\n"
"現在のところ、この値は rename イベントに対してのみ使われており、\n"
"結果のペアである B<IN_MOVED_FROM> と B<IN_MOVED_TO> イベントを\n"
"アプリケーションで関連づけることができる。\n"
"他のイベント種別の場合には、 I<cookie> は 0 に設定する。"

#. type: Plain text
#: build/C/man7/inotify.7:151
msgid ""
"The I<name> field is present only when an event is returned for a file "
"inside a watched directory; it identifies the filename within the watched "
"directory.  This filename is null-terminated, and may include further null "
"bytes (\\(aq\\e0\\(aq) to align subsequent reads to a suitable address "
"boundary."
msgstr "I<name> フィールドは監視しているディレクトリ内のファイルに対して イベントが返される場合のためにだけ存在する。 監視するディレクトリ内のファイル名を表す。 このファイル名はヌルで終端され、 その後の読み込みで適切なアドレス境界に調整するために、 さらにヌルバイト (\\(aq\\e0\\(aq) が含まれる場合もある。"

#. type: Plain text
#: build/C/man7/inotify.7:161
msgid ""
"The I<len> field counts all of the bytes in I<name>, including the null "
"bytes; the length of each I<inotify_event> structure is thus I<sizeof(struct "
"inotify_event)+len>."
msgstr ""
"I<len> フィールドはヌルバイトを含む I<name> の全てのバイト数を表す。\n"
"よって、 I<inotify_event> 構造体のサイズは \n"
"I<sizeof(struct inotify_event)+len> である。"

#. type: Plain text
#: build/C/man7/inotify.7:172
msgid ""
"The behavior when the buffer given to B<read>(2)  is too small to return "
"information about the next event depends on the kernel version: in kernels "
"before 2.6.21, B<read>(2)  returns 0; since kernel 2.6.21, B<read>(2)  fails "
"with the error B<EINVAL>.  Specifying a buffer of size"
msgstr ""
"B<read>(2) に渡されたバッファーが小さすぎて次のイベントに関する情報を返せ\n"
"ない場合の動作はカーネルのバージョンにより異なる。 2.6.21 より前のカー\n"
"ネルでは、 B<read>(2) は 0 を返す。 2.6.21 以降のカーネルでは、\n"
"B<read>(2) はエラー B<EINVAL> で失敗する。\n"
"バッファーサイズとして"

#. type: Plain text
#: build/C/man7/inotify.7:174
#, no-wrap
msgid "    sizeof(struct inotify_event) + NAME_MAX + 1\n"
msgstr "    sizeof(struct inotify_event) + NAME_MAX + 1\n"

#. type: Plain text
#: build/C/man7/inotify.7:176
msgid "will be sufficient to read at least one event."
msgstr "を指定すれば、少なくとも 1 イベントで読み出しを行うには十分である。"

#. type: SS
#: build/C/man7/inotify.7:176
#, no-wrap
msgid "inotify events"
msgstr "inotify イベント"

#. type: Plain text
#: build/C/man7/inotify.7:196
msgid ""
"The B<inotify_add_watch>(2)  I<mask> argument and the I<mask> field of the "
"I<inotify_event> structure returned when B<read>(2)ing an inotify file "
"descriptor are both bit masks identifying inotify events.  The following "
"bits can be specified in I<mask> when calling B<inotify_add_watch>(2)  and "
"may be returned in the I<mask> field returned by B<read>(2):"
msgstr ""
"B<inotify_add_watch>(2)  の I<mask> 引数と、inotify ファイル構造体を "
"B<read>(2)  したときに返される I<inotify_event> 構造体の I<mask> フィールド"
"は、ともに inotify イベントを識別するための ビットマスクである。 以下のビット"
"が B<inotify_add_watch>(2)  を呼ぶときの I<mask> に指定可能であり、 "
"B<read>(2)  で返される I<mask> フィールドで返される:"

#. type: TP
#: build/C/man7/inotify.7:197
#, no-wrap
msgid "B<IN_ACCESS> (+)"
msgstr "B<IN_ACCESS> (+)"

#. type: Plain text
#: build/C/man7/inotify.7:202
msgid "File was accessed (e.g., B<read>(2), B<execve>(2))."
msgstr "(B<read>(2), B<execve>(2) などで) ファイルがアクセスされた。"

#. type: TP
#: build/C/man7/inotify.7:202
#, no-wrap
msgid "B<IN_ATTRIB> (*)"
msgstr "B<IN_ATTRIB> (*)"

#.  FIXME .
#.  Events do not occur for link count changes on a file inside a monitored
#.  directory. This differs from other metadata changes for files inside
#.  a monitored directory.
#. type: Plain text
#: build/C/man7/inotify.7:221
msgid ""
"Metadata changed\\(emfor example, permissions (e.g., B<chmod>(2)), "
"timestamps (e.g., B<utimensat>(2)), extended attributes (B<setxattr>(2)), "
"link count (since Linux 2.6.25; e.g., for the target of B<link>(2)  and for "
"B<unlink>(2)), and user/group ID (e.g., B<chown>(2))."
msgstr ""
"メタデータが変更された。 メタデータとは、例えば、アクセス許可 (B<chmod>(2))、"
"タイムスタンプ (B<utimensat>(2) など)、拡張属性 (B<setxattr>(2))、 リンクカウ"
"ント (Linux 2.6.25 以降; B<link>(2) のリンク先や B<unlink>(2) など)、ユー"
"ザー/グループ ID (B<chown>(2) など) などである。"

#. type: TP
#: build/C/man7/inotify.7:221
#, no-wrap
msgid "B<IN_CLOSE_WRITE> (+)"
msgstr "B<IN_CLOSE_WRITE> (+)"

#. type: Plain text
#: build/C/man7/inotify.7:224
msgid "File opened for writing was closed."
msgstr "書き込みのためにオープンされたファイルがクローズされた。"

#. type: TP
#: build/C/man7/inotify.7:224
#, no-wrap
msgid "B<IN_CLOSE_NOWRITE> (*)"
msgstr "B<IN_CLOSE_NOWRITE> (*)"

#. type: Plain text
#: build/C/man7/inotify.7:227
msgid "File or directory not opened for writing was closed."
msgstr ""
"書き込み用としてはオープンされていないファイルやディレクトリがクローズされ"
"た。"

#. type: TP
#: build/C/man7/inotify.7:227
#, no-wrap
msgid "B<IN_CREATE> (+)"
msgstr "B<IN_CREATE> (+)"

#. type: Plain text
#: build/C/man7/inotify.7:237
msgid ""
"File/directory created in watched directory (e.g., B<open>(2)  B<O_CREAT>, "
"B<mkdir>(2), B<link>(2), B<symlink>(2), B<bind>(2)  on a UNIX domain socket)."
msgstr ""
"監視対象ディレクトリ内でファイルやディレクトリが作成された (B<open>(2)  "
"B<O_CREAT>, B<mkdir>(2), B<link>(2), B<symlink>(2), UNIX ドメインソケットに対"
"する B<bind>(2) など)。"

#. type: TP
#: build/C/man7/inotify.7:237
#, no-wrap
msgid "B<IN_DELETE> (+)"
msgstr "B<IN_DELETE> (+)"

#. type: Plain text
#: build/C/man7/inotify.7:240
msgid "File/directory deleted from watched directory."
msgstr "監視対象ディレクトリ内でファイルやディレクトリが削除された。"

#. type: TP
#: build/C/man7/inotify.7:240
#, no-wrap
msgid "B<IN_DELETE_SELF>"
msgstr "B<IN_DELETE_SELF>"

#. type: Plain text
#: build/C/man7/inotify.7:251
msgid ""
"Watched file/directory was itself deleted.  (This event also occurs if an "
"object is moved to another filesystem, since B<mv>(1)  in effect copies the "
"file to the other filesystem and then deletes it from the original "
"filesystem.)  In addition, an B<IN_IGNORED> event will subsequently be "
"generated for the watch descriptor."
msgstr ""
"監視対象のファイルやディレクトリ自身が削除あれた。 (このイベントはオブジェク"
"トが別のファイルシステムに移動された場合にも発生する。 B<mv>(1) は実際には別"
"のファイルシステムにファイルをコピーした後、元のファイルシステムからそのファ"
"イルを削除するからである。) また、 結果的に監視ディスクリプターに対して "
"B<IN_IGNORED> イベントも生成される。"

#. type: TP
#: build/C/man7/inotify.7:251
#, no-wrap
msgid "B<IN_MODIFY> (+)"
msgstr "B<IN_MODIFY> (+)"

#. type: Plain text
#: build/C/man7/inotify.7:256
msgid "File was modified (e.g., B<write>(2), B<truncate>(2))."
msgstr "ファイルが変更された (B<write>(2), B<truncate>(2) など)。"

#. type: TP
#: build/C/man7/inotify.7:256
#, no-wrap
msgid "B<IN_MOVE_SELF>"
msgstr "B<IN_MOVE_SELF>"

#. type: Plain text
#: build/C/man7/inotify.7:259
msgid "Watched file/directory was itself moved."
msgstr "監視対象のディレクトリまたはファイル自身が移動された。"

#. type: TP
#: build/C/man7/inotify.7:259
#, no-wrap
msgid "B<IN_MOVED_FROM> (+)"
msgstr "B<IN_MOVED_FROM> (+)"

#. type: Plain text
#: build/C/man7/inotify.7:263
msgid ""
"Generated for the directory containing the old filename when a file is "
"renamed."
msgstr ""
"ファイル名の変更を行った際に変更前のファイル名が含まれるディレクトリに対して"
"生成される。"

#. type: TP
#: build/C/man7/inotify.7:263
#, no-wrap
msgid "B<IN_MOVED_TO> (+)"
msgstr "B<IN_MOVED_TO> (+)"

#. type: Plain text
#: build/C/man7/inotify.7:267
msgid ""
"Generated for the directory containing the new filename when a file is "
"renamed."
msgstr ""
"ファイル名の変更を行った際に新しいファイル名が含まれるディレクトリに対して生"
"成される。"

#. type: TP
#: build/C/man7/inotify.7:267
#, no-wrap
msgid "B<IN_OPEN> (*)"
msgstr "B<IN_OPEN> (*)"

#. type: Plain text
#: build/C/man7/inotify.7:270
msgid "File or directory was opened."
msgstr "ファイルやディレクトリがオープンされた。"

#. type: Plain text
#: build/C/man7/inotify.7:276
msgid ""
"Inotify monitoring is inode-based: when monitoring a file (but not when "
"monitoring the directory containing a file), an event can be generated for "
"activity on any link to the file (in the same or a different directory)."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:278
msgid "When monitoring a directory:"
msgstr "ディレクトリを監視する場合:"

#. type: Plain text
#: build/C/man7/inotify.7:281
msgid ""
"the events marked above with an asterisk (*) can occur both for the "
"directory itself and for objects inside the directory; and"
msgstr ""
"上記でアスタリスク (*) が付いたイベントは、 ディレクトリ自身とディレクトリ内"
"のオブジェクトのどちらに対しても発生する。"

#. type: Plain text
#: build/C/man7/inotify.7:284
msgid ""
"the events marked with a plus sign (+) occur only for objects inside the "
"directory (not for the directory itself)."
msgstr ""
"上記でプラス記号 (+) が付いたイベントは、 ディレクトリ内のオブジェクトに対し"
"てのみ発生する (ディレクトリ自身に対しては発生しない)。"

#. type: Plain text
#: build/C/man7/inotify.7:290
msgid ""
"I<Note>: when monitoring a directory, events are not generated for the files "
"inside the directory when the events are performed via a pathname (i.e., a "
"link)  that lies outside the monitored directory."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:296
msgid ""
"When events are generated for objects inside a watched directory, the "
"I<name> field in the returned I<inotify_event> structure identifies the name "
"of the file within the directory."
msgstr ""
"監視対象のディレクトリ内のオブジェクトに対してイベントが発生した場合、 "
"I<inotify_event> 構造体で返される I<name> フィールドは、ディレクトリ内のファ"
"イル名を表す。"

#. type: Plain text
#: build/C/man7/inotify.7:304
msgid ""
"The B<IN_ALL_EVENTS> macro is defined as a bit mask of all of the above "
"events.  This macro can be used as the I<mask> argument when calling "
"B<inotify_add_watch>(2)."
msgstr ""
"B<IN_ALL_EVENTS> マクロは上記のイベント全てのマスクとして定義される。 このマ"
"クロは B<inotify_add_watch>(2)  を呼び出すときの I<mask> 引数として使える。"

#. type: Plain text
#: build/C/man7/inotify.7:306
msgid "Two additional convenience macros are defined:"
msgstr "以下の 2 つの便利なマクロが定義されている。"

#. type: TP
#: build/C/man7/inotify.7:307
#, no-wrap
msgid "B<IN_MOVE>"
msgstr "B<IN_MOVE>"

#. type: Plain text
#: build/C/man7/inotify.7:311
msgid "Equates to B<IN_MOVED_FROM | IN_MOVED_TO>."
msgstr "B<IN_MOVED_FROM | IN_MOVED_TO> と等価。"

#. type: TP
#: build/C/man7/inotify.7:311
#, no-wrap
msgid "B<IN_CLOSE>"
msgstr "B<IN_CLOSE>"

#. type: Plain text
#: build/C/man7/inotify.7:315
msgid "Equates to B<IN_CLOSE_WRITE | IN_CLOSE_NOWRITE>."
msgstr "B<IN_CLOSE_WRITE | IN_CLOSE_NOWRITE> と等価。"

#. type: Plain text
#: build/C/man7/inotify.7:321
msgid ""
"The following further bits can be specified in I<mask> when calling "
"B<inotify_add_watch>(2):"
msgstr ""
"その他にも以下のビットを B<inotify_add_watch>(2)  を呼ぶときの I<mask> に指定"
"できる:"

#. type: TP
#: build/C/man7/inotify.7:322
#, no-wrap
msgid "B<IN_DONT_FOLLOW> (since Linux 2.6.15)"
msgstr "B<IN_DONT_FOLLOW> (Linux 2.6.15 以降)"

#. type: Plain text
#: build/C/man7/inotify.7:327
msgid "Don't dereference I<pathname> if it is a symbolic link."
msgstr ""
"I<pathname> がシンボリックリンクである場合に辿らない。 (Linux 2.6.15 以降)"

#. type: TP
#: build/C/man7/inotify.7:327
#, no-wrap
msgid "B<IN_EXCL_UNLINK> (since Linux 2.6.36)"
msgstr "B<IN_EXCL_UNLINK> (Linux 2.6.36 以降)"

#.  commit 8c1934c8d70b22ca8333b216aec6c7d09fdbd6a6
#. type: Plain text
#: build/C/man7/inotify.7:343
msgid ""
"By default, when watching events on the children of a directory, events are "
"generated for children even after they have been unlinked from the "
"directory.  This can result in large numbers of uninteresting events for "
"some applications (e.g., if watching I</tmp>, in which many applications "
"create temporary files whose names are immediately unlinked).  Specifying "
"B<IN_EXCL_UNLINK> changes the default behavior, so that events are not "
"generated for children after they have been unlinked from the watched "
"directory."
msgstr ""
"デフォルトでは、あるディレクトリの子ファイルに関するイベントを監視 (watch) し"
"た際、ディレクトリからその子ファイルが削除 (unlink) された場合であってもその"
"子ファイルに対してイベントが生成される。このことは、アプリケーションによって"
"はあまり興味のないイベントが大量に発生することにつながる (例えば、I</tmp> を"
"監視している場合、たくさんのアプリケーションが、すぐにその名前が削除される一"
"時ファイルをそのディレクトリに作成する)。 B<IN_EXCL_UNLINK> を指定するとこの"
"デフォルトの動作を変更でき、監視対象のディレクトリから子ファイルが削除された"
"後に子ファイルに関するイベントが生成されなくなる。"

#. type: TP
#: build/C/man7/inotify.7:343
#, no-wrap
msgid "B<IN_MASK_ADD>"
msgstr "B<IN_MASK_ADD>"

#. type: Plain text
#: build/C/man7/inotify.7:355
#, fuzzy
#| msgid ""
#| "If a watch instance already exists for the filesystem object "
#| "corresponding to I<pathname>, add (OR) the events in I<mask> to the watch "
#| "mask (instead of replacing the mask)."
msgid ""
"If a watch instance already exists for the filesystem object corresponding "
"to I<pathname>, add (OR) the events in I<mask> to the watch mask (instead of "
"replacing the mask); the error B<EINVAL> results if B<IN_MASK_CREATE> is "
"also specified."
msgstr ""
"監視インスタンスが I<pathname> に対応するファイルシステムオブジェクトに対して"
"すでに存在する場合に、 (マスクを置き換えるのではなく) 監視マスクに I<mask> で"
"指定されたイベントを追加 (OR) する。"

#. type: TP
#: build/C/man7/inotify.7:355
#, no-wrap
msgid "B<IN_ONESHOT>"
msgstr "B<IN_ONESHOT>"

#. type: Plain text
#: build/C/man7/inotify.7:361
msgid ""
"Monitor the filesystem object corresponding to I<pathname> for one event, "
"then remove from watch list."
msgstr ""
"I<pathname> に対応するファイルシステムオブジェクトを 1 イベントについてだけ監"
"視し、 イベントが発生したら監視対象リストから削除する。"

#. type: TP
#: build/C/man7/inotify.7:361
#, no-wrap
msgid "B<IN_ONLYDIR> (since Linux 2.6.15)"
msgstr "B<IN_ONLYDIR> (Linux 2.6.15 以降)"

#. type: Plain text
#: build/C/man7/inotify.7:373
#, fuzzy
#| msgid ""
#| "Only watch I<pathname> if it is a directory.  Using this flag provides an "
#| "application with a race-free way of ensuring that the monitored object is "
#| "a directory."
msgid ""
"Watch I<pathname> only if it is a directory; the error B<ENOTDIR> results if "
"I<pathname> is not a directory.  Using this flag provides an application "
"with a race-free way of ensuring that the monitored object is a directory."
msgstr ""
"I<pathname> がディレクトリの場合のみ監視する。 このフラグを使うことで、アプリ"
"ケーションは、競合状態を考慮せずに、監視するオブジェクトがディレクトリである"
"ことを保証することができるようになる。"

#. type: TP
#: build/C/man7/inotify.7:373
#, no-wrap
msgid "B<IN_MASK_CREATE> (since Linux 4.18)"
msgstr "B<IN_MASK_CREATE> (Linux 4.18 以降)"

#. type: Plain text
#: build/C/man7/inotify.7:383
msgid ""
"Watch I<pathname> only if it does not already have a watch associated with "
"it; the error B<EEXIST> results if I<pathname> is already being watched."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:390
msgid ""
"Using this flag provides an application with a way of ensuring that new "
"watches do not modify existing ones.  This is useful because multiple paths "
"may refer to the same inode, and multiple calls to B<inotify_add_watch>(2)  "
"without this flag may clobber existing watch masks."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:396
msgid ""
"The following bits may be set in the I<mask> field returned by B<read>(2):"
msgstr "以下のビットが B<read>(2)  で返される I<mask> フィールドに設定される:"

#. type: TP
#: build/C/man7/inotify.7:397
#, no-wrap
msgid "B<IN_IGNORED>"
msgstr "B<IN_IGNORED>"

#. type: Plain text
#: build/C/man7/inotify.7:403
msgid ""
"Watch was removed explicitly (B<inotify_rm_watch>(2))  or automatically "
"(file was deleted, or filesystem was unmounted).  See also BUGS."
msgstr ""
"監視対象が (B<inotify_rm_watch>(2) により) 明示的に 削除された。もしくは "
"(ファイルの削除、またはファイル システムのアンマウントにより) 自動的に削除さ"
"れた。「バグ」も参照のこと。"

#. type: TP
#: build/C/man7/inotify.7:403
#, no-wrap
msgid "B<IN_ISDIR>"
msgstr "B<IN_ISDIR>"

#. type: Plain text
#: build/C/man7/inotify.7:406
msgid "Subject of this event is a directory."
msgstr "このイベントの対象がディレクトリである。"

#. type: TP
#: build/C/man7/inotify.7:406
#, no-wrap
msgid "B<IN_Q_OVERFLOW>"
msgstr "B<IN_Q_OVERFLOW>"

#. type: Plain text
#: build/C/man7/inotify.7:411
msgid "Event queue overflowed (I<wd> is -1 for this event)."
msgstr "イベントキューが溢れた (このイベントの場合、I<wd> は -1 である)。"

#. type: TP
#: build/C/man7/inotify.7:411
#, no-wrap
msgid "B<IN_UNMOUNT>"
msgstr "B<IN_UNMOUNT>"

#. type: Plain text
#: build/C/man7/inotify.7:417
msgid ""
"Filesystem containing watched object was unmounted.  In addition, an "
"B<IN_IGNORED> event will subsequently be generated for the watch descriptor."
msgstr ""
"監視対象オブジェクトを含むファイルシステムがアンマウントされた。さらに、この"
"監視対象ディスクリプターに対して B<IN_IGNORED> イベントが生成される。"

#. type: SS
#: build/C/man7/inotify.7:418
#, no-wrap
msgid "Examples"
msgstr "例"

#. type: Plain text
#: build/C/man7/inotify.7:426
msgid ""
"Suppose an application is watching the directory I<dir> and the file I<dir/"
"myfile> for all events.  The examples below show some events that will be "
"generated for these two objects."
msgstr ""
"アプリケーションがディレクトリ I<dir> とファイル I<dir/myfile> のすべてのイベ"
"ントを監視しているとする。 以下に、これらの 2 つのオブジェクトに対して生成さ"
"れるイベントの例を示す。"

#. type: TP
#: build/C/man7/inotify.7:427
#, no-wrap
msgid "fd = open(\"dir/myfile\", O_RDWR);"
msgstr "fd = open(\"dir/myfile\", O_RDWR);"

#. type: Plain text
#: build/C/man7/inotify.7:435
msgid "Generates B<IN_OPEN> events for both I<dir> and I<dir/myfile>."
msgstr ""
"I<dir> と I<dir/myfile> の両方に対して B<IN_OPEN> イベントが生成される。"

#. type: TP
#: build/C/man7/inotify.7:435
#, no-wrap
msgid "read(fd, buf, count);"
msgstr "read(fd, buf, count);"

#. type: Plain text
#: build/C/man7/inotify.7:443
msgid "Generates B<IN_ACCESS> events for both I<dir> and I<dir/myfile>."
msgstr ""
"I<dir> と I<dir/myfile> の両方に対して B<IN_ACCESS> イベントが生成される"

#. type: TP
#: build/C/man7/inotify.7:443
#, no-wrap
msgid "write(fd, buf, count);"
msgstr "write(fd, buf, count);"

#. type: Plain text
#: build/C/man7/inotify.7:451
msgid "Generates B<IN_MODIFY> events for both I<dir> and I<dir/myfile>."
msgstr ""
"I<dir> と I<dir/myfile> の両方に対して B<IN_MODIFY> イベントが生成される"

#. type: TP
#: build/C/man7/inotify.7:451
#, no-wrap
msgid "fchmod(fd, mode);"
msgstr "fchmod(fd, mode);"

#. type: Plain text
#: build/C/man7/inotify.7:459
msgid "Generates B<IN_ATTRIB> events for both I<dir> and I<dir/myfile>."
msgstr ""
"I<dir> と I<dir/myfile> の両方に対して B<IN_ATTRIB> イベントが生成される"

#. type: TP
#: build/C/man7/inotify.7:459
#, no-wrap
msgid "close(fd);"
msgstr "close(fd);"

#. type: Plain text
#: build/C/man7/inotify.7:467
msgid "Generates B<IN_CLOSE_WRITE> events for both I<dir> and I<dir/myfile>."
msgstr ""
"I<dir> と I<dir/myfile> の両方に対して B<IN_CLOSE_WRITE> イベントが生成される"

#. type: Plain text
#: build/C/man7/inotify.7:476
msgid ""
"Suppose an application is watching the directories I<dir1> and I<dir2>, and "
"the file I<dir1/myfile>.  The following examples show some events that may "
"be generated."
msgstr ""
"アプリケーションがディレクトリ I<dir1> と I<dir2>、およびファイル I<dir1/"
"myfile> を監視しているとする。 以下に生成されるイベントの例を示す。"

#. type: TP
#: build/C/man7/inotify.7:477
#, no-wrap
msgid "link(\"dir1/myfile\", \"dir2/new\");"
msgstr "link(\"dir1/myfile\", \"dir2/new\");"

#. type: Plain text
#: build/C/man7/inotify.7:487
msgid ""
"Generates an B<IN_ATTRIB> event for I<myfile> and an B<IN_CREATE> event for "
"I<dir2>."
msgstr ""
"I<myfile> に対して B<IN_ATTRIB> イベントが生成され、 I<dir2> に対して "
"B<IN_CREATE> イベントが生成される。"

#. type: TP
#: build/C/man7/inotify.7:487
#, no-wrap
msgid "rename(\"dir1/myfile\", \"dir2/myfile\");"
msgstr "rename(\"dir1/myfile\", \"dir2/myfile\");"

#. type: Plain text
#: build/C/man7/inotify.7:508
msgid ""
"Generates an B<IN_MOVED_FROM> event for I<dir1>, an B<IN_MOVED_TO> event for "
"I<dir2>, and an B<IN_MOVE_SELF> event for I<myfile>.  The B<IN_MOVED_FROM> "
"and B<IN_MOVED_TO> events will have the same I<cookie> value."
msgstr ""
"I<dir1> に対してイベント B<IN_MOVED_FROM> が、 I<dir2> に対してイベント "
"B<IN_MOVED_TO> が、 I<myfile> に対してイベント B<IN_MOVE_SELF> が生成される。"
"この際 イベント B<IN_MOVED_FROM> と B<IN_MOVED_TO> は同じ I<cookie> 値を持"
"つ。"

#. type: Plain text
#: build/C/man7/inotify.7:522
msgid ""
"Suppose that I<dir1/xx> and I<dir2/yy> are (the only) links to the same "
"file, and an application is watching I<dir1>, I<dir2>, I<dir1/xx>, and "
"I<dir2/yy>.  Executing the following calls in the order given below will "
"generate the following events:"
msgstr ""
"I<dir1/xx> と I<dir2/yy> は同じファイルを参照するリンクで (他のリンクはないも"
"のとする)、 アプリケーションは I<dir1>, I<dir2>, I<dir1/xx>, I<dir2/yy> を監"
"視しているものとする。 以下に示す順序で下記の呼び出しを実行すると、以下のイベ"
"ントが生成される。"

#. type: TP
#: build/C/man7/inotify.7:523
#, no-wrap
msgid "unlink(\"dir2/yy\");"
msgstr "unlink(\"dir2/yy\");"

#. type: Plain text
#: build/C/man7/inotify.7:534
msgid ""
"Generates an B<IN_ATTRIB> event for I<xx> (because its link count changes)  "
"and an B<IN_DELETE> event for I<dir2>."
msgstr ""
"I<xx> に対して B<IN_ATTRIB> イベントが生成され (リンク数が変化したため)、 "
"I<dir2> に対して B<IN_DELETE> イベントが生成される。"

#. type: TP
#: build/C/man7/inotify.7:534
#, no-wrap
msgid "unlink(\"dir1/xx\");"
msgstr "unlink(\"dir1/xx\");"

#. type: Plain text
#: build/C/man7/inotify.7:547
msgid ""
"Generates B<IN_ATTRIB>, B<IN_DELETE_SELF>, and B<IN_IGNORED> events for "
"I<xx>, and an B<IN_DELETE> event for I<dir1>."
msgstr ""
"I<xx> に対してイベント B<IN_ATTRIB>, B<IN_DELETE_SELF>, B<IN_IGNORED> が生成"
"され、 I<dir1> に対して B<IN_DELETE> イベントが生成される。"

#. type: Plain text
#: build/C/man7/inotify.7:554
msgid ""
"Suppose an application is watching the directory I<dir> and (the empty) "
"directory I<dir/subdir>.  The following examples show some events that may "
"be generated."
msgstr ""
"アプリケーションがディレクトリ I<dir> と (空の) ディレクトリ I<dir/subdir> を"
"監視しているものとする。 以下に生成されるイベントの例を示す。"

#. type: TP
#: build/C/man7/inotify.7:555
#, no-wrap
msgid "mkdir(\"dir/new\", mode);"
msgstr "mkdir(\"dir/new\", mode);"

#. type: Plain text
#: build/C/man7/inotify.7:561
msgid "Generates an B<IN_CREATE | IN_ISDIR> event for I<dir>."
msgstr "I<dir> に対して B<IN_CREATE | IN_ISDIR> イベントが生成される。"

#. type: TP
#: build/C/man7/inotify.7:561
#, no-wrap
msgid "rmdir(\"dir/subdir\");"
msgstr "rmdir(\"dir/subdir\");"

#. type: Plain text
#: build/C/man7/inotify.7:573
msgid ""
"Generates B<IN_DELETE_SELF> and B<IN_IGNORED> events for I<subdir>, and an "
"B<IN_DELETE | IN_ISDIR> event for I<dir>."
msgstr ""
"I<subdir> に対してイベント B<IN_DELETE_SELF> と B<IN_IGNORED> が生成され、 "
"I<dir> に対して B<IN_DELETE | IN_ISDIR> イベントが生成される。"

#. type: SS
#: build/C/man7/inotify.7:574
#, no-wrap
msgid "/proc interfaces"
msgstr "/proc インターフェース"

#. type: Plain text
#: build/C/man7/inotify.7:577
msgid ""
"The following interfaces can be used to limit the amount of kernel memory "
"consumed by inotify:"
msgstr ""
"以下のインターフェースは、inotify で消費される カーネルメモリーの総量を制限す"
"るのに使用できる:"

#. type: TP
#: build/C/man7/inotify.7:577
#, no-wrap
msgid "I</proc/sys/fs/inotify/max_queued_events>"
msgstr "I</proc/sys/fs/inotify/max_queued_events>"

#. type: Plain text
#: build/C/man7/inotify.7:586
msgid ""
"The value in this file is used when an application calls B<inotify_init>(2)  "
"to set an upper limit on the number of events that can be queued to the "
"corresponding inotify instance.  Events in excess of this limit are dropped, "
"but an B<IN_Q_OVERFLOW> event is always generated."
msgstr ""
"このファイルの値は、アプリケーションが B<inotify_init>(2)  を呼び出すときに使"
"用され、対応する inotify インスタンスについて キューに入れられるイベントの数"
"の上限を設定する。 この制限を超えたイベントは破棄されるが、 B<IN_Q_OVERFLOW> "
"イベントが常に生成される。"

#. type: TP
#: build/C/man7/inotify.7:586
#, no-wrap
msgid "I</proc/sys/fs/inotify/max_user_instances>"
msgstr "I</proc/sys/fs/inotify/max_user_instances>"

#. type: Plain text
#: build/C/man7/inotify.7:590
msgid ""
"This specifies an upper limit on the number of inotify instances that can be "
"created per real user ID."
msgstr ""
"1 つの実ユーザー ID に対して生成できる inotify インスタンスの数の上限を指定す"
"る。"

#. type: TP
#: build/C/man7/inotify.7:590
#, no-wrap
msgid "I</proc/sys/fs/inotify/max_user_watches>"
msgstr "I</proc/sys/fs/inotify/max_user_watches>"

#. type: Plain text
#: build/C/man7/inotify.7:594
msgid ""
"This specifies an upper limit on the number of watches that can be created "
"per real user ID."
msgstr "作成可能な監視対象の数の実 UID 単位の上限を指定する。"

#. type: Plain text
#: build/C/man7/inotify.7:602
msgid ""
"Inotify was merged into the 2.6.13 Linux kernel.  The required library "
"interfaces were added to glibc in version 2.4.  (B<IN_DONT_FOLLOW>, "
"B<IN_MASK_ADD>, and B<IN_ONLYDIR> were added in glibc version 2.5.)"
msgstr ""
"inotify は 2.6.13 の Linux カーネルに組込まれた。 これに必要なライブラリのイ"
"ンターフェースは、 glibc のバージョン 2.4 に追加された (B<IN_DONT_FOLLOW>, "
"B<IN_MASK_ADD>, B<IN_ONLYDIR> は glibc バージョン 2.5 で追加された)。"

#. type: Plain text
#: build/C/man7/inotify.7:604
msgid "The inotify API is Linux-specific."
msgstr "inotify API は Linux 独自のものである。"

#. type: Plain text
#: build/C/man7/inotify.7:611
msgid ""
"Inotify file descriptors can be monitored using B<select>(2), B<poll>(2), "
"and B<epoll>(7).  When an event is available, the file descriptor indicates "
"as readable."
msgstr ""
"inotify ファイルディスクリプターは B<select>(2), B<poll>(2), B<epoll>(7)  を"
"使って監視できる。 イベントがある場合、ファイルディスクリプターは読み込み可能"
"と通知する。"

#. type: Plain text
#: build/C/man7/inotify.7:640
msgid ""
"Since Linux 2.6.25, signal-driven I/O notification is available for inotify "
"file descriptors; see the discussion of B<F_SETFL> (for setting the "
"B<O_ASYNC> flag), B<F_SETOWN>, and B<F_SETSIG> in B<fcntl>(2).  The "
"I<siginfo_t> structure (described in B<sigaction>(2))  that is passed to the "
"signal handler has the following fields set: I<si_fd> is set to the inotify "
"file descriptor number; I<si_signo> is set to the signal number; I<si_code> "
"is set to B<POLL_IN>; and B<POLLIN> is set in I<si_band>."
msgstr ""
"Linux 2.6.25 以降では、シグナル駆動 (signal-driven) I/O の通知が inotify ファ"
"イルディスクリプターについて利用可能である。 B<fcntl>(2)  に書かれている "
"(B<O_ASYNC> フラグを設定するための)  B<F_SETFL>, B<F_SETOWN>, B<F_SETSIG> の"
"議論を参照のこと。 シグナルハンドラーに渡される I<siginfo_t> 構造体は、以下の"
"フィールドが設定される (I<siginfo_t> は B<sigaction>(2)  で説明されている)。 "
"I<si_fd> には inotify ファイルディスクリプター番号が、 I<si_signo> にはシグナ"
"ル番号が、 I<si_code> には B<POLL_IN> が、 I<si_band> には B<POLLIN> が設定さ"
"れる。"

#. type: Plain text
#: build/C/man7/inotify.7:653
msgid ""
"If successive output inotify events produced on the inotify file descriptor "
"are identical (same I<wd>, I<mask>, I<cookie>, and I<name>), then they are "
"coalesced into a single event if the older event has not yet been read (but "
"see BUGS).  This reduces the amount of kernel memory required for the event "
"queue, but also means that an application can't use inotify to reliably "
"count file events."
msgstr ""
"inotify ファイルディスクリプターに対して 連続して生成される出力 inotify イベ"
"ントが同一の場合 (I<wd>, I<mask>, I<cookie>, I<name> が等しい場合)、 前のイベ"
"ントがまだ読み込まれていなければ、 連続するイベントが 1 つのイベントにまとめ"
"られる (ただし「バグ」の節も参照のこと)。 これによりイベントキューに必要な"
"カーネルメモリー量が減るが、 これはまたアプリケーションがファイルイベント数を"
"信頼性を持って数えるのに inotify を使用できないということでもある。"

#. type: Plain text
#: build/C/man7/inotify.7:659
msgid ""
"The events returned by reading from an inotify file descriptor form an "
"ordered queue.  Thus, for example, it is guaranteed that when renaming from "
"one directory to another, events will be produced in the correct order on "
"the inotify file descriptor."
msgstr ""
"inotify ファイルディスクリプターの読み込みで返されるイベントは、 順序付けられ"
"たキューになる。 従って、たとえば、あるディレクトリの名前を別の名前に変更した"
"場合、 inotify ファイルディスクリプターについての正しい順番で イベントが生成"
"されることが保証される。"

#. type: Plain text
#: build/C/man7/inotify.7:673
msgid ""
"The set of watch descriptors that is being monitored via an inotify file "
"descriptor can be viewed via the entry for the inotify file descriptor in "
"the process's I</proc/[pid]/fdinfo> directory.  See B<proc>(5)  for further "
"details.  The B<FIONREAD> B<ioctl>(2)  returns the number of bytes available "
"to read from an inotify file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:680
msgid ""
"The inotify API provides no information about the user or process that "
"triggered the inotify event.  In particular, there is no easy way for a "
"process that is monitoring events via inotify to distinguish events that it "
"triggers itself from those that are triggered by other processes."
msgstr ""
"inotify API では、inotify イベントが発生するきっかけとなったユーザーやプロセ"
"スに関する情報は提供されない。とりわけ、inotify 経由でイベントを監視している"
"プロセスが、自分自身がきっかけとなったイベントと他のプロセスがきっかけとなっ"
"たイベントを区別する簡単な手段はない。"

#. type: Plain text
#: build/C/man7/inotify.7:693
msgid ""
"Inotify reports only events that a user-space program triggers through the "
"filesystem API.  As a result, it does not catch remote events that occur on "
"network filesystems.  (Applications must fall back to polling the filesystem "
"to catch such events.)  Furthermore, various pseudo-filesystems such as I</"
"proc>, I</sys>, and I</dev/pts> are not monitorable with inotify."
msgstr ""
"inotify は、ファイルシステム API 経由でユーザー空間プログラムがきっかけとなっ"
"たイベントだけを報告する。 結果として、 inotify はネットワークファイルシステ"
"ムで発生したリモートのイベントを捉えることはできない (このようなイベントを捉"
"えるにはアプリケーションはファイルシステムをポーリングする必要がある)。 さら"
"に、 I</proc>, I</sys>, I</dev/pts> といったいくつかの疑似ファイルシステムは "
"inotify で監視することができない。"

#. type: Plain text
#: build/C/man7/inotify.7:700
msgid ""
"The inotify API does not report file accesses and modifications that may "
"occur because of B<mmap>(2), B<msync>(2), and B<munmap>(2)."
msgstr ""
"inotify API は B<mmap>(2), B<msync>(2), B<munmap>(2) により起こったファイルの"
"アクセスと変更を報告しない。"

#. type: Plain text
#: build/C/man7/inotify.7:704
msgid ""
"The inotify API identifies affected files by filename.  However, by the time "
"an application processes an inotify event, the filename may already have "
"been deleted or renamed."
msgstr ""
"inotify API では影響が受けるファイルをファイル名で特定する。\n"
"しかしながら、アプリケーションが inotify イベントを処理する時点では、\n"
"そのファイル名がすでに削除されたり変更されたりしている可能性がある。"

#. type: Plain text
#: build/C/man7/inotify.7:709
msgid ""
"The inotify API identifies events via watch descriptors.  It is the "
"application's responsibility to cache a mapping (if one is needed) between "
"watch descriptors and pathnames.  Be aware that directory renamings may "
"affect multiple cached pathnames."
msgstr ""
"inotify API では監視対象ディスクリプターを通してイベントが区別される。 (必要"
"であれば) 監視対象ディスクリプターとパス名のマッピングをキャッシュしておくの"
"はアプリケーションの役目である。 ディレクトリの名前変更の場合、キャッシュして"
"いる複数のパス名に影響がある点に注意すること。"

#. type: Plain text
#: build/C/man7/inotify.7:714
msgid ""
"Inotify monitoring of directories is not recursive: to monitor "
"subdirectories under a directory, additional watches must be created.  This "
"can take a significant amount time for large directory trees."
msgstr ""
"inotify によるディレクトリの監視は再帰的に行われない: あるディレクトリ以下"
"の\n"
"サブディレクトリを監視する場合、 監視対象を追加で作成しなければならない。\n"
"大きなディレクトリツリーの場合には、この作業にかなり時間がかかることがある。"

#. type: Plain text
#: build/C/man7/inotify.7:723
msgid ""
"If monitoring an entire directory subtree, and a new subdirectory is created "
"in that tree or an existing directory is renamed into that tree, be aware "
"that by the time you create a watch for the new subdirectory, new files (and "
"subdirectories) may already exist inside the subdirectory.  Therefore, you "
"may want to scan the contents of the subdirectory immediately after adding "
"the watch (and, if desired, recursively add watches for any subdirectories "
"that it contains)."
msgstr ""
"ディレクトリツリー全体を監視していて、 そのツリー内に新しいサブディレクトリが"
"作成されるか、 既存のディレクトリが名前が変更されそのツリー内に移動した場"
"合、 新しいサブディレクトリに対する watch を作成するまでに、 新しいファイル "
"(やサブディレクトリ) がそのサブディレクトリ内にすでに作成されている場合がある"
"点に注意すること。 したがって、watch を追加した直後にサブディレクトリの内容を"
"スキャンしたいと思う場合もあるだろう (必要ならそのサブディレクトリ内のサブ"
"ディレクトリに対する watch も再帰的に追加することもあるだろう)。"

#. type: Plain text
#: build/C/man7/inotify.7:735
msgid ""
"Note that the event queue can overflow.  In this case, events are lost.  "
"Robust applications should handle the possibility of lost events "
"gracefully.  For example, it may be necessary to rebuild part or all of the "
"application cache.  (One simple, but possibly expensive, approach is to "
"close the inotify file descriptor, empty the cache, create a new inotify "
"file descriptor, and then re-create watches and cache entries for the "
"objects to be monitored.)"
msgstr ""
"イベントキューはオーバーフローする場合があることに注意すること。 この場合、イ"
"ベントは失なわれる。 ロバスト性が求められるアプリケーションでは、 イベントが"
"失なわれる可能性も含めて適切に処理を行うべきである。 例えば、アプリケーション"
"内のキャッシュの一部分または全てを再構築する必要があるかもしれない。 (単純だ"
"が、おそらくコストがかかる方法は、 inotify ファイルディスクリプターをクローズ"
"し、 キャッシュを空にし、 新しい inotify ファイルディスクリプターを作成し、 "
"監視しているオブジェクトの監視対象ディスクリプターとキャッシュエントリーの再"
"作成を行う方法である。)"

#. type: Plain text
#: build/C/man7/inotify.7:743
msgid ""
"If a filesystem is mounted on top of a monitored directory, no event is "
"generated, and no events are generated for objects immediately under the new "
"mount point.  If the filesystem is subsequently unmounted, events will "
"subsequently be generated for the directory and the objects it contains."
msgstr ""

#. type: SS
#: build/C/man7/inotify.7:743
#, no-wrap
msgid "Dealing with rename() events"
msgstr "rename() イベントの取り扱い"

#. type: Plain text
#: build/C/man7/inotify.7:752
msgid ""
"As noted above, the B<IN_MOVED_FROM> and B<IN_MOVED_TO> event pair that is "
"generated by B<rename>(2)  can be matched up via their shared cookie value.  "
"However, the task of matching has some challenges."
msgstr ""
"上述の通り、 B<rename>(2) により生成される B<IN_MOVED_FROM> と "
"B<IN_MOVED_TO> イベントの組は、共有される cookie 値によって対応を取ることがで"
"きる。 しかし、対応を取る場合にはいくつか難しい点がある。"

#. type: Plain text
#: build/C/man7/inotify.7:769
msgid ""
"These two events are usually consecutive in the event stream available when "
"reading from the inotify file descriptor.  However, this is not guaranteed.  "
"If multiple processes are triggering events for monitored objects, then (on "
"rare occasions) an arbitrary number of other events may appear between the "
"B<IN_MOVED_FROM> and B<IN_MOVED_TO> events.  Furthermore, it is not "
"guaranteed that the event pair is atomically inserted into the queue: there "
"may be a brief interval where the B<IN_MOVED_FROM> has appeared, but the "
"B<IN_MOVED_TO> has not."
msgstr ""
"これらの 2 つのイベントは、 inotify ファイルディスクリプターから読み出しを"
"行った場合に、通常はイベントストリーム内で連続している。 しかしながら、連続し"
"ていることは保証されていない。 複数のプロセスが監視対象オブジェクトでイベント"
"を発生させた場合、 (めったに起こらないことだが) イベント B<IN_MOVED_FROM> と "
"B<IN_MOVED_TO> の間に任意の数の他のイベントがはさまる可能性がある。 さらに、"
"対となるイベントがアトミックにキューに挿入されることも保証されていない。 "
"B<IN_MOVED_FROM> が現れたが B<IN_MOVED_TO> は現れていないという短い期間があり"
"えるということだ。"

#. type: Plain text
#: build/C/man7/inotify.7:794
msgid ""
"Matching up the B<IN_MOVED_FROM> and B<IN_MOVED_TO> event pair generated by "
"B<rename>(2)  is thus inherently racy.  (Don't forget that if an object is "
"renamed outside of a monitored directory, there may not even be an "
"B<IN_MOVED_TO> event.)  Heuristic approaches (e.g., assume the events are "
"always consecutive)  can be used to ensure a match in most cases, but will "
"inevitably miss some cases, causing the application to perceive the "
"B<IN_MOVED_FROM> and B<IN_MOVED_TO> events as being unrelated.  If watch "
"descriptors are destroyed and re-created as a result, then those watch "
"descriptors will be inconsistent with the watch descriptors in any pending "
"events.  (Re-creating the inotify file descriptor and rebuilding the cache "
"may be useful to deal with this scenario.)"
msgstr ""
"したがって、 B<rename>(2) により生成された B<IN_MOVED_FROM> と "
"B<IN_MOVED_TO> のイベントの組の対応を取るのは本質的に難しいことである (監視対"
"象のディレクトリの外へオブジェクトの rename が行われた場合には "
"B<IN_MOVED_TO> イベントは存在しさえしないことを忘れてはならない)。 (イベント"
"は常に連続しているとの仮定を置くといった) 発見的な方法を使うと、ほとんどの場"
"合でイベントの組をうまく見つけることができるが、 いくつかの場合に見逃すことが"
"避けられず、 アプリケーションが B<IN_MOVED_FROM> と B<IN_MOVED_TO> イベントが"
"無関係だとみなしてしまう可能性がある。 結果的に、監視対象ディスクリプターが破"
"棄され再作成された場合、これらの監視対象ディスクリプターは、処理待ちイベント"
"の監視対象ディスクリプターと一貫性のないものになってしまう (inotify ファイル"
"ディスクリプターの再作成とキャッシュの再構成はこの状況に対処するのに有用な方"
"法なのだが)。"

#. type: Plain text
#: build/C/man7/inotify.7:811
msgid ""
"Applications should also allow for the possibility that the B<IN_MOVED_FROM> "
"event was the last event that could fit in the buffer returned by the "
"current call to B<read>(2), and the accompanying B<IN_MOVED_TO> event might "
"be fetched only on the next B<read>(2), which should be done with a (small) "
"timeout to allow for the fact that insertion of the B<IN_MOVED_FROM>-"
"B<IN_MOVED_TO> event pair is not atomic, and also the possibility that there "
"may not be any B<IN_MOVED_TO> event."
msgstr ""
"また、アプリケーションは、 B<IN_MOVED_FROM> イベントが今行った B<read>(2) の"
"呼び出しで返されたバッファーのちょうど一番最後のイベントで、 B<IN_MOVED_TO> "
"イベントは次の B<read>(2) を行わないと取得できない可能性も考慮に入れる必要が"
"ある。 2 つ目の B<read>(2) は (短い) タイムアウトで行うべきである。 これは、 "
"B<IN_MOVED_FROM>-B<IN_MOVED_TO> のイベントペアのキューへの挿入はアトミックで"
"はなく、 また B<IN_MOVED_TO> イベントが全く発生しない可能性もあるという事実を"
"考慮に入れておく必要があるからである。"

#.  commit 820c12d5d6c0890bc93dd63893924a13041fdc35
#. type: Plain text
#: build/C/man7/inotify.7:822
msgid ""
"Before Linux 3.19, B<fallocate>(2)  did not create any inotify events.  "
"Since Linux 3.19, calls to B<fallocate>(2)  generate B<IN_MODIFY> events."
msgstr ""

#.  FIXME . kernel commit 611da04f7a31b2208e838be55a42c7a1310ae321
#.  implies that unmount events were buggy 2.6.11 to 2.6.36
#. type: Plain text
#: build/C/man7/inotify.7:830
msgid "In kernels before 2.6.16, the B<IN_ONESHOT> I<mask> flag does not work."
msgstr "2.6.16 以前のカーネルでは B<IN_ONESHOT> I<mask> フラグが働かない。"

#. type: Plain text
#: build/C/man7/inotify.7:840
msgid ""
"As originally designed and implemented, the B<IN_ONESHOT> flag did not cause "
"an B<IN_IGNORED> event to be generated when the watch was dropped after one "
"event.  However, as an unintended effect of other changes, since Linux "
"2.6.36, an B<IN_IGNORED> event is generated in this case."
msgstr ""
"元々は設計/実装時の意図通り、 イベントが一つ発生し watch が削除された際に "
"B<IN_ONESHOT> フラグでは B<IN_IGNORED> イベントが発生しなかった。 しかし、 別"
"の変更での意図していなかった影響により、 Linux 2.6.36 以降では、 この場合に "
"B<IN_IGNORED> イベントが生成される。"

#.  commit 1c17d18e3775485bf1e0ce79575eb637a94494a2
#. type: Plain text
#: build/C/man7/inotify.7:849
msgid ""
"Before kernel 2.6.25, the kernel code that was intended to coalesce "
"successive identical events (i.e., the two most recent events could "
"potentially be coalesced if the older had not yet been read)  instead "
"checked if the most recent event could be coalesced with the I<oldest> "
"unread event."
msgstr ""
"カーネル 2.6.25 より前では、 連続する同一のイベントを一つにまとめることを意図"
"したコード (古い方のイベントがまだ読み込まれていない場合に、 最新の 2 つのイ"
"ベントを一つにまとめられる可能性がある) が、 最新のイベントが「最も古い」読み"
"込まれていないイベントとまとめられるか をチェックするようになっていた。"

#.  FIXME . https://bugzilla.kernel.org/show_bug.cgi?id=77111
#. type: Plain text
#: build/C/man7/inotify.7:879
msgid ""
"When a watch descriptor is removed by calling B<inotify_rm_watch>(2)  (or "
"because a watch file is deleted or the filesystem that contains it is "
"unmounted), any pending unread events for that watch descriptor remain "
"available to read.  As watch descriptors are subsequently allocated with "
"B<inotify_add_watch>(2), the kernel cycles through the range of possible "
"watch descriptors (0 to B<INT_MAX>)  incrementally.  When allocating a free "
"watch descriptor, no check is made to see whether that watch descriptor "
"number has any pending unread events in the inotify queue.  Thus, it can "
"happen that a watch descriptor is reallocated even when pending unread "
"events exist for a previous incarnation of that watch descriptor number, "
"with the result that the application might then read those events and "
"interpret them as belonging to the file associated with the newly recycled "
"watch descriptor.  In practice, the likelihood of hitting this bug may be "
"extremely low, since it requires that an application cycle through "
"B<INT_MAX> watch descriptors, release a watch descriptor while leaving "
"unread events for that watch descriptor in the queue, and then recycle that "
"watch descriptor.  For this reason, and because there have been no reports "
"of the bug occurring in real-world applications, as of Linux 3.15, no kernel "
"changes have yet been made to eliminate this possible bug."
msgstr ""
"B<inotify_rm_watch>(2) の呼び出しにより監視対象ディスクリプターが削除された場"
"合 (なお、監視対象ファイルの削除や監視対象ファイルが含まれるファイルシステム"
"のアンマウントによっても監視対象ディスクリプターは削除される)、 この監視対象"
"ディスクリプター関連の処理待ちの未読み出しイベントは、 読み出し可能なままとな"
"る。 監視対象ディスクリプターは B<inotify_add_watch>(2) によって後で割り当て"
"られるため、 カーネルは利用可能な監視対象ディスクリプターの範囲 (0 から "
"B<INT_MAX>) から昇順にサイクリックに割り当てを行う。未使用の監視対象ディスク"
"リプターを割り当てる際、 その監視対象ディスクリプター番号に inotify キューで"
"処理待ちの未読み出しイベントがあるかの確認は行われない。 したがって、監視対象"
"ディスクリプターが再割り当てされた際に、 その監視対象ディスクリプターの一つ前"
"の使用時に発生した処理待ちの未読み出しイベントが存在するということが起こりう"
"る。 その結果、アプリケーションはこれらのイベントを読み出す可能性があり、 こ"
"れらのイベントが新しく再利用された監視対象ディスクリプターに関連付けられた"
"ファイルに属するものかを解釈する必要が出て来る。 実際のところ、このバグを踏む"
"可能性は極めて低い。 それは、このバグを踏むためには、アプリケーションが "
"B<INT_MAX> 個の監視対象ディスクリプターが一周させて、 キューに未読み出しイベ"
"ントが残っている監視対象ディスクリプターを解放し、 その監視対象ディスクリプ"
"ターを再利用する必要があるからである。 この理由と、実世界のアプリケーションで"
"発生したというバグ報告がないことから、 Linux 3.15 時点では、この計算上は起こ"
"りうるバグを取り除くためのカーネルの変更は行われていない。"

#. type: Plain text
#: build/C/man7/inotify.7:887
msgid ""
"The following program demonstrates the usage of the inotify API.  It marks "
"the directories passed as a command-line arguments and waits for events of "
"type B<IN_OPEN>, B<IN_CLOSE_NOWRITE>, and B<IN_CLOSE_WRITE>."
msgstr ""
"以下のプログラムは inotify API の使用例を示したものである。 コマンドライン引"
"数で渡されたディレクトリに印を付け、 タイプが B<IN_OPEN>, "
"B<IN_CLOSE_NOWRITE> B<IN_CLOSE_WRITE> のイベントを待つ。"

#. type: Plain text
#: build/C/man7/inotify.7:902
msgid ""
"The following output was recorded while editing the file I</home/user/temp/"
"foo> and listing directory I</tmp>.  Before the file and the directory were "
"opened, B<IN_OPEN> events occurred.  After the file was closed, an "
"B<IN_CLOSE_WRITE> event occurred.  After the directory was closed, an "
"B<IN_CLOSE_NOWRITE> event occurred.  Execution of the program ended when the "
"user pressed the ENTER key."
msgstr ""
"以下は、 ファイル I</home/user/temp/foo> を編集し、 ディレクトリ I</tmp> の一"
"覧表示を行った場合の出力である。 対象のファイルとディレクトリがオープンされる"
"前に、イベント B<IN_OPEN> が発生している。 対象ファイルがクローズされた後にイ"
"ベント B<IN_CLOSE_WRITE> が発生している。 対象ディレクトリがクローズされた後"
"にイベント B<IN_CLOSE_NOWRITE> が発生している。 ユーザーが ENTER キーを押する"
"と、プログラムの実行は終了する。"

#. type: SS
#: build/C/man7/inotify.7:902
#, no-wrap
msgid "Example output"
msgstr "出力例"

#. type: Plain text
#: build/C/man7/inotify.7:912
#, no-wrap
msgid ""
"$ B<./a.out /tmp /home/user/temp>\n"
"Press enter key to terminate.\n"
"Listening for events.\n"
"IN_OPEN: /home/user/temp/foo [file]\n"
"IN_CLOSE_WRITE: /home/user/temp/foo [file]\n"
"IN_OPEN: /tmp/ [directory]\n"
"IN_CLOSE_NOWRITE: /tmp/ [directory]\n"
msgstr ""
"$ B<./a.out /tmp /home/user/temp>\n"
"Press enter key to terminate.\n"
"Listening for events.\n"
"IN_OPEN: /home/user/temp/foo [file]\n"
"IN_CLOSE_WRITE: /home/user/temp/foo [file]\n"
"IN_OPEN: /tmp/ [directory]\n"
"IN_CLOSE_NOWRITE: /tmp/ [directory]\n"

#. type: SS
#: build/C/man7/inotify.7:916
#, no-wrap
msgid "Program source"
msgstr "プログラムソース"

#. type: Plain text
#: build/C/man7/inotify.7:926
#, no-wrap
msgid ""
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>poll.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/inotify.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>poll.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/inotify.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"

#. type: Plain text
#: build/C/man7/inotify.7:932
#, no-wrap
msgid ""
"/* Read all available inotify events from the file descriptor \\(aqfd\\(aq.\n"
"   wd is the table of watch descriptors for the directories in argv.\n"
"   argc is the length of wd and argv.\n"
"   argv is the list of watched directories.\n"
"   Entry 0 of wd and argv is unused. */\n"
msgstr ""
"/* Read all available inotify events from the file descriptor \\(aqfd\\(aq.\n"
"   wd is the table of watch descriptors for the directories in argv.\n"
"   argc is the length of wd and argv.\n"
"   argv is the list of watched directories.\n"
"   Entry 0 of wd and argv is unused. */\n"

#. type: Plain text
#: build/C/man7/inotify.7:941
#, no-wrap
msgid ""
"static void\n"
"handle_events(int fd, int *wd, int argc, char* argv[])\n"
"{\n"
"    /* Some systems cannot read integer variables if they are not\n"
"       properly aligned. On other systems, incorrect alignment may\n"
"       decrease performance. Hence, the buffer used for reading from\n"
"       the inotify file descriptor should have the same alignment as\n"
"       struct inotify_event. */\n"
msgstr ""
"static void\n"
"handle_events(int fd, int *wd, int argc, char* argv[])\n"
"{\n"
"    /* Some systems cannot read integer variables if they are not\n"
"       properly aligned. On other systems, incorrect alignment may\n"
"       decrease performance. Hence, the buffer used for reading from\n"
"       the inotify file descriptor should have the same alignment as\n"
"       struct inotify_event. */\n"

#. type: Plain text
#: build/C/man7/inotify.7:946
#, no-wrap
msgid ""
"    char buf[4096]\n"
"        __attribute__ ((aligned(__alignof__(struct inotify_event))));\n"
"    const struct inotify_event *event;\n"
"    ssize_t len;\n"
msgstr ""
"    char buf[4096]\n"
"        __attribute__ ((aligned(__alignof__(struct inotify_event))));\n"
"    const struct inotify_event *event;\n"
"    ssize_t len;\n"

#. type: Plain text
#: build/C/man7/inotify.7:948
#, no-wrap
msgid "    /* Loop while events can be read from inotify file descriptor. */\n"
msgstr "    /* Loop while events can be read from inotify file descriptor. */\n"

#. type: Plain text
#: build/C/man7/inotify.7:952
#, no-wrap
msgid "        /* Read some events. */\n"
msgstr "        /* Read some events. */\n"

#. type: Plain text
#: build/C/man7/inotify.7:962
#, no-wrap
msgid ""
"        /* If the nonblocking read() found no events to read, then\n"
"           it returns -1 with errno set to EAGAIN. In that case,\n"
"           we exit the loop. */\n"
msgstr ""
"        /* If the nonblocking read() found no events to read, then\n"
"           it returns -1 with errno set to EAGAIN. In that case,\n"
"           we exit the loop. */\n"

#. type: Plain text
#: build/C/man7/inotify.7:970
#, no-wrap
msgid ""
"        for (char *ptr = buf; ptr E<lt> buf + len;\n"
"                ptr += sizeof(struct inotify_event) + event-E<gt>len) {\n"
msgstr ""
"        for (char *ptr = buf; ptr E<lt> buf + len;\n"
"                ptr += sizeof(struct inotify_event) + event-E<gt>len) {\n"

#. type: Plain text
#: build/C/man7/inotify.7:972
#, no-wrap
msgid "            event = (const struct inotify_event *) ptr;\n"
msgstr "            event = (const struct inotify_event *) ptr;\n"

#. type: Plain text
#: build/C/man7/inotify.7:974
#, no-wrap
msgid "            /* Print event type */\n"
msgstr "            /* Print event type */\n"

#. type: Plain text
#: build/C/man7/inotify.7:981
#, no-wrap
msgid ""
"            if (event-E<gt>mask & IN_OPEN)\n"
"                printf(\"IN_OPEN: \");\n"
"            if (event-E<gt>mask & IN_CLOSE_NOWRITE)\n"
"                printf(\"IN_CLOSE_NOWRITE: \");\n"
"            if (event-E<gt>mask & IN_CLOSE_WRITE)\n"
"                printf(\"IN_CLOSE_WRITE: \");\n"
msgstr ""
"            if (event-E<gt>mask & IN_OPEN)\n"
"                printf(\"IN_OPEN: \");\n"
"            if (event-E<gt>mask & IN_CLOSE_NOWRITE)\n"
"                printf(\"IN_CLOSE_NOWRITE: \");\n"
"            if (event-E<gt>mask & IN_CLOSE_WRITE)\n"
"                printf(\"IN_CLOSE_WRITE: \");\n"

#. type: Plain text
#: build/C/man7/inotify.7:983
#, no-wrap
msgid "            /* Print the name of the watched directory */\n"
msgstr "            /* Print the name of the watched directory */\n"

#. type: Plain text
#: build/C/man7/inotify.7:990
#, no-wrap
msgid ""
"            for (int i = 1; i E<lt> argc; ++i) {\n"
"                if (wd[i] == event-E<gt>wd) {\n"
"                    printf(\"%s/\", argv[i]);\n"
"                    break;\n"
"                }\n"
"            }\n"
msgstr ""
"            for (int i = 1; i E<lt> argc; ++i) {\n"
"                if (wd[i] == event-E<gt>wd) {\n"
"                    printf(\"%s/\", argv[i]);\n"
"                    break;\n"
"                }\n"
"            }\n"

#. type: Plain text
#: build/C/man7/inotify.7:992
#, no-wrap
msgid "            /* Print the name of the file */\n"
msgstr "            /* Print the name of the file */\n"

#. type: Plain text
#: build/C/man7/inotify.7:995
#, no-wrap
msgid ""
"            if (event-E<gt>len)\n"
"                printf(\"%s\", event-E<gt>name);\n"
msgstr ""
"            if (event-E<gt>len)\n"
"                printf(\"%s\", event-E<gt>name);\n"

#. type: Plain text
#: build/C/man7/inotify.7:997
#, no-wrap
msgid "            /* Print type of filesystem object */\n"
msgstr "            /* Print type of filesystem object */\n"

#. type: Plain text
#: build/C/man7/inotify.7:1005
#, no-wrap
msgid ""
"            if (event-E<gt>mask & IN_ISDIR)\n"
"                printf(\" [directory]\\en\");\n"
"            else\n"
"                printf(\" [file]\\en\");\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""
"            if (event-E<gt>mask & IN_ISDIR)\n"
"                printf(\" [directory]\\en\");\n"
"            else\n"
"                printf(\" [file]\\en\");\n"
"        }\n"
"    }\n"
"}\n"

#. type: Plain text
#: build/C/man7/inotify.7:1014
#, no-wrap
msgid ""
"int\n"
"main(int argc, char* argv[])\n"
"{\n"
"    char buf;\n"
"    int fd, i, poll_num;\n"
"    int *wd;\n"
"    nfds_t nfds;\n"
"    struct pollfd fds[2];\n"
msgstr ""
"int\n"
"main(int argc, char* argv[])\n"
"{\n"
"    char buf;\n"
"    int fd, i, poll_num;\n"
"    int *wd;\n"
"    nfds_t nfds;\n"
"    struct pollfd fds[2];\n"

#. type: Plain text
#: build/C/man7/inotify.7:1019
#, no-wrap
msgid ""
"    if (argc E<lt> 2) {\n"
"        printf(\"Usage: %s PATH [PATH ...]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc E<lt> 2) {\n"
"        printf(\"Usage: %s PATH [PATH ...]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man7/inotify.7:1021
#, no-wrap
msgid "    printf(\"Press ENTER key to terminate.\\en\");\n"
msgstr "    printf(\"Press ENTER key to terminate.\\en\");\n"

#. type: Plain text
#: build/C/man7/inotify.7:1023
#, no-wrap
msgid "    /* Create the file descriptor for accessing the inotify API */\n"
msgstr "    /* Create the file descriptor for accessing the inotify API */\n"

#. type: Plain text
#: build/C/man7/inotify.7:1029
#, no-wrap
msgid ""
"    fd = inotify_init1(IN_NONBLOCK);\n"
"    if (fd == -1) {\n"
"        perror(\"inotify_init1\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    fd = inotify_init1(IN_NONBLOCK);\n"
"    if (fd == -1) {\n"
"        perror(\"inotify_init1\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man7/inotify.7:1031
#, no-wrap
msgid "    /* Allocate memory for watch descriptors */\n"
msgstr "    /* Allocate memory for watch descriptors */\n"

#. type: Plain text
#: build/C/man7/inotify.7:1037
#, no-wrap
msgid ""
"    wd = calloc(argc, sizeof(int));\n"
"    if (wd == NULL) {\n"
"        perror(\"calloc\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    wd = calloc(argc, sizeof(int));\n"
"    if (wd == NULL) {\n"
"        perror(\"calloc\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man7/inotify.7:1041
#, no-wrap
msgid ""
"    /* Mark directories for events\n"
"       - file was opened\n"
"       - file was closed */\n"
msgstr ""
"    /* Mark directories for events\n"
"       - file was opened\n"
"       - file was closed */\n"

#. type: Plain text
#: build/C/man7/inotify.7:1051
#, no-wrap
msgid ""
"    for (i = 1; i E<lt> argc; i++) {\n"
"        wd[i] = inotify_add_watch(fd, argv[i],\n"
"                                  IN_OPEN | IN_CLOSE);\n"
"        if (wd[i] == -1) {\n"
"            fprintf(stderr, \"Cannot watch \\(aq%s\\(aq: %s\\en\",\n"
"                    argv[i], strerror(errno));\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"    }\n"
msgstr ""
"    for (i = 1; i E<lt> argc; i++) {\n"
"        wd[i] = inotify_add_watch(fd, argv[i],\n"
"                                  IN_OPEN | IN_CLOSE);\n"
"        if (wd[i] == -1) {\n"
"            fprintf(stderr, \"Cannot watch \\(aq%s\\(aq: %s\\en\",\n"
"                    argv[i], strerror(errno));\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"    }\n"

#. type: Plain text
#: build/C/man7/inotify.7:1062
#, no-wrap
msgid "    /* Inotify input */\n"
msgstr "    /* Inotify input */\n"

#. type: Plain text
#: build/C/man7/inotify.7:1067
#, no-wrap
msgid "    /* Wait for events and/or terminal input */\n"
msgstr "    /* Wait for events and/or terminal input */\n"

#. type: Plain text
#: build/C/man7/inotify.7:1077
#, no-wrap
msgid ""
"    printf(\"Listening for events.\\en\");\n"
"    while (1) {\n"
"        poll_num = poll(fds, nfds, -1);\n"
"        if (poll_num == -1) {\n"
"            if (errno == EINTR)\n"
"                continue;\n"
"            perror(\"poll\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""
"    printf(\"Listening for events.\\en\");\n"
"    while (1) {\n"
"        poll_num = poll(fds, nfds, -1);\n"
"        if (poll_num == -1) {\n"
"            if (errno == EINTR)\n"
"                continue;\n"
"            perror(\"poll\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"

#. type: Plain text
#: build/C/man7/inotify.7:1079
#, no-wrap
msgid "        if (poll_num E<gt> 0) {\n"
msgstr "        if (poll_num E<gt> 0) {\n"

#. type: Plain text
#: build/C/man7/inotify.7:1081
#, no-wrap
msgid "            if (fds[0].revents & POLLIN) {\n"
msgstr "            if (fds[0].revents & POLLIN) {\n"

#. type: Plain text
#: build/C/man7/inotify.7:1083
#, no-wrap
msgid "                /* Console input is available. Empty stdin and quit */\n"
msgstr "                /* Console input is available. Empty stdin and quit */\n"

#. type: Plain text
#: build/C/man7/inotify.7:1092
#, no-wrap
msgid "                /* Inotify events are available */\n"
msgstr "                /* Inotify events are available */\n"

#. type: Plain text
#: build/C/man7/inotify.7:1097
#, no-wrap
msgid ""
"                handle_events(fd, wd, argc, argv);\n"
"            }\n"
"        }\n"
"    }\n"
msgstr ""
"                handle_events(fd, wd, argc, argv);\n"
"            }\n"
"        }\n"
"    }\n"

#. type: Plain text
#: build/C/man7/inotify.7:1099
#, no-wrap
msgid "    printf(\"Listening for events stopped.\\en\");\n"
msgstr "    printf(\"Listening for events stopped.\\en\");\n"

#. type: Plain text
#: build/C/man7/inotify.7:1101
#, no-wrap
msgid "    /* Close inotify file descriptor */\n"
msgstr "    /* Close inotify file descriptor */\n"

#. type: Plain text
#: build/C/man7/inotify.7:1103
#, no-wrap
msgid "    close(fd);\n"
msgstr "    close(fd);\n"

#. type: Plain text
#: build/C/man7/inotify.7:1107
#, no-wrap
msgid ""
"    free(wd);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    free(wd);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man7/inotify.7:1118
msgid ""
"B<inotifywait>(1), B<inotifywatch>(1), B<inotify_add_watch>(2), "
"B<inotify_init>(2), B<inotify_init1>(2), B<inotify_rm_watch>(2), B<read>(2), "
"B<stat>(2), B<fanotify>(7)"
msgstr ""
"B<inotifywait>(1), B<inotifywatch>(1), B<inotify_add_watch>(2), "
"B<inotify_init>(2), B<inotify_init1>(2), B<inotify_rm_watch>(2), B<read>(2), "
"B<stat>(2), B<fanotify>(7)"

#. type: Plain text
#: build/C/man7/inotify.7:1121
msgid ""
"I<Documentation/filesystems/inotify.txt> in the Linux kernel source tree"
msgstr "Linux カーネルソース内の I<Documentation/filesystems/inotify.txt>"

#. type: TH
#: build/C/man2/inotify_add_watch.2:28
#, no-wrap
msgid "INOTIFY_ADD_WATCH"
msgstr "INOTIFY_ADD_WATCH"

#. type: TH
#: build/C/man2/inotify_add_watch.2:28 build/C/man2/inotify_init.2:29
#, no-wrap
msgid "2020-04-11"
msgstr "2020-04-11"

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:31
msgid "inotify_add_watch - add a watch to an initialized inotify instance"
msgstr ""
"inotify_add_watch - 初期化済み inotify インスタンスに監視対象を追加する"

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:33 build/C/man2/inotify_rm_watch.2:32
msgid "B<#include E<lt>sys/inotify.hE<gt>>"
msgstr "B<#include E<lt>sys/inotify.hE<gt>>"

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:35
msgid ""
"B<int inotify_add_watch(int >I<fd>B<, const char *>I<pathname>B<, uint32_t "
">I<mask>B<);>"
msgstr ""
"B<int inotify_add_watch(int >I<fd>B<, const char *>I<pathname>B<, uint32_t "
">I<mask>B<);>"

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:54
msgid ""
"B<inotify_add_watch>()  adds a new watch, or modifies an existing watch, for "
"the file whose location is specified in I<pathname>; the caller must have "
"read permission for this file.  The I<fd> argument is a file descriptor "
"referring to the inotify instance whose watch list is to be modified.  The "
"events to be monitored for I<pathname> are specified in the I<mask> bit-mask "
"argument.  See B<inotify>(7)  for a description of the bits that can be set "
"in I<mask>."
msgstr ""
"B<inotify_add_watch>()  は、 I<pathname> で指定された位置にあるファイルを監視"
"する監視アイテム (watch) の新規追加、 または既存の監視アイテムの変更を行う。 "
"呼び出し元は、監視対象のファイルに対する読み出し許可を 持っていなければならな"
"い。 I<fd> 引数は、変更を行う監視対象リスト (watch list) を持つ inotify イ"
"ンスタンスを参照するファイルディスクリプターである。 I<pathname> のどのイベン"
"トを監視するかは、引数のビットマスク I<mask> で指定する。 I<mask> に設定で"
"きるビットの説明については B<inotify>(7)  を参照のこと。"

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:66
msgid ""
"A successful call to B<inotify_add_watch>()  returns a unique watch "
"descriptor for this inotify instance, for the filesystem object (inode) that "
"corresponds to I<pathname>.  If the filesystem object was not previously "
"being watched by this inotify instance, then the watch descriptor is newly "
"allocated.  If the filesystem object was already being watched (perhaps via "
"a different link to the same object), then the descriptor for the existing "
"watch is returned."
msgstr "B<inotify_add_watch>() の呼び出しが成功すると、 I<pathname> に対応するファイルシステムオブジェクト (inode) に対する、 一意な監視対象ディスクリプター (watch descriptor) を、 対象の inotify インスタンスに対して返す。 そのファイルシステムオブジェクトが対象の inotify インスタンスによって以前に監視されていない場合には、 監視対象ディスクリプターは新規に割り当てられる。 ファイルシステムオブジェクトが (おそらく同じオブジェクトに対する異なるリンク経由で) すでに監視されている場合には、 既存の監視に対するディスクリプターが返される。"

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:77
msgid ""
"The watch descriptor is returned by later B<read>(2)s from the inotify file "
"descriptor.  These reads fetch I<inotify_event> structures (see "
"B<inotify>(7))  indicating filesystem events; the watch descriptor inside "
"this structure identifies the object for which the event occurred."
msgstr ""
"これ以降に inotify ファイルディスクリプターから B<read>(2)  を行うと、監視対"
"象ディスクリプターが返される。 これらの B<read>()  を行うと、ファイルシステム"
"イベントを示す I<inotify_event> 構造体が読み出される (B<inotify>(7)  参照)。"
"この構造体内の監視対象ディスクリプターにより、 どのオブジェクトでそのイベント"
"が発生したかを特定できる。"

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:84
msgid ""
"On success, B<inotify_add_watch>()  returns a watch descriptor (a "
"nonnegative integer).  On error, -1 is returned and I<errno> is set "
"appropriately."
msgstr "成功すると、 B<inotify_add_watch>()  は非負の監視対象ディスクリプター (非負の整数) を返す。 エラーの場合、-1 を返し、 I<errno> を適切に設定する。"

#. type: TP
#: build/C/man2/inotify_add_watch.2:85
#, no-wrap
msgid "B<EACCES>"
msgstr "B<EACCES>"

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:88
msgid "Read access to the given file is not permitted."
msgstr "指定されたファイルに対する読み出しアクセスが許可されていない。"

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:91
msgid "The given file descriptor is not valid."
msgstr "指定されたファイルディスクリプターが有効ではない。"

#. type: TP
#: build/C/man2/inotify_add_watch.2:91
#, no-wrap
msgid "B<EEXIST>"
msgstr "B<EEXIST>"

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:100
msgid ""
"I<mask> contains B<IN_MASK_CREATE> and I<pathname> refers to a file already "
"being watched by the same I<fd>."
msgstr ""

#. type: TP
#: build/C/man2/inotify_add_watch.2:100
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:104
msgid "I<pathname> points outside of the process's accessible address space."
msgstr ""
"I<pathname> が指すアドレスがプロセスがアクセスできるアドレス空間外である。"

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:115
#, fuzzy
#| msgid ""
#| "The given event mask contains no valid events; or I<fd> is not an inotify "
#| "file descriptor."
msgid ""
"The given event mask contains no valid events; or I<mask> contains both "
"B<IN_MASK_ADD> and B<IN_MASK_CREATE>; or I<fd> is not an inotify file "
"descriptor."
msgstr ""
"指定されたイベントマスクに有効なイベントが含まれていない。 もしくは I<fd> が "
"inotify ファイルディスクリプターではない。"

#. type: TP
#: build/C/man2/inotify_add_watch.2:115
#, no-wrap
msgid "B<ENAMETOOLONG>"
msgstr "B<ENAMETOOLONG>"

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:119
msgid "I<pathname> is too long."
msgstr "I<pathname> が長過ぎる。"

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:124
msgid ""
"A directory component in I<pathname> does not exist or is a dangling "
"symbolic link."
msgstr ""
"I<pathname> のディレクトリ部分の構成要素が、存在しないか、\n"
"リンク切れのシンボリックリンクである。"

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:127
msgid "Insufficient kernel memory was available."
msgstr "カーネルメモリーが十分になかった。"

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:131
msgid ""
"The user limit on the total number of inotify watches was reached or the "
"kernel failed to allocate a needed resource."
msgstr ""
"inotify 監視対象の総数がユーザーが追加できる上限に達していた。 もしくは、必要"
"な資源の割り当てにカーネルが失敗した。"

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:139
#, fuzzy
#| msgid ""
#| "I<flags> contains B<FAN_MARK_ONLYDIR>, and I<dirfd> and I<pathname> do "
#| "not specify a directory."
msgid "I<mask> contains B<IN_ONLYDIR> and I<pathname> is not a directory."
msgstr ""
"I<flags> に B<FAN_MARK_ONLYDIR> が含まれているが、 I<dirfd> と I<pathname> が"
"ディレクトリを指定していない。"

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:141 build/C/man2/inotify_rm_watch.2:69
msgid "Inotify was merged into the 2.6.13 Linux kernel."
msgstr "inotify は Linux カーネル 2.6.13 に組み込まれた。"

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:146
msgid "See B<inotify>(7)."
msgstr "B<inotify>(7) 参照。"

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:150
msgid "B<inotify_init>(2), B<inotify_rm_watch>(2), B<inotify>(7)"
msgstr "B<inotify_init>(2), B<inotify_rm_watch>(2), B<inotify>(7)"

#. type: TH
#: build/C/man2/inotify_init.2:29
#, no-wrap
msgid "INOTIFY_INIT"
msgstr "INOTIFY_INIT"

#. type: Plain text
#: build/C/man2/inotify_init.2:32
msgid "inotify_init, inotify_init1 - initialize an inotify instance"
msgstr "inotify_init, inotify_init1 - inotify インスタンスを初期化する"

#. type: Plain text
#: build/C/man2/inotify_init.2:35
#, no-wrap
msgid "B<#include E<lt>sys/inotify.hE<gt>>\n"
msgstr "B<#include E<lt>sys/inotify.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/inotify_init.2:38
#, no-wrap
msgid ""
"B<int inotify_init(void);>\n"
"B<int inotify_init1(int >I<flags>B<);>\n"
msgstr ""
"B<int inotify_init(void);>\n"
"B<int inotify_init1(int >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man2/inotify_init.2:42
msgid "For an overview of the inotify API, see B<inotify>(7)."
msgstr "inotify API の概要については B<inotify>(7) を参照。"

#. type: Plain text
#: build/C/man2/inotify_init.2:46
msgid ""
"B<inotify_init>()  initializes a new inotify instance and returns a file "
"descriptor associated with a new inotify event queue."
msgstr ""
"B<inotify_init>()  は、新規の inotify インスタンスを初期化し、作成された "
"inotify イベントキュー に対応するファイルディスクリプターを返す。"

#. type: Plain text
#: build/C/man2/inotify_init.2:56
msgid ""
"If I<flags> is 0, then B<inotify_init1>()  is the same as "
"B<inotify_init>().  The following values can be bitwise ORed in I<flags> to "
"obtain different behavior:"
msgstr ""
"B<inotify_init1>()  は、 I<flags> が 0 の場合、 B<inotify_init>()  と同じであ"
"る。 I<flags> に以下の値をビット毎の論理和 (OR) で指定することで、 異なる動作"
"をさせることができる。"

#. type: TP
#: build/C/man2/inotify_init.2:56
#, no-wrap
msgid "B<IN_NONBLOCK>"
msgstr "B<IN_NONBLOCK>"

#. type: Plain text
#: build/C/man2/inotify_init.2:66
#, fuzzy
#| msgid ""
#| "Set the B<O_NONBLOCK> file status flag on the new open file description.  "
#| "Using this flag saves extra calls to B<fcntl>(2)  to achieve the same "
#| "result."
msgid ""
"Set the B<O_NONBLOCK> file status flag on the open file description (see "
"B<open>(2))  referred to by the new file descriptor.  Using this flag saves "
"extra calls to B<fcntl>(2)  to achieve the same result."
msgstr ""
"新しく生成されるオープンファイル記述 (open file description) の BR "
"O_NONBLOCK ファイルステータスフラグをセットする。 このフラグを使うことで、 "
"B<O_NONBLOCK> をセットするために B<fcntl>(2)  を追加で呼び出す必要がなくな"
"る。"

#. type: TP
#: build/C/man2/inotify_init.2:66
#, no-wrap
msgid "B<IN_CLOEXEC>"
msgstr "B<IN_CLOEXEC>"

#. type: Plain text
#: build/C/man2/inotify_init.2:76
msgid ""
"Set the close-on-exec (B<FD_CLOEXEC>)  flag on the new file descriptor.  See "
"the description of the B<O_CLOEXEC> flag in B<open>(2)  for reasons why this "
"may be useful."
msgstr ""
"新しいファイルディスクリプターに対して close-on-exec (B<FD_CLOEXEC>)  フラグ"
"をセットする。 このフラグが役に立つ理由については、 B<open>(2)  の "
"B<O_CLOEXEC> フラグの説明を参照のこと。"

#. type: Plain text
#: build/C/man2/inotify_init.2:81
msgid ""
"On success, these system calls return a new file descriptor.  On error, -1 "
"is returned, and I<errno> is set to indicate the error."
msgstr ""
"成功すると、これらのシステムコールは新しいファイルディスクリプターを返す。 エ"
"ラーの場合、-1 を返し、 I<errno> をエラーを示す値に設定する。"

#. type: Plain text
#: build/C/man2/inotify_init.2:87
msgid "(B<inotify_init1>())  An invalid value was specified in I<flags>."
msgstr "(B<inotify_init1>())  無効な値が I<flags> に指定された。"

#. type: Plain text
#: build/C/man2/inotify_init.2:90
msgid ""
"The user limit on the total number of inotify instances has been reached."
msgstr "inotify インスタンスの総数がユーザー単位の上限に達していた。"

#. type: Plain text
#: build/C/man2/inotify_init.2:96
msgid ""
"The system-wide limit on the total number of open files has been reached."
msgstr "オープンされたファイルの総数がシステム全体の上限に達していた。"

#. type: Plain text
#: build/C/man2/inotify_init.2:99
msgid "Insufficient kernel memory is available."
msgstr "カーネルメモリーが十分になかった。"

#. type: Plain text
#: build/C/man2/inotify_init.2:106
msgid ""
"B<inotify_init>()  first appeared in Linux 2.6.13; library support was added "
"to glibc in version 2.4.  B<inotify_init1>()  was added in Linux 2.6.27; "
"library support was added to glibc in version 2.9."
msgstr ""
"B<inotify_init>()  は Linux 2.6.13 で初めて登場し、\n"
"ライブラリによるサポートは glibc バージョン 2.4 で追加された。\n"
"B<inotify_init1>()  は Linux 2.6.27 で追加され、\n"
"ライブラリによるサポートは glibc バージョン 2.9 で追加された。"

#. type: Plain text
#: build/C/man2/inotify_init.2:108
msgid "These system calls are Linux-specific."
msgstr "これらのシステムコールは Linux 独自である。"

#. type: Plain text
#: build/C/man2/inotify_init.2:112
msgid "B<inotify_add_watch>(2), B<inotify_rm_watch>(2), B<inotify>(7)"
msgstr "B<inotify_add_watch>(2), B<inotify_rm_watch>(2), B<inotify>(7)"

#. type: TH
#: build/C/man2/inotify_rm_watch.2:27
#, no-wrap
msgid "INOTIFY_RM_WATCH"
msgstr "INOTIFY_RM_WATCH"

#. type: TH
#: build/C/man2/inotify_rm_watch.2:27
#, no-wrap
msgid "2017-09-15"
msgstr "2017-09-15"

#. type: Plain text
#: build/C/man2/inotify_rm_watch.2:30
msgid "inotify_rm_watch - remove an existing watch from an inotify instance"
msgstr ""
"inotify_rm_watch - inotify インスタンスから既存の監視アイテムを削除する"

#.  Before glibc 2.10, the second argument was types as uint32_t.
#.  http://sources.redhat.com/bugzilla/show_bug.cgi?id=7040
#. type: Plain text
#: build/C/man2/inotify_rm_watch.2:36
msgid "B<int inotify_rm_watch(int >I<fd>B<, int >I<wd>B<);>"
msgstr "B<int inotify_rm_watch(int >I<fd>B<, int >I<wd>B<);>"

#. type: Plain text
#: build/C/man2/inotify_rm_watch.2:42
msgid ""
"B<inotify_rm_watch>()  removes the watch associated with the watch "
"descriptor I<wd> from the inotify instance associated with the file "
"descriptor I<fd>."
msgstr ""
"B<inotify_rm_watch>()  は、監視対象ディスクリプター (watch descriptor)  "
"I<wd> に対応する監視アイテムを、 ファイルディスクリプター I<fd> に対応する "
"inotify インスタンスから削除する。"

#. type: Plain text
#: build/C/man2/inotify_rm_watch.2:48
msgid ""
"Removing a watch causes an B<IN_IGNORED> event to be generated for this "
"watch descriptor.  (See B<inotify>(7).)"
msgstr ""
"監視対象を削除すると、 この監視対象ディスクリプターに対して B<IN_IGNORED> イ"
"ベントが生成される (B<inotify>(7)  参照)。"

#. type: Plain text
#: build/C/man2/inotify_rm_watch.2:55
msgid ""
"On success, B<inotify_rm_watch>()  returns zero.  On error, -1 is returned "
"and I<errno> is set to indicate the cause of the error."
msgstr ""
"成功すると、B<inotify_rm_watch>() は 0 を返す。 エラーの場合、-1 を返し、 "
"I<errno> をエラーの原因を示す値に設定する。"

#. type: Plain text
#: build/C/man2/inotify_rm_watch.2:60
msgid "I<fd> is not a valid file descriptor."
msgstr "I<fd> が有効なファイルディスクリプターではない。"

#. type: Plain text
#: build/C/man2/inotify_rm_watch.2:67
msgid ""
"The watch descriptor I<wd> is not valid; or I<fd> is not an inotify file "
"descriptor."
msgstr ""
"監視対象ディスクリプター I<wd> が有効でない。もしくは、 I<fd> が inotify ファ"
"イルディスクリプターではない。"

#. type: Plain text
#: build/C/man2/inotify_rm_watch.2:75
msgid "B<inotify_add_watch>(2), B<inotify_init>(2), B<inotify>(7)"
msgstr "B<inotify_add_watch>(2), B<inotify_init>(2), B<inotify>(7)"

#~ msgid "Calling B<fallocate>(2)  does not create any fanotify events."
#~ msgstr "B<fallocate>(2) の呼び出しでは fanotify イベントが作成されない。"

#~ msgid "As of Linux 3.17, the following bug exists:"
#~ msgstr "Linux 3.17 時点では、 以下のバグが存在する。"

#~ msgid ""
#~ "Create events for directories\\(emfor example, when B<opendir>(3), "
#~ "B<readdir>(3)  (but see BUGS), and B<closedir>(3)  are called.  Without "
#~ "this flag, only events for files are created."
#~ msgstr ""
#~ "ディレクトリに対するイベントを作成する。 例えば B<opendir>(3)、 "
#~ "B<readdir>(3) (ただし「バグ」も参照)、 B<closedir>(3) が呼び出された場"
#~ "合。 このフラグが指定されなかった場合、 ファイルに対するイベントだけが作成"
#~ "される。"

#~ msgid ""
#~ "The B<FIONREAD> B<ioctl>(2)  returns the number of bytes available to "
#~ "read from an inotify file descriptor."
#~ msgstr ""
#~ "B<FIONREAD> B<ioctl>(2)  は inotify ファイルディスクリプターから何バイト読"
#~ "み込めるかを返す。"

#~ msgid ""
#~ "As of kernel 3.17, calling B<fallocate>(2)  does not create any inotify "
#~ "events."
#~ msgstr ""
#~ "カーネル 3.17 時点では、 B<fallocate>(2) の呼び出しでは inotify イベントが"
#~ "生成されない。"
