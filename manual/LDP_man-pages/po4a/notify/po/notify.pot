# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-03-12 14:01+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man7/fanotify.7:25
#, no-wrap
msgid "FANOTIFY"
msgstr ""

#. type: TH
#: build/C/man7/fanotify.7:25 build/C/man2/fanotify_init.2:24 build/C/man2/fanotify_mark.2:24 build/C/man7/inotify.7:26
#, no-wrap
msgid "2020-11-01"
msgstr ""

#. type: TH
#: build/C/man7/fanotify.7:25 build/C/man2/fanotify_init.2:24 build/C/man2/fanotify_mark.2:24 build/C/man7/inotify.7:26 build/C/man2/inotify_add_watch.2:28 build/C/man2/inotify_init.2:29 build/C/man2/inotify_rm_watch.2:27
#, no-wrap
msgid "Linux"
msgstr ""

#. type: TH
#: build/C/man7/fanotify.7:25 build/C/man2/fanotify_init.2:24 build/C/man2/fanotify_mark.2:24 build/C/man7/inotify.7:26 build/C/man2/inotify_add_watch.2:28 build/C/man2/inotify_init.2:29 build/C/man2/inotify_rm_watch.2:27
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr ""

#. type: SH
#: build/C/man7/fanotify.7:26 build/C/man2/fanotify_init.2:25 build/C/man2/fanotify_mark.2:25 build/C/man7/inotify.7:27 build/C/man2/inotify_add_watch.2:29 build/C/man2/inotify_init.2:30 build/C/man2/inotify_rm_watch.2:28
#, no-wrap
msgid "NAME"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:28
msgid "fanotify - monitoring filesystem events"
msgstr ""

#. type: SH
#: build/C/man7/fanotify.7:28 build/C/man2/fanotify_init.2:33 build/C/man2/fanotify_mark.2:36 build/C/man7/inotify.7:29 build/C/man2/inotify_add_watch.2:35 build/C/man2/inotify_init.2:39 build/C/man2/inotify_rm_watch.2:36
#, no-wrap
msgid "DESCRIPTION"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:38
msgid ""
"The fanotify API provides notification and interception of filesystem "
"events.  Use cases include virus scanning and hierarchical storage "
"management.  In the original fanotify API, only a limited set of events was "
"supported.  In particular, there was no support for create, delete, and move "
"events.  The support for those events was added in Linux 5.1.  (See "
"B<inotify>(7)  for details of an API that did notify those events pre Linux "
"5.1.)"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:45
msgid ""
"Additional capabilities compared to the B<inotify>(7)  API include the "
"ability to monitor all of the objects in a mounted filesystem, the ability "
"to make access permission decisions, and the possibility to read or modify "
"files before access by other applications."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:53
msgid ""
"The following system calls are used with this API: B<fanotify_init>(2), "
"B<fanotify_mark>(2), B<read>(2), B<write>(2), and B<close>(2)."
msgstr ""

#. type: SS
#: build/C/man7/fanotify.7:53
#, no-wrap
msgid "fanotify_init(), fanotify_mark(), and notification groups"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:58
msgid ""
"The B<fanotify_init>(2)  system call creates and initializes an fanotify "
"notification group and returns a file descriptor referring to it."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:62
msgid ""
"An fanotify notification group is a kernel-internal object that holds a list "
"of files, directories, filesystems, and mount points for which events shall "
"be created."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:73
msgid ""
"For each entry in an fanotify notification group, two bit masks exist: the "
"I<mark> mask and the I<ignore> mask.  The mark mask defines file activities "
"for which an event shall be created.  The ignore mask defines activities for "
"which no event shall be generated.  Having these two types of masks permits "
"a filesystem, mount point, or directory to be marked for receiving events, "
"while at the same time ignoring events for specific objects under a mount "
"point or directory."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:79
msgid ""
"The B<fanotify_mark>(2)  system call adds a file, directory, filesystem or "
"mount point to a notification group and specifies which events shall be "
"reported (or ignored), or removes or modifies such an entry."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:92
msgid ""
"A possible usage of the ignore mask is for a file cache.  Events of interest "
"for a file cache are modification of a file and closing of the same.  Hence, "
"the cached directory or mount point is to be marked to receive these "
"events.  After receiving the first event informing that a file has been "
"modified, the corresponding cache entry will be invalidated.  No further "
"modification events for this file are of interest until the file is closed.  "
"Hence, the modify event can be added to the ignore mask.  Upon receiving the "
"close event, the modify event can be removed from the ignore mask and the "
"file cache entry can be updated."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:99
msgid ""
"The entries in the fanotify notification groups refer to files and "
"directories via their inode number and to mounts via their mount ID.  If "
"files or directories are renamed or moved within the same mount, the "
"respective entries survive.  If files or directories are deleted or moved to "
"another mount or if filesystems or mounts are unmounted, the corresponding "
"entries are deleted."
msgstr ""

#. type: SS
#: build/C/man7/fanotify.7:99
#, no-wrap
msgid "The event queue"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:108
msgid ""
"As events occur on the filesystem objects monitored by a notification group, "
"the fanotify system generates events that are collected in a queue.  These "
"events can then be read (using B<read>(2)  or similar)  from the fanotify "
"file descriptor returned by B<fanotify_init>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:121
msgid ""
"Two types of events are generated: I<notification> events and I<permission> "
"events.  Notification events are merely informative and require no action to "
"be taken by the receiving application with one exception: if a valid file "
"descriptor is provided within a generic event, the file descriptor must be "
"closed.  Permission events are requests to the receiving application to "
"decide whether permission for a file access shall be granted.  For these "
"events, the recipient must write a response which decides whether access is "
"granted or not."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:128
msgid ""
"An event is removed from the event queue of the fanotify group when it has "
"been read.  Permission events that have been read are kept in an internal "
"list of the fanotify group until either a permission decision has been taken "
"by writing to the fanotify file descriptor or the fanotify file descriptor "
"is closed."
msgstr ""

#. type: SS
#: build/C/man7/fanotify.7:128
#, no-wrap
msgid "Reading fanotify events"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:140
msgid ""
"Calling B<read>(2)  for the file descriptor returned by B<fanotify_init>(2)  "
"blocks (if the flag B<FAN_NONBLOCK> is not specified in the call to "
"B<fanotify_init>(2))  until either a file event occurs or the call is "
"interrupted by a signal (see B<signal>(7))."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:150
msgid ""
"The use of one of the flags B<FAN_REPORT_FID>, B<FAN_REPORT_DIR_FID> in "
"B<fanotify_init>(2)  influences what data structures are returned to the "
"event listener for each event.  Events reported to a group initialized with "
"one of these flags will use file handles to identify filesystem objects "
"instead of file descriptors."
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:150
#, no-wrap
msgid "After a successful"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:154
msgid ""
"B<read>(2), the read buffer contains one or more of the following "
"structures:"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:166
#, no-wrap
msgid ""
"struct fanotify_event_metadata {\n"
"    __u32 event_len;\n"
"    __u8 vers;\n"
"    __u8 reserved;\n"
"    __u16 metadata_len;\n"
"    __aligned_u64 mask;\n"
"    __s32 fd;\n"
"    __s32 pid;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:174
msgid ""
"In case of an fanotify group that identifies filesystem objects by file "
"handles, you should also expect to receive one or more additional "
"information records of the structure detailed below following the generic "
"I<fanotify_event_metadata> structure within the read buffer:"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:182
#, no-wrap
msgid ""
"struct fanotify_event_info_header {\n"
"    __u8 info_type;\n"
"    __u8 pad;\n"
"    __u16 len;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:188
#, no-wrap
msgid ""
"struct fanotify_event_info_fid {\n"
"    struct fanotify_event_info_header hdr;\n"
"    __kernel_fsid_t fsid;\n"
"    unsigned char file_handle[0];\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:195
msgid ""
"For performance reasons, it is recommended to use a large buffer size (for "
"example, 4096 bytes), so that multiple events can be retrieved by a single "
"B<read>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:200
msgid ""
"The return value of B<read>(2)  is the number of bytes placed in the buffer, "
"or -1 in case of an error (but see BUGS)."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:204
msgid "The fields of the I<fanotify_event_metadata> structure are as follows:"
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:204
#, no-wrap
msgid "I<event_len>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:215
msgid ""
"This is the length of the data for the current event and the offset to the "
"next event in the buffer.  Unless the group identifies filesystem objects by "
"file handles, the value of I<event_len> is always "
"B<FAN_EVENT_METADATA_LEN>.  For a group that identifies filesystem objects "
"by file handles, I<event_len> also includes the variable length file "
"identifier records."
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:215
#, no-wrap
msgid "I<vers>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:224
msgid ""
"This field holds a version number for the structure.  It must be compared to "
"B<FANOTIFY_METADATA_VERSION> to verify that the structures returned at run "
"time match the structures defined at compile time.  In case of a mismatch, "
"the application should abandon trying to use the fanotify file descriptor."
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:224
#, no-wrap
msgid "I<reserved>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:227
msgid "This field is not used."
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:227
#, no-wrap
msgid "I<metadata_len>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:233
msgid ""
"This is the length of the structure.  The field was introduced to facilitate "
"the implementation of optional headers per event type.  No such optional "
"headers exist in the current implementation."
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:233
#, no-wrap
msgid "I<mask>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:236
msgid "This is a bit mask describing the event (see below)."
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:236 build/C/man7/fanotify.7:576
#, no-wrap
msgid "I<fd>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:248
msgid ""
"This is an open file descriptor for the object being accessed, or "
"B<FAN_NOFD> if a queue overflow occurred.  With an fanotify group that "
"identifies filesystem objects by file handles, applications should expect "
"this value to be set to B<FAN_NOFD> for each event that is received.  The "
"file descriptor can be used to access the contents of the monitored file or "
"directory.  The reading application is responsible for closing this file "
"descriptor."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:261
msgid ""
"When calling B<fanotify_init>(2), the caller may specify (via the "
"I<event_f_flags> argument) various file status flags that are to be set on "
"the open file description that corresponds to this file descriptor.  In "
"addition, the (kernel-internal)  B<FMODE_NONOTIFY> file status flag is set "
"on the open file description.  This flag suppresses fanotify event "
"generation.  Hence, when the receiver of the fanotify event accesses the "
"notified file or directory using this file descriptor, no additional events "
"will be created."
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:261
#, no-wrap
msgid "I<pid>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:269
msgid ""
"If flag B<FAN_REPORT_TID> was set in B<fanotify_init>(2), this is the TID of "
"the thread that caused the event.  Otherwise, this the PID of the process "
"that caused the event."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:275
msgid ""
"A program listening to fanotify events can compare this PID to the PID "
"returned by B<getpid>(2), to determine whether the event is caused by the "
"listener itself, or is due to a file access by another process."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:285
msgid ""
"The bit mask in I<mask> indicates which events have occurred for a single "
"filesystem object.  Multiple bits may be set in this mask, if more than one "
"event occurred for the monitored filesystem object.  In particular, "
"consecutive events for the same filesystem object and originating from the "
"same process may be merged into a single event, with the exception that two "
"permission events are never merged into one queue entry."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:289
msgid "The bits that may appear in I<mask> are as follows:"
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:289 build/C/man2/fanotify_mark.2:170
#, no-wrap
msgid "B<FAN_ACCESS>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:292
msgid "A file or a directory (but see BUGS) was accessed (read)."
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:292 build/C/man2/fanotify_mark.2:182
#, no-wrap
msgid "B<FAN_OPEN>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:295
msgid "A file or a directory was opened."
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:295
#, no-wrap
msgid "B<FAN_OPEN_EXEC>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:301
msgid ""
"A file was opened with the intent to be executed.  See NOTES in "
"B<fanotify_mark>(2)  for additional details."
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:301
#, no-wrap
msgid "B<FAN_ATTRIB>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:304
msgid "A file or directory metadata was changed."
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:304
#, no-wrap
msgid "B<FAN_CREATE>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:307
msgid "A child file or directory was created in a watched parent."
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:307
#, no-wrap
msgid "B<FAN_DELETE>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:310
msgid "A child file or directory was deleted in a watched parent."
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:310
#, no-wrap
msgid "B<FAN_DELETE_SELF>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:313
msgid "A watched file or directory was deleted."
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:313
#, no-wrap
msgid "B<FAN_MOVED_FROM>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:316
msgid "A file or directory has been moved from a watched parent directory."
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:316
#, no-wrap
msgid "B<FAN_MOVED_TO>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:319
msgid "A file or directory has been moved to a watched parent directory."
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:319
#, no-wrap
msgid "B<FAN_MOVE_SELF>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:322
msgid "A watched file or directory was moved."
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:322 build/C/man2/fanotify_mark.2:173
#, no-wrap
msgid "B<FAN_MODIFY>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:325
msgid "A file was modified."
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:325 build/C/man2/fanotify_mark.2:176
#, no-wrap
msgid "B<FAN_CLOSE_WRITE>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:332
msgid "A file that was opened for writing (B<O_WRONLY> or B<O_RDWR>)  was closed."
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:332 build/C/man2/fanotify_mark.2:179
#, no-wrap
msgid "B<FAN_CLOSE_NOWRITE>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:337
msgid "A file or directory that was opened read-only (B<O_RDONLY>)  was closed."
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:337
#, no-wrap
msgid "B<FAN_Q_OVERFLOW>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:344
msgid ""
"The event queue exceeded the limit of 16384 entries.  This limit can be "
"overridden by specifying the B<FAN_UNLIMITED_QUEUE> flag when calling "
"B<fanotify_init>(2)."
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:344 build/C/man2/fanotify_mark.2:255
#, no-wrap
msgid "B<FAN_ACCESS_PERM>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:353
msgid ""
"An application wants to read a file or directory, for example using "
"B<read>(2)  or B<readdir>(2).  The reader must write a response (as "
"described below)  that determines whether the permission to access the "
"filesystem object shall be granted."
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:353 build/C/man2/fanotify_mark.2:236
#, no-wrap
msgid "B<FAN_OPEN_PERM>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:358
msgid ""
"An application wants to open a file or directory.  The reader must write a "
"response that determines whether the permission to open the filesystem "
"object shall be granted."
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:358
#, no-wrap
msgid "B<FAN_OPEN_EXEC_PERM>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:366
msgid ""
"An application wants to open a file for execution.  The reader must write a "
"response that determines whether the permission to open the filesystem "
"object for execution shall be granted.  See NOTES in B<fanotify_mark>(2)  "
"for additional details."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:368
msgid "To check for any close event, the following bit mask may be used:"
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:368 build/C/man2/fanotify_mark.2:307
#, no-wrap
msgid "B<FAN_CLOSE>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:372
msgid "A file was closed.  This is a synonym for:"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:374
#, no-wrap
msgid "    FAN_CLOSE_WRITE | FAN_CLOSE_NOWRITE\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:376
msgid "To check for any move event, the following bit mask may be used:"
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:376 build/C/man2/fanotify_mark.2:311
#, no-wrap
msgid "B<FAN_MOVE>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:380
msgid "A file or directory was moved.  This is a synonym for:"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:382
#, no-wrap
msgid "    FAN_MOVED_FROM | FAN_MOVED_TO\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:386
msgid ""
"The following bits may appear in I<mask> only in conjunction with other "
"event type bits:"
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:386 build/C/man2/fanotify_mark.2:263
#, no-wrap
msgid "B<FAN_ONDIR>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:399
msgid ""
"The events described in the I<mask> have occurred on a directory object.  "
"Reporting events on directories requires setting this flag in the mark "
"mask.  See B<fanotify_mark>(2)  for additional details.  The B<FAN_ONDIR> "
"flag is reported in an event mask only if the fanotify group identifies "
"filesystem objects by file handles."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:403
msgid "The fields of the I<fanotify_event_info_fid> structure are as follows:"
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:403
#, no-wrap
msgid "I<hdr>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:446
msgid ""
"This is a structure of type I<fanotify_event_info_header>.  It is a generic "
"header that contains information used to describe an additional information "
"record attached to the event.  For example, when an fanotify file descriptor "
"is created using B<FAN_REPORT_FID>, a single information record is expected "
"to be attached to the event with I<info_type> field value of "
"B<FAN_EVENT_INFO_TYPE_FID>.  When an fanotify file descriptor is created "
"using the combination of B<FAN_REPORT_FID> and B<FAN_REPORT_DIR_FID>, there "
"may be two information records attached to the event: one with I<info_type> "
"field value of B<FAN_EVENT_INFO_TYPE_DFID>, identifying a parent directory "
"object, and one with I<info_type> field value of B<FAN_EVENT_INFO_TYPE_FID>, "
"identifying a non-directory object.  The I<fanotify_event_info_header> "
"contains a I<len> field.  The value of I<len> is the size of the additional "
"information record including the I<fanotify_event_info_header> itself.  The "
"total size of all additional information records is not expected to be "
"bigger than ( I<event_len> - I<metadata_len> )."
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:446
#, no-wrap
msgid "I<fsid>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:456
msgid ""
"This is a unique identifier of the filesystem containing the object "
"associated with the event.  It is a structure of type I<__kernel_fsid_t> and "
"contains the same value as I<f_fsid> when calling B<statfs>(2)."
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:456
#, no-wrap
msgid "I<file_handle>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:512
msgid ""
"This is a variable length structure of type struct file_handle.  It is an "
"opaque handle that corresponds to a specified object on a filesystem as "
"returned by B<name_to_handle_at>(2).  It can be used to uniquely identify a "
"file on a filesystem and can be passed as an argument to "
"B<open_by_handle_at>(2).  Note that for the directory entry modification "
"events B<FAN_CREATE>, B<FAN_DELETE>, and B<FAN_MOVE>, the I<file_handle> "
"identifies the modified directory and not the created/deleted/moved child "
"object.  If the value of I<info_type> field is "
"B<FAN_EVENT_INFO_TYPE_DFID_NAME>, the file handle is followed by a null "
"terminated string that identifies the created/deleted/moved directory entry "
"name.  For other events such as B<FAN_OPEN>, B<FAN_ATTRIB>, "
"B<FAN_DELETE_SELF>, and B<FAN_MOVE_SELF>, if the value of I<info_type> field "
"is B<FAN_EVENT_INFO_TYPE_FID>, the I<file_handle> identifies the object "
"correlated to the event.  If the value of I<info_type> field is "
"B<FAN_EVENT_INFO_TYPE_DFID>, the I<file_handle> identifies the directory "
"object correlated to the event or the parent directory of a non-directory "
"object correlated to the event.  If the value of I<info_type> field is "
"B<FAN_EVENT_INFO_TYPE_DFID_NAME>, the I<file_handle> identifies the same "
"directory object that would be reported with B<FAN_EVENT_INFO_TYPE_DFID> and "
"the file handle is followed by a null terminated string that identifies the "
"name of a directory entry in that directory, or '.' to identify the "
"directory object itself."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:517
msgid ""
"The following macros are provided to iterate over a buffer containing "
"fanotify event metadata returned by a B<read>(2)  from an fanotify file "
"descriptor:"
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:517
#, no-wrap
msgid "B<FAN_EVENT_OK(meta, len)>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:526
msgid ""
"This macro checks the remaining length I<len> of the buffer I<meta> against "
"the length of the metadata structure and the I<event_len> field of the first "
"metadata structure in the buffer."
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:526
#, no-wrap
msgid "B<FAN_EVENT_NEXT(meta, len)>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:545
msgid ""
"This macro uses the length indicated in the I<event_len> field of the "
"metadata structure pointed to by I<meta> to calculate the address of the "
"next metadata structure that follows I<meta>.  I<len> is the number of bytes "
"of metadata that currently remain in the buffer.  The macro returns a "
"pointer to the next metadata structure that follows I<meta>, and reduces "
"I<len> by the number of bytes in the metadata structure that has been "
"skipped over (i.e., it subtracts I<meta-E<gt>event_len> from I<len>)."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:547
msgid "In addition, there is:"
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:547
#, no-wrap
msgid "B<FAN_EVENT_METADATA_LEN>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:553
msgid ""
"This macro returns the size (in bytes) of the structure "
"I<fanotify_event_metadata>.  This is the minimum size (and currently the "
"only size) of any event metadata."
msgstr ""

#. type: SS
#: build/C/man7/fanotify.7:553
#, no-wrap
msgid "Monitoring an fanotify file descriptor for events"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:560
msgid ""
"When an fanotify event occurs, the fanotify file descriptor indicates as "
"readable when passed to B<epoll>(7), B<poll>(2), or B<select>(2)."
msgstr ""

#. type: SS
#: build/C/man7/fanotify.7:560
#, no-wrap
msgid "Dealing with permission events"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:565
msgid ""
"For permission events, the application must B<write>(2)  a structure of the "
"following form to the fanotify file descriptor:"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:572
#, no-wrap
msgid ""
"struct fanotify_response {\n"
"    __s32 fd;\n"
"    __u32 response;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:576
msgid "The fields of this structure are as follows:"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:580
msgid "This is the file descriptor from the structure I<fanotify_event_metadata>."
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:580
#, no-wrap
msgid "I<response>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:588
msgid ""
"This field indicates whether or not the permission is to be granted.  Its "
"value must be either B<FAN_ALLOW> to allow the file operation or B<FAN_DENY> "
"to deny the file operation."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:593
msgid ""
"If access is denied, the requesting application call will receive an "
"B<EPERM> error."
msgstr ""

#. type: SS
#: build/C/man7/fanotify.7:593
#, no-wrap
msgid "Closing the fanotify file descriptor"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:600
msgid ""
"When all file descriptors referring to the fanotify notification group are "
"closed, the fanotify group is released and its resources are freed for reuse "
"by the kernel.  Upon B<close>(2), outstanding permission events will be set "
"to allowed."
msgstr ""

#. type: SS
#: build/C/man7/fanotify.7:600
#, no-wrap
msgid "/proc/[pid]/fdinfo"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:610
msgid ""
"The file I</proc/[pid]/fdinfo/[fd]> contains information about fanotify "
"marks for file descriptor I<fd> of process I<pid>.  See B<proc>(5)  for "
"details."
msgstr ""

#. type: SH
#: build/C/man7/fanotify.7:610 build/C/man2/fanotify_init.2:343 build/C/man2/fanotify_mark.2:368 build/C/man2/inotify_add_watch.2:84 build/C/man2/inotify_init.2:81 build/C/man2/inotify_rm_watch.2:55
#, no-wrap
msgid "ERRORS"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:615
msgid ""
"In addition to the usual errors for B<read>(2), the following errors can "
"occur when reading from the fanotify file descriptor:"
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:615 build/C/man7/fanotify.7:649 build/C/man2/fanotify_init.2:344 build/C/man2/fanotify_mark.2:373 build/C/man2/fanotify_mark.2:382 build/C/man2/inotify_add_watch.2:104 build/C/man2/inotify_init.2:82 build/C/man2/inotify_rm_watch.2:60
#, no-wrap
msgid "B<EINVAL>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:618
msgid "The buffer is too small to hold the event."
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:618 build/C/man2/fanotify_init.2:355 build/C/man2/fanotify_init.2:358 build/C/man2/inotify_init.2:87 build/C/man2/inotify_init.2:90
#, no-wrap
msgid "B<EMFILE>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:625
msgid ""
"The per-process limit on the number of open files has been reached.  See the "
"description of B<RLIMIT_NOFILE> in B<getrlimit>(2)."
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:625 build/C/man2/inotify_init.2:93
#, no-wrap
msgid "B<ENFILE>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:632
msgid ""
"The system-wide limit on the total number of open files has been reached.  "
"See I</proc/sys/fs/file-max> in B<proc>(5)."
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:632
#, no-wrap
msgid "B<ETXTBSY>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:645
msgid ""
"This error is returned by B<read>(2)  if B<O_RDWR> or B<O_WRONLY> was "
"specified in the I<event_f_flags> argument when calling B<fanotify_init>(2)  "
"and an event occurred for a monitored file that is currently being executed."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:649
msgid ""
"In addition to the usual errors for B<write>(2), the following errors can "
"occur when writing to the fanotify file descriptor:"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:655
msgid ""
"Fanotify access permissions are not enabled in the kernel configuration or "
"the value of I<response> in the response structure is not valid."
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:655 build/C/man2/fanotify_mark.2:401 build/C/man2/inotify_add_watch.2:119
#, no-wrap
msgid "B<ENOENT>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:662
msgid ""
"The file descriptor I<fd> in the response structure is not valid.  This may "
"occur when a response for the permission event has already been written."
msgstr ""

#. type: SH
#: build/C/man7/fanotify.7:662 build/C/man2/fanotify_init.2:375 build/C/man2/fanotify_mark.2:454 build/C/man7/inotify.7:594 build/C/man2/inotify_add_watch.2:139 build/C/man2/inotify_init.2:99 build/C/man2/inotify_rm_watch.2:67
#, no-wrap
msgid "VERSIONS"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:666
msgid ""
"The fanotify API was introduced in version 2.6.36 of the Linux kernel and "
"enabled in version 2.6.37.  Fdinfo support was added in version 3.8."
msgstr ""

#. type: SH
#: build/C/man7/fanotify.7:666 build/C/man2/fanotify_init.2:379 build/C/man2/fanotify_mark.2:458 build/C/man7/inotify.7:602 build/C/man2/inotify_add_watch.2:141 build/C/man2/inotify_init.2:106 build/C/man2/inotify_rm_watch.2:69
#, no-wrap
msgid "CONFORMING TO"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:668
msgid "The fanotify API is Linux-specific."
msgstr ""

#. type: SH
#: build/C/man7/fanotify.7:668 build/C/man2/fanotify_mark.2:460 build/C/man7/inotify.7:604
#, no-wrap
msgid "NOTES"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:675
msgid ""
"The fanotify API is available only if the kernel was built with the "
"B<CONFIG_FANOTIFY> configuration option enabled.  In addition, fanotify "
"permission handling is available only if the "
"B<CONFIG_FANOTIFY_ACCESS_PERMISSIONS> configuration option is enabled."
msgstr ""

#. type: SS
#: build/C/man7/fanotify.7:675 build/C/man7/inotify.7:673
#, no-wrap
msgid "Limitations and caveats"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:680
msgid ""
"Fanotify reports only events that a user-space program triggers through the "
"filesystem API.  As a result, it does not catch remote events that occur on "
"network filesystems."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:687
msgid ""
"The fanotify API does not report file accesses and modifications that may "
"occur because of B<mmap>(2), B<msync>(2), and B<munmap>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:692
msgid ""
"Events for directories are created only if the directory itself is opened, "
"read, and closed.  Adding, removing, or changing children of a marked "
"directory does not create events for the monitored directory itself."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:707
msgid ""
"Fanotify monitoring of directories is not recursive: to monitor "
"subdirectories under a directory, additional marks must be created.  The "
"B<FAN_CREATE> event can be used for detecting when a subdirectory has been "
"created under a marked directory.  An additional mark must then be set on "
"the newly created subdirectory.  This approach is racy, because it can lose "
"events that occurred inside the newly created subdirectory, before a mark is "
"added on that subdirectory.  Monitoring mounts offers the capability to "
"monitor a whole directory tree in a race-free manner.  Monitoring "
"filesystems offers the capability to monitor changes made from any mount of "
"a filesystem instance in a race-free manner."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:710
msgid "The event queue can overflow.  In this case, events are lost."
msgstr ""

#. type: SH
#: build/C/man7/fanotify.7:710 build/C/man2/fanotify_init.2:381 build/C/man2/fanotify_mark.2:506 build/C/man7/inotify.7:811
#, no-wrap
msgid "BUGS"
msgstr ""

#.  commit 820c12d5d6c0890bc93dd63893924a13041fdc35
#. type: Plain text
#: build/C/man7/fanotify.7:721
msgid ""
"Before Linux 3.19, B<fallocate>(2)  did not generate fanotify events.  Since "
"Linux 3.19, calls to B<fallocate>(2)  generate B<FAN_MODIFY> events."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:724
msgid "As of Linux 3.17, the following bugs exist:"
msgstr ""

#. type: IP
#: build/C/man7/fanotify.7:724 build/C/man7/fanotify.7:733 build/C/man7/fanotify.7:742 build/C/man2/fanotify_init.2:383 build/C/man2/fanotify_init.2:391 build/C/man2/fanotify_mark.2:320 build/C/man2/fanotify_mark.2:326 build/C/man2/fanotify_mark.2:334 build/C/man2/fanotify_mark.2:340 build/C/man2/fanotify_mark.2:351 build/C/man2/fanotify_mark.2:508 build/C/man2/fanotify_mark.2:518 build/C/man2/fanotify_mark.2:524 build/C/man7/inotify.7:39 build/C/man7/inotify.7:50 build/C/man7/inotify.7:63 build/C/man7/inotify.7:69 build/C/man7/inotify.7:72 build/C/man7/inotify.7:278 build/C/man7/inotify.7:281
#, no-wrap
msgid "*"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:733
msgid ""
"On Linux, a filesystem object may be accessible through multiple paths, for "
"example, a part of a filesystem may be remounted using the I<--bind> option "
"of B<mount>(8).  A listener that marked a mount will be notified only of "
"events that were triggered for a filesystem object using the same mount.  "
"Any other event will pass unnoticed."
msgstr ""

#.  FIXME . A patch was proposed.
#. type: Plain text
#: build/C/man7/fanotify.7:742
msgid ""
"When an event is generated, no check is made to see whether the user ID of "
"the receiving process has authorization to read or write the file before "
"passing a file descriptor for that file.  This poses a security risk, when "
"the B<CAP_SYS_ADMIN> capability is set for programs executed by unprivileged "
"users."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:752
msgid ""
"If a call to B<read>(2)  processes multiple events from the fanotify queue "
"and an error occurs, the return value will be the total length of the events "
"successfully copied to the user-space buffer before the error occurred.  The "
"return value will not be -1, and I<errno> will not be set.  Thus, the "
"reading application has no way to detect the error."
msgstr ""

#. type: SH
#: build/C/man7/fanotify.7:752 build/C/man7/inotify.7:879 build/C/man2/inotify_add_watch.2:143
#, no-wrap
msgid "EXAMPLES"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:754
msgid "The two example programs below demonstrate the usage of the fanotify API."
msgstr ""

#. type: SS
#: build/C/man7/fanotify.7:754
#, no-wrap
msgid "Example program: fanotify_example.c"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:766
msgid ""
"The first program is an example of fanotify being used with its event object "
"information passed in the form of a file descriptor.  The program marks the "
"mount point passed as a command-line argument and waits for events of type "
"B<FAN_OPEN_PERM> and B<FAN_CLOSE_WRITE>.  When a permission event occurs, a "
"B<FAN_ALLOW> response is given."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:778
msgid ""
"The following shell session shows an example of running this program.  This "
"session involved editing the file I</home/user/temp/notes>.  Before the file "
"was opened, a B<FAN_OPEN_PERM> event occurred.  After the file was closed, a "
"B<FAN_CLOSE_WRITE> event occurred.  Execution of the program ends when the "
"user presses the ENTER key."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:786
#, no-wrap
msgid ""
"# B<./fanotify_example /home>\n"
"Press enter key to terminate.\n"
"Listening for events.\n"
"FAN_OPEN_PERM: File /home/user/temp/notes\n"
"FAN_CLOSE_WRITE: File /home/user/temp/notes\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:788 build/C/man7/inotify.7:914
#, no-wrap
msgid "Listening for events stopped.\n"
msgstr ""

#. type: SS
#: build/C/man7/fanotify.7:790
#, no-wrap
msgid "Program source: fanotify_example.c"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:802
#, no-wrap
msgid ""
"#define _GNU_SOURCE     /* Needed to get O_LARGEFILE definition */\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>limits.hE<gt>\n"
"#include E<lt>poll.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/fanotify.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:804
#, no-wrap
msgid ""
"/* Read all available fanotify events from the file descriptor \\(aqfd\\(aq "
"*/\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:815
#, no-wrap
msgid ""
"static void\n"
"handle_events(int fd)\n"
"{\n"
"    const struct fanotify_event_metadata *metadata;\n"
"    struct fanotify_event_metadata buf[200];\n"
"    ssize_t len;\n"
"    char path[PATH_MAX];\n"
"    ssize_t path_len;\n"
"    char procfd_path[PATH_MAX];\n"
"    struct fanotify_response response;\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:817
#, no-wrap
msgid "    /* Loop while events can be read from fanotify file descriptor */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:819 build/C/man7/inotify.7:950
#, no-wrap
msgid "    for (;;) {\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:821
#, no-wrap
msgid "        /* Read some events */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:827 build/C/man7/inotify.7:958
#, no-wrap
msgid ""
"        len = read(fd, buf, sizeof(buf));\n"
"        if (len == -1 && errno != EAGAIN) {\n"
"            perror(\"read\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:829
#, no-wrap
msgid "        /* Check if end of available data reached */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:832 build/C/man7/inotify.7:965
#, no-wrap
msgid ""
"        if (len E<lt>= 0)\n"
"            break;\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:834
#, no-wrap
msgid "        /* Point to the first event in the buffer */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:836
#, no-wrap
msgid "        metadata = buf;\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:838 build/C/man7/inotify.7:967
#, no-wrap
msgid "        /* Loop over all events in the buffer */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:840
#, no-wrap
msgid "        while (FAN_EVENT_OK(metadata, len)) {\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:842
#, no-wrap
msgid "            /* Check that run-time and compile-time structures match */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:848
#, no-wrap
msgid ""
"            if (metadata-E<gt>vers != FANOTIFY_METADATA_VERSION) {\n"
"                fprintf(stderr,\n"
"                        \"Mismatch of fanotify metadata version.\\en\");\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:852
#, no-wrap
msgid ""
"            /* metadata-E<gt>fd contains either FAN_NOFD, indicating a\n"
"               queue overflow, or a file descriptor (a nonnegative\n"
"               integer). Here, we simply ignore queue overflow. */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:854
#, no-wrap
msgid "            if (metadata-E<gt>fd E<gt>= 0) {\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:856
#, no-wrap
msgid "                /* Handle open permission event */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:859
#, no-wrap
msgid ""
"                if (metadata-E<gt>mask & FAN_OPEN_PERM) {\n"
"                    printf(\"FAN_OPEN_PERM: \");\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:861
#, no-wrap
msgid "                    /* Allow file to be opened */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:866
#, no-wrap
msgid ""
"                    response.fd = metadata-E<gt>fd;\n"
"                    response.response = FAN_ALLOW;\n"
"                    write(fd, &response, sizeof(response));\n"
"                }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:868
#, no-wrap
msgid "                /* Handle closing of writable file event */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:871
#, no-wrap
msgid ""
"                if (metadata-E<gt>mask & FAN_CLOSE_WRITE)\n"
"                    printf(\"FAN_CLOSE_WRITE: \");\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:873
#, no-wrap
msgid "                /* Retrieve and print pathname of the accessed file */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:882
#, no-wrap
msgid ""
"                snprintf(procfd_path, sizeof(procfd_path),\n"
"                         \"/proc/self/fd/%d\", metadata-E<gt>fd);\n"
"                path_len = readlink(procfd_path, path,\n"
"                                    sizeof(path) - 1);\n"
"                if (path_len == -1) {\n"
"                    perror(\"readlink\");\n"
"                    exit(EXIT_FAILURE);\n"
"                }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:885
#, no-wrap
msgid ""
"                path[path_len] = \\(aq\\e0\\(aq;\n"
"                printf(\"File %s\\en\", path);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:887
#, no-wrap
msgid "                /* Close the file descriptor of the event */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:890
#, no-wrap
msgid ""
"                close(metadata-E<gt>fd);\n"
"            }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:892
#, no-wrap
msgid "            /* Advance to next event */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:897
#, no-wrap
msgid ""
"            metadata = FAN_EVENT_NEXT(metadata, len);\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:905
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char buf;\n"
"    int fd, poll_num;\n"
"    nfds_t nfds;\n"
"    struct pollfd fds[2];\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:907
#, no-wrap
msgid "    /* Check mount point is supplied */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:912
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s MOUNT\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:914
#, no-wrap
msgid "    printf(\"Press enter key to terminate.\\en\");\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:916
#, no-wrap
msgid "    /* Create the file descriptor for accessing the fanotify API */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:923
#, no-wrap
msgid ""
"    fd = fanotify_init(FAN_CLOEXEC | FAN_CLASS_CONTENT | FAN_NONBLOCK,\n"
"                       O_RDONLY | O_LARGEFILE);\n"
"    if (fd == -1) {\n"
"        perror(\"fanotify_init\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:928
#, no-wrap
msgid ""
"    /* Mark the mount for:\n"
"       - permission events before opening files\n"
"       - notification events after closing a write-enabled\n"
"         file descriptor */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:935
#, no-wrap
msgid ""
"    if (fanotify_mark(fd, FAN_MARK_ADD | FAN_MARK_MOUNT,\n"
"                      FAN_OPEN_PERM | FAN_CLOSE_WRITE, AT_FDCWD,\n"
"                      argv[1]) == -1) {\n"
"        perror(\"fanotify_mark\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:937 build/C/man7/inotify.7:1053
#, no-wrap
msgid "    /* Prepare for polling */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:939 build/C/man7/inotify.7:1055
#, no-wrap
msgid "    nfds = 2;\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:941 build/C/man7/inotify.7:1057
#, no-wrap
msgid "    /* Console input */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:944 build/C/man7/inotify.7:1060
#, no-wrap
msgid ""
"    fds[0].fd = STDIN_FILENO;\n"
"    fds[0].events = POLLIN;\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:946
#, no-wrap
msgid "    /* Fanotify input */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:949 build/C/man7/inotify.7:1065
#, no-wrap
msgid ""
"    fds[1].fd = fd;\n"
"    fds[1].events = POLLIN;\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:951
#, no-wrap
msgid "    /* This is the loop to wait for incoming events */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:953 build/C/man7/fanotify.7:1113
#, no-wrap
msgid "    printf(\"Listening for events.\\en\");\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:959
#, no-wrap
msgid ""
"    while (1) {\n"
"        poll_num = poll(fds, nfds, -1);\n"
"        if (poll_num == -1) {\n"
"            if (errno == EINTR)     /* Interrupted by a signal */\n"
"                continue;           /* Restart poll() */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:963
#, no-wrap
msgid ""
"            perror(\"poll\");         /* Unexpected error */\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:966
#, no-wrap
msgid ""
"        if (poll_num E<gt> 0) {\n"
"            if (fds[0].revents & POLLIN) {\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:968
#, no-wrap
msgid "                /* Console input is available: empty stdin and quit */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:973 build/C/man7/inotify.7:1088
#, no-wrap
msgid ""
"                while (read(STDIN_FILENO, &buf, 1) E<gt> 0 && buf != "
"\\(aq\\en\\(aq)\n"
"                    continue;\n"
"                break;\n"
"            }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:975 build/C/man7/inotify.7:1090
#, no-wrap
msgid "            if (fds[1].revents & POLLIN) {\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:977
#, no-wrap
msgid "                /* Fanotify events are available */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:982
#, no-wrap
msgid ""
"                handle_events(fd);\n"
"            }\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:986
#, no-wrap
msgid ""
"    printf(\"Listening for events stopped.\\en\");\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: SS
#: build/C/man7/fanotify.7:988
#, no-wrap
msgid "Example program: fanotify_fid.c"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:1000
msgid ""
"The second program is an example of fanotify being used with a group that "
"identifies objects by file handles.  The program marks the filesystem object "
"that is passed as a command-line argument and waits until an event of type "
"B<FAN_CREATE> has occurred.  The event mask indicates which type of "
"filesystem object\\(emeither a file or a directory\\(emwas created.  Once "
"all events have been read from the buffer and processed accordingly, the "
"program simply terminates."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:1003
msgid ""
"The following shell sessions show two different invocations of this program, "
"with different actions performed on a watched object."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:1014
msgid ""
"The first session shows a mark being placed on I</home/user>.  This is "
"followed by the creation of a regular file, I</home/user/testfile.txt>.  "
"This results in a B<FAN_CREATE> event being generated and reported against "
"the file's parent watched directory object and with the created file name.  "
"Program execution ends once all events captured within the buffer have been "
"processed."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:1023
#, no-wrap
msgid ""
"# B<./fanotify_fid /home/user>\n"
"Listening for events.\n"
"FAN_CREATE (file created):\n"
"        Directory /home/user has been modified.\n"
"        Entry \\(aqtestfile.txt\\(aq is not a subdirectory.\n"
"All events processed successfully. Program exiting.\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:1025
#, no-wrap
msgid "$ B<touch /home/user/testfile.txt>              # In another terminal\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:1037
msgid ""
"The second session shows a mark being placed on I</home/user>.  This is "
"followed by the creation of a directory, I</home/user/testdir>.  This "
"specific action results in a B<FAN_CREATE> event being generated and is "
"reported with the B<FAN_ONDIR> flag set and with the created directory name."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:1046
#, no-wrap
msgid ""
"# B<./fanotify_fid /home/user>\n"
"Listening for events.\n"
"FAN_CREATE | FAN_ONDIR (subdirectory created):\n"
"        Directory /home/user has been modified.\n"
"        Entry \\(aqtestdir\\(aq is a subdirectory.\n"
"All events processed successfully. Program exiting.\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:1048
#, no-wrap
msgid "$ B<mkdir -p /home/user/testdir>          # In another terminal\n"
msgstr ""

#. type: SS
#: build/C/man7/fanotify.7:1050
#, no-wrap
msgid "Program source: fanotify_fid.c"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:1063
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>limits.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>sys/fanotify.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:1065
#, no-wrap
msgid "#define BUF_SIZE 256\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:1079
#, no-wrap
msgid ""
"int\n"
"main(int argc, char **argv)\n"
"{\n"
"    int fd, ret, event_fd, mount_fd;\n"
"    ssize_t len, path_len;\n"
"    char path[PATH_MAX];\n"
"    char procfd_path[PATH_MAX];\n"
"    char events_buf[BUF_SIZE];\n"
"    struct file_handle *file_handle;\n"
"    struct fanotify_event_metadata *metadata;\n"
"    struct fanotify_event_info_fid *fid;\n"
"    const char *file_name;\n"
"    struct stat sb;\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:1084
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Invalid number of command line "
"arguments.\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:1090
#, no-wrap
msgid ""
"    mount_fd = open(argv[1], O_DIRECTORY | O_RDONLY);\n"
"    if (mount_fd == -1) {\n"
"        perror(argv[1]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:1095
#, no-wrap
msgid ""
"    /* Create an fanotify file descriptor with FAN_REPORT_DFID_NAME as\n"
"       a flag so that program can receive fid events with directory\n"
"       entry name. */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:1101
#, no-wrap
msgid ""
"    fd = fanotify_init(FAN_CLASS_NOTIF | FAN_REPORT_DFID_NAME, 0);\n"
"    if (fd == -1) {\n"
"        perror(\"fanotify_init\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:1103
#, no-wrap
msgid "    /* Place a mark on the filesystem object supplied in argv[1]. */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:1111
#, no-wrap
msgid ""
"    ret = fanotify_mark(fd, FAN_MARK_ADD | FAN_MARK_ONLYDIR,\n"
"                        FAN_CREATE | FAN_ONDIR,\n"
"                        AT_FDCWD, argv[1]);\n"
"    if (ret == -1) {\n"
"        perror(\"fanotify_mark\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:1115
#, no-wrap
msgid "    /* Read events from the event queue into a buffer */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:1121
#, no-wrap
msgid ""
"    len = read(fd, events_buf, sizeof(events_buf));\n"
"    if (len == -1 && errno != EAGAIN) {\n"
"        perror(\"read\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:1123
#, no-wrap
msgid "    /* Process all events within the buffer */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:1129
#, no-wrap
msgid ""
"    for (metadata = (struct fanotify_event_metadata *) events_buf;\n"
"            FAN_EVENT_OK(metadata, len);\n"
"            metadata = FAN_EVENT_NEXT(metadata, len)) {\n"
"        fid = (struct fanotify_event_info_fid *) (metadata + 1);\n"
"        file_handle = (struct file_handle *) fid-E<gt>handle;\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:1131
#, no-wrap
msgid "        /* Ensure that the event info is of the correct type */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:1142
#, no-wrap
msgid ""
"        if (fid-E<gt>hdr.info_type == FAN_EVENT_INFO_TYPE_FID ||\n"
"            fid-E<gt>hdr.info_type == FAN_EVENT_INFO_TYPE_DFID) {\n"
"            file_name = NULL;\n"
"        } else if (fid-E<gt>hdr.info_type == FAN_EVENT_INFO_TYPE_DFID_NAME) "
"{\n"
"            file_name = file_handle-E<gt>f_handle +\n"
"                        file_handle-E<gt>handle_bytes;\n"
"        } else {\n"
"            fprintf(stderr, \"Received unexpected event info type.\\en\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:1145
#, no-wrap
msgid ""
"        if (metadata-E<gt>mask == FAN_CREATE)\n"
"            printf(\"FAN_CREATE (file created):\\en\");\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:1148
#, no-wrap
msgid ""
"        if (metadata-E<gt>mask == (FAN_CREATE | FAN_ONDIR))\n"
"            printf(\"FAN_CREATE | FAN_ONDIR (subdirectory "
"created):\\en\");\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:1157
#, no-wrap
msgid ""
"\t/* metadata-E<gt>fd is set to FAN_NOFD when the group identifies\n"
"\t   objects by file handles.  To obtain a file descriptor for\n"
"\t   the file object corresponding to an event you can use the\n"
"\t   struct file_handle that\\(aqs provided within the\n"
"\t   fanotify_event_info_fid in conjunction with the\n"
"\t   open_by_handle_at(2) system call.  A check for ESTALE is\n"
"\t   done to accommodate for the situation where the file handle\n"
"\t   for the object was deleted prior to this system call. */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:1169
#, no-wrap
msgid ""
"        event_fd = open_by_handle_at(mount_fd, file_handle, O_RDONLY);\n"
"        if (event_fd == -1) {\n"
"            if (errno == ESTALE) {\n"
"                printf(\"File handle is no longer valid. \"\n"
"                        \"File has been deleted\\en\");\n"
"                continue;\n"
"            } else {\n"
"                perror(\"open_by_handle_at\");\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
"        }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:1172
#, no-wrap
msgid ""
"        snprintf(procfd_path, sizeof(procfd_path), \"/proc/self/fd/%d\",\n"
"                event_fd);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:1174
#, no-wrap
msgid "        /* Retrieve and print the path of the modified dentry */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:1180
#, no-wrap
msgid ""
"        path_len = readlink(procfd_path, path, sizeof(path) - 1);\n"
"        if (path_len == -1) {\n"
"            perror(\"readlink\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:1183
#, no-wrap
msgid ""
"        path[path_len] = \\(aq\\e0\\(aq;\n"
"        printf(\"\\etDirectory \\(aq%s\\(aq has been modified.\\en\", "
"path);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:1199
#, no-wrap
msgid ""
"        if (file_name) {\n"
"            ret = fstatat(event_fd, file_name, &sb, 0);\n"
"            if (ret == -1) {\n"
"                if (errno != ENOENT) {\n"
"                    perror(\"fstatat\");\n"
"                    exit(EXIT_FAILURE);\n"
"                }\n"
"                printf(\"\\etEntry \\(aq%s\\(aq does not exist.\\en\", "
"file_name);\n"
"            } else if ((sb.st_mode & S_IFMT) == S_IFDIR) {\n"
"                printf(\"\\etEntry \\(aq%s\\(aq is a subdirectory.\\en\", "
"file_name);\n"
"            } else {\n"
"                printf(\"\\etEntry \\(aq%s\\(aq is not a "
"subdirectory.\\en\",\n"
"                        file_name);\n"
"            }\n"
"        }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:1201
#, no-wrap
msgid "        /* Close associated file descriptor for this event */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:1204
#, no-wrap
msgid ""
"        close(event_fd);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:1208
#, no-wrap
msgid ""
"    printf(\"All events processed successfully. Program exiting.\\en\");\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: SH
#: build/C/man7/fanotify.7:1209 build/C/man2/fanotify_init.2:401 build/C/man2/fanotify_mark.2:532 build/C/man7/inotify.7:1108 build/C/man2/inotify_add_watch.2:146 build/C/man2/inotify_init.2:108 build/C/man2/inotify_rm_watch.2:71
#, no-wrap
msgid "SEE ALSO"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:1214
msgid "B<fanotify_init>(2), B<fanotify_mark>(2), B<inotify>(7)"
msgstr ""

#. type: SH
#: build/C/man7/fanotify.7:1214 build/C/man2/fanotify_init.2:404 build/C/man2/fanotify_mark.2:535 build/C/man7/inotify.7:1121 build/C/man2/inotify_add_watch.2:150 build/C/man2/inotify_init.2:112 build/C/man2/inotify_rm_watch.2:75
#, no-wrap
msgid "COLOPHON"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:1222 build/C/man2/fanotify_init.2:412 build/C/man2/fanotify_mark.2:543 build/C/man7/inotify.7:1129 build/C/man2/inotify_add_watch.2:158 build/C/man2/inotify_init.2:120 build/C/man2/inotify_rm_watch.2:83
msgid ""
"This page is part of release 5.10 of the Linux I<man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at "
"\\%https://www.kernel.org/doc/man-pages/."
msgstr ""

#. type: TH
#: build/C/man2/fanotify_init.2:24
#, no-wrap
msgid "FANOTIFY_INIT"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:27
msgid "fanotify_init - create and initialize fanotify group"
msgstr ""

#. type: SH
#: build/C/man2/fanotify_init.2:27 build/C/man2/fanotify_mark.2:28 build/C/man2/inotify_add_watch.2:31 build/C/man2/inotify_init.2:32 build/C/man2/inotify_rm_watch.2:30
#, no-wrap
msgid "SYNOPSIS"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:29
msgid "B<#include E<lt>fcntl.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:31
msgid "B<#include E<lt>sys/fanotify.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:33
msgid ""
"B<int fanotify_init(unsigned int >I<flags>B<, unsigned int "
">I<event_f_flags>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:36 build/C/man2/fanotify_mark.2:39
msgid "For an overview of the fanotify API, see B<fanotify>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:40
msgid ""
"B<fanotify_init>()  initializes a new fanotify group and returns a file "
"descriptor for the event queue associated with the group."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:51
msgid ""
"The file descriptor is used in calls to B<fanotify_mark>(2)  to specify the "
"files, directories, mounts or filesystems for which fanotify events shall be "
"created.  These events are received by reading from the file descriptor.  "
"Some events are only informative, indicating that a file has been accessed.  "
"Other events can be used to determine whether another application is "
"permitted to access a file or directory.  Permission to access filesystem "
"objects is granted by writing to the file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:54
msgid ""
"Multiple programs may be using the fanotify interface at the same time to "
"monitor the same files."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:58
msgid ""
"In the current implementation, the number of fanotify groups per user is "
"limited to 128.  This limit cannot be overridden."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:67
msgid ""
"Calling B<fanotify_init>()  requires the B<CAP_SYS_ADMIN> capability.  This "
"constraint might be relaxed in future versions of the API.  Therefore, "
"certain additional capability checks have been implemented as indicated "
"below."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:73
msgid ""
"The I<flags> argument contains a multi-bit field defining the notification "
"class of the listening application and further single bit fields specifying "
"the behavior of the file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:77
msgid ""
"If multiple listeners for permission events exist, the notification class is "
"used to establish the sequence in which the listeners receive the events."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:80
msgid "Only one of the following notification classes may be specified in I<flags>:"
msgstr ""

#. type: TP
#: build/C/man2/fanotify_init.2:80
#, no-wrap
msgid "B<FAN_CLASS_PRE_CONTENT>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:88
msgid ""
"This value allows the receipt of events notifying that a file has been "
"accessed and events for permission decisions if a file may be accessed.  It "
"is intended for event listeners that need to access files before they "
"contain their final data.  This notification class might be used by "
"hierarchical storage managers, for example."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_init.2:88
#, no-wrap
msgid "B<FAN_CLASS_CONTENT>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:96
msgid ""
"This value allows the receipt of events notifying that a file has been "
"accessed and events for permission decisions if a file may be accessed.  It "
"is intended for event listeners that need to access files when they already "
"contain their final content.  This notification class might be used by "
"malware detection programs, for example."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_init.2:96
#, no-wrap
msgid "B<FAN_CLASS_NOTIF>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:103
msgid ""
"This is the default value.  It does not need to be specified.  This value "
"only allows the receipt of events notifying that a file has been accessed.  "
"Permission decisions before the file is accessed are not possible."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:111
msgid ""
"Listeners with different notification classes will receive events in the "
"order B<FAN_CLASS_PRE_CONTENT>, B<FAN_CLASS_CONTENT>, B<FAN_CLASS_NOTIF>.  "
"The order of notification for listeners in the same notification class is "
"undefined."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:114
msgid "The following bits can additionally be set in I<flags>:"
msgstr ""

#. type: TP
#: build/C/man2/fanotify_init.2:114
#, no-wrap
msgid "B<FAN_CLOEXEC>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:123
msgid ""
"Set the close-on-exec flag (B<FD_CLOEXEC>)  on the new file descriptor.  See "
"the description of the B<O_CLOEXEC> flag in B<open>(2)."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_init.2:123
#, no-wrap
msgid "B<FAN_NONBLOCK>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:133
msgid ""
"Enable the nonblocking flag (B<O_NONBLOCK>)  for the file descriptor.  "
"Reading from the file descriptor will not block.  Instead, if no data is "
"available, B<read>(2)  fails with the error B<EAGAIN>."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_init.2:133
#, no-wrap
msgid "B<FAN_UNLIMITED_QUEUE>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:139
msgid ""
"Remove the limit of 16384 events for the event queue.  Use of this flag "
"requires the B<CAP_SYS_ADMIN> capability."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_init.2:139
#, no-wrap
msgid "B<FAN_UNLIMITED_MARKS>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:145
msgid ""
"Remove the limit of 8192 marks.  Use of this flag requires the "
"B<CAP_SYS_ADMIN> capability."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_init.2:145
#, no-wrap
msgid "B<FAN_REPORT_TID> (since Linux 4.20)"
msgstr ""

#.  commit d0a6a87e40da49cfc7954c491d3065a25a641b29
#. type: Plain text
#: build/C/man2/fanotify_init.2:157
msgid ""
"Report thread ID (TID) instead of process ID (PID)  in the I<pid> field of "
"the I<struct fanotify_event_metadata> supplied to B<read>(2)  (see "
"B<fanotify>(7))."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_init.2:157
#, no-wrap
msgid "B<FAN_REPORT_FID> (since Linux 5.1)"
msgstr ""

#.  commit a8b13aa20afb69161b5123b4f1acc7ea0a03d360
#. type: Plain text
#: build/C/man2/fanotify_init.2:195
msgid ""
"This value allows the receipt of events which contain additional information "
"about the underlying filesystem object correlated to an event.  An "
"additional record of type B<FAN_EVENT_INFO_TYPE_FID> encapsulates the "
"information about the object and is included alongside the generic event "
"metadata structure.  The file descriptor that is used to represent the "
"object correlated to an event is instead substituted with a file handle.  It "
"is intended for applications that may find the use of a file handle to "
"identify an object more suitable than a file descriptor.  Additionally, it "
"may be used for applications monitoring a directory or a filesystem that are "
"interested in the directory entry modification events B<FAN_CREATE>, "
"B<FAN_DELETE>, and B<FAN_MOVE>, or in events such as B<FAN_ATTRIB>, "
"B<FAN_DELETE_SELF>, and B<FAN_MOVE_SELF>.  All the events above require an "
"fanotify group that identifies filesystem objects by file handles.  Note "
"that for the directory entry modification events the reported file handle "
"identifies the modified directory and not the created/deleted/moved child "
"object.  The use of B<FAN_CLASS_CONTENT> or B<FAN_CLASS_PRE_CONTENT> is not "
"permitted with this flag and will result in the error B<EINVAL>.  See "
"B<fanotify>(7)  for additional details."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_init.2:195
#, no-wrap
msgid "B<FAN_REPORT_DIR_FID> (since Linux 5.9)"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:227
msgid ""
"Events for fanotify groups initialized with this flag will contain (see "
"exceptions below) additional information about a directory object correlated "
"to an event.  An additional record of type B<FAN_EVENT_INFO_TYPE_DFID> "
"encapsulates the information about the directory object and is included "
"alongside the generic event metadata structure.  For events that occur on a "
"non-directory object, the additional structure includes a file handle that "
"identifies the parent directory filesystem object.  Note that there is no "
"guarantee that the directory filesystem object will be found at the location "
"described by the file handle information at the time the event is received.  "
"When combined with the flag B<FAN_REPORT_FID>, two records may be reported "
"with events that occur on a non-directory object, one to identify the "
"non-directory object itself and one to identify the parent directory "
"object.  Note that in some cases, a filesystem object does not have a "
"parent, for example, when an event occurs on an unlinked but open file.  In "
"that case, with the B<FAN_REPORT_FID> flag, the event will be reported with "
"only one record to identify the non-directory object itself, because there "
"is no directory associated with the event.  Without the B<FAN_REPORT_FID> "
"flag, no event will be reported.  See B<fanotify>(7)  for additional "
"details."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_init.2:227
#, no-wrap
msgid "B<FAN_REPORT_NAME> (since Linux 5.9)"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:277
msgid ""
"Events for fanotify groups initialized with this flag will contain "
"additional information about the name of the directory entry correlated to "
"an event.  This flag must be provided in conjunction with the flag "
"B<FAN_REPORT_DIR_FID>.  Providing this flag value without "
"B<FAN_REPORT_DIR_FID> will result in the error B<EINVAL>.  This flag may be "
"combined with the flag B<FAN_REPORT_FID>.  An additional record of type "
"B<FAN_EVENT_INFO_TYPE_DFID_NAME>, which encapsulates the information about "
"the directory entry, is included alongside the generic event metadata "
"structure and substitutes the additional information record of type "
"B<FAN_EVENT_INFO_TYPE_DFID>.  The additional record includes a file handle "
"that identifies a directory filesystem object followed by a name that "
"identifies an entry in that directory.  For the directory entry modification "
"events B<FAN_CREATE>, B<FAN_DELETE>, and B<FAN_MOVE>, the reported name is "
"that of the created/deleted/moved directory entry.  For other events that "
"occur on a directory object, the reported file handle is that of the "
"directory object itself and the reported name is '.'.  For other events that "
"occur on a non-directory object, the reported file handle is that of the "
"parent directory object and the reported name is the name of a directory "
"entry where the object was located at the time of the event.  The rationale "
"behind this logic is that the reported directory file handle can be passed "
"to B<open_by_handle_at>(2)  to get an open directory file descriptor and "
"that file descriptor along with the reported name can be used to call "
"B<fstatat>(2).  The same rule that applies to record type "
"B<FAN_EVENT_INFO_TYPE_DFID> also applies to record type "
"B<FAN_EVENT_INFO_TYPE_DFID_NAME>: if a non-directory object has no parent, "
"either the event will not be reported or it will be reported without the "
"directory entry information.  Note that there is no guarantee that the "
"filesystem object will be found at the location described by the directory "
"entry information at the time the event is received.  See B<fanotify>(7)  "
"for additional details."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_init.2:277
#, no-wrap
msgid "B<FAN_REPORT_DFID_NAME>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:281
msgid "This is a synonym for (B<FAN_REPORT_DIR_FID>|B<FAN_REPORT_NAME>)."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:294
msgid ""
"The I<event_f_flags> argument defines the file status flags that will be set "
"on the open file descriptions that are created for fanotify events.  For "
"details of these flags, see the description of the I<flags> values in "
"B<open>(2).  I<event_f_flags> includes a multi-bit field for the access "
"mode.  This field can take the following values:"
msgstr ""

#. type: TP
#: build/C/man2/fanotify_init.2:294
#, no-wrap
msgid "B<O_RDONLY>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:297
msgid "This value allows only read access."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_init.2:297
#, no-wrap
msgid "B<O_WRONLY>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:300
msgid "This value allows only write access."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_init.2:300
#, no-wrap
msgid "B<O_RDWR>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:303
msgid "This value allows read and write access."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:307
msgid "Additional bits can be set in I<event_f_flags>.  The most useful values are:"
msgstr ""

#. type: TP
#: build/C/man2/fanotify_init.2:307
#, no-wrap
msgid "B<O_LARGEFILE>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:314
msgid ""
"Enable support for files exceeding 2\\ GB.  Failing to set this flag will "
"result in an B<EOVERFLOW> error when trying to open a large file which is "
"monitored by an fanotify group on a 32-bit system."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_init.2:314
#, no-wrap
msgid "B<O_CLOEXEC> (since Linux 3.18)"
msgstr ""

#.  commit 0b37e097a648aa71d4db1ad108001e95b69a2da4
#. type: Plain text
#: build/C/man2/fanotify_init.2:323
msgid ""
"Enable the close-on-exec flag for the file descriptor.  See the description "
"of the B<O_CLOEXEC> flag in B<open>(2)  for reasons why this may be useful."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:336
msgid ""
"The following are also allowable: B<O_APPEND>, B<O_DSYNC>, B<O_NOATIME>, "
"B<O_NONBLOCK>, and B<O_SYNC>.  Specifying any other flag in I<event_f_flags> "
"yields the error B<EINVAL> (but see BUGS)."
msgstr ""

#. type: SH
#: build/C/man2/fanotify_init.2:336 build/C/man2/fanotify_mark.2:361 build/C/man2/inotify_add_watch.2:77 build/C/man2/inotify_init.2:76 build/C/man2/inotify_rm_watch.2:48
#, no-wrap
msgid "RETURN VALUE"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:343
msgid ""
"On success, B<fanotify_init>()  returns a new file descriptor.  On error, -1 "
"is returned, and I<errno> is set to indicate the error."
msgstr ""

#.  commit 23c9deeb3285d34fd243abb3d6b9f07db60c3cf4
#. type: Plain text
#: build/C/man2/fanotify_init.2:355
msgid ""
"An invalid value was passed in I<flags> or I<event_f_flags>.  "
"B<FAN_ALL_INIT_FLAGS> (deprecated since Linux kernel version 4.20)  defines "
"all allowable bits for I<flags>."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:358
msgid "The number of fanotify groups for this user exceeds 128."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:361 build/C/man2/inotify_init.2:93
msgid ""
"The per-process limit on the number of open file descriptors has been "
"reached."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_init.2:361 build/C/man2/fanotify_mark.2:410 build/C/man2/inotify_add_watch.2:124 build/C/man2/inotify_init.2:96
#, no-wrap
msgid "B<ENOMEM>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:364
msgid "The allocation of memory for the notification group failed."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_init.2:364 build/C/man2/fanotify_mark.2:419
#, no-wrap
msgid "B<ENOSYS>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:370
msgid ""
"This kernel does not implement B<fanotify_init>().  The fanotify API is "
"available only if the kernel was configured with B<CONFIG_FANOTIFY>."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_init.2:370
#, no-wrap
msgid "B<EPERM>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:375
msgid ""
"The operation is not permitted because the caller lacks the B<CAP_SYS_ADMIN> "
"capability."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:379
msgid ""
"B<fanotify_init>()  was introduced in version 2.6.36 of the Linux kernel and "
"enabled in version 2.6.37."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:381 build/C/man2/fanotify_mark.2:460 build/C/man2/inotify_add_watch.2:143 build/C/man2/inotify_rm_watch.2:71
msgid "This system call is Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:383
msgid "The following bug was present in Linux kernels before version 3.18:"
msgstr ""

#.  Fixed by commit 0b37e097a648aa71d4db1ad108001e95b69a2da4
#. type: Plain text
#: build/C/man2/fanotify_init.2:389
msgid "The B<O_CLOEXEC> is ignored when passed in I<event_f_flags>."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:391
msgid "The following bug was present in Linux kernels before version 3.14:"
msgstr ""

#.  Fixed by commit 48149e9d3a7e924010a0daab30a6197b7d7b6580
#. type: Plain text
#: build/C/man2/fanotify_init.2:401
msgid ""
"The I<event_f_flags> argument is not checked for invalid flags.  Flags that "
"are intended only for internal use, such as B<FMODE_EXEC>, can be set, and "
"will consequently be set for the file descriptors returned when reading from "
"the fanotify file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:404
msgid "B<fanotify_mark>(2), B<fanotify>(7)"
msgstr ""

#. type: TH
#: build/C/man2/fanotify_mark.2:24
#, no-wrap
msgid "FANOTIFY_MARK"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:28
msgid ""
"fanotify_mark - add, remove, or modify an fanotify mark on a filesystem "
"object"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:31
#, no-wrap
msgid "B<#include E<lt>sys/fanotify.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:35
#, no-wrap
msgid ""
"B<int fanotify_mark(int >I<fanotify_fd>B<, unsigned int >I<flags>B<,>\n"
"B<                  uint64_t >I<mask>B<, int >I<dirfd>B<, const char "
"*>I<pathname>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:44
msgid ""
"B<fanotify_mark>()  adds, removes, or modifies an fanotify mark on a "
"filesystem object.  The caller must have read permission on the filesystem "
"object that is to be marked."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:49
msgid ""
"The I<fanotify_fd> argument is a file descriptor returned by "
"B<fanotify_init>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:53
msgid ""
"I<flags> is a bit mask describing the modification to perform.  It must "
"include exactly one of the following values:"
msgstr ""

#. type: TP
#: build/C/man2/fanotify_mark.2:53
#, no-wrap
msgid "B<FAN_MARK_ADD>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:62
msgid ""
"The events in I<mask> will be added to the mark mask (or to the ignore "
"mask).  I<mask> must be nonempty or the error B<EINVAL> will occur."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_mark.2:62
#, no-wrap
msgid "B<FAN_MARK_REMOVE>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:71
msgid ""
"The events in argument I<mask> will be removed from the mark mask (or from "
"the ignore mask).  I<mask> must be nonempty or the error B<EINVAL> will "
"occur."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_mark.2:71
#, no-wrap
msgid "B<FAN_MARK_FLUSH>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:94
msgid ""
"Remove either all marks for filesystems, all marks for mounts, or all marks "
"for directories and files from the fanotify group.  If I<flags> contains "
"B<FAN_MARK_MOUNT>, all marks for mounts are removed from the group.  If "
"I<flags> contains B<FAN_MARK_FILESYSTEM>, all marks for filesystems are "
"removed from the group.  Otherwise, all marks for directories and files are "
"removed.  No flag other than and at most one of the flags B<FAN_MARK_MOUNT> "
"or B<FAN_MARK_FILESYSTEM> can be used in conjunction with "
"B<FAN_MARK_FLUSH>.  I<mask> is ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:98
msgid ""
"If none of the values above is specified, or more than one is specified, the "
"call fails with the error B<EINVAL>."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:102
msgid "In addition, zero or more of the following values may be ORed into I<flags>:"
msgstr ""

#. type: TP
#: build/C/man2/fanotify_mark.2:102
#, no-wrap
msgid "B<FAN_MARK_DONT_FOLLOW>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:113
msgid ""
"If I<pathname> is a symbolic link, mark the link itself, rather than the "
"file to which it refers.  (By default, B<fanotify_mark>()  dereferences "
"I<pathname> if it is a symbolic link.)"
msgstr ""

#. type: TP
#: build/C/man2/fanotify_mark.2:113
#, no-wrap
msgid "B<FAN_MARK_ONLYDIR>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:118
msgid ""
"If the filesystem object to be marked is not a directory, the error "
"B<ENOTDIR> shall be raised."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_mark.2:118
#, no-wrap
msgid "B<FAN_MARK_MOUNT>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:145
msgid ""
"Mark the mount point specified by I<pathname>.  If I<pathname> is not itself "
"a mount point, the mount point containing I<pathname> will be marked.  All "
"directories, subdirectories, and the contained files of the mount point will "
"be monitored.  The events which require that filesystem objects are "
"identified by file handles, such as B<FAN_CREATE>, B<FAN_ATTRIB>, "
"B<FAN_MOVE>, and B<FAN_DELETE_SELF>, cannot be provided as a I<mask> when "
"I<flags> contains B<FAN_MARK_MOUNT>.  Attempting to do so will result in the "
"error B<EINVAL> being returned."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_mark.2:145
#, no-wrap
msgid "B<FAN_MARK_FILESYSTEM> (since Linux 4.20)"
msgstr ""

#.  commit d54f4fba889b205e9cd8239182ca5d27d0ac3bc2
#. type: Plain text
#: build/C/man2/fanotify_mark.2:155
msgid ""
"Mark the filesystem specified by I<pathname>.  The filesystem containing "
"I<pathname> will be marked.  All the contained files and directories of the "
"filesystem from any mount point will be monitored."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_mark.2:155
#, no-wrap
msgid "B<FAN_MARK_IGNORED_MASK>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:160
msgid "The events in I<mask> shall be added to or removed from the ignore mask."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_mark.2:160
#, no-wrap
msgid "B<FAN_MARK_IGNORED_SURV_MODIFY>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:166
msgid ""
"The ignore mask shall survive modify events.  If this flag is not set, the "
"ignore mask is cleared when a modify event occurs for the ignored file or "
"directory."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:170
msgid ""
"I<mask> defines which events shall be listened for (or which shall be "
"ignored).  It is a bit mask composed of the following values:"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:173
msgid "Create an event when a file or directory (but see BUGS) is accessed (read)."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:176
msgid "Create an event when a file is modified (write)."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:179
msgid "Create an event when a writable file is closed."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:182
msgid "Create an event when a read-only file or directory is closed."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:185
msgid "Create an event when a file or directory is opened."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_mark.2:185
#, no-wrap
msgid "B<FAN_OPEN_EXEC> (since Linux 5.0)"
msgstr ""

#.  commit 9b076f1c0f4869b838a1b7aa0edb5664d47ec8aa
#. type: Plain text
#: build/C/man2/fanotify_mark.2:190
msgid ""
"Create an event when a file is opened with the intent to be executed.  See "
"NOTES for additional details."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_mark.2:190
#, no-wrap
msgid "B<FAN_ATTRIB> (since Linux 5.1)"
msgstr ""

#.  commit 235328d1fa4251c6dcb32351219bb553a58838d2
#. type: Plain text
#: build/C/man2/fanotify_mark.2:196
msgid ""
"Create an event when the metadata for a file or directory has changed.  An "
"fanotify group that identifies filesystem objects by file handles is "
"required."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_mark.2:196
#, no-wrap
msgid "B<FAN_CREATE> (since Linux 5.1)"
msgstr ""

#.  commit 235328d1fa4251c6dcb32351219bb553a58838d2
#. type: Plain text
#: build/C/man2/fanotify_mark.2:203
msgid ""
"Create an event when a file or directory has been created in a marked parent "
"directory.  An fanotify group that identifies filesystem objects by file "
"handles is required."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_mark.2:203
#, no-wrap
msgid "B<FAN_DELETE> (since Linux 5.1)"
msgstr ""

#.  commit 235328d1fa4251c6dcb32351219bb553a58838d2
#. type: Plain text
#: build/C/man2/fanotify_mark.2:210
msgid ""
"Create an event when a file or directory has been deleted in a marked parent "
"directory.  An fanotify group that identifies filesystem objects by file "
"handles is required."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_mark.2:210
#, no-wrap
msgid "B<FAN_DELETE_SELF> (since Linux 5.1)"
msgstr ""

#.  commit 235328d1fa4251c6dcb32351219bb553a58838d2
#. type: Plain text
#: build/C/man2/fanotify_mark.2:216
msgid ""
"Create an event when a marked file or directory itself is deleted.  An "
"fanotify group that identifies filesystem objects by file handles is "
"required."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_mark.2:216
#, no-wrap
msgid "B<FAN_MOVED_FROM> (since Linux 5.1)"
msgstr ""

#.  commit 235328d1fa4251c6dcb32351219bb553a58838d2
#. type: Plain text
#: build/C/man2/fanotify_mark.2:223
msgid ""
"Create an event when a file or directory has been moved from a marked parent "
"directory.  An fanotify group that identifies filesystem objects by file "
"handles is required."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_mark.2:223
#, no-wrap
msgid "B<FAN_MOVED_TO> (since Linux 5.1)"
msgstr ""

#.  commit 235328d1fa4251c6dcb32351219bb553a58838d2
#. type: Plain text
#: build/C/man2/fanotify_mark.2:230
msgid ""
"Create an event when a file or directory has been moved to a marked parent "
"directory.  An fanotify group that identifies filesystem objects by file "
"handles is required."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_mark.2:230
#, no-wrap
msgid "B<FAN_MOVE_SELF> (since Linux 5.1)"
msgstr ""

#.  commit 235328d1fa4251c6dcb32351219bb553a58838d2
#. type: Plain text
#: build/C/man2/fanotify_mark.2:236
msgid ""
"Create an event when a marked file or directory itself has been moved.  An "
"fanotify group that identifies filesystem objects by file handles is "
"required."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:244
msgid ""
"Create an event when a permission to open a file or directory is requested.  "
"An fanotify file descriptor created with B<FAN_CLASS_PRE_CONTENT> or "
"B<FAN_CLASS_CONTENT> is required."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_mark.2:244
#, no-wrap
msgid "B<FAN_OPEN_EXEC_PERM> (since Linux 5.0)"
msgstr ""

#.  commit 66917a3130f218dcef9eeab4fd11a71cd00cd7c9
#. type: Plain text
#: build/C/man2/fanotify_mark.2:255
msgid ""
"Create an event when a permission to open a file for execution is "
"requested.  An fanotify file descriptor created with "
"B<FAN_CLASS_PRE_CONTENT> or B<FAN_CLASS_CONTENT> is required.  See NOTES for "
"additional details."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:263
msgid ""
"Create an event when a permission to read a file or directory is requested.  "
"An fanotify file descriptor created with B<FAN_CLASS_PRE_CONTENT> or "
"B<FAN_CLASS_CONTENT> is required."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:284
msgid ""
"Create events for directories\\(emfor example, when B<opendir>(3), "
"B<readdir>(3)  (but see BUGS), and B<closedir>(3)  are called.  Without this "
"flag, events are created only for files.  In the context of directory entry "
"events, such as B<FAN_CREATE>, B<FAN_DELETE>, B<FAN_MOVED_FROM>, and "
"B<FAN_MOVED_TO>, specifying the flag B<FAN_ONDIR> is required in order to "
"create events when subdirectory entries are modified (i.e., B<mkdir>(2)/ "
"B<rmdir>(2))."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_mark.2:284
#, no-wrap
msgid "B<FAN_EVENT_ON_CHILD>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:305
msgid ""
"Events for the immediate children of marked directories shall be created.  "
"The flag has no effect when marking mounts and filesystems.  Note that "
"events are not generated for children of the subdirectories of marked "
"directories.  More specifically, the directory entry modification events "
"B<FAN_CREATE>, B<FAN_DELETE>, B<FAN_MOVED_FROM>, and B<FAN_MOVED_TO> are not "
"generated for any entry modifications performed inside subdirectories of "
"marked directories.  Note that the events B<FAN_DELETE_SELF> and "
"B<FAN_MOVE_SELF> are not generated for children of marked directories.  To "
"monitor complete directory trees it is necessary to mark the relevant mount "
"or filesystem."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:307
msgid "The following composed values are defined:"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:311
msgid "A file is closed (B<FAN_CLOSE_WRITE>|B<FAN_CLOSE_NOWRITE>)."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:315
msgid "A file or directory has been moved (B<FAN_MOVED_FROM>|B<FAN_MOVED_TO>)."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:320
msgid ""
"The filesystem object to be marked is determined by the file descriptor "
"I<dirfd> and the pathname specified in I<pathname>:"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:326
msgid "If I<pathname> is NULL, I<dirfd> defines the filesystem object to be marked."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:334
msgid ""
"If I<pathname> is NULL, and I<dirfd> takes the special value B<AT_FDCWD>, "
"the current working directory is to be marked."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:340
msgid ""
"If I<pathname> is absolute, it defines the filesystem object to be marked, "
"and I<dirfd> is ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:351
msgid ""
"If I<pathname> is relative, and I<dirfd> does not have the value "
"B<AT_FDCWD>, then the filesystem object to be marked is determined by "
"interpreting I<pathname> relative the directory referred to by I<dirfd>."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:361
msgid ""
"If I<pathname> is relative, and I<dirfd> has the value B<AT_FDCWD>, then the "
"filesystem object to be marked is determined by interpreting I<pathname> "
"relative the current working directory."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:368
msgid ""
"On success, B<fanotify_mark>()  returns 0.  On error, -1 is returned, and "
"I<errno> is set to indicate the error."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_mark.2:369 build/C/man2/inotify_add_watch.2:88 build/C/man2/inotify_rm_watch.2:56
#, no-wrap
msgid "B<EBADF>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:373
msgid "An invalid file descriptor was passed in I<fanotify_fd>."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:382
msgid ""
"An invalid value was passed in I<flags> or I<mask>, or I<fanotify_fd> was "
"not an fanotify file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:391
msgid ""
"The fanotify file descriptor was opened with B<FAN_CLASS_NOTIF> or the "
"fanotify group identifies filesystem objects by file handles and mask "
"contains a flag for permission events (B<FAN_OPEN_PERM> or "
"B<FAN_ACCESS_PERM>)."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_mark.2:391
#, no-wrap
msgid "B<ENODEV>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:401
msgid ""
"The filesystem object indicated by I<pathname> is not associated with a "
"filesystem that supports I<fsid> (e.g., B<tmpfs>(5)).  This error can be "
"returned only with an fanotify group that identifies filesystem objects by "
"file handles."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:410
msgid ""
"The filesystem object indicated by I<dirfd> and I<pathname> does not exist.  "
"This error also occurs when trying to remove a mark from an object which is "
"not marked."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:413
msgid "The necessary memory could not be allocated."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_mark.2:413 build/C/man2/inotify_add_watch.2:127
#, no-wrap
msgid "B<ENOSPC>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:419
msgid ""
"The number of marks exceeds the limit of 8192 and the B<FAN_UNLIMITED_MARKS> "
"flag was not specified when the fanotify file descriptor was created with "
"B<fanotify_init>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:425
msgid ""
"This kernel does not implement B<fanotify_mark>().  The fanotify API is "
"available only if the kernel was configured with B<CONFIG_FANOTIFY>."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_mark.2:425 build/C/man2/inotify_add_watch.2:131
#, no-wrap
msgid "B<ENOTDIR>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:435
msgid ""
"I<flags> contains B<FAN_MARK_ONLYDIR>, and I<dirfd> and I<pathname> do not "
"specify a directory."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_mark.2:435
#, no-wrap
msgid "B<EOPNOTSUPP>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:443
msgid ""
"The object indicated by I<pathname> is associated with a filesystem that "
"does not support the encoding of file handles.  This error can be returned "
"only with an fanotify group that identifies filesystem objects by file "
"handles."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_mark.2:443
#, no-wrap
msgid "B<EXDEV>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:454
msgid ""
"The filesystem object indicated by I<pathname> resides within a filesystem "
"subvolume (e.g., B<btrfs>(5))  which uses a different I<fsid> than its root "
"superblock.  This error can be returned only with an fanotify group that "
"identifies filesystem objects by file handles."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:458
msgid ""
"B<fanotify_mark>()  was introduced in version 2.6.36 of the Linux kernel and "
"enabled in version 2.6.37."
msgstr ""

#. type: SS
#: build/C/man2/fanotify_mark.2:461
#, no-wrap
msgid "FAN_OPEN_EXEC and FAN_OPEN_EXEC_PERM"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:478
msgid ""
"When using either B<FAN_OPEN_EXEC> or B<FAN_OPEN_EXEC_PERM> within the "
"I<mask>, events of these types will be returned only when the direct "
"execution of a program occurs.  More specifically, this means that events of "
"these types will be generated for files that are opened using B<execve>(2), "
"B<execveat>(2), or B<uselib>(2).  Events of these types will not be raised "
"in the situation where an interpreter is passed (or reads) a file for "
"interpretation."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:485
msgid ""
"Additionally, if a mark has also been placed on the Linux dynamic linker, a "
"user should also expect to receive an event for it when an ELF object has "
"been successfully opened using B<execve>(2)  or B<execveat>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:489
msgid ""
"For example, if the following ELF binary were to be invoked and a "
"B<FAN_OPEN_EXEC> mark has been placed on /:"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:493
#, no-wrap
msgid "$ /bin/echo foo\n"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:499
msgid ""
"The listening application in this case would receive B<FAN_OPEN_EXEC> events "
"for both the ELF binary and interpreter, respectively:"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:504
#, no-wrap
msgid ""
"/bin/echo\n"
"/lib64/ld-linux-x86-64.so.2\n"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:508
msgid "The following bugs were present in Linux kernels before version 3.16:"
msgstr ""

#.  Fixed by commit 0a8dd2db579f7a0ac7033d6b857c3d5dbaa77563
#. type: Plain text
#: build/C/man2/fanotify_mark.2:518
msgid ""
"If I<flags> contains B<FAN_MARK_FLUSH>, I<dirfd>, and I<pathname> must "
"specify a valid filesystem object, even though this object is not used."
msgstr ""

#.  Fixed by commit d4c7cf6cffb1bc711a833b5e304ba5bcfe76398b
#. type: Plain text
#: build/C/man2/fanotify_mark.2:524
msgid "B<readdir>(2)  does not generate a B<FAN_ACCESS> event."
msgstr ""

#.  Fixed by commit cc299a98eb13a9853675a9cbb90b30b4011e1406
#. type: Plain text
#: build/C/man2/fanotify_mark.2:532
msgid ""
"If B<fanotify_mark>()  is called with B<FAN_MARK_FLUSH>, I<flags> is not "
"checked for invalid values."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:535
msgid "B<fanotify_init>(2), B<fanotify>(7)"
msgstr ""

#. type: TH
#: build/C/man7/inotify.7:26
#, no-wrap
msgid "INOTIFY"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:29
msgid "inotify - monitoring filesystem events"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:37
msgid ""
"The I<inotify> API provides a mechanism for monitoring filesystem events.  "
"Inotify can be used to monitor individual files, or to monitor directories.  "
"When a directory is monitored, inotify will return events for the directory "
"itself, and for files inside the directory."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:39
msgid "The following system calls are used with this API:"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:50
msgid ""
"B<inotify_init>(2)  creates an inotify instance and returns a file "
"descriptor referring to the inotify instance.  The more recent "
"B<inotify_init1>(2)  is like B<inotify_init>(2), but has a I<flags> argument "
"that provides access to some extra functionality."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:63
msgid ""
"B<inotify_add_watch>(2)  manipulates the \"watch list\" associated with an "
"inotify instance.  Each item (\"watch\") in the watch list specifies the "
"pathname of a file or directory, along with some set of events that the "
"kernel should monitor for the file referred to by that pathname.  "
"B<inotify_add_watch>(2)  either creates a new watch item, or modifies an "
"existing watch.  Each watch has a unique \"watch descriptor\", an integer "
"returned by B<inotify_add_watch>(2)  when the watch is created."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:69
msgid ""
"When events occur for monitored files and directories, those events are made "
"available to the application as structured data that can be read from the "
"inotify file descriptor using B<read>(2)  (see below)."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:72
msgid "B<inotify_rm_watch>(2)  removes an item from an inotify watch list."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:79
msgid ""
"When all file descriptors referring to an inotify instance have been closed "
"(using B<close>(2)), the underlying object and its resources are freed for "
"reuse by the kernel; all associated watches are automatically freed."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:88
msgid ""
"With careful programming, an application can use inotify to efficiently "
"monitor and cache the state of a set of filesystem objects.  However, robust "
"applications should allow for the fact that bugs in the monitoring logic or "
"races of the kind described below may leave the cache inconsistent with the "
"filesystem state.  It is probably wise to do some consistency checking, and "
"rebuild the cache when inconsistencies are detected."
msgstr ""

#. type: SS
#: build/C/man7/inotify.7:88
#, no-wrap
msgid "Reading events from an inotify file descriptor"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:101
msgid ""
"To determine what events have occurred, an application B<read>(2)s from the "
"inotify file descriptor.  If no events have so far occurred, then, assuming "
"a blocking file descriptor, B<read>(2)  will block until at least one event "
"occurs (unless interrupted by a signal, in which case the call fails with "
"the error B<EINTR>; see B<signal>(7))."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:105
msgid ""
"Each successful B<read>(2)  returns a buffer containing one or more of the "
"following structures:"
msgstr ""

#.  FIXME . The type of the 'wd' field should probably be "int32_t".
#.  I submitted a patch to fix this.  See the LKML thread
#.  "[patch] Fix type errors in inotify interfaces", 18 Nov 2008
#.  Glibc bug filed: http://sources.redhat.com/bugzilla/show_bug.cgi?id=7040
#. type: Plain text
#: build/C/man7/inotify.7:120
#, no-wrap
msgid ""
"struct inotify_event {\n"
"    int      wd;       /* Watch descriptor */\n"
"    uint32_t mask;     /* Mask describing event */\n"
"    uint32_t cookie;   /* Unique cookie associating related\n"
"                          events (for rename(2)) */\n"
"    uint32_t len;      /* Size of I<name> field */\n"
"    char     name[];   /* Optional null-terminated name */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:127
msgid ""
"I<wd> identifies the watch for which this event occurs.  It is one of the "
"watch descriptors returned by a previous call to B<inotify_add_watch>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:130
msgid "I<mask> contains bits that describe the event that occurred (see below)."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:142
msgid ""
"I<cookie> is a unique integer that connects related events.  Currently, this "
"is used only for rename events, and allows the resulting pair of "
"B<IN_MOVED_FROM> and B<IN_MOVED_TO> events to be connected by the "
"application.  For all other event types, I<cookie> is set to 0."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:151
msgid ""
"The I<name> field is present only when an event is returned for a file "
"inside a watched directory; it identifies the filename within the watched "
"directory.  This filename is null-terminated, and may include further null "
"bytes (\\(aq\\e0\\(aq) to align subsequent reads to a suitable address "
"boundary."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:161
msgid ""
"The I<len> field counts all of the bytes in I<name>, including the null "
"bytes; the length of each I<inotify_event> structure is thus I<sizeof(struct "
"inotify_event)+len>."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:172
msgid ""
"The behavior when the buffer given to B<read>(2)  is too small to return "
"information about the next event depends on the kernel version: in kernels "
"before 2.6.21, B<read>(2)  returns 0; since kernel 2.6.21, B<read>(2)  fails "
"with the error B<EINVAL>.  Specifying a buffer of size"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:174
#, no-wrap
msgid "    sizeof(struct inotify_event) + NAME_MAX + 1\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:176
msgid "will be sufficient to read at least one event."
msgstr ""

#. type: SS
#: build/C/man7/inotify.7:176
#, no-wrap
msgid "inotify events"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:196
msgid ""
"The B<inotify_add_watch>(2)  I<mask> argument and the I<mask> field of the "
"I<inotify_event> structure returned when B<read>(2)ing an inotify file "
"descriptor are both bit masks identifying inotify events.  The following "
"bits can be specified in I<mask> when calling B<inotify_add_watch>(2)  and "
"may be returned in the I<mask> field returned by B<read>(2):"
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:197
#, no-wrap
msgid "B<IN_ACCESS> (+)"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:202
msgid "File was accessed (e.g., B<read>(2), B<execve>(2))."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:202
#, no-wrap
msgid "B<IN_ATTRIB> (*)"
msgstr ""

#.  FIXME .
#.  Events do not occur for link count changes on a file inside a monitored
#.  directory. This differs from other metadata changes for files inside
#.  a monitored directory.
#. type: Plain text
#: build/C/man7/inotify.7:221
msgid ""
"Metadata changed\\(emfor example, permissions (e.g., B<chmod>(2)), "
"timestamps (e.g., B<utimensat>(2)), extended attributes (B<setxattr>(2)), "
"link count (since Linux 2.6.25; e.g., for the target of B<link>(2)  and for "
"B<unlink>(2)), and user/group ID (e.g., B<chown>(2))."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:221
#, no-wrap
msgid "B<IN_CLOSE_WRITE> (+)"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:224
msgid "File opened for writing was closed."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:224
#, no-wrap
msgid "B<IN_CLOSE_NOWRITE> (*)"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:227
msgid "File or directory not opened for writing was closed."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:227
#, no-wrap
msgid "B<IN_CREATE> (+)"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:237
msgid ""
"File/directory created in watched directory (e.g., B<open>(2)  B<O_CREAT>, "
"B<mkdir>(2), B<link>(2), B<symlink>(2), B<bind>(2)  on a UNIX domain "
"socket)."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:237
#, no-wrap
msgid "B<IN_DELETE> (+)"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:240
msgid "File/directory deleted from watched directory."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:240
#, no-wrap
msgid "B<IN_DELETE_SELF>"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:251
msgid ""
"Watched file/directory was itself deleted.  (This event also occurs if an "
"object is moved to another filesystem, since B<mv>(1)  in effect copies the "
"file to the other filesystem and then deletes it from the original "
"filesystem.)  In addition, an B<IN_IGNORED> event will subsequently be "
"generated for the watch descriptor."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:251
#, no-wrap
msgid "B<IN_MODIFY> (+)"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:256
msgid "File was modified (e.g., B<write>(2), B<truncate>(2))."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:256
#, no-wrap
msgid "B<IN_MOVE_SELF>"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:259
msgid "Watched file/directory was itself moved."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:259
#, no-wrap
msgid "B<IN_MOVED_FROM> (+)"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:263
msgid ""
"Generated for the directory containing the old filename when a file is "
"renamed."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:263
#, no-wrap
msgid "B<IN_MOVED_TO> (+)"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:267
msgid ""
"Generated for the directory containing the new filename when a file is "
"renamed."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:267
#, no-wrap
msgid "B<IN_OPEN> (*)"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:270
msgid "File or directory was opened."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:276
msgid ""
"Inotify monitoring is inode-based: when monitoring a file (but not when "
"monitoring the directory containing a file), an event can be generated for "
"activity on any link to the file (in the same or a different directory)."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:278
msgid "When monitoring a directory:"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:281
msgid ""
"the events marked above with an asterisk (*) can occur both for the "
"directory itself and for objects inside the directory; and"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:284
msgid ""
"the events marked with a plus sign (+) occur only for objects inside the "
"directory (not for the directory itself)."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:290
msgid ""
"I<Note>: when monitoring a directory, events are not generated for the files "
"inside the directory when the events are performed via a pathname (i.e., a "
"link)  that lies outside the monitored directory."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:296
msgid ""
"When events are generated for objects inside a watched directory, the "
"I<name> field in the returned I<inotify_event> structure identifies the name "
"of the file within the directory."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:304
msgid ""
"The B<IN_ALL_EVENTS> macro is defined as a bit mask of all of the above "
"events.  This macro can be used as the I<mask> argument when calling "
"B<inotify_add_watch>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:306
msgid "Two additional convenience macros are defined:"
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:307
#, no-wrap
msgid "B<IN_MOVE>"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:311
msgid "Equates to B<IN_MOVED_FROM | IN_MOVED_TO>."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:311
#, no-wrap
msgid "B<IN_CLOSE>"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:315
msgid "Equates to B<IN_CLOSE_WRITE | IN_CLOSE_NOWRITE>."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:321
msgid ""
"The following further bits can be specified in I<mask> when calling "
"B<inotify_add_watch>(2):"
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:322
#, no-wrap
msgid "B<IN_DONT_FOLLOW> (since Linux 2.6.15)"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:327
msgid "Don't dereference I<pathname> if it is a symbolic link."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:327
#, no-wrap
msgid "B<IN_EXCL_UNLINK> (since Linux 2.6.36)"
msgstr ""

#.  commit 8c1934c8d70b22ca8333b216aec6c7d09fdbd6a6
#. type: Plain text
#: build/C/man7/inotify.7:343
msgid ""
"By default, when watching events on the children of a directory, events are "
"generated for children even after they have been unlinked from the "
"directory.  This can result in large numbers of uninteresting events for "
"some applications (e.g., if watching I</tmp>, in which many applications "
"create temporary files whose names are immediately unlinked).  Specifying "
"B<IN_EXCL_UNLINK> changes the default behavior, so that events are not "
"generated for children after they have been unlinked from the watched "
"directory."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:343
#, no-wrap
msgid "B<IN_MASK_ADD>"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:355
msgid ""
"If a watch instance already exists for the filesystem object corresponding "
"to I<pathname>, add (OR) the events in I<mask> to the watch mask (instead of "
"replacing the mask); the error B<EINVAL> results if B<IN_MASK_CREATE> is "
"also specified."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:355
#, no-wrap
msgid "B<IN_ONESHOT>"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:361
msgid ""
"Monitor the filesystem object corresponding to I<pathname> for one event, "
"then remove from watch list."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:361
#, no-wrap
msgid "B<IN_ONLYDIR> (since Linux 2.6.15)"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:373
msgid ""
"Watch I<pathname> only if it is a directory; the error B<ENOTDIR> results if "
"I<pathname> is not a directory.  Using this flag provides an application "
"with a race-free way of ensuring that the monitored object is a directory."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:373
#, no-wrap
msgid "B<IN_MASK_CREATE> (since Linux 4.18)"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:383
msgid ""
"Watch I<pathname> only if it does not already have a watch associated with "
"it; the error B<EEXIST> results if I<pathname> is already being watched."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:390
msgid ""
"Using this flag provides an application with a way of ensuring that new "
"watches do not modify existing ones.  This is useful because multiple paths "
"may refer to the same inode, and multiple calls to B<inotify_add_watch>(2)  "
"without this flag may clobber existing watch masks."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:396
msgid "The following bits may be set in the I<mask> field returned by B<read>(2):"
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:397
#, no-wrap
msgid "B<IN_IGNORED>"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:403
msgid ""
"Watch was removed explicitly (B<inotify_rm_watch>(2))  or automatically "
"(file was deleted, or filesystem was unmounted).  See also BUGS."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:403
#, no-wrap
msgid "B<IN_ISDIR>"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:406
msgid "Subject of this event is a directory."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:406
#, no-wrap
msgid "B<IN_Q_OVERFLOW>"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:411
msgid "Event queue overflowed (I<wd> is -1 for this event)."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:411
#, no-wrap
msgid "B<IN_UNMOUNT>"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:417
msgid ""
"Filesystem containing watched object was unmounted.  In addition, an "
"B<IN_IGNORED> event will subsequently be generated for the watch descriptor."
msgstr ""

#. type: SS
#: build/C/man7/inotify.7:418
#, no-wrap
msgid "Examples"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:426
msgid ""
"Suppose an application is watching the directory I<dir> and the file "
"I<dir/myfile> for all events.  The examples below show some events that will "
"be generated for these two objects."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:427
#, no-wrap
msgid "fd = open(\"dir/myfile\", O_RDWR);"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:435
msgid "Generates B<IN_OPEN> events for both I<dir> and I<dir/myfile>."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:435
#, no-wrap
msgid "read(fd, buf, count);"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:443
msgid "Generates B<IN_ACCESS> events for both I<dir> and I<dir/myfile>."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:443
#, no-wrap
msgid "write(fd, buf, count);"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:451
msgid "Generates B<IN_MODIFY> events for both I<dir> and I<dir/myfile>."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:451
#, no-wrap
msgid "fchmod(fd, mode);"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:459
msgid "Generates B<IN_ATTRIB> events for both I<dir> and I<dir/myfile>."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:459
#, no-wrap
msgid "close(fd);"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:467
msgid "Generates B<IN_CLOSE_WRITE> events for both I<dir> and I<dir/myfile>."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:476
msgid ""
"Suppose an application is watching the directories I<dir1> and I<dir2>, and "
"the file I<dir1/myfile>.  The following examples show some events that may "
"be generated."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:477
#, no-wrap
msgid "link(\"dir1/myfile\", \"dir2/new\");"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:487
msgid ""
"Generates an B<IN_ATTRIB> event for I<myfile> and an B<IN_CREATE> event for "
"I<dir2>."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:487
#, no-wrap
msgid "rename(\"dir1/myfile\", \"dir2/myfile\");"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:508
msgid ""
"Generates an B<IN_MOVED_FROM> event for I<dir1>, an B<IN_MOVED_TO> event for "
"I<dir2>, and an B<IN_MOVE_SELF> event for I<myfile>.  The B<IN_MOVED_FROM> "
"and B<IN_MOVED_TO> events will have the same I<cookie> value."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:522
msgid ""
"Suppose that I<dir1/xx> and I<dir2/yy> are (the only) links to the same "
"file, and an application is watching I<dir1>, I<dir2>, I<dir1/xx>, and "
"I<dir2/yy>.  Executing the following calls in the order given below will "
"generate the following events:"
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:523
#, no-wrap
msgid "unlink(\"dir2/yy\");"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:534
msgid ""
"Generates an B<IN_ATTRIB> event for I<xx> (because its link count changes)  "
"and an B<IN_DELETE> event for I<dir2>."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:534
#, no-wrap
msgid "unlink(\"dir1/xx\");"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:547
msgid ""
"Generates B<IN_ATTRIB>, B<IN_DELETE_SELF>, and B<IN_IGNORED> events for "
"I<xx>, and an B<IN_DELETE> event for I<dir1>."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:554
msgid ""
"Suppose an application is watching the directory I<dir> and (the empty) "
"directory I<dir/subdir>.  The following examples show some events that may "
"be generated."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:555
#, no-wrap
msgid "mkdir(\"dir/new\", mode);"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:561
msgid "Generates an B<IN_CREATE | IN_ISDIR> event for I<dir>."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:561
#, no-wrap
msgid "rmdir(\"dir/subdir\");"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:573
msgid ""
"Generates B<IN_DELETE_SELF> and B<IN_IGNORED> events for I<subdir>, and an "
"B<IN_DELETE | IN_ISDIR> event for I<dir>."
msgstr ""

#. type: SS
#: build/C/man7/inotify.7:574
#, no-wrap
msgid "/proc interfaces"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:577
msgid ""
"The following interfaces can be used to limit the amount of kernel memory "
"consumed by inotify:"
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:577
#, no-wrap
msgid "I</proc/sys/fs/inotify/max_queued_events>"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:586
msgid ""
"The value in this file is used when an application calls B<inotify_init>(2)  "
"to set an upper limit on the number of events that can be queued to the "
"corresponding inotify instance.  Events in excess of this limit are dropped, "
"but an B<IN_Q_OVERFLOW> event is always generated."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:586
#, no-wrap
msgid "I</proc/sys/fs/inotify/max_user_instances>"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:590
msgid ""
"This specifies an upper limit on the number of inotify instances that can be "
"created per real user ID."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:590
#, no-wrap
msgid "I</proc/sys/fs/inotify/max_user_watches>"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:594
msgid ""
"This specifies an upper limit on the number of watches that can be created "
"per real user ID."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:602
msgid ""
"Inotify was merged into the 2.6.13 Linux kernel.  The required library "
"interfaces were added to glibc in version 2.4.  (B<IN_DONT_FOLLOW>, "
"B<IN_MASK_ADD>, and B<IN_ONLYDIR> were added in glibc version 2.5.)"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:604
msgid "The inotify API is Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:611
msgid ""
"Inotify file descriptors can be monitored using B<select>(2), B<poll>(2), "
"and B<epoll>(7).  When an event is available, the file descriptor indicates "
"as readable."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:640
msgid ""
"Since Linux 2.6.25, signal-driven I/O notification is available for inotify "
"file descriptors; see the discussion of B<F_SETFL> (for setting the "
"B<O_ASYNC> flag), B<F_SETOWN>, and B<F_SETSIG> in B<fcntl>(2).  The "
"I<siginfo_t> structure (described in B<sigaction>(2))  that is passed to the "
"signal handler has the following fields set: I<si_fd> is set to the inotify "
"file descriptor number; I<si_signo> is set to the signal number; I<si_code> "
"is set to B<POLL_IN>; and B<POLLIN> is set in I<si_band>."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:653
msgid ""
"If successive output inotify events produced on the inotify file descriptor "
"are identical (same I<wd>, I<mask>, I<cookie>, and I<name>), then they are "
"coalesced into a single event if the older event has not yet been read (but "
"see BUGS).  This reduces the amount of kernel memory required for the event "
"queue, but also means that an application can't use inotify to reliably "
"count file events."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:659
msgid ""
"The events returned by reading from an inotify file descriptor form an "
"ordered queue.  Thus, for example, it is guaranteed that when renaming from "
"one directory to another, events will be produced in the correct order on "
"the inotify file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:673
msgid ""
"The set of watch descriptors that is being monitored via an inotify file "
"descriptor can be viewed via the entry for the inotify file descriptor in "
"the process's I</proc/[pid]/fdinfo> directory.  See B<proc>(5)  for further "
"details.  The B<FIONREAD> B<ioctl>(2)  returns the number of bytes available "
"to read from an inotify file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:680
msgid ""
"The inotify API provides no information about the user or process that "
"triggered the inotify event.  In particular, there is no easy way for a "
"process that is monitoring events via inotify to distinguish events that it "
"triggers itself from those that are triggered by other processes."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:693
msgid ""
"Inotify reports only events that a user-space program triggers through the "
"filesystem API.  As a result, it does not catch remote events that occur on "
"network filesystems.  (Applications must fall back to polling the filesystem "
"to catch such events.)  Furthermore, various pseudo-filesystems such as "
"I</proc>, I</sys>, and I</dev/pts> are not monitorable with inotify."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:700
msgid ""
"The inotify API does not report file accesses and modifications that may "
"occur because of B<mmap>(2), B<msync>(2), and B<munmap>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:704
msgid ""
"The inotify API identifies affected files by filename.  However, by the time "
"an application processes an inotify event, the filename may already have "
"been deleted or renamed."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:709
msgid ""
"The inotify API identifies events via watch descriptors.  It is the "
"application's responsibility to cache a mapping (if one is needed) between "
"watch descriptors and pathnames.  Be aware that directory renamings may "
"affect multiple cached pathnames."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:714
msgid ""
"Inotify monitoring of directories is not recursive: to monitor "
"subdirectories under a directory, additional watches must be created.  This "
"can take a significant amount time for large directory trees."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:723
msgid ""
"If monitoring an entire directory subtree, and a new subdirectory is created "
"in that tree or an existing directory is renamed into that tree, be aware "
"that by the time you create a watch for the new subdirectory, new files (and "
"subdirectories) may already exist inside the subdirectory.  Therefore, you "
"may want to scan the contents of the subdirectory immediately after adding "
"the watch (and, if desired, recursively add watches for any subdirectories "
"that it contains)."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:735
msgid ""
"Note that the event queue can overflow.  In this case, events are lost.  "
"Robust applications should handle the possibility of lost events "
"gracefully.  For example, it may be necessary to rebuild part or all of the "
"application cache.  (One simple, but possibly expensive, approach is to "
"close the inotify file descriptor, empty the cache, create a new inotify "
"file descriptor, and then re-create watches and cache entries for the "
"objects to be monitored.)"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:743
msgid ""
"If a filesystem is mounted on top of a monitored directory, no event is "
"generated, and no events are generated for objects immediately under the new "
"mount point.  If the filesystem is subsequently unmounted, events will "
"subsequently be generated for the directory and the objects it contains."
msgstr ""

#. type: SS
#: build/C/man7/inotify.7:743
#, no-wrap
msgid "Dealing with rename() events"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:752
msgid ""
"As noted above, the B<IN_MOVED_FROM> and B<IN_MOVED_TO> event pair that is "
"generated by B<rename>(2)  can be matched up via their shared cookie value.  "
"However, the task of matching has some challenges."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:769
msgid ""
"These two events are usually consecutive in the event stream available when "
"reading from the inotify file descriptor.  However, this is not guaranteed.  "
"If multiple processes are triggering events for monitored objects, then (on "
"rare occasions) an arbitrary number of other events may appear between the "
"B<IN_MOVED_FROM> and B<IN_MOVED_TO> events.  Furthermore, it is not "
"guaranteed that the event pair is atomically inserted into the queue: there "
"may be a brief interval where the B<IN_MOVED_FROM> has appeared, but the "
"B<IN_MOVED_TO> has not."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:794
msgid ""
"Matching up the B<IN_MOVED_FROM> and B<IN_MOVED_TO> event pair generated by "
"B<rename>(2)  is thus inherently racy.  (Don't forget that if an object is "
"renamed outside of a monitored directory, there may not even be an "
"B<IN_MOVED_TO> event.)  Heuristic approaches (e.g., assume the events are "
"always consecutive)  can be used to ensure a match in most cases, but will "
"inevitably miss some cases, causing the application to perceive the "
"B<IN_MOVED_FROM> and B<IN_MOVED_TO> events as being unrelated.  If watch "
"descriptors are destroyed and re-created as a result, then those watch "
"descriptors will be inconsistent with the watch descriptors in any pending "
"events.  (Re-creating the inotify file descriptor and rebuilding the cache "
"may be useful to deal with this scenario.)"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:811
msgid ""
"Applications should also allow for the possibility that the B<IN_MOVED_FROM> "
"event was the last event that could fit in the buffer returned by the "
"current call to B<read>(2), and the accompanying B<IN_MOVED_TO> event might "
"be fetched only on the next B<read>(2), which should be done with a (small) "
"timeout to allow for the fact that insertion of the "
"B<IN_MOVED_FROM>-B<IN_MOVED_TO> event pair is not atomic, and also the "
"possibility that there may not be any B<IN_MOVED_TO> event."
msgstr ""

#.  commit 820c12d5d6c0890bc93dd63893924a13041fdc35
#. type: Plain text
#: build/C/man7/inotify.7:822
msgid ""
"Before Linux 3.19, B<fallocate>(2)  did not create any inotify events.  "
"Since Linux 3.19, calls to B<fallocate>(2)  generate B<IN_MODIFY> events."
msgstr ""

#.  FIXME . kernel commit 611da04f7a31b2208e838be55a42c7a1310ae321
#.  implies that unmount events were buggy 2.6.11 to 2.6.36
#. type: Plain text
#: build/C/man7/inotify.7:830
msgid "In kernels before 2.6.16, the B<IN_ONESHOT> I<mask> flag does not work."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:840
msgid ""
"As originally designed and implemented, the B<IN_ONESHOT> flag did not cause "
"an B<IN_IGNORED> event to be generated when the watch was dropped after one "
"event.  However, as an unintended effect of other changes, since Linux "
"2.6.36, an B<IN_IGNORED> event is generated in this case."
msgstr ""

#.  commit 1c17d18e3775485bf1e0ce79575eb637a94494a2
#. type: Plain text
#: build/C/man7/inotify.7:849
msgid ""
"Before kernel 2.6.25, the kernel code that was intended to coalesce "
"successive identical events (i.e., the two most recent events could "
"potentially be coalesced if the older had not yet been read)  instead "
"checked if the most recent event could be coalesced with the I<oldest> "
"unread event."
msgstr ""

#.  FIXME . https://bugzilla.kernel.org/show_bug.cgi?id=77111
#. type: Plain text
#: build/C/man7/inotify.7:879
msgid ""
"When a watch descriptor is removed by calling B<inotify_rm_watch>(2)  (or "
"because a watch file is deleted or the filesystem that contains it is "
"unmounted), any pending unread events for that watch descriptor remain "
"available to read.  As watch descriptors are subsequently allocated with "
"B<inotify_add_watch>(2), the kernel cycles through the range of possible "
"watch descriptors (0 to B<INT_MAX>)  incrementally.  When allocating a free "
"watch descriptor, no check is made to see whether that watch descriptor "
"number has any pending unread events in the inotify queue.  Thus, it can "
"happen that a watch descriptor is reallocated even when pending unread "
"events exist for a previous incarnation of that watch descriptor number, "
"with the result that the application might then read those events and "
"interpret them as belonging to the file associated with the newly recycled "
"watch descriptor.  In practice, the likelihood of hitting this bug may be "
"extremely low, since it requires that an application cycle through "
"B<INT_MAX> watch descriptors, release a watch descriptor while leaving "
"unread events for that watch descriptor in the queue, and then recycle that "
"watch descriptor.  For this reason, and because there have been no reports "
"of the bug occurring in real-world applications, as of Linux 3.15, no kernel "
"changes have yet been made to eliminate this possible bug."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:887
msgid ""
"The following program demonstrates the usage of the inotify API.  It marks "
"the directories passed as a command-line arguments and waits for events of "
"type B<IN_OPEN>, B<IN_CLOSE_NOWRITE>, and B<IN_CLOSE_WRITE>."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:902
msgid ""
"The following output was recorded while editing the file "
"I</home/user/temp/foo> and listing directory I</tmp>.  Before the file and "
"the directory were opened, B<IN_OPEN> events occurred.  After the file was "
"closed, an B<IN_CLOSE_WRITE> event occurred.  After the directory was "
"closed, an B<IN_CLOSE_NOWRITE> event occurred.  Execution of the program "
"ended when the user pressed the ENTER key."
msgstr ""

#. type: SS
#: build/C/man7/inotify.7:902
#, no-wrap
msgid "Example output"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:912
#, no-wrap
msgid ""
"$ B<./a.out /tmp /home/user/temp>\n"
"Press enter key to terminate.\n"
"Listening for events.\n"
"IN_OPEN: /home/user/temp/foo [file]\n"
"IN_CLOSE_WRITE: /home/user/temp/foo [file]\n"
"IN_OPEN: /tmp/ [directory]\n"
"IN_CLOSE_NOWRITE: /tmp/ [directory]\n"
msgstr ""

#. type: SS
#: build/C/man7/inotify.7:916
#, no-wrap
msgid "Program source"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:926
#, no-wrap
msgid ""
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>poll.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/inotify.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:932
#, no-wrap
msgid ""
"/* Read all available inotify events from the file descriptor "
"\\(aqfd\\(aq.\n"
"   wd is the table of watch descriptors for the directories in argv.\n"
"   argc is the length of wd and argv.\n"
"   argv is the list of watched directories.\n"
"   Entry 0 of wd and argv is unused. */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:941
#, no-wrap
msgid ""
"static void\n"
"handle_events(int fd, int *wd, int argc, char* argv[])\n"
"{\n"
"    /* Some systems cannot read integer variables if they are not\n"
"       properly aligned. On other systems, incorrect alignment may\n"
"       decrease performance. Hence, the buffer used for reading from\n"
"       the inotify file descriptor should have the same alignment as\n"
"       struct inotify_event. */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:946
#, no-wrap
msgid ""
"    char buf[4096]\n"
"        __attribute__ ((aligned(__alignof__(struct inotify_event))));\n"
"    const struct inotify_event *event;\n"
"    ssize_t len;\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:948
#, no-wrap
msgid "    /* Loop while events can be read from inotify file descriptor. */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:952
#, no-wrap
msgid "        /* Read some events. */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:962
#, no-wrap
msgid ""
"        /* If the nonblocking read() found no events to read, then\n"
"           it returns -1 with errno set to EAGAIN. In that case,\n"
"           we exit the loop. */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:970
#, no-wrap
msgid ""
"        for (char *ptr = buf; ptr E<lt> buf + len;\n"
"                ptr += sizeof(struct inotify_event) + event-E<gt>len) {\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:972
#, no-wrap
msgid "            event = (const struct inotify_event *) ptr;\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:974
#, no-wrap
msgid "            /* Print event type */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:981
#, no-wrap
msgid ""
"            if (event-E<gt>mask & IN_OPEN)\n"
"                printf(\"IN_OPEN: \");\n"
"            if (event-E<gt>mask & IN_CLOSE_NOWRITE)\n"
"                printf(\"IN_CLOSE_NOWRITE: \");\n"
"            if (event-E<gt>mask & IN_CLOSE_WRITE)\n"
"                printf(\"IN_CLOSE_WRITE: \");\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:983
#, no-wrap
msgid "            /* Print the name of the watched directory */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:990
#, no-wrap
msgid ""
"            for (int i = 1; i E<lt> argc; ++i) {\n"
"                if (wd[i] == event-E<gt>wd) {\n"
"                    printf(\"%s/\", argv[i]);\n"
"                    break;\n"
"                }\n"
"            }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:992
#, no-wrap
msgid "            /* Print the name of the file */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:995
#, no-wrap
msgid ""
"            if (event-E<gt>len)\n"
"                printf(\"%s\", event-E<gt>name);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:997
#, no-wrap
msgid "            /* Print type of filesystem object */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:1005
#, no-wrap
msgid ""
"            if (event-E<gt>mask & IN_ISDIR)\n"
"                printf(\" [directory]\\en\");\n"
"            else\n"
"                printf(\" [file]\\en\");\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:1014
#, no-wrap
msgid ""
"int\n"
"main(int argc, char* argv[])\n"
"{\n"
"    char buf;\n"
"    int fd, i, poll_num;\n"
"    int *wd;\n"
"    nfds_t nfds;\n"
"    struct pollfd fds[2];\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:1019
#, no-wrap
msgid ""
"    if (argc E<lt> 2) {\n"
"        printf(\"Usage: %s PATH [PATH ...]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:1021
#, no-wrap
msgid "    printf(\"Press ENTER key to terminate.\\en\");\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:1023
#, no-wrap
msgid "    /* Create the file descriptor for accessing the inotify API */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:1029
#, no-wrap
msgid ""
"    fd = inotify_init1(IN_NONBLOCK);\n"
"    if (fd == -1) {\n"
"        perror(\"inotify_init1\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:1031
#, no-wrap
msgid "    /* Allocate memory for watch descriptors */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:1037
#, no-wrap
msgid ""
"    wd = calloc(argc, sizeof(int));\n"
"    if (wd == NULL) {\n"
"        perror(\"calloc\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:1041
#, no-wrap
msgid ""
"    /* Mark directories for events\n"
"       - file was opened\n"
"       - file was closed */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:1051
#, no-wrap
msgid ""
"    for (i = 1; i E<lt> argc; i++) {\n"
"        wd[i] = inotify_add_watch(fd, argv[i],\n"
"                                  IN_OPEN | IN_CLOSE);\n"
"        if (wd[i] == -1) {\n"
"            fprintf(stderr, \"Cannot watch \\(aq%s\\(aq: %s\\en\",\n"
"                    argv[i], strerror(errno));\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:1062
#, no-wrap
msgid "    /* Inotify input */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:1067
#, no-wrap
msgid "    /* Wait for events and/or terminal input */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:1077
#, no-wrap
msgid ""
"    printf(\"Listening for events.\\en\");\n"
"    while (1) {\n"
"        poll_num = poll(fds, nfds, -1);\n"
"        if (poll_num == -1) {\n"
"            if (errno == EINTR)\n"
"                continue;\n"
"            perror(\"poll\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:1079
#, no-wrap
msgid "        if (poll_num E<gt> 0) {\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:1081
#, no-wrap
msgid "            if (fds[0].revents & POLLIN) {\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:1083
#, no-wrap
msgid "                /* Console input is available. Empty stdin and quit */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:1092
#, no-wrap
msgid "                /* Inotify events are available */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:1097
#, no-wrap
msgid ""
"                handle_events(fd, wd, argc, argv);\n"
"            }\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:1099
#, no-wrap
msgid "    printf(\"Listening for events stopped.\\en\");\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:1101
#, no-wrap
msgid "    /* Close inotify file descriptor */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:1103
#, no-wrap
msgid "    close(fd);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:1107
#, no-wrap
msgid ""
"    free(wd);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:1118
msgid ""
"B<inotifywait>(1), B<inotifywatch>(1), B<inotify_add_watch>(2), "
"B<inotify_init>(2), B<inotify_init1>(2), B<inotify_rm_watch>(2), B<read>(2), "
"B<stat>(2), B<fanotify>(7)"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:1121
msgid "I<Documentation/filesystems/inotify.txt> in the Linux kernel source tree"
msgstr ""

#. type: TH
#: build/C/man2/inotify_add_watch.2:28
#, no-wrap
msgid "INOTIFY_ADD_WATCH"
msgstr ""

#. type: TH
#: build/C/man2/inotify_add_watch.2:28 build/C/man2/inotify_init.2:29
#, no-wrap
msgid "2020-04-11"
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:31
msgid "inotify_add_watch - add a watch to an initialized inotify instance"
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:33 build/C/man2/inotify_rm_watch.2:32
msgid "B<#include E<lt>sys/inotify.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:35
msgid ""
"B<int inotify_add_watch(int >I<fd>B<, const char *>I<pathname>B<, uint32_t "
">I<mask>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:54
msgid ""
"B<inotify_add_watch>()  adds a new watch, or modifies an existing watch, for "
"the file whose location is specified in I<pathname>; the caller must have "
"read permission for this file.  The I<fd> argument is a file descriptor "
"referring to the inotify instance whose watch list is to be modified.  The "
"events to be monitored for I<pathname> are specified in the I<mask> bit-mask "
"argument.  See B<inotify>(7)  for a description of the bits that can be set "
"in I<mask>."
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:66
msgid ""
"A successful call to B<inotify_add_watch>()  returns a unique watch "
"descriptor for this inotify instance, for the filesystem object (inode) that "
"corresponds to I<pathname>.  If the filesystem object was not previously "
"being watched by this inotify instance, then the watch descriptor is newly "
"allocated.  If the filesystem object was already being watched (perhaps via "
"a different link to the same object), then the descriptor for the existing "
"watch is returned."
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:77
msgid ""
"The watch descriptor is returned by later B<read>(2)s from the inotify file "
"descriptor.  These reads fetch I<inotify_event> structures (see "
"B<inotify>(7))  indicating filesystem events; the watch descriptor inside "
"this structure identifies the object for which the event occurred."
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:84
msgid ""
"On success, B<inotify_add_watch>()  returns a watch descriptor (a "
"nonnegative integer).  On error, -1 is returned and I<errno> is set "
"appropriately."
msgstr ""

#. type: TP
#: build/C/man2/inotify_add_watch.2:85
#, no-wrap
msgid "B<EACCES>"
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:88
msgid "Read access to the given file is not permitted."
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:91
msgid "The given file descriptor is not valid."
msgstr ""

#. type: TP
#: build/C/man2/inotify_add_watch.2:91
#, no-wrap
msgid "B<EEXIST>"
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:100
msgid ""
"I<mask> contains B<IN_MASK_CREATE> and I<pathname> refers to a file already "
"being watched by the same I<fd>."
msgstr ""

#. type: TP
#: build/C/man2/inotify_add_watch.2:100
#, no-wrap
msgid "B<EFAULT>"
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:104
msgid "I<pathname> points outside of the process's accessible address space."
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:115
msgid ""
"The given event mask contains no valid events; or I<mask> contains both "
"B<IN_MASK_ADD> and B<IN_MASK_CREATE>; or I<fd> is not an inotify file "
"descriptor."
msgstr ""

#. type: TP
#: build/C/man2/inotify_add_watch.2:115
#, no-wrap
msgid "B<ENAMETOOLONG>"
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:119
msgid "I<pathname> is too long."
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:124
msgid ""
"A directory component in I<pathname> does not exist or is a dangling "
"symbolic link."
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:127
msgid "Insufficient kernel memory was available."
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:131
msgid ""
"The user limit on the total number of inotify watches was reached or the "
"kernel failed to allocate a needed resource."
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:139
msgid "I<mask> contains B<IN_ONLYDIR> and I<pathname> is not a directory."
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:141 build/C/man2/inotify_rm_watch.2:69
msgid "Inotify was merged into the 2.6.13 Linux kernel."
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:146
msgid "See B<inotify>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:150
msgid "B<inotify_init>(2), B<inotify_rm_watch>(2), B<inotify>(7)"
msgstr ""

#. type: TH
#: build/C/man2/inotify_init.2:29
#, no-wrap
msgid "INOTIFY_INIT"
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_init.2:32
msgid "inotify_init, inotify_init1 - initialize an inotify instance"
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_init.2:35
#, no-wrap
msgid "B<#include E<lt>sys/inotify.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_init.2:38
#, no-wrap
msgid ""
"B<int inotify_init(void);>\n"
"B<int inotify_init1(int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_init.2:42
msgid "For an overview of the inotify API, see B<inotify>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_init.2:46
msgid ""
"B<inotify_init>()  initializes a new inotify instance and returns a file "
"descriptor associated with a new inotify event queue."
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_init.2:56
msgid ""
"If I<flags> is 0, then B<inotify_init1>()  is the same as "
"B<inotify_init>().  The following values can be bitwise ORed in I<flags> to "
"obtain different behavior:"
msgstr ""

#. type: TP
#: build/C/man2/inotify_init.2:56
#, no-wrap
msgid "B<IN_NONBLOCK>"
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_init.2:66
msgid ""
"Set the B<O_NONBLOCK> file status flag on the open file description (see "
"B<open>(2))  referred to by the new file descriptor.  Using this flag saves "
"extra calls to B<fcntl>(2)  to achieve the same result."
msgstr ""

#. type: TP
#: build/C/man2/inotify_init.2:66
#, no-wrap
msgid "B<IN_CLOEXEC>"
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_init.2:76
msgid ""
"Set the close-on-exec (B<FD_CLOEXEC>)  flag on the new file descriptor.  See "
"the description of the B<O_CLOEXEC> flag in B<open>(2)  for reasons why this "
"may be useful."
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_init.2:81
msgid ""
"On success, these system calls return a new file descriptor.  On error, -1 "
"is returned, and I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_init.2:87
msgid "(B<inotify_init1>())  An invalid value was specified in I<flags>."
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_init.2:90
msgid "The user limit on the total number of inotify instances has been reached."
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_init.2:96
msgid "The system-wide limit on the total number of open files has been reached."
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_init.2:99
msgid "Insufficient kernel memory is available."
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_init.2:106
msgid ""
"B<inotify_init>()  first appeared in Linux 2.6.13; library support was added "
"to glibc in version 2.4.  B<inotify_init1>()  was added in Linux 2.6.27; "
"library support was added to glibc in version 2.9."
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_init.2:108
msgid "These system calls are Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_init.2:112
msgid "B<inotify_add_watch>(2), B<inotify_rm_watch>(2), B<inotify>(7)"
msgstr ""

#. type: TH
#: build/C/man2/inotify_rm_watch.2:27
#, no-wrap
msgid "INOTIFY_RM_WATCH"
msgstr ""

#. type: TH
#: build/C/man2/inotify_rm_watch.2:27
#, no-wrap
msgid "2017-09-15"
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_rm_watch.2:30
msgid "inotify_rm_watch - remove an existing watch from an inotify instance"
msgstr ""

#.  Before glibc 2.10, the second argument was types as uint32_t.
#.  http://sources.redhat.com/bugzilla/show_bug.cgi?id=7040
#. type: Plain text
#: build/C/man2/inotify_rm_watch.2:36
msgid "B<int inotify_rm_watch(int >I<fd>B<, int >I<wd>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_rm_watch.2:42
msgid ""
"B<inotify_rm_watch>()  removes the watch associated with the watch "
"descriptor I<wd> from the inotify instance associated with the file "
"descriptor I<fd>."
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_rm_watch.2:48
msgid ""
"Removing a watch causes an B<IN_IGNORED> event to be generated for this "
"watch descriptor.  (See B<inotify>(7).)"
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_rm_watch.2:55
msgid ""
"On success, B<inotify_rm_watch>()  returns zero.  On error, -1 is returned "
"and I<errno> is set to indicate the cause of the error."
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_rm_watch.2:60
msgid "I<fd> is not a valid file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_rm_watch.2:67
msgid ""
"The watch descriptor I<wd> is not valid; or I<fd> is not an inotify file "
"descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_rm_watch.2:75
msgid "B<inotify_add_watch>(2), B<inotify_init>(2), B<inotify>(7)"
msgstr ""
