# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-03-12 14:01+0900\n"
"PO-Revision-Date: 2021-07-19 09:40+0900\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man2/_syscall.2:38
#, no-wrap
msgid "_SYSCALL"
msgstr "_SYSCALL"

#. type: TH
#: build/C/man2/_syscall.2:38 build/C/man2/chown.2:38 build/C/man2/close.2:36
#: build/C/man3/confstr.3:33 build/C/man2/fork.2:39 build/C/man2/fsync.2:38
#: build/C/man3/get_nprocs_conf.3:26 build/C/man3/getdtablesize.3:27
#: build/C/man3/getopt.3:42 build/C/man2/mkdir.2:11 build/C/man5/shells.5:28
#: build/C/man2/syscall.2:42
#, no-wrap
msgid "2020-06-09"
msgstr "2020-06-09"

#. type: TH
#: build/C/man2/_syscall.2:38 build/C/man2/access.2:43 build/C/man2/alarm.2:30
#: build/C/man2/brk.2:29 build/C/man2/chdir.2:33 build/C/man2/chmod.2:32
#: build/C/man2/chown.2:38 build/C/man2/chroot.2:33 build/C/man2/close.2:36
#: build/C/man2/dup.2:37 build/C/man7/environ.7:34 build/C/man2/execve.2:37
#: build/C/man2/exit_group.2:25 build/C/man2/fcntl.2:67
#: build/C/man3/fexecve.3:25 build/C/man2/flock.2:35 build/C/man2/fork.2:39
#: build/C/man2/fsync.2:38 build/C/man2/getdomainname.2:29
#: build/C/man3/getdtablesize.3:27 build/C/man3/gethostid.3:29
#: build/C/man2/gethostname.2:32 build/C/man2/getpagesize.2:25
#: build/C/man2/gettid.2:26 build/C/man2/idle.2:32 build/C/man2/ioperm.2:34
#: build/C/man2/mincore.2:34 build/C/man2/mkdir.2:11 build/C/man2/nice.2:31
#: build/C/man2/pread.2:25 build/C/man2/set_thread_area.2:9
#: build/C/man2/setup.2:34 build/C/man2/swapon.2:42 build/C/man2/syscall.2:42
#: build/C/man2/syscalls.2:31 build/C/man2/sysctl.2:30
#: build/C/man2/sysinfo.2:35 build/C/man2/truncate.2:43 build/C/man2/umask.2:34
#: build/C/man2/uname.2:27 build/C/man2/uselib.2:31 build/C/man2/vfork.2:29
#: build/C/man2/vhangup.2:28 build/C/man2/execveat.2:26
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#: build/C/man2/_syscall.2:38 build/C/man2/access.2:43 build/C/man2/alarm.2:30
#: build/C/man2/brk.2:29 build/C/man2/chdir.2:33 build/C/man2/chmod.2:32
#: build/C/man2/chown.2:38 build/C/man2/chroot.2:33 build/C/man2/close.2:36
#: build/C/man3/confstr.3:33 build/C/man3/crypt.3:36 build/C/man3/daemon.3:36
#: build/C/man3/des_crypt.3:14 build/C/man2/dup.2:37 build/C/man3/encrypt.3:30
#: build/C/man7/environ.7:34 build/C/man3/euidaccess.3:25
#: build/C/man3/exec.3:41 build/C/man2/execve.2:37 build/C/man2/exit_group.2:25
#: build/C/man2/fcntl.2:67 build/C/man3/fexecve.3:25 build/C/man2/flock.2:35
#: build/C/man2/fork.2:39 build/C/man3/fpathconf.3:42 build/C/man2/fsync.2:38
#: build/C/man3/get_nprocs_conf.3:26 build/C/man3/getcwd.3:32
#: build/C/man2/getdomainname.2:29 build/C/man3/getdtablesize.3:27
#: build/C/man3/gethostid.3:29 build/C/man2/gethostname.2:32
#: build/C/man3/getlogin.3:28 build/C/man3/getopt.3:42
#: build/C/man2/getpagesize.2:25 build/C/man2/gettid.2:26
#: build/C/man3/getumask.3:28 build/C/man3/getusershell.3:30
#: build/C/man2/idle.2:32 build/C/man2/ioperm.2:34 build/C/man3/lockf.3:28
#: build/C/man2/mincore.2:34 build/C/man2/mkdir.2:11 build/C/man2/nice.2:31
#: build/C/man2/pread.2:25 build/C/man2/set_thread_area.2:9
#: build/C/man2/setup.2:34 build/C/man5/shells.5:28 build/C/man3/sleep.3:26
#: build/C/man3/swab.3:31 build/C/man2/swapon.2:42 build/C/man2/syscall.2:42
#: build/C/man2/syscalls.2:31 build/C/man3/sysconf.3:27
#: build/C/man2/sysctl.2:30 build/C/man2/sysinfo.2:35
#: build/C/man3/tcgetpgrp.3:25 build/C/man2/truncate.2:43
#: build/C/man3/ualarm.3:24 build/C/man2/umask.2:34 build/C/man2/uname.2:27
#: build/C/man2/uselib.2:31 build/C/man3/usleep.3:33 build/C/man2/vfork.2:29
#: build/C/man2/vhangup.2:28 build/C/man2/execveat.2:26
#: build/C/man3/get_phys_pages.3:25
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux Programmer's Manual"

#. type: SH
#: build/C/man2/_syscall.2:39 build/C/man2/access.2:44 build/C/man2/alarm.2:31
#: build/C/man2/brk.2:30 build/C/man2/chdir.2:34 build/C/man2/chmod.2:33
#: build/C/man2/chown.2:39 build/C/man2/chroot.2:34 build/C/man2/close.2:37
#: build/C/man3/confstr.3:34 build/C/man3/crypt.3:37 build/C/man3/daemon.3:37
#: build/C/man3/des_crypt.3:15 build/C/man2/dup.2:38 build/C/man3/encrypt.3:31
#: build/C/man7/environ.7:35 build/C/man3/euidaccess.3:26
#: build/C/man3/exec.3:42 build/C/man2/execve.2:38 build/C/man2/exit_group.2:26
#: build/C/man2/fcntl.2:68 build/C/man3/fexecve.3:26 build/C/man2/flock.2:36
#: build/C/man2/fork.2:40 build/C/man3/fpathconf.3:43 build/C/man2/fsync.2:39
#: build/C/man3/get_nprocs_conf.3:27 build/C/man3/getcwd.3:33
#: build/C/man2/getdomainname.2:30 build/C/man3/getdtablesize.3:28
#: build/C/man3/gethostid.3:30 build/C/man2/gethostname.2:33
#: build/C/man3/getlogin.3:29 build/C/man3/getopt.3:43
#: build/C/man2/getpagesize.2:26 build/C/man2/gettid.2:27
#: build/C/man3/getumask.3:29 build/C/man3/getusershell.3:31
#: build/C/man2/idle.2:33 build/C/man2/ioperm.2:35 build/C/man3/lockf.3:29
#: build/C/man2/mincore.2:35 build/C/man2/mkdir.2:12 build/C/man2/nice.2:32
#: build/C/man2/pread.2:26 build/C/man2/set_thread_area.2:10
#: build/C/man2/setup.2:35 build/C/man5/shells.5:29 build/C/man3/sleep.3:27
#: build/C/man3/swab.3:32 build/C/man2/swapon.2:43 build/C/man2/syscall.2:43
#: build/C/man2/syscalls.2:32 build/C/man3/sysconf.3:28
#: build/C/man2/sysctl.2:31 build/C/man2/sysinfo.2:36
#: build/C/man3/tcgetpgrp.3:26 build/C/man2/truncate.2:44
#: build/C/man3/ualarm.3:25 build/C/man2/umask.2:35 build/C/man2/uname.2:28
#: build/C/man2/uselib.2:32 build/C/man3/usleep.3:34 build/C/man2/vfork.2:30
#: build/C/man2/vhangup.2:29 build/C/man2/execveat.2:27
#: build/C/man3/get_phys_pages.3:26
#, no-wrap
msgid "NAME"
msgstr "名前"

#. type: Plain text
#: build/C/man2/_syscall.2:41
msgid "_syscall - invoking a system call without library support (OBSOLETE)"
msgstr ""
"_syscall - ライブラリのサポートなしでシステムコールを起動する (昔の方法)"

#. type: SH
#: build/C/man2/_syscall.2:41 build/C/man2/access.2:46 build/C/man2/alarm.2:33
#: build/C/man2/brk.2:32 build/C/man2/chdir.2:36 build/C/man2/chmod.2:35
#: build/C/man2/chown.2:41 build/C/man2/chroot.2:36 build/C/man2/close.2:39
#: build/C/man3/confstr.3:36 build/C/man3/crypt.3:39 build/C/man3/daemon.3:39
#: build/C/man3/des_crypt.3:18 build/C/man2/dup.2:40 build/C/man3/encrypt.3:33
#: build/C/man7/environ.7:37 build/C/man3/euidaccess.3:28
#: build/C/man3/exec.3:44 build/C/man2/execve.2:40 build/C/man2/exit_group.2:28
#: build/C/man2/fcntl.2:70 build/C/man3/fexecve.3:28 build/C/man2/flock.2:38
#: build/C/man2/fork.2:42 build/C/man3/fpathconf.3:45 build/C/man2/fsync.2:41
#: build/C/man3/get_nprocs_conf.3:29 build/C/man3/getcwd.3:35
#: build/C/man2/getdomainname.2:32 build/C/man3/getdtablesize.3:30
#: build/C/man3/gethostid.3:32 build/C/man2/gethostname.2:35
#: build/C/man3/getlogin.3:31 build/C/man3/getopt.3:46
#: build/C/man2/getpagesize.2:28 build/C/man2/gettid.2:29
#: build/C/man3/getumask.3:31 build/C/man3/getusershell.3:33
#: build/C/man2/idle.2:35 build/C/man2/ioperm.2:37 build/C/man3/lockf.3:31
#: build/C/man2/mincore.2:37 build/C/man2/mkdir.2:14 build/C/man2/nice.2:34
#: build/C/man2/pread.2:28 build/C/man2/set_thread_area.2:12
#: build/C/man2/setup.2:37 build/C/man3/sleep.3:29 build/C/man3/swab.3:34
#: build/C/man2/swapon.2:45 build/C/man2/syscall.2:45
#: build/C/man2/syscalls.2:34 build/C/man3/sysconf.3:30
#: build/C/man2/sysctl.2:33 build/C/man2/sysinfo.2:38
#: build/C/man3/tcgetpgrp.3:28 build/C/man2/truncate.2:46
#: build/C/man3/ualarm.3:27 build/C/man2/umask.2:37 build/C/man2/uname.2:30
#: build/C/man2/uselib.2:34 build/C/man3/usleep.3:36 build/C/man2/vfork.2:32
#: build/C/man2/vhangup.2:31 build/C/man2/execveat.2:29
#: build/C/man3/get_phys_pages.3:29
#, no-wrap
msgid "SYNOPSIS"
msgstr "書式"

#. type: Plain text
#: build/C/man2/_syscall.2:43
msgid "B<#include E<lt>linux/unistd.hE<gt>>"
msgstr "B<#include E<lt>linux/unistd.hE<gt>>"

#. type: Plain text
#: build/C/man2/_syscall.2:45
msgid "A _syscall macro"
msgstr "A _syscall macro"

#. type: Plain text
#: build/C/man2/_syscall.2:47
msgid "desired system call"
msgstr "desired system call"

#. type: SH
#: build/C/man2/_syscall.2:47 build/C/man2/access.2:81 build/C/man2/alarm.2:39
#: build/C/man2/brk.2:74 build/C/man2/chdir.2:59 build/C/man2/chmod.2:92
#: build/C/man2/chown.2:85 build/C/man2/chroot.2:62 build/C/man2/close.2:45
#: build/C/man3/confstr.3:50 build/C/man3/crypt.3:54 build/C/man3/daemon.3:59
#: build/C/man3/des_crypt.3:34 build/C/man2/dup.2:53 build/C/man3/encrypt.3:54
#: build/C/man7/environ.7:41 build/C/man3/euidaccess.3:36
#: build/C/man3/exec.3:69 build/C/man2/execve.2:46 build/C/man2/exit_group.2:34
#: build/C/man2/fcntl.2:77 build/C/man3/fexecve.3:53 build/C/man2/flock.2:42
#: build/C/man2/fork.2:48 build/C/man3/fpathconf.3:52 build/C/man2/fsync.2:62
#: build/C/man3/get_nprocs_conf.3:35 build/C/man3/getcwd.3:74
#: build/C/man2/getdomainname.2:57 build/C/man3/getdtablesize.3:58
#: build/C/man3/gethostid.3:61 build/C/man2/gethostname.2:69
#: build/C/man3/getlogin.3:59 build/C/man3/getopt.3:80
#: build/C/man2/getpagesize.2:59 build/C/man2/gettid.2:37
#: build/C/man3/getumask.3:39 build/C/man3/getusershell.3:63
#: build/C/man2/idle.2:39 build/C/man2/ioperm.2:42 build/C/man3/lockf.3:50
#: build/C/man2/mincore.2:54 build/C/man2/mkdir.2:46 build/C/man2/nice.2:48
#: build/C/man2/pread.2:53 build/C/man2/set_thread_area.2:36
#: build/C/man2/setup.2:41 build/C/man5/shells.5:31 build/C/man3/sleep.3:35
#: build/C/man3/swab.3:41 build/C/man2/swapon.2:53 build/C/man2/syscall.2:70
#: build/C/man2/syscalls.2:36 build/C/man3/sysconf.3:36
#: build/C/man2/sysctl.2:40 build/C/man2/sysinfo.2:42
#: build/C/man3/tcgetpgrp.3:34 build/C/man2/truncate.2:77
#: build/C/man3/ualarm.3:57 build/C/man2/umask.2:43 build/C/man2/uname.2:34
#: build/C/man2/uselib.2:41 build/C/man3/usleep.3:66 build/C/man2/vfork.2:62
#: build/C/man2/vhangup.2:53 build/C/man2/execveat.2:37
#: build/C/man3/get_phys_pages.3:36
#, no-wrap
msgid "DESCRIPTION"
msgstr "説明"

#. type: Plain text
#: build/C/man2/_syscall.2:53
msgid ""
"The important thing to know about a system call is its prototype.  You need "
"to know how many arguments, their types, and the function return type.  "
"There are seven macros that make the actual call into the system easier.  "
"They have the form:"
msgstr ""
"システムコールに関してそのプロトタイプを知ることが重要である。 引数の個数、"
"それらの型、返り値の型を知る必要がある。 実際の使用にあたっては、システムコー"
"ルをシステムに呼び出しやすくするために、 7 個のマクロが用意されている。これら"
"のマクロは以下の形である。"

#. type: Plain text
#: build/C/man2/_syscall.2:57
#, no-wrap
msgid "_syscallI<X>(I<type>,I<name>,I<type1>,I<arg1>,I<type2>,I<arg2>,...)\n"
msgstr "_syscallI<X>(I<type>,I<name>,I<type1>,I<arg1>,I<type2>,I<arg2>,...)\n"

#. type: Plain text
#: build/C/man2/_syscall.2:61
msgid "where"
msgstr "ここで"

#. type: Plain text
#: build/C/man2/_syscall.2:65
msgid ""
"I<X> is 0\\(en6, which are the number of arguments taken by the system call"
msgstr "I<X> は 0〜6 で、システムコールが取る引数の個数である。"

#. type: Plain text
#: build/C/man2/_syscall.2:68
msgid "I<type> is the return type of the system call"
msgstr "I<type> はシステムコールの返り値の型である。"

#. type: Plain text
#: build/C/man2/_syscall.2:71
msgid "I<name> is the name of the system call"
msgstr "I<name> はシステムコールの名前である。"

#. type: Plain text
#: build/C/man2/_syscall.2:74
msgid "I<typeN> is the Nth argument's type"
msgstr "I<typeN> は N 番目の引数の型である。"

#. type: Plain text
#: build/C/man2/_syscall.2:77
msgid "I<argN> is the name of the Nth argument"
msgstr "I<argN> は N 番目の引数の名前である。"

#. type: Plain text
#: build/C/man2/_syscall.2:85
msgid ""
"These macros create a function called I<name> with the arguments you "
"specify.  Once you include the _syscall() in your source file, you call the "
"system call by I<name>."
msgstr ""
"これらのマクロは、指定した引数を持つ I<name> という名前の関数を生成する。 "
"一度ソースファイルの中で _syscall() をインクルードしておくと、 そのシステム"
"コールを I<name> という名前で呼ぶことができる。"

#. type: SH
#: build/C/man2/_syscall.2:85 build/C/man3/getlogin.3:139
#: build/C/man3/getusershell.3:95 build/C/man5/shells.5:43
#, no-wrap
msgid "FILES"
msgstr "ファイル"

#. type: Plain text
#: build/C/man2/_syscall.2:87
msgid "I</usr/include/linux/unistd.h>"
msgstr "I</usr/include/linux/unistd.h>"

#. type: SH
#: build/C/man2/_syscall.2:87 build/C/man2/access.2:301 build/C/man2/alarm.2:59
#: build/C/man2/brk.2:123 build/C/man2/chdir.2:131 build/C/man2/chmod.2:348
#: build/C/man2/chown.2:320 build/C/man2/chroot.2:160 build/C/man2/close.2:100
#: build/C/man3/confstr.3:141 build/C/man3/crypt.3:185
#: build/C/man3/daemon.3:111 build/C/man3/des_crypt.3:156
#: build/C/man2/dup.2:209 build/C/man3/encrypt.3:150
#: build/C/man3/euidaccess.3:86 build/C/man3/exec.3:213
#: build/C/man2/execve.2:560 build/C/man2/exit_group.2:43
#: build/C/man2/fcntl.2:1831 build/C/man3/fexecve.3:119
#: build/C/man2/flock.2:139 build/C/man2/fork.2:279
#: build/C/man3/fpathconf.3:269 build/C/man2/fsync.2:152
#: build/C/man3/get_nprocs_conf.3:63 build/C/man3/getcwd.3:226
#: build/C/man2/getdomainname.2:119 build/C/man3/getdtablesize.3:82
#: build/C/man3/gethostid.3:113 build/C/man2/gethostname.2:132
#: build/C/man3/getlogin.3:190 build/C/man3/getopt.3:344
#: build/C/man2/getpagesize.2:68 build/C/man2/gettid.2:61
#: build/C/man3/getumask.3:58 build/C/man3/getusershell.3:112
#: build/C/man2/idle.2:61 build/C/man2/ioperm.2:99 build/C/man3/lockf.3:173
#: build/C/man2/mincore.2:137 build/C/man2/mkdir.2:213 build/C/man2/nice.2:92
#: build/C/man2/pread.2:123 build/C/man2/set_thread_area.2:168
#: build/C/man2/setup.2:62 build/C/man3/sleep.3:58 build/C/man3/swab.3:84
#: build/C/man2/swapon.2:165 build/C/man3/sysconf.3:383
#: build/C/man2/sysctl.2:99 build/C/man2/sysinfo.2:114
#: build/C/man3/tcgetpgrp.3:122 build/C/man2/truncate.2:207
#: build/C/man3/ualarm.3:104 build/C/man2/umask.2:115 build/C/man2/uname.2:74
#: build/C/man2/uselib.2:79 build/C/man3/usleep.3:102 build/C/man2/vfork.2:162
#: build/C/man2/vhangup.2:71 build/C/man2/execveat.2:165
#: build/C/man3/get_phys_pages.3:58
#, no-wrap
msgid "CONFORMING TO"
msgstr "準拠"

#. type: Plain text
#: build/C/man2/_syscall.2:89
msgid "The use of these macros is Linux-specific, and deprecated."
msgstr "これらのマクロは Linux 固有であり、その使用は非推奨である。"

#. type: SH
#: build/C/man2/_syscall.2:89 build/C/man2/access.2:310 build/C/man2/alarm.2:61
#: build/C/man2/brk.2:131 build/C/man2/chdir.2:133 build/C/man2/chmod.2:355
#: build/C/man2/chown.2:337 build/C/man2/chroot.2:165 build/C/man2/close.2:103
#: build/C/man3/crypt.3:190 build/C/man3/daemon.3:117 build/C/man2/dup.2:219
#: build/C/man3/encrypt.3:160 build/C/man7/environ.7:236
#: build/C/man3/euidaccess.3:92 build/C/man3/exec.3:219
#: build/C/man2/execve.2:568 build/C/man2/exit_group.2:45
#: build/C/man2/fcntl.2:1896 build/C/man3/fexecve.3:124
#: build/C/man2/flock.2:148 build/C/man2/fork.2:281
#: build/C/man3/fpathconf.3:271 build/C/man2/fsync.2:167
#: build/C/man3/get_nprocs_conf.3:65 build/C/man3/getcwd.3:248
#: build/C/man2/getdomainname.2:122 build/C/man3/getdtablesize.3:90
#: build/C/man3/gethostid.3:124 build/C/man2/gethostname.2:138
#: build/C/man3/getopt.3:378 build/C/man2/getpagesize.2:75
#: build/C/man2/gettid.2:65 build/C/man3/getumask.3:60
#: build/C/man2/ioperm.2:103 build/C/man2/mkdir.2:220 build/C/man2/nice.2:99
#: build/C/man2/pread.2:125 build/C/man2/set_thread_area.2:174
#: build/C/man2/setup.2:65 build/C/man3/sleep.3:60 build/C/man2/swapon.2:171
#: build/C/man2/syscall.2:96 build/C/man2/syscalls.2:907
#: build/C/man2/sysctl.2:110 build/C/man2/sysinfo.2:117
#: build/C/man3/tcgetpgrp.3:124 build/C/man2/truncate.2:221
#: build/C/man3/ualarm.3:112 build/C/man2/umask.2:117 build/C/man2/uname.2:83
#: build/C/man2/uselib.2:83 build/C/man3/usleep.3:120 build/C/man2/vfork.2:177
#: build/C/man2/execveat.2:169 build/C/man3/get_phys_pages.3:60
#, no-wrap
msgid "NOTES"
msgstr "注意"

#. type: Plain text
#: build/C/man2/_syscall.2:99
msgid ""
"Starting around kernel 2.6.18, the _syscall macros were removed from header "
"files supplied to user space.  Use B<syscall>(2)  instead.  (Some "
"architectures, notably ia64, never provided the _syscall macros; on those "
"architectures, B<syscall>(2)  was always required.)"
msgstr ""
"カーネル 2.6.18 あたりから、_syscall マクロ群はユーザー空間に対して提供され"
"る ヘッダーファイルから削除された。代わりに B<syscall>(2)  を使用すること。 "
"(いくつかのアーキテクチャー、特に ia64、では、これまで _syscall マクロが 提供"
"されたことはない。このようなアーキテクチャーでは、常に B<syscall>(2)  が必要"
"であった。)"

#. type: Plain text
#: build/C/man2/_syscall.2:105
msgid ""
"The _syscall() macros I<do not> produce a prototype.  You may have to create "
"one, especially for C++ users."
msgstr ""
"_syscall() マクロはプロトタイプを「生成しない」。 ユーザーはプロトタイプを自"
"分で書かなければならないかもしれない。 とりわけ C++ ユーザーの場合はそうであ"
"ろう。"

#. type: Plain text
#: build/C/man2/_syscall.2:126
msgid ""
"System calls are not required to return only positive or negative error "
"codes.  You need to read the source to be sure how it will return errors.  "
"Usually, it is the negative of a standard error code, for example, -"
"I<EPERM>.  The _syscall() macros will return the result I<r> of the system "
"call when I<r> is nonnegative, but will return -1 and set the variable "
"I<errno> to -I<r> when I<r> is negative.  For the error codes, see "
"B<errno>(3)."
msgstr ""
"システムコールは、正のエラーコードのみ、または負のエラーコードのみを返すよう"
"に 定められている訳ではない。そのシステムコールがどのようなエラーコードを返す"
"かを 確認するには、そのソースコードを読む必要がある。たいていの場合は、標準の"
"エラー コードを負にしたものである (例えば -I<EPERM>)。 _syscall() マクロは、"
"そのシステムコールの返り値 I<r> が負でない場合、その値 をそのまま返す。一方、"
"I<r> が負の場合には、変数 I<errno> に -I<r> を設定し、-1 を返す。 エラーコー"
"ドについては B<errno>(3)  を参照。"

#.  The preferred way to invoke system calls that glibc does not know
#.  about yet is via
#.  .BR syscall (2).
#.  However, this mechanism can be used only if using a libc
#.  (such as glibc) that supports
#.  .BR syscall (2),
#.  and if the
#.  .I <sys/syscall.h>
#.  header file contains the required SYS_foo definition.
#.  Otherwise, the use of a _syscall macro is required.
#. type: Plain text
#: build/C/man2/_syscall.2:142
msgid ""
"When defining a system call, the argument types I<must> be passed by-value "
"or by-pointer (for aggregates like structs)."
msgstr ""
"システムコールを定義する際、引数の型は値渡し (by-value) か、 (構造体のよう"
"に集合的なデータの場合は) ポインター渡し (by-pointer)  でなければならない。"

#. type: SH
#: build/C/man2/_syscall.2:142 build/C/man2/chown.2:449
#: build/C/man3/confstr.3:143 build/C/man3/encrypt.3:166
#: build/C/man2/execve.2:783 build/C/man2/fork.2:311
#: build/C/man3/get_nprocs_conf.3:84 build/C/man3/getopt.3:397
#: build/C/man5/shells.5:45 build/C/man2/syscall.2:371
#: build/C/man2/sysctl.2:135 build/C/man3/get_phys_pages.3:79
#, no-wrap
msgid "EXAMPLES"
msgstr "例"

#. type: Plain text
#: build/C/man2/_syscall.2:149
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>linux/unistd.hE<gt>       /* for _syscallX macros/related stuff */\n"
"#include E<lt>linux/kernel.hE<gt>       /* for struct sysinfo */\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>linux/unistd.hE<gt>       /* for _syscallX macros/related stuff */\n"
"#include E<lt>linux/kernel.hE<gt>       /* for struct sysinfo */\n"

#. type: Plain text
#: build/C/man2/_syscall.2:151
#, no-wrap
msgid "_syscall1(int, sysinfo, struct sysinfo *, info);\n"
msgstr "_syscall1(int, sysinfo, struct sysinfo *, info);\n"

#. type: Plain text
#: build/C/man2/_syscall.2:157
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    struct sysinfo s_info;\n"
"    int error;\n"
msgstr ""
"int\n"
"main(void)\n"
"{\n"
"    struct sysinfo s_info;\n"
"    int error;\n"

#. type: Plain text
#: build/C/man2/_syscall.2:172
#, no-wrap
msgid ""
"    error = sysinfo(&s_info);\n"
"    printf(\"code error = %d\\en\", error);\n"
"    printf(\"Uptime = %lds\\enLoad: 1 min %lu / 5 min %lu / 15 min %lu\\en\"\n"
"           \"RAM: total %lu / free %lu / shared %lu\\en\"\n"
"           \"Memory in buffers = %lu\\enSwap: total %lu / free %lu\\en\"\n"
"           \"Number of processes = %d\\en\",\n"
"           s_info.uptime, s_info.loads[0],\n"
"           s_info.loads[1], s_info.loads[2],\n"
"           s_info.totalram, s_info.freeram,\n"
"           s_info.sharedram, s_info.bufferram,\n"
"           s_info.totalswap, s_info.freeswap,\n"
"           s_info.procs);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    error = sysinfo(&s_info);\n"
"    printf(\"code error = %d\\en\", error);\n"
"    printf(\"Uptime = %lds\\enLoad: 1 min %lu / 5 min %lu / 15 min %lu\\en\"\n"
"           \"RAM: total %lu / free %lu / shared %lu\\en\"\n"
"           \"Memory in buffers = %lu\\enSwap: total %lu / free %lu\\en\"\n"
"           \"Number of processes = %d\\en\",\n"
"           s_info.uptime, s_info.loads[0],\n"
"           s_info.loads[1], s_info.loads[2],\n"
"           s_info.totalram, s_info.freeram,\n"
"           s_info.sharedram, s_info.bufferram,\n"
"           s_info.totalswap, s_info.freeswap,\n"
"           s_info.procs);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: SS
#: build/C/man2/_syscall.2:173
#, no-wrap
msgid "Sample output"
msgstr "出力例"

#. type: Plain text
#: build/C/man2/_syscall.2:182
#, no-wrap
msgid ""
"code error = 0\n"
"uptime = 502034s\n"
"Load: 1 min 13376 / 5 min 5504 / 15 min 1152\n"
"RAM: total 15343616 / free 827392 / shared 8237056\n"
"Memory in buffers = 5066752\n"
"Swap: total 27881472 / free 24698880\n"
"Number of processes = 40\n"
msgstr ""
"code error = 0\n"
"uptime = 502034s\n"
"Load: 1 min 13376 / 5 min 5504 / 15 min 1152\n"
"RAM: total 15343616 / free 827392 / shared 8237056\n"
"Memory in buffers = 5066752\n"
"Swap: total 27881472 / free 24698880\n"
"Number of processes = 40\n"

#. type: SH
#: build/C/man2/_syscall.2:183 build/C/man2/access.2:450
#: build/C/man2/alarm.2:86 build/C/man2/brk.2:173 build/C/man2/chdir.2:142
#: build/C/man2/chmod.2:379 build/C/man2/chown.2:496 build/C/man2/chroot.2:181
#: build/C/man2/close.2:274 build/C/man3/confstr.3:159 build/C/man3/crypt.3:300
#: build/C/man3/daemon.3:145 build/C/man3/des_crypt.3:159
#: build/C/man2/dup.2:277 build/C/man3/encrypt.3:214 build/C/man7/environ.7:281
#: build/C/man3/euidaccess.3:107 build/C/man3/exec.3:290
#: build/C/man2/execve.2:876 build/C/man2/exit_group.2:49
#: build/C/man2/fcntl.2:2106 build/C/man3/fexecve.3:195
#: build/C/man2/flock.2:240 build/C/man2/fork.2:316
#: build/C/man3/fpathconf.3:280 build/C/man2/fsync.2:189
#: build/C/man3/get_nprocs_conf.3:105 build/C/man3/getcwd.3:316
#: build/C/man2/getdomainname.2:136 build/C/man3/getdtablesize.3:103
#: build/C/man3/gethostid.3:146 build/C/man2/gethostname.2:184
#: build/C/man3/getlogin.3:245 build/C/man3/getopt.3:537
#: build/C/man2/getpagesize.2:112 build/C/man2/gettid.2:81
#: build/C/man3/getumask.3:66 build/C/man3/getusershell.3:114
#: build/C/man2/ioperm.2:119 build/C/man3/lockf.3:175
#: build/C/man2/mincore.2:169 build/C/man2/mkdir.2:242 build/C/man2/nice.2:123
#: build/C/man2/pread.2:167 build/C/man2/set_thread_area.2:226
#: build/C/man5/shells.5:56 build/C/man3/sleep.3:87 build/C/man3/swab.3:86
#: build/C/man2/swapon.2:205 build/C/man2/syscall.2:388
#: build/C/man2/syscalls.2:1112 build/C/man3/sysconf.3:394
#: build/C/man2/sysctl.2:173 build/C/man2/sysinfo.2:122
#: build/C/man3/tcgetpgrp.3:133 build/C/man2/truncate.2:273
#: build/C/man3/ualarm.3:154 build/C/man2/umask.2:155 build/C/man2/uname.2:167
#: build/C/man2/uselib.2:120 build/C/man3/usleep.3:153 build/C/man2/vfork.2:329
#: build/C/man2/vhangup.2:74 build/C/man2/execveat.2:229
#: build/C/man3/get_phys_pages.3:100
#, no-wrap
msgid "SEE ALSO"
msgstr "関連項目"

#. type: Plain text
#: build/C/man2/_syscall.2:187
msgid "B<intro>(2), B<syscall>(2), B<errno>(3)"
msgstr "B<intro>(2), B<syscall>(2), B<errno>(3)"

#. type: SH
#: build/C/man2/_syscall.2:187 build/C/man2/access.2:461
#: build/C/man2/alarm.2:97 build/C/man2/brk.2:178 build/C/man2/chdir.2:146
#: build/C/man2/chmod.2:388 build/C/man2/chown.2:503 build/C/man2/chroot.2:187
#: build/C/man2/close.2:281 build/C/man3/confstr.3:167 build/C/man3/crypt.3:306
#: build/C/man3/daemon.3:150 build/C/man3/des_crypt.3:163
#: build/C/man2/dup.2:282 build/C/man3/encrypt.3:219 build/C/man7/environ.7:299
#: build/C/man3/euidaccess.3:118 build/C/man3/exec.3:299
#: build/C/man2/execve.2:891 build/C/man2/exit_group.2:51
#: build/C/man2/fcntl.2:2128 build/C/man3/fexecve.3:198
#: build/C/man2/flock.2:255 build/C/man2/fork.2:328
#: build/C/man3/fpathconf.3:286 build/C/man2/fsync.2:201
#: build/C/man3/get_nprocs_conf.3:107 build/C/man3/getcwd.3:324
#: build/C/man2/getdomainname.2:141 build/C/man3/getdtablesize.3:108
#: build/C/man3/gethostid.3:149 build/C/man2/gethostname.2:190
#: build/C/man3/getlogin.3:250 build/C/man3/getopt.3:540
#: build/C/man2/getpagesize.2:115 build/C/man2/gettid.2:100
#: build/C/man3/getumask.3:68 build/C/man3/getusershell.3:116
#: build/C/man2/idle.2:64 build/C/man2/ioperm.2:123 build/C/man3/lockf.3:190
#: build/C/man2/mincore.2:176 build/C/man2/mkdir.2:254 build/C/man2/nice.2:132
#: build/C/man2/pread.2:172 build/C/man2/set_thread_area.2:231
#: build/C/man2/setup.2:72 build/C/man5/shells.5:60 build/C/man3/sleep.3:93
#: build/C/man3/swab.3:88 build/C/man2/swapon.2:209 build/C/man2/syscall.2:394
#: build/C/man2/syscalls.2:1119 build/C/man3/sysconf.3:403
#: build/C/man2/sysctl.2:175 build/C/man2/sysinfo.2:124
#: build/C/man3/tcgetpgrp.3:137 build/C/man2/truncate.2:278
#: build/C/man3/ualarm.3:162 build/C/man2/umask.2:161 build/C/man2/uname.2:172
#: build/C/man2/uselib.2:130 build/C/man3/usleep.3:162 build/C/man2/vfork.2:336
#: build/C/man2/vhangup.2:77 build/C/man2/execveat.2:233
#: build/C/man3/get_phys_pages.3:102
#, no-wrap
msgid "COLOPHON"
msgstr "この文書について"

#. type: Plain text
#: build/C/man2/_syscall.2:195 build/C/man2/access.2:469
#: build/C/man2/alarm.2:105 build/C/man2/brk.2:186 build/C/man2/chdir.2:154
#: build/C/man2/chmod.2:396 build/C/man2/chown.2:511 build/C/man2/chroot.2:195
#: build/C/man2/close.2:289 build/C/man3/confstr.3:175 build/C/man3/crypt.3:314
#: build/C/man3/daemon.3:158 build/C/man3/des_crypt.3:171
#: build/C/man2/dup.2:290 build/C/man3/encrypt.3:227 build/C/man7/environ.7:307
#: build/C/man3/euidaccess.3:126 build/C/man3/exec.3:307
#: build/C/man2/execve.2:899 build/C/man2/exit_group.2:59
#: build/C/man2/fcntl.2:2136 build/C/man3/fexecve.3:206
#: build/C/man2/flock.2:263 build/C/man2/fork.2:336
#: build/C/man3/fpathconf.3:294 build/C/man2/fsync.2:209
#: build/C/man3/get_nprocs_conf.3:115 build/C/man3/getcwd.3:332
#: build/C/man2/getdomainname.2:149 build/C/man3/getdtablesize.3:116
#: build/C/man3/gethostid.3:157 build/C/man2/gethostname.2:198
#: build/C/man3/getlogin.3:258 build/C/man3/getopt.3:548
#: build/C/man2/getpagesize.2:123 build/C/man2/gettid.2:108
#: build/C/man3/getumask.3:76 build/C/man3/getusershell.3:124
#: build/C/man2/idle.2:72 build/C/man2/ioperm.2:131 build/C/man3/lockf.3:198
#: build/C/man2/mincore.2:184 build/C/man2/mkdir.2:262 build/C/man2/nice.2:140
#: build/C/man2/pread.2:180 build/C/man2/set_thread_area.2:239
#: build/C/man2/setup.2:80 build/C/man5/shells.5:68 build/C/man3/sleep.3:101
#: build/C/man3/swab.3:96 build/C/man2/swapon.2:217 build/C/man2/syscall.2:402
#: build/C/man2/syscalls.2:1127 build/C/man3/sysconf.3:411
#: build/C/man2/sysctl.2:183 build/C/man2/sysinfo.2:132
#: build/C/man3/tcgetpgrp.3:145 build/C/man2/truncate.2:286
#: build/C/man3/ualarm.3:170 build/C/man2/umask.2:169 build/C/man2/uname.2:180
#: build/C/man2/uselib.2:138 build/C/man3/usleep.3:170 build/C/man2/vfork.2:344
#: build/C/man2/vhangup.2:85 build/C/man2/execveat.2:241
#: build/C/man3/get_phys_pages.3:110
msgid ""
"This page is part of release 5.10 of the Linux I<man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at \\%https://www.kernel.org/doc/man-"
"pages/."
msgstr ""
"この man ページは Linux I<man-pages> プロジェクトのリリース 5.10 の一部であ"
"る。プロジェクトの説明とバグ報告に関する情報は \\%https://www.kernel.org/doc/"
"man-pages/ に書かれている。"

#. type: TH
#: build/C/man2/access.2:43
#, no-wrap
msgid "ACCESS"
msgstr "ACCESS"

#. type: TH
#: build/C/man2/access.2:43 build/C/man2/chroot.2:33 build/C/man2/fcntl.2:67
#: build/C/man2/syscalls.2:31 build/C/man2/uselib.2:31
#, no-wrap
msgid "2020-12-21"
msgstr "2020-12-21"

#. type: Plain text
#: build/C/man2/access.2:46
msgid "access, faccessat, faccessat2 - check user's permissions for a file"
msgstr ""
"access, faccessat, faccessat2 - ユーザーのファイルへのアクセス権をチェックす"
"る"

#. type: Plain text
#: build/C/man2/access.2:49 build/C/man2/alarm.2:36 build/C/man2/chown.2:44
#: build/C/man2/close.2:42 build/C/man3/confstr.3:39 build/C/man2/dup.2:43
#: build/C/man3/exec.3:47 build/C/man3/fexecve.3:31 build/C/man3/fpathconf.3:48
#: build/C/man3/getcwd.3:38 build/C/man3/getopt.3:49
#: build/C/man3/getusershell.3:36 build/C/man3/sleep.3:32
#: build/C/man3/sysconf.3:33 build/C/man3/ualarm.3:30 build/C/man3/usleep.3:39
#, no-wrap
msgid "B<#include E<lt>unistd.hE<gt>>\n"
msgstr "B<#include E<lt>unistd.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/access.2:51
#, no-wrap
msgid "B<int access(const char *>I<pathname>B<, int >I<mode>B<);>\n"
msgstr "B<int access(const char *>I<pathname>B<, int >I<mode>B<);>\n"

#. type: Plain text
#: build/C/man2/access.2:54 build/C/man2/chown.2:51
#, no-wrap
msgid ""
"B<#include E<lt>fcntl.hE<gt>           >/* Definition of AT_* constants */\n"
"B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""
"B<#include E<lt>fcntl.hE<gt>           >/* AT_* 定数の定義 */\n"
"B<#include E<lt>unistd.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/access.2:58
#, no-wrap
msgid ""
"B<int faccessat(int >I<dirfd>B<, const char *>I<pathname>B<, int >I<mode>B<, int >I<flags>B<);>\n"
"                /* But see C library/kernel differences, below */\n"
msgstr ""
" B<int faccessat(int >I<dirfd>B<, const char *>I<pathname>B<, int >I<mode>B<, int >I<flags>B<);>\n"
"                /* But see C library/kernel differences, below */\n"

#. type: Plain text
#: build/C/man2/access.2:61
#, no-wrap
msgid "B<int faccessat2(int >I<dirfd>B<, const char *>I<pathname>B<, int >I<mode>B<, int >I<flags>B<);>\n"
msgstr "B<int faccessat2(int >I<dirfd>B<, const char *>I<pathname>B<, int >I<mode>B<, int >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man2/access.2:66 build/C/man2/brk.2:42 build/C/man2/chdir.2:46
#: build/C/man2/chmod.2:52 build/C/man2/chown.2:59 build/C/man2/chroot.2:44
#: build/C/man3/confstr.3:46 build/C/man3/daemon.3:47 build/C/man3/exec.3:65
#: build/C/man3/fexecve.3:38 build/C/man2/fsync.2:51 build/C/man3/getcwd.3:49
#: build/C/man2/getdomainname.2:42 build/C/man3/getdtablesize.3:38
#: build/C/man3/gethostid.3:42 build/C/man2/gethostname.2:45
#: build/C/man3/getlogin.3:45 build/C/man3/getopt.3:70
#: build/C/man2/getpagesize.2:36 build/C/man3/getusershell.3:47
#: build/C/man3/lockf.3:39 build/C/man2/mincore.2:47 build/C/man2/mkdir.2:31
#: build/C/man2/nice.2:42 build/C/man2/pread.2:40 build/C/man2/syscall.2:56
#: build/C/man2/truncate.2:58 build/C/man3/ualarm.3:37 build/C/man3/usleep.3:46
#: build/C/man2/vfork.2:42 build/C/man2/vhangup.2:39
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr "glibc 向けの機能検査マクロの要件 (B<feature_test_macros>(7)  参照):"

#. type: Plain text
#: build/C/man2/access.2:69
msgid "B<faccessat>():"
msgstr "B<faccessat>():"

#. type: TP
#: build/C/man2/access.2:72 build/C/man2/chmod.2:82 build/C/man2/chown.2:76
#: build/C/man3/fexecve.3:44 build/C/man2/mkdir.2:37
#, no-wrap
msgid "Since glibc 2.10:"
msgstr "glibc 2.10 以降:"

#. type: Plain text
#: build/C/man2/access.2:75 build/C/man2/chmod.2:85 build/C/man2/chown.2:79
#: build/C/man3/fexecve.3:47 build/C/man2/mkdir.2:40
msgid "_POSIX_C_SOURCE\\ E<gt>=\\ 200809L"
msgstr "_POSIX_C_SOURCE\\ E<gt>=\\ 200809L"

#. type: TP
#: build/C/man2/access.2:75 build/C/man2/chmod.2:85 build/C/man2/chown.2:79
#: build/C/man3/fexecve.3:47 build/C/man2/mkdir.2:40
#, no-wrap
msgid "Before glibc 2.10:"
msgstr "glibc 2.10 より前:"

#. type: Plain text
#: build/C/man2/access.2:78 build/C/man2/chmod.2:88 build/C/man2/chown.2:82
#: build/C/man2/mkdir.2:43
msgid "_ATFILE_SOURCE"
msgstr "_ATFILE_SOURCE"

#. type: Plain text
#: build/C/man2/access.2:88
msgid ""
"B<access>()  checks whether the calling process can access the file "
"I<pathname>.  If I<pathname> is a symbolic link, it is dereferenced."
msgstr ""
"B<access>()  は、呼び出し元プロセスがファイル I<pathname> にアクセスできるか"
"どうかをチェックする。 I<pathname> がシンボリックリンクの場合、シンボリックリ"
"ンクは展開される。"

#.  F_OK is defined as 0 on every system that I know of.
#. type: Plain text
#: build/C/man2/access.2:102
msgid ""
"The I<mode> specifies the accessibility check(s) to be performed, and is "
"either the value B<F_OK>, or a mask consisting of the bitwise OR of one or "
"more of B<R_OK>, B<W_OK>, and B<X_OK>.  B<F_OK> tests for the existence of "
"the file.  B<R_OK>, B<W_OK>, and B<X_OK> test whether the file exists and "
"grants read, write, and execute permissions, respectively."
msgstr ""
"I<mode> はチェックを行うアクセス権を指定するもので、その値は B<F_OK>、 もしく"
"は B<R_OK>, B<W_OK>, B<X_OK> の 1個以上のビット単位の論理和から構成されるマス"
"クである。 B<F_OK> はファイルが存在するかどうかのみを検査する。 B<R_OK>, "
"B<W_OK>, B<X_OK> は、ファイルが存在して、それぞれ読み込み、書き込み、実行の許"
"可があるか を検査する。"

#. type: Plain text
#: build/C/man2/access.2:113
#, fuzzy
#| msgid ""
#| "The check is done using the calling process's I<real> UID and GID, rather "
#| "than the effective IDs as is done when actually attempting an operation "
#| "(e.g., B<open>(2))  on the file.  This allows set-user-ID programs to "
#| "easily determine the invoking user's authority."
msgid ""
"The check is done using the calling process's I<real> UID and GID, rather "
"than the effective IDs as is done when actually attempting an operation (e."
"g., B<open>(2))  on the file.  Similarly, for the root user, the check uses "
"the set of permitted capabilities rather than the set of effective "
"capabilities; and for non-root users, the check uses an empty set of "
"capabilities."
msgstr ""
"チェックは、実際に操作が行われる際に使用される実効 (effective) ID でなく、 呼"
"び出し元プロセスの I<実 (real)> UID と I<実 (real)> GID を使って行われる。 こ"
"れにより、set-user-ID プログラムで、プログラムを起動するユーザーの権限を 簡単"
"に決定することができる。"

#. type: Plain text
#: build/C/man2/access.2:126
msgid ""
"This allows set-user-ID programs and capability-endowed programs to easily "
"determine the invoking user's authority.  In other words, B<access>()  does "
"not answer the \"can I read/write/execute this file?\" question.  It answers "
"a slightly different question: \"(assuming I'm a setuid binary) can I<the "
"user who invoked me> read/write/execute this file?\", which gives set-user-"
"ID programs the possibility to prevent malicious users from causing them to "
"read files which users shouldn't be able to read."
msgstr ""

#. type: Plain text
#: build/C/man2/access.2:132
msgid ""
"If the calling process is privileged (i.e., its real UID is zero), then an "
"B<X_OK> check is successful for a regular file if execute permission is "
"enabled for any of the file owner, group, or other."
msgstr ""
"呼び出し元プロセスが特権プロセス (つまり、プロセスの実 UID が 0) の場合、 通"
"常のファイルに対する B<X_OK> のチェックは、そのファイルの所有者、グループ、他"
"人のいずれかの 実行許可が有効になっていれば成功する。"

#. type: SS
#: build/C/man2/access.2:132
#, no-wrap
msgid "faccessat()"
msgstr "faccessat()"

#. type: Plain text
#: build/C/man2/access.2:137
msgid ""
"B<faccessat>()  operates in exactly the same way as B<access>(), except for "
"the differences described here."
msgstr ""
"B<faccessat>() は B<access>() と全く同様に動作するが、以下で説明する点が異な"
"る。"

#. type: Plain text
#: build/C/man2/access.2:147
msgid ""
"If the pathname given in I<pathname> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<dirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<access>()  for a relative pathname)."
msgstr ""
"I<pathname> で指定されたパス名が相対パスの場合、このパス名はファイルディスク"
"リプター I<dirfd> が参照するディレクトリに対する相対パスと解釈される "
"(B<access>() に相対パス名を渡した場合のように、呼び出したプロセスのカレント"
"ワーキングディレクトリに対する相対パスではない)。"

#. type: Plain text
#: build/C/man2/access.2:159
msgid ""
"If I<pathname> is relative and I<dirfd> is the special value B<AT_FDCWD>, "
"then I<pathname> is interpreted relative to the current working directory of "
"the calling process (like B<access>())."
msgstr ""
"I<pathname> で指定されたパス名が相対パスで、 I<dirfd> が特別な値 B<AT_FDCWD> "
"の場合、 (B<access>() と同様に) I<pathname> は呼び出したプロセスのカレント"
"ワーキングディレクトリに対する相対パスと解釈される。"

#. type: Plain text
#: build/C/man2/access.2:165 build/C/man2/chmod.2:229 build/C/man2/chown.2:181
#: build/C/man2/mkdir.2:113 build/C/man2/execveat.2:76
msgid "If I<pathname> is absolute, then I<dirfd> is ignored."
msgstr ""
"I<pathname> で指定されたパス名が絶対パスの場合、 I<dirfd> は無視される。"

#. type: Plain text
#: build/C/man2/access.2:168
msgid ""
"I<flags> is constructed by ORing together zero or more of the following "
"values:"
msgstr "I<flags> は以下に示す値の 0 個以上の OR (論理和) をとって作成される。"

#. type: TP
#: build/C/man2/access.2:168
#, no-wrap
msgid "B<AT_EACCESS>"
msgstr "B<AT_EACCESS>"

#. type: Plain text
#: build/C/man2/access.2:175
msgid ""
"Perform access checks using the effective user and group IDs.  By default, "
"B<faccessat>()  uses the real IDs (like B<access>())."
msgstr ""
"アクセスチェックを実行ユーザー/グループ ID を使って行う。デフォルトでは、"
"B<faccessat>() は (B<access>() と同様に) 実 ID を使用する。"

#. type: TP
#: build/C/man2/access.2:175 build/C/man2/chmod.2:232 build/C/man2/chown.2:209
#: build/C/man2/execveat.2:100
#, no-wrap
msgid "B<AT_SYMLINK_NOFOLLOW>"
msgstr "B<AT_SYMLINK_NOFOLLOW>"

#. type: Plain text
#: build/C/man2/access.2:181
msgid ""
"If I<pathname> is a symbolic link, do not dereference it: instead return "
"information about the link itself."
msgstr ""
"I<pathname> がシンボリックリンクの場合、リンクの展開を行わない。代わりに、リ"
"ンク自身の情報を返す。"

#. type: Plain text
#: build/C/man2/access.2:187
msgid "See B<openat>(2)  for an explanation of the need for B<faccessat>()."
msgstr "B<faccessat>() の必要性についての説明については B<openat>(2) を参照。"

#. type: SS
#: build/C/man2/access.2:187
#, no-wrap
msgid "faccessat2()"
msgstr "faccessat2()"

#. type: Plain text
#: build/C/man2/access.2:205
msgid ""
"The description of B<faccessat>()  given above corresponds to POSIX.1 and to "
"the implementation provided by glibc.  However, the glibc implementation was "
"an imperfect emulation (see BUGS)  that papered over the fact that the raw "
"Linux B<faccessat>()  system call does not have a I<flags> argument.  To "
"allow for a proper implementation, Linux 5.8 added the B<faccessat2>()  "
"system call, which supports the I<flags> argument and allows a correct "
"implementation of the B<faccessat>()  wrapper function."
msgstr ""

#. type: SH
#: build/C/man2/access.2:205 build/C/man2/alarm.2:54 build/C/man2/brk.2:103
#: build/C/man2/chdir.2:70 build/C/man2/chmod.2:244 build/C/man2/chown.2:225
#: build/C/man2/chroot.2:116 build/C/man2/close.2:65 build/C/man3/confstr.3:96
#: build/C/man3/crypt.3:118 build/C/man3/daemon.3:81
#: build/C/man3/des_crypt.3:106 build/C/man2/dup.2:150
#: build/C/man3/encrypt.3:111 build/C/man3/euidaccess.3:58
#: build/C/man3/exec.3:178 build/C/man2/execve.2:438
#: build/C/man2/exit_group.2:39 build/C/man2/fcntl.2:1627
#: build/C/man3/fexecve.3:69 build/C/man2/flock.2:112 build/C/man2/fork.2:214
#: build/C/man3/fpathconf.3:174 build/C/man2/fsync.2:112
#: build/C/man3/get_nprocs_conf.3:46 build/C/man3/getcwd.3:155
#: build/C/man2/getdomainname.2:83 build/C/man3/getdtablesize.3:62
#: build/C/man3/gethostid.3:76 build/C/man2/gethostname.2:96
#: build/C/man3/getlogin.3:102 build/C/man3/getopt.3:286
#: build/C/man2/gettid.2:49 build/C/man3/getusershell.3:91
#: build/C/man2/idle.2:52 build/C/man2/ioperm.2:77 build/C/man3/lockf.3:118
#: build/C/man2/mincore.2:97 build/C/man2/mkdir.2:118 build/C/man2/nice.2:66
#: build/C/man2/pread.2:79 build/C/man2/set_thread_area.2:132
#: build/C/man2/setup.2:53 build/C/man3/sleep.3:41 build/C/man3/swab.3:68
#: build/C/man2/swapon.2:113 build/C/man2/syscall.2:90
#: build/C/man3/sysconf.3:326 build/C/man2/sysctl.2:70
#: build/C/man2/sysinfo.2:99 build/C/man3/tcgetpgrp.3:64
#: build/C/man2/truncate.2:108 build/C/man3/ualarm.3:80
#: build/C/man2/umask.2:112 build/C/man2/uname.2:64 build/C/man2/uselib.2:51
#: build/C/man3/usleep.3:74 build/C/man2/vhangup.2:58
#: build/C/man2/execveat.2:108 build/C/man3/get_phys_pages.3:45
#, no-wrap
msgid "RETURN VALUE"
msgstr "返り値"

#. type: Plain text
#: build/C/man2/access.2:221
msgid ""
"On success (all requested permissions granted, or I<mode> is B<F_OK> and the "
"file exists), zero is returned.  On error (at least one bit in I<mode> asked "
"for a permission that is denied, or I<mode> is B<F_OK> and the file does not "
"exist, or some other error occurred), -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""
"成功した場合 (要求した全てについて許可が得られたか、 I<mode> が B<F_OK> で"
"ファイルが存在した場合)、ゼロが返される。 エラーの場合 (I<mode> の少なくとも"
"一つのビットで要求した許可がなかった場合、 I<mode> が B<F_OK> でファイルが存"
"在しなかった場合、他のエラーが起こった場合)、-1 が返され、 I<errno> が適切に"
"設定される。"

#. type: SH
#: build/C/man2/access.2:221 build/C/man2/chdir.2:75 build/C/man2/chmod.2:249
#: build/C/man2/chown.2:230 build/C/man2/chroot.2:121 build/C/man2/close.2:71
#: build/C/man3/confstr.3:123 build/C/man3/crypt.3:121 build/C/man2/dup.2:156
#: build/C/man3/encrypt.3:113 build/C/man3/euidaccess.3:66
#: build/C/man3/exec.3:185 build/C/man2/execve.2:444 build/C/man2/fcntl.2:1665
#: build/C/man3/fexecve.3:76 build/C/man2/flock.2:117 build/C/man2/fork.2:221
#: build/C/man3/fpathconf.3:212 build/C/man2/fsync.2:117
#: build/C/man3/getcwd.3:171 build/C/man2/getdomainname.2:88
#: build/C/man3/getdtablesize.3:64 build/C/man3/gethostid.3:86
#: build/C/man2/gethostname.2:101 build/C/man3/getlogin.3:110
#: build/C/man2/gettid.2:51 build/C/man2/idle.2:55 build/C/man2/ioperm.2:82
#: build/C/man3/lockf.3:123 build/C/man2/mincore.2:104 build/C/man2/mkdir.2:125
#: build/C/man2/nice.2:78 build/C/man2/pread.2:97
#: build/C/man2/set_thread_area.2:146 build/C/man2/setup.2:56
#: build/C/man2/swapon.2:118 build/C/man3/sysconf.3:366
#: build/C/man2/sysctl.2:77 build/C/man2/sysinfo.2:106
#: build/C/man3/tcgetpgrp.3:86 build/C/man2/truncate.2:113
#: build/C/man3/ualarm.3:83 build/C/man2/uname.2:69 build/C/man2/uselib.2:56
#: build/C/man3/usleep.3:81 build/C/man2/vhangup.2:63
#: build/C/man2/execveat.2:115 build/C/man3/get_phys_pages.3:51
#, no-wrap
msgid "ERRORS"
msgstr "エラー"

#. type: Plain text
#: build/C/man2/access.2:226
msgid "B<access>()  and B<faccessat>()  shall fail if:"
msgstr "B<access>() と B<faccessat>() は以下の場合に失敗する。"

#. type: TP
#: build/C/man2/access.2:226 build/C/man2/chdir.2:81 build/C/man2/chdir.2:119
#: build/C/man2/chmod.2:256 build/C/man2/chown.2:237 build/C/man2/chroot.2:124
#: build/C/man2/execve.2:452 build/C/man2/execve.2:459
#: build/C/man2/execve.2:462 build/C/man2/execve.2:465
#: build/C/man3/fpathconf.3:213 build/C/man3/getcwd.3:172
#: build/C/man3/gethostid.3:89 build/C/man2/mkdir.2:126
#: build/C/man2/truncate.2:116 build/C/man2/uselib.2:62
#, no-wrap
msgid "B<EACCES>"
msgstr "B<EACCES>"

#. type: Plain text
#: build/C/man2/access.2:233
msgid ""
"The requested access would be denied to the file, or search permission is "
"denied for one of the directories in the path prefix of I<pathname>.  (See "
"also B<path_resolution>(7).)"
msgstr ""
"要求されたアクセスは そのファイル自身に拒否されたか I<pathname> へ至るまで"
"ディレクトリのいずれかに対する検索許可 (search permission) が得られなかっ"
"た。 (B<path_resolution>(7)  も参照のこと)"

#. type: TP
#: build/C/man2/access.2:233 build/C/man2/chdir.2:94 build/C/man2/chmod.2:268
#: build/C/man2/chown.2:246 build/C/man2/chroot.2:138 build/C/man2/execve.2:500
#: build/C/man2/execve.2:505 build/C/man3/fpathconf.3:232
#: build/C/man2/mkdir.2:154 build/C/man2/truncate.2:150
#: build/C/man2/execveat.2:130
#, no-wrap
msgid "B<ELOOP>"
msgstr "B<ELOOP>"

#. type: Plain text
#: build/C/man2/access.2:237 build/C/man2/chmod.2:272 build/C/man2/chown.2:250
#: build/C/man2/mkdir.2:158
msgid "Too many symbolic links were encountered in resolving I<pathname>."
msgstr "I<pathname> を解決するときに、解決すべきシンボリックリンクが多すぎた。"

#. type: TP
#: build/C/man2/access.2:237 build/C/man2/chdir.2:98 build/C/man2/chmod.2:272
#: build/C/man2/chown.2:250 build/C/man2/chroot.2:142 build/C/man2/execve.2:516
#: build/C/man3/fpathconf.3:237 build/C/man3/getcwd.3:191
#: build/C/man2/gethostname.2:116 build/C/man2/mkdir.2:162
#: build/C/man2/truncate.2:153
#, no-wrap
msgid "B<ENAMETOOLONG>"
msgstr "B<ENAMETOOLONG>"

#. type: Plain text
#: build/C/man2/access.2:241 build/C/man2/chmod.2:276 build/C/man2/chown.2:254
#: build/C/man2/execve.2:520
msgid "I<pathname> is too long."
msgstr "I<pathname> が長過ぎる。"

#. type: TP
#: build/C/man2/access.2:241 build/C/man2/chdir.2:102 build/C/man2/chmod.2:276
#: build/C/man2/chown.2:254 build/C/man2/chown.2:286 build/C/man2/chroot.2:146
#: build/C/man2/execve.2:523 build/C/man3/fexecve.3:88
#: build/C/man3/fpathconf.3:242 build/C/man3/getcwd.3:197
#: build/C/man3/getlogin.3:129 build/C/man2/mkdir.2:165
#: build/C/man2/swapon.2:150 build/C/man2/truncate.2:157
#: build/C/man2/execveat.2:140
#, no-wrap
msgid "B<ENOENT>"
msgstr "B<ENOENT>"

#. type: Plain text
#: build/C/man2/access.2:246
msgid ""
"A component of I<pathname> does not exist or is a dangling symbolic link."
msgstr ""
"I<pathname> を構成するパスのいずれかが、存在しないか、 参照先のない "
"(dangling) シンボリックリンクになっている。"

#. type: TP
#: build/C/man2/access.2:246 build/C/man2/access.2:288 build/C/man2/chdir.2:110
#: build/C/man2/chdir.2:127 build/C/man2/chmod.2:282 build/C/man2/chmod.2:332
#: build/C/man2/chown.2:260 build/C/man2/chown.2:310 build/C/man2/chroot.2:152
#: build/C/man2/execve.2:536 build/C/man2/fcntl.2:1801
#: build/C/man3/fpathconf.3:250 build/C/man2/mkdir.2:182
#: build/C/man2/mkdir.2:203 build/C/man2/sysctl.2:92
#: build/C/man2/truncate.2:160 build/C/man2/execveat.2:154
#, no-wrap
msgid "B<ENOTDIR>"
msgstr "B<ENOTDIR>"

#. type: Plain text
#: build/C/man2/access.2:251 build/C/man2/mkdir.2:187
msgid ""
"A component used as a directory in I<pathname> is not, in fact, a directory."
msgstr "I<pathname> のディレクトリ部分が実際にはディレクトリでない。"

#. type: TP
#: build/C/man2/access.2:251 build/C/man2/chmod.2:296 build/C/man2/chmod.2:314
#: build/C/man2/chown.2:272 build/C/man2/chown.2:292 build/C/man2/mkdir.2:192
#: build/C/man2/truncate.2:173
#, no-wrap
msgid "B<EROFS>"
msgstr "B<EROFS>"

#. type: Plain text
#: build/C/man2/access.2:254
msgid "Write permission was requested for a file on a read-only filesystem."
msgstr ""
"読み込み専用 (read-only) のファイルシステムに対して書き込み許可を 要求した。"

#. type: Plain text
#: build/C/man2/access.2:259
msgid "B<access>()  and B<faccessat>()  may fail if:"
msgstr "B<access>() と B<faccessat>() は以下の理由により失敗することがある。"

#. type: TP
#: build/C/man2/access.2:259 build/C/man2/chdir.2:87 build/C/man2/chmod.2:261
#: build/C/man2/chown.2:242 build/C/man2/chroot.2:131 build/C/man2/execve.2:479
#: build/C/man2/fcntl.2:1710 build/C/man3/getcwd.3:175
#: build/C/man2/getdomainname.2:91 build/C/man2/gethostname.2:102
#: build/C/man2/mincore.2:107 build/C/man2/mkdir.2:145
#: build/C/man2/set_thread_area.2:147 build/C/man2/sysctl.2:86
#: build/C/man2/sysinfo.2:107 build/C/man2/truncate.2:122
#: build/C/man2/uname.2:70
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
#: build/C/man2/access.2:263 build/C/man2/chmod.2:265 build/C/man2/chown.2:246
#: build/C/man2/mkdir.2:148
msgid "I<pathname> points outside your accessible address space."
msgstr "I<pathname> がアクセス可能なアドレス空間の外を指している。"

#. type: TP
#: build/C/man2/access.2:263 build/C/man2/access.2:284 build/C/man2/chmod.2:328
#: build/C/man2/chown.2:306 build/C/man3/confstr.3:124 build/C/man3/crypt.3:122
#: build/C/man2/dup.2:186 build/C/man2/dup.2:191 build/C/man2/execve.2:487
#: build/C/man2/fcntl.2:1736 build/C/man2/fcntl.2:1741
#: build/C/man2/fcntl.2:1749 build/C/man2/fcntl.2:1759
#: build/C/man2/fcntl.2:1771 build/C/man2/fcntl.2:1779
#: build/C/man3/fexecve.3:80 build/C/man2/flock.2:127
#: build/C/man3/fpathconf.3:223 build/C/man3/fpathconf.3:227
#: build/C/man3/getcwd.3:179 build/C/man3/getcwd.3:186
#: build/C/man2/getdomainname.2:95 build/C/man2/getdomainname.2:108
#: build/C/man2/gethostname.2:106 build/C/man2/ioperm.2:83
#: build/C/man3/lockf.3:154 build/C/man2/mincore.2:111 build/C/man2/mkdir.2:148
#: build/C/man2/set_thread_area.2:150 build/C/man2/swapon.2:126
#: build/C/man2/swapon.2:131 build/C/man2/swapon.2:142
#: build/C/man3/sysconf.3:367 build/C/man3/tcgetpgrp.3:91
#: build/C/man2/truncate.2:139 build/C/man2/truncate.2:194
#: build/C/man3/ualarm.3:88 build/C/man3/usleep.3:86
#: build/C/man2/execveat.2:126
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#: build/C/man2/access.2:267
msgid "I<mode> was incorrectly specified."
msgstr "I<mode> に不正な値が指定された。"

#. type: TP
#: build/C/man2/access.2:267 build/C/man2/chdir.2:91 build/C/man2/chmod.2:265
#: build/C/man2/chmod.2:308 build/C/man2/chown.2:283 build/C/man2/chroot.2:135
#: build/C/man2/close.2:84 build/C/man2/execve.2:491 build/C/man2/fsync.2:122
#: build/C/man2/ioperm.2:89 build/C/man2/truncate.2:144
#, no-wrap
msgid "B<EIO>"
msgstr "B<EIO>"

#. type: Plain text
#: build/C/man2/access.2:270 build/C/man2/chdir.2:94 build/C/man2/chmod.2:268
#: build/C/man2/chroot.2:138 build/C/man2/close.2:87 build/C/man2/execve.2:494
msgid "An I/O error occurred."
msgstr "I/O エラーが発生した。"

#. type: TP
#: build/C/man2/access.2:270 build/C/man2/chdir.2:107 build/C/man2/chmod.2:279
#: build/C/man2/chown.2:257 build/C/man2/chroot.2:149 build/C/man2/execve.2:533
#: build/C/man2/fork.2:258 build/C/man2/fork.2:262 build/C/man3/getcwd.3:200
#: build/C/man3/getlogin.3:132 build/C/man2/ioperm.2:92
#: build/C/man2/mincore.2:115 build/C/man2/mincore.2:127
#: build/C/man2/mkdir.2:170 build/C/man2/swapon.2:155
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
#: build/C/man2/access.2:273 build/C/man2/chdir.2:110 build/C/man2/chmod.2:282
#: build/C/man2/chown.2:260 build/C/man2/chroot.2:152 build/C/man2/execve.2:536
#: build/C/man2/mkdir.2:173
msgid "Insufficient kernel memory was available."
msgstr "カーネルに十分なメモリーがない。"

#. type: TP
#: build/C/man2/access.2:273 build/C/man2/execve.2:557
#: build/C/man2/truncate.2:176
#, no-wrap
msgid "B<ETXTBSY>"
msgstr "B<ETXTBSY>"

#. type: Plain text
#: build/C/man2/access.2:277
msgid "Write access was requested to an executable which is being executed."
msgstr "実行中のファイルに対して書き込みを要求した。"

#. type: Plain text
#: build/C/man2/access.2:280
msgid "The following additional errors can occur for B<faccessat>():"
msgstr "B<faccessat>() では以下のエラーも発生する。"

#. type: TP
#: build/C/man2/access.2:280 build/C/man2/chdir.2:123 build/C/man2/chmod.2:303
#: build/C/man2/chmod.2:324 build/C/man2/chown.2:279 build/C/man2/chown.2:302
#: build/C/man2/close.2:72 build/C/man2/dup.2:157 build/C/man2/dup.2:161
#: build/C/man2/fcntl.2:1673 build/C/man2/fcntl.2:1677 build/C/man2/flock.2:118
#: build/C/man3/fpathconf.3:218 build/C/man2/fsync.2:118
#: build/C/man3/lockf.3:132 build/C/man2/mkdir.2:199
#: build/C/man3/tcgetpgrp.3:87 build/C/man2/truncate.2:186
#: build/C/man2/execveat.2:122
#, no-wrap
msgid "B<EBADF>"
msgstr "B<EBADF>"

#. type: Plain text
#: build/C/man2/access.2:284 build/C/man2/chmod.2:328 build/C/man2/chown.2:306
#: build/C/man2/mkdir.2:203 build/C/man2/execveat.2:126
msgid "I<dirfd> is not a valid file descriptor."
msgstr "I<dirfd> が適切なファイルディスクリプターでない。"

#. type: Plain text
#: build/C/man2/access.2:288 build/C/man2/chmod.2:332 build/C/man2/chown.2:310
#: build/C/man2/execveat.2:130
msgid "Invalid flag specified in I<flags>."
msgstr "I<flags> に無効なフラグが指定された。"

#. type: Plain text
#: build/C/man2/access.2:294 build/C/man2/chmod.2:338 build/C/man2/chown.2:316
#: build/C/man2/mkdir.2:209 build/C/man2/execveat.2:160
msgid ""
"I<pathname> is relative and I<dirfd> is a file descriptor referring to a "
"file other than a directory."
msgstr ""
"I<pathname> が相対パスで、 I<dirfd> がディレクトリ以外のファイルを参照してい"
"るファイルディスクリプターである。"

#. type: SH
#: build/C/man2/access.2:294 build/C/man2/chmod.2:344 build/C/man2/chown.2:316
#: build/C/man3/des_crypt.3:129 build/C/man2/dup.2:204
#: build/C/man3/encrypt.3:122 build/C/man3/euidaccess.3:69
#: build/C/man3/exec.3:190 build/C/man2/exit_group.2:41
#: build/C/man3/fexecve.3:103 build/C/man2/gettid.2:53 build/C/man2/idle.2:59
#: build/C/man2/mincore.2:135 build/C/man2/mkdir.2:209 build/C/man2/pread.2:112
#: build/C/man2/set_thread_area.2:163 build/C/man2/setup.2:60
#: build/C/man2/sysctl.2:96 build/C/man2/sysinfo.2:111
#: build/C/man2/execveat.2:160
#, no-wrap
msgid "VERSIONS"
msgstr "バージョン"

#. type: Plain text
#: build/C/man2/access.2:298
msgid ""
"B<faccessat>()  was added to Linux in kernel 2.6.16; library support was "
"added to glibc in version 2.4."
msgstr ""
"B<faccessat>()  はバージョン 2.6.16 で Linux に追加された。 ライブラリによる"
"サポートは glibc バージョン 2.4 で追加された。"

#. type: Plain text
#: build/C/man2/access.2:301
msgid "B<faccessat2>()  was added to Linux in version 5.8."
msgstr "B<faccessat2>() は Linux 5.8 で追加された。"

#. type: Plain text
#: build/C/man2/access.2:304
msgid "B<access>(): SVr4, 4.3BSD, POSIX.1-2001, POSIX.1-2008."
msgstr "B<access>(): SVr4, 4.3BSD, POSIX.1-2001, POSIX.1-2008."

#. type: Plain text
#: build/C/man2/access.2:307
msgid "B<faccessat>(): POSIX.1-2008."
msgstr "B<faccessat>(): POSIX.1-2008."

#. type: Plain text
#: build/C/man2/access.2:310
msgid "B<faccessat2>(): Linux-specific."
msgstr "B<faccessat2>() は Linux 固有である。"

#. type: Plain text
#: build/C/man2/access.2:322
msgid ""
"B<Warning>: Using these calls to check if a user is authorized to, for "
"example, open a file before actually doing so using B<open>(2)  creates a "
"security hole, because the user might exploit the short time interval "
"between checking and opening the file to manipulate it.  B<For this reason, "
"the use of this system call should be avoided>.  (In the example just "
"described, a safer alternative would be to temporarily switch the process's "
"effective user ID to the real ID and then call B<open>(2).)"
msgstr ""
"B<警告>: あるユーザーが、例えば B<open>(2) によるアクセスが可能かどうかを、 "
"(実際に行う前に) これらのシステムコールを使ってチェックするのは、セキュリティ"
"ホールの原因になる。なぜならチェックをしてから 実際にファイルのオープン操作を"
"する間の短い間隔を悪用できるからである。 B<この理由があるので、このシステム"
"コールを使うのは避けるべきである。> (ここで説明した例の場合には、より安全な方"
"法としては、 そのプロセスの実効ユーザー ID を実ユーザー ID に一時的に切り替え"
"てから B<open>(2) を呼び出す方法がある。)"

#. type: Plain text
#: build/C/man2/access.2:329
msgid ""
"B<access>()  always dereferences symbolic links.  If you need to check the "
"permissions on a symbolic link, use B<faccessat>()  with the flag "
"B<AT_SYMLINK_NOFOLLOW>."
msgstr ""
"B<access>() は常にシンボリックリンクの展開を行う。\n"
"シンボリックリンクのアクセス許可を確認する必要がある場合は、\n"
"B<AT_SYMLINK_NOFOLLOW> フラグ付きで B<faccessat>() を使うこと。"

#. type: Plain text
#: build/C/man2/access.2:335
msgid ""
"These calls return an error if any of the access types in I<mode> is denied, "
"even if some of the other access types in I<mode> are permitted."
msgstr ""
"I<mode> で指定されたアクセス種別のいずれか一つでも拒否されると、 たとえ "
"I<mode> で指定された他のアクセス種別が許可されたとしても、 これらのシステム"
"コールはエラーを返す。"

#.  HPU-UX 11 and Tru64 5.1 do this.
#. type: Plain text
#: build/C/man2/access.2:342
msgid ""
"If the calling process has appropriate privileges (i.e., is superuser), "
"POSIX.1-2001 permits an implementation to indicate success for an B<X_OK> "
"check even if none of the execute file permission bits are set.  Linux does "
"not do this."
msgstr ""
"POSIX.1-2001 では、 呼び出し元プロセスが適切な特権を持っている場合 (つまり、"
"スーパーユーザーの場合)、 たとえファイルの実行許可ビットが全くセットされてい"
"なくても B<X_OK> のチェックとして成功を返す実装が認められている。 Linux はこ"
"のようにはなっていない。"

#. type: Plain text
#: build/C/man2/access.2:350
msgid ""
"A file is accessible only if the permissions on each of the directories in "
"the path prefix of I<pathname> grant search (i.e., execute) access.  If any "
"directory is inaccessible, then the B<access>()  call fails, regardless of "
"the permissions on the file itself."
msgstr ""
"I<pathname> のプレフィックスを構成するディレクトリの全てに対して 検索アクセ"
"ス (すなわち、実行アクセス) が許可された場合にのみ、 ファイルはアクセス可能と"
"なる。 いずれかのディレクトリがアクセス不可の場合、 ファイル自身のアクセス許"
"可に関わらず、 B<access>()  は失敗する。"

#. type: Plain text
#: build/C/man2/access.2:358
msgid ""
"Only access bits are checked, not the file type or contents.  Therefore, if "
"a directory is found to be writable, it probably means that files can be "
"created in the directory, and not that the directory can be written as a "
"file.  Similarly, a DOS file may be found to be \"executable,\" but the "
"B<execve>(2)  call will still fail."
msgstr ""
"アクセスビットのみがチェックされ、ファイルの種類や内容はチェックされない。 "
"従って、ディレクトリが書き込み可能となった場合は、ディレクトリに ファイルを作"
"成することが可能なことを意味するのであり、ディレクトリに ファイルとして書き込"
"むことができるわけではない。 同様に DOS のファイルは「実行可能」と判断される"
"が、 B<execve>(2)  コールは失敗するだろう。"

#. type: Plain text
#: build/C/man2/access.2:367
msgid ""
"These calls may not work correctly on NFSv2 filesystems with UID mapping "
"enabled, because UID mapping is done on the server and hidden from the "
"client, which checks permissions.  (NFS versions 3 and higher perform the "
"check on the server.)  Similar problems can occur to FUSE mounts."
msgstr ""
"これらのシステムコールは、 UID マッピングを使用した NFSv2 ファイルシステムで"
"は正常に機能しないかもしれない。なぜならば UID のマッピングはサーバーで 行な"
"われ、権利のチェックをするクライアントには見えないからである。 (NFS バージョ"
"ン 3 以降ではサーバー側でチェックが実行される。) 同様の問題は FUSE マウントで"
"も起こり得る。"

#. type: SS
#: build/C/man2/access.2:367 build/C/man2/brk.2:150 build/C/man2/chmod.2:356
#: build/C/man2/fork.2:287 build/C/man3/getcwd.3:268
#: build/C/man2/gethostname.2:148 build/C/man2/nice.2:109
#: build/C/man2/pread.2:134 build/C/man2/uname.2:139
#, no-wrap
msgid "C library/kernel differences"
msgstr "C ライブラリとカーネルの違い"

#. type: Plain text
#: build/C/man2/access.2:381
msgid ""
"The raw B<faccessat>()  system call takes only the first three arguments.  "
"The B<AT_EACCESS> and B<AT_SYMLINK_NOFOLLOW> flags are actually implemented "
"within the glibc wrapper function for B<faccessat>().  If either of these "
"flags is specified, then the wrapper function employs B<fstatat>(2)  to "
"determine access permissions, but see BUGS."
msgstr ""
"生の B<faccessat>() システムコールは、最初の 3 つの引数だけを取る。フラグ "
"B<AT_EACCESS> と B<AT_SYMLINK_NOFOLLOW> は実際には B<faccessat>() の glibc の"
"ラッパー関数内で実装されている。これらのフラグのいずれかが指定された場合、"
"ラッパー関数は B<fstatat>(2) を使ってアクセス許可の判定を行う。ただし「バグ」"
"を参照のこと。"

#. type: SS
#: build/C/man2/access.2:381 build/C/man2/chmod.2:366 build/C/man2/chown.2:387
#: build/C/man2/mkdir.2:229
#, no-wrap
msgid "Glibc notes"
msgstr "glibc での注意"

#. type: Plain text
#: build/C/man2/access.2:399
msgid ""
"On older kernels where B<faccessat>()  is unavailable (and when the "
"B<AT_EACCESS> and B<AT_SYMLINK_NOFOLLOW> flags are not specified), the glibc "
"wrapper function falls back to the use of B<access>().  When I<pathname> is "
"a relative pathname, glibc constructs a pathname based on the symbolic link "
"in I</proc/self/fd> that corresponds to the I<dirfd> argument."
msgstr ""
"B<faccessat>() が利用できない古いカーネルでは、(フラグ B<AT_EACCESS> と "
"B<AT_SYMLINK_NOFOLLOW> が指定されていない場合) glibc ラッパー関数は "
"B<access>() を使用するモードにフォールバックする。 I<pathname> が相対パスの場"
"合、 glibc は I<dirfd> 引数に対応する I</proc/self/fd> のシンボリックリンク"
"に基づいてパス名を構成する。"

#. type: SH
#: build/C/man2/access.2:399 build/C/man3/daemon.3:125
#: build/C/man7/environ.7:243 build/C/man3/exec.3:267 build/C/man2/fcntl.2:2008
#: build/C/man3/fexecve.3:176 build/C/man3/getcwd.3:305
#: build/C/man3/gethostid.3:144 build/C/man3/getlogin.3:213
#: build/C/man2/mincore.2:147 build/C/man2/pread.2:155
#: build/C/man2/set_thread_area.2:201 build/C/man3/sysconf.3:385
#: build/C/man2/sysctl.2:127 build/C/man2/truncate.2:265
#: build/C/man2/vfork.2:309 build/C/man2/execveat.2:210
#, no-wrap
msgid "BUGS"
msgstr "バグ"

#. type: Plain text
#: build/C/man2/access.2:417
msgid ""
"Because the Linux kernel's B<faccessat>()  system call does not support a "
"I<flags> argument, the glibc B<faccessat>()  wrapper function provided in "
"glibc 2.32 and earlier emulates the required functionality using a "
"combination of the B<faccessat>()  system call and B<fstatat>(2).  However, "
"this emulation does not take ACLs into account.  Starting with glibc 2.33, "
"the wrapper function avoids this bug by making use of the B<faccessat2>()  "
"system call where it is provided by the underlying kernel."
msgstr ""

#.  This behavior appears to have been an implementation accident.
#. type: Plain text
#: build/C/man2/access.2:440
msgid ""
"In kernel 2.4 (and earlier) there is some strangeness in the handling of "
"B<X_OK> tests for superuser.  If all categories of execute permission are "
"disabled for a nondirectory file, then the only B<access>()  test that "
"returns -1 is when I<mode> is specified as just B<X_OK>; if B<R_OK> or "
"B<W_OK> is also specified in I<mode>, then B<access>()  returns 0 for such "
"files.  Early 2.6 kernels (up to and including 2.6.3)  also behaved in the "
"same way as kernel 2.4."
msgstr ""
"バージョン 2.4 (とそれ以前) のカーネルには、スーパーユーザーでの B<X_OK> の"
"チェックの扱いに奇妙な点がある。 ディレクトリ以外のファイルで (ユーザー、グ"
"ループ、他人の) 全てのカテゴリーについて 実行許可がない場合、 B<access>()  の"
"チェックで -1 が返るのは I<mode> に B<X_OK> だけが指定されたときだけであり "
"I<mode> に B<R_OK> や B<W_OK> が一緒に指定された場合には B<access>()  は 0 を"
"返す。 (バージョン 2.6.3 以前の) 初期の 2.6 系のカーネルも 2.4 系のカーネルと"
"同様の動作をする。"

#. type: Plain text
#: build/C/man2/access.2:450
msgid ""
"In kernels before 2.6.20, these calls ignored the effect of the B<MS_NOEXEC> "
"flag if it was used to B<mount>(2)  the underlying filesystem.  Since kernel "
"2.6.20, the B<MS_NOEXEC> flag is honored."
msgstr ""
"2.6.20 より前のカーネルでは、 これらのシステムコールはファイルが存在するファ"
"イルシステムを B<mount>(2) する際に指定された B<MS_NOEXEC> フラグの効果を無視"
"していた。 カーネル 2.6.20 以降では、 B<MS_NOEXEC> フラグは考慮されるように"
"なっている。"

#. type: Plain text
#: build/C/man2/access.2:461
msgid ""
"B<chmod>(2), B<chown>(2), B<open>(2), B<setgid>(2), B<setuid>(2), "
"B<stat>(2), B<euidaccess>(3), B<credentials>(7), B<path_resolution>(7), "
"B<symlink>(7)"
msgstr ""
"B<chmod>(2), B<chown>(2), B<open>(2), B<setgid>(2), B<setuid>(2), "
"B<stat>(2), B<euidaccess>(3), B<credentials>(7), B<path_resolution>(7), "
"B<symlink>(7)"

#. type: TH
#: build/C/man2/alarm.2:30
#, no-wrap
msgid "ALARM"
msgstr "ALARM"

#. type: TH
#: build/C/man2/alarm.2:30
#, no-wrap
msgid "2017-05-03"
msgstr " 2017-05-03"

#. type: Plain text
#: build/C/man2/alarm.2:33
msgid "alarm - set an alarm clock for delivery of a signal"
msgstr "alarm - シグナル配送のためのアラームクロックを設定する"

#. type: Plain text
#: build/C/man2/alarm.2:38
#, no-wrap
msgid "B<unsigned int alarm(unsigned int >I<seconds>B<);>\n"
msgstr "B<unsigned int alarm(unsigned int >I<seconds>B<);>\n"

#. type: Plain text
#: build/C/man2/alarm.2:46
msgid ""
"B<alarm>()  arranges for a B<SIGALRM> signal to be delivered to the calling "
"process in I<seconds> seconds."
msgstr ""
"B<alarm>()  は B<SIGALRM> シグナルを I<seconds> 秒後に呼び出したプロセスに配"
"送するように手配する。"

#. type: Plain text
#: build/C/man2/alarm.2:50
msgid "If I<seconds> is zero, any pending alarm is canceled."
msgstr ""
"I<seconds> がゼロならば、処理待ち (pending) のアラームはすべてキャンセルされ"
"る。"

#. type: Plain text
#: build/C/man2/alarm.2:54
msgid "In any event any previously set B<alarm>()  is canceled."
msgstr "今までに設定されていた B<alarm>()  は中断される。"

#. type: Plain text
#: build/C/man2/alarm.2:59
msgid ""
"B<alarm>()  returns the number of seconds remaining until any previously "
"scheduled alarm was due to be delivered, or zero if there was no previously "
"scheduled alarm."
msgstr ""
"B<alarm>()  は以前に予定されていたアラームの配送までの残り時間を返す。以前に "
"アラームが予定されていなければゼロを返す。"

#. type: Plain text
#: build/C/man2/alarm.2:61 build/C/man2/close.2:103 build/C/man2/fork.2:281
#: build/C/man3/swab.3:86 build/C/man2/umask.2:117
msgid "POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD."
msgstr " POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD."

#. type: Plain text
#: build/C/man2/alarm.2:67
msgid ""
"B<alarm>()  and B<setitimer>(2)  share the same timer; calls to one will "
"interfere with use of the other."
msgstr ""
"B<alarm>()  と B<setitimer>(2)  は同じタイマーを共有している; 片方を呼び出す"
"ことはもう一方の 使用に影響を与える。"

#. type: Plain text
#: build/C/man2/alarm.2:74
msgid ""
"Alarms created by B<alarm>()  are preserved across B<execve>(2)  and are not "
"inherited by children created via B<fork>(2)."
msgstr ""
"B<alarm>() で作成されたアラームは B<execve>(2) の前後で保持され、 B<fork>(2) "
"で作成された子プロセスには継承されない。"

#. type: Plain text
#: build/C/man2/alarm.2:83
msgid ""
"B<sleep>(3)  may be implemented using B<SIGALRM>; mixing calls to "
"B<alarm>()  and B<sleep>(3)  is a bad idea."
msgstr ""
"B<sleep>(3)  は B<SIGALRM> を利用して実装されているかもしれない。 "
"B<alarm>()  と B<sleep>(3)  を混ぜて使用してはならない。"

#. type: Plain text
#: build/C/man2/alarm.2:86
msgid ""
"Scheduling delays can, as ever, cause the execution of the process to be "
"delayed by an arbitrary amount of time."
msgstr ""
"スケジューリング(scheduling)の遅延により、プロセスの実行に不定量の 遅延が起き"
"る可能性がある。"

#. type: Plain text
#: build/C/man2/alarm.2:97
msgid ""
"B<gettimeofday>(2), B<pause>(2), B<select>(2), B<setitimer>(2), "
"B<sigaction>(2), B<signal>(2), B<timer_create>(2), B<timerfd_create>(2), "
"B<sleep>(3), B<time>(7)"
msgstr ""
" B<gettimeofday>(2), B<pause>(2), B<select>(2), B<setitimer>(2), "
"B<sigaction>(2), B<signal>(2), B<timer_create>(2), B<timerfd_create>(2), "
"B<sleep>(3), B<time>(7)"

#. type: TH
#: build/C/man2/brk.2:29
#, no-wrap
msgid "BRK"
msgstr "BRK"

#. type: TH
#: build/C/man2/brk.2:29 build/C/man3/getusershell.3:30
#: build/C/man2/vhangup.2:28
#, no-wrap
msgid "2016-03-15"
msgstr " 2016-03-15"

#. type: Plain text
#: build/C/man2/brk.2:32
msgid "brk, sbrk - change data segment size"
msgstr "brk, sbrk - データセグメントのサイズの変更する"

#. type: Plain text
#: build/C/man2/brk.2:34 build/C/man2/chdir.2:38 build/C/man2/chroot.2:38
#: build/C/man3/daemon.3:41 build/C/man2/execve.2:42 build/C/man2/fork.2:46
#: build/C/man2/fsync.2:43 build/C/man2/getdomainname.2:34
#: build/C/man3/getdtablesize.3:32 build/C/man3/gethostid.3:34
#: build/C/man2/gethostname.2:37 build/C/man3/getlogin.3:33
#: build/C/man2/getpagesize.2:30 build/C/man2/idle.2:37 build/C/man3/lockf.3:33
#: build/C/man2/mincore.2:39 build/C/man2/nice.2:36 build/C/man2/pread.2:30
#: build/C/man2/setup.2:39 build/C/man2/swapon.2:47 build/C/man3/tcgetpgrp.3:30
#: build/C/man2/truncate.2:48 build/C/man2/uselib.2:36 build/C/man2/vfork.2:36
#: build/C/man2/vhangup.2:33 build/C/man2/execveat.2:31
msgid "B<#include E<lt>unistd.hE<gt>>"
msgstr "B<#include E<lt>unistd.hE<gt>>"

#. type: Plain text
#: build/C/man2/brk.2:36
msgid "B<int brk(void *>I<addr>B<);>"
msgstr "B<int brk(void *>I<addr>B<);>"

#. type: Plain text
#: build/C/man2/brk.2:38
msgid "B<void *sbrk(intptr_t >I<increment>B<);>"
msgstr "B<void *sbrk(intptr_t >I<increment>B<);>"

#. type: Plain text
#: build/C/man2/brk.2:46
msgid "B<brk>(), B<sbrk>():"
msgstr "B<brk>(), B<sbrk>():"

#. type: TP
#: build/C/man2/brk.2:49 build/C/man2/getpagesize.2:42
#: build/C/man2/syscall.2:61
#, no-wrap
msgid "Since glibc 2.19:"
msgstr "glibc 2.19 以降:"

#.     (_XOPEN_SOURCE\ >=\ 500 ||
#.         _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED) &&
#. type: Plain text
#: build/C/man2/brk.2:57
#, no-wrap
msgid ""
"_DEFAULT_SOURCE ||\n"
"    (_XOPEN_SOURCE\\ E<gt>=\\ 500) &&\n"
"    ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200112L)\n"
msgstr ""
" _DEFAULT_SOURCE ||\n"
"    (_XOPEN_SOURCE\\ E<gt>=\\ 500) &&\n"
"    ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200112L)\n"

#. type: TP
#: build/C/man2/brk.2:58 build/C/man2/getpagesize.2:47
#, no-wrap
msgid "From glibc 2.12 to 2.19:"
msgstr "glibc 2.12 から 2.19 まで:"

#.     (_XOPEN_SOURCE\ >=\ 500 ||
#.         _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED) &&
#. type: Plain text
#: build/C/man2/brk.2:66
#, no-wrap
msgid ""
"_BSD_SOURCE || _SVID_SOURCE ||\n"
"    (_XOPEN_SOURCE\\ E<gt>=\\ 500) &&\n"
"    ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200112L)\n"
msgstr ""
"_BSD_SOURCE || _SVID_SOURCE ||\n"
"    (_XOPEN_SOURCE\\ E<gt>=\\ 500) &&\n"
"    ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200112L)\n"

#. type: TP
#: build/C/man2/brk.2:67 build/C/man3/getcwd.3:67
#: build/C/man3/getdtablesize.3:51 build/C/man2/getpagesize.2:52
#: build/C/man3/ualarm.3:50 build/C/man3/usleep.3:59 build/C/man2/vfork.2:55
#, no-wrap
msgid "Before glibc 2.12:"
msgstr "glibc 2.12 より前:"

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: build/C/man2/brk.2:71
msgid "_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500"
msgstr "_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500"

#. type: Plain text
#: build/C/man2/brk.2:86
msgid ""
"B<brk>()  and B<sbrk>()  change the location of the I<program break>, which "
"defines the end of the process's data segment (i.e., the program break is "
"the first location after the end of the uninitialized data segment).  "
"Increasing the program break has the effect of allocating memory to the "
"process; decreasing the break deallocates memory."
msgstr ""
"B<brk>()  と B<sbrk>()  は I<プログラムブレーク (program break)> の場所を変更"
"する。 プログラムブレークはプロセスのデータセグメント (data segment) の 末尾"
"を示す (プログラムブレークは、初期化されていない データセグメントの末尾の直後"
"の場所となる)。 プログラムブレークを増やすということは、そのプロセスへの メモ"
"リーを割り当てる効果があり、 プログラムブレークを減らすということは、メモリー"
"を解放する ということである。"

#. type: Plain text
#: build/C/man2/brk.2:93
msgid ""
"B<brk>()  sets the end of the data segment to the value specified by "
"I<addr>, when that value is reasonable, the system has enough memory, and "
"the process does not exceed its maximum data size (see B<setrlimit>(2))."
msgstr ""
"B<brk>()  は、データセグメントの末尾を I<addr> で指定した値に設定する。 設定"
"が行われるのは、指定した値が有効で、 システムに十分なメモリーがあり、 プロセ"
"スのデータサイズの最大値を超えていない場合である (B<setrlimit>(2)  を参照)。"

#. type: Plain text
#: build/C/man2/brk.2:103
msgid ""
"B<sbrk>()  increments the program's data space by I<increment> bytes.  "
"Calling B<sbrk>()  with an I<increment> of 0 can be used to find the current "
"location of the program break."
msgstr ""
"B<sbrk>()  は、プログラムのデータ空間を I<increment> バイトだけ増やす。 "
"I<increment> を 0 にして B<sbrk>()  を呼び出すことで、プログラムの現在のブ"
"レーク (break) 場所を知ることができる。"

#. type: Plain text
#: build/C/man2/brk.2:111
msgid ""
"On success, B<brk>()  returns zero.  On error, -1 is returned, and I<errno> "
"is set to B<ENOMEM>."
msgstr ""
"成功した場合、 B<brk>()  は 0 を返す。 エラーの場合には、-1 を返し、 "
"I<errno> に B<ENOMEM> を設定する。"

#. type: Plain text
#: build/C/man2/brk.2:123
msgid ""
"On success, B<sbrk>()  returns the previous program break.  (If the break "
"was increased, then this value is a pointer to the start of the newly "
"allocated memory).  On error, I<(void\\ *)\\ -1> is returned, and I<errno> "
"is set to B<ENOMEM>."
msgstr ""
"成功した場合、 B<sbrk>()  は変更前のプログラムブレークを返す (プログラムブ"
"レークが増やされた場合、この値は 新しく割り当てられたメモリーの先頭を指すポイ"
"ンターとなる)。 エラーの場合には、 I<(void\\ *)\\ -1> を返し、 I<errno> に "
"B<ENOMEM> を設定する。"

#.  .BR brk ()
#.  and
#.  .BR sbrk ()
#.  are not defined in the C Standard and are deliberately excluded from the
#.  POSIX.1-1990 standard (see paragraphs B.1.1.1.3 and B.8.3.3).
#. type: Plain text
#: build/C/man2/brk.2:131
msgid "4.3BSD; SUSv1, marked LEGACY in SUSv2, removed in POSIX.1-2001."
msgstr ""
"4.3BSD, SUSv1.  SUSv2 では「過去の名残 (LEGACY)」と位置付けられており、 "
"POSIX.1-2001 で削除された。"

#. type: Plain text
#: build/C/man2/brk.2:140
msgid ""
"Avoid using B<brk>()  and B<sbrk>(): the B<malloc>(3)  memory allocation "
"package is the portable and comfortable way of allocating memory."
msgstr ""
"B<brk>()  や B<sbrk>()  を使用するのは避けること。 B<malloc>(3)  メモリー割り"
"当てパッケージの方が、移植性が高く、 使いやすいメモリー割り当て方法を提供して"
"いる。"

#.  One sees
#.  \fIint\fP (e.g., XPGv4, DU 4.0, HP-UX 11, FreeBSD 4.0, OpenBSD 3.2),
#.  \fIssize_t\fP (OSF1 2.0, Irix 5.3, 6.5),
#.  \fIptrdiff_t\fP (libc4, libc5, ulibc, glibc 2.0, 2.1),
#.  \fIintptr_t\fP (e.g., XPGv5, AIX, SunOS 5.8, 5.9, FreeBSD 4.7, NetBSD 1.6,
#.  Tru64 5.1, glibc2.2).
#. type: Plain text
#: build/C/man2/brk.2:150
msgid ""
"Various systems use various types for the argument of B<sbrk>().  Common are "
"I<int>, I<ssize_t>, I<ptrdiff_t>, I<intptr_t>."
msgstr ""
"いろいろなシステムにおいて、 B<sbrk>()  の引数に様々な型が使われている。 一"
"般的なのは I<int>, I<ssize_t>, I<ptrdiff_t>, I<intptr_t> である。"

#. type: Plain text
#: build/C/man2/brk.2:166
msgid ""
"The return value described above for B<brk>()  is the behavior provided by "
"the glibc wrapper function for the Linux B<brk>()  system call.  (On most "
"other implementations, the return value from B<brk>()  is the same; this "
"return value was also specified in SUSv2.)  However, the actual Linux system "
"call returns the new program break on success.  On failure, the system call "
"returns the current break.  The glibc wrapper function does some work (i.e., "
"checks whether the new break is less than I<addr>)  to provide the 0 and -1 "
"return values described above."
msgstr ""
"上で説明した B<brk>()  の返り値についての動作は、 Linux の B<brk>()  システム"
"コールをラップする glibc の関数によるものである。 (その他の多くの実装でも、 "
"B<brk>()  の返り値はこれと同じである。 この返り値は SUSv2 でも規定されてい"
"る。)  しかし、実際の Linux システムコールは、成功した場合、 プログラムの新し"
"いブレークを返す。 失敗した場合、このシステムコールは現在のブレークを返す。 "
"glibc ラッパー関数は同様の働きをし (すなわち、新しいブレークが I<addr> より小"
"さいかどうかをチェックし)、 上で説明した 0 と -1 という返り値を返す。"

#. type: Plain text
#: build/C/man2/brk.2:173
msgid ""
"On Linux, B<sbrk>()  is implemented as a library function that uses the "
"B<brk>()  system call, and does some internal bookkeeping so that it can "
"return the old break value."
msgstr ""
"Linux では B<sbrk>()  は B<brk>()  システムコールを使うライブラリ関数として実"
"装されており、 以前のブレークの値を返すことができるように内部で調整が行われて"
"いる。"

#. type: Plain text
#: build/C/man2/brk.2:178
msgid "B<execve>(2), B<getrlimit>(2), B<end>(3), B<malloc>(3)"
msgstr "B<execve>(2), B<getrlimit>(2), B<end>(3), B<malloc>(3)"

#. type: TH
#: build/C/man2/chdir.2:33
#, no-wrap
msgid "CHDIR"
msgstr "CHDIR"

#. type: TH
#: build/C/man2/chdir.2:33 build/C/man3/exec.3:41
#, no-wrap
msgid "2019-08-02"
msgstr "2019-08-02"

#. type: Plain text
#: build/C/man2/chdir.2:36
msgid "chdir, fchdir - change working directory"
msgstr "chdir, fchdir - 作業ディレクトリの変更"

#. type: Plain text
#: build/C/man2/chdir.2:40
msgid "B<int chdir(const char *>I<path>B<);>"
msgstr "B<int chdir(const char *>I<path>B<);>"

#. type: Plain text
#: build/C/man2/chdir.2:42
msgid "B<int fchdir(int >I<fd>B<);>"
msgstr "B<int fchdir(int >I<fd>B<);>"

#. type: Plain text
#: build/C/man2/chdir.2:49
msgid "B<fchdir>():"
msgstr "B<fchdir>():"

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: build/C/man2/chdir.2:56
#, no-wrap
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* Since glibc 2.12: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L\n"
"    || /* Glibc up to and including 2.19: */ _BSD_SOURCE\n"
msgstr ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* glibc 2.12 以降: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L\n"
"    || /* glibc 2.19 以前: */ _BSD_SOURCE\n"

#. type: Plain text
#: build/C/man2/chdir.2:64
msgid ""
"B<chdir>()  changes the current working directory of the calling process to "
"the directory specified in I<path>."
msgstr ""
"B<chdir>()  は、呼び出し元プロセスの現在の作業ディレクトリ (current working "
"directory) を、 I<path> に指定されたディレクトリに変更する。"

#. type: Plain text
#: build/C/man2/chdir.2:70
msgid ""
"B<fchdir>()  is identical to B<chdir>(); the only difference is that the "
"directory is given as an open file descriptor."
msgstr ""
"B<fchdir>()  は、ディレクトリがオープンされたファイルディスクリプターとして "
"指定される以外は、 B<chdir>()  と同じである。"

#. type: Plain text
#: build/C/man2/chdir.2:75 build/C/man2/chmod.2:249 build/C/man2/chown.2:230
#: build/C/man2/chroot.2:121 build/C/man2/flock.2:117
#: build/C/man2/getdomainname.2:88 build/C/man2/gethostname.2:101
#: build/C/man2/ioperm.2:82 build/C/man3/lockf.3:123 build/C/man2/swapon.2:118
#: build/C/man2/truncate.2:113 build/C/man2/uname.2:69 build/C/man2/uselib.2:56
#: build/C/man2/vhangup.2:63
msgid ""
"On success, zero is returned.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""
"成功した場合は 0 が返される。エラーの場合は -1 が返され、 I<errno> が適切に設"
"定される。"

#. type: Plain text
#: build/C/man2/chdir.2:81
msgid ""
"Depending on the filesystem, other errors can be returned.  The more general "
"errors for B<chdir>()  are listed below:"
msgstr ""
"ファイルシステムによっては他のエラーが返される事がある。 B<chdir>()  で一般的"
"なエラーを以下に挙げる:"

#. type: Plain text
#: build/C/man2/chdir.2:87
msgid ""
"Search permission is denied for one of the components of I<path>.  (See also "
"B<path_resolution>(7).)"
msgstr ""
"I<path> の構成要素のいずれかに検索許可 (search permission) がない "
"(B<path_resolution>(7)  も参照すること)。"

#. type: Plain text
#: build/C/man2/chdir.2:91 build/C/man2/chroot.2:135
msgid "I<path> points outside your accessible address space."
msgstr "I<path> がアクセスできるアドレス空間外を指している。"

#. type: Plain text
#: build/C/man2/chdir.2:98 build/C/man2/chroot.2:142
msgid "Too many symbolic links were encountered in resolving I<path>."
msgstr "I<path> を解決する際に遭遇したシンボリックリンクが多過ぎる。"

#. type: Plain text
#: build/C/man2/chdir.2:102 build/C/man2/chroot.2:146
msgid "I<path> is too long."
msgstr "I<path> が長過ぎる。"

#. type: Plain text
#: build/C/man2/chdir.2:107
msgid "The directory specified in I<path> does not exist."
msgstr "I<path> で指定されたディレクトリが存在しない。"

#. type: Plain text
#: build/C/man2/chdir.2:115 build/C/man2/chroot.2:157
msgid "A component of I<path> is not a directory."
msgstr "I<path> の構成要素がディレクトリではない。"

#. type: Plain text
#: build/C/man2/chdir.2:119
msgid "The general errors for B<fchdir>()  are listed below:"
msgstr "B<fchdir>()  で一般的なエラーを以下に挙げる:"

#. type: Plain text
#: build/C/man2/chdir.2:123
msgid "Search permission was denied on the directory open on I<fd>."
msgstr "I<fd> をディレクトリとしてオープンするための検索許可がない。"

#. type: Plain text
#: build/C/man2/chdir.2:127 build/C/man3/tcgetpgrp.3:91
#: build/C/man2/truncate.2:190
msgid "I<fd> is not a valid file descriptor."
msgstr "I<fd> が適切なファイルディスクリプターでない。"

#. type: Plain text
#: build/C/man2/chdir.2:131
msgid "I<fd> does not refer to a directory."
msgstr "I<fd> がディレクトリを参照していない。"

#. type: Plain text
#: build/C/man2/chdir.2:133
msgid "POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD."
msgstr "POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD."

#. type: Plain text
#: build/C/man2/chdir.2:136
msgid ""
"The current working directory is the starting point for interpreting "
"relative pathnames (those not starting with \\(aq/\\(aq)."
msgstr ""
"現在の作業ディレクトリは、相対パス名 (\\(aq/\\(aq) で始まっていないパス名) "
"を 解釈する際の開始点である。"

#. type: Plain text
#: build/C/man2/chdir.2:142
msgid ""
"A child process created via B<fork>(2)  inherits its parent's current "
"working directory.  The current working directory is left unchanged by "
"B<execve>(2)."
msgstr ""
"B<fork>(2)  で作成された子プロセスは、親プロセスの現在の作業ディレクトリを 継"
"承する。 B<execve>(2)  の前後で、現在の作業ディレクトリは変更されない。"

#. type: Plain text
#: build/C/man2/chdir.2:146
msgid "B<chroot>(2), B<getcwd>(3), B<path_resolution>(7)"
msgstr "B<chroot>(2), B<getcwd>(3), B<path_resolution>(7)"

#. type: TH
#: build/C/man2/chmod.2:32
#, no-wrap
msgid "CHMOD"
msgstr "CHMOD"

#. type: TH
#: build/C/man2/chmod.2:32 build/C/man3/euidaccess.3:25 build/C/man2/flock.2:35
#: build/C/man3/gethostid.3:29 build/C/man2/getpagesize.2:25
#: build/C/man3/getumask.3:28 build/C/man2/ioperm.2:34
#: build/C/man2/mincore.2:34 build/C/man2/nice.2:31 build/C/man2/pread.2:25
#: build/C/man3/sleep.3:26 build/C/man2/swapon.2:42 build/C/man2/sysinfo.2:35
#: build/C/man3/ualarm.3:24 build/C/man3/usleep.3:33 build/C/man2/vfork.2:29
#: build/C/man2/execveat.2:26
#, no-wrap
msgid "2017-09-15"
msgstr "2017-09-15"

#. type: Plain text
#: build/C/man2/chmod.2:35
msgid "chmod, fchmod, fchmodat - change permissions of a file"
msgstr "chmod, fchmod, fchmodat - ファイルのモードを変更する"

#. type: Plain text
#: build/C/man2/chmod.2:38
#, no-wrap
msgid "B<#include E<lt>sys/stat.hE<gt>>\n"
msgstr "B<#include E<lt>sys/stat.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/chmod.2:41
#, no-wrap
msgid ""
"B<int chmod(const char *>I<pathname>B<, mode_t >I<mode>B<);>\n"
"B<int fchmod(int >I<fd>B<, mode_t >I<mode>B<);>\n"
msgstr ""
"B<int chmod(const char *>I<pathname>B<, mode_t >I<mode>B<);>\n"
"B<int fchmod(int >I<fd>B<, mode_t >I<mode>B<);>\n"

#. type: Plain text
#: build/C/man2/chmod.2:44
#, no-wrap
msgid ""
"B<#include E<lt>fcntl.hE<gt>>           /* Definition of AT_* constants */\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
msgstr ""
"B<#include E<lt>fcntl.hE<gt>>           /* AT_* 定数の定義 */\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/chmod.2:47
#, no-wrap
msgid "B<int fchmodat(int >I<dirfd>B<, const char *>I<pathname>B<, mode_t >I<mode>B<, int >I<flags>B<);>\n"
msgstr "B<int fchmodat(int >I<dirfd>B<, const char *>I<pathname>B<, mode_t >I<mode>B<, int >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man2/chmod.2:57
msgid "B<fchmod>():"
msgstr "B<fchmod>():"

#.         || (_XOPEN_SOURCE && _XOPEN_SOURCE_EXTENDED)
#. type: Plain text
#: build/C/man2/chmod.2:61
#, no-wrap
msgid ""
"Since glibc 2.24:\n"
"    _POSIX_C_SOURCE\\ E<gt>=\\ 199309L\n"
msgstr ""
"glibc 2.24 以降:\n"
"    _POSIX_C_SOURCE\\ E<gt>=\\ 199309L\n"

#. type: Plain text
#: build/C/man2/chmod.2:64
#, no-wrap
msgid ""
"Glibc 2.19 to 2.23\n"
"    _POSIX_C_SOURCE\n"
msgstr ""
"glibc 2.19 から 2.23 まで\n"
"    _POSIX_C_SOURCE\n"

#. type: Plain text
#: build/C/man2/chmod.2:67
#, no-wrap
msgid ""
"Glibc 2.16 to 2.19:\n"
"    _BSD_SOURCE || _POSIX_C_SOURCE\n"
msgstr ""
"glibc 2.16 から 2.19 まで:\n"
"    _BSD_SOURCE || _POSIX_C_SOURCE\n"

#. type: Plain text
#: build/C/man2/chmod.2:71
#, no-wrap
msgid ""
"Glibc 2.12 to 2.16:\n"
"    _BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 ||\n"
"        _POSIX_C_SOURCE E<gt>= 200809L\n"
msgstr ""
"glibc 2.12 から 2.16 まで:\n"
"    _BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 ||\n"
"        _POSIX_C_SOURCE E<gt>= 200809L\n"

#.         || (_XOPEN_SOURCE && _XOPEN_SOURCE_EXTENDED)
#. type: Plain text
#: build/C/man2/chmod.2:75
#, no-wrap
msgid ""
"Glibc 2.11 and earlier:\n"
"    _BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500\n"
msgstr ""
"glibc 2.11 以前:\n"
"    _BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500\n"

#. type: Plain text
#: build/C/man2/chmod.2:79
msgid "B<fchmodat>():"
msgstr "B<fchmodat>():"

#. type: Plain text
#: build/C/man2/chmod.2:101
#, fuzzy
#| msgid ""
#| "The B<chmod>()  and B<fchmod>()  system calls change the permissions of a "
#| "file.  They differ only in how the file is specified:"
msgid ""
"The B<chmod>()  and B<fchmod>()  system calls change a files mode bits.  "
"(The file mode consists of the file permission bits plus the set-user-ID, "
"set-group-ID, and sticky bits.)  These system calls differ only in how the "
"file is specified:"
msgstr ""
"システムコール B<chmod>() と B<fchmod>() は、ファイルのアクセス許可 "
"(permission) を変更する。 システムコール間の違いは、ファイルの指定の仕方だけ"
"である。"

#. type: IP
#: build/C/man2/chmod.2:101 build/C/man2/chmod.2:106 build/C/man2/chown.2:93
#: build/C/man2/chown.2:98 build/C/man2/chown.2:102 build/C/man2/chown.2:360
#: build/C/man2/chown.2:365 build/C/man2/chown.2:371 build/C/man2/dup.2:106
#: build/C/man2/dup.2:112 build/C/man2/dup.2:129 build/C/man2/dup.2:138
#: build/C/man7/environ.7:176 build/C/man7/environ.7:185
#: build/C/man7/environ.7:192 build/C/man7/environ.7:197
#: build/C/man7/environ.7:201 build/C/man7/environ.7:207
#: build/C/man7/environ.7:213 build/C/man7/environ.7:224
#: build/C/man7/environ.7:228 build/C/man7/environ.7:231
#: build/C/man2/execve.2:118 build/C/man2/execve.2:123
#: build/C/man2/execve.2:131 build/C/man2/execve.2:167
#: build/C/man2/execve.2:171 build/C/man2/execve.2:174
#: build/C/man2/execve.2:177 build/C/man2/execve.2:180
#: build/C/man2/execve.2:183 build/C/man2/execve.2:186
#: build/C/man2/execve.2:189 build/C/man2/execve.2:192
#: build/C/man2/execve.2:195 build/C/man2/execve.2:199
#: build/C/man2/execve.2:203 build/C/man2/execve.2:212
#: build/C/man2/execve.2:229 build/C/man2/execve.2:234
#: build/C/man2/execve.2:241 build/C/man2/execve.2:248
#: build/C/man2/execve.2:255 build/C/man2/execve.2:260
#: build/C/man2/execve.2:267 build/C/man2/execve.2:271
#: build/C/man2/execve.2:274 build/C/man2/execve.2:282
#: build/C/man2/execve.2:286 build/C/man2/execve.2:291 build/C/man2/fcntl.2:461
#: build/C/man2/fcntl.2:477 build/C/man2/fork.2:70 build/C/man2/fork.2:75
#: build/C/man2/fork.2:77 build/C/man2/fork.2:81 build/C/man2/fork.2:87
#: build/C/man2/fork.2:90 build/C/man2/fork.2:93 build/C/man2/fork.2:101
#: build/C/man2/fork.2:106 build/C/man2/fork.2:118 build/C/man2/fork.2:125
#: build/C/man2/fork.2:131 build/C/man2/fork.2:138 build/C/man2/fork.2:144
#: build/C/man2/fork.2:153 build/C/man2/fork.2:158 build/C/man2/fork.2:166
#: build/C/man2/fork.2:175 build/C/man2/fork.2:183 build/C/man2/fork.2:197
#: build/C/man2/fork.2:206 build/C/man2/fork.2:228 build/C/man2/fork.2:235
#: build/C/man2/fork.2:240 build/C/man2/fork.2:246 build/C/man3/fpathconf.3:176
#: build/C/man3/fpathconf.3:185 build/C/man3/fpathconf.3:197
#: build/C/man3/fpathconf.3:203 build/C/man3/getopt.3:179
#: build/C/man3/getopt.3:186 build/C/man3/getopt.3:197
#: build/C/man2/syscalls.2:89 build/C/man2/syscalls.2:92
#: build/C/man2/syscalls.2:98 build/C/man2/syscalls.2:114
#: build/C/man2/syscalls.2:120 build/C/man2/syscalls.2:126
#: build/C/man2/syscalls.2:132 build/C/man2/syscalls.2:141
#: build/C/man2/syscalls.2:850 build/C/man2/syscalls.2:852
#: build/C/man2/syscalls.2:860 build/C/man2/syscalls.2:863
#: build/C/man2/syscalls.2:866 build/C/man2/syscalls.2:869
#: build/C/man2/syscalls.2:872 build/C/man2/syscalls.2:875
#: build/C/man2/syscalls.2:884 build/C/man2/syscalls.2:887
#: build/C/man2/syscalls.2:890 build/C/man2/syscalls.2:893
#: build/C/man2/syscalls.2:902 build/C/man2/syscalls.2:940
#: build/C/man2/syscalls.2:961 build/C/man2/syscalls.2:972
#: build/C/man2/syscalls.2:979 build/C/man2/syscalls.2:990
#: build/C/man2/syscalls.2:1002 build/C/man2/syscalls.2:1025
#: build/C/man2/syscalls.2:1033 build/C/man2/syscalls.2:1088
#: build/C/man2/syscalls.2:1094 build/C/man2/syscalls.2:1099
#: build/C/man2/syscalls.2:1103 build/C/man2/syscalls.2:1108
#: build/C/man3/sysconf.3:330 build/C/man3/sysconf.3:339
#: build/C/man3/sysconf.3:351 build/C/man3/sysconf.3:357
#: build/C/man2/vfork.2:195 build/C/man2/vfork.2:199 build/C/man2/vfork.2:216
#, no-wrap
msgid "*"
msgstr "*"

#. type: Plain text
#: build/C/man2/chmod.2:106
msgid ""
"B<chmod>()  changes the mode of the file specified whose pathname is given "
"in I<pathname>, which is dereferenced if it is a symbolic link."
msgstr ""
"B<chmod>()  は、 I<pathname> で指定されたパス名を持つファイルのモードを変更す"
"る。 I<pathname> がシンボリックリンクの場合は、リンクの展開が行われる。"

#. type: Plain text
#: build/C/man2/chmod.2:110
msgid ""
"B<fchmod>()  changes the mode of the file referred to by the open file "
"descriptor I<fd>."
msgstr ""
"B<fchmod>()  は、オープンされたファイルディスクリプター I<fd> により参照され"
"るファイルのモードを変更する。"

#. type: Plain text
#: build/C/man2/chmod.2:115
msgid ""
"The new file mode is specified in I<mode>, which is a bit mask created by "
"ORing together zero or more of the following:"
msgstr ""
"新しいファイルモードは I<mode> で指定される。 I<mode> は、以下に示す値の 0 個"
"以上の OR (論理和) をとって作成される ビットマスクである。"

#. type: TP
#: build/C/man2/chmod.2:115
#, no-wrap
msgid "B<S_ISUID>  (04000)"
msgstr "B<S_ISUID>  (04000)"

#. type: Plain text
#: build/C/man2/chmod.2:119
msgid "set-user-ID (set process effective user ID on B<execve>(2))"
msgstr ""
"set-user-ID (B<execve>(2)  時にプロセスの実効ユーザー ID にセットされる)"

#. type: TP
#: build/C/man2/chmod.2:119
#, no-wrap
msgid "B<S_ISGID>  (02000)"
msgstr "B<S_ISGID>  (02000)"

#. type: Plain text
#: build/C/man2/chmod.2:129
msgid ""
"set-group-ID (set process effective group ID on B<execve>(2); mandatory "
"locking, as described in B<fcntl>(2); take a new file's group from parent "
"directory, as described in B<chown>(2)  and B<mkdir>(2))"
msgstr ""
"set-group-ID (以下の場合に (B<execve>(2)  実行時にプロセスの実効グループ ID "
"にセットされる、 強制ロック (mandatory locking) を行う (B<fcntl>(2)  の説明を"
"参照)、 新しいファイルのグループとして親ディレクトリと同じものを使う "
"(B<chown>(2)  と B<(>mkdirB<(2)> の説明を参照)"

#. type: TP
#: build/C/man2/chmod.2:129
#, no-wrap
msgid "B<S_ISVTX>  (01000)"
msgstr "B<S_ISVTX>  (01000)"

#. type: Plain text
#: build/C/man2/chmod.2:133
msgid "sticky bit (restricted deletion flag, as described in B<unlink>(2))"
msgstr ""
"スティッキービット (sticky bit) (削除制限フラグ、 B<unlink>(2)  の説明を参照)"

#. type: TP
#: build/C/man2/chmod.2:133
#, no-wrap
msgid "B<S_IRUSR>  (00400)"
msgstr "B<S_IRUSR>  (00400)"

#. type: Plain text
#: build/C/man2/chmod.2:136
msgid "read by owner"
msgstr "所有者による読み取り"

#. type: TP
#: build/C/man2/chmod.2:136
#, no-wrap
msgid "B<S_IWUSR>  (00200)"
msgstr "B<S_IWUSR>  (00200)"

#. type: Plain text
#: build/C/man2/chmod.2:139
msgid "write by owner"
msgstr "所有者による書き込み"

#. type: TP
#: build/C/man2/chmod.2:139
#, no-wrap
msgid "B<S_IXUSR>  (00100)"
msgstr "B<S_IXUSR>  (00100)"

#. type: Plain text
#: build/C/man2/chmod.2:143
msgid ""
"execute/search by owner (\"search\" applies for directories, and means that "
"entries within the directory can be accessed)"
msgstr ""
"所有者による実行 (execute) / 検索 (search)  (「検索」はディレクトリに対して適"
"用されるもので、 そのディレクトリ内のエントリーへアクセスできるかを意味する)"

#. type: TP
#: build/C/man2/chmod.2:143
#, no-wrap
msgid "B<S_IRGRP>  (00040)"
msgstr "B<S_IRGRP>  (00040)"

#. type: Plain text
#: build/C/man2/chmod.2:146
msgid "read by group"
msgstr "グループによる読み取り"

#. type: TP
#: build/C/man2/chmod.2:146
#, no-wrap
msgid "B<S_IWGRP>  (00020)"
msgstr "B<S_IWGRP>  (00020)"

#. type: Plain text
#: build/C/man2/chmod.2:149
msgid "write by group"
msgstr "グループによる書き込み"

#. type: TP
#: build/C/man2/chmod.2:149
#, no-wrap
msgid "B<S_IXGRP>  (00010)"
msgstr "B<S_IXGRP>  (00010)"

#. type: Plain text
#: build/C/man2/chmod.2:152
msgid "execute/search by group"
msgstr "グループによる実行 / 検索"

#. type: TP
#: build/C/man2/chmod.2:152
#, no-wrap
msgid "B<S_IROTH>  (00004)"
msgstr "B<S_IROTH>  (00004)"

#. type: Plain text
#: build/C/man2/chmod.2:155
msgid "read by others"
msgstr "他人 (others) による読み取り"

#. type: TP
#: build/C/man2/chmod.2:155
#, no-wrap
msgid "B<S_IWOTH>  (00002)"
msgstr "B<S_IWOTH>  (00002)"

#. type: Plain text
#: build/C/man2/chmod.2:158
msgid "write by others"
msgstr "他人による書き込み"

#. type: TP
#: build/C/man2/chmod.2:158
#, no-wrap
msgid "B<S_IXOTH>  (00001)"
msgstr "B<S_IXOTH>  (00001)"

#. type: Plain text
#: build/C/man2/chmod.2:161
msgid "execute/search by others"
msgstr "他人による実行 / 検索"

#. type: Plain text
#: build/C/man2/chmod.2:166
msgid ""
"The effective UID of the calling process must match the owner of the file, "
"or the process must be privileged (Linux: it must have the B<CAP_FOWNER> "
"capability)."
msgstr ""
"呼び出したプロセスの実効 (effective) UID がファイルの所有者と一致するか、 そ"
"のプロセスが特権を持たなければならない (Linux では B<CAP_FOWNER> ケーパビリ"
"ティ (capability) を持たなければならない)。"

#. type: Plain text
#: build/C/man2/chmod.2:175
msgid ""
"If the calling process is not privileged (Linux: does not have the "
"B<CAP_FSETID> capability), and the group of the file does not match the "
"effective group ID of the process or one of its supplementary group IDs, the "
"B<S_ISGID> bit will be turned off, but this will not cause an error to be "
"returned."
msgstr ""
"呼び出したプロセスに特権がなく (Linux では B<CAP_FSETID> ケーパビリティがな"
"く)、かつファイルのグループ ID が プロセスの実効グループ ID または補助的なグ"
"ループ ID にマッチしない場合、 B<S_ISGID> ビットはオフにされるが、これによっ"
"てエラーが返されることはない。"

#. type: Plain text
#: build/C/man2/chmod.2:187
msgid ""
"As a security measure, depending on the filesystem, the set-user-ID and set-"
"group-ID execution bits may be turned off if a file is written.  (On Linux, "
"this occurs if the writing process does not have the B<CAP_FSETID> "
"capability.)  On some filesystems, only the superuser can set the sticky "
"bit, which may have a special meaning.  For the sticky bit, and for set-user-"
"ID and set-group-ID bits on directories, see B<inode>(7)."
msgstr ""
"安全のための処置として、 ファイルシステムによっては、ファイルの書き込みを行う"
"時に set-user-ID とset-group-ID ビットと実行ビットが オフにされることがあ"
"る。 (Linux では、書き込みプロセスが B<CAP_FSETID> ケーパビリティを持っていな"
"い場合に、これが起こる。)  ファイルシステムの中には、スーパーユーザーだけが "
"特別の意味を持つスティッキービットを設定できるものがある。 スティッキービット"
"とディレクトリに対する set-user-ID (set-group-ID) ビットについては、 "
"B<inode>(7)  を見よ。"

#. type: Plain text
#: build/C/man2/chmod.2:195
msgid ""
"On NFS filesystems, restricting the permissions will immediately influence "
"already open files, because the access control is done on the server, but "
"open files are maintained by the client.  Widening the permissions may be "
"delayed for other clients if attribute caching is enabled on them."
msgstr ""
"NFS ファイルシステム上では、パーミッションを制限すると、 既にオープンされてい"
"るファイルに対してすぐに影響が及ぶ。 これはアクセス制御がサーバー上で行われて"
"いるが、 オープンされているファイルはクライアント側で管理されているためであ"
"る。 クライアント側でファイル属性のキャッシュが有効になっている場合に、 パー"
"ミッションの制限を緩くすると、 他のクライアントに情報が伝わるのが遅れるかもし"
"れない。"

#. type: SS
#: build/C/man2/chmod.2:195
#, no-wrap
msgid "fchmodat()"
msgstr "fchmodat()"

#. type: Plain text
#: build/C/man2/chmod.2:201
msgid ""
"The B<fchmodat>()  system call operates in exactly the same way as "
"B<chmod>(), except for the differences described here."
msgstr ""
"B<fchmodat>() システムコールは B<chmod>() と全く同様に動作するが、以下で説明"
"する点が異なる。"

#. type: Plain text
#: build/C/man2/chmod.2:211
msgid ""
"If the pathname given in I<pathname> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<dirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<chmod>()  for a relative pathname)."
msgstr ""
"I<pathname> で指定されたパス名が相対パスの場合、このパス名はファイルディスク"
"リプター I<dirfd> が参照するディレクトリに対する相対パスと解釈される "
"(B<chmod>() に相対パス名を渡した場合のように、呼び出したプロセスのカレント"
"ワーキングディレクトリに対する相対パスではない)。"

#. type: Plain text
#: build/C/man2/chmod.2:223
msgid ""
"If I<pathname> is relative and I<dirfd> is the special value B<AT_FDCWD>, "
"then I<pathname> is interpreted relative to the current working directory of "
"the calling process (like B<chmod>())."
msgstr ""
"I<pathname> で指定されたパス名が相対パスで、 I<dirfd> が特別な値 B<AT_FDCWD> "
"の場合、 (B<chmod>() と同様に) I<pathname> は呼び出したプロセスのカレントワー"
"キングディレクトリに対する相対パスと解釈される。"

#. type: Plain text
#: build/C/man2/chmod.2:232
msgid "I<flags> can either be 0, or include the following flag:"
msgstr "I<flags> には 0 か、以下のフラグを指定することができる。"

#. type: Plain text
#: build/C/man2/chmod.2:239
msgid ""
"If I<pathname> is a symbolic link, do not dereference it: instead operate on "
"the link itself.  This flag is not currently implemented."
msgstr ""
"I<pathname> がシンボリックリンクの場合、リンクの展開を行わない。代わりに、リ"
"ンク自身に対して操作を行う。このフラグは現在のところ実装されていない。"

#. type: Plain text
#: build/C/man2/chmod.2:244
msgid "See B<openat>(2)  for an explanation of the need for B<fchmodat>()."
msgstr "B<fchmodat>() の必要性についての説明については B<openat>(2) を参照。"

#. type: Plain text
#: build/C/man2/chmod.2:252 build/C/man2/chown.2:233
msgid ""
"Depending on the filesystem, errors other than those listed below can be "
"returned."
msgstr ""
"ファイルシステムによっては、下記の一覧にない他のエラーが返されることもある。"

#. type: Plain text
#: build/C/man2/chmod.2:256
msgid "The more general errors for B<chmod>()  are listed below:"
msgstr "B<chmod>() のごく一般的なエラーを挙げる:"

#.  Also search permission is required on the final component,
#.  maybe just to guarantee that it is a directory?
#. type: Plain text
#: build/C/man2/chmod.2:261 build/C/man2/chown.2:242 build/C/man2/chroot.2:131
msgid ""
"Search permission is denied on a component of the path prefix.  (See also "
"B<path_resolution>(7).)"
msgstr "パス名の構成要素に検索許可がない (B<path_resolution>(7)  も見よ)。"

#. type: Plain text
#: build/C/man2/chmod.2:279 build/C/man2/chown.2:257 build/C/man2/chroot.2:149
msgid "The file does not exist."
msgstr "ファイルが存在しない。"

#. type: Plain text
#: build/C/man2/chmod.2:285 build/C/man2/chown.2:263
#: build/C/man2/truncate.2:163
msgid "A component of the path prefix is not a directory."
msgstr "パス名の構成要素がディレクトリではない。"

#. type: TP
#: build/C/man2/chmod.2:285 build/C/man2/chmod.2:291 build/C/man2/chmod.2:311
#: build/C/man2/chown.2:263 build/C/man2/chown.2:267 build/C/man2/chown.2:289
#: build/C/man2/chroot.2:157 build/C/man3/crypt.3:165 build/C/man2/execve.2:541
#: build/C/man2/execve.2:547 build/C/man2/execve.2:551
#: build/C/man2/fcntl.2:1809 build/C/man2/fcntl.2:1816
#: build/C/man2/fcntl.2:1821 build/C/man2/getdomainname.2:99
#: build/C/man3/gethostid.3:93 build/C/man2/gethostname.2:124
#: build/C/man2/idle.2:56 build/C/man2/ioperm.2:96 build/C/man2/mkdir.2:187
#: build/C/man2/nice.2:79 build/C/man2/setup.2:57 build/C/man2/swapon.2:158
#: build/C/man3/tcgetpgrp.3:104 build/C/man2/truncate.2:163
#: build/C/man2/truncate.2:169 build/C/man2/vhangup.2:64
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#. type: Plain text
#: build/C/man2/chmod.2:291
msgid ""
"The effective UID does not match the owner of the file, and the process is "
"not privileged (Linux: it does not have the B<CAP_FOWNER> capability)."
msgstr ""
"実効 UID がファイルの所有者と一致せず、プロセスに特権がない (Linux では "
"B<CAP_FOWNER> ケーパビリティを持たない)。"

#. type: Plain text
#: build/C/man2/chmod.2:296 build/C/man2/chown.2:272
msgid "The file is marked immutable or append-only.  (See B<ioctl_iflags>(2).)"
msgstr ""

#. type: Plain text
#: build/C/man2/chmod.2:299 build/C/man2/chown.2:275
#: build/C/man2/truncate.2:176
msgid "The named file resides on a read-only filesystem."
msgstr "ファイルが読み込み専用 (read only) のファイルシステム上にある。"

#. type: Plain text
#: build/C/man2/chmod.2:303
msgid "The general errors for B<fchmod>()  are listed below:"
msgstr "B<fchmod>()  で一般的なエラーを挙げる:"

#. type: Plain text
#: build/C/man2/chmod.2:308
msgid "The file descriptor I<fd> is not valid."
msgstr "ファイルディスクリプター I<fd> が有効でない。"

#. type: Plain text
#: build/C/man2/chmod.2:311 build/C/man2/chmod.2:314 build/C/man2/chmod.2:317
#: build/C/man2/chown.2:289 build/C/man2/chown.2:292 build/C/man2/chown.2:295
msgid "See above."
msgstr "上記を参照。"

#. type: Plain text
#: build/C/man2/chmod.2:324
msgid ""
"The same errors that occur for B<chmod>()  can also occur for "
"B<fchmodat>().  The following additional errors can occur for B<fchmodat>():"
msgstr ""
"B<chmod>() で発生するのと同じエラーが B<fchmodat>() でも起こる。 "
"B<fchmodat>() では以下のエラーも発生する。"

#. type: TP
#: build/C/man2/chmod.2:338
#, no-wrap
msgid "B<ENOTSUP>"
msgstr "B<ENOTSUP>"

#. type: Plain text
#: build/C/man2/chmod.2:344
msgid "I<flags> specified B<AT_SYMLINK_NOFOLLOW>, which is not supported."
msgstr "I<flags> に対応していないフラグ B<AT_SYMLINK_NOFOLLOW> が指定された。"

#. type: Plain text
#: build/C/man2/chmod.2:348
msgid ""
"B<fchmodat>()  was added to Linux in kernel 2.6.16; library support was "
"added to glibc in version 2.4."
msgstr ""
"B<fchmodat>()  はカーネル 2.6.16 で Linux に追加された。 ライブラリによるサ"
"ポートはバージョン 2.4 以降の glibc で利用できる。"

#. type: Plain text
#: build/C/man2/chmod.2:352
msgid "B<chmod>(), B<fchmod>(): 4.4BSD, SVr4, POSIX.1-2001i, POSIX.1-2008."
msgstr "B<chmod>(), B<fchmod>(): 4.4BSD, SVr4, POSIX.1-2001i, POSIX.1-2008."

#. type: Plain text
#: build/C/man2/chmod.2:355
msgid "B<fchmodat>(): POSIX.1-2008."
msgstr "B<fchmodat>(): POSIX.1-2008."

#. type: Plain text
#: build/C/man2/chmod.2:366
msgid ""
"The GNU C library B<fchmodat>()  wrapper function implements the POSIX-"
"specified interface described in this page.  This interface differs from the "
"underlying Linux system call, which does I<not> have a I<flags> argument."
msgstr ""
"GNU C ライブラリの B<fchmodat>() ラッパー関数は、このページで説明している "
"POSIX で規定されたインターフェースを実装している。このインターフェースは、内"
"部で呼ばれる Linux のシステムコールとは異なる。システムコールは I<flags> 引"
"数をI<持たない>。"

#. type: Plain text
#: build/C/man2/chmod.2:379
msgid ""
"On older kernels where B<fchmodat>()  is unavailable, the glibc wrapper "
"function falls back to the use of B<chmod>().  When I<pathname> is a "
"relative pathname, glibc constructs a pathname based on the symbolic link in "
"I</proc/self/fd> that corresponds to the I<dirfd> argument."
msgstr ""
"B<fchmodat>() が利用できない古いカーネルでは、 glibc ラッパー関数は "
"B<chmod>() を使用するモードにフォールバックする。 I<pathname> が相対パスの場"
"合、 glibc は I<dirfd> 引数に対応する I</proc/self/fd> のシンボリックリンク"
"に基づいてパス名を構成する。"

#. type: Plain text
#: build/C/man2/chmod.2:388
msgid ""
"B<chmod>(1), B<chown>(2), B<execve>(2), B<open>(2), B<stat>(2), B<inode>(7), "
"B<path_resolution>(7), B<symlink>(7)"
msgstr ""
"B<chmod>(1), B<chown>(2), B<execve>(2), B<open>(2), B<stat>(2), B<inode>(7), "
"B<path_resolution>(7), B<symlink>(7)"

#. type: TH
#: build/C/man2/chown.2:38
#, no-wrap
msgid "CHOWN"
msgstr "CHOWN"

#. type: Plain text
#: build/C/man2/chown.2:41
msgid "chown, fchown, lchown, fchownat - change ownership of a file"
msgstr "chown, fchown, lchown, fchownat - ファイルの所有者を変更する"

#. type: Plain text
#: build/C/man2/chown.2:48
#, no-wrap
msgid ""
"B<int chown(const char *>I<pathname>B<, uid_t >I<owner>B<, gid_t >I<group>B<);>\n"
"B<int fchown(int >I<fd>B<, uid_t >I<owner>B<, gid_t >I<group>B<);>\n"
"B<int lchown(const char *>I<pathname>B<, uid_t >I<owner>B<, gid_t >I<group>B<);>\n"
msgstr ""
"B<int chown(const char *>I<pathname>B<, uid_t >I<owner>B<, gid_t >I<group>B<);>\n"
"B<int fchown(int >I<fd>B<, uid_t >I<owner>B<, gid_t >I<group>B<);>\n"
"B<int lchown(const char *>I<pathname>B<, uid_t >I<owner>B<, gid_t >I<group>B<);>\n"

#. type: Plain text
#: build/C/man2/chown.2:54
#, no-wrap
msgid ""
"B<int fchownat(int >I<dirfd>B<, const char *>I<pathname>B<,>\n"
"B<             uid_t >I<owner>B<, gid_t >I<group>B<, int >I<flags>B<);>\n"
msgstr ""
"B<int fchownat(int >I<dirfd>B<, const char *>I<pathname>B<,>\n"
"B<             uid_t >I<owner>B<, gid_t >I<group>B<, int >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man2/chown.2:63
msgid "B<fchown>(), B<lchown>():"
msgstr "B<fchown>(), B<lchown>():"

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: build/C/man2/chown.2:70
#, no-wrap
msgid ""
"/* Since glibc 2.12: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L\n"
"    || _XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE\n"
msgstr ""
"/* glibc 2.12 以降: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L\n"
"    || _XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* glibc 2.19 以前: */ _BSD_SOURCE\n"

#. type: Plain text
#: build/C/man2/chown.2:73
msgid "B<fchownat>():"
msgstr "B<fchownat>():"

#. type: Plain text
#: build/C/man2/chown.2:93
msgid ""
"These system calls change the owner and group of a file.  The B<chown>(), "
"B<fchown>(), and B<lchown>()  system calls differ only in how the file is "
"specified:"
msgstr ""
"これらのシステムコールは、いずれもファイルの所有者 (owner) とグループを変更す"
"る。システムコール B<chown>(), B<fchown>(), B<lchown>() 間の違いは、ファイル"
"の指定の仕方だけである。"

#. type: Plain text
#: build/C/man2/chown.2:98
msgid ""
"B<chown>()  changes the ownership of the file specified by I<pathname>, "
"which is dereferenced if it is a symbolic link."
msgstr ""
"B<chown>()  は I<pathname> で指定されたファイルの所有権を変更する。 "
"I<pathname> がシンボリックリンクの場合は、リンクの展開が行われる。"

#. type: Plain text
#: build/C/man2/chown.2:102
msgid ""
"B<fchown>()  changes the ownership of the file referred to by the open file "
"descriptor I<fd>."
msgstr ""
"B<fchown>()  はオープンされたファイルディスクリプター I<fd> により参照される"
"ファイルの所有権を変更する。"

#. type: Plain text
#: build/C/man2/chown.2:107
msgid ""
"B<lchown>()  is like B<chown>(), but does not dereference symbolic links."
msgstr ""
"B<lchown>()  は B<chown>()  と同じだが、シンボリックリンクを展開しない点が異"
"なる。"

#. type: Plain text
#: build/C/man2/chown.2:116
msgid ""
"Only a privileged process (Linux: one with the B<CAP_CHOWN> capability) may "
"change the owner of a file.  The owner of a file may change the group of the "
"file to any group of which that owner is a member.  A privileged process "
"(Linux: with B<CAP_CHOWN>)  may change the group arbitrarily."
msgstr ""
"特権を持つプロセス (Linux では B<CAP_CHOWN> ケーパビリティ (capability) を持"
"つプロセス) だけが ファイルの所有者を変更できる。 ファイルの所有者は、その所"
"有者が属しているグループのいずれかに ファイルのグループを変更することができ"
"る。 特権 (Linux では B<CAP_CHOWN>)  を持つプロセスは、任意のグループに変更で"
"きる。"

#. type: Plain text
#: build/C/man2/chown.2:122
msgid ""
"If the I<owner> or I<group> is specified as -1, then that ID is not changed."
msgstr ""
"I<owner> または I<group> に -1 が指定された場合、それらの ID は変更されない。"

#.  In Linux 2.0 kernels, superuser was like everyone else
#.  In 2.2, up to 2.2.12, these bits were not cleared for superuser.
#.  Since 2.2.13, superuser is once more like everyone else.
#. type: Plain text
#: build/C/man2/chown.2:143
#, fuzzy
#| msgid ""
#| "When the owner or group of an executable file are changed by an "
#| "unprivileged user the B<S_ISUID> and B<S_ISGID> mode bits are cleared.  "
#| "POSIX does not specify whether this also should happen when root does the "
#| "B<chown>(); the Linux behavior depends on the kernel version.  In case of "
#| "a non-group-executable file (i.e., one for which the B<S_IXGRP> bit is "
#| "not set) the B<S_ISGID> bit indicates mandatory locking, and is not "
#| "cleared by a B<chown>()."
msgid ""
"When the owner or group of an executable file is changed by an unprivileged "
"user, the B<S_ISUID> and B<S_ISGID> mode bits are cleared.  POSIX does not "
"specify whether this also should happen when root does the B<chown>(); the "
"Linux behavior depends on the kernel version, and since Linux 2.2.13, root "
"is treated like other users.  In case of a non-group-executable file (i.e., "
"one for which the B<S_IXGRP> bit is not set) the B<S_ISGID> bit indicates "
"mandatory locking, and is not cleared by a B<chown>()."
msgstr ""
"非特権ユーザーにより実行ファイルの所有者またはグループが 変更された場合は "
"B<S_ISUID> と B<ISGID> モードビットはクリアされる。 POSIX はこの動作やルート"
"が B<chown>()  を行なった場合については特に指定されていない。 Linux における"
"動作はカーネルのバージョンに依存する。 非グループ実行ファイル (B<S_IXGRP> "
"ビットが設定されていないファイル) の場合には B<S_ISGID> ビットは強制ロック "
"(mandatory locking) を意味している。 そしてそれは B<chown>()  ではクリアでき"
"ない。"

#. type: Plain text
#: build/C/man2/chown.2:147
msgid ""
"When the owner or group of an executable file is changed (by any user), all "
"capability sets for the file are cleared."
msgstr ""

#. type: SS
#: build/C/man2/chown.2:147
#, no-wrap
msgid "fchownat()"
msgstr "fchownat()"

#. type: Plain text
#: build/C/man2/chown.2:153
msgid ""
"The B<fchownat>()  system call operates in exactly the same way as "
"B<chown>(), except for the differences described here."
msgstr ""
"B<fchownat>() システムコールは B<chown>() と全く同様に動作するが、以下で説明"
"する点が異なる。"

#. type: Plain text
#: build/C/man2/chown.2:163
msgid ""
"If the pathname given in I<pathname> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<dirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<chown>()  for a relative pathname)."
msgstr ""
"I<pathname> で指定されたパス名が相対パスの場合、このパス名はファイルディスク"
"リプター I<dirfd> が参照するディレクトリに対する相対パスと解釈される "
"(B<chown>() に相対パス名を渡した場合のように、呼び出したプロセスのカレント"
"ワーキングディレクトリに対する相対パスではない)。"

#. type: Plain text
#: build/C/man2/chown.2:175
msgid ""
"If I<pathname> is relative and I<dirfd> is the special value B<AT_FDCWD>, "
"then I<pathname> is interpreted relative to the current working directory of "
"the calling process (like B<chown>())."
msgstr ""
"I<pathname> で指定されたパス名が相対パスで、 I<dirfd> が特別な値 B<AT_FDCWD> "
"の場合、 (B<chown>() と同様に) I<pathname> は呼び出したプロセスのカレントワー"
"キングディレクトリに対する相対パスと解釈される。"

#. type: Plain text
#: build/C/man2/chown.2:186
msgid ""
"The I<flags> argument is a bit mask created by ORing together 0 or more of "
"the following values;"
msgstr ""
"I<flags> 引数は、以下に示す値の 0 個以上の OR (論理和) をとって作成される "
"ビットマスクである。"

#. type: TP
#: build/C/man2/chown.2:186
#, no-wrap
msgid "B<AT_EMPTY_PATH> (since Linux 2.6.39)"
msgstr "B<AT_EMPTY_PATH> (Linux 2.6.39 以降)"

#.  commit 65cfc6722361570bfe255698d9cd4dccaf47570d
#.  Before glibc 2.16, defining _ATFILE_SOURCE sufficed
#. type: Plain text
#: build/C/man2/chown.2:209
msgid ""
"If I<pathname> is an empty string, operate on the file referred to by "
"I<dirfd> (which may have been obtained using the B<open>(2)  B<O_PATH> "
"flag).  In this case, I<dirfd> can refer to any type of file, not just a "
"directory.  If I<dirfd> is B<AT_FDCWD>, the call operates on the current "
"working directory.  This flag is Linux-specific; define B<_GNU_SOURCE> to "
"obtain its definition."
msgstr ""
"I<pathname> が空文字列の場合、 I<dirfd> が参照するファイルに対して操作を行う "
"(I<dirfd> は B<open>(2) B<O_PATH> フラグを使って取得することができる)。この場"
"合、 I<dirfd> は、ディレクトリだけでなく、任意のタイプのファイルを参照するこ"
"とができる。 I<dirfd> が B<AT_FDCWD> の場合、この呼び出しはカレントワーキング"
"ディレクトリに対して操作を行う。このフラグは Linux 固有であり、その定義を得る"
"には B<_GNU_SOURCE> を定義すること。"

#. type: Plain text
#: build/C/man2/chown.2:220
msgid ""
"If I<pathname> is a symbolic link, do not dereference it: instead operate on "
"the link itself, like B<lchown>().  (By default, B<fchownat>()  dereferences "
"symbolic links, like B<chown>().)"
msgstr ""
"I<pathname> がシンボリックリンクの場合、リンクの展開を行わない。代わりに、"
"B<lchown>() 同様、リンク自身に対して操作を行う。(デフォルトでは "
"B<fchownat>() は B<chown>() と同様にシンボリックリンクの展開を行う。)"

#. type: Plain text
#: build/C/man2/chown.2:225
msgid "See B<openat>(2)  for an explanation of the need for B<fchownat>()."
msgstr "B<fchownat>() の必要性についての説明については B<openat>(2) を参照。"

#. type: Plain text
#: build/C/man2/chown.2:237
msgid "The more general errors for B<chown>()  are listed below."
msgstr "B<chown>()  でごく一般的なエラーを以下に挙げる:"

#. type: Plain text
#: build/C/man2/chown.2:267
msgid ""
"The calling process did not have the required permissions (see above) to "
"change owner and/or group."
msgstr ""
"呼び出したプロセスに所有者またはグループ (もしくはその両方) を変更するために "
"要求される許可 (上記を参照) がない。"

#. type: Plain text
#: build/C/man2/chown.2:279
msgid "The general errors for B<fchown>()  are listed below:"
msgstr "B<fchown>()  で一般的なエラーを以下に挙げる:"

#. type: Plain text
#: build/C/man2/chown.2:283 build/C/man2/fsync.2:122
msgid "I<fd> is not a valid open file descriptor."
msgstr "I<fd> が有効なオープンされたディスクリプターでない。"

#. type: Plain text
#: build/C/man2/chown.2:286
msgid "A low-level I/O error occurred while modifying the inode."
msgstr "i ノード (inode) を変更する際に低レベル I/O エラーが発生した。"

#. type: Plain text
#: build/C/man2/chown.2:302
msgid ""
"The same errors that occur for B<chown>()  can also occur for "
"B<fchownat>().  The following additional errors can occur for B<fchownat>():"
msgstr ""
"B<chown>() で発生するのと同じエラーが B<fchownat>() でも起こる。 "
"B<fchownat>() では以下のエラーも発生する。"

#. type: Plain text
#: build/C/man2/chown.2:320
msgid ""
"B<fchownat>()  was added to Linux in kernel 2.6.16; library support was "
"added to glibc in version 2.4."
msgstr ""
"B<fchownat>()  はカーネル 2.6.16 で Linux に追加された。 ライブラリによるサ"
"ポートはバージョン 2.4 以降の glibc で利用できる。"

#. type: Plain text
#: build/C/man2/chown.2:325
msgid ""
"B<chown>(), B<fchown>(), B<lchown>(): 4.4BSD, SVr4, POSIX.1-2001, "
"POSIX.1-2008."
msgstr ""
"B<chown>(), B<fchown>(), B<lchown>(): 4.4BSD, SVr4, POSIX.1-2001, "
"POSIX.1-2008."

#.  chown():
#.  SVr4 documents EINVAL, EINTR, ENOLINK and EMULTIHOP returns, but no
#.  ENOMEM.  POSIX.1 does not document ENOMEM or ELOOP error conditions.
#.  fchown():
#.  SVr4 documents additional EINVAL, EIO, EINTR, and ENOLINK
#.  error conditions.
#. type: Plain text
#: build/C/man2/chown.2:334
msgid ""
"The 4.4BSD version can be used only by the superuser (that is, ordinary "
"users cannot give away files)."
msgstr ""
"4.4BSD 版ではスーパーユーザーのみが使用できる (つまり、普通のユーザーはファイ"
"ルを手放すことはできない)。"

#. type: Plain text
#: build/C/man2/chown.2:337
msgid "B<fchownat>(): POSIX.1-2008."
msgstr "B<fchownat>(): POSIX.1-2008."

#. type: SS
#: build/C/man2/chown.2:338
#, no-wrap
msgid "Ownership of new files"
msgstr "新しいファイルの所有権"

#. type: Plain text
#: build/C/man2/chown.2:360
msgid ""
"When a new file is created (by, for example, B<open>(2)  or B<mkdir>(2)), "
"its owner is made the same as the filesystem user ID of the creating "
"process.  The group of the file depends on a range of factors, including the "
"type of filesystem, the options used to mount the filesystem, and whether or "
"not the set-group-ID mode bit is enabled on the parent directory.  If the "
"filesystem supports the B<-o\\ grpid> (or, synonymously B<-o\\ bsdgroups>)  "
"and B<-o\\ nogrpid> (or, synonymously B<-o\\ sysvgroups>)  B<mount>(8)  "
"options, then the rules are as follows:"
msgstr ""
"(B<open>(2)  や B<mkdir>(2)  などにより) 新しいファイルが作成されるとき、 そ"
"の所有者は呼び出したプロセスのファイルシステムユーザー ID と 同じに設定され"
"る。 そのファイルのグループはいくつかの要因により決定される。 その要因として"
"は、 ファイルシステムの種類、そのファイルシステムのマウント時に 使用されたオ"
"プション、親ディレクトリで set-group-ID モードビットが 有効になっているどう"
"か、がある。 ファイルシステムが B<mount>(8)  オプションの B<-o\\ grpid> (B<-o"
"\\ bsdgroups> も同義語) と B<-o\\ nogrpid> (B<-o sysvgroups> も同義語) に対応"
"している場合、ルールは以下の通りとなる。"

#. type: Plain text
#: build/C/man2/chown.2:365
msgid ""
"If the filesystem is mounted with B<-o\\ grpid>, then the group of a new "
"file is made the same as that of the parent directory."
msgstr ""
"ファイルシステムが B<-o\\ grpid> 付きでマウントされている場合、新しいファイル"
"のグループは 親ディレクトリのグループと同じになる。"

#. type: Plain text
#: build/C/man2/chown.2:371
msgid ""
"If the filesystem is mounted with B<-o\\ nogrpid> and the set-group-ID bit "
"is disabled on the parent directory, then the group of a new file is made "
"the same as the process's filesystem GID."
msgstr ""
"ファイルシステムが B<-o\\ nogrpid> 付きでマウントされており、親ディレクトリで"
"は set-group-ID ビットが 無効になっている場合、新しいファイルのグループは プ"
"ロセスのファイルシステム GID と同じになる。"

#. type: Plain text
#: build/C/man2/chown.2:377
msgid ""
"If the filesystem is mounted with B<-o\\ nogrpid> and the set-group-ID bit "
"is enabled on the parent directory, then the group of a new file is made the "
"same as that of the parent directory."
msgstr ""
"ファイルシステムが B<-o\\ nogrpid> 付きでマウントされており、親ディレクトリで"
"は set-group-ID ビットが 有効になっている場合、新しいファイルのグループは 親"
"ディレクトリのグループと同じになる。"

#. type: Plain text
#: build/C/man2/chown.2:387
msgid ""
"As at Linux 4.12, the B<-o\\ grpid> and B<-o\\ nogrpid> mount options are "
"supported by ext2, ext3, ext4, and XFS.  Filesystems that don't support "
"these mount options follow the B<-o\\ nogrpid> rules."
msgstr ""
"Linux 4.12 の時点では、マウントオプション B<-o\\ grpid> と B<-o\\ nogrpid> に"
"対応しているファイルシステムは ext2, ext3, ext4, XFS である。 これらのマウン"
"トオプションに対応していないファイルシステムでは、 B<-o\\ nogrpid> に関する"
"ルールが適用される。"

#. type: Plain text
#: build/C/man2/chown.2:402
msgid ""
"On older kernels where B<fchownat>()  is unavailable, the glibc wrapper "
"function falls back to the use of B<chown>()  and B<lchown>().  When "
"I<pathname> is a relative pathname, glibc constructs a pathname based on the "
"symbolic link in I</proc/self/fd> that corresponds to the I<dirfd> argument."
msgstr ""
"B<fchownat>() が利用できない古いカーネルでは、 glibc ラッパー関数は "
"B<chown>() を使用するモードにフォールバックする。 I<pathname> が相対パスの場"
"合、 glibc は I<dirfd> 引数に対応する I</proc/self/fd> のシンボリックリンク"
"に基づいてパス名を構成する。"

#. type: SS
#: build/C/man2/chown.2:402
#, no-wrap
msgid "NFS"
msgstr "NFS"

#. type: Plain text
#: build/C/man2/chown.2:415
msgid ""
"The B<chown>()  semantics are deliberately violated on NFS filesystems which "
"have UID mapping enabled.  Additionally, the semantics of all system calls "
"which access the file contents are violated, because B<chown>()  may cause "
"immediate access revocation on already open files.  Client side caching may "
"lead to a delay between the time where ownership have been changed to allow "
"access for a user and the time where the file can actually be accessed by "
"the user on other clients."
msgstr ""
"B<chown>()  方式は UID マッピングを使用した NFS ファイルシステムを侵害する。 "
"さらにファイルの内容にアクセスする全てのシステムコールを侵害する。 これは "
"B<chown>()  が既にオープンされたファイルに対する アクセスをただちに取り消すこ"
"とによる。 クライアント側のキャッシュにより所有権が変更されて ユーザーのアク"
"セスが許した時点と、実際に他のクライアントでユーザーによって ファイルにアクセ"
"スできる時点との間に時間差があるかもしれない。"

#. type: SS
#: build/C/man2/chown.2:415
#, no-wrap
msgid "Historical details"
msgstr "歴史的な詳細"

#. type: Plain text
#: build/C/man2/chown.2:434
msgid ""
"The original Linux B<chown>(), B<fchown>(), and B<lchown>()  system calls "
"supported only 16-bit user and group IDs.  Subsequently, Linux 2.4 added "
"B<chown32>(), B<fchown32>(), and B<lchown32>(), supporting 32-bit IDs.  The "
"glibc B<chown>(), B<fchown>(), and B<lchown>()  wrapper functions "
"transparently deal with the variations across kernel versions."
msgstr ""
"元々の Linux の B<chown>(), B<fchown>(), B<lchown>() システムコールは、\n"
"16 ビットのユーザー ID とグループ ID だけに対応していた。\n"
"その後、 32 ビットの ID に対応した B<chown32>(), B<fchown32>(), "
"B<lchown32>()\n"
"が Linux 2.4 で追加された。\n"
"B<chown>(), B<fchown>(), and B<lchown>() の glibc のラッパー関数は、\n"
"カーネルのバージョンによる違いを吸収している。"

#. type: Plain text
#: build/C/man2/chown.2:449
msgid ""
"In versions of Linux prior to 2.1.81 (and distinct from 2.1.46), B<chown>()  "
"did not follow symbolic links.  Since Linux 2.1.81, B<chown>()  does follow "
"symbolic links, and there is a new system call B<lchown>()  that does not "
"follow symbolic links.  Since Linux 2.1.86, this new call (that has the same "
"semantics as the old B<chown>())  has got the same syscall number, and "
"B<chown>()  got the newly introduced number."
msgstr ""
"Linux の 2.1.81 より前のバージョン (特に 2.1.46 以前) では、 B<chown>()  はシ"
"ンボリックリンクを追跡しない。 Linux 2.1.81 以降では B<chown>()  はシンボリッ"
"クリンクを追跡し、新たなシステムコール B<lchown>()  はシンボリックリンクを追"
"跡しない。 Linux 2.1.86 以降ではこの新しいコール (古い B<chown>()  と全く同じ"
"動作を行なう) は同じシステムコール番号を持ち B<chown>()  は新しく導入された番"
"号を持つ。"

#. type: Plain text
#: build/C/man2/chown.2:457
msgid ""
"The following program changes the ownership of the file named in its second "
"command-line argument to the value specified in its first command-line "
"argument.  The new owner can be specified either as a numeric user ID, or as "
"a username (which is converted to a user ID by using B<getpwnam>(3)  to "
"perform a lookup in the system password file)."
msgstr ""
"以下のプログラムは、 二つ目のコマンドライン引数で指定された名前のファイルの"
"所有者を、 一つ目のコマンドライン引数で指定された値に変更する。 新しい所有"
"者は、数字のユーザー ID かユーザー名のいずれかで指定できる (ユーザー名で指定"
"した場合には、 B<getpwnam>(3)  を使ってシステムのパスワードファイルの検索が行"
"われ、 ユーザー ID への変換が行われる)。"

#. type: SS
#: build/C/man2/chown.2:457
#, no-wrap
msgid "Program source"
msgstr "プログラムのソース"

#. type: Plain text
#: build/C/man2/chown.2:463
#, no-wrap
msgid ""
"#include E<lt>pwd.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""
"#include E<lt>pwd.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"

#. type: Plain text
#: build/C/man2/chown.2:470
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    uid_t uid;\n"
"    struct passwd *pwd;\n"
"    char *endptr;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    uid_t uid;\n"
"    struct passwd *pwd;\n"
"    char *endptr;\n"

#. type: Plain text
#: build/C/man2/chown.2:475
#, no-wrap
msgid ""
"    if (argc != 3 || argv[1][0] == \\(aq\\e0\\(aq) {\n"
"        fprintf(stderr, \"%s E<lt>ownerE<gt> E<lt>fileE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 3 || argv[1][0] == \\(aq\\e0\\(aq) {\n"
"        fprintf(stderr, \"%s E<lt>ownerE<gt> E<lt>fileE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/chown.2:477
#, no-wrap
msgid "    uid = strtol(argv[1], &endptr, 10);  /* Allow a numeric string */\n"
msgstr "    uid = strtol(argv[1], &endptr, 10);  /* Allow a numeric string */\n"

#. type: Plain text
#: build/C/man2/chown.2:484
#, no-wrap
msgid ""
"    if (*endptr != \\(aq\\e0\\(aq) {         /* Was not pure numeric string */\n"
"        pwd = getpwnam(argv[1]);   /* Try getting UID for username */\n"
"        if (pwd == NULL) {\n"
"            perror(\"getpwnam\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""
"    if (*endptr != \\(aq\\e0\\(aq) {         /* Was not pure numeric string */\n"
"        pwd = getpwnam(argv[1]);   /* Try getting UID for username */\n"
"        if (pwd == NULL) {\n"
"            perror(\"getpwnam\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"

#. type: Plain text
#: build/C/man2/chown.2:487
#, no-wrap
msgid ""
"        uid = pwd-E<gt>pw_uid;\n"
"    }\n"
msgstr ""
"        uid = pwd-E<gt>pw_uid;\n"
"    }\n"

#. type: Plain text
#: build/C/man2/chown.2:492
#, no-wrap
msgid ""
"    if (chown(argv[2], uid, -1) == -1) {\n"
"        perror(\"chown\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (chown(argv[2], uid, -1) == -1) {\n"
"        perror(\"chown\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/chown.2:495 build/C/man2/execve.2:802 build/C/man3/getopt.3:451
#: build/C/man3/getopt.3:536
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man2/chown.2:503
msgid ""
"B<chgrp>(1), B<chown>(1), B<chmod>(2), B<flock>(2), B<path_resolution>(7), "
"B<symlink>(7)"
msgstr ""
"B<chgrp>(1), B<chown>(1), B<chmod>(2), B<flock>(2), B<path_resolution>(7), "
"B<symlink>(7)"

#. type: TH
#: build/C/man2/chroot.2:33
#, no-wrap
msgid "CHROOT"
msgstr "CHROOT"

#. type: Plain text
#: build/C/man2/chroot.2:36
msgid "chroot - change root directory"
msgstr "chroot - ルートディレクトリを変更する"

#. type: Plain text
#: build/C/man2/chroot.2:40
msgid "B<int chroot(const char *>I<path>B<);>"
msgstr "B<int chroot(const char *>I<path>B<);>"

#. type: Plain text
#: build/C/man2/chroot.2:47
msgid "B<chroot>():"
msgstr "B<chroot>():"

#. type: TP
#: build/C/man2/chroot.2:50
#, no-wrap
msgid "Since glibc 2.2.2:"
msgstr "glibc 2.2.2 以降:"

#. type: Plain text
#: build/C/man2/chroot.2:56
#, no-wrap
msgid ""
"_XOPEN_SOURCE && ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200112L)\n"
"    || /* Since glibc 2.20: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE\n"
msgstr ""
"_XOPEN_SOURCE && ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200112L)\n"
"    || /* glibc 2.20 以降: */ _DEFAULT_SOURCE\n"
"    || /* Glibc 2.19 以前: */ _BSD_SOURCE\n"

#. type: TP
#: build/C/man2/chroot.2:57
#, no-wrap
msgid "Before glibc 2.2.2: none"
msgstr "glibc 2.2.2 より前: なし"

#. type: Plain text
#: build/C/man2/chroot.2:68
msgid ""
"B<chroot>()  changes the root directory of the calling process to that "
"specified in I<path>.  This directory will be used for pathnames beginning "
"with I</>.  The root directory is inherited by all children of the calling "
"process."
msgstr ""
"B<chroot>()  は、呼び出し元プロセスのルートディレクトリを I<path> で指定され"
"たディレクトリに変更する。 このディレクトリ以下が I</> から始まるパス名として"
"使われる。 このルートディレクトリは呼び出し元のプロセスの全ての子プロセスに受"
"け継がれる。"

#. type: Plain text
#: build/C/man2/chroot.2:73
msgid ""
"Only a privileged process (Linux: one with the B<CAP_SYS_CHROOT> capability "
"in its user namespace) may call B<chroot>()."
msgstr ""
"特権プロセス (Linux では、そのプロセスのユーザー名前空間で B<CAP_SYS_CHROOT> "
"ケーパビリティを持つプロセス) のみが B<chroot>()  を呼び出すことができる。"

#. type: Plain text
#: build/C/man2/chroot.2:90
msgid ""
"This call changes an ingredient in the pathname resolution process and does "
"nothing else.  In particular, it is not intended to be used for any kind of "
"security purpose, neither to fully sandbox a process nor to restrict "
"filesystem system calls.  In the past, B<chroot>()  has been used by daemons "
"to restrict themselves prior to passing paths supplied by untrusted users to "
"system calls such as B<open>(2).  However, if a folder is moved out of the "
"chroot directory, an attacker can exploit that to get out of the chroot "
"directory as well.  The easiest way to do that is to B<chdir>(2)  to the to-"
"be-moved directory, wait for it to be moved out, then open a path "
"like ../../../etc/passwd."
msgstr ""

#.  This is how the "slightly trickier variation" works:
#.  https://github.com/QubesOS/qubes-secpack/blob/master/QSBs/qsb-014-2015.txt#L142
#. type: Plain text
#: build/C/man2/chroot.2:101
msgid ""
"A slightly trickier variation also works under some circumstances if "
"B<chdir>(2)  is not permitted.  If a daemon allows a \"chroot directory\" to "
"be specified, that usually means that if you want to prevent remote users "
"from accessing files outside the chroot directory, you must ensure that "
"folders are never moved out of it."
msgstr ""

#. type: Plain text
#: build/C/man2/chroot.2:107
msgid ""
"This call does not change the current working directory, so that after the "
"call \\(aqI<.>\\(aq can be outside the tree rooted at \\(aqI</>\\(aq.  In "
"particular, the superuser can escape from a \"chroot jail\" by doing:"
msgstr ""
"このコールは現在の作業ディレクトリ (working directory) を変更しない。 そのた"
"め、このコールの後に \\(aqI<.>\\(aq が \\(aqI</>\\(aq を 根とするツリーの外に"
"なる場合がある。 特に、スーパーユーザーは以下のようにすることで \"chroot jail"
"\" から逃げ出せてしまう。"

#. type: Plain text
#: build/C/man2/chroot.2:111
#, no-wrap
msgid "mkdir foo; chroot foo; cd ..\n"
msgstr "mkdir foo; chroot foo; cd ..\n"

#. type: Plain text
#: build/C/man2/chroot.2:116
msgid ""
"This call does not close open file descriptors, and such file descriptors "
"may allow access to files outside the chroot tree."
msgstr ""
"このコールはオープンファイルディスクリプターをクローズしないので、 このような"
"ファイルディスクリプターは chroot ツリーの外にある ファイルにアクセスできる。"

#. type: Plain text
#: build/C/man2/chroot.2:124
msgid ""
"Depending on the filesystem, other errors can be returned.  The more general "
"errors are listed below:"
msgstr ""
"ファイルシステムによっては他のエラーが返される事がある。 一般的なエラーを以下"
"に挙げる:"

#. type: Plain text
#: build/C/man2/chroot.2:160
msgid "The caller has insufficient privilege."
msgstr "呼び出し側に十分な特権がない。"

#.  SVr4 documents additional EINTR, ENOLINK and EMULTIHOP error conditions.
#.  X/OPEN does not document EIO, ENOMEM or EFAULT error conditions.
#. type: Plain text
#: build/C/man2/chroot.2:165
msgid ""
"SVr4, 4.4BSD, SUSv2 (marked LEGACY).  This function is not part of "
"POSIX.1-2001."
msgstr ""
"SVr4, 4.4BSD, SUSv2 (但し、SUSv2 では過去の名残とされている)。 この関数は "
"POSIX.1-2001 にはない。"

#. type: Plain text
#: build/C/man2/chroot.2:171
msgid ""
"A child process created via B<fork>(2)  inherits its parent's root "
"directory.  The root directory is left unchanged by B<execve>(2)."
msgstr ""
"B<fork>(2)  で作成された子プロセスは、 親プロセスのルートディレクトリを継承す"
"る。 B<execve>(2)  の場合も、ルートディレクトリは変更されない。"

#. type: Plain text
#: build/C/man2/chroot.2:177
msgid ""
"The magic symbolic link, I</proc/[pid]/root>, can be used to discover a "
"process's root directory; see B<proc>(5)  for details."
msgstr ""

#. type: Plain text
#: build/C/man2/chroot.2:181
msgid "FreeBSD has a stronger B<jail>()  system call."
msgstr "FreeBSD にはより強力な B<jail>()  システムコールがある。"

#. type: Plain text
#: build/C/man2/chroot.2:187
msgid ""
"B<chroot>(1), B<chdir>(2), B<pivot_root>(2), B<path_resolution>(7), "
"B<switch_root>(8)"
msgstr ""
"B<chroot>(1), B<chdir>(2), B<pivot_root>(2), B<path_resolution>(7), "
"B<switch_root>(8)"

#. type: TH
#: build/C/man2/close.2:36
#, no-wrap
msgid "CLOSE"
msgstr "CLOSE"

#. type: Plain text
#: build/C/man2/close.2:39
msgid "close - close a file descriptor"
msgstr "close - ファイルディスクリプターをクローズする"

#. type: Plain text
#: build/C/man2/close.2:44
#, no-wrap
msgid "B<int close(int >I<fd>B<);>\n"
msgstr "B<int close(int >I<fd>B<);>\n"

#. type: Plain text
#: build/C/man2/close.2:54
msgid ""
"B<close>()  closes a file descriptor, so that it no longer refers to any "
"file and may be reused.  Any record locks (see B<fcntl>(2))  held on the "
"file it was associated with, and owned by the process, are removed "
"(regardless of the file descriptor that was used to obtain the lock)."
msgstr ""
"B<close>()  は、ファイルディスクリプターをクローズする。 そのディスクリプター"
"は、どのファイルも参照していない状態になり、 再利用が可能になる。 そのファイ"
"ルディスクリプターに関連づけられたファイルに かけられたレコードロック "
"(B<fcntl>(2)  参照) のうち、そのプロセスが保有しているものは、 (そのファイル"
"ディスクリプターがロック取得に利用されたか どうかによらず) すべて削除される。"

#. type: Plain text
#: build/C/man2/close.2:65
msgid ""
"If I<fd> is the last file descriptor referring to the underlying open file "
"description (see B<open>(2)), the resources associated with the open file "
"description are freed; if the file descriptor was the last reference to a "
"file which has been removed using B<unlink>(2), the file is deleted."
msgstr ""
"I<fd> が、対応するオープンファイル記述 (open file description)  (B<open>(2)  "
"参照) を参照する最後のファイルディスクリプターだった場合、 オープンファイル記"
"述に関連するリソースが解放される。 そのファイルディスクリプターが、 "
"B<unlink> を使用して削除 (remove) されたファイルに対する最後の参照だった場合"
"には、 そのファイルは削除 (delete) される。"

#. type: Plain text
#: build/C/man2/close.2:71
msgid ""
"B<close>()  returns zero on success.  On error, -1 is returned, and I<errno> "
"is set appropriately."
msgstr ""
"B<close>()  は成功した場合は 0 を返す。 エラーが発生した場合は -1 を返して、 "
"I<errno> を適切に設定する。"

#. type: Plain text
#: build/C/man2/close.2:76
msgid "I<fd> isn't a valid open file descriptor."
msgstr "I<fd> が有効なオープンされたディスクリプターでない。"

#. type: TP
#: build/C/man2/close.2:76 build/C/man2/dup.2:178 build/C/man2/fcntl.2:1714
#: build/C/man2/fcntl.2:1723 build/C/man2/flock.2:122 build/C/man3/lockf.3:149
#: build/C/man2/truncate.2:132 build/C/man3/ualarm.3:84
#: build/C/man3/usleep.3:82
#, no-wrap
msgid "B<EINTR>"
msgstr "B<EINTR>"

#.  Though, it's in doubt whether this error can ever occur; see
#.  https://lwn.net/Articles/576478/ "Returning EINTR from close()"
#. type: Plain text
#: build/C/man2/close.2:84
msgid "The B<close>()  call was interrupted by a signal; see B<signal>(7)."
msgstr ""
"B<close>()  コールがシグナルにより中断 (interrupt) された。 B<signal>(7)  参"
"照。"

#. type: TP
#: build/C/man2/close.2:87 build/C/man2/fsync.2:144
#, no-wrap
msgid "B<ENOSPC>, B<EDQUOT>"
msgstr "B<ENOSPC>, B<EDQUOT>"

#. type: Plain text
#: build/C/man2/close.2:96
msgid ""
"On NFS, these errors are not normally reported against the first write which "
"exceeds the available storage space, but instead against a subsequent "
"B<write>(2), B<fsync>(2), or B<close>()."
msgstr ""

#. type: Plain text
#: build/C/man2/close.2:100
msgid ""
"See NOTES for a discussion of why B<close>()  should not be retried after an "
"error."
msgstr ""

#. type: Plain text
#: build/C/man2/close.2:111
#, fuzzy
#| msgid ""
#| "A successful close does not guarantee that the data has been successfully "
#| "saved to disk, as the kernel defers writes.  It is not common for a "
#| "filesystem to flush the buffers when the stream is closed.  If you need "
#| "to be sure that the data is physically stored, use B<fsync>(2).  (It will "
#| "depend on the disk hardware at this point.)"
msgid ""
"A successful close does not guarantee that the data has been successfully "
"saved to disk, as the kernel uses the buffer cache to defer writes.  "
"Typically, filesystems do not flush buffers when a file is closed.  If you "
"need to be sure that the data is physically stored on the underlying disk, "
"use B<fsync>(2).  (It will depend on the disk hardware at this point.)"
msgstr ""
"クローズに成功しても、データがディスクに保存されたかどうかは 保証されない "
"(カーネルが書きこみを遅延させることがあるためである)。 ストリームがクローズさ"
"れるときにバッファーをフラッシュするかどうかは、 ファイルシステムによって異な"
"る。 データが物理的に保存されることを保証する必要がある場合には、 "
"B<fsync>(2)  を使用すること (B<fsync>(3)  を行った時点で、データの保存はディ"
"スクのハードウェアに依存する 問題となる)。"

#. type: Plain text
#: build/C/man2/close.2:119
msgid ""
"The close-on-exec file descriptor flag can be used to ensure that a file "
"descriptor is automatically closed upon a successful B<execve>(2); see "
"B<fcntl>(2)  for details."
msgstr ""

#. type: SS
#: build/C/man2/close.2:119
#, no-wrap
msgid "Multithreaded processes and close()"
msgstr "マルチスレッドプロセスと close()"

#.  Date: Tue, 4 Sep 2007 13:57:35 +0200
#.  From: Fredrik Noring <noring@nocrew.org>
#.  One such race involves signals and ERESTARTSYS. If a file descriptor
#.  in use by a system call is closed and then reused by e.g. an
#.  independent open() in some unrelated thread, before the original system
#.  call has restarted after ERESTARTSYS, the original system call will
#.  later restart with the reused file descriptor. This is most likely a
#.  serious programming error.
#. type: Plain text
#: build/C/man2/close.2:134
msgid ""
"It is probably unwise to close file descriptors while they may be in use by "
"system calls in other threads in the same process.  Since a file descriptor "
"may be reused, there are some obscure race conditions that may cause "
"unintended side effects."
msgstr ""
"同じプロセス内の他のスレッドのシステムコールが使用している可能性がある間に、 "
"ファイルディスクリプターをクローズするのは、おそらく賢明ではないだろう。 ファ"
"イルディスクリプターは再利用されるかもしれないので、 あいまいな競合条件となる"
"ことがあり、意図しない副作用の原因となりうる。"

#. type: Plain text
#: build/C/man2/close.2:137
msgid ""
"Furthermore, consider the following scenario where two threads are "
"performing operations on the same file descriptor:"
msgstr ""

#. type: IP
#: build/C/man2/close.2:137
#, no-wrap
msgid "1."
msgstr "1."

#. type: Plain text
#: build/C/man2/close.2:144
msgid ""
"One thread is blocked in an I/O system call on the file descriptor.  For "
"example, it is trying to B<write>(2)  to a pipe that is already full, or "
"trying to B<read>(2)  from a stream socket which currently has no available "
"data."
msgstr ""

#. type: IP
#: build/C/man2/close.2:144
#, no-wrap
msgid "2."
msgstr "2."

#. type: Plain text
#: build/C/man2/close.2:146
msgid "Another thread closes the file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/close.2:150
msgid ""
"The behavior in this situation varies across systems.  On some systems, when "
"the file descriptor is closed, the blocking system call returns immediately "
"with an error."
msgstr ""

#.  'struct file' in kernel-speak
#. type: Plain text
#: build/C/man2/close.2:164
msgid ""
"On Linux (and possibly some other systems), the behavior is different.  the "
"blocking I/O system call holds a reference to the underlying open file "
"description, and this reference keeps the description open until the I/O "
"system call completes.  (See B<open>(2)  for a discussion of open file "
"descriptions.)  Thus, the blocking system call in the first thread may "
"successfully complete after the B<close>()  in the second thread."
msgstr ""

#. type: SS
#: build/C/man2/close.2:164
#, no-wrap
msgid "Dealing with error returns from close()"
msgstr ""

#. type: Plain text
#: build/C/man2/close.2:176
#, fuzzy
#| msgid ""
#| "Not checking the return value of B<close>()  is a common but nevertheless "
#| "serious programming error.  It is quite possible that errors on a "
#| "previous B<write>(2)  operation are first reported at the final "
#| "B<close>().  Not checking the return value when closing the file may lead "
#| "to silent loss of data.  This can especially be observed with NFS and "
#| "with disk quota.  Note that the return value should be used only for "
#| "diagnostics.  In particular B<close>()  should not be retried after an "
#| "B<EINTR> since this may cause a reused descriptor from another thread to "
#| "be closed."
msgid ""
"A careful programmer will check the return value of B<close>(), since it is "
"quite possible that errors on a previous B<write>(2)  operation are reported "
"only on the final B<close>()  that releases the open file description.  "
"Failing to check the return value when closing a file may lead to I<silent> "
"loss of data.  This can especially be observed with NFS and with disk quota."
msgstr ""
"B<close>()  の返り値のチェックはよく省略されるが、 これは深刻なプログラミング"
"エラーである。 前の B<write>(2)  処理に関するエラーが最後の B<close>()  のと"
"きになって初めて通知される場合がありうる。 ファイルクローズの際に返り値を"
"チェックしないと、 気付かないうちにデータを失ってしまうかもしれない。 これは"
"特に NFS やディスククォータを使用した場合に見られる。返り値は状態確認用にのみ"
"利用すべき点に注意すること。特に、B<EINTR> 後に B<close>() を再度行うべきでは"
"ない。なぜなら、これにより、別のスレッドが再利用したディスクリプターをクロー"
"ズしてしまう可能性があるからだ。"

#. type: Plain text
#: build/C/man2/close.2:182
msgid ""
"Note, however, that a failure return should be used only for diagnostic "
"purposes (i.e., a warning to the application that there may still be I/O "
"pending or there may have been failed I/O)  or remedial purposes (e.g., "
"writing the file once more or creating a backup)."
msgstr ""

#
#.  The file descriptor is released early in close();
#.  close() ==> __close_fd():
#. 			__put_unused_fd() ==> __clear_open_fd()
#. 			return filp_close(file, files);
#.  The errors are returned by filp_close() after the FD has been
#.  cleared for re-use.
#.  filp_close()
#. type: Plain text
#: build/C/man2/close.2:203
msgid ""
"Retrying the B<close>()  after a failure return is the wrong thing to do, "
"since this may cause a reused file descriptor from another thread to be "
"closed.  This can occur because the Linux kernel I<always> releases the file "
"descriptor early in the close operation, freeing it for reuse; the steps "
"that may return an error, such as flushing data to the filesystem or device, "
"occur only later in the close operation."
msgstr ""

#.  FreeBSD documents this explicitly. From the look of the source code
#.  SVR4, ancient SunOS, later Solaris, and AIX all do this.
#.  Issue 8
#. type: Plain text
#: build/C/man2/close.2:216
msgid ""
"Many other implementations similarly always close the file descriptor "
"(except in the case of B<EBADF>, meaning that the file descriptor was "
"invalid)  even if they subsequently report an error on return from "
"B<close>().  POSIX.1 is currently silent on this point, but there are plans "
"to mandate this behavior in the next major release of the standard."
msgstr ""

#. type: Plain text
#: build/C/man2/close.2:221
msgid ""
"A careful programmer who wants to know about I/O errors may precede "
"B<close>()  with a call to B<fsync>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/close.2:228
msgid ""
"The B<EINTR> error is a somewhat special case.  Regarding the B<EINTR> "
"error, POSIX.1-2008 says:"
msgstr ""

#. type: Plain text
#: build/C/man2/close.2:239
msgid ""
"If B<close>()  is interrupted by a signal that is to be caught, it shall "
"return -1 with I<errno> set to B<EINTR> and the state of I<fildes> is "
"unspecified."
msgstr ""

#
#.  FIXME . for later review when Issue 8 is one day released...
#.  POSIX proposes further changes for EINTR
#.  http://austingroupbugs.net/tag_view_page.php?tag_id=8
#.  http://austingroupbugs.net/view.php?id=529
#.  FIXME .
#.  Review the following glibc bug later
#.  https://sourceware.org/bugzilla/show_bug.cgi?id=14627
#. type: Plain text
#: build/C/man2/close.2:274
msgid ""
"This permits the behavior that occurs on Linux and many other "
"implementations, where, as with other errors that may be reported by "
"B<close>(), the file descriptor is guaranteed to be closed.  However, it "
"also permits another possibility: that the implementation returns an "
"B<EINTR> error and keeps the file descriptor open.  (According to its "
"documentation, HP-UX's B<close>()  does this.)  The caller must then once "
"more use B<close>()  to close the file descriptor, to avoid file descriptor "
"leaks.  This divergence in implementation behaviors provides a difficult "
"hurdle for portable applications, since on many implementations, B<close>()  "
"must not be called again after an B<EINTR> error, and on at least one, "
"B<close>()  must be called again.  There are plans to address this conundrum "
"for the next major release of the POSIX.1 standard."
msgstr ""

#. type: Plain text
#: build/C/man2/close.2:281
msgid ""
"B<fcntl>(2), B<fsync>(2), B<open>(2), B<shutdown>(2), B<unlink>(2), "
"B<fclose>(3)"
msgstr ""
"B<fcntl>(2), B<fsync>(2), B<open>(2), B<shutdown>(2), B<unlink>(2), "
"B<fclose>(3)"

#. type: TH
#: build/C/man3/confstr.3:33
#, no-wrap
msgid "CONFSTR"
msgstr "CONFSTR"

#. type: TH
#: build/C/man3/confstr.3:33 build/C/man3/daemon.3:36 build/C/man3/exec.3:41
#: build/C/man3/fpathconf.3:42 build/C/man3/get_nprocs_conf.3:26
#: build/C/man3/getcwd.3:32 build/C/man3/getlogin.3:28 build/C/man3/getopt.3:42
#: build/C/man3/getumask.3:28 build/C/man3/getusershell.3:30
#: build/C/man3/lockf.3:28 build/C/man3/sleep.3:26 build/C/man3/sysconf.3:27
#: build/C/man3/tcgetpgrp.3:25 build/C/man3/get_phys_pages.3:25
#, no-wrap
msgid "GNU"
msgstr "GNU"

#. type: Plain text
#: build/C/man3/confstr.3:36
msgid "confstr - get configuration dependent string variables"
msgstr "confstr - コンフィグレーションに依存した文字列変数の取得"

#. type: Plain text
#: build/C/man3/confstr.3:41
#, no-wrap
msgid "B<size_t confstr(int >I<name>B<, char *>I<buf>B<, size_t >I<len>B<);>\n"
msgstr "B<size_t confstr(int >I<name>B<, char *>I<buf>B<, size_t >I<len>B<);>\n"

#. type: Plain text
#: build/C/man3/confstr.3:50
msgid "B<confstr>(): _POSIX_C_SOURCE\\ E<gt>=\\ 2 || _XOPEN_SOURCE"
msgstr "B<confstr>(): _POSIX_C_SOURCE\\ E<gt>=\\ 2 || _XOPEN_SOURCE"

#. type: Plain text
#: build/C/man3/confstr.3:53
msgid ""
"B<confstr>()  gets the value of configuration-dependent string variables."
msgstr ""
"B<confstr>()  はコンフィグレーションに依存した文字列変数の値を取得する。"

#. type: Plain text
#: build/C/man3/confstr.3:58
msgid ""
"The I<name> argument is the system variable to be queried.  The following "
"variables are supported:"
msgstr ""
"引数 I<name> は、問い合わせ内容を表すシステム変数である。 以下の変数がサ"
"ポートされている。"

#. type: TP
#: build/C/man3/confstr.3:58
#, no-wrap
msgid "B<_CS_GNU_LIBC_VERSION> (GNU C library only; since glibc 2.3.2)"
msgstr "B<_CS_GNU_LIBC_VERSION> (GNU C library 限定; glibc 2.3.2 以降)"

#. type: Plain text
#: build/C/man3/confstr.3:62
msgid ""
"A string which identifies the GNU C library version on this system (e.g., "
"\"glibc 2.3.4\")."
msgstr ""
"そのシステムの GNU C ライブラリのバージョンを示す文字列 (例えば \"glibc "
"2.3.4\")。"

#. type: TP
#: build/C/man3/confstr.3:62
#, no-wrap
msgid "B<_CS_GNU_LIBPTHREAD_VERSION> (GNU C library only; since glibc 2.3.2)"
msgstr "B<_CS_GNU_LIBPTHREAD_VERSION> (GNU C library 限定; glibc 2.3.2 以降)"

#. type: Plain text
#: build/C/man3/confstr.3:66
msgid ""
"A string which identifies the POSIX implementation supplied by this C "
"library (e.g., \"NPTL 2.3.4\" or \"linuxthreads-0.10\")."
msgstr ""
"その C ライブラリが提供している POSIX 実装を示す文字列 (例えば \"NPTL "
"2.3.4\" や \"linuxthreads-0.10\")。"

#. type: TP
#: build/C/man3/confstr.3:66
#, no-wrap
msgid "B<_CS_PATH>"
msgstr "B<_CS_PATH>"

#. type: Plain text
#: build/C/man3/confstr.3:72
msgid ""
"A value for the B<PATH> variable which indicates where all the POSIX.2 "
"standard utilities can be found."
msgstr "すべての POSIX.2 標準ユーティリティが見つかるような B<PATH> の値。"

#. type: Plain text
#: build/C/man3/confstr.3:88
msgid ""
"If I<buf> is not NULL and I<len> is not zero, B<confstr>()  copies the value "
"of the string to I<buf> truncated to I<len - 1> bytes if necessary, with a "
"null byte (\\(aq\\e0\\(aq) as terminator.  This can be detected by comparing "
"the return value of B<confstr>()  against I<len>."
msgstr ""
"I<buf> が NULL でなく、かつ I<len> が 0 でなければ B<confstr>() は取得\n"
"した文字列の内容を I<buf> にコピーする。必要ならば長さが I<len - 1> \n"
"バイトに切り捨てられて、NULL バイト (\\(aq\\e0\\(aq) で終端される。\n"
"末尾が切り捨てられたかどうかを判定するには、 B<confstr>() の返り値を\n"
"I<len> と比較すればよい。"

#. type: Plain text
#: build/C/man3/confstr.3:96
msgid ""
"If I<len> is zero and I<buf> is NULL, B<confstr>()  just returns the value "
"as defined below."
msgstr ""
"I<len> が 0 で I<buf> が NULL ならば、 B<confstr>()  は以下で定義された値 (訳"
"注: 切り捨てる前の、取得した文字列の長さ) を返す。"

#. type: Plain text
#: build/C/man3/confstr.3:108
msgid ""
"If I<name> is a valid configuration variable, B<confstr>()  returns the "
"number of bytes (including the terminating null byte)  that would be "
"required to hold the entire value of that variable.  This value may be "
"greater than I<len>, which means that the value in I<buf> is truncated."
msgstr ""
"I<name> が有効なコンフィギュレーション変数の場合、 B<confstr>()  はその変数の"
"値全体を保持するのに必要であったバイト数を返す (文字列終端のヌルバイトも含"
"む)。この値は I<len> より大きいこともある。この場合には、 I<buf> に格納された"
"値の末尾が切り詰められたことを意味する。"

#. type: Plain text
#: build/C/man3/confstr.3:123
msgid ""
"If I<name> is a valid configuration variable, but that variable does not "
"have a value, then B<confstr>()  returns 0.  If I<name> does not correspond "
"to a valid configuration variable, B<confstr>()  returns 0, and I<errno> is "
"set to B<EINVAL>."
msgstr ""
"I<name> が有効なコンフィギュレーション変数だが、 変数が値を持っていない場"
"合、 B<confstr>()  は 0 を返す。 I<name> が有効なコンフィグレーション変数に対"
"応していなければ、 B<confstr>()  は 0 を返し、 I<errno> に B<EINVAL> を設定す"
"る。"

#. type: Plain text
#: build/C/man3/confstr.3:129
msgid "The value of I<name> is invalid."
msgstr "I<name> の値が不正である。"

#. type: SH
#: build/C/man3/confstr.3:129 build/C/man3/crypt.3:170 build/C/man3/daemon.3:99
#: build/C/man3/des_crypt.3:142 build/C/man3/encrypt.3:133
#: build/C/man3/euidaccess.3:73 build/C/man3/exec.3:194
#: build/C/man3/fexecve.3:106 build/C/man3/fpathconf.3:256
#: build/C/man3/get_nprocs_conf.3:48 build/C/man3/getcwd.3:210
#: build/C/man3/getdtablesize.3:70 build/C/man3/gethostid.3:97
#: build/C/man3/getlogin.3:147 build/C/man3/getopt.3:330
#: build/C/man3/getusershell.3:97 build/C/man3/lockf.3:161
#: build/C/man3/sleep.3:45 build/C/man3/swab.3:72 build/C/man3/sysconf.3:371
#: build/C/man3/tcgetpgrp.3:109 build/C/man3/ualarm.3:92
#: build/C/man3/usleep.3:90
#, no-wrap
msgid "ATTRIBUTES"
msgstr "属性"

#. type: Plain text
#: build/C/man3/confstr.3:132 build/C/man3/crypt.3:173
#: build/C/man3/daemon.3:102 build/C/man3/des_crypt.3:145
#: build/C/man3/encrypt.3:136 build/C/man3/euidaccess.3:76
#: build/C/man3/exec.3:197 build/C/man3/fexecve.3:109
#: build/C/man3/fpathconf.3:259 build/C/man3/get_nprocs_conf.3:51
#: build/C/man3/getcwd.3:213 build/C/man3/getdtablesize.3:73
#: build/C/man3/gethostid.3:100 build/C/man3/getlogin.3:150
#: build/C/man3/getopt.3:333 build/C/man3/getusershell.3:100
#: build/C/man3/lockf.3:164 build/C/man3/sleep.3:48 build/C/man3/swab.3:75
#: build/C/man3/sysconf.3:374 build/C/man3/tcgetpgrp.3:112
#: build/C/man3/ualarm.3:95 build/C/man3/usleep.3:93
msgid ""
"For an explanation of the terms used in this section, see B<attributes>(7)."
msgstr "この節で使用されている用語の説明については、 B<attributes>(7) を参照。"

#. type: tbl table
#: build/C/man3/confstr.3:136 build/C/man3/crypt.3:177
#: build/C/man3/daemon.3:106 build/C/man3/des_crypt.3:149
#: build/C/man3/encrypt.3:140 build/C/man3/euidaccess.3:80
#: build/C/man3/exec.3:201 build/C/man3/fexecve.3:113
#: build/C/man3/fpathconf.3:263 build/C/man3/get_nprocs_conf.3:55
#: build/C/man3/getcwd.3:217 build/C/man3/getdtablesize.3:77
#: build/C/man3/gethostid.3:104 build/C/man3/getlogin.3:154
#: build/C/man3/getopt.3:337 build/C/man3/getusershell.3:104
#: build/C/man3/lockf.3:168 build/C/man3/sleep.3:52 build/C/man3/swab.3:79
#: build/C/man3/sysconf.3:378 build/C/man3/tcgetpgrp.3:116
#: build/C/man3/ualarm.3:99 build/C/man3/usleep.3:97
#, no-wrap
msgid "Interface"
msgstr "インターフェース"

#. type: tbl table
#: build/C/man3/confstr.3:136 build/C/man3/crypt.3:177
#: build/C/man3/daemon.3:106 build/C/man3/des_crypt.3:149
#: build/C/man3/encrypt.3:140 build/C/man3/euidaccess.3:80
#: build/C/man3/exec.3:201 build/C/man3/fexecve.3:113
#: build/C/man3/fpathconf.3:263 build/C/man3/get_nprocs_conf.3:55
#: build/C/man3/getcwd.3:217 build/C/man3/getdtablesize.3:77
#: build/C/man3/gethostid.3:104 build/C/man3/getlogin.3:154
#: build/C/man3/getopt.3:337 build/C/man3/getusershell.3:104
#: build/C/man3/lockf.3:168 build/C/man3/sleep.3:52 build/C/man3/swab.3:79
#: build/C/man3/sysconf.3:378 build/C/man3/tcgetpgrp.3:116
#: build/C/man3/ualarm.3:99 build/C/man3/usleep.3:97
#, no-wrap
msgid "Attribute"
msgstr "属性"

#. type: tbl table
#: build/C/man3/confstr.3:136 build/C/man3/crypt.3:177
#: build/C/man3/daemon.3:106 build/C/man3/des_crypt.3:149
#: build/C/man3/encrypt.3:140 build/C/man3/euidaccess.3:80
#: build/C/man3/exec.3:201 build/C/man3/fexecve.3:113
#: build/C/man3/fpathconf.3:263 build/C/man3/get_nprocs_conf.3:55
#: build/C/man3/getcwd.3:217 build/C/man3/getdtablesize.3:77
#: build/C/man3/gethostid.3:104 build/C/man3/getlogin.3:154
#: build/C/man3/getopt.3:337 build/C/man3/getusershell.3:104
#: build/C/man3/lockf.3:168 build/C/man3/sleep.3:52 build/C/man3/swab.3:79
#: build/C/man3/sysconf.3:378 build/C/man3/tcgetpgrp.3:116
#: build/C/man3/ualarm.3:99 build/C/man3/usleep.3:97
#, no-wrap
msgid "Value"
msgstr "値"

#. type: tbl table
#: build/C/man3/confstr.3:139
#, no-wrap
msgid "B<confstr>()"
msgstr "B<confstr>()"

#. type: tbl table
#: build/C/man3/confstr.3:139 build/C/man3/crypt.3:180 build/C/man3/crypt.3:183
#: build/C/man3/daemon.3:109 build/C/man3/des_crypt.3:154
#: build/C/man3/encrypt.3:144 build/C/man3/encrypt.3:148
#: build/C/man3/euidaccess.3:84 build/C/man3/exec.3:206 build/C/man3/exec.3:211
#: build/C/man3/fexecve.3:116 build/C/man3/fpathconf.3:267
#: build/C/man3/get_nprocs_conf.3:60 build/C/man3/getcwd.3:221
#: build/C/man3/getcwd.3:224 build/C/man3/getdtablesize.3:80
#: build/C/man3/gethostid.3:107 build/C/man3/gethostid.3:110
#: build/C/man3/getlogin.3:157 build/C/man3/getlogin.3:164
#: build/C/man3/getlogin.3:171 build/C/man3/getopt.3:342
#: build/C/man3/getusershell.3:110 build/C/man3/lockf.3:171
#: build/C/man3/sleep.3:55 build/C/man3/swab.3:82 build/C/man3/sysconf.3:381
#: build/C/man3/tcgetpgrp.3:120 build/C/man3/ualarm.3:102
#: build/C/man3/usleep.3:100
#, no-wrap
msgid "Thread safety"
msgstr "Thread safety"

#. type: tbl table
#: build/C/man3/confstr.3:139 build/C/man3/crypt.3:183
#: build/C/man3/daemon.3:109 build/C/man3/des_crypt.3:154
#: build/C/man3/encrypt.3:148 build/C/man3/euidaccess.3:84
#: build/C/man3/exec.3:206 build/C/man3/fexecve.3:116
#: build/C/man3/fpathconf.3:267 build/C/man3/get_nprocs_conf.3:60
#: build/C/man3/getcwd.3:221 build/C/man3/getdtablesize.3:80
#: build/C/man3/lockf.3:171 build/C/man3/swab.3:82 build/C/man3/tcgetpgrp.3:120
#: build/C/man3/ualarm.3:102 build/C/man3/usleep.3:100
#, no-wrap
msgid "MT-Safe"
msgstr "MT-Safe"

#. type: Plain text
#: build/C/man3/confstr.3:143 build/C/man3/exec.3:215
#: build/C/man3/fpathconf.3:271 build/C/man2/pread.2:125
#: build/C/man3/sleep.3:60 build/C/man3/sysconf.3:385
#: build/C/man3/tcgetpgrp.3:124
msgid "POSIX.1-2001, POSIX.1-2008."
msgstr "POSIX.1-2001, POSIX.1-2008."

#. type: Plain text
#: build/C/man3/confstr.3:146
msgid ""
"The following code fragment determines the path where to find the POSIX.2 "
"system utilities:"
msgstr ""
"次の部分的なコードは、 POSIX.2 システムのユーティリティがあるパス を取得する"
"ものである。"

#. type: Plain text
#: build/C/man3/confstr.3:151
#, no-wrap
msgid ""
"char *pathbuf;\n"
"size_t n;\n"
msgstr ""
"char *pathbuf;\n"
"size_t n;\n"

#. type: Plain text
#: build/C/man3/confstr.3:157
#, no-wrap
msgid ""
"n = confstr(_CS_PATH, NULL, (size_t) 0);\n"
"pathbuf = malloc(n);\n"
"if (pathbuf == NULL)\n"
"    abort();\n"
"confstr(_CS_PATH, pathbuf, n);\n"
msgstr ""
"n = confstr(_CS_PATH, NULL, (size_t) 0);\n"
"pathbuf = malloc(n);\n"
"if (pathbuf == NULL)\n"
"    abort();\n"
"confstr(_CS_PATH, pathbuf, n);\n"

#. type: Plain text
#: build/C/man3/confstr.3:167
msgid ""
"B<getconf>(1), B<sh>(1), B<exec>(3), B<fpathconf>(3), B<pathconf>(3), "
"B<sysconf>(3), B<system>(3)"
msgstr ""
"B<getconf>(1), B<sh>(1), B<exec>(3), B<fpathconf>(3), B<pathconf>(3), "
"B<sysconf>(3), B<system>(3)"

#. type: TH
#: build/C/man3/crypt.3:36
#, no-wrap
msgid "CRYPT"
msgstr "CRYPT"

#. type: TH
#: build/C/man3/crypt.3:36 build/C/man3/getcwd.3:32
#, no-wrap
msgid "2018-04-30"
msgstr "2018-04-30"

#. type: Plain text
#: build/C/man3/crypt.3:39
msgid "crypt, crypt_r - password and data encryption"
msgstr "crypt, crypt_r - パスワードとデータの暗号化"

#. type: Plain text
#: build/C/man3/crypt.3:43 build/C/man3/encrypt.3:37 build/C/man3/swab.3:38
#, no-wrap
msgid ""
"B<#define _XOPEN_SOURCE>       /* See feature_test_macros(7) */\n"
"B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""
"B<#define _XOPEN_SOURCE>       /* feature_test_macros(7) 参照 */\n"
"B<#include E<lt>unistd.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/crypt.3:45
#, no-wrap
msgid "B<char *crypt(const char *>I<key>B<, const char *>I<salt>B<);>\n"
msgstr "B<char *crypt(const char *>I<key>B<, const char *>I<salt>B<);>\n"

#. type: Plain text
#: build/C/man3/crypt.3:48 build/C/man3/encrypt.3:47
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>crypt.hE<gt>>\n"
msgstr ""
" B<#define _GNU_SOURCE>         /* feature_test_macros(7) 参照 */\n"
"B<#include E<lt>crypt.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/crypt.3:51
#, no-wrap
msgid ""
"B<char *crypt_r(const char *>I<key>B<, const char *>I<salt>B<,>\n"
"B<              struct crypt_data *>I<data>B<);>\n"
msgstr ""
"B<char *crypt_r(const char *>I<key>B<, const char *>I<salt>B<,>\n"
"B<              struct crypt_data *>I<data>B<);>\n"

#. type: Plain text
#: build/C/man3/crypt.3:54
msgid "Link with I<-lcrypt>."
msgstr "I<-lcrypt> でリンクする。"

#. type: Plain text
#: build/C/man3/crypt.3:60
msgid ""
"B<crypt>()  is the password encryption function.  It is based on the Data "
"Encryption Standard algorithm with variations intended (among other things) "
"to discourage use of hardware implementations of a key search."
msgstr ""
"B<crypt>()  はパスワード暗号化関数である。 鍵探索のハードウェアによる実装を妨"
"げるように(その他にもいろいろ)  変更した Data Encryption Standard アルゴリズ"
"ムを元にしている。"

#. type: Plain text
#: build/C/man3/crypt.3:63
msgid "I<key> is a user's typed password."
msgstr "I<key> はユーザーが入力するパスワードである。"

#. type: Plain text
#: build/C/man3/crypt.3:69
msgid ""
"I<salt> is a two-character string chosen from the set [B<a-zA-Z0-9./>].  "
"This string is used to perturb the algorithm in one of 4096 different ways."
msgstr ""
"I<salt> は集合 [B<a-zA-Z0-9./>] から選ばれた 2 文字の文字列である。 この文字"
"列はアルゴリズムの出力を 4096 通りにかき乱すのに使われる。"

#. type: Plain text
#: build/C/man3/crypt.3:80
msgid ""
"By taking the lowest 7 bits of each of the first eight characters of the "
"I<key>, a 56-bit key is obtained.  This 56-bit key is used to encrypt "
"repeatedly a constant string (usually a string consisting of all zeros).  "
"The returned value points to the encrypted password, a series of 13 "
"printable ASCII characters (the first two characters represent the salt "
"itself).  The return value points to static data whose content is "
"overwritten by each call."
msgstr ""
"I<key> の最初の 8 文字の各文字から下位 7 ビットをとって 56 ビットの鍵が得られ"
"る。 この 56 ビットの鍵は特定の文字列(ふつうはすべて 0 の文字列)  を繰り返し"
"暗号化するのに用いられる。 返り値は暗号化されたパスワードへのポインターで、"
"13 の印字可能な ASCII 文字 からなる(最初の 2 文字は salt そのもの)。 返り値"
"は、関数呼出しのたびに上書きされる静的なデータへのポインターである。"

#. type: Plain text
#: build/C/man3/crypt.3:82
msgid "Warning: the key space consists of"
msgstr "警告: 鍵空間は"

#. type: Plain text
#: build/C/man3/crypt.3:97
msgid ""
"equal 7.2e16 possible values.  Exhaustive searches of this key space are "
"possible using massively parallel computers.  Software, such as B<crack>(1), "
"is available which will search the portion of this key space that is "
"generally used by humans for passwords.  Hence, password selection should, "
"at minimum, avoid common words and names.  The use of a B<passwd>(1)  "
"program that checks for crackable passwords during the selection process is "
"recommended."
msgstr ""
"= 7.2e16 の可能な値から成る。 この鍵空間の全探索は強力な並列計算機を使えば可"
"能である。また B<crack>(1)  のようなソフトウェアはこの鍵空間の中で、多くの人"
"にパスワードとして 使われるような鍵についての全探索が可能である。 それゆえ、"
"パスワードを選択するときには、すくなくとも、 一般的に使われる単語と名前は避け"
"るべきである。 B<passwd>(1)  を使う時にはクラックされうるパスワードについての"
"検査をすることが 推奨される。"

#. type: Plain text
#: build/C/man3/crypt.3:106
msgid ""
"The DES algorithm itself has a few quirks which make the use of the "
"B<crypt>()  interface a very poor choice for anything other than password "
"authentication.  If you are planning on using the B<crypt>()  interface for "
"a cryptography project, don't do it: get a good book on encryption and one "
"of the widely available DES libraries."
msgstr ""
"DES アルゴリズムにはいくつかの癖があり、それによってパスワード認証以外に "
"B<crypt>()  を使うのはたいへんよくない選択となっている。もし B<crypt>()  を暗"
"号プロジェクトに使おうという案をもっているならば、それはやめたほうが よい。暗"
"号化についてのよい本と誰でも入手できる DES ライブラリのひとつを 手にいれるべ"
"きだ。"

#. type: Plain text
#: build/C/man3/crypt.3:118
msgid ""
"B<crypt_r>()  is a reentrant version of B<crypt>().  The structure pointed "
"to by I<data> is used to store result data and bookkeeping information.  "
"Other than allocating it, the only thing that the caller should do with this "
"structure is to set I<data-E<gt>initialized> to zero before the first call "
"to B<crypt_r>()."
msgstr ""
"B<crypt_r>()  は B<crypt>()  の再入可能版である。 I<data> で示される構造体は"
"結果データの保存と情報の管理に使われる。 この構造体に対して(メモリーを割り当"
"てること以外に)呼び出し元がするべき唯一の ことは、 B<crypt_r>()  の初回の呼び"
"出しの前に I<data-E<gt>initialized> をゼロにすることだけである。"

#. type: Plain text
#: build/C/man3/crypt.3:121
msgid ""
"On success, a pointer to the encrypted password is returned.  On error, NULL "
"is returned."
msgstr ""
"成功の場合には、暗号化されたパスワードへのポインターが返される。 エラーの場合"
"には NULL が返される。"

#. type: Plain text
#: build/C/man3/crypt.3:126
msgid "I<salt> has the wrong format."
msgstr "I<salt> が間違ったフォーマットである。"

#. type: TP
#: build/C/man3/crypt.3:126 build/C/man3/encrypt.3:118
#: build/C/man3/fexecve.3:96 build/C/man2/fork.2:268
#: build/C/man2/set_thread_area.2:153 build/C/man3/get_phys_pages.3:52
#, no-wrap
msgid "B<ENOSYS>"
msgstr "B<ENOSYS>"

#.  This level of detail is not necessary in this man page. . .
#.  .PP
#.  When encrypting a plain text P using DES with the key K results in the
#.  encrypted text C, then the complementary plain text P' being encrypted
#.  using the complementary key K' will result in the complementary encrypted
#.  text C'.
#.  .PP
#.  Weak keys are keys which stay invariant under the DES key transformation.
#.  The four known weak keys 0101010101010101, fefefefefefefefe,
#.  1f1f1f1f0e0e0e0e and e0e0e0e0f1f1f1f1 must be avoided.
#.  .PP
#.  There are six known half weak key pairs, which keys lead to the same
#.  encrypted data.  Keys which are part of such key clusters should be
#.  avoided.
#.  Sorry, I could not find out what they are.
#. "
#.  .PP
#.  Heavily redundant data causes trouble with DES encryption, when used in the
#.  .I codebook
#.  mode that
#.  .BR crypt ()
#.  implements.  The
#.  .BR crypt ()
#.  interface should be used only for its intended purpose of password
#.  verification, and should not be used as part of a data encryption tool.
#.  .PP
#.  The first and last three output bits of the fourth S-box can be
#.  represented as function of their input bits.  Empiric studies have
#.  shown that S-boxes partially compute the same output for similar input.
#.  It is suspected that this may contain a back door which could allow the
#.  NSA to decrypt DES encrypted data.
#.  .PP
#.  Making encrypted data computed using crypt() publicly available has
#.  to be considered insecure for the given reasons.
#. type: Plain text
#: build/C/man3/crypt.3:165
msgid ""
"The B<crypt>()  function was not implemented, probably because of U.S.A. "
"export restrictions."
msgstr "B<crypt>()  関数が実装されていない。多分アメリカの輸出規制のために。"

#. type: Plain text
#: build/C/man3/crypt.3:170
msgid ""
"I</proc/sys/crypto/fips_enabled> has a nonzero value, and an attempt was "
"made to use a weak encryption type, such as DES."
msgstr ""
"I</proc/sys/crypto/fips_enabled> が 0 でない値で、 DES などの弱い暗号タイプを"
"利用しようとした。"

#. type: tbl table
#: build/C/man3/crypt.3:180
#, no-wrap
msgid "B<crypt>()"
msgstr "B<crypt>()"

#. type: tbl table
#: build/C/man3/crypt.3:180 build/C/man3/encrypt.3:144
#, no-wrap
msgid "MT-Unsafe race:crypt"
msgstr "MT-Unsafe race:crypt"

#. type: tbl table
#: build/C/man3/crypt.3:183
#, no-wrap
msgid "B<crypt_r>()"
msgstr "B<crypt_r>()"

#. type: Plain text
#: build/C/man3/crypt.3:190
msgid ""
"B<crypt>(): POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD.  B<crypt_r>()  is a "
"GNU extension."
msgstr ""
"B<crypt>(): POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD.  B<crypt_r>()  は GNU "
"拡張である。"

#. type: SS
#: build/C/man3/crypt.3:191 build/C/man3/encrypt.3:161
#, no-wrap
msgid "Availability in glibc"
msgstr ""

#. type: Plain text
#: build/C/man3/crypt.3:216
msgid ""
"The B<crypt>(), B<encrypt>(3), and B<setkey>(3)  functions are part of the "
"POSIX.1-2008 XSI Options Group for Encryption and are optional.  If the "
"interfaces are not available, then the symbolic constant B<_XOPEN_CRYPT> is "
"either not defined, or it is defined to -1 and availability can be checked "
"at run time with B<sysconf>(3).  This may be the case if the downstream "
"distribution has switched from glibc crypt to I<libxcrypt>.  When "
"recompiling applications in such distributions, the programmer must detect "
"if B<_XOPEN_CRYPT> is not available and include I<E<lt>crypt.hE<gt>> for the "
"function prototypes; otherwise I<libxcrypt> is an ABI-compatible drop-in "
"replacement."
msgstr ""

#. type: SS
#: build/C/man3/crypt.3:216 build/C/man3/encrypt.3:164
#, no-wrap
msgid "Features in glibc"
msgstr ""

#. type: Plain text
#: build/C/man3/crypt.3:219
msgid ""
"The glibc version of this function supports additional encryption algorithms."
msgstr "この関数の glibc 版は追加の暗号化アルゴリズムに対応している。"

#. type: Plain text
#: build/C/man3/crypt.3:225
#, fuzzy
#| msgid ""
#| "If I<salt> is a character string starting with the characters \"$I<id>$\" "
#| "followed by a string terminated by \"$\":"
msgid ""
"If I<salt> is a character string starting with the characters \"$I<id>$\" "
"followed by a string optionally terminated by \"$\", then the result has the "
"form:"
msgstr ""
"もし I<salt> の文字列が \"$I<id>$\" で始まっていて、\"$\" で終わっている文字"
"列が 続いている場合:"

#. type: Plain text
#: build/C/man3/crypt.3:228
msgid "$I<id>$I<salt>$I<encrypted>"
msgstr "$I<id>$I<salt>$I<encrypted>"

#. type: Plain text
#: build/C/man3/crypt.3:236
msgid ""
"I<id> identifies the encryption method used instead of DES and this then "
"determines how the rest of the password string is interpreted.  The "
"following values of I<id> are supported:"
msgstr "DES を使う代わりに、 I<id> で使用する暗号化手法を識別し、これがパスワード文字列の残りの部分を解釈する 方法を決定する。 I<id> の値として、以下の値に対応している:"

#. type: tbl table
#: build/C/man3/crypt.3:239
#, no-wrap
msgid "ID  | Method"
msgstr "ID  | Method"

#. type: tbl table
#: build/C/man3/crypt.3:240 build/C/man2/syscall.2:200
#: build/C/man2/syscall.2:331
#, no-wrap
msgid "_"
msgstr "_"

#. type: tbl table
#: build/C/man3/crypt.3:241
#, no-wrap
msgid "1   | MD5"
msgstr "1   | MD5"

#. type: tbl table
#: build/C/man3/crypt.3:242
#, no-wrap
msgid "2a  | Blowfish (not in mainline glibc; added in some"
msgstr "2a  | Blowfish (本流の glibc には入っていない;"

#. type: tbl table
#: build/C/man3/crypt.3:243
#, no-wrap
msgid "    | Linux distributions)"
msgstr "    | いくつかの Linux ディストリビューションで追加されている)"

#.  openSUSE has Blowfish, but AFAICS, this option is not supported
#.  natively by glibc -- mtk, Jul 08
#.  md5 | Sun MD5
#.  glibc doesn't appear to natively support Sun MD5; I don't know
#.  if any distros add the support.
#. type: tbl table
#: build/C/man3/crypt.3:250
#, no-wrap
msgid "5   | SHA-256 (since glibc 2.7)"
msgstr "5   | SHA-256 (glibc 2.7 以降)"

#. type: tbl table
#: build/C/man3/crypt.3:251
#, no-wrap
msgid "6   | SHA-512 (since glibc 2.7)"
msgstr "6   | SHA-512 (glibc 2.7 以降)"

#. type: Plain text
#: build/C/man3/crypt.3:258
msgid ""
"Thus, $5$I<salt>$I<encrypted> and $6$I<salt>$I<encrypted> contain the "
"password encrypted with, respectively, functions based on SHA-256 and "
"SHA-512."
msgstr ""

#. type: Plain text
#: build/C/man3/crypt.3:264
#, fuzzy
#| msgid ""
#| "\"I<salt>\" stands for the up to 16 characters following \"$I<id>$\" in "
#| "the salt.  The encrypted part of the password string is the actual "
#| "computed password.  The size of this string is fixed:"
msgid ""
"\"I<salt>\" stands for the up to 16 characters following \"$I<id>$\" in the "
"salt.  The \"I<encrypted>\" part of the password string is the actual "
"computed password.  The size of this string is fixed:"
msgstr ""
"\"I<salt>\" は salt における \"$I<id>$\" に引き続く 16 文字以下の 文字列であ"
"る。 パスワード文字列の暗号化部分は実際に計算されたパスワードである。 この文"
"字列のサイズは固定である:"

#. type: tbl table
#: build/C/man3/crypt.3:266
#, no-wrap
msgid "MD5     | 22 characters"
msgstr "MD5     | 22 characters"

#. type: tbl table
#: build/C/man3/crypt.3:267
#, no-wrap
msgid "SHA-256 | 43 characters"
msgstr "SHA-256 | 43 characters"

#. type: tbl table
#: build/C/man3/crypt.3:268
#, no-wrap
msgid "SHA-512 | 86 characters"
msgstr "SHA-512 | 86 characters"

#. type: Plain text
#: build/C/man3/crypt.3:277
msgid ""
"The characters in \"I<salt>\" and \"I<encrypted>\" are drawn from the set "
"[B<a-zA-Z0-9./>].  In the MD5 and SHA implementations the entire I<key> is "
"significant (instead of only the first 8 bytes in DES)."
msgstr ""
"\"I<salt>\" と \"I<encrypted>\" の文字は [B<a-zA-Z0-9./>] の集合から 選ばれ"
"る。 MD5 と SHA の実装では、 I<key> 全体が意味がある (DES の場合には最初の 8 "
"文字だけに意味がある)。"

#.  glibc commit 9425cb9eea6a62fc21d99aafe8a60f752b934b05
#. type: Plain text
#: build/C/man3/crypt.3:285
msgid ""
"Since glibc 2.7, the SHA-256 and SHA-512 implementations support a user-"
"supplied number of hashing rounds, defaulting to 5000.  If the \"$I<id>$\" "
"characters in the salt are followed by \"rounds=I<xxx>$\", where I<xxx> is "
"an integer, then the result has the form"
msgstr ""

#. type: Plain text
#: build/C/man3/crypt.3:288
msgid "$I<id>$I<rounds=yyy>$I<salt>$I<encrypted>"
msgstr "$I<id>$I<rounds=yyy>$I<salt>$I<encrypted>"

#. type: Plain text
#: build/C/man3/crypt.3:300
msgid ""
"where I<yyy> is the number of hashing rounds actually used.  The number of "
"rounds actually used is 1000 if I<xxx> is less than 1000, 999999999 if "
"I<xxx> is greater than 999999999, and is equal to I<xxx> otherwise."
msgstr ""

#. type: Plain text
#: build/C/man3/crypt.3:306
msgid "B<login>(1), B<passwd>(1), B<encrypt>(3), B<getpass>(3), B<passwd>(5)"
msgstr "B<login>(1), B<passwd>(1), B<encrypt>(3), B<getpass>(3), B<passwd>(5)"

#. type: TH
#: build/C/man3/daemon.3:36
#, no-wrap
msgid "DAEMON"
msgstr "DAEMON"

#. type: TH
#: build/C/man3/daemon.3:36
#, no-wrap
msgid "2017-11-26"
msgstr "2017-11-26"

#. type: Plain text
#: build/C/man3/daemon.3:39
msgid "daemon - run in the background"
msgstr "daemon - バックグラウンドで動作させる"

#. type: Plain text
#: build/C/man3/daemon.3:43
msgid "B<int daemon(int >I<nochdir>B<, int >I<noclose>B<);>"
msgstr "B<int daemon(int >I<nochdir>B<, int >I<noclose>B<);>"

#. type: Plain text
#: build/C/man3/daemon.3:50
msgid "B<daemon>():"
msgstr "B<daemon>():"

#. 		commit 266865c0e7b79d4196e2cc393693463f03c90bd8
#. type: Plain text
#: build/C/man3/daemon.3:58 build/C/man2/getdomainname.2:55
#: build/C/man3/gethostid.3:59 build/C/man2/gethostname.2:66
#: build/C/man3/getusershell.3:61 build/C/man2/vhangup.2:51
#, no-wrap
msgid ""
"    Since glibc 2.21:\n"
"        _DEFAULT_SOURCE\n"
"    In glibc 2.19 and 2.20:\n"
"        _DEFAULT_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE\\ E<lt>\\ 500)\n"
"    Up to and including glibc 2.19:\n"
"        _BSD_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE\\ E<lt>\\ 500)\n"
msgstr ""
"    glibc 2.21 以降:\n"
"        _DEFAULT_SOURCE\n"
"    glibc 2.19 と 2.20:\n"
"        _DEFAULT_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE\\ E<lt>\\ 500)\n"
"    glibc 2.19 以前:\n"
"        _BSD_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE\\ E<lt>\\ 500)\n"

#. type: Plain text
#: build/C/man3/daemon.3:64
msgid ""
"The B<daemon>()  function is for programs wishing to detach themselves from "
"the controlling terminal and run in the background as system daemons."
msgstr ""
"B<daemon>()  は、制御端末から分離させてシステムデーモンとして動作させたい プ"
"ログラムのための関数である。"

#. type: Plain text
#: build/C/man3/daemon.3:72
msgid ""
"If I<nochdir> is zero, B<daemon>()  changes the process's current working "
"directory to the root directory (\"/\"); otherwise, the current working "
"directory is left unchanged."
msgstr ""
"I<nochdir> が 0 の場合、 B<daemon>()  はプロセスの現在の作業ディレクトリ "
"(current working directory)  をルートディレクトリ (\"/\") に変更する。 それ以"
"外の場合、現在の作業ディレクトリは変更されない。"

#. type: Plain text
#: build/C/man3/daemon.3:81
msgid ""
"If I<noclose> is zero, B<daemon>()  redirects standard input, standard "
"output and standard error to I</dev/null>; otherwise, no changes are made to "
"these file descriptors."
msgstr ""
"I<noclose> が 0 の場合、 B<daemon>()  は標準入力・標準出力・標準エラーを I</"
"dev/null> にリダイレクトする。 それ以外の場合、これらのファイルディスクリプ"
"ターは変更されない。"

#.  not .IR in order not to underline _
#. type: Plain text
#: build/C/man3/daemon.3:99
msgid ""
"(This function forks, and if the B<fork>(2)  succeeds, the parent calls "
"B<_exit>(2), so that further errors are seen by the child only.)  On success "
"B<daemon>()  returns zero.  If an error occurs, B<daemon>()  returns -1 and "
"sets I<errno> to any of the errors specified for the B<fork>(2)  and "
"B<setsid>(2)."
msgstr ""
"(この関数が fork して B<fork>(2)  が成功すると、親プロセスでは B<_exit>(2)  "
"を呼び出すので、これ以降のエラーは子プロセスからしか見れない)。 成功した場"
"合、 B<daemon>()  は 0 を返す。 エラーが起こった場合、 B<daemon>()  は -1 を"
"返す。 さらに、 I<errno> に B<fork>(2)  と B<setsid>(2)  に関して規定されたエ"
"ラーを設定する。"

#. type: tbl table
#: build/C/man3/daemon.3:109
#, no-wrap
msgid "B<daemon>()"
msgstr "B<daemon>()"

#. type: Plain text
#: build/C/man3/daemon.3:117
msgid ""
"Not in POSIX.1.  A similar function appears on the BSDs.  The B<daemon>()  "
"function first appeared in 4.4BSD."
msgstr ""
"POSIX.1 にはない。 同様の関数が BSD には見られる。 B<daemon>()  関数は "
"4.4BSD で始めて登場した。"

#. type: Plain text
#: build/C/man3/daemon.3:125
msgid ""
"The glibc implementation can also return -1 when I</dev/null> exists but is "
"not a character device with the expected major and minor numbers.  In this "
"case, I<errno> need not be set."
msgstr ""
"The glibc implementation can also return -1 when I</dev/null> exists but is "
"not a character device with the expected major and minor numbers.  In this "
"case, I<errno> need not be set."

#.  FIXME . https://sourceware.org/bugzilla/show_bug.cgi?id=19144
#.  Tested using a program that uses daemon() and then opens an
#.  otherwise unused console device (/dev/ttyN) that does not
#.  have an associated getty process.
#. type: Plain text
#: build/C/man3/daemon.3:145
msgid ""
"The GNU C library implementation of this function was taken from BSD, and "
"does not employ the double-fork technique (i.e., B<fork>(2), B<setsid>(2), "
"B<fork>(2))  that is necessary to ensure that the resulting daemon process "
"is not a session leader.  Instead, the resulting daemon I<is> a session "
"leader.  On systems that follow System V semantics (e.g., Linux), this means "
"that if the daemon opens a terminal that is not already a controlling "
"terminal for another session, then that terminal will inadvertently become "
"the controlling terminal for the daemon."
msgstr ""

#. type: Plain text
#: build/C/man3/daemon.3:150
msgid "B<fork>(2), B<setsid>(2), B<daemon>(7), B<logrotate>(8)"
msgstr "B<fork>(2), B<setsid>(2), B<daemon>(7), B<logrotate>(8)"

#. type: TH
#: build/C/man3/des_crypt.3:14
#, no-wrap
msgid "DES_CRYPT"
msgstr "DES_CRYPT"

#. type: TH
#: build/C/man3/des_crypt.3:14 build/C/man2/gettid.2:26
#, no-wrap
msgid "2020-04-11"
msgstr "2020-04-11"

#. type: Plain text
#: build/C/man3/des_crypt.3:18
msgid ""
"des_crypt, ecb_crypt, cbc_crypt, des_setparity, DES_FAILED - fast DES "
"encryption"
msgstr ""
"des_crypt, ecb_crypt, cbc_crypt, des_setparity, DES_FAILED - 高速な DES 暗号"
"化"

#.  Sun version
#.  .B #include <des_crypt.h>
#. type: Plain text
#: build/C/man3/des_crypt.3:23
#, no-wrap
msgid "B<#include E<lt>rpc/des_crypt.hE<gt>>\n"
msgstr "B<#include E<lt>rpc/des_crypt.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/des_crypt.3:26
#, no-wrap
msgid ""
"B<int ecb_crypt(char *>I<key>B<, char *>I<data>B<, unsigned >I<datalen>B<,>\n"
"B<              unsigned >I<mode>B<);>\n"
msgstr ""
"B<int ecb_crypt(char *>I<key>B<, char *>I<data>B<, unsigned >I<datalen>B<,>\n"
"B<              unsigned >I<mode>B<);>\n"

#. type: Plain text
#: build/C/man3/des_crypt.3:29
#, no-wrap
msgid ""
"B<int cbc_crypt(char *>I<key>B<, char *>I<data>B<, unsigned >I<datalen>B<,>\n"
"B<              unsigned >I<mode>B<, char *>I<ivec>B<);>\n"
msgstr ""
"B<int cbc_crypt(char *>I<key>B<, char *>I<data>B<, unsigned >I<datalen>B<,>\n"
"B<              unsigned >I<mode>B<, char *>I<ivec>B<);>\n"

#. type: Plain text
#: build/C/man3/des_crypt.3:31
#, no-wrap
msgid "B<void des_setparity(char *>I<key>B<);>\n"
msgstr "B<void des_setparity(char *>I<key>B<);>\n"

#. type: Plain text
#: build/C/man3/des_crypt.3:33
#, no-wrap
msgid "B<int DES_FAILED(int >I<status>B<);>\n"
msgstr "B<int DES_FAILED(int >I<status>B<);>\n"

#. type: Plain text
#: build/C/man3/des_crypt.3:63
msgid ""
"B<ecb_crypt>()  and B<cbc_crypt>()  implement the NBS DES (Data Encryption "
"Standard).  These routines are faster and more general purpose than "
"B<crypt>(3).  They also are able to utilize DES hardware if it is "
"available.  B<ecb_crypt>()  encrypts in ECB (Electronic Code Book)  mode, "
"which encrypts blocks of data independently.  B<cbc_crypt>()  encrypts in "
"CBC (Cipher Block Chaining)  mode, which chains together successive blocks.  "
"CBC mode protects against insertions, deletions and substitutions of "
"blocks.  Also, regularities in the clear text will not appear in the cipher "
"text."
msgstr ""
"B<ecb_crypt>()  と B<cbc_crypt>()  は NBS DES (Data Encryption Standard, デー"
"タ暗号化規格) を実装している。 これらのルーチンは B<crypt>(3)  よりも高速でよ"
"り一般的な目的に使用できる。 利用可能であれば、これらのルーチンは DES ハード"
"ウェアを使用することもできる。 B<ecb_crypt>()  は ECB (Electronic Code Book) "
"モードで暗号化する。 このモードでは (個々の) データのブロックを独立して暗号化"
"する B<cbc_crypt>()  は CBC (Cipher Block Chaining) モードで暗号化する。 この"
"モードでは連続するブロックを互いに連鎖させて暗号化する。 CBC はブロックの挿"
"入・削除・置き換えから保護する。 また平文の規則性が暗号文に現れない。"

#. type: Plain text
#: build/C/man3/des_crypt.3:106
msgid ""
"Here is how to use these routines.  The first argument, I<key>, is the 8-"
"byte encryption key with parity.  To set the key's parity, which for DES is "
"in the low bit of each byte, use B<des_setparity>().  The second argument, "
"I<data>, contains the data to be encrypted or decrypted.  The third "
"argument, I<datalen>, is the length in bytes of I<data>, which must be a "
"multiple of 8.  The fourth argument, I<mode>, is formed by ORing together "
"some things.  For the encryption direction OR in either B<DES_ENCRYPT> or "
"B<DES_DECRYPT>.  For software versus hardware encryption, OR in either "
"B<DES_HW> or B<DES_SW>.  If B<DES_HW> is specified, and there is no "
"hardware, then the encryption is performed in software and the routine "
"returns B<DESERR_NOHWDEVICE>.  For B<cbc_crypt>(), the argument I<ivec> is "
"the 8-byte initialization vector for the chaining.  It is updated to the "
"next initialization vector upon return."
msgstr ""
"これらのルーチンの使用法を示す。 第 1 引数 I<key> はパリティ付きの 8 バイト"
"の暗号化鍵である。 鍵のパリティを設定するには B<des_setparity>()  を使うこ"
"と。 DES の場合、鍵のパリティは各バイトの最下位ビットである。 第 2 引数 "
"I<data> は暗号化または復号化されるデータを含む。 第 3 引数 I<datalen> は "
"I<data> のバイト長であり、8 の倍数でなければならない。 第 4 引数 I<mode> は"
"いくつかの値を OR することで作成する。 暗号化の方向 (訳註: 暗号化なのか復号化"
"なのか) を指定するため、 B<DES_ENCRYPT> または B<DES_DECRYPT> を OR する。 暗"
"号化をソフトウェアで行うかハードウェアで行うかを指定するため、 B<DES_HW> また"
"は B<DES_SW> を OR する。 B<DES_HW> が指定されていて、かつハードウェアがない"
"場合、 暗号化はソフトウェアで実行されて、ルーチンは B<DESERR_NOHWDEVICE> を返"
"す。 B<cbc_crypt>()  において、引数 I<ivec> はデータブロックを連鎖させる際"
"の 8 バイトの初期化ベクトルである。 この引数はルーチンから戻るときに次の初"
"期化ベクトルに更新される。"

#. type: TP
#: build/C/man3/des_crypt.3:107
#, no-wrap
msgid "B<DESERR_NONE>"
msgstr "B<DESERR_NONE>"

#. type: Plain text
#: build/C/man3/des_crypt.3:110
msgid "No error."
msgstr "エラーなし。"

#. type: TP
#: build/C/man3/des_crypt.3:110
#, no-wrap
msgid "B<DESERR_NOHWDEVICE>"
msgstr "B<DESERR_NOHWDEVICE>"

#. type: Plain text
#: build/C/man3/des_crypt.3:113
msgid ""
"Encryption succeeded, but done in software instead of the requested hardware."
msgstr ""
"暗号化は成功したが、要求されたハードウェアの代わりにソフトウェアで実行され"
"た。"

#. type: TP
#: build/C/man3/des_crypt.3:113
#, no-wrap
msgid "B<DESERR_HWERROR>"
msgstr "B<DESERR_HWERROR>"

#. type: Plain text
#: build/C/man3/des_crypt.3:116
msgid "An error occurred in the hardware or driver."
msgstr "ハードウェアまたはドライバでエラーが発生した。"

#. type: TP
#: build/C/man3/des_crypt.3:116
#, no-wrap
msgid "B<DESERR_BADPARAM>"
msgstr "B<DESERR_BADPARAM>"

#. type: Plain text
#: build/C/man3/des_crypt.3:119
msgid "Bad argument to routine."
msgstr "ルーチンへの引数が不正である。"

#.  .BR DES_FAILED\c
#.  .BR ( stat )
#.  So far the Sun page
#.  Some additions - aeb
#. type: Plain text
#: build/C/man3/des_crypt.3:129
msgid ""
"Given a result status I<stat>, the macro B<DES_FAILED(>I<stat>B<)> is false "
"only for the first two statuses."
msgstr ""
"結果の状態 I<stat> を与えたとき、マクロ B<DES_FAILED(>I<stat>B<)> が false に"
"なるのは、最初の 2 つだけである。"

#. type: Plain text
#: build/C/man3/des_crypt.3:131
msgid "These functions were added to glibc in version 2.1."
msgstr "これらの関数は glibc のバージョン 2.1 で追加された。"

#. type: Plain text
#: build/C/man3/des_crypt.3:142
msgid ""
"Because they employ the DES block cipher, which is no longer considered "
"secure, B<ecb_crypt>(), B<ecb_crypt>(), B<crypt_r>(), and "
"B<des_setparity>()  were removed in glibc 2.28.  Applications should switch "
"to a modern cryptography library, such as B<libgcrypt>."
msgstr ""

#. type: tbl table
#: build/C/man3/des_crypt.3:154
#, no-wrap
msgid ""
"B<ecb_crypt>(),\n"
"B<cbc_crypt>(),\n"
"B<des_setparity>()"
msgstr ""
"B<ecb_crypt>(),\n"
"B<cbc_crypt>(),\n"
"B<des_setparity>()"

#. type: Plain text
#: build/C/man3/des_crypt.3:159
msgid "4.3BSD.  Not in POSIX.1."
msgstr "4.3BSD. POSIX.1 にはない。"

#. type: Plain text
#: build/C/man3/des_crypt.3:163
msgid "B<des>(1), B<crypt>(3), B<xcrypt>(3)"
msgstr "B<des>(1), B<crypt>(3), B<xcrypt>(3)"

#. type: TH
#: build/C/man2/dup.2:37
#, no-wrap
msgid "DUP"
msgstr "DUP"

#. type: TH
#: build/C/man2/dup.2:37 build/C/man3/encrypt.3:30 build/C/man2/sysctl.2:30
#: build/C/man3/get_phys_pages.3:25
#, no-wrap
msgid "2020-11-01"
msgstr "2020-11-01"

#. type: Plain text
#: build/C/man2/dup.2:40
msgid "dup, dup2, dup3 - duplicate a file descriptor"
msgstr "dup, dup2, dup3 - ファイルディスクリプターを複製する"

#. type: Plain text
#: build/C/man2/dup.2:46
#, no-wrap
msgid ""
"B<int dup(int >I<oldfd>B<);>\n"
"B<int dup2(int >I<oldfd>B<, int >I<newfd>B<);>\n"
msgstr ""
"B<int dup(int >I<oldfd>B<);>\n"
"B<int dup2(int >I<oldfd>B<, int >I<newfd>B<);>\n"

#. type: Plain text
#: build/C/man2/dup.2:50
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>fcntl.hE<gt>>              /* Obtain O_* constant definitions */\n"
"B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>             /* feature_test_macros(7) 参照 */\n"
"B<#include E<lt>fcntl.hE<gt>>              /* 定数 O_* の定義の取得 */\n"
"B<#include E<lt>unistd.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/dup.2:52
#, no-wrap
msgid "B<int dup3(int >I<oldfd>B<, int >I<newfd>B<, int >I<flags>B<);>\n"
msgstr "B<int dup3(int >I<oldfd>B<, int >I<newfd>B<, int >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man2/dup.2:59
msgid ""
"The B<dup>()  system call creates a copy of the file descriptor I<oldfd>, "
"using the lowest-numbered unused file descriptor for the new descriptor."
msgstr ""
"B<dup>() システムコールは、 ファイルディスクリプター I<oldfd> のコピーを作成"
"し、 最も小さい番号の未使用のファイルディスクリプターを 新しいディスクリプ"
"ターとして使用する。"

#. type: Plain text
#: build/C/man2/dup.2:68
msgid ""
"After a successful return, the old and new file descriptors may be used "
"interchangeably.  They refer to the same open file description (see "
"B<open>(2))  and thus share file offset and file status flags; for example, "
"if the file offset is modified by using B<lseek>(2)  on one of the file "
"descriptors, the offset is also changed for the other."
msgstr ""
"成功が返された場合には、 古いファイルディスクリプターと新しいファイルディスク"
"リプターは 互いに可換なものとして使うことができる。 2つのファイルディスクリプ"
"ターは同じファイル記述 (description)  (B<open>(2)  参照) を参照しており、した"
"がってファイルオフセットやファイル状態フラグが 共有される。例えば、一方のファ"
"イルディスクリプターに対して B<lseek>(2)  を使ってファイルオフセットを変更し"
"た場合、もう一方のファイルディスクリプターの オフセットも変化する。"

#. type: Plain text
#: build/C/man2/dup.2:77
msgid ""
"The two file descriptors do not share file descriptor flags (the close-on-"
"exec flag).  The close-on-exec flag (B<FD_CLOEXEC>; see B<fcntl>(2))  for "
"the duplicate descriptor is off."
msgstr ""
"2つのファイルディスクリプターはファイルディスクリプターフラグ (close-on-exec "
"flag)  を共有しない。複製されたディスクリプターの close-on-exec flag "
"(B<fcntl>(2)  参照) は off となる。"

#. type: SS
#: build/C/man2/dup.2:77
#, no-wrap
msgid "dup2()"
msgstr "dup2()"

#. type: Plain text
#: build/C/man2/dup.2:88
msgid ""
"The B<dup2>()  system call performs the same task as B<dup>(), but instead "
"of using the lowest-numbered unused file descriptor, it uses the file "
"descriptor number specified in I<newfd>.  If the file descriptor I<newfd> "
"was previously open, it is silently closed before being reused."
msgstr ""
"B<dup2>() システムコールは B<dup>() と同じ処理を実行するが、\n"
"番号が最も小さい未使用のファイルディスクリプターを使用する代わりに、\n"
"I<newfd> で指定されたファイルディスクリプター番号を使用する。\n"
"ファイルディスクリプター I<newfd> が以前にオープンされていた場合には、\n"
"黙ってそのファイルディスクリプターをクローズしてから再利用する。"

#. type: Plain text
#: build/C/man2/dup.2:104
msgid ""
"The steps of closing and reusing the file descriptor I<newfd> are performed "
"I<atomically>.  This is important, because trying to implement equivalent "
"functionality using B<close>(2)  and B<dup>()  would be subject to race "
"conditions, whereby I<newfd> might be reused between the two steps.  Such "
"reuse could happen because the main program is interrupted by a signal "
"handler that allocates a file descriptor, or because a parallel thread "
"allocates a file descriptor."
msgstr ""
"ファイルディスクリプター I<newfd> をクローズして再利用する処理は\n"
"I<アトミック(不可分)に>実行される。これは重要な点である。 なぜなら、\n"
"等価な機能を B<close>(2) と B<dup>() を使って実装しようとすると、\n"
"2 つの処理の間に I<newfd> が再利用されてしまうという、\n"
"競合状態にさらされることになるからだ。\n"
"このような再利用が起こるのは、\n"
"メインプログラムがファイルディスクリプターを割り当てる\n"
"シグナルハンドラーにより割り込まれたり、並行動作するスレッドが\n"
"ファイルディスクリプターを割り当てたりすることがあるからだ。"

#. type: Plain text
#: build/C/man2/dup.2:106
msgid "Note the following points:"
msgstr "以下の点について注意すること:"

#. type: Plain text
#: build/C/man2/dup.2:112
msgid ""
"If I<oldfd> is not a valid file descriptor, then the call fails, and "
"I<newfd> is not closed."
msgstr ""
"I<oldfd> が有効なファイルディスクリプターでない場合、その呼び出しは失敗し、 "
"I<newfd> はクローズされない。"

#. type: Plain text
#: build/C/man2/dup.2:124
msgid ""
"If I<oldfd> is a valid file descriptor, and I<newfd> has the same value as "
"I<oldfd>, then B<dup2>()  does nothing, and returns I<newfd>."
msgstr ""
"I<oldfd> が有効なファイルディスクリプターで、 I<newfd> が I<oldfd> と同じ値の"
"場合、 B<dup2>()  は何もせず、 I<newfd> を返す。"

#. type: SS
#: build/C/man2/dup.2:124
#, no-wrap
msgid "dup3()"
msgstr "dup3()"

#. type: Plain text
#: build/C/man2/dup.2:129
msgid "B<dup3>()  is the same as B<dup2>(), except that:"
msgstr "B<dup3>()  は B<dup2>()  と同じだが、以下の点が異なる。"

#. type: Plain text
#: build/C/man2/dup.2:138
msgid ""
"The caller can force the close-on-exec flag to be set for the new file "
"descriptor by specifying B<O_CLOEXEC> in I<flags>.  See the description of "
"the same flag in B<open>(2)  for reasons why this may be useful."
msgstr ""
"呼び出し元が、新しいファイルディスクリプターに対して close-on-exec フラグを強"
"制的に設定することができる。 これを行うには、 I<flags> に B<O_CLOEXEC> を指定"
"する。 このフラグが役に立つ理由については、 B<open>(2)  の B<O_CLOEXEC> フラ"
"グの説明を参照のこと。"

#.  Ulrich Drepper, LKML, 2008-10-09:
#. 	We deliberately decided on this change.  Otherwise, what is the
#. 	result of dup3(fd, fd, O_CLOEXEC)?
#. type: Plain text
#: build/C/man2/dup.2:150
msgid ""
"If I<oldfd> equals I<newfd>, then B<dup3>()  fails with the error B<EINVAL>."
msgstr ""
"I<oldfd> が I<newfd> と同じ場合、 B<dup3>()  は B<EINVAL> エラーで失敗する。"

#. type: Plain text
#: build/C/man2/dup.2:156
msgid ""
"On success, these system calls return the new file descriptor.  On error, -1 "
"is returned, and I<errno> is set appropriately."
msgstr ""
"成功すると、これらのシステムコールは新しいファイルディスクリプターを返す。 エ"
"ラーの場合、-1 を返し、 I<errno> を適切に設定する。"

#. type: Plain text
#: build/C/man2/dup.2:161
msgid "I<oldfd> isn't an open file descriptor."
msgstr "I<oldfd> がオープンされたファイルディスクリプターではない。"

#. type: Plain text
#: build/C/man2/dup.2:168
msgid ""
"I<newfd> is out of the allowed range for file descriptors (see the "
"discussion of B<RLIMIT_NOFILE> in B<getrlimit>(2))."
msgstr ""
"I<newfd> がファイルディスクリプターとして許可されている範囲ではない "
"(B<getrlimit>(2) の B<RLIMIT_NOFILE> の議論を参照)。"

#. type: TP
#: build/C/man2/dup.2:168 build/C/man2/fcntl.2:1686 build/C/man2/fcntl.2:1695
#: build/C/man2/swapon.2:119
#, no-wrap
msgid "B<EBUSY>"
msgstr "B<EBUSY>"

#. type: Plain text
#: build/C/man2/dup.2:178
msgid ""
"(Linux only) This may be returned by B<dup2>()  or B<dup3>()  during a race "
"condition with B<open>(2)  and B<dup>()."
msgstr ""
"(Linux のみ)  B<open>(2)  や B<dup>()  との競合状態の場合に、 B<dup2>()  や "
"B<dup3>()  はこのエラーを返すかもしれない。"

#. type: Plain text
#: build/C/man2/dup.2:186
msgid ""
"The B<dup2>()  or B<dup3>()  call was interrupted by a signal; see "
"B<signal>(7)."
msgstr ""
"B<dup2>()  や B<dup3>()  の呼び出しがシグナルにより割り込まれた。 "
"B<signal>(7)  参照。"

#. type: Plain text
#: build/C/man2/dup.2:191
msgid "(B<dup3>())  I<flags> contain an invalid value."
msgstr "(B<dup3>())  I<flags> に無効な値が入っている。"

#. type: Plain text
#: build/C/man2/dup.2:197
msgid "(B<dup3>())  I<oldfd> was equal to I<newfd>."
msgstr "(B<dup3>()) I<oldfd> が I<newfd> と同じであった。"

#. type: TP
#: build/C/man2/dup.2:197 build/C/man2/execve.2:513 build/C/man2/fcntl.2:1790
#: build/C/man3/getlogin.3:112
#, no-wrap
msgid "B<EMFILE>"
msgstr "B<EMFILE>"

#. type: Plain text
#: build/C/man2/dup.2:204
#, fuzzy
#| msgid ""
#| "The process already has the maximum number of file descriptors open and "
#| "tried to open a new one (see the discussion of B<RLIMIT_NOFILE> in "
#| "B<getrlimit>(2))."
msgid ""
"The per-process limit on the number of open file descriptors has been "
"reached (see the discussion of B<RLIMIT_NOFILE> in B<getrlimit>(2))."
msgstr ""
"プロセスがすでにオープンできる最大数までファイルディスクリプター を開いてい"
"て、さらに新しいものを開こうとした (B<getrlimit>(2) のリソース上限 "
"B<RLIMIT_NOFILE> を参照)。"

#. type: Plain text
#: build/C/man2/dup.2:209
msgid ""
"B<dup3>()  was added to Linux in version 2.6.27; glibc support is available "
"starting with version 2.9."
msgstr ""
"B<dup3>()  はバージョン 2.6.27 で Linux に追加された。 glibc によるサポートは"
"バージョン 2.9 以降で利用できる。"

#. type: Plain text
#: build/C/man2/dup.2:213
msgid "B<dup>(), B<dup2>(): POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD."
msgstr "B<dup>(), B<dup2>(): POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD."

#.  SVr4 documents additional
#.  EINTR and ENOLINK error conditions.  POSIX.1 adds EINTR.
#.  The EBUSY return is Linux-specific.
#. type: Plain text
#: build/C/man2/dup.2:219
msgid "B<dup3>()  is Linux-specific."
msgstr "B<dup3>()  は Linux 固有である。"

#. type: Plain text
#: build/C/man2/dup.2:233
msgid ""
"The error returned by B<dup2>()  is different from that returned by "
"B<fcntl(>..., B<F_DUPFD>, ...B<)> when I<newfd> is out of range.  On some "
"systems, B<dup2>()  also sometimes returns B<EINVAL> like B<F_DUPFD>."
msgstr ""
"I<newfd> が範囲を超えた時に返されるエラーは、 B<dup2>()  と B<fcntl(>..., "
"B<F_DUPFD>, ...B<)> では異っている。 B<dup2>()  が B<F_DUPFD> と同じように "
"B<EINVAL> を返すシステムもある。"

#. type: Plain text
#: build/C/man2/dup.2:249
msgid ""
"If I<newfd> was open, any errors that would have been reported at "
"B<close>(2)  time are lost.  If this is of concern, then\\(emunless the "
"program is single-threaded and does not allocate file descriptors in signal "
"handlers\\(emthe correct approach is I<not> to close I<newfd> before calling "
"B<dup2>(), because of the race condition described above.  Instead, code "
"something like the following could be used:"
msgstr ""
"I<newfd> がオープンされていた場合、\n"
"B<close>(2) 時に報告されることになるエラーはすべて失われる。\n"
"これが心配で、シングルスレッドかつシグナルハンドラーで\n"
"ファイルディスクリプターを割り当てるようなプログラムでない場合には、\n"
"正しい方法は B<dup2>() を呼び出す前に\n"
"I<newfd> をクローズ「しない」ことである。\n"
"なぜなら、上で説明した競合状況があるからである。\n"
"代わりに、以下のようなコードが使用できることだろう。"

#. type: Plain text
#: build/C/man2/dup.2:255
#, no-wrap
msgid ""
"/* Obtain a duplicate of \\(aqnewfd\\(aq that can subsequently\n"
"   be used to check for close() errors; an EBADF error\n"
"   means that \\(aqnewfd\\(aq was not open. */\n"
msgstr ""
"/* あとで close() エラーをチェックするのに使用できる\n"
"   ように \\(aqnewfd\\(aq の複製を取得する。 EBADF エラーは\n"
"   \\(aqnewfd\\(aq がオープンされていないことを意味する。 */\n"

#. type: Plain text
#: build/C/man2/dup.2:260
#, no-wrap
msgid ""
"tmpfd = dup(newfd);\n"
"if (tmpfd == -1 && errno != EBADF) {\n"
"    /* Handle unexpected dup() error */\n"
"}\n"
msgstr ""
"tmpfd = dup(newfd);\n"
"if (tmpfd == -1 && errno != EBADF) {\n"
"    /* 予期しない dup() のエラーを処理する */\n"
"}\n"

#. type: Plain text
#: build/C/man2/dup.2:262
#, no-wrap
msgid "/* Atomically duplicate \\(aqoldfd\\(aq on \\(aqnewfd\\(aq */\n"
msgstr "/* アトミックに \\(aqoldfd\\(aq を \\(aqnewfd\\(aq に複製する */\n"

#. type: Plain text
#: build/C/man2/dup.2:266
#, no-wrap
msgid ""
"if (dup2(oldfd, newfd) == -1) {\n"
"    /* Handle dup2() error */\n"
"}\n"
msgstr ""
"if (dup2(oldfd, newfd) == -1) {\n"
"    /* dup2() のエラーを処理する */\n"
"}\n"

#. type: Plain text
#: build/C/man2/dup.2:269
#, no-wrap
msgid ""
"/* Now check for close() errors on the file originally\n"
"   referred to by \\(aqnewfd\\(aq */\n"
msgstr ""
"/* ここでもともと \\(aqnewfd\\(aq で参照されていたファイルの\n"
"   close() エラーをチェックする */\n"

#. type: Plain text
#: build/C/man2/dup.2:275
#, no-wrap
msgid ""
"if (tmpfd != -1) {\n"
"    if (close(tmpfd) == -1) {\n"
"        /* Handle errors from close */\n"
"    }\n"
"}\n"
msgstr ""
"if (tmpfd != -1) {\n"
"    if (close(tmpfd) == -1) {\n"
"        /* close からのエラーを処理する */\n"
"    }\n"
"}\n"

#. type: Plain text
#: build/C/man2/dup.2:282
msgid "B<close>(2), B<fcntl>(2), B<open>(2), B<pidfd_getfd>(2)"
msgstr "B<close>(2), B<fcntl>(2), B<open>(2), B<pidfd_getfd>(2)"

#. type: TH
#: build/C/man3/encrypt.3:30
#, no-wrap
msgid "ENCRYPT"
msgstr "ENCRYPT"

#. type: Plain text
#: build/C/man3/encrypt.3:33
msgid "encrypt, setkey, encrypt_r, setkey_r - encrypt 64-bit messages"
msgstr ""
"encrypt, setkey, encrypt_r, setkey_r - 64 ビットのメッセージを暗号化する"

#. type: Plain text
#: build/C/man3/encrypt.3:39
#, no-wrap
msgid "B<void encrypt(char >I<block>B<[64], int >I<edflag>B<);>\n"
msgstr "B<void encrypt(char >I<block>B<[64], int >I<edflag>B<);>\n"

#. type: Plain text
#: build/C/man3/encrypt.3:42
#, no-wrap
msgid ""
"B<#define _XOPEN_SOURCE>       /* See feature_test_macros(7) */\n"
"B<#include E<lt>stdlib.hE<gt>>\n"
msgstr ""
"B<#define _XOPEN_SOURCE>       /* feature_test_macros(7) 参照 */\n"
"B<#include E<lt>stdlib.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/encrypt.3:44
#, no-wrap
msgid "B<void setkey(const char *>I<key>B<);>\n"
msgstr "B<void setkey(const char *>I<key>B<);>\n"

#. type: Plain text
#: build/C/man3/encrypt.3:51
#, no-wrap
msgid ""
"B<void setkey_r(const char *>I<key>B<, struct crypt_data *>I<data>B<);>\n"
"B<void encrypt_r(char *>I<block>B<, int >I<edflag>B<, struct crypt_data *>I<data>B<);>\n"
msgstr ""
"B<void setkey_r(const char *>I<key>B<, struct crypt_data *>I<data>B<);>\n"
"B<void encrypt_r(char *>I<block>B<, int >I<edflag>B<, struct crypt_data *>I<data>B<);>\n"

#. type: Plain text
#: build/C/man3/encrypt.3:54
msgid "Each of these requires linking with I<-lcrypt>."
msgstr "これらの関数は I<-lcrypt> でリンクする必要がある。"

#. type: Plain text
#: build/C/man3/encrypt.3:66
msgid ""
"These functions encrypt and decrypt 64-bit messages.  The B<setkey>()  "
"function sets the key used by B<encrypt>().  The I<key> argument used here "
"is an array of 64 bytes, each of which has numerical value 1 or 0.  The "
"bytes key[n] where n=8*i-1 are ignored, so that the effective key length is "
"56 bits."
msgstr ""
"これらの関数は、64 ビットのメッセージの暗号化と復号化を行う。 B<setkey>()  関"
"数は B<encrypt>()  によって使われる暗号鍵を設定する。 ここで使われる引数 "
"I<key> は 64 バイトの配列であり、各バイトは数値 1 または 0 である。 n=8*i-1 "
"に対するバイト key[n] は無視されるので、 有効な暗号鍵の長さは 56 ビットにな"
"る。"

#. type: Plain text
#: build/C/man3/encrypt.3:78
msgid ""
"The B<encrypt>()  function modifies the passed buffer, encoding if I<edflag> "
"is 0, and decoding if 1 is being passed.  Like the I<key> argument, also "
"I<block> is a bit vector representation of the actual value that is "
"encoded.  The result is returned in that same vector."
msgstr ""
"B<encrypt>()  関数は、 I<edflag> が 0 の場合は暗号化し、1 が渡された場合は復"
"号化するというように、 渡されたバッファーを変更する。 引数 I<key> と同様"
"に、 I<block> はエンコードされた実際の値を表現するビットの配列である。 結果は"
"この同じ配列を使って返される。"

#. type: Plain text
#: build/C/man3/encrypt.3:88
msgid ""
"These two functions are not reentrant, that is, the key data is kept in "
"static storage.  The functions B<setkey_r>()  and B<encrypt_r>()  are the "
"reentrant versions.  They use the following structure to hold the key data:"
msgstr ""
"これら 2 つの関数はリエントラント (reentrant) ではない。 つまり暗号鍵データは"
"静的な領域に保存される。 関数 B<setkey_r>()  と B<encrypt_r>()  はリエントラ"
"ントなバージョンである。 これらの関数は暗号鍵データを保持するために以下のよう"
"な構造体を使う。"

#. type: Plain text
#: build/C/man3/encrypt.3:103
#, no-wrap
msgid ""
"struct crypt_data {\n"
"    char keysched[16 * 8];\n"
"    char sb0[32768];\n"
"    char sb1[32768];\n"
"    char sb2[32768];\n"
"    char sb3[32768];\n"
"    char crypt_3_buf[14];\n"
"    char current_salt[2];\n"
"    long current_saltbits;\n"
"    int  direction;\n"
"    int  initialized;\n"
"};\n"
msgstr ""
"struct crypt_data {\n"
"    char keysched[16 * 8];\n"
"    char sb0[32768];\n"
"    char sb1[32768];\n"
"    char sb2[32768];\n"
"    char sb3[32768];\n"
"    char crypt_3_buf[14];\n"
"    char current_salt[2];\n"
"    long current_saltbits;\n"
"    int  direction;\n"
"    int  initialized;\n"
"};\n"

#. type: Plain text
#: build/C/man3/encrypt.3:111
msgid "Before calling B<setkey_r>()  set I<data-E<gt>initialized> to zero."
msgstr ""
"B<setkey_r>()  を呼び出す前には、 I<data-E<gt>initialized> を 0 に設定するこ"
"と。"

#. type: Plain text
#: build/C/man3/encrypt.3:113
msgid "These functions do not return any value."
msgstr "これらの関数は、なにも値を返さない。"

#. type: Plain text
#: build/C/man3/encrypt.3:118
msgid ""
"Set I<errno> to zero before calling the above functions.  On success, it is "
"unchanged."
msgstr ""
"上記の関数を呼び出す前に I<errno> を 0 に設定すること。 成功した場合、この値"
"は変更されない。"

#. type: Plain text
#: build/C/man3/encrypt.3:122
msgid ""
"The function is not provided.  (For example because of former USA export "
"restrictions.)"
msgstr ""
"(例えば以前のアメリカ合衆国輸出規制などにより)  この関数が提供されていない。"

#. type: Plain text
#: build/C/man3/encrypt.3:133
msgid ""
"Because they employ the DES block cipher, which is no longer considered "
"secure, B<crypt>(), B<crypt_r>(), B<setkey>(), and B<setkey_r>()  were "
"removed in glibc 2.28.  Applications should switch to a modern cryptography "
"library, such as B<libgcrypt>."
msgstr ""

#. type: tbl table
#: build/C/man3/encrypt.3:144
#, no-wrap
msgid ""
"B<encrypt>(),\n"
"B<setkey>()"
msgstr ""
"B<encrypt>(),\n"
"B<setkey>()"

#. type: tbl table
#: build/C/man3/encrypt.3:148
#, no-wrap
msgid ""
"B<encrypt_r>(),\n"
"B<setkey_r>()"
msgstr ""
"B<encrypt_r>(),\n"
"B<setkey_r>()"

#. type: Plain text
#: build/C/man3/encrypt.3:154
msgid "B<encrypt>(), B<setkey>(): POSIX.1-2001, POSIX.1-2008, SUS, SVr4."
msgstr "B<encrypt>(), B<setkey>(): POSIX.1-2001, POSIX.1-2008, SUS, SVr4."

#. type: Plain text
#: build/C/man3/encrypt.3:160
msgid "The functions B<encrypt_r>()  and B<setkey_r>()  are GNU extensions."
msgstr "関数 B<encrypt_r>() と B<setkey_r>() は GNU による拡張である。"

#. type: Plain text
#: build/C/man3/encrypt.3:164
msgid "See B<crypt>(3)."
msgstr "B<crypt>(3) を参照。"

#. type: Plain text
#: build/C/man3/encrypt.3:166
msgid "In glibc 2.2, these functions use the DES algorithm."
msgstr "glibc 2.2 では、これらの関数は DES アルゴリズムを使う。"

#. type: Plain text
#: build/C/man3/encrypt.3:173
#, no-wrap
msgid ""
"#define _XOPEN_SOURCE\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>crypt.hE<gt>\n"
msgstr ""
"#define _XOPEN_SOURCE\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>crypt.hE<gt>\n"

#. type: Plain text
#: build/C/man3/encrypt.3:181
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    char key[64];\n"
"    char orig[9] = \"eggplant\";\n"
"    char buf[64];\n"
"    char txt[9];\n"
msgstr ""
" int\n"
"main(void)\n"
"{\n"
"    char key[64];\n"
"    char orig[9] = \"eggplant\";\n"
"    char buf[64];\n"
"    char txt[9];\n"

#. type: Plain text
#: build/C/man3/encrypt.3:185
#, no-wrap
msgid ""
"    for (int i = 0; i E<lt> 64; i++) {\n"
"        key[i] = rand() & 1;\n"
"    }\n"
msgstr ""
"    for (int i = 0; i E<lt> 64; i++) {\n"
"        key[i] = rand() & 1;\n"
"    }\n"

#. type: Plain text
#: build/C/man3/encrypt.3:193
#, no-wrap
msgid ""
"    for (int i = 0; i E<lt> 8; i++) {\n"
"        for (int j = 0; j E<lt> 8; j++) {\n"
"            buf[i * 8 + j] = orig[i] E<gt>E<gt> j & 1;\n"
"        }\n"
"        setkey(key);\n"
"    }\n"
"    printf(\"Before encrypting: %s\\en\", orig);\n"
msgstr ""
"    for (int i = 0; i E<lt> 8; i++) {\n"
"        for (int j = 0; j E<lt> 8; j++) {\n"
"            buf[i * 8 + j] = orig[i] E<gt>E<gt> j & 1;\n"
"        }\n"
"        setkey(key);\n"
"    }\n"
"    printf(\"Before encrypting: %s\\en\", orig);\n"

#. type: Plain text
#: build/C/man3/encrypt.3:202
#, no-wrap
msgid ""
"    encrypt(buf, 0);\n"
"    for (int i = 0; i E<lt> 8; i++) {\n"
"        for (int j = 0, txt[i] = \\(aq\\e0\\(aq; j E<lt> 8; j++) {\n"
"            txt[i] |= buf[i * 8 + j] E<lt>E<lt> j;\n"
"        }\n"
"        txt[8] = \\(aq\\e0\\(aq;\n"
"    }\n"
"    printf(\"After encrypting:  %s\\en\", txt);\n"
msgstr ""
"    encrypt(buf, 0);\n"
"    for (int i = 0; i E<lt> 8; i++) {\n"
"        for (int j = 0, txt[i] = \\(aq\\e0\\(aq; j E<lt> 8; j++) {\n"
"            txt[i] |= buf[i * 8 + j] E<lt>E<lt> j;\n"
"        }\n"
"        txt[8] = \\(aq\\e0\\(aq;\n"
"    }\n"
"    printf(\"After encrypting:  %s\\en\", txt);\n"

#. type: Plain text
#: build/C/man3/encrypt.3:213
#, no-wrap
msgid ""
"    encrypt(buf, 1);\n"
"    for (int i = 0; i E<lt> 8; i++) {\n"
"        for (int j = 0, txt[i] = \\(aq\\e0\\(aq; j E<lt> 8; j++) {\n"
"            txt[i] |= buf[i * 8 + j] E<lt>E<lt> j;\n"
"        }\n"
"        txt[8] = \\(aq\\e0\\(aq;\n"
"    }\n"
"    printf(\"After decrypting:  %s\\en\", txt);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    encrypt(buf, 1);\n"
"    for (int i = 0; i E<lt> 8; i++) {\n"
"        for (int j = 0, txt[i] = \\(aq\\e0\\(aq; j E<lt> 8; j++) {\n"
"            txt[i] |= buf[i * 8 + j] E<lt>E<lt> j;\n"
"        }\n"
"        txt[8] = \\(aq\\e0\\(aq;\n"
"    }\n"
"    printf(\"After decrypting:  %s\\en\", txt);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#.  .BR fcrypt (3)
#. type: Plain text
#: build/C/man3/encrypt.3:219
msgid "B<cbc_crypt>(3), B<crypt>(3), B<ecb_crypt>(3),"
msgstr "B<cbc_crypt>(3), B<crypt>(3), B<ecb_crypt>(3)"

#. type: TH
#: build/C/man7/environ.7:34
#, no-wrap
msgid "ENVIRON"
msgstr "ENVIRON"

#. type: TH
#: build/C/man7/environ.7:34 build/C/man2/execve.2:37 build/C/man2/umask.2:34
#, no-wrap
msgid "2020-08-13"
msgstr " 2020-08-13"

#. type: Plain text
#: build/C/man7/environ.7:37
msgid "environ - user environment"
msgstr "environ - ユーザー環境"

#. type: Plain text
#: build/C/man7/environ.7:40
#, no-wrap
msgid "B<extern char **>I<environ>B<;>\n"
msgstr "B<extern char **>I<environ>B<;>\n"

#. type: Plain text
#: build/C/man7/environ.7:60
#, fuzzy
#| msgid ""
#| "The variable I<environ> points to an array of pointers to strings called "
#| "the \"environment\".  The last pointer in this array has the value NULL.  "
#| "(This variable must be declared in the user program, but is declared in "
#| "the header file I<E<lt>unistd.hE<gt>> if the B<_GNU_SOURCE> feature test "
#| "macro is defined.)  This array of strings is made available to the "
#| "process by the B<exec>(3)  call that started the process."
msgid ""
"The variable I<environ> points to an array of pointers to strings called the "
"\"environment\".  The last pointer in this array has the value NULL.  (This "
"variable must be declared in the user program, but is declared in the header "
"file I<E<lt>unistd.hE<gt>> if the B<_GNU_SOURCE> feature test macro is "
"defined.)  This array of strings is made available to the process by the "
"B<exec>(3)  call that started the process.  When a child process is created "
"via B<fork>(2), it inherits a I<copy> of its parent's environment."
msgstr ""
"変数 I<environ> は「環境 (environment)」と呼ばれる文字列へのポインターの配列"
"である。 この配列の最後のポインターの値は NULL である。 (この変数はユーザープ"
"ログラムで宣言しなければならないが、 機能検査マクロ B<_GNU_SOURCE> が定義され"
"ていればヘッダーファイル I<E<lt>unistd.hE<gt>> で宣言される)。 この文字列配列"
"は、 プロセスを起動する B<exec>(3)  によって、その起動されたプロセスで利用で"
"きるようになる。"

#. type: Plain text
#: build/C/man7/environ.7:65
msgid ""
"By convention the strings in I<environ> have the form \"I<name>B<=>I<value>"
"\".  Common examples are:"
msgstr ""
"通例では、 I<environ> の文字列は \"I<name>B<=>I<value>\" という書式をとる。 "
"よく用いられる例を以下に示す。"

#. type: TP
#: build/C/man7/environ.7:65
#, no-wrap
msgid "B<USER>"
msgstr "B<USER>"

#. type: Plain text
#: build/C/man7/environ.7:68
msgid "The name of the logged-in user (used by some BSD-derived programs)."
msgstr "ユーザーのログイン名 (BSD 起源のプログラムなどによって使用される)。"

#. type: TP
#: build/C/man7/environ.7:68
#, no-wrap
msgid "B<LOGNAME>"
msgstr "B<LOGNAME>"

#. type: Plain text
#: build/C/man7/environ.7:71
msgid ""
"The name of the logged-in user (used by some System-V derived programs)."
msgstr ""
"ユーザーのログイン名(System V 起源のプログラムなどによって使用される)。"

#. type: TP
#: build/C/man7/environ.7:71
#, no-wrap
msgid "B<HOME>"
msgstr "B<HOME>"

#. type: Plain text
#: build/C/man7/environ.7:77
msgid ""
"A user's login directory, set by B<login>(1)  from the password file "
"B<passwd>(5)."
msgstr ""
"ユーザーのログインディレクトリ。 B<login>(1)  がパスワードファイル "
"B<passwd>(5)  から取得して設定する。"

#. type: TP
#: build/C/man7/environ.7:77
#, no-wrap
msgid "B<LANG>"
msgstr "B<LANG>"

#. type: Plain text
#: build/C/man7/environ.7:95
msgid ""
"The name of a locale to use for locale categories when not overridden by "
"B<LC_ALL> or more specific environment variables such as B<LC_COLLATE>, "
"B<LC_CTYPE>, B<LC_MESSAGES>, B<LC_MONETARY>, B<LC_NUMERIC>, and B<LC_TIME> "
"(see B<locale>(7)  for further details of the B<LC_*> environment variables)."
msgstr ""
"ロケールの各カテゴリーで使用されるロケールの名前。B<LC_ALL> や、 より狭い範囲"
"を対象とする環境変数 (B<LC_COLLATE>, B<LC_CTYPE>, B<LC_MESSAGES>, "
"B<LC_MONETARY>, B<LC_NUMERIC>, B<LC_TIME> など)  によって上書きされることもあ"
"る (B<LC_*> 環境変数のさらなる詳細は B<locale>(7) 参照)。"

#. type: TP
#: build/C/man7/environ.7:95
#, no-wrap
msgid "B<PATH>"
msgstr "B<PATH>"

#. type: Plain text
#: build/C/man7/environ.7:110
msgid ""
"The sequence of directory prefixes that B<sh>(1)  and many other programs "
"apply in searching for a file known by an incomplete pathname.  The prefixes "
"are separated by \\(aqB<:>\\(aq.  (Similarly one has B<CDPATH> used by some "
"shells to find the target of a change directory command, B<MANPATH> used by "
"B<man>(1)  to find manual pages, and so on)"
msgstr ""
"B<sh>(1)  や他のプログラムが、フルパスで与えられなかった実行ファイルを検索す"
"るとき、 ファイル名に前置されるディレクトリの配列。 各ディレクトリは \\(aqB<:"
">\\(aq によって区切られる。 (同じようなものに、 シェルがディレクトリ変更コマ"
"ンドの変更先を探すために用いる B<CDPATH> や、 B<man>(1)  がマニュアルページの"
"検索に用いる B<MANPATH> などがある。)"

#. type: TP
#: build/C/man7/environ.7:110
#, no-wrap
msgid "B<PWD>"
msgstr "B<PWD>"

#. type: Plain text
#: build/C/man7/environ.7:114
msgid "The current working directory.  Set by some shells."
msgstr "現在のワーキングディレクトリ。いくつかのシェルが設定する。"

#. type: TP
#: build/C/man7/environ.7:114
#, no-wrap
msgid "B<SHELL>"
msgstr "B<SHELL>"

#. type: Plain text
#: build/C/man7/environ.7:117
msgid "The pathname of the user's login shell."
msgstr "ユーザーのログインシェルのパス名。"

#. type: TP
#: build/C/man7/environ.7:117
#, no-wrap
msgid "B<TERM>"
msgstr "B<TERM>"

#. type: Plain text
#: build/C/man7/environ.7:120
msgid "The terminal type for which output is to be prepared."
msgstr "端末の種類。出力はこれにあわせて用意される。"

#. type: TP
#: build/C/man7/environ.7:120
#, no-wrap
msgid "B<PAGER>"
msgstr "B<PAGER>"

#. type: Plain text
#: build/C/man7/environ.7:123
msgid "The user's preferred utility to display text files."
msgstr ""
"テキストファイルを表示するユーテリティ。ユーザーが好みのものを設定する。"

#. type: TP
#: build/C/man7/environ.7:123
#, no-wrap
msgid "B<EDITOR>/B<VISUAL>"
msgstr "B<EDITOR>/B<VISUAL>"

#.  .TP
#.  .B BROWSER
#.  The user's preferred utility to browse URLs. Sequence of colon-separated
#.  browser commands. See http://www.catb.org/\(tiesr/BROWSER/ .
#. type: Plain text
#: build/C/man7/environ.7:130
msgid "The user's preferred utility to edit text files."
msgstr ""
"テキストファイルを編集するユーテリティ。ユーザーが好みのものを設定する。"

#. type: Plain text
#: build/C/man7/environ.7:139
msgid ""
"Names may be placed in the shell's environment by the I<export> command in "
"B<sh>(1), or by the I<setenv> command if you use B<csh>(1)."
msgstr ""

#. type: Plain text
#: build/C/man7/environ.7:152
msgid ""
"The initial environment of the shell is populated in various ways, such as "
"definitions from I</etc/environment> that are processed by B<pam_env>(8)  "
"for all users at login time (on systems that employ B<pam>(8)).  In "
"addition, various shell initialization scripts, such as the system-wide I</"
"etc/profile> script and per-user initializations script may include commands "
"that add variables to the shell's environment; see the manual page of your "
"preferred shell for details."
msgstr ""

#. type: Plain text
#: build/C/man7/environ.7:154
msgid "Bourne-style shells support the syntax"
msgstr ""

#. type: Plain text
#: build/C/man7/environ.7:156
#, no-wrap
msgid "    NAME=value command\n"
msgstr ""

#. type: Plain text
#: build/C/man7/environ.7:162
msgid ""
"to create an environment variable definition only in the scope of the "
"process that executes I<command>.  Multiple variable definitions, separated "
"by white space, may precede I<command>."
msgstr ""

#. type: Plain text
#: build/C/man7/environ.7:172
msgid ""
"Arguments may also be placed in the environment at the point of an "
"B<exec>(3).  A C program can manipulate its environment using the functions "
"B<getenv>(3), B<putenv>(3), B<setenv>(3), and B<unsetenv>(3)."
msgstr "B<exec>(3)  の引数としても環境を設定することができる。 C プログラムからは、 B<getenv>(3), B<putenv>(3), B<setenv>(3), B<unsetenv>(3)  などの関数を用いて環境を扱うことができる。"

#. type: Plain text
#: build/C/man7/environ.7:176
#, fuzzy
#| msgid ""
#| "Note that the behavior of many programs and library routines is "
#| "influenced by the presence or value of certain environment variables.  A "
#| "random collection:"
msgid ""
"Note that the behavior of many programs and library routines is influenced "
"by the presence or value of certain environment variables.  Examples include "
"the following:"
msgstr ""
"プログラムやライブラリルーチンの多くは、それぞれ適当な環境変数の存在 や値に"
"よって、動作に影響を受けることがある。以下、適宜挙げてみよう。"

#. type: Plain text
#: build/C/man7/environ.7:185
msgid ""
"The variables B<LANG>, B<LANGUAGE>, B<NLSPATH>, B<LOCPATH>, B<LC_ALL>, "
"B<LC_MESSAGES>, and so on influence locale handling; see B<catopen>(3), "
"B<gettext>(3), and B<locale>(7)."
msgstr ""
"B<LANG>, B<LANGUAGE>, B<NLSPATH>, B<LOCPATH>, B<LC_ALL>, B<LC_MESSAGES>, など"
"の変数は、ロケールの扱いに影響する。 B<catopen>(3), B<gettext>(3), "
"B<locale>(5) を参照。"

#. type: Plain text
#: build/C/man7/environ.7:192
msgid ""
"B<TMPDIR> influences the path prefix of names created by B<tempnam>(3)  and "
"other routines, and the temporary directory used by B<sort>(1)  and other "
"programs."
msgstr ""
"B<TMPDIR> は、 B<tempnam>(3) などのルーチンによって作成されるファイル名や "
"B<sort>(1) や他のプログラムが使用する一時ディレクトリに前置されるパスに影響す"
"る。"

#. type: Plain text
#: build/C/man7/environ.7:197
msgid ""
"B<LD_LIBRARY_PATH>, B<LD_PRELOAD>, and other B<LD_*> variables influence the "
"behavior of the dynamic loader/linker."
msgstr ""
"B<LD_LIBRARY_PATH>, B<LD_PRELOAD> などの B<LD_*> 変数はダイナミックローダーリ"
"ンカーの動作に影響する。"

#. type: Plain text
#: build/C/man7/environ.7:201
msgid ""
"B<POSIXLY_CORRECT> makes certain programs and library routines follow the "
"prescriptions of POSIX."
msgstr ""
"B<POSIXLY_CORRECT> が指定されると、ある種のプログラムやライブラリルーチンは "
"POSIX の規定に従うようになる。"

#. type: Plain text
#: build/C/man7/environ.7:207
msgid "The behavior of B<malloc>(3)  is influenced by B<MALLOC_*> variables."
msgstr "B<malloc>(3)  の動作は B<MALLOC_*> 変数によって影響される。"

#. type: Plain text
#: build/C/man7/environ.7:213
msgid ""
"The variable B<HOSTALIASES> gives the name of a file containing aliases to "
"be used with B<gethostbyname>(3)."
msgstr ""
"B<HOSTALIAS> 変数は、 B<gethostbyname>(3)  が用いるエイリアスが書かれている"
"ファイル名を与える。"

#. type: Plain text
#: build/C/man7/environ.7:224
msgid ""
"B<TZ> and B<TZDIR> give timezone information used by B<tzset>(3)  and "
"through that by functions like B<ctime>(3), B<localtime>(3), B<mktime>(3), "
"B<strftime>(3).  See also B<tzselect>(8)."
msgstr ""
"B<TZ> と B<TZDIR> は B<tzset>(3)  および、この関数を使う B<ctime>(3), "
"B<localtime>(3), B<mktime>(3), B<strftime>(3)  といった関数で用いられるタイム"
"ゾーンの情報を与える。 B<tzselect>(8)  も参照のこと。"

#. type: Plain text
#: build/C/man7/environ.7:228
msgid ""
"B<TERMCAP> gives information on how to address a given terminal (or gives "
"the name of a file containing such information)."
msgstr ""
"B<TERMCAP> は、現在の端末情報の取得先 (あるいはそのような情報が書かれている"
"ファイル名) を与える。"

#. type: Plain text
#: build/C/man7/environ.7:231
msgid ""
"B<COLUMNS> and B<LINES> tell applications about the window size, possibly "
"overriding the actual size."
msgstr ""
"B<COLUMNS> と B<LINES> アプリケーションにウインドウのサイズを伝える。 実際の"
"サイズとは違う値を与えることもできる。"

#. type: Plain text
#: build/C/man7/environ.7:236
msgid ""
"B<PRINTER> or B<LPDEST> may specify the desired printer to use.  See "
"B<lpr>(1)."
msgstr ""
"B<PRINTER> または B<LPDEST> 用いたいプリンタを指定する。 B<lpr>(1)  を参照の"
"こと。"

#. type: Plain text
#: build/C/man7/environ.7:243
msgid ""
"The B<prctl>(2)  B<PR_SET_MM_ENV_START> and B<PR_SET_MM_ENV_END> operations "
"can be used to control the location of the process's environment."
msgstr ""

#. type: Plain text
#: build/C/man7/environ.7:248
msgid ""
"Clearly there is a security risk here.  Many a system command has been "
"tricked into mischief by a user who specified unusual values for B<IFS> or "
"B<LD_LIBRARY_PATH>."
msgstr ""
"これらの中には、明らかにセキュリティ上の危険が存在する。 ユーザーが B<IFS> "
"や B<LD_LIBRARY_PATH> に異常な値を与えたことによって、 これまで多くのシステム"
"コマンドがだまされて、 システムをひどい目にあわせてきた。"

#. type: Plain text
#: build/C/man7/environ.7:281
msgid ""
"There is also the risk of name space pollution.  Programs like I<make> and "
"I<autoconf> allow overriding of default utility names from the environment "
"with similarly named variables in all caps.  Thus one uses B<CC> to select "
"the desired C compiler (and similarly B<MAKE>, B<AR>, B<AS>, B<FC>, B<LD>, "
"B<LEX>, B<RM>, B<YACC>, etc.).  However, in some traditional uses such an "
"environment variable gives options for the program instead of a pathname.  "
"Thus, one has B<MORE>, B<LESS>, and B<GZIP>.  Such usage is considered "
"mistaken, and to be avoided in new programs.  The authors of I<gzip> should "
"consider renaming their option to B<GZIP_OPT>."
msgstr ""
"名前空間が汚染される危険性も存在する。 I<make> や I<autoconf> のようなプログ"
"ラムでは、デフォルトのユーティリティを 環境にある似たような名前の変数で上書き"
"することができる (通常はすべて大文字の変数を用いる)。 すなわち、利用したい C "
"コンパイラは B<CC> で選択できる。また同様に B<MAKE>, B<AR>, B<AS>, B<FC>, "
"B<LD>, B<LEX>, B<RM>, B<YACC> なども用いることができる。 ところが一方では、こ"
"のような変数を (パス名ではなく)  プログラムに対するオプションとして扱うような"
"流儀も存在してきた。 例えば B<MORE>, B<LESS>, B<GZIP> などがそうである。 この"
"ような利用法は間違っていると考えるべきで、 新しいプログラムでは避けるべきであ"
"る。 I<gzip> の作者たちは、オプションを与える環境変数を B<GZIP_OPT> に改名す"
"ることを考えるほうがよい。"

#. type: Plain text
#: build/C/man7/environ.7:299
msgid ""
"B<bash>(1), B<csh>(1), B<env>(1), B<login>(1), B<printenv>(1), B<sh>(1), "
"B<tcsh>(1), B<execve>(2), B<clearenv>(3), B<exec>(3), B<getenv>(3), "
"B<putenv>(3), B<setenv>(3), B<unsetenv>(3), B<locale>(7), B<ld.so>(8), "
"B<pam_env>(8)"
msgstr ""
"B<bash>(1), B<csh>(1), B<env>(1), B<login>(1), B<printenv>(1), B<sh>(1), "
"B<tcsh>(1), B<execve>(2), B<clearenv>(3), B<exec>(3), B<getenv>(3), "
"B<putenv>(3), B<setenv>(3), B<unsetenv>(3), B<locale>(7), B<ld.so>(8), "
"B<pam_env>(8)"

#. type: TH
#: build/C/man3/euidaccess.3:25
#, no-wrap
msgid "EUIDACCESS"
msgstr "EUIDACCESS"

#. type: Plain text
#: build/C/man3/euidaccess.3:28
msgid "euidaccess, eaccess - check effective user's permissions for a file"
msgstr ""
"euidaccess, eaccess - ファイルへのアクセス権を実効ユーザーでチェックする"

#. type: Plain text
#: build/C/man3/euidaccess.3:32
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>             /* feature_test_macros(7) 参照 */\n"
"B<#include E<lt>unistd.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/euidaccess.3:35
#, no-wrap
msgid ""
"B<int euidaccess(const char *>I<pathname>B<, int >I<mode>B<);>\n"
"B<int eaccess(const char *>I<pathname>B<, int >I<mode>B<);>\n"
msgstr ""
"B<int euidaccess(const char *>I<pathname>B<, int >I<mode>B<);>\n"
"B<int eaccess(const char *>I<pathname>B<, int >I<mode>B<);>\n"

#. type: Plain text
#: build/C/man3/euidaccess.3:47
msgid ""
"Like B<access>(2), B<euidaccess>()  checks permissions and existence of the "
"file identified by its argument I<pathname>.  However, whereas B<access>(2)  "
"performs checks using the real user and group identifiers of the process, "
"B<euidaccess>()  uses the effective identifiers."
msgstr ""
"B<access>(2)  と同様、 B<euidaccess>()  は引数 I<pathname> で指定されたファ"
"イルの許可 (permission) と存在のチェックを行う。 B<access>(2)  はプロセスの"
"実 (real) ユーザーID / 実グループID を用いてチェックを行うのに対し、 "
"B<euidaccess>()  は実効 (effective) ID を用いる。"

#. type: Plain text
#: build/C/man3/euidaccess.3:53
msgid ""
"I<mode> is a mask consisting of one or more of B<R_OK>, B<W_OK>, B<X_OK>, "
"and B<F_OK>, with the same meanings as for B<access>(2)."
msgstr ""
"I<mode> は B<R_OK>, B<W_OK>, B<X_OK>, B<F_OK> の一つ以上から構成されるマスク"
"である。 B<R_OK>, B<W_OK>, B<X_OK>, B<F_OK> は B<access>(2)  と同じ意味を持"
"つ。"

#. type: Plain text
#: build/C/man3/euidaccess.3:58
msgid ""
"B<eaccess>()  is a synonym for B<euidaccess>(), provided for compatibility "
"with some other systems."
msgstr ""
"B<eaccess>()  は B<euidaccess>()  の同義語であり、他のいくつかのシステムとの"
"互換性のために提供されている。"

#. type: Plain text
#: build/C/man3/euidaccess.3:66
msgid ""
"On success (all requested permissions granted), zero is returned.  On error "
"(at least one bit in I<mode> asked for a permission that is denied, or some "
"other error occurred), -1 is returned, and I<errno> is set appropriately."
msgstr ""
"成功した場合 (要求した全てについて許可が得られたら)、ゼロが返される。 エラー"
"の場合 (I<mode> の少なくとも一つのビットで要求した許可がなかった場合や、 他の"
"エラーが起こった場合)、-1 が返され、 I<errno> が適切に設定される。"

#. type: Plain text
#: build/C/man3/euidaccess.3:69
msgid "As for B<access>(2)."
msgstr "B<access>(2)  と同じ。"

#. type: Plain text
#: build/C/man3/euidaccess.3:73
msgid "The B<eaccess>()  function was added to glibc in version 2.4."
msgstr "B<eaccess>()  関数は glibc のバージョン 2.4 で追加された。"

#. type: tbl table
#: build/C/man3/euidaccess.3:84
#, no-wrap
msgid ""
"B<euidaccess>(),\n"
"B<eaccess>()"
msgstr ""
"B<euidaccess>(),\n"
"B<eaccess>()"

#.  e.g., FreeBSD 6.1.
#. type: Plain text
#: build/C/man3/euidaccess.3:92
msgid ""
"These functions are nonstandard.  Some other systems have an B<eaccess>()  "
"function."
msgstr ""
"これらの関数は非標準である。 他のいくつかのシステムには B<eaccess>()  関数が"
"ある。"

#. type: Plain text
#: build/C/man3/euidaccess.3:99
msgid ""
"I<Warning>: Using this function to check a process's permissions on a file "
"before performing some operation based on that information leads to race "
"conditions: the file permissions may change between the two steps.  "
"Generally, it is safer just to attempt the desired operation and handle any "
"permission error that occurs."
msgstr ""
"I<警告>: \n"
"ある操作を実行する前にこの関数を使ってファイルに対するプロセスのアクセス許可"
"を\n"
"確認してから、その情報に基づいて操作を行うと、競合条件が発生する可能性があ"
"る。\n"
"これは二つの操作の間でファイルのアクセス許可が変化する場合があるからであ"
"る。\n"
"一般的には、必要な操作のみを行い、その際に発生したアクセス許可に関するエラー"
"を\n"
"処理する方が安全である。"

#. type: Plain text
#: build/C/man3/euidaccess.3:107
msgid ""
"This function always dereferences symbolic links.  If you need to check the "
"permissions on a symbolic link, use B<faccessat>(2)  with the flags "
"B<AT_EACCESS> and B<AT_SYMLINK_NOFOLLOW>."
msgstr ""
"この関数は常にシンボリックリンクの展開を行う。\n"
"シンボリックリンクのアクセス許可を確認する必要がある場合は、\n"
"フラグ B<AT_EACCESS> と B<AT_SYMLINK_NOFOLLOW> を付けて\n"
"B<faccessat>(2) を使うこと。"

#. type: Plain text
#: build/C/man3/euidaccess.3:118
msgid ""
"B<access>(2), B<chmod>(2), B<chown>(2), B<faccessat>(2), B<open>(2), "
"B<setgid>(2), B<setuid>(2), B<stat>(2), B<credentials>(7), "
"B<path_resolution>(7)"
msgstr ""
"B<access>(2), B<chmod>(2), B<chown>(2), B<faccessat>(2), B<open>(2), "
"B<setgid>(2), B<setuid>(2), B<stat>(2), B<credentials>(7), "
"B<path_resolution>(7)"

#. type: TH
#: build/C/man3/exec.3:41
#, no-wrap
msgid "EXEC"
msgstr "EXEC"

#. type: Plain text
#: build/C/man3/exec.3:44
msgid "execl, execlp, execle, execv, execvp, execvpe - execute a file"
msgstr "execl, execlp, execle, execv, execvp, execvpe - ファイルを実行する"

#. type: Plain text
#: build/C/man3/exec.3:49
#, no-wrap
msgid "B<extern char **environ;>\n"
msgstr "B<extern char **environ;>\n"

#. type: Plain text
#: build/C/man3/exec.3:60
#, no-wrap
msgid ""
"B<int execl(const char *>I<pathname>B<, const char *>I<arg>B<, ...>\n"
"B</* (char  *) NULL */);>\n"
"B<int execlp(const char *>I<file>B<, const char *>I<arg>B<, ...>\n"
"B</* (char  *) NULL */);>\n"
"B<int execle(const char *>I<pathname>B<, const char *>I<arg>B<, ...>\n"
"B<                /*, (char *) NULL, char *const >I<envp>B<[] */);>\n"
"B<int execv(const char *>I<pathname>B<, char *const >I<argv>B<[]);>\n"
"B<int execvp(const char *>I<file>B<, char *const >I<argv>B<[]);>\n"
"B<int execvpe(const char *>I<file>B<, char *const >I<argv>B<[],>\n"
"B<                char *const >I<envp>B<[]);>\n"
msgstr ""
"B<int execl(const char *>I<pathname>B<, const char *>I<arg>B<, ...>\n"
"B</* (char  *) NULL */);>\n"
"B<int execlp(const char *>I<file>B<, const char *>I<arg>B<, ...>\n"
"B</* (char  *) NULL */);>\n"
"B<int execle(const char *>I<pathname>B<, const char *>I<arg>B<, ...>\n"
"B<                /*, (char *) NULL, char *const >I<envp>B<[] */);>\n"
"B<int execv(const char *>I<pathname>B<, char *const >I<argv>B<[]);>\n"
"B<int execvp(const char *>I<file>B<, char *const >I<argv>B<[]);>\n"
"B<int execvpe(const char *>I<file>B<, char *const >I<argv>B<[],>\n"
"B<                char *const >I<envp>B<[]);>\n"

#. type: Plain text
#: build/C/man3/exec.3:69
msgid "B<execvpe>(): _GNU_SOURCE"
msgstr "B<execvpe>(): _GNU_SOURCE"

#. type: Plain text
#: build/C/man3/exec.3:79
#, fuzzy
#| msgid ""
#| "The B<exec>()  family of functions replaces the current process image "
#| "with a new process image.  The functions described in this manual page "
#| "are front-ends for B<execve>(2).  (See the manual page for B<execve>(2)  "
#| "for further details about the replacement of the current process image.)"
msgid ""
"The B<exec>()  family of functions replaces the current process image with a "
"new process image.  The functions described in this manual page are layered "
"on top of B<execve>(2).  (See the manual page for B<execve>(2)  for further "
"details about the replacement of the current process image.)"
msgstr ""
"B<exec>()  ファミリーの関数は現在のプロセスイメージを新しいプロセスイメージで"
"置き 換える。このマニュアルで説明されている関数は B<execve>(2)  のフロントエ"
"ンドである。 (現在のプロセスイメージの置き換えについての詳細は B<execve>(2)  "
"のマニュアルを参照)"

#. type: Plain text
#: build/C/man3/exec.3:82
msgid ""
"The initial argument for these functions is the name of a file that is to be "
"executed."
msgstr "これらの関数の最初の引数は、実行されるファイルの名前である。"

#. type: Plain text
#: build/C/man3/exec.3:85
msgid ""
"The functions can be grouped based on the letters following the \"exec\" "
"prefix."
msgstr ""

#. type: SS
#: build/C/man3/exec.3:85
#, no-wrap
msgid "l - execl(), execlp(), execle()"
msgstr "l - execl(), execlp(), execle()"

#. type: Plain text
#: build/C/man3/exec.3:102
msgid ""
"The I<const char\\ *arg> and subsequent ellipses can be thought of as "
"I<arg0>, I<arg1>, \\&..., I<argn>.  Together they describe a list of one or "
"more pointers to null-terminated strings that represent the argument list "
"available to the executed program.  The first argument, by convention, "
"should point to the filename associated with the file being executed.  The "
"list of arguments I<must> be terminated by a null pointer, and, since these "
"are variadic functions, this pointer must be cast I<(char\\ *) NULL>."
msgstr ""
"I<const char\\ *arg> とそれに続く省略部分は I<arg0>, I<arg1>, \\&..., "
"I<argn> とみなされる。 これらには、実行されるプログラムで利用可能な引数のリ"
"ストを指定する (引数のリストは ヌルで終端された文字列へのポインターから構成"
"される)。 慣習として、最初の引数は、実行されるファイル名 へのポインターにす"
"る。引数のリストは必ず NULL で終わらなければならず、これらの関数は可変長引"
"数関数なので、 このポインターは I<(char\\ *) NULL> とキャストしなければなら"
"ない。"

#. type: Plain text
#: build/C/man3/exec.3:106
msgid ""
"By contrast with the 'l' functions, the 'v' functions (below) specify the "
"command-line arguments of the executed program as a vector."
msgstr ""

#. type: SS
#: build/C/man3/exec.3:106
#, no-wrap
msgid "v - execv(), execvp(), execvpe()"
msgstr " v - execv(), execvp(), execvpe()"

#. type: Plain text
#: build/C/man3/exec.3:116
#, fuzzy
#| msgid ""
#| "The B<execv>(), B<execvp>(), and B<execvpe>()  functions provide an array "
#| "of pointers to null-terminated strings that represent the argument list "
#| "available to the new program.  The first argument, by convention, should "
#| "point to the filename associated with the file being executed.  The array "
#| "of pointers I<must> be terminated by a null pointer."
msgid ""
"The I<char\\ *const argv[]> argument is an array of pointers to null-"
"terminated strings that represent the argument list available to the new "
"program.  The first argument, by convention, should point to the filename "
"associated with the file being executed.  The array of pointers I<must> be "
"terminated by a null pointer."
msgstr ""
"関数 B<execv>(), B<execvp>(), B<execvpe>()  は、利用可能な引数リスト (ヌル"
"で終端された文字列への ポインターの配列) を新しいプログラムに渡す。 慣習とし"
"て、最初の引数は実行されるファイル名へ のポインターにする。ポインターの配列"
"は必ず NULL で終わらなければならない。"

#. type: SS
#: build/C/man3/exec.3:116
#, no-wrap
msgid "e - execle(), execvpe()"
msgstr " e - execle(), execvpe()"

#. type: Plain text
#: build/C/man3/exec.3:124
#, fuzzy
#| msgid ""
#| "The B<execle>()  and B<execvpe>()  functions allow the caller to specify "
#| "the environment of the executed program via the argument I<envp>.  The "
#| "I<envp> argument is an array of pointers to null-terminated strings and "
#| "I<must> be terminated by a null pointer.  The other functions take the "
#| "environment for the new process image from the external variable "
#| "I<environ> in the calling process."
msgid ""
"The environment of the caller is specified via the argument I<envp>.  The "
"I<envp> argument is an array of pointers to null-terminated strings and "
"I<must> be terminated by a null pointer."
msgstr ""
"関数 B<execle>(), B<execvpe>()  では、呼び出し元が引数 I<envp> 経由実行され"
"るプログラムの環境を指定することができる。 I<envp> 引数は、NULL で終端され"
"た文字列へのポインターの配列であり、ヌルポインターで終わらなければならない。 "
"他の関数では、呼び出し元のプロセスの外部変数 B<environ> から新しいプロセス用"
"の環境を与える。"

#. type: Plain text
#: build/C/man3/exec.3:132
msgid ""
"All other B<exec>()  functions (which do not include 'e' in the suffix)  "
"take the environment for the new process image from the external variable "
"I<environ> in the calling process."
msgstr ""

#. type: SS
#: build/C/man3/exec.3:132
#, no-wrap
msgid "p - execlp(), execvp(), execvpe()"
msgstr "p - execlp(), execvp(), execvpe()"

#. type: Plain text
#: build/C/man3/exec.3:146
#, fuzzy
#| msgid ""
#| "The B<execlp>(), B<execvp>(), and B<execvpe>()  functions duplicate the "
#| "actions of the shell in searching for an executable file if the specified "
#| "filename does not contain a slash (/) character.  The file is sought in "
#| "the colon-separated list of directory pathnames specified in the B<PATH> "
#| "environment variable.  If this variable isn't defined, the path list "
#| "defaults to the current directory followed by the list of directories "
#| "returned by I<confstr(_CS_PATH)>.  (This B<confstr>(3)  call typically "
#| "returns the value \"/bin:/usr/bin\".)"
msgid ""
"These functions duplicate the actions of the shell in searching for an "
"executable file if the specified filename does not contain a slash (/) "
"character.  The file is sought in the colon-separated list of directory "
"pathnames specified in the B<PATH> environment variable.  If this variable "
"isn't defined, the path list defaults to a list that includes the "
"directories returned by I<confstr(_CS_PATH)> (which typically returns the "
"value \"/bin:/usr/bin\")  and possibly also the current working directory; "
"see NOTES for further details."
msgstr ""
"関数 B<execlp>(), B<execvp>(), B<execvpe>()  は、指定されたファイル名がスラッ"
"シュ (/) を含んでいない場合、 シェルと同じ動作で実行可能なファイルを探索す"
"る。 ファイルの検索は、環境変数 B<PATH> で指定されたコロン区切りのディレクト"
"リのパス名のリストを対象に行われる。 この変数が定義されていない場合、パス名の"
"リストのデフォルト値として、 カレントディレクトリの後ろに、 "
"I<confstr(_CS_PATH)> が返すディレクトリのリストをつなげた値が使用される (こ"
"の B<confstr>(3)  の呼び出しでは通常 \"/bin:/usr/bin\" が返される)。"

#. type: Plain text
#: build/C/man3/exec.3:150
msgid ""
"If the specified filename includes a slash character, then B<PATH> is "
"ignored, and the file at the specified pathname is executed."
msgstr ""
"指定されたファイル名がスラッシュを含む場合、 B<PATH> は無視され、指定されたパ"
"ス名のファイルが実行される。"

#. type: Plain text
#: build/C/man3/exec.3:152
msgid "In addition, certain errors are treated specially."
msgstr "さらに、いくつかのエラーは特別に処理される。"

#. type: Plain text
#: build/C/man3/exec.3:163
msgid ""
"If permission is denied for a file (the attempted B<execve>(2)  failed with "
"the error B<EACCES>), these functions will continue searching the rest of "
"the search path.  If no other file is found, however, they will return with "
"I<errno> set to B<EACCES>."
msgstr ""
"ファイルが実行ファイルでない場合 (このとき呼び出そうとした B<execve>(2)  はエ"
"ラー B<EACCES> で失敗する)、これらの関数は残りの検索パスの検索を続ける。 他に"
"ファイルが見つからなくなった場合 I<errno> に B<EACCES> を設定し復帰する。"

#. type: Plain text
#: build/C/man3/exec.3:172
msgid ""
"If the header of a file isn't recognized (the attempted B<execve>(2)  failed "
"with the error B<ENOEXEC>), these functions will execute the shell (I</bin/"
"sh>)  with the path of the file as its first argument.  (If this attempt "
"fails, no further searching is done.)"
msgstr ""
"ファイルのヘッダーが実行形式として認識できない場合 (このとき呼び出そうとした "
"B<execve>(2)  はエラー B<ENOEXEC> で失敗する)、これらの関数はそのファイルを最"
"初の引数としたシェル (I</bin/sh>)  を実行する (これにも失敗した場合、これ以"
"上の検索は行われない)。"

#. type: Plain text
#: build/C/man3/exec.3:178
msgid ""
"All other B<exec>()  functions (which do not include 'p' in the suffix)  "
"take as their first argument a (relative or absolute) pathname that "
"identifies the program to be executed."
msgstr ""

#. type: Plain text
#: build/C/man3/exec.3:185
msgid ""
"The B<exec>()  functions return only if an error has occurred.  The return "
"value is -1, and I<errno> is set to indicate the error."
msgstr ""
"B<exec>()  群の関数が復帰するのは、エラーが発生した場合のみである。 返り値は "
"-1 で、 I<errno> にエラーの内容がセットされる。"

#. type: Plain text
#: build/C/man3/exec.3:190
msgid ""
"All of these functions may fail and set I<errno> for any of the errors "
"specified for B<execve>(2)."
msgstr ""
"これら全ての関数は失敗する場合がある。その場合、 B<execve>(2)  に対して規定さ"
"れたエラーが I<errno> に設定される。"

#. type: Plain text
#: build/C/man3/exec.3:194
msgid "The B<execvpe>()  function first appeared in glibc 2.11."
msgstr "B<execvpe>()  関数は glibc 2.11 で初めて登場した。"

#. type: tbl table
#: build/C/man3/exec.3:206
#, no-wrap
msgid ""
"B<execl>(),\n"
"B<execle>(),\n"
"B<execv>()"
msgstr ""
"B<execl>(),\n"
"B<execle>(),\n"
"B<execv>()"

#. type: tbl table
#: build/C/man3/exec.3:211
#, no-wrap
msgid ""
"B<execlp>(),\n"
"B<execvp>(),\n"
"B<execvpe>()"
msgstr ""
"B<execlp>(),\n"
"B<execvp>(),\n"
"B<execvpe>()"

#. type: tbl table
#: build/C/man3/exec.3:211 build/C/man3/getcwd.3:224 build/C/man3/sysconf.3:381
#, no-wrap
msgid "MT-Safe env"
msgstr "MT-Safe env"

#. type: Plain text
#: build/C/man3/exec.3:219
msgid "The B<execvpe>()  function is a GNU extension."
msgstr "B<execvpe>()  関数は GNU による拡張である。"

#.  glibc commit 1eb8930608705702d5746e5491bab4e4429fcb83
#. type: Plain text
#: build/C/man3/exec.3:241
msgid ""
"The default search path (used when the environment does not contain the "
"variable B<PATH>)  shows some variation across systems.  It generally "
"includes I</bin> and I</usr/bin> (in that order) and may also include the "
"current working directory.  On some other systems, the current working is "
"included after I</bin> and I</usr/bin>, as an anti-Trojan-horse measure.  "
"The glibc implementation long followed the traditional default where the "
"current working directory is included at the start of the search path.  "
"However, some code refactoring during the development of glibc 2.24 caused "
"the current working directory to be dropped altogether from the default "
"search path.  This accidental behavior change is considered mildly "
"beneficial, and won't be reverted."
msgstr ""

#. type: Plain text
#: build/C/man3/exec.3:255
msgid ""
"The behavior of B<execlp>()  and B<execvp>()  when errors occur while "
"attempting to execute the file is historic practice, but has not "
"traditionally been documented and is not specified by the POSIX standard.  "
"BSD (and possibly other systems) do an automatic sleep and retry if "
"B<ETXTBSY> is encountered.  Linux treats it as a hard error and returns "
"immediately."
msgstr ""
"ファイルを実行しようとしている間にエラーが発生した時の B<execlp>()  と "
"B<execvp>()  のふるまいについて歴史的な慣習はあるが、伝統的に文書として記載さ"
"れておらず、 POSIX 標準でも規定されていない。BSD (またおそらく他のシステム) "
"では、 B<ETXTBSY> が発生した場合、自動的に中断 (sleep) し再試行を行う。 "
"Linux はそれをハードエラーとして取り扱い即座に復帰する。"

#. type: Plain text
#: build/C/man3/exec.3:267
msgid ""
"Traditionally, the functions B<execlp>()  and B<execvp>()  ignored all "
"errors except for the ones described above and B<ENOMEM> and B<E2BIG>, upon "
"which they returned.  They now return if any error other than the ones "
"described above occurs."
msgstr ""
"伝統的に、関数 B<execlp>()  と B<execvp>()  は、上で説明したエラーと、これら "
"2 つの関数自身が返す B<ENOMEM> と B<E2BIG> 以外の全てのエラーを無視していた"
"が、 今では、上で説明した以外のエラーが発生した場合でも、 返ってくるよう変更"
"された。"

#.  https://sourceware.org/bugzilla/show_bug.cgi?id=19534
#. type: Plain text
#: build/C/man3/exec.3:279
msgid ""
"Before glibc 2.24, B<execl>()  and B<execle>()  employed B<realloc>(3)  "
"internally and were consequently not async-signal-safe, in violation of the "
"requirements of POSIX.1.  This was fixed in glibc 2.24."
msgstr ""

#. type: SS
#: build/C/man3/exec.3:279
#, no-wrap
msgid "Architecture-specific details"
msgstr "アーキテクチャー固有の詳細"

#. type: Plain text
#: build/C/man3/exec.3:290
msgid ""
"On sparc and sparc64, B<execv>()  is provided as a system call by the kernel "
"(with the prototype shown above)  for compatibility with SunOS.  This "
"function is I<not> employed by the B<execv>()  wrapper function on those "
"architectures."
msgstr ""

#. type: Plain text
#: build/C/man3/exec.3:299
msgid ""
"B<sh>(1), B<execve>(2), B<execveat>(2), B<fork>(2), B<ptrace>(2), "
"B<fexecve>(3), B<system>(3), B<environ>(7)"
msgstr ""
" B<sh>(1), B<execve>(2), B<execveat>(2), B<fork>(2), B<ptrace>(2), "
"B<fexecve>(3), B<system>(3), B<environ>(7)"

#. type: TH
#: build/C/man2/execve.2:37
#, no-wrap
msgid "EXECVE"
msgstr "EXECVE"

#. type: Plain text
#: build/C/man2/execve.2:40
msgid "execve - execute program"
msgstr "execve - プログラムを実行する"

#. type: Plain text
#: build/C/man2/execve.2:44
msgid "B<int execve(const char *>I<pathname>B<, char *const >I<argv>B<[],>"
msgstr " B<int execve(const char *>I<pathname>B<, char *const >I<argv>B<[],>"

#. type: Plain text
#: build/C/man2/execve.2:46
msgid "B< char *const >I<envp>B<[]);>"
msgstr "B< char *const >I<envp>B<[]);>"

#. type: Plain text
#: build/C/man2/execve.2:52
msgid ""
"B<execve>()  executes the program referred to by I<pathname>.  This causes "
"the program that is currently being run by the calling process to be "
"replaced with a new program, with newly initialized stack, heap, and "
"(initialized and uninitialized) data segments."
msgstr ""

#. type: Plain text
#: build/C/man2/execve.2:55
msgid ""
"I<pathname> must be either a binary executable, or a script starting with a "
"line of the form:"
msgstr ""
"I<pathname> は、バイナリ実行形式か、 以下の形式の行で始まるスクリプトでなけれ"
"ばならない。"

#. type: Plain text
#: build/C/man2/execve.2:59 build/C/man2/execve.2:325
#, no-wrap
msgid "B<#!>I<interpreter >[optional-arg]\n"
msgstr "B<#!>I<interpreter >[optional-arg]\n"

#. type: Plain text
#: build/C/man2/execve.2:63
msgid "For details of the latter case, see \"Interpreter scripts\" below."
msgstr "後者の詳細は、後ろの「インタープリタースクリプト」の節を参照のこと。"

#. type: Plain text
#: build/C/man2/execve.2:75
#, fuzzy
#| msgid ""
#| "I<argv> is an array of argument strings passed to the new program.  By "
#| "convention, the first of these strings should contain the filename "
#| "associated with the file being executed.  I<envp> is an array of strings, "
#| "conventionally of the form B<key=value>, which are passed as environment "
#| "to the new program.  Both I<argv> and I<envp> must be terminated by a "
#| "null pointer.  The argument vector and environment can be accessed by the "
#| "called program's main function, when it is defined as:"
msgid ""
"I<argv> is an array of pointers to strings passed to the new program as its "
"command-line arguments.  By convention, the first of these strings (i.e., "
"I<argv[0]>)  should contain the filename associated with the file being "
"executed.  The I<argv> array must be terminated by a NULL pointer.  (Thus, "
"in the new program, I<argv[argc]> will be NULL.)"
msgstr ""
"I<argv> は新しいプログラムに渡される引数文字列の配列である。\n"
"慣例では、引数文字列の最初の要素には実行されたファイルに関連付けられた\n"
"ファイル名を含めることになっている。\n"
"I<envp> は文字列の配列であり、伝統的に B<key=value> の形式をしており、\n"
"新しいプログラムの環境変数として渡される。\n"
"I<argv> と I<envp> はいずれものヌルポインターで終わっている必要がある。\n"
"引数配列と環境変数は、呼び出されたプログラムの main 関数を\n"
"以下のように定義することによってアクセス可能になる。"

#. type: Plain text
#: build/C/man2/execve.2:81
msgid ""
"I<envp> is an array of pointers to strings, conventionally of the form "
"B<key=value>, which are passed as the environment of the new program.  The "
"I<envp> array must be terminated by a NULL pointer."
msgstr ""

#. type: Plain text
#: build/C/man2/execve.2:84
msgid ""
"The argument vector and environment can be accessed by the new program's "
"main function, when it is defined as:"
msgstr ""

#. type: Plain text
#: build/C/man2/execve.2:88
#, no-wrap
msgid "int main(int argc, char *argv[], char *envp[])\n"
msgstr "int main(int argc, char *argv[], char *envp[])\n"

#. type: Plain text
#: build/C/man2/execve.2:96
msgid ""
"Note, however, that the use of a third argument to the main function is not "
"specified in POSIX.1; according to POSIX.1, the environment should be "
"accessed via the external variable B<environ>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/execve.2:101
#, fuzzy
#| msgid ""
#| "B<execve>()  does not return on success, and the text, data, bss, and "
#| "stack of the calling process are overwritten by that of the program "
#| "loaded."
msgid ""
"B<execve>()  does not return on success, and the text, initialized data, "
"uninitialized data (bss), and stack of the calling process are overwritten "
"according to the contents of the newly loaded program."
msgstr ""
"成功した場合、 B<execve>()  は返らない。 そして、呼び出し元のプロセスの "
"text, data, bss, スタックは、 読み込まれたプログラムによって上書きされる。"

#. type: Plain text
#: build/C/man2/execve.2:105
msgid ""
"If the current program is being ptraced, a B<SIGTRAP> signal is sent to it "
"after a successful B<execve>()."
msgstr ""
"元のプログラムが ptrace されている場合、 B<execve>()  が成功した後に そのプロ"
"グラムに B<SIGTRAP> シグナルが送られる。"

#. type: Plain text
#: build/C/man2/execve.2:113
msgid ""
"If the set-user-ID bit is set on the program file referred to by "
"I<pathname>, then the effective user ID of the calling process is changed to "
"that of the owner of the program file.  Similarly, if the set-group-ID bit "
"is set on the program file, then the effective group ID of the calling "
"process is set to the group of the program file."
msgstr "I<pathname> で参照されるプログラムファイルに set-user-ID ビットが設定されている場合、呼び出したプロセスの実効 (effective) ユーザー ID は プログラムファイルの所有者 (owner) に変更される。 同様に、プログラムファイルに set-group-ID ビットが設定されていた場合、 呼び出したプロセスの有効グループ ID は プログラムファイルのグループに変更される。"

#. type: Plain text
#: build/C/man2/execve.2:118
msgid ""
"The aforementioned transformations of the effective IDs are I<not> performed "
"(i.e., the set-user-ID and set-group-ID bits are ignored)  if any of the "
"following is true:"
msgstr ""

#. type: Plain text
#: build/C/man2/execve.2:123
msgid ""
"the I<no_new_privs> attribute is set for the calling thread (see "
"B<prctl>(2));"
msgstr ""

#. type: Plain text
#: build/C/man2/execve.2:131
msgid ""
"the underlying filesystem is mounted I<nosuid> (the B<MS_NOSUID> flag for "
"B<mount>(2)); or"
msgstr ""

#. type: Plain text
#: build/C/man2/execve.2:133
#, fuzzy
#| msgid "The calling process has no controlling terminal."
msgid "the calling process is being ptraced."
msgstr "呼び出し元プロセスには制御端末がない。"

#. type: Plain text
#: build/C/man2/execve.2:137
msgid ""
"The capabilities of the program file (see B<capabilities>(7))  are also "
"ignored if any of the above are true."
msgstr ""

#. type: Plain text
#: build/C/man2/execve.2:142
msgid ""
"The effective user ID of the process is copied to the saved set-user-ID; "
"similarly, the effective group ID is copied to the saved set-group-ID.  This "
"copying takes place after any effective ID changes that occur because of the "
"set-user-ID and set-group-ID mode bits."
msgstr ""
"プロセスの実効ユーザー ID は保存 (saved) set-user-ID にコピーされる。 同様"
"に、実効グループ ID は保存 set-group-ID にコピーされる。 このコピーは、set-"
"user-ID / set-group-ID モードビットにより発生する 実効 ID の変更後に行われ"
"る。"

#. type: Plain text
#: build/C/man2/execve.2:146
msgid ""
"The process's real UID and real GID, as well its supplementary group IDs, "
"are unchanged by a call to B<execve>()."
msgstr ""

#. type: Plain text
#: build/C/man2/execve.2:154
msgid ""
"If the executable is an a.out dynamically linked binary executable "
"containing shared-library stubs, the Linux dynamic linker B<ld.so>(8)  is "
"called at the start of execution to bring needed shared objects into memory "
"and link the executable with them."
msgstr ""
"実行ファイルが動的リンクされた a.out 実行形式で、共有ライブラリの スタブを含"
"むものだった場合、実行の開始時に Linux の ダイナミックリンカー B<ld.so>(8)  "
"が呼び出され、必要な共有オブジェクトをメモリーに読み込んでリンクを行う。"

#. type: Plain text
#: build/C/man2/execve.2:163
msgid ""
"If the executable is a dynamically linked ELF executable, the interpreter "
"named in the PT_INTERP segment is used to load the needed shared objects.  "
"This interpreter is typically I</lib/ld-linux.so.2> for binaries linked with "
"glibc (see B<ld-linux.so>(8))."
msgstr ""
"実行ファイルがダイナミックリンクされた ELF 実行形式だった場合、\n"
"PT_INTERP セグメントに指定されたインタープリターが必要な 共有オブジェクト\n"
"(shared library) を読み込むのに使用される。\n"
"通常、インタープリターは glibc をリンクしたバイナリでは\n"
"I</lib/ld-linux.so.2> である。 (B<ld-linux.so>(8) を参照)"

#. type: SS
#: build/C/man2/execve.2:163
#, no-wrap
msgid "Effect on process attributes"
msgstr ""

#. type: Plain text
#: build/C/man2/execve.2:167
msgid ""
"All process attributes are preserved during an B<execve>(), except the "
"following:"
msgstr ""
"以下に示す以外のすべてのプロセス属性は B<execve>()  の前後で保持される。"

#. type: Plain text
#: build/C/man2/execve.2:171
msgid ""
"The dispositions of any signals that are being caught are reset to the "
"default (B<signal>(7))."
msgstr ""
"捕捉されたシグナルの処理方法 (disposition) は デフォルト動作にリセットされる "
"(B<signal>(7))。"

#. type: Plain text
#: build/C/man2/execve.2:174
msgid "Any alternate signal stack is not preserved (B<sigaltstack>(2))."
msgstr "代替シグナルスタックはどれも保持されない (B<sigaltstack>(2))。"

#. type: Plain text
#: build/C/man2/execve.2:177
msgid "Memory mappings are not preserved (B<mmap>(2))."
msgstr "メモリーマッピングは保持されない (B<mmap>(2))。"

#. type: Plain text
#: build/C/man2/execve.2:180
msgid "Attached System\\ V shared memory segments are detached (B<shmat>(2))."
msgstr ""
"付加された (attached) System\\ V 共有メモリーセグメントは分離される "
"(B<shmat>(2))。"

#. type: Plain text
#: build/C/man2/execve.2:183
msgid "POSIX shared memory regions are unmapped (B<shm_open>(3))."
msgstr "POSIX 共有メモリー領域はマッピングを解除される (B<shm_open>(3))。"

#. type: Plain text
#: build/C/man2/execve.2:186
msgid "Open POSIX message queue descriptors are closed (B<mq_overview>(7))."
msgstr ""
"オープンされた POSIX メッセージキューディスクリプターはクローズされる "
"(B<mq_overview>(7))。"

#. type: Plain text
#: build/C/man2/execve.2:189
msgid "Any open POSIX named semaphores are closed (B<sem_overview>(7))."
msgstr ""
"オープンされた POSIX 名前付きセマフォはいずれもクローズされる "
"(B<sem_overview>(7))。"

#. type: Plain text
#: build/C/man2/execve.2:192
msgid "POSIX timers are not preserved (B<timer_create>(2))."
msgstr "POSIX タイマーは保持されない (B<timer_create>(2))。"

#. type: Plain text
#: build/C/man2/execve.2:195
msgid "Any open directory streams are closed (B<opendir>(3))."
msgstr ""
"オープンされたディレクトリストリームはいずれもクローズされる "
"(B<opendir>(3))。"

#. type: Plain text
#: build/C/man2/execve.2:199
msgid "Memory locks are not preserved (B<mlock>(2), B<mlockall>(2))."
msgstr "メモリーロックは保持されない (B<mlock>(2), B<mlockall>(2))。"

#. type: Plain text
#: build/C/man2/execve.2:203
msgid "Exit handlers are not preserved (B<atexit>(3), B<on_exit>(3))."
msgstr "終了 (exit) ハンドラーは保持されない (B<atexit>(3), B<on_exit>(3))。"

#. type: Plain text
#: build/C/man2/execve.2:206
msgid ""
"The floating-point environment is reset to the default (see B<fenv>(3))."
msgstr "浮動小数点関連の環境はデフォルトにリセットされる (B<fenv>(3)  参照)。"

#. type: Plain text
#: build/C/man2/execve.2:212
msgid ""
"The process attributes in the preceding list are all specified in POSIX.1.  "
"The following Linux-specific process attributes are also not preserved "
"during an B<execve>():"
msgstr ""
"上記のリストのプロセス属性はいずれも POSIX.1 で規定されている。 以下に示す "
"Linux 固有のプロセス属性も B<execve>()  の前後で保持されない。"

#. type: Plain text
#: build/C/man2/execve.2:229
msgid ""
"The process's \"dumpable\" attribute is set to the value 1, unless a set-"
"user-ID program, a set-group-ID program, or a program with capabilities is "
"being executed, in which case the dumpable flag may instead be reset to the "
"value in I</proc/sys/fs/suid_dumpable>, in the circumstances described under "
"B<PR_SET_DUMPABLE> in B<prctl>(2).  Note that changes to the \"dumpable\" "
"attribute may cause ownership of files in the process's I</proc/[pid]> "
"directory to change to I<root:root>, as described in B<proc>(5)."
msgstr ""

#. type: Plain text
#: build/C/man2/execve.2:234
msgid "The B<prctl>(2)  B<PR_SET_KEEPCAPS> flag is cleared."
msgstr "B<prctl>(2)  の B<PR_SET_KEEPCAPS> フラグはクリアされる。"

#. type: Plain text
#: build/C/man2/execve.2:241
msgid ""
"(Since Linux 2.4.36 / 2.6.23)  If a set-user-ID or set-group-ID program is "
"being executed, then the parent death signal set by B<prctl>(2)  "
"B<PR_SET_PDEATHSIG> flag is cleared."
msgstr ""
"(Linux 2.4.36 以降 / 2.6.23 以降)  set-user-ID や set-group-ID されたプログラ"
"ムが実行された場合、 B<prctl>(2) の B<PR_SET_PDEATHSIG> フラグで設定された "
"parent death シグナルはクリアされる。"

#. type: Plain text
#: build/C/man2/execve.2:248
msgid ""
"The process name, as set by B<prctl>(2)  B<PR_SET_NAME> (and displayed by "
"I<ps\\ -o comm>), is reset to the name of the new executable file."
msgstr ""
"プロセス名は新しい実行ファイルの名前にリセットされる。 プロセス名は "
"B<prctl>(2)  の B<PR_SET_NAME> で設定でき、 I<ps\\ -o comm> で表示できる。"

#. type: Plain text
#: build/C/man2/execve.2:255
msgid ""
"The B<SECBIT_KEEP_CAPS> I<securebits> flag is cleared.  See "
"B<capabilities>(7)."
msgstr ""
"B<SECBIT_KEEP_CAPS> の I<securebits> フラグはクリアされる。 "
"B<capabilities>(7) 参照。"

#. type: Plain text
#: build/C/man2/execve.2:260
msgid "The termination signal is reset to B<SIGCHLD> (see B<clone>(2))."
msgstr ""
"終了シグナル (termination signal) は B<SIGCHLD> にリセットされる "
"(B<clone>(2)  参照)。"

#. type: Plain text
#: build/C/man2/execve.2:265
msgid ""
"The file descriptor table is unshared, undoing the effect of the "
"B<CLONE_FILES> flag of B<clone>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/execve.2:267 build/C/man2/fork.2:166
msgid "Note the following further points:"
msgstr "以下の点についても注意すること:"

#. type: Plain text
#: build/C/man2/execve.2:271
msgid ""
"All threads other than the calling thread are destroyed during an "
"B<execve>().  Mutexes, condition variables, and other pthreads objects are "
"not preserved."
msgstr ""
"呼び出し元スレッド以外の全てのスレッドは B<execve>()  中に破棄される。 "
"mutex、条件変数、その他の pthread オブジェクトは保持されない。"

#. type: Plain text
#: build/C/man2/execve.2:274
msgid ""
"The equivalent of I<setlocale(LC_ALL, \"C\")> is executed at program start-"
"up."
msgstr "I<setlocale(LC_ALL, \"C\")> 相当の処理がプログラム開始時に実行される。"

#. type: Plain text
#: build/C/man2/execve.2:282
msgid ""
"POSIX.1 specifies that the dispositions of any signals that are ignored or "
"set to the default are left unchanged.  POSIX.1 specifies one exception: if "
"B<SIGCHLD> is being ignored, then an implementation may leave the "
"disposition unchanged or reset it to the default; Linux does the former."
msgstr ""
"POSIX.1 は、動作が無視かデフォルトに設定されている全てのシグナル の処理方法は"
"変更せずそのままにする、と規定している。 但し、POSIX.1-2001 には一つ例外があ"
"り、 B<SIGCHLD> が無視になっている場合、 その処理方法を変更せずにそのままにす"
"るか、デフォルト動作にリセットするかは 実装依存となっている。 Linux では前者 "
"(変更しない) となっている。"

#. type: Plain text
#: build/C/man2/execve.2:286
msgid ""
"Any outstanding asynchronous I/O operations are canceled (B<aio_read>(3), "
"B<aio_write>(3))."
msgstr ""
"完了していない非同期 I/O 操作はキャンセルされる (B<aio_read>(3), "
"B<aio_write>(3))。"

#. type: Plain text
#: build/C/man2/execve.2:291
msgid ""
"For the handling of capabilities during B<execve>(), see B<capabilities>(7)."
msgstr ""
"B<execve>(2)  時のケーパビリティの扱いについては、 B<capabilities>(7)  を参"
"照。"

#.  On Linux it appears that these file descriptors are
#.  always open after an execve(), and it looks like
#.  Solaris 8 and FreeBSD 6.1 are the same. -- mtk, 30 Apr 2007
#. type: Plain text
#: build/C/man2/execve.2:318
msgid ""
"By default, file descriptors remain open across an B<execve>().  File "
"descriptors that are marked close-on-exec are closed; see the description of "
"B<FD_CLOEXEC> in B<fcntl>(2).  (If a file descriptor is closed, this will "
"cause the release of all record locks obtained on the underlying file by "
"this process.  See B<fcntl>(2)  for details.)  POSIX.1 says that if file "
"descriptors 0, 1, and 2 would otherwise be closed after a successful "
"B<execve>(), and the process would gain privilege because the set-user-ID or "
"set-group-ID mode bit was set on the executed file, then the system may open "
"an unspecified file for each of these file descriptors.  As a general "
"principle, no portable program, whether privileged or not, can assume that "
"these three file descriptors will remain closed across an B<execve>()."
msgstr ""
"デフォルトでは、ファイルディスクリプターは B<execve>()  を行った後でもオープ"
"ンされたままである。 close-on-exec の印が付いているファイルディスクリプターは"
"クローズされる。 B<fcntl>(2)  の B<FD_CLOEXEC> の説明を参照。 (ファイルディス"
"クリプターがクローズされると、このプロセスが ファイルディスクリプターに対応す"
"るファイルに対して獲得していた レコードのロックが全て解放されることにな"
"る。)  POSIX.1 では、 ファイルディスクリプター 0, 1, 2 が B<execve>()  成功後"
"にどこかでクローズされ、かつ 実行されるファイルに set-user_ID か set-"
"group_ID のモードビットが セットされていてプロセスが特権を獲得した場合、 シス"
"テムは何らかのファイルをオープンする際に これらの番号のディスクリプターのどれ"
"かを使うことがある、 とされている。 原則として、移植性が必要なプログラムで"
"は、 特権の有無に関わらず、 B<execve>()  の前後でこれら 3つのファイルディスク"
"リプターがクローズされたままで あることを前提にすることはできない。"

#. type: SS
#: build/C/man2/execve.2:318 build/C/man2/execve.2:649
#, no-wrap
msgid "Interpreter scripts"
msgstr "インタープリタースクリプト"

#. type: Plain text
#: build/C/man2/execve.2:321
msgid ""
"An interpreter script is a text file that has execute permission enabled and "
"whose first line is of the form:"
msgstr ""
"インタープリタースクリプトとは、実行許可が有効になっていて、 最初の行が以下の"
"形になっているテキストファイルのことである。"

#. type: Plain text
#: build/C/man2/execve.2:331
msgid "The I<interpreter> must be a valid pathname for an executable file."
msgstr ""

#. type: Plain text
#: build/C/man2/execve.2:339
msgid ""
"If the I<pathname> argument of B<execve>()  specifies an interpreter script, "
"then I<interpreter> will be invoked with the following arguments:"
msgstr ""
"B<execve>()  の I<pathname> 引数がインタープリタースクリプトを指定している"
"場合、 I<interpreter> は以下の引数で起動される。"

#. type: Plain text
#: build/C/man2/execve.2:343
#, no-wrap
msgid "I<interpreter> [optional-arg] I<pathname> arg...\n"
msgstr "I<interpreter> [optional-arg] I<pathname> arg...\n"

#.  See the P - preserve-argv[0] option.
#.  Documentation/admin-guide/binfmt-misc.rst
#.  https://www.kernel.org/doc/html/latest/admin-guide/binfmt-misc.html
#. type: Plain text
#: build/C/man2/execve.2:366
msgid ""
"where I<pathname> is the absolute pathname of the file specified as the "
"first argument of B<execve>(), and I<arg...> is the series of words pointed "
"to by the I<argv> argument of B<execve>(), starting at I<argv[1]>.  Note "
"that there is no way to get the I<argv[0]> that was passed to the "
"B<execve>()  call."
msgstr ""

#. type: Plain text
#: build/C/man2/execve.2:371
msgid ""
"For portable use, I<optional-arg> should either be absent, or be specified "
"as a single word (i.e., it should not contain white space); see NOTES below."
msgstr ""
"移植性を持たすには、 I<optional-arg> は空か 1ワードだけにすべきである (つま"
"り、ホワイトスペースを含めるべきではない)。 下記の「注意」の節を参照。"

#.  commit bf2a9a39639b8b51377905397a5005f444e9a892
#. type: Plain text
#: build/C/man2/execve.2:378
msgid ""
"Since Linux 2.6.28, the kernel permits the interpreter of a script to itself "
"be a script.  This permission is recursive, up to a limit of four "
"recursions, so that the interpreter may be a script which is interpreted by "
"a script, and so on."
msgstr ""

#. type: SS
#: build/C/man2/execve.2:378
#, no-wrap
msgid "Limits on size of arguments and environment"
msgstr "引数と環境変数の合計サイズの上限"

#. type: Plain text
#: build/C/man2/execve.2:391
msgid ""
"Most UNIX implementations impose some limit on the total size of the command-"
"line argument (I<argv>)  and environment (I<envp>)  strings that may be "
"passed to a new program.  POSIX.1 allows an implementation to advertise this "
"limit using the B<ARG_MAX> constant (either defined in I<E<lt>limits.hE<gt>> "
"or available at run time using the call I<sysconf(_SC_ARG_MAX)>)."
msgstr ""
"ほとんどの UNIX の実装は、新しいプログラムに渡すことができる コマンドライン引"
"数 (I<argv>)  と環境変数 (I<envp>)  の文字列群の合計サイズに何らかの上限を"
"設けている。 POSIX.1 は、 B<ARG_MAX> 定数を使ってこの上限を決める実装を認めて"
"いる (B<ARG_MAX> は I<E<lt>limits.hE<gt>> で定義されるか、実行時に "
"I<sysconf(_SC_ARG_MAX)> の呼び出しで入手できるかのいずれかである)。"

#. type: Plain text
#: build/C/man2/execve.2:398
msgid ""
"On Linux prior to kernel 2.6.23, the memory used to store the environment "
"and argument strings was limited to 32 pages (defined by the kernel constant "
"B<MAX_ARG_PAGES>).  On architectures with a 4-kB page size, this yields a "
"maximum size of 128\\ kB."
msgstr ""
"カーネル 2.6.23 より前の Linux では、環境変数と引数の文字列群を 格納するの"
"に使用されるメモリーは 32 ページに制限されていた (32 ページというのはカーネル"
"定数 B<MAX_ARG_PAGES> で定義される)。したがって、 ページサイズが 4\\ kB の"
"アーキテクチャーでは、 最大サイズは 128\\ kB ということになる。"

#.  For some background on the changes to ARG_MAX in kernels 2.6.23 and
#.  2.6.25, see:
#.      http://sourceware.org/bugzilla/show_bug.cgi?id=5786
#.      http://bugzilla.kernel.org/show_bug.cgi?id=10095
#.      http://thread.gmane.org/gmane.linux.kernel/646709/focus=648101,
#.      checked into 2.6.25 as commit a64e715fc74b1a7dcc5944f848acc38b2c4d4ee2.
#.  Ollie: That doesn't include the lists of pointers, though,
#.  so the actual usage is a bit higher (1 pointer per argument).
#. type: Plain text
#: build/C/man2/execve.2:438
#, fuzzy
#| msgid ""
#| "On kernel 2.6.23 and later, most architectures support a size limit "
#| "derived from the soft B<RLIMIT_STACK> resource limit (see "
#| "B<getrlimit>(2))  that is in force at the time of the B<execve>()  call.  "
#| "(Architectures with no memory management unit are excepted: they maintain "
#| "the limit that was in effect before kernel 2.6.23.)  This change allows "
#| "programs to have a much larger argument and/or environment list.  For "
#| "these architectures, the total size is limited to 1/4 of the allowed "
#| "stack size.  (Imposing the 1/4-limit ensures that the new program always "
#| "has some stack space.)  Since Linux 2.6.25, the kernel places a floor of "
#| "32 pages on this size limit, so that, even when B<RLIMIT_STACK> is set "
#| "very low, applications are guaranteed to have at least as much argument "
#| "and environment space as was provided by Linux 2.6.23 and earlier.  (This "
#| "guarantee was not provided in Linux 2.6.23 and 2.6.24.)  Additionally, "
#| "the limit per string is 32 pages (the kernel constant B<MAX_ARG_STRLEN>), "
#| "and the maximum number of strings is 0x7FFFFFFF."
msgid ""
"On kernel 2.6.23 and later, most architectures support a size limit derived "
"from the soft B<RLIMIT_STACK> resource limit (see B<getrlimit>(2))  that is "
"in force at the time of the B<execve>()  call.  (Architectures with no "
"memory management unit are excepted: they maintain the limit that was in "
"effect before kernel 2.6.23.)  This change allows programs to have a much "
"larger argument and/or environment list.  For these architectures, the total "
"size is limited to 1/4 of the allowed stack size.  (Imposing the 1/4-limit "
"ensures that the new program always has some stack space.)  Additionally, "
"the total size is limited to 3/4 of the value of the kernel constant "
"B<_STK_LIM> (8 Mibibytes).  Since Linux 2.6.25, the kernel also places a "
"floor of 32 pages on this size limit, so that, even when B<RLIMIT_STACK> is "
"set very low, applications are guaranteed to have at least as much argument "
"and environment space as was provided by Linux 2.6.23 and earlier.  (This "
"guarantee was not provided in Linux 2.6.23 and 2.6.24.)  Additionally, the "
"limit per string is 32 pages (the kernel constant B<MAX_ARG_STRLEN>), and "
"the maximum number of strings is 0x7FFFFFFF."
msgstr ""
"カーネル 2.6.23 以降では、ほとんどのアーキテクチャーにおいて、 B<execve>()  "
"が呼び出された時点で適用されているリソースのソフト上限 B<RLIMIT_STACK> に基づ"
"いたサイズ上限が使われる (メモリー管理ユニット (MMU) を持たないアーキテク"
"チャーは上記の変更の 例外であり、これらのアーキテクチャーではカーネル 2.6.23 "
"より前と 同じ上限がそのまま使用される)。 これらのアーキテクチャーでは、合計サ"
"イズは許可されたスタックサイズの 1/4 に制限されている (1/4 の上限を設けている"
"のは、新しいプログラムが必ずある程度の スタック空間を持てることを保証するため"
"である)。 Linux 2.6.25 以降では、カーネルはこのサイズ上限に 32 ページの下限"
"を 設けている。これにより、 B<RLIMIT_STACK> が非常に小さく設定された場合で"
"も、アプリケーションが少なくとも Linux 2.6.23 以前で提供されていたのと同じ大"
"きさの引数と環境変数の空間 と同じだけは確保できることが保証されている (この"
"最低限の保証は Linux 2.6.23 と 2.6.24 では提供されていない)。 また、各文字列"
"の上限は 32 ページ (カーネル定数 B<MAX_ARG_STRLEN>)  で、文字列数の最大値は "
"0x7FFFFFFF である。"

#. type: Plain text
#: build/C/man2/execve.2:444
msgid ""
"On success, B<execve>()  does not return, on error -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""
"成功すると B<execve>()  は返らない。エラーの場合は -1 を返し、 I<errno> を適"
"切に設定する。"

#. type: TP
#: build/C/man2/execve.2:445
#, no-wrap
msgid "B<E2BIG>"
msgstr "B<E2BIG>"

#. type: Plain text
#: build/C/man2/execve.2:452
msgid ""
"The total number of bytes in the environment (I<envp>)  and argument list "
"(I<argv>)  is too large."
msgstr ""
"環境変数 (I<envp>)  と引数リスト (I<argv>)  の合計バイト数が大き過ぎる。"

#. type: Plain text
#: build/C/man2/execve.2:459
msgid ""
"Search permission is denied on a component of the path prefix of I<pathname> "
"or the name of a script interpreter.  (See also B<path_resolution>(7).)"
msgstr ""
"I<pathname> やスクリプトインタープリター名の構成要素に検索許可 (search "
"permission)  が与えられていない (B<path_resolution>(7)  も参照すること)。"

#. type: Plain text
#: build/C/man2/execve.2:462
msgid "The file or a script interpreter is not a regular file."
msgstr ""
"ファイルもしくはスクリプトのインタープリターが通常ファイル (regular file)  で"
"ない。"

#. type: Plain text
#: build/C/man2/execve.2:465
msgid ""
"Execute permission is denied for the file or a script or ELF interpreter."
msgstr ""
"ファイルやスクリプトや ELF インタープリターに 実行許可 (execute permission) "
"が与えられていない。"

#. type: Plain text
#: build/C/man2/execve.2:469
msgid "The filesystem is mounted I<noexec>."
msgstr "ファイルシステムが I<noexec> でマウントされている。"

#. type: TP
#: build/C/man2/execve.2:469
#, no-wrap
msgid "B<EAGAIN> (since Linux 3.1)"
msgstr "B<EAGAIN> (Linux 3.1 以降)"

#.  commit 72fa59970f8698023045ab0713d66f3f4f96945c
#. type: Plain text
#: build/C/man2/execve.2:479
msgid ""
"Having changed its real UID using one of the B<set*uid>()  calls, the caller "
"was\\(emand is now still\\(emabove its B<RLIMIT_NPROC> resource limit (see "
"B<setrlimit>(2)).  For a more detailed explanation of this error, see NOTES."
msgstr ""
"B<set*uid>() のいずれかの呼び出しでプロセスの実 UID が変更されたとすると、呼"
"び出し元の B<RLIMIT_NPROC> リソース上限 (B<setrlimit>(2) 参照) を超えてしま"
"う、 現在もまだ超えている。 このエラーの詳細な説明については「注意」の節を参"
"照。"

#. type: Plain text
#: build/C/man2/execve.2:487
msgid ""
"I<pathname> or one of the pointers in the vectors I<argv> or I<envp> points "
"outside your accessible address space."
msgstr ""
"I<pathname> または配列 I<argv> か I<envp> のポインターの一つがアクセス可能な"
"アドレス空間の外を指している。"

#. type: Plain text
#: build/C/man2/execve.2:491
msgid ""
"An ELF executable had more than one PT_INTERP segment (i.e., tried to name "
"more than one interpreter)."
msgstr ""
"ELF 実行形式で複数の PT_INTERP セグメントが存在する。 (すなわち複数のインター"
"プリターを指定した。)"

#. type: TP
#: build/C/man2/execve.2:494 build/C/man2/truncate.2:147
#, no-wrap
msgid "B<EISDIR>"
msgstr "B<EISDIR>"

#. type: Plain text
#: build/C/man2/execve.2:497
msgid "An ELF interpreter was a directory."
msgstr "ELF インタープリターがディレクトリだった。"

#. type: TP
#: build/C/man2/execve.2:497
#, no-wrap
msgid "B<ELIBBAD>"
msgstr "B<ELIBBAD>"

#. type: Plain text
#: build/C/man2/execve.2:500
msgid "An ELF interpreter was not in a recognized format."
msgstr "ELF インタープリターが理解できるフォーマットでなかった。"

#. type: Plain text
#: build/C/man2/execve.2:505
msgid ""
"Too many symbolic links were encountered in resolving I<pathname> or the "
"name of a script or ELF interpreter."
msgstr ""
"I<pathname> やスクリプトや ELF のインタープリターを解決する際に遭遇した シン"
"ボリックリンクが多過ぎる。"

#.  commit d740269867021faf4ce38a449353d2b986c34a67
#. type: Plain text
#: build/C/man2/execve.2:513
msgid ""
"The maximum recursion limit was reached during recursive script "
"interpretation (see \"Interpreter scripts\", above).  Before Linux 3.8, the "
"error produced for this case was B<ENOEXEC>."
msgstr ""

#. type: Plain text
#: build/C/man2/execve.2:516 build/C/man3/getlogin.3:115
#, fuzzy
#| msgid "The system limit on the total number of open files has been reached."
msgid ""
"The per-process limit on the number of open file descriptors has been "
"reached."
msgstr "オープンされたファイルの総数がシステム全体の上限に達していた。"

#. type: TP
#: build/C/man2/execve.2:520 build/C/man3/getlogin.3:115
#: build/C/man2/swapon.2:147 build/C/man2/uselib.2:70
#, no-wrap
msgid "B<ENFILE>"
msgstr "B<ENFILE>"

#. type: Plain text
#: build/C/man2/execve.2:523 build/C/man3/getlogin.3:118
#: build/C/man2/swapon.2:150 build/C/man2/uselib.2:73
msgid ""
"The system-wide limit on the total number of open files has been reached."
msgstr "オープンされたファイルの総数がシステム全体の上限に達していた。"

#. type: Plain text
#: build/C/man2/execve.2:528
#, fuzzy
#| msgid "The file or a script interpreter is not a regular file."
msgid "The file I<pathname> or a script or ELF interpreter does not exist."
msgstr ""
"ファイルもしくはスクリプトのインタープリターが通常ファイル (regular file)  で"
"ない。"

#. type: TP
#: build/C/man2/execve.2:528 build/C/man2/uselib.2:73
#, no-wrap
msgid "B<ENOEXEC>"
msgstr "B<ENOEXEC>"

#. type: Plain text
#: build/C/man2/execve.2:533
msgid ""
"An executable is not in a recognized format, is for the wrong architecture, "
"or has some other format error that means it cannot be executed."
msgstr ""
"実行ファイルが理解できない形式であるか、違うアーキテクチャーのものか、 その他"
"のフォーマットエラーにより実行ができなかった。"

#. type: Plain text
#: build/C/man2/execve.2:541
msgid ""
"A component of the path prefix of I<pathname> or a script or ELF interpreter "
"is not a directory."
msgstr ""
"I<pathname> やスクリプトや ELF のインタープリターの構成要素がディレクトリでな"
"い。"

#. type: Plain text
#: build/C/man2/execve.2:547
msgid ""
"The filesystem is mounted I<nosuid>, the user is not the superuser, and the "
"file has the set-user-ID or set-group-ID bit set."
msgstr ""
"ファイルシステムが I<nosuid> でマウントされ、ユーザーがスーパーユーザーでな"
"く、 ファイルに set-user-ID あるいは set-group-ID ビットが設定されている。"

#. type: Plain text
#: build/C/man2/execve.2:551
msgid ""
"The process is being traced, the user is not the superuser and the file has "
"the set-user-ID or set-group-ID bit set."
msgstr ""
"プロセスがトレースされ、ユーザーがスーパーユーザーでなく、 ファイルに set-"
"user-ID あるいは set-group-ID ビットが設定されている。"

#. type: Plain text
#: build/C/man2/execve.2:557
msgid ""
"A \"capability-dumb\" applications would not obtain the full set of "
"permitted capabilities granted by the executable file.  See "
"B<capabilities>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/execve.2:560
msgid "The specified executable was open for writing by one or more processes."
msgstr "指定された実行ファイルを書き込み用にオープンしているプロセスがある。"

#.  SVr4 documents additional error
#.  conditions EAGAIN, EINTR, ELIBACC, ENOLINK, EMULTIHOP; POSIX does not
#.  document ETXTBSY, EPERM, EFAULT, ELOOP, EIO, ENFILE, EMFILE, EINVAL,
#.  EISDIR or ELIBBAD error conditions.
#. type: Plain text
#: build/C/man2/execve.2:568
#, fuzzy
#| msgid ""
#| "SVr4, 4.3BSD, POSIX.1-2001.  POSIX.1-2001 does not document the #! "
#| "behavior but is otherwise compatible."
msgid ""
"POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD.  POSIX does not document the #! "
"behavior, but it exists (with some variations) on other UNIX systems."
msgstr ""
"SVr4, 4.3BSD, POSIX.1-2001.  POSIX.1-2001 には #! 動作についての記述はない"
"が、 他は互換性がある。"

#. type: Plain text
#: build/C/man2/execve.2:584
msgid ""
"One sometimes sees B<execve>()  (and the related functions described in "
"B<exec>(3))  described as \"executing a I<new> process\" (or similar).  This "
"is a highly misleading description: there is no new process; many attributes "
"of the calling process remain unchanged (in particular, its PID).  All that "
"B<execve>()  does is arrange for an existing process (the calling process)  "
"to execute a new program."
msgstr ""

#. type: Plain text
#: build/C/man2/execve.2:587
msgid "Set-user-ID and set-group-ID processes can not be B<ptrace>(2)d."
msgstr ""
"set-user-id プロセスと set-group-ID プロセスは B<ptrace>(2)  できない。"

#. type: Plain text
#: build/C/man2/execve.2:598
msgid ""
"The result of mounting a filesystem I<nosuid> varies across Linux kernel "
"versions: some will refuse execution of set-user-ID and set-group-ID "
"executables when this would give the user powers they did not have already "
"(and return B<EPERM>), some will just ignore the set-user-ID and set-group-"
"ID bits and B<exec>()  successfully."
msgstr ""
"ファイルシステムを I<nosuid> でマウントした場合に set-user-ID/set-group-ID の"
"実行ファイルを どの様に扱うかは、Linux カーネルのバージョンによって異なる: あ"
"るバージョンでは、すでに必要な権限を持っている場合を除いて、 その実行を拒否す"
"る (そして B<EPERM> を返す)。別のあるバージョンでは set-user-ID/set-group-ID "
"ビットのみを無視し B<exec>()  は成功する。"

#.  e.g., EFAULT on Solaris 8 and FreeBSD 6.1; but
#.  HP-UX 11 is like Linux -- mtk, Apr 2007
#.  Bug filed 30 Apr 2007: http://bugzilla.kernel.org/show_bug.cgi?id=8408
#.  Bug rejected (because fix would constitute an ABI change).
#. type: Plain text
#: build/C/man2/execve.2:620
msgid ""
"On Linux, I<argv> and I<envp> can be specified as NULL.  In both cases, this "
"has the same effect as specifying the argument as a pointer to a list "
"containing a single null pointer.  B<Do not take advantage of this "
"nonstandard and nonportable misfeature!> On many other UNIX systems, "
"specifying I<argv> as NULL will result in an error (B<EFAULT>).  I<Some> "
"other UNIX systems treat the I<envp==NULL> case the same as Linux."
msgstr ""

#. type: Plain text
#: build/C/man2/execve.2:631
msgid ""
"POSIX.1 says that values returned by B<sysconf>(3)  should be invariant over "
"the lifetime of a process.  However, since Linux 2.6.23, if the "
"B<RLIMIT_STACK> resource limit changes, then the value reported by "
"B<_SC_ARG_MAX> will also change, to reflect the fact that the limit on space "
"for holding command-line arguments and environment variables has changed."
msgstr ""
"POSIX.1 は、 B<sysconf>(3)  が返す値はプロセスの生存中は変化しないべきだとし"
"ている。 しかしながら、Linux 2.6.23 以降では、リソース上限 B<RLIMIT_STACK> が"
"変化した場合、 コマンドライン引数と環境変数を保持するための空間に対する上限"
"が 変化したことを反映して、 B<_SC_ARG_MAX> が返す値も変化する。"

#.  commit 19d860a140beac48a1377f179e693abe86a9dac9
#. type: Plain text
#: build/C/man2/execve.2:649
msgid ""
"In most cases where B<execve>()  fails, control returns to the original "
"executable image, and the caller of B<execve>()  can then handle the error.  "
"However, in (rare) cases (typically caused by resource exhaustion), failure "
"may occur past the point of no return: the original executable image has "
"been torn down, but the new image could not be completely built.  In such "
"cases, the kernel kills the process with a B<SIGSEGV> (B<SIGKILL> until "
"Linux 3.17)  signal."
msgstr ""
"B<execve>() が失敗するほとんどの場合、 制御は元の実行可能イメージに戻り、 "
"B<execve>() の呼び出し元がエラーを処理することができる。 しかしながら、 (リ"
"ソース枯渇が原因となった場合など、まれに) 呼び出し元に制御が戻る時点を過ぎて"
"からエラーが発生する場合がある。 元の実行可能イメージはすでに破棄されている"
"が、 新しいイメージが完全には構築されていないという状況である。 このような場"
"合、カーネルはそのプロセスをシグナル B<SIGSEGV> (Linux 3.17 までは "
"B<SIGKILL>) で停止 (kill) する。"

#.  commit 6eb3c3d0a52dca337e327ae8868ca1f44a712e02
#. type: Plain text
#: build/C/man2/execve.2:657
msgid ""
"The kernel imposes a maximum length on the text that follows the \"#!\" "
"characters at the start of a script; characters beyond the limit are "
"ignored.  Before Linux 5.1, the limit is 127 characters.  Since Linux 5.1, "
"the limit is 255 characters."
msgstr ""

#.  e.g., Solaris 8
#.  e.g., FreeBSD before 6.0, but not FreeBSD 6.0 onward
#. type: Plain text
#: build/C/man2/execve.2:676
msgid ""
"The semantics of the I<optional-arg> argument of an interpreter script vary "
"across implementations.  On Linux, the entire string following the "
"I<interpreter> name is passed as a single argument to the interpreter, and "
"this string can include white space.  However, behavior differs on some "
"other systems.  Some systems use the first white space to terminate "
"I<optional-arg>.  On some systems, an interpreter script can have multiple "
"arguments, and white spaces in I<optional-arg> are used to delimit the "
"arguments."
msgstr ""
"インタープリタースクリプトの I<optional-arg> 引数の解釈方法は実装により異な"
"る。 Linux では、インタープリター名 I<interpreter> に続く文字列全体がインター"
"プリターに 1個の引数として渡される。 しかし、動作が異なるシステムもある。 "
"あるシステムでは、 I<optional-arg> のうち最初のホワイトスペースまでが 引数"
"として渡される。 また、別のシステムでは インタープリタースクリプトは複数の引"
"数を持つことができ、 I<optional-arg> 内のホワイトスペースが引数の区切りと"
"なる。"

#.  .SH BUGS
#.  Some Linux versions have failed to check permissions on ELF
#.  interpreters.  This is a security hole, because it allows users to
#.  open any file, such as a rewinding tape device, for reading.  Some
#.  Linux versions have also had other security holes in
#.  .BR execve ()
#.  that could be exploited for denial of service by a suitably crafted
#.  ELF binary. There are no known problems with 2.0.34 or 2.2.15.
#. type: Plain text
#: build/C/man2/execve.2:688
#, fuzzy
#| msgid "Linux ignores the set-user-ID and set-group-ID bits on scripts."
msgid ""
"Linux (like most other modern UNIX systems)  ignores the set-user-ID and set-"
"group-ID bits on scripts."
msgstr "Linux はスクリプトの set-user-ID と set-group-ID ビットを無視する。"

#. type: SS
#: build/C/man2/execve.2:688
#, no-wrap
msgid "execve() and EAGAIN"
msgstr "execve() と EAGAIN"

#. type: Plain text
#: build/C/man2/execve.2:694
msgid ""
"A more detailed explanation of the B<EAGAIN> error that can occur (since "
"Linux 3.1) when calling B<execve>()  is as follows."
msgstr ""
"B<execve>() を呼び出した際に (Linux 3.1 以降で) 起こり得る B<EAGAIN> エラーの"
"詳細な説明を以下で行う。"

#.  commit 909cc4ae86f3380152a18e2a3c44523893ee11c4
#. type: Plain text
#: build/C/man2/execve.2:716
msgid ""
"The B<EAGAIN> error can occur when a I<preceding> call to B<setuid>(2), "
"B<setreuid>(2), or B<setresuid>(2)  caused the real user ID of the process "
"to change, and that change caused the process to exceed its B<RLIMIT_NPROC> "
"resource limit (i.e., the number of processes belonging to the new real UID "
"exceeds the resource limit).  From Linux 2.6.0 to 3.0, this caused the "
"B<set*uid>()  call to fail.  (Prior to 2.6, the resource limit was not "
"imposed on processes that changed their user IDs.)"
msgstr ""
"I<直前の> B<setuid>(2), B<setreuid>(2), B<setresuid>(2) の呼び出しで、 そのプ"
"ロセスの実ユーザー ID が変更され、 その変更によりそのプロセスが "
"B<RLIMIT_NPROC> リソース上限を超過してしまった場合 (すなわち、新しい実ユー"
"ザー ID に属するプロセス数が B<RLIMIT_NPROC> リソース上限を超過した場合) "
"に、 B<EAGAIN> エラーが発生する。 Linux 2.6.0 以上 3.0 以下では、これにより "
"B<set*uid>() の呼び出しが失敗していた。 (Linux 2.6 より前では、このリソース上"
"限はユーザー ID を変更したプロセスには適用されていなかった。)"

#. type: Plain text
#: build/C/man2/execve.2:747
msgid ""
"Since Linux 3.1, the scenario just described no longer causes the "
"B<set*uid>()  call to fail, because it too often led to security holes where "
"buggy applications didn't check the return status and assumed that\\(emif "
"the caller had root privileges\\(emthe call would always succeed.  Instead, "
"the B<set*uid>()  calls now successfully change the real UID, but the kernel "
"sets an internal flag, named B<PF_NPROC_EXCEEDED>, to note that the "
"B<RLIMIT_NPROC> resource limit has been exceeded.  If the "
"B<PF_NPROC_EXCEEDED> flag is set and the resource limit is still exceeded at "
"the time of a subsequent B<execve>()  call, that call fails with the error "
"B<EAGAIN>.  This kernel logic ensures that the B<RLIMIT_NPROC> resource "
"limit is still enforced for the common privileged daemon workflow"
"\\(emnamely, B<fork>(2)  + B<set*uid>()  + B<execve>()."
msgstr ""
"Linux 3.1 以降では、上で説明したシナリオでは B<set*uid>() の呼び出しは失敗し"
"ない。 なぜなら、 返されたステータスの確認を行わず「呼び出し元が特権を持って"
"いる場合には」呼び出しは必ず成功するとみなしているバグがあるアプリケーション"
"では、セキュリティホールにつながることが非常によくあるからだ。 その代わり、 "
"B<set*uid>() の呼び出しによる実 UID の変更は成功するが、 カーネルは "
"B<PF_NPROC_EXCEEDED> という名前の内部フラグをセットする。 このフラグは "
"B<RLIMIT_NPROC> リソース上限が超過したことを示す。 B<PF_NPROC_EXCEEDED> フラ"
"グがセットされていて、その後で B<execve>() が呼ばれた際にリソース上限がまだ超"
"過していれば、 その B<execve>() の呼び出しは B<EAGAIN> エラーで失敗する。 こ"
"のカーネルのロジックにより、 特権デーモンでよく行われる処理フロー、 すなわち "
"B<fork>(2)  + B<set*uid>()  + B<execve>() に対して、前と変わらず "
"B<RLIMIT_NPROC> リソース上限を適用できることが保証される。"

#. type: Plain text
#: build/C/man2/execve.2:763
msgid ""
"If the resource limit was not still exceeded at the time of the B<execve>()  "
"call (because other processes belonging to this real UID terminated between "
"the B<set*uid>()  call and the B<execve>()  call), then the B<execve>()  "
"call succeeds and the kernel clears the B<PF_NPROC_EXCEEDED> process flag.  "
"The flag is also cleared if a subsequent call to B<fork>(2)  by this process "
"succeeds."
msgstr ""
"(B<set*uid>() と B<execve>() の呼び出しの間に、この実 UID に属する他のプロセ"
"スが終了して) 次に B<execve>() が呼び出された際にこのリソース上限が超過してな"
"ければ、 B<execve>() の呼び出しは成功し、カーネルは B<PF_NPROC_EXCEEDED> プロ"
"セスフラグをクリアする。 同じプロセスによって B<fork>(2) の呼び出しが後で行わ"
"れた場合にも、このフラグはクリアされる。"

#. type: SS
#: build/C/man2/execve.2:763
#, no-wrap
msgid "Historical"
msgstr "歴史"

#.  .SH BUGS
#.  Some Linux versions have failed to check permissions on ELF
#.  interpreters.  This is a security hole, because it allows users to
#.  open any file, such as a rewinding tape device, for reading.  Some
#.  Linux versions have also had other security holes in
#.  .BR execve ()
#.  that could be exploited for denial of service by a suitably crafted
#.  ELF binary. There are no known problems with 2.0.34 or 2.2.15.
#. type: Plain text
#: build/C/man2/execve.2:783
msgid ""
"With UNIX\\ V6, the argument list of an B<exec>()  call was ended by 0, "
"while the argument list of I<main> was ended by -1.  Thus, this argument "
"list was not directly usable in a further B<exec>()  call.  Since UNIX\\ V7, "
"both are NULL."
msgstr ""
"UNIX\\ V6 では B<exec>()  コールの引数リストは 0 で終端され、 I<main> の引"
"数リストは -1 で終端されていた。 そのため、 I<main> の引数リストは、その"
"後の B<exec>()  コールには直接使用できなかった。 UNIX\\ V7 以降では、ともに "
"NULL で終端される。"

#. type: Plain text
#: build/C/man2/execve.2:786
msgid ""
"The following program is designed to be execed by the second program below.  "
"It just echoes its command-line arguments, one per line."
msgstr ""
"このプログラムは、以下の二つ目のプログラムから実行するためのものである。 コマ"
"ンドライン引数を 1行に 1個ずつ表示するだけのプログラムである。"

#. type: Plain text
#: build/C/man2/execve.2:790
#, no-wrap
msgid "/* myecho.c */\n"
msgstr "/* myecho.c */\n"

#. type: Plain text
#: build/C/man2/execve.2:793
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"

#. type: Plain text
#: build/C/man2/execve.2:799
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    for (int j = 0; j E<lt> argc; j++)\n"
"        printf(\"argv[%d]: %s\\en\", j, argv[j]);\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    for (int j = 0; j E<lt> argc; j++)\n"
"        printf(\"argv[%d]: %s\\en\", j, argv[j]);\n"

#. type: Plain text
#: build/C/man2/execve.2:807
msgid ""
"This program can be used to exec the program named in its command-line "
"argument:"
msgstr ""
"以下のプログラムは、コマンドライン引数で指定した名前のプログラムを 実行する"
"のに使う。"

#. type: Plain text
#: build/C/man2/execve.2:811
#, no-wrap
msgid "/* execve.c */\n"
msgstr "/* execve.c */\n"

#. type: Plain text
#: build/C/man2/execve.2:815
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"

#. type: Plain text
#: build/C/man2/execve.2:821
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *newargv[] = { NULL, \"hello\", \"world\", NULL };\n"
"    char *newenviron[] = { NULL };\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *newargv[] = { NULL, \"hello\", \"world\", NULL };\n"
"    char *newenviron[] = { NULL };\n"

#. type: Plain text
#: build/C/man2/execve.2:826
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>file-to-execE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>file-to-execE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/execve.2:828
#, no-wrap
msgid "    newargv[0] = argv[1];\n"
msgstr "    newargv[0] = argv[1];\n"

#. type: Plain text
#: build/C/man2/execve.2:833
#, no-wrap
msgid ""
"    execve(argv[1], newargv, newenviron);\n"
"    perror(\"execve\");   /* execve() returns only on error */\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""
"    execve(argv[1], newargv, newenviron);\n"
"    perror(\"execve\");   /* execve() returns only on error */\n"
"    exit(EXIT_FAILURE);\n"
"}\n"

#. type: Plain text
#: build/C/man2/execve.2:837
msgid "We can use the second program to exec the first as follows:"
msgstr ""
"二つ目のプログラムを使って一つ目のプログラムを実行するには 以下のようにする。"

#. type: Plain text
#: build/C/man2/execve.2:846
#, no-wrap
msgid ""
"$B< cc myecho.c -o myecho>\n"
"$B< cc execve.c -o execve>\n"
"$B< ./execve ./myecho>\n"
"argv[0]: ./myecho\n"
"argv[1]: hello\n"
"argv[2]: world\n"
msgstr ""
"$B< cc myecho.c -o myecho>\n"
"$B< cc execve.c -o execve>\n"
"$B< ./execve ./myecho>\n"
"argv[0]: ./myecho\n"
"argv[1]: hello\n"
"argv[2]: world\n"

#. type: Plain text
#: build/C/man2/execve.2:854
msgid ""
"We can also use these programs to demonstrate the use of a script "
"interpreter.  To do this we create a script whose \"interpreter\" is our "
"I<myecho> program:"
msgstr ""
"さらに、これらのプログラムを使って、スクリプトインタープリターの例を示す。 こ"
"のために、「インタープリター」として先ほど作成したプログラム I<myecho> を使う"
"スクリプトを作成する。"

#. type: Plain text
#: build/C/man2/execve.2:861
#, no-wrap
msgid ""
"$B< cat E<gt> script>\n"
"B<#!./myecho script-arg>\n"
"B<\\(haD>\n"
"$B< chmod +x script>\n"
msgstr ""
"$B< cat E<gt> script>\n"
"B<#!./myecho script-arg>\n"
"B<\\(haD>\n"
"$B< chmod +x script>\n"

#. type: Plain text
#: build/C/man2/execve.2:865
msgid "We can then use our program to exec the script:"
msgstr "作成しておいたプログラムを使ってスクリプトを実行する。"

#. type: Plain text
#: build/C/man2/execve.2:874
#, no-wrap
msgid ""
"$B< ./execve ./script>\n"
"argv[0]: ./myecho\n"
"argv[1]: script-arg\n"
"argv[2]: ./script\n"
"argv[3]: hello\n"
"argv[4]: world\n"
msgstr ""
"$B< ./execve ./script>\n"
"argv[0]: ./myecho\n"
"argv[1]: script-arg\n"
"argv[2]: ./script\n"
"argv[3]: hello\n"
"argv[4]: world\n"

#. type: Plain text
#: build/C/man2/execve.2:891
msgid ""
"B<chmod>(2), B<execveat>(2), B<fork>(2), B<get_robust_list>(2), "
"B<ptrace>(2), B<exec>(3), B<fexecve>(3), B<getopt>(3), B<system>(3), "
"B<capabilities>(7), B<credentials>(7), B<environ>(7), B<path_resolution>(7), "
"B<ld.so>(8)"
msgstr ""
"B<chmod>(2), B<execveat>(2), B<fork>(2), B<get_robust_list>(2), "
"B<ptrace>(2), B<exec>(3), B<fexecve>(3), B<getopt>(3), B<system>(3), "
"B<capabilities>(7), B<credentials>(7), B<environ>(7), B<path_resolution>(7), "
"B<ld.so>(8)"

#. type: TH
#: build/C/man2/exit_group.2:25
#, no-wrap
msgid "EXIT_GROUP"
msgstr "EXIT_GROUP"

#. type: TH
#: build/C/man2/exit_group.2:25
#, no-wrap
msgid "2008-11-27"
msgstr "2008-11-27"

#. type: Plain text
#: build/C/man2/exit_group.2:28
msgid "exit_group - exit all threads in a process"
msgstr "exit_group - プロセス中の全てのスレッドを exit させる"

#. type: Plain text
#: build/C/man2/exit_group.2:31 build/C/man2/set_thread_area.2:15
#, no-wrap
msgid "B<#include E<lt>linux/unistd.hE<gt>>\n"
msgstr "B<#include E<lt>linux/unistd.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/exit_group.2:33
#, no-wrap
msgid "B<void exit_group(int >I<status>B<);>\n"
msgstr "B<void exit_group(int >I<status>B<);>\n"

#. type: Plain text
#: build/C/man2/exit_group.2:39
msgid ""
"This system call is equivalent to B<_exit>(2)  except that it terminates not "
"only the calling thread, but all threads in the calling process's thread "
"group."
msgstr ""
"このシステムコールは、基本的に B<_exit>(2)  と等しいが、 呼び出し元のスレッド"
"だけでなく、呼び出し元のプロセスのスレッドグループに ある全てのスレッドを終了"
"させる点が異なる。"

#. type: Plain text
#: build/C/man2/exit_group.2:41
msgid "This system call does not return."
msgstr "このシステムコールは値を返さない。"

#. type: Plain text
#: build/C/man2/exit_group.2:43
msgid "This call is present since Linux 2.5.35."
msgstr "このコールは、Linux 2.5.35 以降に存在する。"

#. type: Plain text
#: build/C/man2/exit_group.2:45
msgid "This call is Linux-specific."
msgstr "このシステムコールは Linux 固有である。"

#. type: Plain text
#: build/C/man2/exit_group.2:49
msgid ""
"Since glibc 2.3, this is the system call invoked when the B<_exit>(2)  "
"wrapper function is called."
msgstr ""
"glibc 2.3 以降では、 B<_exit>(2)  のラッパー関数が呼び出された際に、 このシス"
"テムコールが起動される。"

#. type: tbl table
#: build/C/man2/exit_group.2:51 build/C/man2/syscalls.2:257
#, no-wrap
msgid "B<exit>(2)"
msgstr "B<exit>(2)"

#. type: TH
#: build/C/man2/fcntl.2:67
#, no-wrap
msgid "FCNTL"
msgstr "FCNTL"

#. type: Plain text
#: build/C/man2/fcntl.2:70
msgid "fcntl - manipulate file descriptor"
msgstr "fcntl - ファイルディスクリプターの操作を行う"

#. type: Plain text
#: build/C/man2/fcntl.2:74
#, no-wrap
msgid ""
"B<#include E<lt>unistd.hE<gt>>\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
msgstr ""
"B<#include E<lt>unistd.hE<gt>>\n"
"B<#include E<lt>fcntl.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/fcntl.2:76
#, no-wrap
msgid "B<int fcntl(int >I<fd>B<, int >I<cmd>B<, ... /* >I<arg>B< */ );>\n"
msgstr "B<int fcntl(int >I<fd>B<, int >I<cmd>B<, ... /* >I<arg>B< */ );>\n"

#. type: Plain text
#: build/C/man2/fcntl.2:83
msgid ""
"B<fcntl>()  performs one of the operations described below on the open file "
"descriptor I<fd>.  The operation is determined by I<cmd>."
msgstr ""
"B<fcntl>()  は、オープンされたファイルディスクリプター I<fd> に関して下記の操"
"作を行う。操作は I<cmd> によって決まる:"

#. type: Plain text
#: build/C/man2/fcntl.2:97
msgid ""
"B<fcntl>()  can take an optional third argument.  Whether or not this "
"argument is required is determined by I<cmd>.  The required argument type is "
"indicated in parentheses after each I<cmd> name (in most cases, the required "
"type is I<int>, and we identify the argument using the name I<arg>), or "
"I<void> is specified if the argument is not required."
msgstr ""
"B<fcntl>() はオプションとして第三引数をとることができる。 第三引数が必"
"要\n"
"かどうかは I<cmd> により決まる。必要な引数の型は I<cmd> 名の後ろの括弧内"
"で\n"
"指定されている (ほとんどの場合、必要な型は I<int> であり、この引数を表す"
"の\n"
"に I<arg> という名前を使っている)。引数が必要ない場合には I<void> が指定"
"さ\n"
"れている。"

#. type: Plain text
#: build/C/man2/fcntl.2:108
msgid ""
"Certain of the operations below are supported only since a particular Linux "
"kernel version.  The preferred method of checking whether the host kernel "
"supports a particular operation is to invoke B<fcntl>()  with the desired "
"I<cmd> value and then test whether the call failed with B<EINVAL>, "
"indicating that the kernel does not recognize this value."
msgstr ""
"下記のいくつかの操作は特定のバージョンの Linux カーネルでのみサポートされてい"
"る。 ホストカーネルが特定の操作をサポートしているかを確認する推奨の方法は、 "
"B<fcntl>() を所望の I<cmd> 値で呼び出し、 B<EINVAL> で失敗するかを検査するこ"
"とである。 B<EINVAL> が返った場合、カーネルがこの値を認識していないことを示"
"す。"

#. type: SS
#: build/C/man2/fcntl.2:108
#, no-wrap
msgid "Duplicating a file descriptor"
msgstr "ファイルディスクリプターの複製"

#. type: TP
#: build/C/man2/fcntl.2:109
#, no-wrap
msgid "B<F_DUPFD> (I<int>)"
msgstr "B<F_DUPFD> (I<int>)"

#. type: Plain text
#: build/C/man2/fcntl.2:118
#, fuzzy
#| msgid ""
#| "Find the lowest numbered available file descriptor greater than or equal "
#| "to I<arg> and make it be a copy of I<fd>.  This is different from "
#| "B<dup2>(2), which uses exactly the descriptor specified."
msgid ""
"Duplicate the file descriptor I<fd> using the lowest-numbered available file "
"descriptor greater than or equal to I<arg>.  This is different from "
"B<dup2>(2), which uses exactly the file descriptor specified."
msgstr ""
"利用可能なファイルディスクリプターのうち、 I<arg> 以上で最小のものを探し、 "
"I<fd> のコピーとする。これは別の形の B<dup2>(2)  である。 B<dup2>(2)  では指"
"定されたディスクリプターが使われる点が違う。"

#. type: Plain text
#: build/C/man2/fcntl.2:120
msgid "On success, the new file descriptor is returned."
msgstr "成功すると、新しいファイルディスクリプターが返される。"

#. type: Plain text
#: build/C/man2/fcntl.2:124
msgid "See B<dup>(2)  for further details."
msgstr "詳細は B<dup>(2)  を参照のこと。"

#. type: TP
#: build/C/man2/fcntl.2:124
#, no-wrap
msgid "B<F_DUPFD_CLOEXEC> (I<int>; since Linux 2.6.24)"
msgstr "B<F_DUPFD_CLOEXEC> (I<int>; Linux 2.6.24 以降)"

#. type: Plain text
#: build/C/man2/fcntl.2:141
msgid ""
"As for B<F_DUPFD>, but additionally set the close-on-exec flag for the "
"duplicate file descriptor.  Specifying this flag permits a program to avoid "
"an additional B<fcntl>()  B<F_SETFD> operation to set the B<FD_CLOEXEC> "
"flag.  For an explanation of why this flag is useful, see the description of "
"B<O_CLOEXEC> in B<open>(2)."
msgstr ""
"B<F_DUPFD> と同様だが、それに加えて複製されたファイルディスクリプターに対し"
"て close-on-exec フラグをセットする。 このフラグを指定することで、プログラム"
"は B<FD_CLOEXEC> フラグをセットするために B<fcntl>()  の B<F_SETFD> 操作を追"
"加で行う必要がなくなる。 このフラグがなぜ有用かについては、 B<open>(2)  の "
"B<O_CLOEXEC> の説明を参照のこと。"

#. type: SS
#: build/C/man2/fcntl.2:141
#, no-wrap
msgid "File descriptor flags"
msgstr "ファイルディスクリプターフラグ"

#. type: Plain text
#: build/C/man2/fcntl.2:159
#, fuzzy
#| msgid ""
#| "The following commands manipulate the flags associated with a file "
#| "descriptor.  Currently, only one such flag is defined: B<FD_CLOEXEC>, the "
#| "close-on-exec flag.  If the B<FD_CLOEXEC> bit is 0, the file descriptor "
#| "will remain open across an B<execve>(2), otherwise it will be closed."
msgid ""
"The following commands manipulate the flags associated with a file "
"descriptor.  Currently, only one such flag is defined: B<FD_CLOEXEC>, the "
"close-on-exec flag.  If the B<FD_CLOEXEC> bit is set, the file descriptor "
"will automatically be closed during a successful B<execve>(2).  (If the "
"B<execve>(2)  fails, the file descriptor is left open.)  If the "
"B<FD_CLOEXEC> bit is not set, the file descriptor will remain open across an "
"B<execve>(2)."
msgstr ""
"以下のコマンドを使って、ファイルディスクリプターに関連するフラグ を操作するこ"
"とができる。 現在のところ、定義されているフラグは一つだけである: "
"B<FD_CLOEXEC> (close-on-exec フラグ)。 B<FD_CLOEXEC> ビットが 0 なら、ファイ"
"ルディスクリプターは B<execve>(2)  を行ってもオープンされたままだが、そうでな"
"い場合はクローズされる。"

#. type: TP
#: build/C/man2/fcntl.2:159
#, no-wrap
msgid "B<F_GETFD> (I<void>)"
msgstr "B<F_GETFD> (I<void>)"

#. type: Plain text
#: build/C/man2/fcntl.2:164
#, fuzzy
#| msgid "Read the file descriptor flags; I<arg> is ignored."
msgid ""
"Return (as the function result) the file descriptor flags; I<arg> is ignored."
msgstr "ファイルディスクリプターフラグを読み出す。 I<arg> は無視される。"

#. type: TP
#: build/C/man2/fcntl.2:164
#, no-wrap
msgid "B<F_SETFD> (I<int>)"
msgstr "B<F_SETFD> (I<int>)"

#. type: Plain text
#: build/C/man2/fcntl.2:168
msgid "Set the file descriptor flags to the value specified by I<arg>."
msgstr "ファイルディスクリプターフラグに I<arg> で指定した値を設定する。"

#. type: Plain text
#: build/C/man2/fcntl.2:183
msgid ""
"In multithreaded programs, using B<fcntl>()  B<F_SETFD> to set the close-on-"
"exec flag at the same time as another thread performs a B<fork>(2)  plus "
"B<execve>(2)  is vulnerable to a race condition that may unintentionally "
"leak the file descriptor to the program executed in the child process.  See "
"the discussion of the B<O_CLOEXEC> flag in B<open>(2)  for details and a "
"remedy to the problem."
msgstr ""
"マルチスレッドプログラムでは、 B<fcntl>() の B<F_SETFD> を使って close-on-"
"exec フラグを設定するのと同時に、 別のスレッドで B<execve>(2) と B<fork>(2) "
"を実行することは、競合条件次第では、 そのファイルディスクリプターが子プロセス"
"で実行されるプログラムに意図せず見えてしまうという危険性がある。 詳細とこの問"
"題への対処法については B<open>(2) の B<O_CLOEXEC> フラグの議論を参照のこと。"

#. type: SS
#: build/C/man2/fcntl.2:183
#, no-wrap
msgid "File status flags"
msgstr "ファイル状態フラグ"

#.  or
#.  .BR creat (2),
#. type: Plain text
#: build/C/man2/fcntl.2:198
msgid ""
"Each open file description has certain associated status flags, initialized "
"by B<open>(2)  and possibly modified by B<fcntl>().  Duplicated file "
"descriptors (made with B<dup>(2), B<fcntl>(F_DUPFD), B<fork>(2), etc.) refer "
"to the same open file description, and thus share the same file status flags."
msgstr ""
"オープンファイル記述 (open file description) には、 ファイル記述毎に設定され"
"る状態フラグがいくつかある。これらのフラグは B<open>(2)  によって初期化さ"
"れ、 B<fcntl>(2)  により変更することもできる。これらは、 (B<dup>(2), "
"B<fcntl>(F_DUPFD), B<fork>(2)  などで) 複製されたファイルディスクリプター同士"
"は 同じオープンファイル記述を参照する。 そのため、 同じファイル状態フラグが共"
"有される。"

#. type: Plain text
#: build/C/man2/fcntl.2:201
msgid "The file status flags and their semantics are described in B<open>(2)."
msgstr "ファイル状態フラグとその意味は B<open>(2)  で説明されている。"

#. type: TP
#: build/C/man2/fcntl.2:201
#, no-wrap
msgid "B<F_GETFL> (I<void>)"
msgstr "B<F_GETFL> (I<void>)"

#. type: Plain text
#: build/C/man2/fcntl.2:207
#, fuzzy
#| msgid ""
#| "Get the file access mode and the file status flags; I<arg> is ignored."
msgid ""
"Return (as the function result)  the file access mode and the file status "
"flags; I<arg> is ignored."
msgstr ""
"ファイルのアクセスモードとファイル状態フラグを取得する。\n"
"I<arg> は無視される。"

#. type: TP
#: build/C/man2/fcntl.2:207
#, no-wrap
msgid "B<F_SETFL> (I<int>)"
msgstr "B<F_SETFL> (I<int>)"

#. type: Plain text
#: build/C/man2/fcntl.2:232
msgid ""
"Set the file status flags to the value specified by I<arg>.  File access "
"mode (B<O_RDONLY>, B<O_WRONLY>, B<O_RDWR>)  and file creation flags (i.e., "
"B<O_CREAT>, B<O_EXCL>, B<O_NOCTTY>, B<O_TRUNC>)  in I<arg> are ignored.  On "
"Linux, this command can change only the B<O_APPEND>, B<O_ASYNC>, "
"B<O_DIRECT>, B<O_NOATIME>, and B<O_NONBLOCK> flags.  It is not possible to "
"change the B<O_DSYNC> and B<O_SYNC> flags; see BUGS, below."
msgstr ""
"ファイル状態フラグに I<arg> で指定された値を設定する。 I<arg> のうち、ファイ"
"ルのアクセスモード (B<O_RDONLY>, B<O_WRONLY>, B<O_RDWR>)  とファイル作成フラ"
"グ (すなわち B<O_CREAT>, B<O_EXCL>, B<O_NOCTTY>, B<O_TRUNC>)  に関するビット"
"は無視される。 Linux では、このコマンドで変更できるのは B<O_APPEND>, "
"B<O_ASYNC>, B<O_DIRECT>, B<O_NOATIME>, B<O_NONBLOCK> フラグだけである。フラ"
"グ B<O_DSYNC>, B<O_SYNC> を変更することはできない。下記の「バグ」を参照。"

#. type: SS
#: build/C/man2/fcntl.2:232
#, no-wrap
msgid "Advisory record locking"
msgstr "アドバイザリーレコードロック"

#. type: Plain text
#: build/C/man2/fcntl.2:237
msgid ""
"Linux implements traditional (\"process-associated\") UNIX record locks, as "
"standardized by POSIX.  For a Linux-specific alternative with better "
"semantics, see the discussion of open file description locks below."
msgstr ""
"Linux は昔からある (「プロセスに関連付けられる」) UNIX のレコードロックを実装"
"している。 このレコードロックは POSIX で標準化されている。 Linux 固有のより良"
"い動作を行うロックについては、下記のオープンファイル記述ロックの議論を参照の"
"こと。"

#. type: Plain text
#: build/C/man2/fcntl.2:248
msgid ""
"B<F_SETLK>, B<F_SETLKW>, and B<F_GETLK> are used to acquire, release, and "
"test for the existence of record locks (also known as byte-range, file-"
"segment, or file-region locks).  The third argument, I<lock>, is a pointer "
"to a structure that has at least the following fields (in unspecified order)."
msgstr ""
"B<F_SETLK>, B<F_SETLKW>, B<F_GETLK> は、レコードロックの獲得／解放／テストの"
"ために使用する (レコードロックは、バイト範囲ロック、ファイルセグメントロッ"
"ク、ファイル領域ロックとも呼ばれる)。 三番目の引数 I<lock> は、以下に示す"
"フィールドを含む構造体へのポインターである (フィールドの順序は関係なく、構造"
"体に他のフィールドがあってもよい)。"

#. type: Plain text
#: build/C/man2/fcntl.2:263
#, no-wrap
msgid ""
"struct flock {\n"
"    ...\n"
"    short l_type;    /* Type of lock: F_RDLCK,\n"
"                        F_WRLCK, F_UNLCK */\n"
"    short l_whence;  /* How to interpret l_start:\n"
"                        SEEK_SET, SEEK_CUR, SEEK_END */\n"
"    off_t l_start;   /* Starting offset for lock */\n"
"    off_t l_len;     /* Number of bytes to lock */\n"
"    pid_t l_pid;     /* PID of process blocking our lock\n"
"                        (set by F_GETLK and F_OFD_GETLK) */\n"
"    ...\n"
"};\n"
msgstr ""
"struct flock {\n"
"    ...\n"
"    short l_type;    /* Type of lock: F_RDLCK,\n"
"                        F_WRLCK, F_UNLCK */\n"
"    short l_whence;  /* How to interpret l_start:\n"
"                        SEEK_SET, SEEK_CUR, SEEK_END */\n"
"    off_t l_start;   /* Starting offset for lock */\n"
"    off_t l_len;     /* Number of bytes to lock */\n"
"    pid_t l_pid;     /* PID of process blocking our lock\n"
"                        (set by F_GETLK and F_OFD_GETLK) */\n"
"    ...\n"
"};\n"

#. type: Plain text
#: build/C/man2/fcntl.2:271
msgid ""
"The I<l_whence>, I<l_start>, and I<l_len> fields of this structure specify "
"the range of bytes we wish to lock.  Bytes past the end of the file may be "
"locked, but not bytes before the start of the file."
msgstr ""
"この構造体の I<l_whence>, I<l_start>, I<l_len> フィールドで、ロックを行いたい"
"バイト範囲を指定する。 ファイルの末尾より後ろのバイトをロックすることはできる"
"が、 ファイルの先頭より前のバイトをロックすることはできない。"

#. type: Plain text
#: build/C/man2/fcntl.2:291
msgid ""
"I<l_start> is the starting offset for the lock, and is interpreted relative "
"to either: the start of the file (if I<l_whence> is B<SEEK_SET>); the "
"current file offset (if I<l_whence> is B<SEEK_CUR>); or the end of the file "
"(if I<l_whence> is B<SEEK_END>).  In the final two cases, I<l_start> can be "
"a negative number provided the offset does not lie before the start of the "
"file."
msgstr ""
"I<l_start> はロックを行う領域の開始オフセットである。 その意味は I<l_whence> "
"により異なる: I<l_whence> が B<SEEK_SET> の場合はファイルの先頭からのオフセッ"
"ト、 I<l_whence> が B<SEEK_CUR> の場合は現在のファイルオフセットからのオフ"
"セット、 I<l_whence> が B<SEEK_END> の場合はファイルの末尾からのオフセットと"
"解釈される。 後ろの２つの場合には、 ファイルの先頭より前にならない範囲で、 "
"I<l_start> に負の値を指定することができる。"

#. type: Plain text
#: build/C/man2/fcntl.2:306
msgid ""
"I<l_len> specifies the number of bytes to be locked.  If I<l_len> is "
"positive, then the range to be locked covers bytes I<l_start> up to and "
"including I<l_start>+I<l_len>-1.  Specifying 0 for I<l_len> has the special "
"meaning: lock all bytes starting at the location specified by I<l_whence> "
"and I<l_start> through to the end of file, no matter how large the file "
"grows."
msgstr ""
"I<l_len> はロックしたいバイト数を示す。 I<l_len> が正の場合、ロックされるバイ"
"ト範囲は I<l_start> 以上 I<l_start>+I<l_len>-1 以下となる。 I<l_len> に 0 を"
"指定した場合は特別な意味を持つ: I<l_whence> and I<l_start> で指定される位置か"
"らファイルの末尾までの全てのバイトをロックする (ファイルがどんなに大きくなっ"
"たとしてもファイルの末尾までロックする)。"

#. type: Plain text
#: build/C/man2/fcntl.2:319
msgid ""
"POSIX.1-2001 allows (but does not require)  an implementation to support a "
"negative I<l_len> value; if I<l_len> is negative, the interval described by "
"I<lock> covers bytes I<l_start>+I<l_len> up to and including I<l_start>-1.  "
"This is supported by Linux since kernel versions 2.4.21 and 2.5.49."
msgstr ""
"POSIX.1-2001 では、負の値の I<l_len> をサポートする実装を認めている (必須では"
"ない)。 I<l_len> が負の場合、ロックされるバイト範囲は I<l_start>+I<l_len> 以"
"上 I<l_start>-1 以下となる。 この動作はカーネル 2.4.21 以降および 2.5.49 以降"
"の Linux で サポートされている。"

#. type: Plain text
#: build/C/man2/fcntl.2:338
msgid ""
"The I<l_type> field can be used to place a read (B<F_RDLCK>)  or a write "
"(B<F_WRLCK>)  lock on a file.  Any number of processes may hold a read lock "
"(shared lock)  on a file region, but only one process may hold a write lock "
"(exclusive lock).  An exclusive lock excludes all other locks, both shared "
"and exclusive.  A single process can hold only one type of lock on a file "
"region; if a new lock is applied to an already-locked region, then the "
"existing lock is converted to the new lock type.  (Such conversions may "
"involve splitting, shrinking, or coalescing with an existing lock if the "
"byte range specified by the new lock does not precisely coincide with the "
"range of the existing lock.)"
msgstr ""
"I<l_type> フィールドは、ファイルに対して読み出しロック (B<F_RDLCK>)  と書き込"
"みロック (B<F_WRLCK>)  のどちらを 設定するかを指定する。 ファイルのある領域に"
"対して、読み出しロック (共有ロック) を保持できる プロセス数に制限はないが、書"
"き込みロック (排他ロック) を保持できる のは一つのプロセスだけである。排他ロッ"
"クを設定すると、(共有ロックか 排他ロックにかかわらず) 他のロックは何も設定で"
"きない。 一つのプロセスは、ファイルのある領域に対して一種類のロックしか保持で"
"きない。 新規のロックがロックが設定されている領域に対して適用されると、既存の"
"ロック は新規のロックの種別に変換される (新規のロックで指定されたバイト範囲が"
"既存ロックの範囲と一致する場合以外では、 変換の過程で既存のロックの分割、縮"
"小、結合が行われることがある)。"

#. type: TP
#: build/C/man2/fcntl.2:338
#, no-wrap
msgid "B<F_SETLK> (I<struct flock *>)"
msgstr "B<F_SETLK> (I<struct flock *>)"

#. type: Plain text
#: build/C/man2/fcntl.2:363
msgid ""
"Acquire a lock (when I<l_type> is B<F_RDLCK> or B<F_WRLCK>)  or release a "
"lock (when I<l_type> is B<F_UNLCK>)  on the bytes specified by the "
"I<l_whence>, I<l_start>, and I<l_len> fields of I<lock>.  If a conflicting "
"lock is held by another process, this call returns -1 and sets I<errno> to "
"B<EACCES> or B<EAGAIN>.  (The error returned in this case differs across "
"implementations, so POSIX requires a portable application to check for both "
"errors.)"
msgstr ""
"(I<l_type> が B<F_RDLCK> か B<F_WRLCK> の場合は) ロックの獲得を、 "
"(B<F_UNLCK> の場合は) ロックの解放を、 I<flock> 構造体のフィールド "
"I<l_whence>, I<l_start>, I<l_len> で指定された範囲のバイトに対して行う。 指定"
"されたロックが他のプロセスが設定しているロックと衝突する場合は、 -1 を返し、 "
"I<errno> に B<EACCES> か B<EAGAIN> を設定する。 (この場合に返されるエラーは実"
"装により異なる。 そのため、 POSIX では移植性が必要なアプリケーションでは、 こ"
"れらの両方のエラーをチェックすることが必要としている。)"

#. type: TP
#: build/C/man2/fcntl.2:363
#, no-wrap
msgid "B<F_SETLKW> (I<struct flock *>)"
msgstr "B<F_SETLKW> (I<struct flock *>)"

#. type: Plain text
#: build/C/man2/fcntl.2:377
msgid ""
"As for B<F_SETLK>, but if a conflicting lock is held on the file, then wait "
"for that lock to be released.  If a signal is caught while waiting, then the "
"call is interrupted and (after the signal handler has returned)  returns "
"immediately (with return value -1 and I<errno> set to B<EINTR>; see "
"B<signal>(7))."
msgstr ""
"B<F_SETLK> と同様だが、こちらではそのファイルに対して衝突するロックが 適用さ"
"れていた場合に、そのロックが解放されるのを待つ点が異なる。 待っている間にシグ"
"ナルを受けた場合は、システムコールは中断され、 (シグナルハンドラーが戻った直"
"後に) 返り値 -1 を返す (また I<errno> に B<EINTR> が設定される; "
"B<signal>(7)  参照)。"

#. type: TP
#: build/C/man2/fcntl.2:377
#, no-wrap
msgid "B<F_GETLK> (I<struct flock *>)"
msgstr "B<F_GETLK> (I<struct flock *>)"

#. type: Plain text
#: build/C/man2/fcntl.2:391
msgid ""
"On input to this call, I<lock> describes a lock we would like to place on "
"the file.  If the lock could be placed, B<fcntl>()  does not actually place "
"it, but returns B<F_UNLCK> in the I<l_type> field of I<lock> and leaves the "
"other fields of the structure unchanged."
msgstr ""
"このコールの呼び出し時には、 I<lock> にはそのファイルに適用しようとするロック"
"に関する情報が入っている。 ロックを適用できる場合には、 B<fcntl>()  は実際に"
"はロックを行わず、 構造体 I<lock> の I<l_type> フィールドに B<F_UNLCK> を返"
"し、 他のフィールドは変更しない。 "

#. type: Plain text
#: build/C/man2/fcntl.2:408
msgid ""
"If one or more incompatible locks would prevent this lock being placed, then "
"B<fcntl>()  returns details about one of those locks in the I<l_type>, "
"I<l_whence>, I<l_start>, and I<l_len> fields of I<lock>.  If the conflicting "
"lock is a traditional (process-associated) record lock, then the I<l_pid> "
"field is set to the PID of the process holding that lock.  If the "
"conflicting lock is an open file description lock, then I<l_pid> is set to "
"-1.  Note that the returned information may already be out of date by the "
"time the caller inspects it."
msgstr ""
"違う種別のロックが (一つもしくは複数) 適用されていてロックを適用できないよう"
"な場合には、 B<fcntl>() は、 原因となったロックの一つについての詳細を、 "
"I<lock> のフィールド I<l_type>, I<l_whence>, I<l_start>, I<l_len> で返す。 衝"
"突するロックが昔からある (プロセスに関連付けられる) レコードロックの場合、 "
"I<l_pid> フィールドにロックを保持しているプロセスの PID が設定される。 衝突す"
"るロックがオープンファイル記述ロックの場合、 I<l_pid> に -1 が設定される。 呼"
"び出し元がその内容を参照した時点では、 返された情報はすでに古いものとなってい"
"る可能性がある点に注意すること。"

#. type: Plain text
#: build/C/man2/fcntl.2:416
msgid ""
"In order to place a read lock, I<fd> must be open for reading.  In order to "
"place a write lock, I<fd> must be open for writing.  To place both types of "
"lock, open a file read-write."
msgstr ""
"読み出しロックを適用するには、 I<fd> は読み出し用にオープンされていなければな"
"らない。 書き込みロックを適用するには、 I<fd> は書き込み用にオープンされてい"
"なければならない。 読み書き両方のロックを適用するには、読み書き両用で ファイ"
"ルをオープンしなければならない。"

#. type: Plain text
#: build/C/man2/fcntl.2:439
msgid ""
"When placing locks with B<F_SETLKW>, the kernel detects I<deadlocks>, "
"whereby two or more processes have their lock requests mutually blocked by "
"locks held by the other processes.  For example, suppose process A holds a "
"write lock on byte 100 of a file, and process B holds a write lock on byte "
"200.  If each process then attempts to lock the byte already locked by the "
"other process using B<F_SETLKW>, then, without deadlock detection, both "
"processes would remain blocked indefinitely.  When the kernel detects such "
"deadlocks, it causes one of the blocking lock requests to immediately fail "
"with the error B<EDEADLK>; an application that encounters such an error "
"should release some of its locks to allow other applications to proceed "
"before attempting regain the locks that it requires.  Circular deadlocks "
"involving more than two processes are also detected.  Note, however, that "
"there are limitations to the kernel's deadlock-detection algorithm; see BUGS."
msgstr ""
"B<F_SETLKW> でロックを適用する際、 カーネルはI<デッドロック>の検出を行う。 2 "
"つ以上のプロセスが、 他のプロセスが保持するロックにより互いにブロックされるよ"
"うなロック要求を行っているかを検査する。 例えば、 プロセス A があるファイルの"
"バイト 100 に対して書き込みロックを保持していて、 プロセス B がバイト 200 に"
"対して書き込みロックを保持しているとする。 各プロセスが B<F_SETLKW> を使って"
"他のプロセスによるすでにロックされているバイトをロックしようとすると、 デッド"
"ロック検出がない場合、 両方のプロセスが無限に停止することになる。 カーネルは"
"このようなデッドロックを検出すると、 停止していたロック要求の一つをエラー "
"B<EDEADLK> ですぐに失敗させる。 このエラーを受け取ったアプリケーションは、 必"
"要なロックを再度獲得しようとする前に、 他のアプリケーションが実行できるように"
"自分が保持するロックのいくつかを解放する必要がある。 3 つ以上のプロセスが関連"
"する循環するデッドロックも検出される。 ただし、 カーネルのデッドロック検出ア"
"ルゴリズムには制限がある点に注意すること。 「バグ」を参照。"

#. type: Plain text
#: build/C/man2/fcntl.2:443
msgid ""
"As well as being removed by an explicit B<F_UNLCK>, record locks are "
"automatically released when the process terminates."
msgstr "レコードロックは B<F_UNLCK> で明示的に削除されるだけでなく、 そのプロセスが終了した際には自動的に解放される。"

#. type: Plain text
#: build/C/man2/fcntl.2:448
msgid ""
"Record locks are not inherited by a child created via B<fork>(2), but are "
"preserved across an B<execve>(2)."
msgstr ""
"レコードのロックは B<fork>(2)  で作成された子プロセスには継承されないが、 "
"B<execve>(2)  の前後では保存される。"

#. type: Plain text
#: build/C/man2/fcntl.2:457
msgid ""
"Because of the buffering performed by the B<stdio>(3)  library, the use of "
"record locking with routines in that package should be avoided; use "
"B<read>(2)  and B<write>(2)  instead."
msgstr ""
"B<stdio>(3)  ではバッファーリングが行われるので、 stdio 関連の関数ではレコー"
"ドのロックの使用は回避される; 代わりに B<read>(2)  や B<write>(2)  を使用する"
"こと。"

#. type: Plain text
#: build/C/man2/fcntl.2:461
msgid ""
"The record locks described above are associated with the process (unlike the "
"open file description locks described below).  This has some unfortunate "
"consequences:"
msgstr ""
"上記で説明したレコードロックはプロセスと関連付けられる (以下で説明するオープ"
"ンファイル記述ロックと異なる点である)。 そのため、 残念ながら以下のようなこと"
"が起こる。"

#.  (Additional file descriptors referring to the same file
#.  may have been obtained by calls to
#.  .BR open "(2), " dup "(2), " dup2 "(2), or " fcntl ().)
#. type: Plain text
#: build/C/man2/fcntl.2:477
msgid ""
"If a process closes I<any> file descriptor referring to a file, then all of "
"the process's locks on that file are released, regardless of the file "
"descriptor(s) on which the locks were obtained.  This is bad: it means that "
"a process can lose its locks on a file such as I</etc/passwd> or I</etc/"
"mtab> when for some reason a library function decides to open, read, and "
"close the same file."
msgstr ""
"プロセスがロックが適用されているファイルを参照しているファイルディスクリプ"
"ターの「いずれか」をクローズした場合、 そのファイルに対するそのプロセスのすべ"
"てのロックが解放される。 この動作はまずい。 あるプロセスが I</etc/passwd> や "
"I</etc/mtab> といったファイルにロックを適用しているときに、 あるライブラリ関"
"数が何かの理由で同じファイルを open, read, close すると、そのファイルへのロッ"
"クが失われることになる。"

#. type: Plain text
#: build/C/man2/fcntl.2:482
msgid ""
"The threads in a process share locks.  In other words, a multithreaded "
"program can't use record locking to ensure that threads don't simultaneously "
"access the same region of a file."
msgstr ""
"1 つのプロセス内のスレッドはロックを共有する。 言い換えると、 マルチスレッド"
"のプログラムで、 レコードロックを使って、 複数のスレッドが同時に 1 つのファイ"
"ルの同じ領域にアクセスしないようにすることはできないということだ。"

#. type: Plain text
#: build/C/man2/fcntl.2:484
msgid "Open file description locks solve both of these problems."
msgstr "オープンファイル記述ロックを使うとこれらの問題が解決できる。"

#. type: SS
#: build/C/man2/fcntl.2:484
#, no-wrap
msgid "Open file description locks (non-POSIX)"
msgstr "オープンファイル記述ロック (非 POSIX)"

#.  FIXME . Review progress into POSIX
#.  http://austingroupbugs.net/view.php?id=768
#. type: Plain text
#: build/C/man2/fcntl.2:495
#, fuzzy
#| msgid ""
#| "Open file description locks are advisory byte-range locks whose operation "
#| "is in most respects identical to the traditional record locks described "
#| "above.  This lock type is Linux-specific, and available since Linux "
#| "3.15.  For an explanation of open file descriptions, see B<open>(2)."
msgid ""
"Open file description locks are advisory byte-range locks whose operation is "
"in most respects identical to the traditional record locks described above.  "
"This lock type is Linux-specific, and available since Linux 3.15.  (There is "
"a proposal with the Austin Group to include this lock type in the next "
"revision of POSIX.1.)  For an explanation of open file descriptions, see "
"B<open>(2)."
msgstr ""
"オープンファイル記述ロックはバイト範囲に対するアドバイザリーロックで、 ほとん"
"どの点で上述の昔からあるレコードロックと等価である。 このロック種別は Linux "
"固有であり、 Linux 3.15 以降で利用できる。 オープンファイル記述の説明は "
"B<open>(2) を参照。"

#. type: Plain text
#: build/C/man2/fcntl.2:513
msgid ""
"The principal difference between the two lock types is that whereas "
"traditional record locks are associated with a process, open file "
"description locks are associated with the open file description on which "
"they are acquired, much like locks acquired with B<flock>(2).  Consequently "
"(and unlike traditional advisory record locks), open file description locks "
"are inherited across B<fork>(2)  (and B<clone>(2)  with B<CLONE_FILES>), and "
"are only automatically released on the last close of the open file "
"description, instead of being released on any close of the file."
msgstr ""
"2 つのロック種別の主な違いは、 昔からあるレコードロックはプロセスに関連付けら"
"れるのに対して、 オープンファイル記述ロックはロックが獲得されるオープンファイ"
"ル記述に関連付けられる点である。 この動作は B<flock>(2) で獲得されるロックに"
"よく似ている。 結果として (昔からあるアドバイザリーレコードロックと違い)、 "
"オープンファイル記述ロックは B<fork>(2) (や B<CLONE_FILES> 付きの "
"B<clone>(2)) の前後で継承され、 ファイルのクローズ時に解放されるのではなく、 "
"オープンファイル記述の最後のクローズ時にのみ自動的に解放される。"

#. type: Plain text
#: build/C/man2/fcntl.2:519
#, fuzzy
#| msgid ""
#| "Open file description locks always conflict with traditional record "
#| "locks, even when they are acquired by the same process on the same file "
#| "descriptor."
msgid ""
"Conflicting lock combinations (i.e., a read lock and a write lock or two "
"write locks)  where one lock is an open file description lock and the other "
"is a traditional record lock conflict even when they are acquired by the "
"same process on the same file descriptor."
msgstr ""
"オープンファイル記述ロックは常に昔からあるレコードロックと競合する。 たと"
"え、 ロックが同じプロセスによって同じファイルディスクリプターに対して行われた"
"としてもである。"

#. type: Plain text
#: build/C/man2/fcntl.2:532
msgid ""
"Open file description locks placed via the same open file description (i.e., "
"via the same file descriptor, or via a duplicate of the file descriptor "
"created by B<fork>(2), B<dup>(2), B<fcntl>()  B<F_DUPFD>, and so on) are "
"always compatible: if a new lock is placed on an already locked region, then "
"the existing lock is converted to the new lock type.  (Such conversions may "
"result in splitting, shrinking, or coalescing with an existing lock as "
"discussed above.)"
msgstr ""
"同じオープンファイル記述経由 (同じファイルディスクリプター経由や B<fork>(2), "
"B<dup>(2), B<fcntl>() B<F_DUPFD> などで作成されたファイルディスクリプターの複"
"製経由) で適用されたオープンファイル記述ロックは常に互換性がある。 つまり、 "
"すでにロックされている領域に対して新しいロックが適用された場合、 既存のロック"
"は新しいロック種別に変換される。 (上記で説明した通り、 このような変換の結"
"果、 既存のロックの分割、 縮小、 結合が行われることがある。)"

#. type: Plain text
#: build/C/man2/fcntl.2:540
msgid ""
"On the other hand, open file description locks may conflict with each other "
"when they are acquired via different open file descriptions.  Thus, the "
"threads in a multithreaded program can use open file description locks to "
"synchronize access to a file region by having each thread perform its own "
"B<open>(2)  on the file and applying locks via the resulting file descriptor."
msgstr ""
"一方、 異なるオープンファイル記述経由で獲得されると、 オープンファイル記述"
"ロックは互いに競合する。 したがって、 マルチスレッドプログラムのスレッドは、 "
"各スレッドがそれぞれ自分で B<open>(2) を実行し、 得られたファイルディスクリプ"
"ター経由でロックを適用することで、 オープンファイル記述ロックを使って一つの"
"ファイル領域えのアクセスを同期させることができる。"

#. type: Plain text
#: build/C/man2/fcntl.2:551
msgid ""
"As with traditional advisory locks, the third argument to B<fcntl>(), "
"I<lock>, is a pointer to an I<flock> structure.  By contrast with "
"traditional record locks, the I<l_pid> field of that structure must be set "
"to zero when using the commands described below."
msgstr ""
"昔からあるレコードロックの場合と同様、 B<fcntl>() の第 3 引数 I<lock> は "
"I<flock> 構造体へのポインターである。 昔からあるレコードロックと違い、 下記で"
"説明するコマンドを使う際には、 この構造体のフィールド I<l_pid> に 0 を設定し"
"なければならない。"

#. type: Plain text
#: build/C/man2/fcntl.2:554
msgid ""
"The commands for working with open file description locks are analogous to "
"those used with traditional locks:"
msgstr ""
"オープンファイル記述ロックで使用できるコマンドは、 昔からあるロックのコマンド"
"と同じである。"

#. type: TP
#: build/C/man2/fcntl.2:554
#, no-wrap
msgid "B<F_OFD_SETLK> (I<struct flock *>)"
msgstr "B<F_OFD_SETLK> (I<struct flock *>)"

#. type: Plain text
#: build/C/man2/fcntl.2:575
msgid ""
"Acquire an open file description lock (when I<l_type> is B<F_RDLCK> or "
"B<F_WRLCK>)  or release an open file description lock (when I<l_type> is "
"B<F_UNLCK>)  on the bytes specified by the I<l_whence>, I<l_start>, and "
"I<l_len> fields of I<lock>.  If a conflicting lock is held by another "
"process, this call returns -1 and sets I<errno> to B<EAGAIN>."
msgstr ""
"(I<l_type> が B<F_RDLCK> か B<F_WRLCK> の場合は) オープンファイル記述のロック"
"の獲得を、 (B<F_UNLCK> の場合は) オープンファイル記述のロックの解放を、 "
"I<flock> 構造体のフィールド I<l_whence>, I<l_start>, I<l_len> で指定された範"
"囲のバイトに対して行う。 指定されたロックが他のプロセスが設定しているロックと"
"衝突する場合は、 -1 を返し、 I<errno> に B<EAGAIN> を設定する。"

#. type: TP
#: build/C/man2/fcntl.2:575
#, no-wrap
msgid "B<F_OFD_SETLKW> (I<struct flock *>)"
msgstr "B<F_OFD_SETLKW> (I<struct flock *>)"

#. type: Plain text
#: build/C/man2/fcntl.2:589
msgid ""
"As for B<F_OFD_SETLK>, but if a conflicting lock is held on the file, then "
"wait for that lock to be released.  If a signal is caught while waiting, "
"then the call is interrupted and (after the signal handler has returned) "
"returns immediately (with return value -1 and I<errno> set to B<EINTR>; see "
"B<signal>(7))."
msgstr ""
"B<F_OFD_SETLK> と同様だが、こちらではそのファイルに対して衝突するロックが 適"
"用されていた場合に、そのロックが解放されるのを待つ点が異なる。 待っている間に"
"シグナルを受けた場合は、システムコールは中断され、 (シグナルハンドラーが戻っ"
"た直後に) 返り値 -1 を返す (また I<errno> に B<EINTR> が設定される; "
"B<signal>(7)  参照)。"

#. type: TP
#: build/C/man2/fcntl.2:589
#, no-wrap
msgid "B<F_OFD_GETLK> (I<struct flock *>)"
msgstr "B<F_OFD_GETLK> (I<struct flock *>)"

#. type: Plain text
#: build/C/man2/fcntl.2:608
msgid ""
"On input to this call, I<lock> describes an open file description lock we "
"would like to place on the file.  If the lock could be placed, B<fcntl>()  "
"does not actually place it, but returns B<F_UNLCK> in the I<l_type> field of "
"I<lock> and leaves the other fields of the structure unchanged.  If one or "
"more incompatible locks would prevent this lock being placed, then details "
"about one of these locks are returned via I<lock>, as described above for "
"B<F_GETLK>."
msgstr ""
"このコールの呼び出し時には、 I<lock> にはそのファイルに適用しようとするロック"
"に関する情報が入っている。 ロックを適用できる場合には、 B<fcntl>()  は実際に"
"はロックを行わず、 構造体 I<lock> の I<l_type> フィールドで B<F_UNLCK> を返"
"し、 他のフィールドは変更しない。 違う種別のロックが (一つもしくは複数) 適用"
"されていてロックを適用できないような場合には、 原因となったロックの一つについ"
"ての詳細が I<lock> で返される。 詳細は上記の B<F_GETLK> を参照。"

#.  commit 57b65325fe34ec4c917bc4e555144b4a94d9e1f7
#. type: Plain text
#: build/C/man2/fcntl.2:615
msgid ""
"In the current implementation, no deadlock detection is performed for open "
"file description locks.  (This contrasts with process-associated record "
"locks, for which the kernel does perform deadlock detection.)"
msgstr ""
"現在の実装では、 オープンファイル記述ロクではデッドロックの検出は行われな"
"い。 (これがプロセスと関連付けられるレコードロックとは異なる点である。 プロセ"
"スと関連付けられるレコードロックではカーネルはデッドロックの検出を行う。)"

#. type: SS
#: build/C/man2/fcntl.2:615 build/C/man2/fcntl.2:2084
#, no-wrap
msgid "Mandatory locking"
msgstr "強制ロック (mandatory locking)"

#. type: Plain text
#: build/C/man2/fcntl.2:625
msgid ""
"I<Warning>: the Linux implementation of mandatory locking is unreliable.  "
"See BUGS below.  Because of these bugs, and the fact that the feature is "
"believed to be little used, since Linux 4.5, mandatory locking has been made "
"an optional feature, governed by a configuration option "
"(B<CONFIG_MANDATORY_FILE_LOCKING>).  This is an initial step toward removing "
"this feature completely."
msgstr ""

#. type: Plain text
#: build/C/man2/fcntl.2:630
msgid ""
"By default, both traditional (process-associated) and open file description "
"record locks are advisory.  Advisory locks are not enforced and are useful "
"only between cooperating processes."
msgstr "デフォルトでは、 昔からある (プロセスに関連付けられる) レコードロックも、 オープンファイル記述のレコードロックも、 アドバイザリーロックである。 アドバイザリーロックに強制力はなく、協調して動作するプロセス間でのみ有効である。"

#. type: Plain text
#: build/C/man2/fcntl.2:650
msgid ""
"Both lock types can also be mandatory.  Mandatory locks are enforced for all "
"processes.  If a process tries to perform an incompatible access (e.g., "
"B<read>(2)  or B<write>(2))  on a file region that has an incompatible "
"mandatory lock, then the result depends upon whether the B<O_NONBLOCK> flag "
"is enabled for its open file description.  If the B<O_NONBLOCK> flag is not "
"enabled, then the system call is blocked until the lock is removed or "
"converted to a mode that is compatible with the access.  If the "
"B<O_NONBLOCK> flag is enabled, then the system call fails with the error "
"B<EAGAIN>."
msgstr ""
"両方のタイプのロックも強制ロックにすることもできる。 強制ロックは全てのプロセ"
"スに対して効果がある。 あるプロセスが互換性のない強制ロックが適用されたファイ"
"ル領域に対して (B<read>(2)  や B<write>(2)  により) 互換性のないアクセスを実"
"行しようとした場合、 アクセスの結果は そのファイルのオープンファイル記述で "
"B<O_NONBLOCK> フラグが有効になっているかにより決まる。 B<O_NONBLOCK> フラグが"
"有効になっていないときは、ロックが削除されるか、 ロックがアクセスと互換性のあ"
"るモードに変換されるまで、 システムコールは停止 (block) される。 "
"B<O_NONBLOCK> フラグが有効になっているときは、システムコールはエラー "
"B<EAGAIN> で失敗する。"

#. type: Plain text
#: build/C/man2/fcntl.2:667
msgid ""
"To make use of mandatory locks, mandatory locking must be enabled both on "
"the filesystem that contains the file to be locked, and on the file itself.  "
"Mandatory locking is enabled on a filesystem using the \"-o mand\" option to "
"B<mount>(8), or the B<MS_MANDLOCK> flag for B<mount>(2).  Mandatory locking "
"is enabled on a file by disabling group execute permission on the file and "
"enabling the set-group-ID permission bit (see B<chmod>(1)  and B<chmod>(2))."
msgstr ""
"強制ロックを使用するためには、ロック対象のファイルが含まれるファイルシステム "
"と、ロック対象のファイル自身の両方について、強制ロックが有効になっていなけれ "
"ばならない。ファイルシステムについて強制ロックを有効にするには、 "
"B<mount>(8)  に \"-o mand\" オプションを渡すか、 B<mount>(2)  に "
"B<MS_MANDLOCK> フラグを指定する。ファイルについて強制ロックを有効にするに"
"は、 そのファイルのグループ実行許可 (group execute permission) を無効とし、 "
"かつ set-group-ID 許可ビットを有効にする (B<chmod>(1)  と B<chmod>(2)  を参"
"照)。"

#. type: Plain text
#: build/C/man2/fcntl.2:672
msgid ""
"Mandatory locking is not specified by POSIX.  Some other systems also "
"support mandatory locking, although the details of how to enable it vary "
"across systems."
msgstr ""
"強制ロックは POSIX では規定されていない。 他のいくつかのシステムでも強制ロッ"
"クはサポートされているが、 強制ロックをどのようにして有効にするかの詳細はシス"
"テムより異なる。"

#. type: SS
#: build/C/man2/fcntl.2:672
#, fuzzy, no-wrap
#| msgid "Record locks"
msgid "Lost locks"
msgstr "レコードロック"

#. type: Plain text
#: build/C/man2/fcntl.2:679
msgid ""
"When an advisory lock is obtained on a networked filesystem such as NFS it "
"is possible that the lock might get lost.  This may happen due to "
"administrative action on the server, or due to a network partition (i.e., "
"loss of network connectivity with the server)  which lasts long enough for "
"the server to assume that the client is no longer functioning."
msgstr ""

#.  commit ef1820f9be27b6ad158f433ab38002ab8131db4d
#. type: Plain text
#: build/C/man2/fcntl.2:691
msgid ""
"When the filesystem determines that a lock has been lost, future B<read>(2)  "
"or B<write>(2)  requests may fail with the error B<EIO>.  This error will "
"persist until the lock is removed or the file descriptor is closed.  Since "
"Linux 3.12, this happens at least for NFSv4 (including all minor versions)."
msgstr ""

#. type: Plain text
#: build/C/man2/fcntl.2:698
msgid ""
"Some versions of UNIX send a signal (B<SIGLOST>)  in this circumstance.  "
"Linux does not define this signal, and does not provide any asynchronous "
"notification of lost locks."
msgstr ""

#. type: SS
#: build/C/man2/fcntl.2:698
#, no-wrap
msgid "Managing signals"
msgstr "シグナルの管理"

#. type: Plain text
#: build/C/man2/fcntl.2:707
msgid ""
"B<F_GETOWN>, B<F_SETOWN>, B<F_GETOWN_EX>, B<F_SETOWN_EX>, B<F_GETSIG>, and "
"B<F_SETSIG> are used to manage I/O availability signals:"
msgstr ""
"B<F_GETOWN>, B<F_SETOWN>, B<F_GETOWN_EX>, B<F_SETOWN_EX>, B<F_GETSIG>, "
"B<F_SETSIG> は、I/O が利用可能になったことを示すシグナルを管理するために使用"
"される。"

#. type: TP
#: build/C/man2/fcntl.2:707
#, no-wrap
msgid "B<F_GETOWN> (I<void>)"
msgstr "B<F_GETOWN> (I<void>)"

#. type: Plain text
#: build/C/man2/fcntl.2:720
msgid ""
"Return (as the function result)  the process ID or process group ID "
"currently receiving B<SIGIO> and B<SIGURG> signals for events on file "
"descriptor I<fd>.  Process IDs are returned as positive values; process "
"group IDs are returned as negative values (but see BUGS below).  I<arg> is "
"ignored."
msgstr ""
"ファイルディスクリプター I<fd> のイベントに対するシグナル B<SIGIO> および "
"B<SIGURG> を受けているプロセスのプロセス ID かプロセスグループ ID を (関数の"
"結果として) 返す。 プロセス ID は正の値として返される。 プロセスグループ ID "
"は負の値として返される (下記のバグの章を参照)。 I<arg> は無視される。"

#. type: TP
#: build/C/man2/fcntl.2:720
#, no-wrap
msgid "B<F_SETOWN> (I<int>)"
msgstr "B<F_SETOWN> (I<int>)"

#. type: Plain text
#: build/C/man2/fcntl.2:737
#, fuzzy
#| msgid ""
#| "Set the process ID or process group ID that will receive B<SIGIO> and "
#| "B<SIGURG> signals for events on file descriptor I<fd> to the ID given in "
#| "I<arg>.  A process ID is specified as a positive value; a process group "
#| "ID is specified as a negative value.  Most commonly, the calling process "
#| "specifies itself as the owner (that is, I<arg> is specified as "
#| "B<getpid>(2))."
msgid ""
"Set the process ID or process group ID that will receive B<SIGIO> and "
"B<SIGURG> signals for events on the file descriptor I<fd>.  The target "
"process or process group ID is specified in I<arg>.  A process ID is "
"specified as a positive value; a process group ID is specified as a negative "
"value.  Most commonly, the calling process specifies itself as the owner "
"(that is, I<arg> is specified as B<getpid>(2))."
msgstr ""
"ファイルディスクリプター I<fd> のイベント発生を知らせるシグナル B<SIGIO> や "
"B<SIGURG> を受けるプロセスの プロセス ID またはプロセスグループID を I<arg> "
"で指定された ID に設定する。 プロセスID は正の値として指定し、 プロセスグルー"
"プID は負の値として指定する。 ほとんどの場合、呼び出し元プロセスは所有者とし"
"て自分自身を指定する (つまり I<arg> に B<getpid>(2)  を指定する)。"

#. type: Plain text
#: build/C/man2/fcntl.2:755
#, fuzzy
#| msgid ""
#| "If you set the B<O_ASYNC> status flag on a file descriptor by using the "
#| "B<F_SETFL> command of B<fcntl>(), a B<SIGIO> signal is sent whenever "
#| "input or output becomes possible on that file descriptor.  B<F_SETSIG> "
#| "can be used to obtain delivery of a signal other than B<SIGIO>.  If this "
#| "permission check fails, then the signal is silently discarded."
msgid ""
"As well as setting the file descriptor owner, one must also enable "
"generation of signals on the file descriptor.  This is done by using the "
"B<fcntl>()  B<F_SETFL> command to set the B<O_ASYNC> file status flag on the "
"file descriptor.  Subsequently, a B<SIGIO> signal is sent whenever input or "
"output becomes possible on the file descriptor.  The B<fcntl>()  B<F_SETSIG> "
"command can be used to obtain delivery of a signal other than B<SIGIO>."
msgstr ""
"B<fcntl>()  の B<F_SETFL> コマンドを使用してファイルディスクリプターに "
"B<O_ASYNC> 状態フラグを設定した場合には、そのファイルディスクリプターへの 入"
"出力が可能になる度に B<SIGIO> シグナルが送られる。 B<F_SETSIG> は B<SIGIO> 以"
"外の別のシグナルの配送を受けられるように するのにも使うことができる。 許可 "
"(permission) のチェックで失敗した場合には、 シグナルは黙って捨てられる。"

#. type: Plain text
#: build/C/man2/fcntl.2:772
#, fuzzy
#| msgid ""
#| "Sending a signal to the owner process (group) specified by B<F_SETOWN> is "
#| "subject to the same permissions checks as are described for B<kill>(2), "
#| "where the sending process is the one that employs B<F_SETOWN> (but see "
#| "BUGS below)."
msgid ""
"Sending a signal to the owner process (group) specified by B<F_SETOWN> is "
"subject to the same permissions checks as are described for B<kill>(2), "
"where the sending process is the one that employs B<F_SETOWN> (but see BUGS "
"below).  If this permission check fails, then the signal is silently "
"discarded.  I<Note>: The B<F_SETOWN> operation records the caller's "
"credentials at the time of the B<fcntl>()  call, and it is these saved "
"credentials that are used for the permission checks."
msgstr ""
"B<F_SETOWN> により指定された所有者のプロセス (またはプロセスグループ) に シグ"
"ナルを送る際には、 B<kill>(2)  に書かれているのと同じ許可のチェックが行われ"
"る。 このとき、シグナルを送信するプロセスは B<F_SETOWN> を使ったプロセスであ"
"る (但し、下記の「バグ」の章を参照のこと)。"

#.  The following appears to be rubbish.  It doesn't seem to
#.  be true according to the kernel source, and I can write
#.  a program that gets a terminal-generated SIGIO even though
#.  it is not the foreground process group of the terminal.
#.  -- MTK, 8 Apr 05
#.  If the file descriptor
#.  .I fd
#.  refers to a terminal device, then SIGIO
#.  signals are sent to the foreground process group of the terminal.
#. type: Plain text
#: build/C/man2/fcntl.2:796
msgid ""
"If the file descriptor I<fd> refers to a socket, B<F_SETOWN> also selects "
"the recipient of B<SIGURG> signals that are delivered when out-of-band data "
"arrives on that socket.  (B<SIGURG> is sent in any situation where "
"B<select>(2)  would report the socket as having an \"exceptional condition"
"\".)"
msgstr ""
"ファイルディスクリプターがソケットを参照している場合は、 B<F_SETOWN> を使用し"
"て、ソケットに帯域外 (out-of-band) データが届いた時に B<SIGURG> シグナルを配"
"送する相手を選択することもできる (B<SIGURG> が送られた場合には B<select>(2)  "
"がソケットが「特別な状態」にあると報告することだろう)。"

#. type: Plain text
#: build/C/man2/fcntl.2:799
msgid ""
"The following was true in 2.6.x kernels up to and including kernel 2.6.11:"
msgstr "バージョン 2.6.11 以前の 2.6.x カーネルでは、以下に示す動作であった。"

#.  The relevant place in the (2.6) kernel source is the
#.  'switch' in fs/fcntl.c::send_sigio_to_task() -- MTK, Apr 2005
#.  send_sigurg()/send_sigurg_to_task() bypasses
#.  kill_fasync()/send_sigio()/send_sigio_to_task()
#.  to directly call send_group_sig_info()
#. 	-- MTK, Apr 2005 (kernel 2.6.11)
#. type: Plain text
#: build/C/man2/fcntl.2:839
msgid ""
"If a nonzero value is given to B<F_SETSIG> in a multithreaded process "
"running with a threading library that supports thread groups (e.g., NPTL), "
"then a positive value given to B<F_SETOWN> has a different meaning: instead "
"of being a process ID identifying a whole process, it is a thread ID "
"identifying a specific thread within a process.  Consequently, it may be "
"necessary to pass B<F_SETOWN> the result of B<gettid>(2)  instead of "
"B<getpid>(2)  to get sensible results when B<F_SETSIG> is used.  (In current "
"Linux threading implementations, a main thread's thread ID is the same as "
"its process ID.  This means that a single-threaded program can equally use "
"B<gettid>(2)  or B<getpid>(2)  in this scenario.)  Note, however, that the "
"statements in this paragraph do not apply to the B<SIGURG> signal generated "
"for out-of-band data on a socket: this signal is always sent to either a "
"process or a process group, depending on the value given to B<F_SETOWN>."
msgstr ""
"スレッドグループをサポートしているスレッドライブラリ (例えば NPTL) を 使って"
"動作しているマルチスレッドプロセスで B<F_SETSIG> に 0 以外の値を指定した場"
"合、 B<F_SETOWN> に正の値を渡すと、その意味が違ってくる: プロセス全体を示すプ"
"ロセスID ではなく、プロセス内の特定の スレッドを示すスレッドID と解釈され"
"る。 したがって、 B<F_SETSIG> を使う場合には、きちんと結果を受け取るには、 "
"B<F_SETOWN> に渡す値を B<getpid>(2)  ではなく B<gettid>(2)  の返り値にする必"
"要があるだろう。 (現状の Linux スレッド実装では、メインスレッドのスレッドID "
"は そのスレッドのプロセスID と同じである。つまり、 シグナルスレッドのプログラ"
"ムではこの場合 B<gettid>(2)  と B<getpid>(2)  は全く同じように使うことができ"
"る。)  ただし、注意すべき点として、この段落で述べたことは、 ソケットの帯域外"
"データが届いたときに生成される B<SIGURG> シグナルにはあてはまらない。 このシ"
"グナルは常にプロセスかプロセスグループに送られ、 送信先は B<F_SETOWN> に渡さ"
"れた値にしたがって決められる。"

#. type: Plain text
#: build/C/man2/fcntl.2:850
msgid ""
"The above behavior was accidentally dropped in Linux 2.6.12, and won't be "
"restored.  From Linux 2.6.32 onward, use B<F_SETOWN_EX> to target B<SIGIO> "
"and B<SIGURG> signals at a particular thread."
msgstr ""
"上記の動作は、Linux 2.6.12 で図らずも削除され、 元に戻されない予定である。 "
"Linux 2.6.32 以降で、特定のスレッド宛にシグナル B<SIGIO> と B<SIGURG> を送る"
"には B<F_SETOWN_EX> を使うこと。"

#. type: TP
#: build/C/man2/fcntl.2:850
#, no-wrap
msgid "B<F_GETOWN_EX> (I<struct f_owner_ex *>) (since Linux 2.6.32)"
msgstr "B<F_GETOWN_EX> (I<struct f_owner_ex *>) (Linux 2.6.32 以降)"

#. type: Plain text
#: build/C/man2/fcntl.2:859
msgid ""
"Return the current file descriptor owner settings as defined by a previous "
"B<F_SETOWN_EX> operation.  The information is returned in the structure "
"pointed to by I<arg>, which has the following form:"
msgstr ""
"直前の B<F_SETOWN_EX> 操作で定義された現在のファイルディスクリプターの所有者"
"設定 を返す。情報は I<arg> が指す構造体に格納されて返される。構造体は以下の通"
"りである。"

#. type: Plain text
#: build/C/man2/fcntl.2:866
#, no-wrap
msgid ""
"struct f_owner_ex {\n"
"    int   type;\n"
"    pid_t pid;\n"
"};\n"
msgstr ""
"struct f_owner_ex {\n"
"    int   type;\n"
"    pid_t pid;\n"
"};\n"

#. type: Plain text
#: build/C/man2/fcntl.2:883
msgid ""
"The I<type> field will have one of the values B<F_OWNER_TID>, "
"B<F_OWNER_PID>, or B<F_OWNER_PGRP>.  The I<pid> field is a positive integer "
"representing a thread ID, process ID, or process group ID.  See "
"B<F_SETOWN_EX> for more details."
msgstr ""
"I<type> フィールドは、 B<F_OWNER_TID ,> B<F_OWNER_PID ,> B<F_OWNER_PGRP> のい"
"ずれか一つの値となる。 I<pid> フィールドは、スレッド ID、プロセス ID、プロセ"
"スグループ ID を 表す正の整数である。詳細は B<F_SETOWN_EX> を参照。"

#. type: TP
#: build/C/man2/fcntl.2:883
#, no-wrap
msgid "B<F_SETOWN_EX> (I<struct f_owner_ex *>) (since Linux 2.6.32)"
msgstr "B<F_SETOWN_EX> (I<struct f_owner_ex *>) (Linux 2.6.32 以降)"

#. type: Plain text
#: build/C/man2/fcntl.2:899
msgid ""
"This operation performs a similar task to B<F_SETOWN>.  It allows the caller "
"to direct I/O availability signals to a specific thread, process, or process "
"group.  The caller specifies the target of signals via I<arg>, which is a "
"pointer to a I<f_owner_ex> structure.  The I<type> field has one of the "
"following values, which define how I<pid> is interpreted:"
msgstr ""
"この操作は B<F_SETOWN> と同様の処理を行う。 この操作を使うと、I/O が利用可能"
"になったことを示すシグナルを、 特定のスレッド、プロセス、プロセスグループに送"
"ることができる ようになる。 呼び出し元は、 I<arg> 経由でシグナルの配送先を指"
"定する。 I<arg> は I<f_owner_ex> 構造体へのポインターである。 I<type> フィー"
"ルドは以下のいずれかの値を取り、 この値により I<pid> がどのように解釈されるか"
"が規定される。"

#. type: TP
#: build/C/man2/fcntl.2:900
#, no-wrap
msgid "B<F_OWNER_TID>"
msgstr "B<F_OWNER_TID>"

#. type: Plain text
#: build/C/man2/fcntl.2:909
msgid ""
"Send the signal to the thread whose thread ID (the value returned by a call "
"to B<clone>(2)  or B<gettid>(2))  is specified in I<pid>."
msgstr ""
"スレッド ID が I<pid> で指定された値のスレッドにそのシグナルを送る (スレッド "
"ID は B<clone>(2)  や B<gettid>(2)  の呼び出しで返される値である)。"

#. type: TP
#: build/C/man2/fcntl.2:909
#, no-wrap
msgid "B<F_OWNER_PID>"
msgstr "B<F_OWNER_PID>"

#. type: Plain text
#: build/C/man2/fcntl.2:914
msgid "Send the signal to the process whose ID is specified in I<pid>."
msgstr "ID が I<pid> で指定された値のプロセスにそのシグナルを送る。"

#. type: TP
#: build/C/man2/fcntl.2:914
#, no-wrap
msgid "B<F_OWNER_PGRP>"
msgstr "B<F_OWNER_PGRP>"

#. type: Plain text
#: build/C/man2/fcntl.2:922
msgid ""
"Send the signal to the process group whose ID is specified in I<pid>.  (Note "
"that, unlike with B<F_SETOWN>, a process group ID is specified as a positive "
"value here.)"
msgstr ""
"ID が I<pid> で指定された値のプロセスグループにそのシグナルを送る。 "
"(B<F_SETOWN> と異なり、プロセスグループ ID には正の値を指定する点に注意するこ"
"と。)"

#. type: TP
#: build/C/man2/fcntl.2:923
#, no-wrap
msgid "B<F_GETSIG> (I<void>)"
msgstr "B<F_GETSIG> (I<void>)"

#. type: Plain text
#: build/C/man2/fcntl.2:938
msgid ""
"Return (as the function result)  the signal sent when input or output "
"becomes possible.  A value of zero means B<SIGIO> is sent.  Any other value "
"(including B<SIGIO>)  is the signal sent instead, and in this case "
"additional info is available to the signal handler if installed with "
"B<SA_SIGINFO>.  I<arg> is ignored."
msgstr ""
"入力や出力が可能になった場合に送るシグナルを (関数の結果として) 返す。 値ゼロ"
"は B<SIGIO> を送ることを意味する。 (B<SIGIO> を含む) 他の値はいずれも、 "
"B<SIGIO> の代わりに送るシグナル番号を表す。 後者の場合、シグナルハンドラーを "
"B<SA_SIGINFO> フラグ付きで設定すれば、ハンドラーで追加の情報を得ることができ"
"る。 I<arg> は無視される。"

#. type: TP
#: build/C/man2/fcntl.2:938
#, no-wrap
msgid "B<F_SETSIG> (I<int>)"
msgstr "B<F_SETSIG> (I<int>)"

#.  The following was true only up until 2.6.11:
#.  Additionally, passing a nonzero value to
#.  .B F_SETSIG
#.  changes the signal recipient from a whole process to a specific thread
#.  within a process.
#.  See the description of
#.  .B F_SETOWN
#.  for more details.
#. type: Plain text
#: build/C/man2/fcntl.2:961
msgid ""
"Set the signal sent when input or output becomes possible to the value given "
"in I<arg>.  A value of zero means to send the default B<SIGIO> signal.  Any "
"other value (including B<SIGIO>)  is the signal to send instead, and in this "
"case additional info is available to the signal handler if installed with "
"B<SA_SIGINFO>."
msgstr ""
"入力や出力が可能になった場合に送るシグナルを I<arg> に指定された値に設定す"
"る。 値ゼロは B<SIGIO> を送ることを意味する。 (B<SIGIO> を含む) 他の値はいず"
"れも、 B<SIGIO> の代わりに送るシグナル番号を表す。 後者の場合、シグナルハンド"
"ラーを B<SA_SIGINFO> フラグ付きで設定すれば、 ハンドラーで追加の情報を得るこ"
"とができる。"

#. type: Plain text
#: build/C/man2/fcntl.2:989
msgid ""
"By using B<F_SETSIG> with a nonzero value, and setting B<SA_SIGINFO> for the "
"signal handler (see B<sigaction>(2)), extra information about I/O events is "
"passed to the handler in a I<siginfo_t> structure.  If the I<si_code> field "
"indicates the source is B<SI_SIGIO>, the I<si_fd> field gives the file "
"descriptor associated with the event.  Otherwise, there is no indication "
"which file descriptors are pending, and you should use the usual mechanisms "
"(B<select>(2), B<poll>(2), B<read>(2)  with B<O_NONBLOCK> set etc.) to "
"determine which file descriptors are available for I/O."
msgstr ""
"B<F_SETSIG> にゼロ以外の値を設定し、シグナルハンドラーに B<SA_SIGINFO> フラグ"
"を設定すると、 (B<sigaction>(2)  を参照) I/O イベントに関する追加の情報が "
"I<siginfo_t> 構造体でシグナルハンドラーへ渡される。 I<si_code> フィールドが示"
"すシグナルの原因が B<SI_SIGIO> である場合、 I<si_fd> フィールドにはイベントに"
"対応するファイルディスクリプターが入っている。 それ以外の場合は、どのファイル"
"ディスクリプターが利用可能かを示す情報は ないので、どのファイルディスクリプ"
"ターで I/O が可能かを判断するためには 通常の機構 (B<select>(2), B<poll>(2), "
"B<O_NONBLOCK> を設定した B<read>(2)  など) を使用しなければならない。"

#. type: Plain text
#: build/C/man2/fcntl.2:1002
msgid ""
"Note that the file descriptor provided in I<si_fd> is the one that was "
"specified during the B<F_SETSIG> operation.  This can lead to an unusual "
"corner case.  If the file descriptor is duplicated (B<dup>(2)  or similar), "
"and the original file descriptor is closed, then I/O events will continue to "
"be generated, but the I<si_fd> field will contain the number of the now "
"closed file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/fcntl.2:1011
msgid ""
"By selecting a real time signal (value E<gt>= B<SIGRTMIN>), multiple I/O "
"events may be queued using the same signal numbers.  (Queuing is dependent "
"on available memory.)  Extra information is available if B<SA_SIGINFO> is "
"set for the signal handler, as above."
msgstr ""
"リアルタイムシグナル (値が B<SIGRTMIN> 以上) を選択している場合は、 同じシグ"
"ナル番号を持つ複数の I/O イベントがキューに入ることがある (キューに入れるかど"
"うかは利用可能なメモリーに依存している)。 上記と同様、 B<SA_SIGINFO> が設定さ"
"れている場合、シグナルハンドラーのための追加の情報が得られる。"

#.  See fs/fcntl.c::send_sigio_to_task() (2.4/2.6) sources -- MTK, Apr 05
#. type: Plain text
#: build/C/man2/fcntl.2:1024
msgid ""
"Note that Linux imposes a limit on the number of real-time signals that may "
"be queued to a process (see B<getrlimit>(2)  and B<signal>(7))  and if this "
"limit is reached, then the kernel reverts to delivering B<SIGIO>, and this "
"signal is delivered to the entire process rather than to a specific thread."
msgstr ""
"以下の点に注意すること。 Linux では一つのプロセスに対してキューに入れられるリ"
"アルタイム シグナルの数に上限が設けられており (B<getrlimit>(2)  と "
"B<signal>(7)  を参照)、この上限に達するとカーネルは B<SIGIO> シグナルを配送す"
"る。この B<SIGIO> シグナルは、指定されたスレッドではなくプロセス全体に送られ"
"る。"

#. type: Plain text
#: build/C/man2/fcntl.2:1031
msgid ""
"Using these mechanisms, a program can implement fully asynchronous I/O "
"without using B<select>(2)  or B<poll>(2)  most of the time."
msgstr ""
"これらの機構を使用することで、ほとんどの場合で B<select>(2)  や B<poll>(2)  "
"を使用せずに完全な非同期 I/O を実装することができる。"

#. type: Plain text
#: build/C/man2/fcntl.2:1055
msgid ""
"The use of B<O_ASYNC> is specific to BSD and Linux.  The only use of "
"B<F_GETOWN> and B<F_SETOWN> specified in POSIX.1 is in conjunction with the "
"use of the B<SIGURG> signal on sockets.  (POSIX does not specify the "
"B<SIGIO> signal.)  B<F_GETOWN_EX>, B<F_SETOWN_EX>, B<F_GETSIG>, and "
"B<F_SETSIG> are Linux-specific.  POSIX has asynchronous I/O and the "
"I<aio_sigevent> structure to achieve similar things; these are also "
"available in Linux as part of the GNU C Library (Glibc)."
msgstr ""
"B<O_ASYNC> の使用方法は BSD と Linux に特有である。 POSIX.1 で規定されている "
"B<F_GETOWN> と B<F_SETOWN> の使用方法は、ソケットに対する B<SIGURG> シグナル"
"との組み合わせだけである (POSIX は B<SIGIO> シグナルは規定していない)。 "
"B<F_GETOWN_EX>, B<F_SETOWN_EX>, B<F_GETSIG>, B<F_SETSIG> は Linux 固有であ"
"る。POSIX には、同様のことを行うために、非同期 I/O と I<aio_sigevent> 構造体"
"がある。Linux では、GNU C ライブラリ (Glibc) の一部として これらも利用可能で"
"ある。"

#. type: SS
#: build/C/man2/fcntl.2:1055
#, no-wrap
msgid "Leases"
msgstr "リース (leases)"

#. type: Plain text
#: build/C/man2/fcntl.2:1070
msgid ""
"B<F_SETLEASE> and B<F_GETLEASE> (Linux 2.4 onward) are used to establish a "
"new lease, and retrieve the current lease, on the open file description "
"referred to by the file descriptor I<fd>.  A file lease provides a mechanism "
"whereby the process holding the lease (the \"lease holder\") is notified "
"(via delivery of a signal)  when a process (the \"lease breaker\") tries to "
"B<open>(2)  or B<truncate>(2)  the file referred to by that file descriptor."
msgstr ""
"(Linix 2.4 以降で利用可能)  B<F_SETLEASE> は、 I<fd> が参照するオープンファイ"
"ル記述に対して新しいリースを設定するのに使用される。 B<F_GETLEASE> は、 "
"I<fd> が参照するオープンファイル記述に対して設定されている 現在のリースを取得"
"するのに使用される。 ファイルのリースにより、 あるプロセス (\"lease breaker"
"\") がそのファイルディスクリプターが参照 しているファイルに対して "
"B<open>(2)  や B<truncate>(2)  を行おうとした際に、リースを保持しているプロセ"
"ス (\"lease holder\") へ (シグナルの配送による) 通知が行われるという機構が提"
"供される。"

#. type: TP
#: build/C/man2/fcntl.2:1070
#, no-wrap
msgid "B<F_SETLEASE> (I<int>)"
msgstr "B<F_SETLEASE> (I<int>)"

#. type: Plain text
#: build/C/man2/fcntl.2:1075
msgid ""
"Set or remove a file lease according to which of the following values is "
"specified in the integer I<arg>:"
msgstr ""
"I<arg> の内容に基いてファイルのリースの設定、削除を行う。整数 I<arg> には以下"
"の値が指定できる:"

#. type: TP
#: build/C/man2/fcntl.2:1076
#, no-wrap
msgid "B<F_RDLCK>"
msgstr "B<F_RDLCK>"

#.  The following became true in kernel 2.6.10:
#.  See the man-pages-2.09 Changelog for further info.
#. type: Plain text
#: build/C/man2/fcntl.2:1085
msgid ""
"Take out a read lease.  This will cause the calling process to be notified "
"when the file is opened for writing or is truncated.  A read lease can be "
"placed only on a file descriptor that is opened read-only."
msgstr ""
"読み出しリースを取得する。これにより、 そのファイルが書き込み用にオープンされ"
"たり、ファイルが切り詰められた場合に、 呼び出し元のプロセスに通知が行われるよ"
"うになる。 読み出しリースを設定できるのは、読み出し専用でオープンされている "
"ファイルディスクリプターに対してのみである。"

#. type: TP
#: build/C/man2/fcntl.2:1085
#, no-wrap
msgid "B<F_WRLCK>"
msgstr "B<F_WRLCK>"

#. type: Plain text
#: build/C/man2/fcntl.2:1092
msgid ""
"Take out a write lease.  This will cause the caller to be notified when the "
"file is opened for reading or writing or is truncated.  A write lease may be "
"placed on a file only if there are no other open file descriptors for the "
"file."
msgstr ""
"書き込みリースを取得する。これにより、 (読み出し用か書き込み用にかかわらず) "
"そのファイルがオープンされたり、 ファイルが切り詰められた場合に、呼び出し元の"
"プロセスに通知が行われるようになる。 書き込みリースは、そのファイルに対する"
"オープンされたファイルディスクリプターが 他にない場合にのみ設定できる。"

#. type: TP
#: build/C/man2/fcntl.2:1092
#, no-wrap
msgid "B<F_UNLCK>"
msgstr "B<F_UNLCK>"

#. type: Plain text
#: build/C/man2/fcntl.2:1095
msgid "Remove our lease from the file."
msgstr "そのファイルからリースを削除する。"

#. type: Plain text
#: build/C/man2/fcntl.2:1109
msgid ""
"Leases are associated with an open file description (see B<open>(2)).  This "
"means that duplicate file descriptors (created by, for example, B<fork>(2)  "
"or B<dup>(2))  refer to the same lease, and this lease may be modified or "
"released using any of these descriptors.  Furthermore, the lease is released "
"by either an explicit B<F_UNLCK> operation on any of these duplicate file "
"descriptors, or when all such file descriptors have been closed."
msgstr ""
"リースはオープンファイル記述に対して関連付けられる (B<open>(2)  参照)。 つま"
"り、 (B<fork>(2)  や B<dup>(2)  などにより作成された) ファイルディスクリプ"
"ターの複製は同じリースを参照し、 複製も含めたどのファイルディスクリプターを"
"使ってもこのリースを変更したり 解放したりできる。 また、これらのファイルディ"
"スクリプターのいずれかに対して B<F_UNLCK> 操作が明示的に実行された場合や、す"
"べてのファイルディスクリプターが 閉じられた場合にも、リースは解放される。"

#. type: Plain text
#: build/C/man2/fcntl.2:1116
msgid ""
"Leases may be taken out only on regular files.  An unprivileged process may "
"take out a lease only on a file whose UID (owner) matches the filesystem UID "
"of the process.  A process with the B<CAP_LEASE> capability may take out "
"leases on arbitrary files."
msgstr ""
"リースの取得は通常のファイル (regular file) に対してのみ可能である。 非特権プ"
"ロセスがリースを取得できるのは、UID (所有者) がプロセスの ファイルシステム "
"UID と一致するファイルに対してだけである。 B<CAP_LEASE> ケーパビリティを持つ"
"プロセスは任意のファイルに対してリースを取得できる。"

#. type: TP
#: build/C/man2/fcntl.2:1116
#, no-wrap
msgid "B<F_GETLEASE> (I<void>)"
msgstr "B<F_GETLEASE> (I<void>)"

#. type: Plain text
#: build/C/man2/fcntl.2:1125
msgid ""
"Indicates what type of lease is associated with the file descriptor I<fd> by "
"returning either B<F_RDLCK>, B<F_WRLCK>, or B<F_UNLCK>, indicating, "
"respectively, a read lease , a write lease, or no lease.  I<arg> is ignored."
msgstr ""
"ファイルディスクリプター I<fd> に対して設定されているリースの種別を取得す"
"る。 B<F_RDLCK>, B<F_WRLCK>, B<F_UNLCK> のいずれかが返される。 B<F_RDLCK>, "
"B<F_WRLCK> はそれぞれ、読み出しリース、書き込みリースが設定されていることを示"
"し、 B<F_UNLCK> はリースが何も設定されていないことを示す。 I<arg> は無視され"
"る。"

#. type: Plain text
#: build/C/man2/fcntl.2:1156
msgid ""
"When a process (the \"lease breaker\") performs an B<open>(2)  or "
"B<truncate>(2)  that conflicts with a lease established via B<F_SETLEASE>, "
"the system call is blocked by the kernel and the kernel notifies the lease "
"holder by sending it a signal (B<SIGIO> by default).  The lease holder "
"should respond to receipt of this signal by doing whatever cleanup is "
"required in preparation for the file to be accessed by another process (e."
"g., flushing cached buffers) and then either remove or downgrade its lease.  "
"A lease is removed by performing an B<F_SETLEASE> command specifying I<arg> "
"as B<F_UNLCK>.  If the lease holder currently holds a write lease on the "
"file, and the lease breaker is opening the file for reading, then it is "
"sufficient for the lease holder to downgrade the lease to a read lease.  "
"This is done by performing an B<F_SETLEASE> command specifying I<arg> as "
"B<F_RDLCK>."
msgstr ""
"あるプロセス (\"lease breaker\") が B<F_SETLEASE> で設定されたリースと矛\n"
"盾するような B<open>(2) や B<truncate>(2) を実行した場合、 そのシステム\n"
"コールはカーネルによって停止され、 カーネルは lease holder にシグナル\n"
"(デフォルトでは B<SIGIO>) を送って通知を行う。 lease holder はこのシグ\n"
"ナルを受信したときにはきちんと対応すべきである。 具体的には、別のプロセ\n"
"スがそのファイルにアクセスするための準備として 必要な後片付け (例えば、\n"
"キャッシュされたバッファーのフラッシュ) を すべて行ってから、そのファイル\n"
"のリースの削除または格下げを行う。リースを削除をするには、 I<arg> に\n"
"B<F_UNLCK> を指定して B<F_SETLEASE> を実行する。lease holder がファイル\n"
"に書き込みリースを保持していて、 lease breaker が読み出し用にそのファイ\n"
"ルをオープンしている場合、 lease holder が保持しているリースを読み出し\n"
"リースに格下げすれば 十分である。これをするには、 I<arg> に B<F_RDLCK>\n"
"を指定して B<F_SETLEASE> を実行する。"

#. type: Plain text
#: build/C/man2/fcntl.2:1161
msgid ""
"If the lease holder fails to downgrade or remove the lease within the number "
"of seconds specified in I</proc/sys/fs/lease-break-time>, then the kernel "
"forcibly removes or downgrades the lease holder's lease."
msgstr ""
"If the lease holder fails to downgrade or remove the lease within the number "
"of seconds specified in I</proc/sys/fs/lease-break-time>, then the kernel "
"forcibly removes or downgrades the lease holder's lease."

#. type: Plain text
#: build/C/man2/fcntl.2:1171
msgid ""
"Once a lease break has been initiated, B<F_GETLEASE> returns the target "
"lease type (either B<F_RDLCK> or B<F_UNLCK>, depending on what would be "
"compatible with the lease breaker)  until the lease holder voluntarily "
"downgrades or removes the lease or the kernel forcibly does so after the "
"lease break timer expires."
msgstr ""
"いったん lease break が開始されると、 lease holder が自発的にそのリース\n"
"の格下げか削除を行うか、lease break timer の満了後にカーネルが強制的に\n"
"リースの格下げか削除を行うまで、 B<F_GETLEASE> は対象となるリースの型を\n"
"返す (リースの型は B<F_RDLCK> か B<F_UNLCK> のどちらであり、lease\n"
"breaker と互換性のある型となる)。"

#. type: Plain text
#: build/C/man2/fcntl.2:1175
msgid ""
"Once the lease has been voluntarily or forcibly removed or downgraded, and "
"assuming the lease breaker has not unblocked its system call, the kernel "
"permits the lease breaker's system call to proceed."
msgstr ""
"一度リースの削除か格下げが自発的もしくは強制的に行われると、 lease breaker が"
"まだシステムコールを再開していない場合には、 カーネルが lease breaker のシス"
"テムコールの続行を許可する。"

#. type: Plain text
#: build/C/man2/fcntl.2:1196
msgid ""
"If the lease breaker's blocked B<open>(2)  or B<truncate>(2)  is interrupted "
"by a signal handler, then the system call fails with the error B<EINTR>, but "
"the other steps still occur as described above.  If the lease breaker is "
"killed by a signal while blocked in B<open>(2)  or B<truncate>(2), then the "
"other steps still occur as described above.  If the lease breaker specifies "
"the B<O_NONBLOCK> flag when calling B<open>(2), then the call immediately "
"fails with the error B<EWOULDBLOCK>, but the other steps still occur as "
"described above."
msgstr ""
"lease breaker が実行した B<open>(2)  や B<truncate>(2)  が停止中にシグナルハ"
"ンドラーにより中断された場合、 そのシステムコールは B<EINTR> エラーで失敗する"
"が、上で述べた他の処理は そのまま行われる。 B<open>(2)  や B<truncate>(2)  が"
"停止中に lease breaker がシグナルにより kill された場合、 上で述べた他の処理"
"はそのまま行われる。 lease breaker が B<open>(2)  を呼ぶ際に B<O_NONBLOCK> フ"
"ラグを指定した場合、そのシステムコールは B<EWOULDBLOCK> エラーで直ちに失敗す"
"るが、上で述べた他の処理はそのまま行われる。"

#. type: Plain text
#: build/C/man2/fcntl.2:1217
msgid ""
"The default signal used to notify the lease holder is B<SIGIO>, but this can "
"be changed using the B<F_SETSIG> command to B<fcntl>().  If a B<F_SETSIG> "
"command is performed (even one specifying B<SIGIO>), and the signal handler "
"is established using B<SA_SIGINFO>, then the handler will receive a "
"I<siginfo_t> structure as its second argument, and the I<si_fd> field of "
"this argument will hold the file descriptor of the leased file that has been "
"accessed by another process.  (This is useful if the caller holds leases "
"against multiple files.)"
msgstr ""
"lease holder への通知に使われるデフォルトのシグナルは B<SIGIO> だが、 "
"B<fcntl>()  の B<F_SETSIG> コマンドで変更することができる。 B<F_SETSIG> コマ"
"ンドが実行され (B<SIGIO> を指定された場合も含む)、 B<SA_SIGINFO> フラグ付きで"
"シグナルハンドラーが設定されている場合には、 ハンドラーの第二引数として "
"I<siginfo_t> 構造体が渡され、この引数の I<si_fd> フィールドには別のプロセス"
"がアクセスしたリース設定済みファイルのファイルディスクリプターが入っている "
"(この機能は複数のファイルに対してリースを設定する場合に有用である)。"

#. type: SS
#: build/C/man2/fcntl.2:1217
#, no-wrap
msgid "File and directory change notification (dnotify)"
msgstr "ファイルやディレクトリの変更の通知 (dnotify)"

#. type: TP
#: build/C/man2/fcntl.2:1218
#, no-wrap
msgid "B<F_NOTIFY> (I<int>)"
msgstr "B<F_NOTIFY> (I<int>)"

#. type: Plain text
#: build/C/man2/fcntl.2:1228
msgid ""
"(Linux 2.4 onward)  Provide notification when the directory referred to by "
"I<fd> or any of the files that it contains is changed.  The events to be "
"notified are specified in I<arg>, which is a bit mask specified by ORing "
"together zero or more of the following bits:"
msgstr ""
"(Linux 2.4 以降)  I<fd> で参照されるディレクトリか、その中にあるファイルに変"
"更があった場合に 通知を行う。どのイベントを通知するかは I<arg> で指定する。 "
"I<arg> はビットマスクで、以下のビットの 0個以上の論理和をとったものを指定す"
"る。"

#. type: TP
#: build/C/man2/fcntl.2:1231
#, no-wrap
msgid "B<DN_ACCESS>"
msgstr "B<DN_ACCESS>"

#. type: Plain text
#: build/C/man2/fcntl.2:1238
msgid "A file was accessed (B<read>(2), B<pread>(2), B<readv>(2), and similar)"
msgstr ""
"ファイルへのアクセスがあった (B<read>(2), B<pread>(2), B<readv>(2) や同様のシ"
"ステムコール)"

#. type: TP
#: build/C/man2/fcntl.2:1238
#, no-wrap
msgid "B<DN_MODIFY>"
msgstr "B<DN_MODIFY>"

#. type: Plain text
#: build/C/man2/fcntl.2:1247
msgid ""
"A file was modified (B<write>(2), B<pwrite>(2), B<writev>(2), "
"B<truncate>(2), B<ftruncate>(2), and similar)."
msgstr ""
"ファイルの内容が変更された (B<write>(2), B<pwrite>(2), B<writev>(2), "
"B<truncate>(2), B<ftruncate>(2) や同様のシステムコール)"

#. type: TP
#: build/C/man2/fcntl.2:1247
#, no-wrap
msgid "B<DN_CREATE>"
msgstr "B<DN_CREATE>"

#. type: Plain text
#: build/C/man2/fcntl.2:1258
msgid ""
"A file was created (B<open>(2), B<creat>(2), B<mknod>(2), B<mkdir>(2), "
"B<link>(2), B<symlink>(2), B<rename>(2)  into this directory)."
msgstr ""
"ファイルが作成された (B<open>(2), B<creat>(2), B<mknod>(2), B<mkdir>(2), \"\n"
"\"B<link>(2), B<symlink>(2), このディレクトリへの B<rename>(2))"

#. type: TP
#: build/C/man2/fcntl.2:1258
#, no-wrap
msgid "B<DN_DELETE>"
msgstr "B<DN_DELETE>"

#. type: Plain text
#: build/C/man2/fcntl.2:1265
msgid ""
"A file was unlinked (B<unlink>(2), B<rename>(2)  to another directory, "
"B<rmdir>(2))."
msgstr ""
"ファイルが削除 (unlink) された (B<unlink>(2), 別のディレクトリへの "
"B<rename>(2), B<rmdir>(2))"

#. type: TP
#: build/C/man2/fcntl.2:1265
#, no-wrap
msgid "B<DN_RENAME>"
msgstr "B<DN_RENAME>"

#. type: Plain text
#: build/C/man2/fcntl.2:1269
msgid "A file was renamed within this directory (B<rename>(2))."
msgstr "ディレクトリ内でのファイル名の変更があった (B<rename>(2))"

#. type: TP
#: build/C/man2/fcntl.2:1269
#, no-wrap
msgid "B<DN_ATTRIB>"
msgstr "B<DN_ATTRIB>"

#. type: Plain text
#: build/C/man2/fcntl.2:1277
msgid ""
"The attributes of a file were changed (B<chown>(2), B<chmod>(2), "
"B<utime>(2), B<utimensat>(2), and similar)."
msgstr ""
"ファイル属性が変更された (B<chown>(2), B<chmod>(2), B<utime>(2), "
"B<utimensat>(2) や同様のシステムコール)"

#. type: Plain text
#: build/C/man2/fcntl.2:1285
msgid ""
"(In order to obtain these definitions, the B<_GNU_SOURCE> feature test macro "
"must be defined before including I<any> header files.)"
msgstr ""
"(上記の定義を利用するには、I<どの> ヘッダーファイルをインクルードするより前"
"に、\n"
"B<_GNU_SOURCE> 機能検査マクロを定義しなければならない。)"

#. type: Plain text
#: build/C/man2/fcntl.2:1293
msgid ""
"Directory notifications are normally \"one-shot\", and the application must "
"reregister to receive further notifications.  Alternatively, if "
"B<DN_MULTISHOT> is included in I<arg>, then notification will remain in "
"effect until explicitly removed."
msgstr ""
"ディレクトリの変更通知は通常「一回限り (one-shot)」であり、 アプリケーション"
"側でその後さらに通知を受信したい場合は 再登録しなければならない。 I<arg> に "
"B<DN_MULTISHOT> が含まれていた場合には、 変更通知は明示的に解除されるまで有効"
"状態が継続する。"

#.  The following does seem a poor API-design choice...
#. type: Plain text
#: build/C/man2/fcntl.2:1305
msgid ""
"A series of B<F_NOTIFY> requests is cumulative, with the events in I<arg> "
"being added to the set already monitored.  To disable notification of all "
"events, make an B<F_NOTIFY> call specifying I<arg> as 0."
msgstr ""
"B<F_NOTIFY> 要求は積算されていく。つまり、 I<arg> で指定されたイベントがすで"
"にモニタされている イベント集合に加算される形になる。 すべてのイベントの通知"
"を無効にするには、 I<arg> に 0 を指定して B<F_NOTIFY> を呼び出す必要がある。"

#. type: Plain text
#: build/C/man2/fcntl.2:1328
msgid ""
"Notification occurs via delivery of a signal.  The default signal is "
"B<SIGIO>, but this can be changed using the B<F_SETSIG> command to "
"B<fcntl>().  (Note that B<SIGIO> is one of the nonqueuing standard signals; "
"switching to the use of a real-time signal means that multiple notifications "
"can be queued to the process.)  In the latter case, the signal handler "
"receives a I<siginfo_t> structure as its second argument (if the handler was "
"established using B<SA_SIGINFO>)  and the I<si_fd> field of this structure "
"contains the file descriptor which generated the notification (useful when "
"establishing notification on multiple directories)."
msgstr ""
"通知はシグナルの配送で行われる。 デフォルトのシグナルは B<SIGIO> だが、 "
"B<fcntl>()  の B<F_SETSIG> コマンドで変更することができる。 (B<SIGIO> は"
"キューイングされない標準のシグナルの一つである点に注意。 リアルタイムシグナル"
"を使うように変更すると、 複数の通知がそのプロセス宛のキューに入ることがあるこ"
"とを意味する。) 後者の場合には、 (B<SA_SIGINFO> フラグ付きでシグナルハンド"
"ラーが設定されている場合には)  ハンドラーの第二引数として I<siginfo_t> 構造"
"体が渡され、この構造体の I<si_fd> フィールドには通知の行われたファイルディス"
"クリプターが入っている (この機能は複数のディレクトリに対して通知を設定する場"
"合に有用である)。"

#. type: Plain text
#: build/C/man2/fcntl.2:1333
msgid ""
"Especially when using B<DN_MULTISHOT>, a real time signal should be used for "
"notification, so that multiple notifications can be queued."
msgstr ""
"特に B<DN_MULTISHOT> を使う場合は、通知にはリアルタイムシグナルを使うべきであ"
"る。 それは、リアルタイムシグナルを使うことで、複数の通知をキューに入れる こ"
"とができるからである。"

#. type: Plain text
#: build/C/man2/fcntl.2:1342
msgid ""
"B<NOTE:> New applications should use the I<inotify> interface (available "
"since kernel 2.6.13), which provides a much superior interface for obtaining "
"notifications of filesystem events.  See B<inotify>(7)."
msgstr ""
"B<注意:> 新しくアプリケーションを書く際には、(カーネル 2.6.13 以降で利用可能"
"となった)  I<inotify> インターフェースを使用すべきである。 I<inotify> はファ"
"イルシステムイベントの通知を取得するための ずっと優れたインターフェースであ"
"る。 B<inotify>(7)  を参照。"

#. type: SS
#: build/C/man2/fcntl.2:1342
#, no-wrap
msgid "Changing the capacity of a pipe"
msgstr "パイプの容量の変更"

#. type: TP
#: build/C/man2/fcntl.2:1343
#, no-wrap
msgid "B<F_SETPIPE_SZ> (I<int>; since Linux 2.6.35)"
msgstr "B<F_SETPIPE_SZ> (I<int>; Linux 2.6.35 以降)"

#. type: Plain text
#: build/C/man2/fcntl.2:1364
msgid ""
"Change the capacity of the pipe referred to by I<fd> to be at least I<arg> "
"bytes.  An unprivileged process can adjust the pipe capacity to any value "
"between the system page size and the limit defined in I</proc/sys/fs/pipe-"
"max-size> (see B<proc>(5)).  Attempts to set the pipe capacity below the "
"page size are silently rounded up to the page size.  Attempts by an "
"unprivileged process to set the pipe capacity above the limit in I</proc/sys/"
"fs/pipe-max-size> yield the error B<EPERM>; a privileged process "
"(B<CAP_SYS_RESOURCE>)  can override the limit."
msgstr ""
"I<fd> が参照するパイプの容量を少なくとも I<arg> バイトに変更する。\n"
"非特権プロセスは、パイプの容量として、\n"
"システムのページサイズと I</proc/sys/fs/pipe-max-size> で定義される\n"
"上限値 (B<proc>(5) 参照) の間の任意の値を設定できる。\n"
"パイプの容量をページサイズよりも小さな値に設定しようとした場合は、\n"
"暗黙のうちにページサイズに切り上げられる。\n"
"非特権プロセスがパイプの容量を I</proc/sys/fs/pipe-max-size> で定義\n"
"された上限より大きな値に設定しようとした場合は、エラー B<EPERM> が\n"
"発生する。特権プロセス (B<CAP_SYS_RESOURCE> ケーパビリティを持つ\n"
"プロセス) はこの上限を上書きできる。"

#. type: Plain text
#: build/C/man2/fcntl.2:1373
#, fuzzy
#| msgid ""
#| "Change the capacity of the pipe referred to by I<fd> to be at least "
#| "I<arg> bytes.  An unprivileged process can adjust the pipe capacity to "
#| "any value between the system page size and the limit defined in I</proc/"
#| "sys/fs/pipe-max-size> (see B<proc>(5)).  Attempts to set the pipe "
#| "capacity below the page size are silently rounded up to the page size.  "
#| "Attempts by an unprivileged process to set the pipe capacity above the "
#| "limit in I</proc/sys/fs/pipe-max-size> yield the error B<EPERM>; a "
#| "privileged process (B<CAP_SYS_RESOURCE>)  can override the limit.  When "
#| "allocating the buffer for the pipe, the kernel may use a capacity larger "
#| "than I<arg>, if that is convenient for the implementation.  The actual "
#| "capacity that is set is returned as the function result.  Attempting to "
#| "set the pipe capacity smaller than the amount of buffer space currently "
#| "used to store data produces the error B<EBUSY>."
msgid ""
"When allocating the buffer for the pipe, the kernel may use a capacity "
"larger than I<arg>, if that is convenient for the implementation.  (In the "
"current implementation, the allocation is the next higher power-of-two page-"
"size multiple of the requested size.)  The actual capacity (in bytes) that "
"is set is returned as the function result."
msgstr ""
"I<fd> が参照するパイプの容量を少なくとも I<arg> バイトに変更する。\n"
"非特権プロセスは、パイプの容量として、\n"
"システムのページサイズと I</proc/sys/fs/pipe-max-size> で定義される\n"
"上限値 (B<proc>(5) 参照) の間の任意の値を設定できる。\n"
"パイプの容量をページサイズよりも小さな値に設定しようとした場合は、\n"
"暗黙のうちにページサイズに切り上げられる。\n"
"非特権プロセスがパイプの容量を I</proc/sys/fs/pipe-max-size> で定義\n"
"された上限より大きな値に設定しようとした場合は、エラー B<EPERM> が\n"
"発生する。特権プロセス (B<CAP_SYS_RESOURCE> ケーパビリティを持つ\n"
"プロセス) はこの上限を上書きできる。\n"
"パイプにバッファーを割り当てる場合、実装側の都合に応じて、\n"
"カーネルは I<arg> よりも大きな容量を割り当ててもよい。\n"
"実際に設定された大きさが関数の返り値として返される。\n"
"パイプの容量を現在データを格納するのに使用されているバッファーの\n"
"サイズよりも小さくしようとした場合は、エラー B<EBUSY> が発生する。"

#. type: Plain text
#: build/C/man2/fcntl.2:1377
msgid ""
"Attempting to set the pipe capacity smaller than the amount of buffer space "
"currently used to store data produces the error B<EBUSY>."
msgstr ""
"パイプの容量を現在データを格納するのに使用されているバッファーのサイズよりも"
"小さくしようとした場合は、エラー B<EBUSY> が発生する。"

#. type: Plain text
#: build/C/man2/fcntl.2:1382
msgid ""
"Note that because of the way the pages of the pipe buffer are employed when "
"data is written to the pipe, the number of bytes that can be written may be "
"less than the nominal size, depending on the size of the writes."
msgstr ""

#. type: TP
#: build/C/man2/fcntl.2:1382
#, no-wrap
msgid "B<F_GETPIPE_SZ> (I<void>; since Linux 2.6.35)"
msgstr "B<F_GETPIPE_SZ> (I<void>; Linux 2.6.35 以降)"

#. type: Plain text
#: build/C/man2/fcntl.2:1387
msgid ""
"Return (as the function result) the capacity of the pipe referred to by "
"I<fd>."
msgstr "I<fd> が参照するパイプの容量を (関数の結果として) 返す。"

#. type: SS
#: build/C/man2/fcntl.2:1387
#, no-wrap
msgid "File Sealing"
msgstr "File Sealing"

#. type: Plain text
#: build/C/man2/fcntl.2:1399
msgid ""
"File seals limit the set of allowed operations on a given file.  For each "
"seal that is set on a file, a specific set of operations will fail with "
"B<EPERM> on this file from now on.  The file is said to be sealed.  The "
"default set of seals depends on the type of the underlying file and "
"filesystem.  For an overview of file sealing, a discussion of its purpose, "
"and some code examples, see B<memfd_create>(2)."
msgstr ""
"file seal は指定されたファイルで許可される操作の集合を制限する。 ファイルに設"
"定される seal 毎に対応する操作の集合が規定されており、 それ以降のそのファイル"
"に対する対応する操作は B<EPERM> で失敗する。 このようなファイルは sealed "
"(seal が適用されている) と呼ばれる。 デフォルトの seal の集合は、適用される"
"ファイルやファイルシステムに依存する。 file seal の概要、 その目的、 サンプル"
"コードについては B<memfd_create>(2) を参照。"

#. type: Plain text
#: build/C/man2/fcntl.2:1410
#, fuzzy
#| msgid ""
#| "Currently, only the I<tmpfs> filesystem supports sealing.  On other "
#| "filesystems, all B<fcntl>(2)  operations that operate on seals will "
#| "return B<EINVAL>."
msgid ""
"Currently, file seals can be applied only to a file descriptor returned by "
"B<memfd_create>(2)  (if the B<MFD_ALLOW_SEALING> was employed).  On other "
"filesystems, all B<fcntl>()  operations that operate on seals will return "
"B<EINVAL>."
msgstr ""
"現在のところ I<tmpfs> ファイルシステムだけが sealing をサポートしている。 他"
"のファイルシステムでは、 seal に関連する B<fcntl>(2) の操作はすべて "
"B<EINVAL> を返す。"

#. type: Plain text
#: build/C/man2/fcntl.2:1415
msgid ""
"Seals are a property of an inode.  Thus, all open file descriptors referring "
"to the same inode share the same set of seals.  Furthermore, seals can never "
"be removed, only added."
msgstr ""
"seal は inode の属性である。 したがって、 同じ inode を参照するすべてのオープ"
"ンされたファイルディスクリプターは、 同じ seal の集合を共有する。 さらに、 "
"seal は削除することはできず、 追加のみ可能である。"

#. type: TP
#: build/C/man2/fcntl.2:1415
#, no-wrap
msgid "B<F_ADD_SEALS> (I<int>; since Linux 3.17)"
msgstr "B<F_ADD_SEALS> (I<int>; Linux 3.17 以降)"

#. type: Plain text
#: build/C/man2/fcntl.2:1433
msgid ""
"Add the seals given in the bit-mask argument I<arg> to the set of seals of "
"the inode referred to by the file descriptor I<fd>.  Seals cannot be removed "
"again.  Once this call succeeds, the seals are enforced by the kernel "
"immediately.  If the current set of seals includes B<F_SEAL_SEAL> (see "
"below), then this call will be rejected with B<EPERM>.  Adding a seal that "
"is already set is a no-op, in case B<F_SEAL_SEAL> is not set already.  In "
"order to place a seal, the file descriptor I<fd> must be writable."
msgstr ""
"ビットマスク引数 I<arg> で指定された seal を、 ファイルディスクリプター "
"I<fd> が参照する inode の seal の集合に追加する。 一度追加した seal を削除す"
"ることはできない。 この呼び出しが成功すると、 seal はただちにカーネルにより適"
"用される。 現在の seal の集合に B<F_SEAL_SEAL> (下記参照) が含まれている場"
"合、 この呼び出しは B<EPERM> で拒否される。 すでに設定されている seal を追加"
"した場合、 B<F_SEAL_SEAL> がまだ設定されていない場合は no-op (何もしない) と"
"なる。 seal を設定するには、 ファイルディスクリプター I<fd> が書き込み可能で"
"なければならない。"

#. type: TP
#: build/C/man2/fcntl.2:1433
#, no-wrap
msgid "B<F_GET_SEALS> (I<void>; since Linux 3.17)"
msgstr "B<F_GET_SEALS> (I<void>; Linux 3.17 以降)"

#. type: Plain text
#: build/C/man2/fcntl.2:1443
msgid ""
"Return (as the function result) the current set of seals of the inode "
"referred to by I<fd>.  If no seals are set, 0 is returned.  If the file does "
"not support sealing, -1 is returned and I<errno> is set to B<EINVAL>."
msgstr ""
"(関数の結果として) I<fd> が参照する inode の seal の現在の集合を返す。 seal "
"が何も設定されていない場合、 0 が返される。 ファイルが sealing をサポートして"
"いない場合、 -1 が返され、 I<errno> に B<EINVAL> が設定される。"

#. type: Plain text
#: build/C/man2/fcntl.2:1445
msgid "The following seals are available:"
msgstr "以下の seal が利用できる。"

#. type: TP
#: build/C/man2/fcntl.2:1445
#, no-wrap
msgid "B<F_SEAL_SEAL>"
msgstr "B<F_SEAL_SEAL>"

#. type: Plain text
#: build/C/man2/fcntl.2:1457
msgid ""
"If this seal is set, any further call to B<fcntl>()  with B<F_ADD_SEALS> "
"fails with the error B<EPERM>.  Therefore, this seal prevents any "
"modifications to the set of seals itself.  If the initial set of seals of a "
"file includes B<F_SEAL_SEAL>, then this effectively causes the set of seals "
"to be constant and locked."
msgstr ""
"この seal が設定されると、  これ以降の B<F_ADD_SEALS> を指定した B<fcntl>() "
"の呼び出しはすべて B<EPERM> エラーで失敗する。 したがって、 この seal を設定"
"すると seal の集合自身の変更を防止できる。 ファイルの最初の seal の集合に "
"B<F_SEAL_SEAL> が含まれていた場合、 結果的に seal の集合が定数になりロックさ"
"れることになる。"

#. type: TP
#: build/C/man2/fcntl.2:1457
#, no-wrap
msgid "B<F_SEAL_SHRINK>"
msgstr "B<F_SEAL_SHRINK>"

#. type: Plain text
#: build/C/man2/fcntl.2:1472
msgid ""
"If this seal is set, the file in question cannot be reduced in size.  This "
"affects B<open>(2)  with the B<O_TRUNC> flag as well as B<truncate>(2)  and "
"B<ftruncate>(2).  Those calls fail with B<EPERM> if you try to shrink the "
"file in question.  Increasing the file size is still possible."
msgstr ""
"この seal が設定されると、 設定されたファイルのサイズを小さくできなくなる。 "
"この seal は B<open>(2) の B<O_TRUNC> フラグに影響する。 B<truncate>(2) と "
"B<ftruncate>(2) についても同様である。 対象のファイルのサイズを小さくしようと"
"した場合、 これらの呼び出しは B<EPERM> で失敗する。 ファイルサイズを増やすこ"
"とはこの場合でも可能である。"

#. type: TP
#: build/C/man2/fcntl.2:1472
#, no-wrap
msgid "B<F_SEAL_GROW>"
msgstr "B<F_SEAL_GROW>"

#. type: Plain text
#: build/C/man2/fcntl.2:1486
msgid ""
"If this seal is set, the size of the file in question cannot be increased.  "
"This affects B<write>(2)  beyond the end of the file, B<truncate>(2), "
"B<ftruncate>(2), and B<fallocate>(2).  These calls fail with B<EPERM> if you "
"use them to increase the file size.  If you keep the size or shrink it, "
"those calls still work as expected."
msgstr ""
"この seal が設定されると、 設定されたファイルのサイズを増やせなくなる。 この "
"seal はファイルの末尾を超えての B<write>(2) や B<truncate>(2), "
"B<ftruncate>(2), B<fallocate>(2) に影響する。 対象のファイルのサイズを大きく"
"しようとした場合、 これらの呼び出しは B<EPERM> で失敗する。 ファイルサイズが"
"変わらない場合、 小さくなる場合は、 これらの呼び出しはそのまま動作する。"

#. type: TP
#: build/C/man2/fcntl.2:1486
#, no-wrap
msgid "B<F_SEAL_WRITE>"
msgstr "B<F_SEAL_WRITE>"

#.  One or more other seals are typically used with F_SEAL_WRITE
#.  because, given a file with the F_SEAL_WRITE seal set, then,
#.  while it would no longer be possible to (say) write zeros into
#.  the last 100 bytes of a file, it would still be possible
#.  to (say) shrink the file by 100 bytes using ftruncate(), and
#.  then increase the file size by 100 bytes, which would have
#.  the effect of replacing the last hundred bytes by zeros.
#. type: Plain text
#: build/C/man2/fcntl.2:1514
msgid ""
"If this seal is set, you cannot modify the contents of the file.  Note that "
"shrinking or growing the size of the file is still possible and allowed.  "
"Thus, this seal is normally used in combination with one of the other "
"seals.  This seal affects B<write>(2)  and B<fallocate>(2)  (only in "
"combination with the B<FALLOC_FL_PUNCH_HOLE> flag).  Those calls fail with "
"B<EPERM> if this seal is set.  Furthermore, trying to create new shared, "
"writable memory-mappings via B<mmap>(2)  will also fail with B<EPERM>."
msgstr ""
"この seal が設定されていると、 ファイルの内容を変更できない。 ファイルのサイ"
"ズを縮小したり伸張したりすることは可能で許可されている。 したがって、 この "
"seal は通常は他の seal のいずれかと組み合わせて使用される。 この seal は "
"B<write>(2) と B<fallocate>(2) (B<FALLOC_FL_PUNCH_HOLE> フラグとの組み合わせ"
"の場合のみ) に影響する。 この seal が設定されると、 これらの呼び出しは "
"B<EPERM> で失敗する。 また、 B<mmap>(2) による新しい書き込み可能な共有メモ"
"リーマッピングの作成も B<EPERM> で失敗する。"

#. type: Plain text
#: build/C/man2/fcntl.2:1527
msgid ""
"Using the B<F_ADD_SEALS> operation to set the B<F_SEAL_WRITE> seal fails "
"with B<EBUSY> if any writable, shared mapping exists.  Such mappings must be "
"unmapped before you can add this seal.  Furthermore, if there are any "
"asynchronous I/O operations (B<io_submit>(2))  pending on the file, all "
"outstanding writes will be discarded."
msgstr "B<F_SEAL_WRITE> seal を設定するのに B<F_ADD_SEALS> 操作を使った場合、書き込み可能な共有マッピングが存在すると B<EBUSY> で失敗する。 このようなマッピングは、 この seal を追加する前にアンマップしなければならない。 また、 ファイルに対して処理待ちの非同期 I/O 操作 (B<io_submit>(2) がある場合、 処理されていない書き込みは破棄される。"

#. type: TP
#: build/C/man2/fcntl.2:1527
#, no-wrap
msgid "B<F_SEAL_FUTURE_WRITE> (since Linux 5.1)"
msgstr "B<F_SEAL_FUTURE_WRITE> (Linux 5.1 以降)"

#. type: Plain text
#: build/C/man2/fcntl.2:1541
msgid ""
"The effect of this seal is similar to B<F_SEAL_WRITE>, but the contents of "
"the file can still be modified via shared writable mappings that were "
"created prior to the seal being set.  Any attempt to create a new writable "
"mapping on the file via B<mmap>(2)  will fail with B<EPERM>.  Likewise, an "
"attempt to write to the file via B<write>(2)  will fail with B<EPERM>."
msgstr ""

#. type: Plain text
#: build/C/man2/fcntl.2:1546
msgid ""
"Using this seal, one process can create a memory buffer that it can continue "
"to modify while sharing that buffer on a \"read-only\" basis with other "
"processes."
msgstr ""

#. type: SS
#: build/C/man2/fcntl.2:1546
#, no-wrap
msgid "File read/write hints"
msgstr ""

#. type: Plain text
#: build/C/man2/fcntl.2:1556
msgid ""
"Write lifetime hints can be used to inform the kernel about the relative "
"expected lifetime of writes on a given inode or via a particular open file "
"description.  (See B<open>(2)  for an explanation of open file "
"descriptions.)  In this context, the term \"write lifetime\" means the "
"expected time the data will live on media, before being overwritten or "
"erased."
msgstr ""

#. type: Plain text
#: build/C/man2/fcntl.2:1564
msgid ""
"An application may use the different hint values specified below to separate "
"writes into different write classes, so that multiple users or applications "
"running on a single storage back-end can aggregate their I/O patterns in a "
"consistent manner.  However, there are no functional semantics implied by "
"these flags, and different I/O classes can use the write lifetime hints in "
"arbitrary ways, so long as the hints are used consistently."
msgstr ""

#. type: Plain text
#: build/C/man2/fcntl.2:1567
msgid "The following operations can be applied to the file descriptor, I<fd>:"
msgstr ""

#. type: TP
#: build/C/man2/fcntl.2:1567
#, no-wrap
msgid "B<F_GET_RW_HINT> (I<uint64_t *>; since Linux 4.13)"
msgstr "B<F_GET_RW_HINT> (I<uint64_t *>; Linux 4.13 以降)"

#. type: Plain text
#: build/C/man2/fcntl.2:1572
#, fuzzy
#| msgid ""
#| "Return (as the function result) the capacity of the pipe referred to by "
#| "I<fd>."
msgid ""
"Returns the value of the read/write hint associated with the underlying "
"inode referred to by I<fd>."
msgstr "I<fd> が参照するパイプの容量を (関数の結果として) 返す。"

#. type: TP
#: build/C/man2/fcntl.2:1572
#, no-wrap
msgid "B<F_SET_RW_HINT> (I<uint64_t *>; since Linux 4.13)"
msgstr "B<F_SET_RW_HINT> (I<uint64_t *>; Linux 4.13 以降)"

#. type: Plain text
#: build/C/man2/fcntl.2:1579
msgid ""
"Sets the read/write hint value associated with the underlying inode referred "
"to by I<fd>.  This hint persists until either it is explicitly modified or "
"the underlying filesystem is unmounted."
msgstr ""

#. type: TP
#: build/C/man2/fcntl.2:1579
#, no-wrap
msgid "B<F_GET_FILE_RW_HINT> (I<uint64_t *>; since Linux 4.13)"
msgstr "B<F_GET_FILE_RW_HINT> (I<uint64_t *>; Linux 4.13 以降)"

#. type: Plain text
#: build/C/man2/fcntl.2:1584
#, fuzzy
#| msgid ""
#| "Return (as the function result) the capacity of the pipe referred to by "
#| "I<fd>."
msgid ""
"Returns the value of the read/write hint associated with the open file "
"description referred to by I<fd>."
msgstr "I<fd> が参照するパイプの容量を (関数の結果として) 返す。"

#. type: TP
#: build/C/man2/fcntl.2:1584
#, no-wrap
msgid "B<F_SET_FILE_RW_HINT> (I<uint64_t *>; since Linux 4.13)"
msgstr "B<F_SET_FILE_RW_HINT> (I<uint64_t *>; Linux 4.13 以降)"

#. type: Plain text
#: build/C/man2/fcntl.2:1589
msgid ""
"Sets the read/write hint value associated with the open file description "
"referred to by I<fd>."
msgstr ""

#. type: Plain text
#: build/C/man2/fcntl.2:1592
msgid ""
"If an open file description has not been assigned a read/write hint, then it "
"shall use the value assigned to the inode, if any."
msgstr ""

#. type: Plain text
#: build/C/man2/fcntl.2:1595
msgid "The following read/write hints are valid since Linux 4.13:"
msgstr ""

#. type: TP
#: build/C/man2/fcntl.2:1595
#, no-wrap
msgid "B<RWH_WRITE_LIFE_NOT_SET>"
msgstr "B<RWH_WRITE_LIFE_NOT_SET>"

#. type: Plain text
#: build/C/man2/fcntl.2:1599
msgid "No specific hint has been set.  This is the default value."
msgstr ""

#. type: TP
#: build/C/man2/fcntl.2:1599
#, no-wrap
msgid "B<RWH_WRITE_LIFE_NONE>"
msgstr "B<RWH_WRITE_LIFE_NONE>"

#. type: Plain text
#: build/C/man2/fcntl.2:1602
msgid "No specific write lifetime is associated with this file or inode."
msgstr ""

#. type: TP
#: build/C/man2/fcntl.2:1602
#, no-wrap
msgid "B<RWH_WRITE_LIFE_SHORT>"
msgstr "B<RWH_WRITE_LIFE_SHORT>"

#. type: Plain text
#: build/C/man2/fcntl.2:1606
msgid ""
"Data written to this inode or via this open file description is expected to "
"have a short lifetime."
msgstr ""

#. type: TP
#: build/C/man2/fcntl.2:1606
#, no-wrap
msgid "B<RWH_WRITE_LIFE_MEDIUM>"
msgstr "B<RWH_WRITE_LIFE_MEDIUM>"

#. type: Plain text
#: build/C/man2/fcntl.2:1612
msgid ""
"Data written to this inode or via this open file description is expected to "
"have a lifetime longer than data written with B<RWH_WRITE_LIFE_SHORT>."
msgstr ""

#. type: TP
#: build/C/man2/fcntl.2:1612
#, no-wrap
msgid "B<RWH_WRITE_LIFE_LONG>"
msgstr "B<RWH_WRITE_LIFE_LONG>"

#. type: Plain text
#: build/C/man2/fcntl.2:1618
msgid ""
"Data written to this inode or via this open file description is expected to "
"have a lifetime longer than data written with B<RWH_WRITE_LIFE_MEDIUM>."
msgstr ""

#. type: TP
#: build/C/man2/fcntl.2:1618
#, no-wrap
msgid "B<RWH_WRITE_LIFE_EXTREME>"
msgstr "B<RWH_WRITE_LIFE_EXTREME>"

#. type: Plain text
#: build/C/man2/fcntl.2:1624
msgid ""
"Data written to this inode or via this open file description is expected to "
"have a lifetime longer than data written with B<RWH_WRITE_LIFE_LONG>."
msgstr ""

#. type: Plain text
#: build/C/man2/fcntl.2:1627
msgid ""
"All the write-specific hints are relative to each other, and no individual "
"absolute meaning should be attributed to them."
msgstr ""

#. type: Plain text
#: build/C/man2/fcntl.2:1629
msgid "For a successful call, the return value depends on the operation:"
msgstr "成功した場合の返り値は操作の種類により違う:"

#. type: TP
#: build/C/man2/fcntl.2:1629
#, no-wrap
msgid "B<F_DUPFD>"
msgstr "B<F_DUPFD>"

#. type: Plain text
#: build/C/man2/fcntl.2:1632
msgid "The new file descriptor."
msgstr "新規のファイルディスクリプター。"

#. type: TP
#: build/C/man2/fcntl.2:1632
#, no-wrap
msgid "B<F_GETFD>"
msgstr "B<F_GETFD>"

#. type: Plain text
#: build/C/man2/fcntl.2:1635
msgid "Value of file descriptor flags."
msgstr "ファイルディスクリプターフラグの値"

#. type: TP
#: build/C/man2/fcntl.2:1635
#, no-wrap
msgid "B<F_GETFL>"
msgstr "B<F_GETFL>"

#. type: Plain text
#: build/C/man2/fcntl.2:1638
msgid "Value of file status flags."
msgstr "ファイル状態フラグの値"

#. type: TP
#: build/C/man2/fcntl.2:1638
#, no-wrap
msgid "B<F_GETLEASE>"
msgstr "B<F_GETLEASE>"

#. type: Plain text
#: build/C/man2/fcntl.2:1641
msgid "Type of lease held on file descriptor."
msgstr "ファイルディスクリプターに対して保持されているリースの種別を返す。"

#. type: TP
#: build/C/man2/fcntl.2:1641
#, no-wrap
msgid "B<F_GETOWN>"
msgstr "B<F_GETOWN>"

#. type: Plain text
#: build/C/man2/fcntl.2:1644
msgid "Value of file descriptor owner."
msgstr "ファイルディスクリプターの所有者。"

#. type: TP
#: build/C/man2/fcntl.2:1644
#, no-wrap
msgid "B<F_GETSIG>"
msgstr "B<F_GETSIG>"

#. type: Plain text
#: build/C/man2/fcntl.2:1650
msgid ""
"Value of signal sent when read or write becomes possible, or zero for "
"traditional B<SIGIO> behavior."
msgstr ""
"読み込みや書き出しが可能になった時に送られるシグナルの値、もしくは 伝統的な "
"B<SIGIO> 動作の場合にはゼロを返す。"

#. type: TP
#: build/C/man2/fcntl.2:1650
#, no-wrap
msgid "B<F_GETPIPE_SZ>, B<F_SETPIPE_SZ>"
msgstr "B<F_GETPIPE_SZ>, B<F_SETPIPE_SZ>"

#. type: Plain text
#: build/C/man2/fcntl.2:1653
msgid "The pipe capacity."
msgstr "パイプの容量。"

#. type: TP
#: build/C/man2/fcntl.2:1653
#, no-wrap
msgid "B<F_GET_SEALS>"
msgstr "B<F_GET_SEALS>"

#. type: Plain text
#: build/C/man2/fcntl.2:1658
msgid ""
"A bit mask identifying the seals that have been set for the inode referred "
"to by I<fd>."
msgstr "I<fd> が参照する inode に設定されている seal を示すビットマスク。"

#. type: TP
#: build/C/man2/fcntl.2:1658
#, no-wrap
msgid "All other commands"
msgstr "他の全てのコマンド"

#. type: Plain text
#: build/C/man2/fcntl.2:1661
msgid "Zero."
msgstr "0 を返す。"

#. type: Plain text
#: build/C/man2/fcntl.2:1665
msgid "On error, -1 is returned, and I<errno> is set appropriately."
msgstr "エラーの時は -1 が返され、 I<errno> に適切な値が設定される。"

#. type: TP
#: build/C/man2/fcntl.2:1666 build/C/man3/lockf.3:124
#, no-wrap
msgid "B<EACCES> or B<EAGAIN>"
msgstr "B<EACCES> か B<EAGAIN>"

#. type: Plain text
#: build/C/man2/fcntl.2:1669
msgid "Operation is prohibited by locks held by other processes."
msgstr "他のプロセスが保持しているロックによって操作が禁止されている。"

#. type: TP
#: build/C/man2/fcntl.2:1669 build/C/man2/fork.2:222 build/C/man2/fork.2:251
#, no-wrap
msgid "B<EAGAIN>"
msgstr "B<EAGAIN>"

#. type: Plain text
#: build/C/man2/fcntl.2:1673
msgid ""
"The operation is prohibited because the file has been memory-mapped by "
"another process."
msgstr ""
"そのファイルは他のプロセスによってメモリーマップされているため、 操作が禁止さ"
"れている。"

#. type: Plain text
#: build/C/man2/fcntl.2:1677
msgid "I<fd> is not an open file descriptor"
msgstr "I<fd> がオープンされたファイルディスクリプターではない。"

#. type: Plain text
#: build/C/man2/fcntl.2:1686
msgid ""
"I<cmd> is B<F_SETLK> or B<F_SETLKW> and the file descriptor open mode "
"doesn't match with the type of lock requested."
msgstr ""
"I<cmd> が B<F_SETLK> または B<F_SETLKW> だったが、対象のファイルディスクリプ"
"ターのオープンモードが 必要となるロックの型にマッチしていない。"

#. type: Plain text
#: build/C/man2/fcntl.2:1695
msgid ""
"I<cmd> is B<F_SETPIPE_SZ> and the new pipe capacity specified in I<arg> is "
"smaller than the amount of buffer space currently used to store data in the "
"pipe."
msgstr ""
"I<cmd> が B<F_SETPIPE_SZ> で、 I<arg> で指定されたパイプの新しい容量がパイプ"
"が、 現在パイプにあるデータを格納するのに使用されているバッファー容量よりも小"
"さい。"

#. type: Plain text
#: build/C/man2/fcntl.2:1705
msgid ""
"I<cmd> is B<F_ADD_SEALS>, I<arg> includes B<F_SEAL_WRITE>, and there exists "
"a writable, shared mapping on the file referred to by I<fd>."
msgstr ""
"I<cmd> が B<F_ADD_SEALS> で、 I<arg> に B<F_SEAL_WRITE> が含まれており、 "
"I<fd> が参照するファイルに対する書き込み可能な共有マッピングが存在する。"

#. type: TP
#: build/C/man2/fcntl.2:1705 build/C/man3/lockf.3:144
#, no-wrap
msgid "B<EDEADLK>"
msgstr "B<EDEADLK>"

#. type: Plain text
#: build/C/man2/fcntl.2:1710
msgid ""
"It was detected that the specified B<F_SETLKW> command would cause a "
"deadlock."
msgstr ""
"指定された B<F_SETLKW> コマンドを実行した場合にはデッドロックになることが検出"
"された。"

#. type: Plain text
#: build/C/man2/fcntl.2:1714
msgid "I<lock> is outside your accessible address space."
msgstr "I<lock> が利用可能なアドレス空間の外部にある。"

#. type: Plain text
#: build/C/man2/fcntl.2:1723
msgid ""
"I<cmd> is B<F_SETLKW> or B<F_OFD_SETLKW> and the operation was interrupted "
"by a signal; see B<signal>(7)."
msgstr ""
"I<cmd> が B<F_SETLKW> か B<F_OFD_SETLKW> で、 操作がシグナルにより割り込まれ"
"た。 B<signal>(7)  参照。"

#. type: Plain text
#: build/C/man2/fcntl.2:1736
msgid ""
"I<cmd> is B<F_GETLK>, B<F_SETLK>, B<F_OFD_GETLK>, or B<F_OFD_SETLK>, and the "
"operation was interrupted by a signal before the lock was checked or "
"acquired.  Most likely when locking a remote file (e.g., locking over NFS), "
"but can sometimes happen locally."
msgstr ""
"I<cmd> が B<F_GETLK>, B<F_SETLK>, B<F_OFD_GETLK>, B<F_OFD_SETLK> で、 操作が"
"シグナルにより割り込まれた (B<signal>(7)  参照)。 B<F_GETLK> と B<F_SETLK> の"
"場合、ロックを確認したり取得したりする前にシグナルによって割り込まれた。 これ"
"はたいていリモートのファイルをロックする場合 (例えば NFS 上でロックする場合) "
"に起こる。 しかしローカルでも起こる場合がある。"

#. type: Plain text
#: build/C/man2/fcntl.2:1741
msgid "The value specified in I<cmd> is not recognized by this kernel."
msgstr "カーネルが認識しない値が I<cmd> で指定された。"

#. type: Plain text
#: build/C/man2/fcntl.2:1749
msgid ""
"I<cmd> is B<F_ADD_SEALS> and I<arg> includes an unrecognized sealing bit."
msgstr ""
"I<cmd> が B<F_ADD_SEALS> で、 I<arg> に認識できない seal を示すビットが含まれ"
"ている。"

#. type: Plain text
#: build/C/man2/fcntl.2:1759
msgid ""
"I<cmd> is B<F_ADD_SEALS> or B<F_GET_SEALS> and the filesystem containing the "
"inode referred to by I<fd> does not support sealing."
msgstr ""
"I<cmd> が B<F_ADD_SEALS> か B<F_GET_SEALS> で、 I<fd> が参照している inode が"
"格納されているファイルシステムが sealing をサポートしていない。"

#. type: Plain text
#: build/C/man2/fcntl.2:1771
msgid ""
"I<cmd> is B<F_DUPFD> and I<arg> is negative or is greater than the maximum "
"allowable value (see the discussion of B<RLIMIT_NOFILE> in B<getrlimit>(2))."
msgstr ""
"I<cmd> が B<F_DUPFD> で、 I<arg> が負か、もしくは許される最大値よりも大きい "
"(B<getrlimit>(2) の B<RLIMIT_NOFILE> の議論を参照)。"

#. type: Plain text
#: build/C/man2/fcntl.2:1779
msgid "I<cmd> is B<F_SETSIG> and I<arg> is not an allowable signal number."
msgstr "I<cmd> が B<F_SETSIG> で、 I<arg> が許可されたシグナル番号ではない。"

#. type: Plain text
#: build/C/man2/fcntl.2:1790
msgid ""
"I<cmd> is B<F_OFD_SETLK>, B<F_OFD_SETLKW>, or B<F_OFD_GETLK>, and I<l_pid> "
"was not specified as zero."
msgstr ""
"I<cmd> が B<F_OFD_SETLK>, B<F_OFD_SETLKW>, B<F_OFD_GETLK> のいずれかで、 "
"I<l_pid> に 0 が指定されなかった。"

#. type: Plain text
#: build/C/man2/fcntl.2:1797
msgid ""
"I<cmd> is B<F_DUPFD> and the per-process limit on the number of open file "
"descriptors has been reached."
msgstr "I<cmd> が B<F_DUPFD>で、オープンされているファイルディスクリプターの数がプロセス単位の上限に達していた。"

#. type: TP
#: build/C/man2/fcntl.2:1797 build/C/man2/flock.2:131 build/C/man3/lockf.3:158
#, no-wrap
msgid "B<ENOLCK>"
msgstr "B<ENOLCK>"

#. type: Plain text
#: build/C/man2/fcntl.2:1801
msgid ""
"Too many segment locks open, lock table is full, or a remote locking "
"protocol failed (e.g., locking over NFS)."
msgstr ""
"オープンされているロックの数が多過ぎて、ロックテーブルがいっぱいである。 また"
"は remote locking protocol (例えば NFS 上のロック) が失敗した。"

#. type: Plain text
#: build/C/man2/fcntl.2:1809
msgid ""
"B<F_NOTIFY> was specified in I<cmd>, but I<fd> does not refer to a directory."
msgstr ""
"B<F_NOTIFY> が I<cmd> に指定されたが、 I<fd> がディレクトリを参照していない。"

#. type: Plain text
#: build/C/man2/fcntl.2:1816
msgid ""
"I<cmd> is B<F_SETPIPE_SZ> and the soft or hard user pipe limit has been "
"reached; see B<pipe>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/fcntl.2:1821
msgid ""
"Attempted to clear the B<O_APPEND> flag on a file that has the append-only "
"attribute set."
msgstr ""
"追加専用属性が設定されたファイルの B<O_APPEND> フラグをクリアしようと試みた。"

#. type: Plain text
#: build/C/man2/fcntl.2:1831
msgid ""
"I<cmd> was B<F_ADD_SEALS>, but I<fd> was not open for writing or the current "
"set of seals on the file already includes B<F_SEAL_SEAL>."
msgstr ""
"I<cmd> が B<F_ADD_SEALS> だが、 I<fd> が書き込み用にオープンされていないか、 "
"ファイルの現在の seal の集合にすでに B<F_SEAL_SEAL> が含まれている。"

#. type: Plain text
#: build/C/man2/fcntl.2:1844
msgid ""
"SVr4, 4.3BSD, POSIX.1-2001.  Only the operations B<F_DUPFD>, B<F_GETFD>, "
"B<F_SETFD>, B<F_GETFL>, B<F_SETFL>, B<F_GETLK>, B<F_SETLK>, and B<F_SETLKW> "
"are specified in POSIX.1-2001."
msgstr ""
"SVr4, 4.3BSD, POSIX.1-2001.  POSIX.1-2001 で規定されている操作は、\n"
"B<F_DUPFD>, B<F_GETFD>, B<F_SETFD>, B<F_GETFL>, B<F_SETFL>, \n"
"B<F_GETLK>, B<F_SETLK>, B<F_SETLKW> だけである。"

#.  .BR _BSD_SOURCE ,
#.  or
#. type: Plain text
#: build/C/man2/fcntl.2:1856
msgid ""
"B<F_GETOWN> and B<F_SETOWN> are specified in POSIX.1-2001.  (To get their "
"definitions, define either B<_XOPEN_SOURCE> with the value 500 or greater, "
"or B<_POSIX_C_SOURCE> with the value 200809L or greater.)"
msgstr "B<F_GETOWN> と B<F_SETOWN> は POSIX.1-2001 で規定されている。 (これら定義するには、 B<_XOPEN_SOURCE> を 500 以上の値で定義するか、 B<_POSIX_C_SOURCE> を 200809L 以上の値で定義するか、 のいずれが必要である。)"

#. type: Plain text
#: build/C/man2/fcntl.2:1864
msgid ""
"B<F_DUPFD_CLOEXEC> is specified in POSIX.1-2008.  (To get this definition, "
"define B<_POSIX_C_SOURCE> with the value 200809L or greater, or "
"B<_XOPEN_SOURCE> with the value 700 or greater.)"
msgstr ""
"B<F_DUPFD_CLOEXEC> は POSIX.1-2008 で規定されている。\n"
"(これら定義するには、\n"
"B<_POSIX_C_SOURCE> を 200809L 以上の値で定義するか、\n"
"B<_XOPEN_SOURCE> を 700 以上の値で定義すること。)"

#.  .PP
#.  SVr4 documents additional EIO, ENOLINK and EOVERFLOW error conditions.
#. type: Plain text
#: build/C/man2/fcntl.2:1881
msgid ""
"B<F_GETOWN_EX>, B<F_SETOWN_EX>, B<F_SETPIPE_SZ>, B<F_GETPIPE_SZ>, "
"B<F_GETSIG>, B<F_SETSIG>, B<F_NOTIFY>, B<F_GETLEASE>, and B<F_SETLEASE> are "
"Linux-specific.  (Define the B<_GNU_SOURCE> macro to obtain these "
"definitions.)"
msgstr ""
"B<F_GETOWN_EX>, B<F_SETOWN_EX>, B<F_SETPIPE_SZ>, B<F_GETPIPE_SZ>, "
"B<F_GETSIG>, \n"
"B<F_SETSIG>, B<F_NOTIFY>, B<F_GETLEASE>, B<F_SETLEASE> は Linux 固有である\n"
"(これらの定義を有効にするには B<_GNU_SOURCE> マクロを定義すること)。"

#. type: Plain text
#: build/C/man2/fcntl.2:1890
msgid ""
"B<F_OFD_SETLK>, B<F_OFD_SETLKW>, and B<F_OFD_GETLK> are Linux-specific (and "
"one must define B<_GNU_SOURCE> to obtain their definitions), but work is "
"being done to have them included in the next version of POSIX.1."
msgstr ""
"B<F_OFD_SETLK>, B<F_OFD_SETLKW>, B<F_OFD_GETLK> は Linux 固有だが (これらの定"
"義を得るには B<_GNU_SOURCE> を定義しなければならない)、 POSIX.1 の次のバー"
"ジョンに含めようという活動が進められている。"

#.  FIXME . Once glibc adds support, add a note about FTM requirements
#. type: Plain text
#: build/C/man2/fcntl.2:1896
msgid "B<F_ADD_SEALS> and B<F_GET_SEALS> are Linux-specific."
msgstr "B<F_ADD_SEALS> と B<F_GET_SEALS> は Linux 固有である。"

#. type: Plain text
#: build/C/man2/fcntl.2:1902
msgid ""
"The errors returned by B<dup2>(2)  are different from those returned by "
"B<F_DUPFD>."
msgstr "エラーの際の返り値が B<dup2>(2)  と B<F_DUPFD> では異なっている。"

#. type: SS
#: build/C/man2/fcntl.2:1902
#, no-wrap
msgid "File locking"
msgstr "ファイルロック"

#. type: Plain text
#: build/C/man2/fcntl.2:1924 build/C/man2/fcntl.2:1966
msgid ""
"The original Linux B<fcntl>()  system call was not designed to handle large "
"file offsets (in the I<flock> structure).  Consequently, an B<fcntl64>()  "
"system call was added in Linux 2.4.  The newer system call employs a "
"different structure for file locking, I<flock64>, and corresponding "
"commands, B<F_GETLK64>, B<F_SETLK64>, and B<F_SETLKW64>.  However, these "
"details can be ignored by applications using glibc, whose B<fcntl>()  "
"wrapper function transparently employs the more recent system call where it "
"is available."
msgstr ""
"元々の Linux の B<fcntl>() システムコールは (I<flock> 構造体で) 大きな\n"
"ファイルオフセットを扱えるように設計されていなかった。\n"
"その結果、Linux 2.4 で B<fcntl64>() システムコールが追加された。\n"
"この新しいシステムコールは、ファイルのロックに I<flock64> という別の\n"
"構造体を利用し、これに対応するコマンドとして B<F_GETLK64>,\n"
"B<F_SETLK64>, B<F_SETLKW64> を使用する。\n"
"しかし、 glibc を使うアプリケーションではこれらの詳細を無視することが\n"
"できる。 glibc の B<fcntl> のラッパー関数は新しいシステムコールが\n"
"利用できる場合はそれを利用するようになっているからである。"

#. type: SS
#: build/C/man2/fcntl.2:1924
#, no-wrap
msgid "Record locks"
msgstr "レコードロック"

#. type: Plain text
#: build/C/man2/fcntl.2:1930
msgid ""
"Since kernel 2.0, there is no interaction between the types of lock placed "
"by B<flock>(2)  and B<fcntl>()."
msgstr ""
"カーネル 2.0 以降では、 B<flock>(2)  と B<fcntl>()  が設定するロック種別の間"
"に相互作用はない。"

#.  e.g., Solaris 8 documents this field in fcntl(2), and Irix 6.5
#.  documents it in fcntl(5).  mtk, May 2007
#.  Also, FreeBSD documents it (Apr 2014).
#. type: Plain text
#: build/C/man2/fcntl.2:1945
#, fuzzy
#| msgid ""
#| "Several systems have more fields in I<struct flock> such as, for example, "
#| "I<l_sysid>.  Clearly, I<l_pid> alone is not going to be very useful if "
#| "the process holding the lock may live on a different machine."
msgid ""
"Several systems have more fields in I<struct flock> such as, for example, "
"I<l_sysid> (to identify the machine where the lock is held).  Clearly, "
"I<l_pid> alone is not going to be very useful if the process holding the "
"lock may live on a different machine; on Linux, while present on some "
"architectures (such as MIPS32), this field is not used."
msgstr ""
"システムによっては、 I<struct flock> に上記以外のフィールドがあるものもある "
"(例えば I<l_sysid>)。 はっきりと言えることは、ロックを保持しているプロセスが"
"別のマシンに存在 する場合には、 I<l_pid> だけはあまり役にたたないだろうという"
"ことである。"

#. type: SS
#: build/C/man2/fcntl.2:1966
#, no-wrap
msgid "Record locking and NFS"
msgstr "レコードロックと NFS"

#
#
#
#.  Neil Brown: With NFSv3 the failure mode is the reverse.  If
#.      the server loses contact with a client then any lock stays in place
#.      indefinitely ("why can't I read my mail"... I remember it well).
#.  Jeff Layton:
#.      Note that this is not a firm timeout. The server runs a job
#.      periodically to clean out expired stateful objects, and it's likely
#.      that there is some time (maybe even up to another whole lease period)
#.      between when the timeout expires and the job actually runs. If the
#.      client gets a RENEW in there within that window, its lease will be
#.      renewed and its state preserved.
#. type: Plain text
#: build/C/man2/fcntl.2:1994
msgid ""
"Before Linux 3.12, if an NFSv4 client loses contact with the server for a "
"period of time (defined as more than 90 seconds with no communication), it "
"might lose and regain a lock without ever being aware of the fact.  (The "
"period of time after which contact is assumed lost is known as the NFSv4 "
"leasetime.  On a Linux NFS server, this can be determined by looking at I</"
"proc/fs/nfsd/nfsv4leasetime>, which expresses the period in seconds.  The "
"default value for this file is 90.)  This scenario potentially risks data "
"corruption, since another process might acquire a lock in the intervening "
"period and perform file I/O."
msgstr ""
"Linux 3.12 より前では、 NFSv4 クライアントが一定時間サーバーと通信がなかった"
"場合 (90 秒間通信がない場合と定義されている)、 クライアントが気付かずにロック"
"を失い再獲得する場合がある。 (通信がなくなったみなす時間は NFSv4 leastime と"
"呼ばれる。 Linux NFS サーバーでは、 この値は I</proc/fs/nfsd/nfsv4leasetime> "
"を見て決定される。 このファイルの値の単位は秒であり、 このファイルのデフォル"
"ト値は 90 である。) この状況では潜在的にデータ破壊が起こる危険性がある。 通信"
"がなかった間に他のプロセスがロックを獲得しファイル入出力を行う場合があるから"
"である。"

#.  commit ef1820f9be27b6ad158f433ab38002ab8131db4d
#.  commit f6de7a39c181dfb8a2c534661a53c73afb3081cd
#. type: Plain text
#: build/C/man2/fcntl.2:2008
msgid ""
"Since Linux 3.12, if an NFSv4 client loses contact with the server, any I/O "
"to the file by a process which \"thinks\" it holds a lock will fail until "
"that process closes and reopens the file.  A kernel parameter, I<nfs."
"recover_lost_locks>, can be set to 1 to obtain the pre-3.12 behavior, "
"whereby the client will attempt to recover lost locks when contact is "
"reestablished with the server.  Because of the attendant risk of data "
"corruption, this parameter defaults to 0 (disabled)."
msgstr ""
"Linux 3.12 以降、 NFSv4 クライアントがサーバーと通信がなかった場合、 ロックを"
"持っていると「思っている」プロセスがそのファイルに入出力を行うと失敗する。 そ"
"のプロセスがそのファイルをいったんクローズし再オープンするまでは入出力は失敗"
"する。 カーネルパラメーター I<nfs.recover_lost_locks> を 1 に設定すると、 "
"Linux 3.12 より前の動作にすることができる。 この場合、 サーバーとの通信が再確"
"立された場合、 クライアントがは失われたロックを回復しようとする。 データ破壊"
"が起こる危険性があるため、 このパラメーターはデフォルトでは 0 (無効) になって"
"いる。"

#. type: SS
#: build/C/man2/fcntl.2:2009
#, no-wrap
msgid "F_SETFL"
msgstr "F_SETFL"

#.  FIXME . According to POSIX.1-2001, O_SYNC should also be modifiable
#.  via fcntl(2), but currently Linux does not permit this
#.  See http://bugzilla.kernel.org/show_bug.cgi?id=5994
#. type: Plain text
#: build/C/man2/fcntl.2:2021
msgid ""
"It is not possible to use B<F_SETFL> to change the state of the B<O_DSYNC> "
"and B<O_SYNC> flags.  Attempts to change the state of these flags are "
"silently ignored."
msgstr ""
"B<F_SETFL> を使って、 フラグ B<O_DSYNC> と B<O_SYNC> の状態を変更することはで"
"きない。これらのフラグの状態を変更しようとした場合には、黙って無視される。"

#. type: SS
#: build/C/man2/fcntl.2:2021
#, no-wrap
msgid "F_GETOWN"
msgstr "F_GETOWN"

#.  glibc source: sysdeps/unix/sysv/linux/i386/sysdep.h
#.  mtk, Dec 04: some limited testing on alpha and ia64 seems to
#.  indicate that ANY negative PGID value will cause F_GETOWN
#.  to misinterpret the return as an error. Some other architectures
#.  seem to have the same range check as i386.
#. type: Plain text
#: build/C/man2/fcntl.2:2047
msgid ""
"A limitation of the Linux system call conventions on some architectures "
"(notably i386) means that if a (negative)  process group ID to be returned "
"by B<F_GETOWN> falls in the range -1 to -4095, then the return value is "
"wrongly interpreted by glibc as an error in the system call; that is, the "
"return value of B<fcntl>()  will be -1, and I<errno> will contain the "
"(positive) process group ID.  The Linux-specific B<F_GETOWN_EX> operation "
"avoids this problem.  Since glibc version 2.11, glibc makes the kernel "
"B<F_GETOWN> problem invisible by implementing B<F_GETOWN> using "
"B<F_GETOWN_EX>."
msgstr ""
"いくつかのアーキテクチャー (特に i386) における Linux システムコールの慣習\n"
"のため以下の制限が存在する。\n"
"B<F_GETOWN> が返す (負の) プロセスグループID が -1 から -4095 の範囲に入った"
"場合、\n"
"glibc はこの返り値をシステムコールでエラーが起こったと間違って解釈してしま"
"う。\n"
"つまり、 B<fcntl>() の返り値は -1 となり、 I<errno> には (正の) プロセスグ"
"ループID\n"
"が設定されることになる。Linux 固有の B<F_GETOWN_EX> ではこの問題を回避でき"
"る。\n"
"glibc バージョン 2.11 以降では、glibc では B<F_GETOWN_EX> を使って\n"
"B<F_GETOWN> を実装することで、カーネルの B<F_GETOWN> の問題を見えないようにし"
"ている。"

#. type: SS
#: build/C/man2/fcntl.2:2047
#, no-wrap
msgid "F_SETOWN"
msgstr "F_SETOWN"

#. type: Plain text
#: build/C/man2/fcntl.2:2065
msgid ""
"In Linux 2.4 and earlier, there is bug that can occur when an unprivileged "
"process uses B<F_SETOWN> to specify the owner of a socket file descriptor as "
"a process (group) other than the caller.  In this case, B<fcntl>()  can "
"return -1 with I<errno> set to B<EPERM>, even when the owner process (group) "
"is one that the caller has permission to send signals to.  Despite this "
"error return, the file descriptor owner is set, and signals will be sent to "
"the owner."
msgstr ""
"Linux 2.4 以前では、非特権プロセスが B<F_SETOWN> を使って、ソケットのファイル"
"ディスクリプターの所有者に 呼び出し元以外のプロセス (やプロセスグループ) を指"
"定すると 発生するバグがある。この場合、 呼び出し元が所有者として指定したプロ"
"セス (やプロセスグループ) に シグナルを送る許可を持っていたとしても、 "
"B<fcntl>()  が -1 を返し I<errno> に B<EPERM> を設定することがある。 このエ"
"ラーが返ったにもかかわらず、ファイルディスクリプターの所有者 は設定され、シグ"
"ナルはその所有者に送られる。"

#. type: SS
#: build/C/man2/fcntl.2:2065
#, no-wrap
msgid "Deadlock detection"
msgstr "デッドロックの検出"

#. type: Plain text
#: build/C/man2/fcntl.2:2084
msgid ""
"The deadlock-detection algorithm employed by the kernel when dealing with "
"B<F_SETLKW> requests can yield both false negatives (failures to detect "
"deadlocks, leaving a set of deadlocked processes blocked indefinitely)  and "
"false positives (B<EDEADLK> errors when there is no deadlock).  For example, "
"the kernel limits the lock depth of its dependency search to 10 steps, "
"meaning that circular deadlock chains that exceed that size will not be "
"detected.  In addition, the kernel may falsely indicate a deadlock when two "
"or more processes created using the B<clone>(2)  B<CLONE_FILES> flag place "
"locks that appear (to the kernel) to conflict."
msgstr ""
"B<F_SETLKW> 要求を処理する際にカーネルが使用するデッドロック検出アルゴリズム"
"は、 false negative になる場合 (デッドロックを検出できず、 デッドロックになっ"
"たプロセスは無限に停止する) も false positive になる場合 (デッドロックがない"
"場合でも B<EDEADLK> エラーとなる) もある。 例えば、 カーネルは依存関係の検索"
"を行うロックの深さを 10 ステップに限定しているが、 このためこれよりも長い循環"
"するデッドロックは検出されない。 また、 B<clone>(2) の B<CLONE_FILES> フラグ"
"を使って作成された 2 つ以上のプロセスが (カーネルにとって) 衝突するように見え"
"るロックを適用した場合、 カーネルはデッドロックを誤って検出する。"

#.  http://marc.info/?l=linux-kernel&m=119013491707153&w=2
#.  Reconfirmed by Jeff Layton
#.      From: Jeff Layton <jlayton <at> redhat.com>
#.      Subject: Re: Status of fcntl() mandatory locking
#.      Newsgroups: gmane.linux.file-systems
#.      Date: 2014-04-28 10:07:57 GMT
#.      http://thread.gmane.org/gmane.linux.file-systems/84481/focus=84518
#. type: Plain text
#: build/C/man2/fcntl.2:2106
msgid ""
"The Linux implementation of mandatory locking is subject to race conditions "
"which render it unreliable: a B<write>(2)  call that overlaps with a lock "
"may modify data after the mandatory lock is acquired; a B<read>(2)  call "
"that overlaps with a lock may detect changes to data that were made only "
"after a write lock was acquired.  Similar races exist between mandatory "
"locks and B<mmap>(2).  It is therefore inadvisable to rely on mandatory "
"locking."
msgstr ""
"Linux の強制ロックの実装は、 競合条件下で強制ロックが不完全になるような場合が"
"ある。 ロックと重なって実行された B<write>(2)  の呼び出しは強制ロックが獲得さ"
"れた後にもデータを変更することができる。 ロックと重なって実行された "
"B<read>(2)  の呼び出しは強制ロックが獲得された後になって行われたデータの変更"
"を 検出することができる。 同様の競合条件が強制ロックと B<mmap>(2)  の間にも存"
"在する。それゆえ、強制ロックに頼るのはお薦めできない。"

#. type: Plain text
#: build/C/man2/fcntl.2:2115
msgid ""
"B<dup2>(2), B<flock>(2), B<open>(2), B<socket>(2), B<lockf>(3), "
"B<capabilities>(7), B<feature_test_macros>(7), B<lslocks>(8)"
msgstr ""
" B<dup2>(2), B<flock>(2), B<open>(2), B<socket>(2), B<lockf>(3), "
"B<capabilities>(7), B<feature_test_macros>(7), B<lslocks>(8)"

#. type: Plain text
#: build/C/man2/fcntl.2:2128
msgid ""
"I<locks.txt>, I<mandatory-locking.txt>, and I<dnotify.txt> in the Linux "
"kernel source directory I<Documentation/filesystems/> (on older kernels, "
"these files are directly under the I<Documentation/> directory, and "
"I<mandatory-locking.txt> is called I<mandatory.txt>)"
msgstr ""
"Linux カーネルソースの I<Documentation/filesystems/> ディレクトリ内の "
"I<locks.txt>, I<mandatory-locking.txt>, I<dnotify.txt> (以前のカーネルでは、"
"これらのファイルは I<Documentation/> ディレクトリ直下にあり、 I<mandatory-"
"locking.txt> は I<mandatory.txt> という名前であった)"

#. type: TH
#: build/C/man3/fexecve.3:25
#, no-wrap
msgid "FEXECVE"
msgstr "FEXECVE"

#. type: TH
#: build/C/man3/fexecve.3:25 build/C/man2/getdomainname.2:29
#: build/C/man2/gethostname.2:32 build/C/man2/uname.2:27
#, no-wrap
msgid "2019-10-10"
msgstr " 2019-10-10"

#. type: Plain text
#: build/C/man3/fexecve.3:28
msgid "fexecve - execute program specified via file descriptor"
msgstr "fexecve - ファイルディスクリプターで指定されたプログラムを実行する"

#. type: Plain text
#: build/C/man3/fexecve.3:33
#, no-wrap
msgid "B<int fexecve(int >I<fd>B<, char *const >I<argv>B<[], char *const >I<envp>B<[]);>\n"
msgstr "B<int fexecve(int >I<fd>B<, char *const >I<argv>B<[], char *const >I<envp>B<[]);>\n"

#. type: Plain text
#: build/C/man3/fexecve.3:41
msgid "B<fexecve>():"
msgstr "B<fexecve>():"

#. type: Plain text
#: build/C/man3/fexecve.3:50 build/C/man3/getcwd.3:54
msgid "_GNU_SOURCE"
msgstr "_GNU_SOURCE"

#. type: Plain text
#: build/C/man3/fexecve.3:69
#, fuzzy
#| msgid ""
#| "B<fexecve>()  performs the same task as B<execve>(2), with the difference "
#| "that the file to be executed is specified via a file descriptor, I<fd>, "
#| "rather than via a pathname.  The file descriptor I<fd> must be opened "
#| "read-only, and the caller must have permission to execute the file that "
#| "it refers to."
msgid ""
"B<fexecve>()  performs the same task as B<execve>(2), with the difference "
"that the file to be executed is specified via a file descriptor, I<fd>, "
"rather than via a pathname.  The file descriptor I<fd> must be opened read-"
"only (B<O_RDONLY>)  or with the B<O_PATH> flag and the caller must have "
"permission to execute the file that it refers to."
msgstr ""
"B<fexecve>()  は B<execve>(2)  と同じ作業を行う。違うのは、 実行するファイル"
"を、パス名ではなく、 ファイルディスクリプター I<fd> を用いて指定する点であ"
"る。 ファイルディスクリプター I<fd> は、読み込み専用でオープンされていなけれ"
"ばならず、 呼び出し元はファイルディスクリプターが参照するファイルに対する 実"
"行許可を持っていなければならない。"

#. type: Plain text
#: build/C/man3/fexecve.3:76
msgid ""
"A successful call to B<fexecve>()  never returns.  On error, the function "
"does return, with a result value of -1, and I<errno> is set appropriately."
msgstr ""
"B<fexecve>()  は呼び出しに成功した場合、戻ることはない。 エラーの場合、返り"
"値 -1 で関数が返り、 I<errno> が適切に設定される。"

#. type: Plain text
#: build/C/man3/fexecve.3:80
msgid "Errors are as for B<execve>(2), with the following additions:"
msgstr "エラーは B<execve>(2)  と同じだが、以下のエラーが追加になっている:"

#. type: Plain text
#: build/C/man3/fexecve.3:88
msgid ""
"I<fd> is not a valid file descriptor, or I<argv> is NULL, or I<envp> is NULL."
msgstr ""
"I<fd> が有効なファイルディスクリプターでない。または I<argv> が NULL である。"
"または I<envp> が NULL である。"

#. type: Plain text
#: build/C/man3/fexecve.3:96
msgid ""
"The close-on-exec flag is set on I<fd>, and I<fd> refers to a script.  See "
"BUGS."
msgstr ""

#. type: Plain text
#: build/C/man3/fexecve.3:103
msgid ""
"The kernel does not provide the B<execveat>(2)  system call, and the I</"
"proc> filesystem could not be accessed."
msgstr ""

#. type: Plain text
#: build/C/man3/fexecve.3:106
msgid "B<fexecve>()  is implemented since glibc 2.3.2."
msgstr "B<fexecve>()  は glibc 2.3.2 以降で実装されている。"

#. type: tbl table
#: build/C/man3/fexecve.3:116
#, no-wrap
msgid "B<fexecve>()"
msgstr " B<fexecve>()"

#. type: Plain text
#: build/C/man3/fexecve.3:124
msgid ""
"POSIX.1-2008.  This function is not specified in POSIX.1-2001, and is not "
"widely available on other systems.  It is specified in POSIX.1-2008."
msgstr ""
"POSIX.1-2008.  この関数は POSIX.1-2001 では規定されておらず、 他のシステムで"
"広く利用できるわけではない。 POSIX.1-2008 で規定されている。"

#.  glibc commit 43ffc53a352a67672210c9dd4959f6c6b7407e60
#. type: Plain text
#: build/C/man3/fexecve.3:141
msgid ""
"On Linux with glibc versions 2.26 and earlier, B<fexecve>()  is implemented "
"using the B<proc>(5)  filesystem, so I</proc> needs to be mounted and "
"available at the time of the call.  Since glibc 2.27, if the underlying "
"kernel supports the B<execveat>(2)  system call, then B<fexecve>()  is "
"implemented using that system call, with the benefit that I</proc> does not "
"need to be mounted."
msgstr ""

#. type: Plain text
#: build/C/man3/fexecve.3:158
msgid ""
"The idea behind B<fexecve>()  is to allow the caller to verify (checksum) "
"the contents of an executable before executing it.  Simply opening the file, "
"checksumming the contents, and then doing an B<execve>(2)  would not "
"suffice, since, between the two steps, the filename, or a directory prefix "
"of the pathname, could have been exchanged (by, for example, modifying the "
"target of a symbolic link).  B<fexecve>()  does not mitigate the problem "
"that the I<contents> of a file could be changed between the checksumming and "
"the call to B<fexecve>(); for that, the solution is to ensure that the "
"permissions on the file prevent it from being modified by malicious users."
msgstr ""
"B<fexecve>() の裏にある考えは、呼び出し元が、ファイルを実行する前に実行ファイ"
"ルの内容を検査 (チェックサムを確認) できるようにすることである。単に、ファイ"
"ルをオープンして内容のチェックサムを検査し、それから B<execve>(2) を行うのは"
"十分ではない。なぜなら、2 つのステップの間で、ファイル名や、パス名のディレク"
"トリの前の方が入れ換えられる可能性があるからだ (例えば、シンボリックリンクの"
"リンク先を変更するなど)。B<fexecve>() は、チェックサムの検査と B<fexecve>() "
"の呼び出しの間で、ファイルのI<内容>を変更できる可能性があるという問題への対策"
"にはならない。この問題に対する対応策は、確実に、ファイルのアクセス許可を設定"
"し、悪意のあるユーザーがファイルを変更できないようにすることである。"

#. type: Plain text
#: build/C/man3/fexecve.3:176
msgid ""
"The natural idiom when using B<fexecve>()  is to set the close-on-exec flag "
"on I<fd>, so that the file descriptor does not leak through to the program "
"that is executed.  This approach is natural for two reasons.  First, it "
"prevents file descriptors being consumed unnecessarily.  (The executed "
"program normally has no need of a file descriptor that refers to the program "
"itself.)  Second, if B<fexecve>()  is used recursively, employing the close-"
"on-exec flag prevents the file descriptor exhaustion that would result from "
"the fact that each step in the recursion would cause one more file "
"descriptor to be passed to the new program.  (But see BUGS.)"
msgstr ""
"B<fexecve>() を使用する際の理にかなった方法は、 I<fd> に close-on-exec フラグ"
"をセットし、 実行するプログラムを通じてそのファイルディスクリプターが外部にも"
"れないようにすることである。 この方法は 2 つの理由から理にかなっている。 1 つ"
"目は、 これにより不必要にファイルディスクリプターが消費されるのを防ぐことがで"
"きる (実行されるプログラムは普通プログラム自身が参照するファイルを参照する必"
"要はない)。 2 つ目は、 B<fexecve>() が再帰的に使用された場合、 close-on-exec "
"フラグを利用することで、 再帰の各ステップで新しいプログラムに一つ余計にファイ"
"ルディスクリプターが渡されることによる、 ファイルディスクリプターの枯渇を防ぐ"
"ことができる (ただし「バグ」を参照)。"

#. type: Plain text
#: build/C/man3/fexecve.3:195
msgid ""
"If I<fd> refers to a script (i.e., it is an executable text file that names "
"a script interpreter with a first line that begins with the characters I<#!"
">)  and the close-on-exec flag has been set for I<fd>, then B<fexecve>()  "
"fails with the error B<ENOENT>.  This error occurs because, by the time the "
"script interpreter is executed, I<fd> has already been closed because of the "
"close-on-exec flag.  Thus, the close-on-exec flag can't be set on I<fd> if "
"it refers to a script, leading to the problems described in NOTES."
msgstr ""
"I<fd> がスクリプトを参照していて (つまり、 最初の行に文字 I<#!> で始まるスク"
"リプトインタープリターの指示がある実行テキストファイルである)、 I<fd> に "
"close-on-exec フラグがセットされていた場合、 B<fexecve>() はエラー B<ENOENT> "
"で失敗する。 このエラーが起こるのは、 スクリプトインタープリターが実行される"
"時点までに、 close-on-exec フラグにより I<fd> がすでにクローズされてしまって"
"いるからである。 そのため、 スクリプトを参照する場合には、 close-on-exec フラ"
"グを I<fd> にセットすることはできず、 「注意」の節で説明されている問題が起こ"
"り得る。"

#. type: Plain text
#: build/C/man3/fexecve.3:198
msgid "B<execve>(2), B<execveat>(2)"
msgstr "B<execve>(2), B<execveat>(2)"

#. type: TH
#: build/C/man2/flock.2:35
#, no-wrap
msgid "FLOCK"
msgstr "FLOCK"

#. type: Plain text
#: build/C/man2/flock.2:38
msgid "flock - apply or remove an advisory lock on an open file"
msgstr ""
"flock - オープンされたファイルに対するアドバイザリロックの適用、解除を行う"

#. type: Plain text
#: build/C/man2/flock.2:40
msgid "B<#include E<lt>sys/file.hE<gt>>"
msgstr "B<#include E<lt>sys/file.hE<gt>>"

#. type: Plain text
#: build/C/man2/flock.2:42
msgid "B<int flock(int >I<fd>B<, int >I<operation>B<);>"
msgstr "B<int flock(int >I<fd>B<, int >I<operation>B<);>"

#. type: Plain text
#: build/C/man2/flock.2:48
msgid ""
"Apply or remove an advisory lock on the open file specified by I<fd>.  The "
"argument I<operation> is one of the following:"
msgstr ""
"オープンされたファイルにアドバイザリロック (advisory lock) の適用 や解除を行"
"う。 ファイルは I<fd> で指定する。引数 I<operation> には以下のいずれか一つ"
"を指定する:"

#. type: TP
#: build/C/man2/flock.2:49
#, no-wrap
msgid "B<LOCK_SH>"
msgstr "B<LOCK_SH>"

#. type: Plain text
#: build/C/man2/flock.2:54
msgid ""
"Place a shared lock.  More than one process may hold a shared lock for a "
"given file at a given time."
msgstr ""
"共有ロックを適用する。 指定したファイルに対して、 一つ以上のプロセスが同時に"
"共有ロックを保持することができる。"

#. type: TP
#: build/C/man2/flock.2:54
#, no-wrap
msgid "B<LOCK_EX>"
msgstr "B<LOCK_EX>"

#. type: Plain text
#: build/C/man2/flock.2:59
msgid ""
"Place an exclusive lock.  Only one process may hold an exclusive lock for a "
"given file at a given time."
msgstr ""
"排他ロックを適用する。 指定したファイルに対して、 ただ一つのプロセスだけが同"
"時に排他ロックを保持することができる。"

#. type: TP
#: build/C/man2/flock.2:59
#, no-wrap
msgid "B<LOCK_UN>"
msgstr "B<LOCK_UN>"

#. type: Plain text
#: build/C/man2/flock.2:62
msgid "Remove an existing lock held by this process."
msgstr "このプロセスが保持している既存のロックを解除する。"

#. type: Plain text
#: build/C/man2/flock.2:71
msgid ""
"A call to B<flock>()  may block if an incompatible lock is held by another "
"process.  To make a nonblocking request, include B<LOCK_NB> (by ORing)  with "
"any of the above operations."
msgstr ""
"B<flock>()  を呼び出したときに、指定したロック種別と異なるロックが別プロセス"
"によって 保持されていると、 B<flock>()  は停止 (block) されることがある。 非"
"停止 (nonblocking) タイプの要求を行うためには、 上記の操作 (operation) に "
"B<LOCK_NB> を論理和の形で指定する。"

#. type: Plain text
#: build/C/man2/flock.2:73
msgid ""
"A single file may not simultaneously have both shared and exclusive locks."
msgstr "一つのファイルに共有ロックと排他ロックを同時に設定することはできない。"

#. type: Plain text
#: build/C/man2/flock.2:88
msgid ""
"Locks created by B<flock>()  are associated with an open file description "
"(see B<open>(2)).  This means that duplicate file descriptors (created by, "
"for example, B<fork>(2)  or B<dup>(2))  refer to the same lock, and this "
"lock may be modified or released using any of these file descriptors.  "
"Furthermore, the lock is released either by an explicit B<LOCK_UN> operation "
"on any of these duplicate file descriptors, or when all such file "
"descriptors have been closed."
msgstr ""
"B<flock>() によって作られるロックは、 オープンファイル記述 (open file "
"description) (B<open>(2) 参照) と関連付けられる。 したがって、ファイルディス"
"クリプターの複製 (B<fork>(2)  や B<dup>(2)  などにより作成される) は同じロッ"
"クを参照し、 これらのファイルディスクリプターのどれを使っても このロックを変"
"更したり解放したりできる。 また、ロックの解放は、 上記の複数のファイルディス"
"クリプターのいずれかに対して 明示的に B<LOCK_UN> 操作を指示した場合か、これら"
"のファイルディスクリプターがすべて 閉じられた場合に行われる。"

#. type: Plain text
#: build/C/man2/flock.2:97
msgid ""
"If a process uses B<open>(2)  (or similar) to obtain more than one file "
"descriptor for the same file, these file descriptors are treated "
"independently by B<flock>().  An attempt to lock the file using one of these "
"file descriptors may be denied by a lock that the calling process has "
"already placed via another file descriptor."
msgstr "あるプロセスが B<open>(2)  (もしくは同様の方法) を使って同じファイルに対して 複数のファイルディスクリプターを取得した場合、 B<flock>()  はこれら複数のファイルディスクリプターを各々独立のものとして扱う。 これらのファイルディスクリプターの一つを使ってファイルをロックしようと した際、そのロック要求は、呼び出し元のプロセスがそのファイルの別のファイルディスクリプター経由ですでに設定しているロックによって拒否される場合がある。"

#. type: Plain text
#: build/C/man2/flock.2:104
msgid ""
"A process may hold only one type of lock (shared or exclusive)  on a file.  "
"Subsequent B<flock>()  calls on an already locked file will convert an "
"existing lock to the new lock mode."
msgstr ""
"一つのプロセスは、一つのファイルに対して (共有ロックと排他ロックのうち)  いず"
"れか一種類のロックしか設定できない。 既にロックされたファイルに対して "
"B<flock>()  を呼び出すと、既存のロックを新しいロックモードに変更することにな"
"る。"

#. type: Plain text
#: build/C/man2/flock.2:109
msgid "Locks created by B<flock>()  are preserved across an B<execve>(2)."
msgstr ""
"B<flock>()  により作成されたロックは B<execve>(2)  の前後で保存される。"

#. type: Plain text
#: build/C/man2/flock.2:112
msgid ""
"A shared or exclusive lock can be placed on a file regardless of the mode in "
"which the file was opened."
msgstr ""
"共有ロックも排他ロックも、ファイルがどのモードでオープンされたかに 関係なく適"
"用することができる。"

#. type: Plain text
#: build/C/man2/flock.2:122
msgid "I<fd> is not an open file descriptor."
msgstr "I<fd> がオープンされたファイルディスクリプターではない。"

#. type: Plain text
#: build/C/man2/flock.2:127 build/C/man3/lockf.3:154
msgid ""
"While waiting to acquire a lock, the call was interrupted by delivery of a "
"signal caught by a handler; see B<signal>(7)."
msgstr ""
"ロックの獲得を待っている間に、ハンドラーにより捕捉されたシグナルを 受信し、 "
"B<flock>()  が中断された。 B<signal>(7)  参照。"

#. type: Plain text
#: build/C/man2/flock.2:131
msgid "I<operation> is invalid."
msgstr "I<oepration> が無効である。"

#. type: Plain text
#: build/C/man2/flock.2:134
msgid "The kernel ran out of memory for allocating lock records."
msgstr "ロックレコードを割り当てるためのメモリーが不足している。"

#. type: TP
#: build/C/man2/flock.2:134
#, no-wrap
msgid "B<EWOULDBLOCK>"
msgstr "B<EWOULDBLOCK>"

#. type: Plain text
#: build/C/man2/flock.2:139
msgid "The file is locked and the B<LOCK_NB> flag was selected."
msgstr ""
"指定したファイルがロックされており、 B<LOCK_NB> フラグが指定されている。"

#. type: Plain text
#: build/C/man2/flock.2:148
msgid ""
"4.4BSD (the B<flock>()  call first appeared in 4.2BSD).  A version of "
"B<flock>(), possibly implemented in terms of B<fcntl>(2), appears on most "
"UNIX systems."
msgstr ""
"4.4BSD (B<flock>()  コールは 4.2BSD で最初に登場した)。 B<fcntl>(2)  で実装さ"
"れているものなどを含めると、 B<flock>()  の機能はほとんどの UNIX システムで実"
"装されている。"

#.  E.g., according to the flock(2) man page, FreeBSD since at least 5.3
#. type: Plain text
#: build/C/man2/flock.2:171
msgid ""
"Since kernel 2.0, B<flock>()  is implemented as a system call in its own "
"right rather than being emulated in the GNU C library as a call to "
"B<fcntl>(2).  With this implementation, there is no interaction between the "
"types of lock placed by B<flock>()  and B<fcntl>(2), and B<flock>()  does "
"not detect deadlock.  (Note, however, that on some systems, such as the "
"modern BSDs, B<flock>()  and B<fcntl>(2)  locks I<do> interact with one "
"another.)"
msgstr ""
"kernel 2.0 以降では、 B<flock>()  は、GNU C ライブラリでの B<fcntl>(2)  を呼"
"び出してのエミュレーションではなく、 それ自体がシステムコールとして実装されて"
"いる。 この実装では、 B<flock>()  と B<fcntl>(2)  で適用されるロックの種別に"
"は相互作用がなくなり、 B<flock>()  がデッドロックを検出しなくなる。 (ただし、"
"最近の BSD などいくつかのシステムでは、 B<flock>() と B<fcntl>(2) ロックが互"
"いに影響することが「ある」という点に注意すること。)"

#. type: Plain text
#: build/C/man2/flock.2:177
msgid ""
"B<flock>()  places advisory locks only; given suitable permissions on a "
"file, a process is free to ignore the use of B<flock>()  and perform I/O on "
"the file."
msgstr ""
"B<flock>()  アドバイザリロックだけを適用する。したがって、ファイルに適切なア"
"クセス権を 付与していれば、プロセスは B<flock>()  の使用に無視して、ファイル"
"への入出力を行うことができる。"

#. type: Plain text
#: build/C/man2/flock.2:190
msgid ""
"B<flock>()  and B<fcntl>(2)  locks have different semantics with respect to "
"forked processes and B<dup>(2).  On systems that implement B<flock>()  using "
"B<fcntl>(2), the semantics of B<flock>()  will be different from those "
"described in this manual page."
msgstr ""
"B<flock>()  と B<fcntl>(2)  は fork されたプロセスと B<dup>(2)  で違った動作"
"をする。 B<flock>()  を B<fcntl>(2)  を使って実装しているシステムでは、 "
"B<flock>()  の動作はこのマニュアルページに記載されているものとは違うだろう。"

#.  Kernel 2.5.21 changed things a little: during lock conversion
#.  it is now the highest priority process that will get the lock -- mtk
#. type: Plain text
#: build/C/man2/flock.2:203
msgid ""
"Converting a lock (shared to exclusive, or vice versa) is not guaranteed to "
"be atomic: the existing lock is first removed, and then a new lock is "
"established.  Between these two steps, a pending lock request by another "
"process may be granted, with the result that the conversion either blocks, "
"or fails if B<LOCK_NB> was specified.  (This is the original BSD behavior, "
"and occurs on many other implementations.)"
msgstr ""
"ロックの変換 (共有ロックから排他ロックへ、もしくはその反対) がアトミックに 行"
"われることは保証されていない: 既存のロックがまず削除され、それから新しい ロッ"
"クが設定される。この 2つのステップの間に、他のプロセスからの処理待ちの ロック"
"要求が認められるかもしれず、結果として変換は停止 (block) したり、 "
"(B<LOCK_NB> が指定された場合には) 失敗したりする。 (これは元々の BSD の動作で"
"あり、多くの他の実装でも起こる。)"

#. type: SS
#: build/C/man2/flock.2:203
#, no-wrap
msgid "NFS details"
msgstr "NFS での詳細"

#. type: Plain text
#: build/C/man2/flock.2:213
msgid ""
"In Linux kernels up to 2.6.11, B<flock>()  does not lock files over NFS (i."
"e., the scope of locks was limited to the local system).  Instead, one could "
"use B<fcntl>(2)  byte-range locking, which does work over NFS, given a "
"sufficiently recent version of Linux and a server which supports locking."
msgstr ""

#. type: Plain text
#: build/C/man2/flock.2:228
msgid ""
"Since Linux 2.6.12, NFS clients support B<flock>()  locks by emulating them "
"as B<fcntl>(2)  byte-range locks on the entire file.  This means that "
"B<fcntl>(2)  and B<flock>()  locks I<do> interact with one another over "
"NFS.  It also means that in order to place an exclusive lock, the file must "
"be opened for writing."
msgstr ""

#.  commit 5eebde23223aeb0ad2d9e3be6590ff8bbfab0fc2
#. type: Plain text
#: build/C/man2/flock.2:240
msgid ""
"Since Linux 2.6.37, the kernel supports a compatibility mode that allows "
"B<flock>()  locks (and also B<fcntl>(2)  byte region locks) to be treated as "
"local; see the discussion of the I<local_lock> option in B<nfs>(5)."
msgstr ""

#. type: Plain text
#: build/C/man2/flock.2:250
msgid ""
"B<flock>(1), B<close>(2), B<dup>(2), B<execve>(2), B<fcntl>(2), B<fork>(2), "
"B<open>(2), B<lockf>(3), B<lslocks>(8)"
msgstr ""
" B<flock>(1), B<close>(2), B<dup>(2), B<execve>(2), B<fcntl>(2), B<fork>(2), "
"B<open>(2), B<lockf>(3), B<lslocks>(8)"

#. type: Plain text
#: build/C/man2/flock.2:255
msgid ""
"I<Documentation/filesystems/locks.txt> in the Linux kernel source tree "
"(I<Documentation/locks.txt> in older kernels)"
msgstr ""
"Linux カーネルソース内の I<Documentation/filesystems/locks.txt> (以前のカーネ"
"ルでは I<Documentation/locks.txt>)"

#. type: TH
#: build/C/man2/fork.2:39
#, no-wrap
msgid "FORK"
msgstr "FORK"

#. type: Plain text
#: build/C/man2/fork.2:42
msgid "fork - create a child process"
msgstr "fork - 子プロセスを生成する"

#. type: Plain text
#: build/C/man2/fork.2:44 build/C/man3/getumask.3:35 build/C/man2/truncate.2:50
#: build/C/man2/umask.2:39 build/C/man2/vfork.2:34
msgid "B<#include E<lt>sys/types.hE<gt>>"
msgstr "B<#include E<lt>sys/types.hE<gt>>"

#. type: Plain text
#: build/C/man2/fork.2:48
msgid "B<pid_t fork(void);>"
msgstr "B<pid_t fork(void);>"

#. type: Plain text
#: build/C/man2/fork.2:57
msgid ""
"B<fork>()  creates a new process by duplicating the calling process.  The "
"new process is referred to as the I<child> process.  The calling process is "
"referred to as the I<parent> process."
msgstr "B<fork>()  は呼び出し元プロセスを複製して新しいプロセスを生成する。新しいプロセスは「子」プロセスと呼ばれ、呼び出し元プロセスは「親」プロセスと呼ばれる。"

#. type: Plain text
#: build/C/man2/fork.2:67
msgid ""
"The child process and the parent process run in separate memory spaces.  At "
"the time of B<fork>()  both memory spaces have the same content.  Memory "
"writes, file mappings (B<mmap>(2)), and unmappings (B<munmap>(2))  performed "
"by one of the processes do not affect the other."
msgstr ""

#. type: Plain text
#: build/C/man2/fork.2:70
msgid ""
"The child process is an exact duplicate of the parent process except for the "
"following points:"
msgstr ""

#. type: Plain text
#: build/C/man2/fork.2:75
#, fuzzy
#| msgid ""
#| "The child has its own unique process ID, and this PID does not match the "
#| "ID of any existing process group (B<setpgid>(2))."
msgid ""
"The child has its own unique process ID, and this PID does not match the ID "
"of any existing process group (B<setpgid>(2))  or session."
msgstr ""
"子プロセスは独自のプロセス ID を持ち、 この PID は既存のどのプロセスグループ "
"(B<setpgid>(2))  の ID とも一致しない。"

#. type: Plain text
#: build/C/man2/fork.2:77
msgid "The child's parent process ID is the same as the parent's process ID."
msgstr "子プロセスの親プロセス ID は、親プロセスのプロセス ID と同じである。"

#. type: Plain text
#: build/C/man2/fork.2:81
msgid ""
"The child does not inherit its parent's memory locks (B<mlock>(2), "
"B<mlockall>(2))."
msgstr ""
"子プロセスは親プロセスのメモリーロック (B<mlock>(2), B<mlockall>(2))  を引き"
"継がない。"

#. type: Plain text
#: build/C/man2/fork.2:87
msgid ""
"Process resource utilizations (B<getrusage>(2))  and CPU time counters "
"(B<times>(2))  are reset to zero in the child."
msgstr ""
"プロセスの資源利用量 (B<getrusage>(2))  と CPU タイムカウンター "
"(B<times>(2))  が、子プロセスでは 0 にリセットされる。"

#. type: Plain text
#: build/C/man2/fork.2:90
msgid ""
"The child's set of pending signals is initially empty (B<sigpending>(2))."
msgstr ""
"子プロセスの処理待ちのシグナルの集合 (B<sigpending>(2))  は、初期状態では空に"
"なる。"

#. type: Plain text
#: build/C/man2/fork.2:93
msgid ""
"The child does not inherit semaphore adjustments from its parent "
"(B<semop>(2))."
msgstr "子プロセスは親プロセスからセマフォ調整 (B<semop>(2))  を引き継がない。"

#. type: Plain text
#: build/C/man2/fork.2:101
msgid ""
"The child does not inherit process-associated record locks from its parent "
"(B<fcntl>(2)).  (On the other hand, it does inherit B<fcntl>(2)  open file "
"description locks and B<flock>(2)  locks from its parent.)"
msgstr ""
"子プロセスは親プロセスからプロセスに関連付けられたレコードロックを引き継がな"
"い (B<fcntl>(2))。 (一方、子プロセスは親プロセスから B<fcntl>(2) オープンファ"
"イル記述ロックと B<flock>(2) ロックを引き継ぐ。)"

#. type: Plain text
#: build/C/man2/fork.2:106
msgid ""
"The child does not inherit timers from its parent (B<setitimer>(2), "
"B<alarm>(2), B<timer_create>(2))."
msgstr ""
"子プロセスは親プロセスからタイマー (B<setitimer>(2), B<alarm>(2), "
"B<timer_create>(2))  を引き継がない。"

#. type: Plain text
#: build/C/man2/fork.2:113
msgid ""
"The child does not inherit outstanding asynchronous I/O operations from its "
"parent (B<aio_read>(3), B<aio_write>(3)), nor does it inherit any "
"asynchronous I/O contexts from its parent (see B<io_setup>(2))."
msgstr ""
"子プロセスは親プロセスから主だった非同期 I/O 操作を引き継がない "
"(B<aio_read>(3), B<aio_write>(3)  参照)。 また、親プロセスから非同期 I/O コン"
"テキストを引き継がない (B<io_setup>(2)  参照)。"

#. type: Plain text
#: build/C/man2/fork.2:118
msgid ""
"The process attributes in the preceding list are all specified in POSIX.1.  "
"The parent and child also differ with respect to the following Linux-"
"specific process attributes:"
msgstr "上記のリストにあるプロセス属性は、POSIX.1 で全て指定されている。 親プロセスと子プロセスは、以下の Linux 固有のプロセス属性も異なる:"

#. type: Plain text
#: build/C/man2/fork.2:125
msgid ""
"The child does not inherit directory change notifications (dnotify)  from "
"its parent (see the description of B<F_NOTIFY> in B<fcntl>(2))."
msgstr ""
"子プロセスは親プロセスからディレクトリ変更通知 (dnotify)  (B<fcntl>(2)  にお"
"ける B<F_NOTIFY> の説明を参照) を引き継がない。"

#. type: Plain text
#: build/C/man2/fork.2:131
msgid ""
"The B<prctl>(2)  B<PR_SET_PDEATHSIG> setting is reset so that the child does "
"not receive a signal when its parent terminates."
msgstr ""
"B<prctl>(2)  の B<PR_SET_PDEATHSIG> の設定がリセットされ、子プロセスは親プロ"
"セスが終了したときに シグナルを受信しない。"

#. type: Plain text
#: build/C/man2/fork.2:138
msgid ""
"The default timer slack value is set to the parent's current timer slack "
"value.  See the description of B<PR_SET_TIMERSLACK> in B<prctl>(2)."
msgstr ""
"timer slack value のデフォルト値には、親プロセスの現在の timer slack value が"
"設定される。 B<prctl>(2) の B<PR_SET_TIMERSLACK> の説明を参照。"

#. type: Plain text
#: build/C/man2/fork.2:144
msgid ""
"Memory mappings that have been marked with the B<madvise>(2)  "
"B<MADV_DONTFORK> flag are not inherited across a B<fork>()."
msgstr ""
"B<madvise>(2)  の B<MADV_DONTFORK> フラグでマークされたメモリーマッピング"
"は、 B<fork>()  によって引き継がれない。"

#. type: Plain text
#: build/C/man2/fork.2:153
msgid ""
"Memory in address ranges that have been marked with the B<madvise>(2)  "
"B<MADV_WIPEONFORK> flag is zeroed in the child after a B<fork>().  (The "
"B<MADV_WIPEONFORK> setting remains in place for those address ranges in the "
"child.)"
msgstr ""

#. type: Plain text
#: build/C/man2/fork.2:158
msgid ""
"The termination signal of the child is always B<SIGCHLD> (see B<clone>(2))."
msgstr ""
"子プロセスの終了シグナルは常に B<SIGCHLD> である (B<clone>(2)  を参照)。"

#. type: Plain text
#: build/C/man2/fork.2:164
msgid ""
"The port access permission bits set by B<ioperm>(2)  are not inherited by "
"the child; the child must turn on any bits that it requires using "
"B<ioperm>(2)."
msgstr ""
"B<ioperm>(2) で設定されるポートアクセス許可ビットは、子プロセスには継承されな"
"い。子プロセスでは、 B<ioperm>(2) を使って必要なビットをセットしなければなら"
"ない。"

#. type: Plain text
#: build/C/man2/fork.2:175
msgid ""
"The child process is created with a single thread\\(emthe one that called "
"B<fork>().  The entire virtual address space of the parent is replicated in "
"the child, including the states of mutexes, condition variables, and other "
"pthreads objects; the use of B<pthread_atfork>(3)  may be helpful for "
"dealing with problems that this can cause."
msgstr ""
"子プロセスはシングルスレッドで生成される。つまり、 B<fork>()  を呼び出したス"
"レッドとなる。 親プロセスの仮想アドレス空間全体が子プロセスに複製される。 こ"
"れにはミューテックス (mutex) の状態・条件変数・ pthread オブジェクトが含まれ"
"る。 これが引き起こす問題を扱うには、 B<pthread_atfork>(3)  を使うと良いだろ"
"う。"

#. type: Plain text
#: build/C/man2/fork.2:183
msgid ""
"After a B<fork>()  in a multithreaded program, the child can safely call "
"only async-signal-safe functions (see B<signal-safety>(7))  until such time "
"as it calls B<execve>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/fork.2:197
msgid ""
"The child inherits copies of the parent's set of open file descriptors.  "
"Each file descriptor in the child refers to the same open file description "
"(see B<open>(2))  as the corresponding file descriptor in the parent.  This "
"means that the two file descriptors share open file status flags, file "
"offset, and signal-driven I/O attributes (see the description of B<F_SETOWN> "
"and B<F_SETSIG> in B<fcntl>(2))."
msgstr "子プロセスは親プロセスが持つ オープンファイルディスクリプターの集合のコピーを引き継ぐ。 子プロセスの各ファイルディスクリプターは、 親プロセスのファイルディスクリプターに対応する 同じオープンファイル記述 (file description) を参照する (B<open>(2)  を参照)。 これは 2 つのファイルディスクリプターが、ファイル状態フラグ・ ファイルオフセット、シグナル駆動 (signal-driven) I/O 属性 (B<fcntl>(2)  における B<F_SETOWN>, B<F_SETSIG> の説明を参照) を共有することを意味する。"

#. type: Plain text
#: build/C/man2/fork.2:206
msgid ""
"The child inherits copies of the parent's set of open message queue "
"descriptors (see B<mq_overview>(7)).  Each file descriptor in the child "
"refers to the same open message queue description as the corresponding file "
"descriptor in the parent.  This means that the two file descriptors share "
"the same flags (I<mq_flags>)."
msgstr "子プロセスは親プロセスが持つオープンメッセージキューディスクリプター (B<mq_overview>(7)  を参照) の集合のコピーを引き継ぐ。 子プロセスの各ファイルディスクリプターは、 親プロセスのファイルディスクリプターに対応する同じオープンメッセージキューディスクリプターを参照する。 これは 2 つのファイルディスクリプターが同じフラグ (I<mq_flags>)  を共有することを意味する。"

#. type: Plain text
#: build/C/man2/fork.2:214
msgid ""
"The child inherits copies of the parent's set of open directory streams (see "
"B<opendir>(3)).  POSIX.1 says that the corresponding directory streams in "
"the parent and child I<may> share the directory stream positioning; on Linux/"
"glibc they do not."
msgstr "子プロセスは、親プロセスのオープン済みのディレクトリストリームの集合 (B<opendir>(3)  参照) のコピーを継承する。 POSIX.1 では、親プロセスと子プロセス間の対応するディレクトリストリーム はディレクトリストリームの位置 (positioning) を共有してもよいとされている。 Linux/glibc ではディレクトリストリームの位置の共有は行われていない。"

#. type: Plain text
#: build/C/man2/fork.2:221
msgid ""
"On success, the PID of the child process is returned in the parent, and 0 is "
"returned in the child.  On failure, -1 is returned in the parent, no child "
"process is created, and I<errno> is set appropriately."
msgstr ""
"成功した場合、親プロセスには子プロセスの PID が返され、 子プロセスには 0 が返"
"される。 失敗した場合、親プロセスに -1 が返され、子プロセスは生成されず、 "
"I<errno> が適切に設定される。"

#.  NOTE! The following should match the description in pthread_create(3)
#. type: Plain text
#: build/C/man2/fork.2:227
msgid ""
"A system-imposed limit on the number of threads was encountered.  There are "
"a number of limits that may trigger this error:"
msgstr ""

#. type: Plain text
#: build/C/man2/fork.2:235
msgid ""
"the B<RLIMIT_NPROC> soft resource limit (set via B<setrlimit>(2)), which "
"limits the number of processes and threads for a real user ID, was reached;"
msgstr ""

#. type: Plain text
#: build/C/man2/fork.2:240
msgid ""
"the kernel's system-wide limit on the number of processes and threads, I</"
"proc/sys/kernel/threads-max>, was reached (see B<proc>(5));"
msgstr ""

#. type: Plain text
#: build/C/man2/fork.2:246
msgid ""
"the maximum number of PIDs, I</proc/sys/kernel/pid_max>, was reached (see "
"B<proc>(5)); or"
msgstr ""

#. type: Plain text
#: build/C/man2/fork.2:250
msgid ""
"the PID limit (I<pids.max>)  imposed by the cgroup \"process number\" (PIDs) "
"controller was reached."
msgstr ""

#. type: Plain text
#: build/C/man2/fork.2:258
msgid ""
"The caller is operating under the B<SCHED_DEADLINE> scheduling policy and "
"does not have the reset-on-fork flag set.  See B<sched>(7)."
msgstr ""
"呼び出し元は、スケジューリングポリシー B<SCHED_DEADLINE> で動作しており、か"
"つ reset-on-fork フラグがセットされていない。 B<sched>(7) 参照。"

#. type: Plain text
#: build/C/man2/fork.2:262
msgid ""
"B<fork>()  failed to allocate the necessary kernel structures because memory "
"is tight."
msgstr ""
"メモリーが足りないために、 B<fork>()  は必要なカーネル構造体を割り当てること"
"ができなかった。"

#. type: Plain text
#: build/C/man2/fork.2:268
msgid ""
"An attempt was made to create a child process in a PID namespace whose \"init"
"\" process has terminated.  See B<pid_namespaces>(7)."
msgstr ""

#.  e.g., arm (optionally), blackfin, c6x, frv, h8300, microblaze, xtensa
#. type: Plain text
#: build/C/man2/fork.2:274
msgid ""
"B<fork>()  is not supported on this platform (for example, hardware without "
"a Memory-Management Unit)."
msgstr ""
"B<fork>() はこのプラットフォームではサポートされていない\n"
"(例えば、メモリー管理ユニット (MMU) がないハードウェア)。"

#. type: TP
#: build/C/man2/fork.2:274
#, no-wrap
msgid "B<ERESTARTNOINTR> (since Linux 2.6.17)"
msgstr "B<ERESTARTNOINTR> (Linux 2.6.17 以降)"

#.  commit 4a2c7a7837da1b91468e50426066d988050e4d56
#. type: Plain text
#: build/C/man2/fork.2:279
msgid ""
"System call was interrupted by a signal and will be restarted.  (This can be "
"seen only during a trace.)"
msgstr ""

#. type: Plain text
#: build/C/man2/fork.2:287
msgid ""
"Under Linux, B<fork>()  is implemented using copy-on-write pages, so the "
"only penalty that it incurs is the time and memory required to duplicate the "
"parent's page tables, and to create a unique task structure for the child."
msgstr ""
"Linux では、 B<fork>()  を 書き込み時コピー (copy-on-write) ページを用いて実"
"装している。 したがって、fork を行うことの唯一のデメリットは、 親プロセスの"
"ページテーブルを複製と 子プロセス自身のタスク構造の作成のための時間とメモリー"
"が必要なことである。"

#.  nptl/sysdeps/unix/sysv/linux/fork.c
#.  and does some magic to ensure that getpid(2) returns the right value.
#. type: Plain text
#: build/C/man2/fork.2:311
msgid ""
"Since version 2.3.3, rather than invoking the kernel's B<fork>()  system "
"call, the glibc B<fork>()  wrapper that is provided as part of the NPTL "
"threading implementation invokes B<clone>(2)  with flags that provide the "
"same effect as the traditional system call.  (A call to B<fork>()  is "
"equivalent to a call to B<clone>(2)  specifying I<flags> as just "
"B<SIGCHLD>.)  The glibc wrapper invokes any fork handlers that have been "
"established using B<pthread_atfork>(3)."
msgstr ""
"glibc 2.3.3 以降では、 NPTL スレッド実装の一部として提供されている\n"
"glibc のB<fork>() ラッパー関数は、 カーネルの B<fork>() システムコール\n"
"を起動するのではなく、B<clone>(2) を起動する。\n"
"B<clone>(2) に渡すフラグとして、伝統的な B<fork>() システムコールと\n"
"同じ効果が得られるようなフラグが指定される (B<fork>() の呼び出しは、\n"
"I<flags> に B<SIGCHLD> だけを指定して B<clone>(2) を呼び出すのと等価であ"
"る)。\n"
"glibc のラッパー関数は B<pthread_atfork>(3) を使って設定されている\n"
"任意の fork ハンドラーを起動する。"

#. type: Plain text
#: build/C/man2/fork.2:316
msgid "See B<pipe>(2)  and B<wait>(2)."
msgstr "B<pipe>(2)  および B<wait>(2)  を参照。"

#. type: Plain text
#: build/C/man2/fork.2:328
msgid ""
"B<clone>(2), B<execve>(2), B<exit>(2), B<setrlimit>(2), B<unshare>(2), "
"B<vfork>(2), B<wait>(2), B<daemon>(3), B<pthread_atfork>(3), "
"B<capabilities>(7), B<credentials>(7)"
msgstr ""
" B<clone>(2), B<execve>(2), B<exit>(2), B<setrlimit>(2), B<unshare>(2), "
"B<vfork>(2), B<wait>(2), B<daemon>(3), B<pthread_atfork>(3), "
"B<capabilities>(7), B<credentials>(7)"

#. type: TH
#: build/C/man3/fpathconf.3:42
#, no-wrap
msgid "FPATHCONF"
msgstr "FPATHCONF"

#. type: TH
#: build/C/man3/fpathconf.3:42
#, no-wrap
msgid "2017-07-13"
msgstr " 2017-07-13"

#. type: Plain text
#: build/C/man3/fpathconf.3:45
msgid "fpathconf, pathconf - get configuration values for files"
msgstr "fpathconf, pathconf - ファイルの設定値を取得する"

#. type: Plain text
#: build/C/man3/fpathconf.3:51
#, no-wrap
msgid ""
"B<long fpathconf(int >I<fd>B<, int >I<name>B<);>\n"
"B<long pathconf(const char *>I<path>B<, int >I<name>B<);>\n"
msgstr ""
" B<long fpathconf(int >I<fd>B<, int >I<name>B<);>\n"
"B<long pathconf(const char *>I<path>B<, int >I<name>B<);>\n"

#. type: Plain text
#: build/C/man3/fpathconf.3:58
msgid ""
"B<fpathconf>()  gets a value for the configuration option I<name> for the "
"open file descriptor I<fd>."
msgstr ""
"B<fpathconf>()  はオープンされているファイルディスクリプター I<fd> に対して設"
"定されているオプション I<name> の値を取得する。"

#. type: Plain text
#: build/C/man3/fpathconf.3:64
msgid ""
"B<pathconf>()  gets a value for configuration option I<name> for the "
"filename I<path>."
msgstr ""
"B<pathconf>()  はファイル名 I<path> に対して設定されているオプション I<name> "
"の値を取得する。"

#. type: Plain text
#: build/C/man3/fpathconf.3:73
msgid ""
"The corresponding macros defined in I<E<lt>unistd.hE<gt>> are minimum "
"values; if an application wants to take advantage of values which may "
"change, a call to B<fpathconf>()  or B<pathconf>()  can be made, which may "
"yield more liberal results."
msgstr ""
"対応するマクロのうち I<E<lt>unistd.hE<gt>> で定義されているものは最小値であ"
"る。アプリケーションによってはこれらの 値を変更してより有利な動作を行おうとす"
"るものがある。この場合でも B<fpathconf>()  または B<pathconf>()  は呼び出すこ"
"とができる。この場合はより大きな値が返ることになろう。"

#. type: Plain text
#: build/C/man3/fpathconf.3:78
msgid ""
"Setting I<name> equal to one of the following constants returns the "
"following configuration options:"
msgstr ""
"I<name> を以下の定数のどれかにすると、対応する設定オプションが返される。"

#. type: TP
#: build/C/man3/fpathconf.3:78
#, no-wrap
msgid "B<_PC_LINK_MAX>"
msgstr "B<_PC_LINK_MAX>"

#. type: Plain text
#: build/C/man3/fpathconf.3:88
msgid ""
"The maximum number of links to the file.  If I<fd> or I<path> refer to a "
"directory, then the value applies to the whole directory.  The corresponding "
"macro is B<_POSIX_LINK_MAX>."
msgstr "ファイルへのリンクの最大数。 I<fd> または I<path> がディレクトリの場合は、この値はディレクトリ全体に適用される。対応する マクロは B<_POSIX_LINK_MAX> である。"

#. type: TP
#: build/C/man3/fpathconf.3:88
#, no-wrap
msgid "B<_PC_MAX_CANON>"
msgstr "B<_PC_MAX_CANON>"

#. type: Plain text
#: build/C/man3/fpathconf.3:97
msgid ""
"The maximum length of a formatted input line, where I<fd> or I<path> must "
"refer to a terminal.  The corresponding macro is B<_POSIX_MAX_CANON>."
msgstr "フォーマット付き入力行の最大長。このとき I<fd> または I<path> は端末を参照していなければならない。 対応するマクロは B<_POSIX_MAX_CANON> である。"

#. type: TP
#: build/C/man3/fpathconf.3:97
#, no-wrap
msgid "B<_PC_MAX_INPUT>"
msgstr "B<_PC_MAX_INPUT>"

#. type: Plain text
#: build/C/man3/fpathconf.3:106
msgid ""
"The maximum length of an input line, where I<fd> or I<path> must refer to a "
"terminal.  The corresponding macro is B<_POSIX_MAX_INPUT>."
msgstr "入力行の最大長。このとき I<fd> または I<path> は端末を参照していなければならない。 対応するマクロは B<_POSIX_MAX_INPUT> である。"

#. type: TP
#: build/C/man3/fpathconf.3:106
#, no-wrap
msgid "B<_PC_NAME_MAX>"
msgstr "B<_PC_NAME_MAX>"

#. type: Plain text
#: build/C/man3/fpathconf.3:115
msgid ""
"The maximum length of a filename in the directory I<path> or I<fd> that the "
"process is allowed to create.  The corresponding macro is B<_POSIX_NAME_MAX>."
msgstr "ディレクトリ I<path> または I<fd> 内に、そのプロセスが作成することができるファイル名の最大長。 対応するマクロは B<_POSIX_NAME_MAX> である。"

#. type: TP
#: build/C/man3/fpathconf.3:115
#, no-wrap
msgid "B<_PC_PATH_MAX>"
msgstr "B<_PC_PATH_MAX>"

#. type: Plain text
#: build/C/man3/fpathconf.3:124
msgid ""
"The maximum length of a relative pathname when I<path> or I<fd> is the "
"current working directory.  The corresponding macro is B<_POSIX_PATH_MAX>."
msgstr "I<path> または I<fd> がカレントディレクトリの場合、相対パス名の最大長。 対応するマクロは B<_POSIX_PATH_MAX> である。"

#. type: TP
#: build/C/man3/fpathconf.3:124
#, no-wrap
msgid "B<_PC_PIPE_BUF>"
msgstr "B<_PC_PIPE_BUF>"

#. type: Plain text
#: build/C/man3/fpathconf.3:138
msgid ""
"The maximum number of bytes that can be written atomically to a pipe of "
"FIFO.  For B<fpathconf>(), I<fd> should refer to a pipe or FIFO.  For "
"B<fpathconf>(), I<path> should refer to a FIFO or a directory; in the latter "
"case, the returned value corresponds to FIFOs created in that directory.  "
"The corresponding macro is B<_POSIX_PIPE_BUF>."
msgstr ""

#. type: TP
#: build/C/man3/fpathconf.3:138
#, no-wrap
msgid "B<_PC_CHOWN_RESTRICTED>"
msgstr "B<_PC_CHOWN_RESTRICTED>"

#. type: Plain text
#: build/C/man3/fpathconf.3:153
msgid ""
"This returns a positive value if the use of B<chown>(2)  and B<fchown>(2)  "
"for changing a file's user ID is restricted to a process with appropriate "
"privileges, and changing a file's group ID to a value other than the "
"process's effective group ID or one of its supplementary group IDs is "
"restricted to a process with appropriate privileges.  According to POSIX.1, "
"this variable shall always be defined with a value other than -1.  The "
"corresponding macro is B<_POSIX_CHOWN_RESTRICTED>."
msgstr ""

#. type: Plain text
#: build/C/man3/fpathconf.3:160
msgid ""
"If I<fd> or I<path> refers to a directory, then the return value applies to "
"all files in that directory."
msgstr ""

#. type: TP
#: build/C/man3/fpathconf.3:160
#, no-wrap
msgid "B<_PC_NO_TRUNC>"
msgstr "B<_PC_NO_TRUNC>"

#. type: Plain text
#: build/C/man3/fpathconf.3:167
msgid ""
"This returns nonzero if accessing filenames longer than B<_POSIX_NAME_MAX> "
"generates an error.  The corresponding macro is B<_POSIX_NO_TRUNC>."
msgstr ""
"アクセス中のファイル名が B<_POSIX_NAME_MAX> よりも長く、エラーとなる場合には "
"0 以外の値を返す。 対応するマクロは B<_POSIX_NAME_MAX> である。"

#. type: TP
#: build/C/man3/fpathconf.3:167
#, no-wrap
msgid "B<_PC_VDISABLE>"
msgstr "B<_PC_VDISABLE>"

#. type: Plain text
#: build/C/man3/fpathconf.3:174
msgid ""
"This returns nonzero if special character processing can be disabled, where "
"I<fd> or I<path> must refer to a terminal."
msgstr ""
"特殊文字 (special character) の処理が許されていない場合は 0 以外の値を 返す。"
"このとき I<fd> または I<path> は端末を参照していなければならない。"

#. type: Plain text
#: build/C/man3/fpathconf.3:176
msgid "The return value of these functions is one of the following:"
msgstr ""

#. type: Plain text
#: build/C/man3/fpathconf.3:185 build/C/man3/sysconf.3:339
msgid ""
"On error, -1 is returned and I<errno> is set to indicate the cause of the "
"error (for example, B<EINVAL>, indicating that I<name> is invalid)."
msgstr ""

#. type: Plain text
#: build/C/man3/fpathconf.3:197 build/C/man3/sysconf.3:351
msgid ""
"If I<name> corresponds to a maximum or minimum limit, and that limit is "
"indeterminate, -1 is returned and I<errno> is not changed.  (To distinguish "
"an indeterminate limit from an error, set I<errno> to zero before the call, "
"and then check whether I<errno> is nonzero when -1 is returned.)"
msgstr ""

#. type: Plain text
#: build/C/man3/fpathconf.3:203 build/C/man3/sysconf.3:357
msgid ""
"If I<name> corresponds to an option, a positive value is returned if the "
"option is supported, and -1 is returned if the option is not supported."
msgstr ""

#. type: Plain text
#: build/C/man3/fpathconf.3:212 build/C/man3/sysconf.3:366
msgid ""
"Otherwise, the current value of the option or limit is returned.  This value "
"will not be more restrictive than the corresponding value that was described "
"to the application in I<E<lt>unistd.hE<gt>> or I<E<lt>limits.hE<gt>> when "
"the application was compiled."
msgstr ""

#. type: Plain text
#: build/C/man3/fpathconf.3:218
#, fuzzy
#| msgid ""
#| "The requested access would be denied to the file, or search permission is "
#| "denied for one of the directories in the path prefix of I<pathname>.  "
#| "(See also B<path_resolution>(7).)"
msgid ""
"(B<pathconf>())  Search permission is denied for one of the directories in "
"the path prefix of I<path>."
msgstr ""
"要求されたアクセスは そのファイル自身に拒否されたか I<pathname> へ至るまで"
"ディレクトリのいずれかに対する検索許可 (search permission) が得られなかっ"
"た。 (B<path_resolution>(7)  も参照のこと)"

#. type: Plain text
#: build/C/man3/fpathconf.3:223
msgid "(B<fpathconf>())  I<fd> is not a valid file descriptor."
msgstr "(B<fpathconf>()) I<fd> が適切なファイルディスクリプターでない。"

#. type: Plain text
#: build/C/man3/fpathconf.3:227 build/C/man3/sysconf.3:371
msgid "I<name> is invalid."
msgstr "I<name> が無効である。"

#. type: Plain text
#: build/C/man3/fpathconf.3:232
msgid ""
"The implementation does not support an association of I<name> with the "
"specified file."
msgstr ""

#. type: Plain text
#: build/C/man3/fpathconf.3:237
msgid ""
"(B<pathconf>())  Too many symbolic links were encountered while resolving "
"I<path>."
msgstr "(B<pathconf>()) I<path> を解決する際に遭遇したシンボリックリンクが多過ぎる。"

#. type: Plain text
#: build/C/man3/fpathconf.3:242
msgid "(B<pathconf>())  I<path> is too long."
msgstr "(B<pathconf>()) I<path> が長過ぎる。"

#. type: Plain text
#: build/C/man3/fpathconf.3:250
#, fuzzy
#| msgid ""
#| "A component of I<pathname> does not exist or is a dangling symbolic link."
msgid ""
"(B<pathconf>())  A component of I<path> does not exist, or I<path> is an "
"empty string."
msgstr ""
"I<pathname> を構成するパスのいずれかが、存在しないか、 参照先のない "
"(dangling) シンボリックリンクになっている。"

#. type: Plain text
#: build/C/man3/fpathconf.3:256
msgid ""
"(B<pathconf>())  A component used as a directory in I<path> is not in fact a "
"directory."
msgstr "(B<pathconf>()) I<path> のディレクトリ部分が実際にはディレクトリでない。"

#. type: tbl table
#: build/C/man3/fpathconf.3:267
#, no-wrap
msgid ""
"B<fpathconf>(),\n"
"B<pathconf>()"
msgstr ""
" B<fpathconf>(),\n"
"B<pathconf>()"

#. type: Plain text
#: build/C/man3/fpathconf.3:277
msgid ""
"Files with name lengths longer than the value returned for I<name> equal to "
"B<_PC_NAME_MAX> may exist in the given directory."
msgstr ""
"I<name> に B<_PC_NAME_MAX> を入れて返された値よりも長いファイル名を持つファイ"
"ルが、与えられたディ レクトリに存在するかもしれない。"

#. type: Plain text
#: build/C/man3/fpathconf.3:280 build/C/man3/sysconf.3:394
msgid ""
"Some returned values may be huge; they are not suitable for allocating "
"memory."
msgstr ""
"いくつかの返り値はとても大きくなることがある。これらを使って メモリーの割り当"
"てを行うのは適当ではない。"

#. type: Plain text
#: build/C/man3/fpathconf.3:286
msgid "B<getconf>(1), B<open>(2), B<statfs>(2), B<confstr>(3), B<sysconf>(3)"
msgstr "B<getconf>(1), B<open>(2), B<statfs>(2), B<confstr>(3), B<sysconf>(3)"

#. type: TH
#: build/C/man2/fsync.2:38
#, no-wrap
msgid "FSYNC"
msgstr "FSYNC"

#. type: Plain text
#: build/C/man2/fsync.2:41
msgid ""
"fsync, fdatasync - synchronize a file's in-core state with storage device"
msgstr ""
"fsync - メモリー上にあるファイルの内容をストレージデバイス上のものと同期させ"
"る"

#. type: Plain text
#: build/C/man2/fsync.2:45
msgid "B<int fsync(int >I<fd>B<);>"
msgstr "B<int fsync(int >I<fd>B<);>"

#. type: Plain text
#: build/C/man2/fsync.2:47
msgid "B<int fdatasync(int >I<fd>B<);>"
msgstr "B<int fdatasync(int >I<fd>B<);>"

#. type: Plain text
#: build/C/man2/fsync.2:59
#, no-wrap
msgid ""
"B<fsync>():\n"
"    Glibc 2.16 and later:\n"
"        No feature test macros need be defined\n"
"    Glibc up to and including 2.15:\n"
"        _BSD_SOURCE || _XOPEN_SOURCE\n"
"            || /* since glibc 2.8: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200112L\n"
msgstr ""
"B<fsync>():\n"
"    2.16 以降:\n"
"        No feature test macros need be defined\n"
"    glibc 2.15 以前:\n"
"        _BSD_SOURCE || _XOPEN_SOURCE\n"
"            || /* since glibc 2.8: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200112L\n"

#. type: Plain text
#: build/C/man2/fsync.2:62
#, no-wrap
msgid ""
"B<fdatasync>():\n"
"    _POSIX_C_SOURCE\\ E<gt>=\\ 199309L || _XOPEN_SOURCE\\ E<gt>=\\ 500\n"
msgstr ""
" B<fdatasync>():\n"
"    _POSIX_C_SOURCE\\ E<gt>=\\ 199309L || _XOPEN_SOURCE\\ E<gt>=\\ 500\n"

#. type: Plain text
#: build/C/man2/fsync.2:73
#, fuzzy
#| msgid ""
#| "B<fsync>()  transfers (\"flushes\") all modified in-core data of (i.e., "
#| "modified buffer cache pages for) the file referred to by the file "
#| "descriptor I<fd> to the disk device (or other permanent storage device) "
#| "so that all changed information can be retrieved even after the system "
#| "crashed or was rebooted.  This includes writing through or flushing a "
#| "disk cache if present.  The call blocks until the device reports that the "
#| "transfer has completed.  It also flushes metadata information associated "
#| "with the file (see B<stat>(2))."
msgid ""
"B<fsync>()  transfers (\"flushes\") all modified in-core data of (i.e., "
"modified buffer cache pages for) the file referred to by the file descriptor "
"I<fd> to the disk device (or other permanent storage device) so that all "
"changed information can be retrieved even if the system crashes or is "
"rebooted.  This includes writing through or flushing a disk cache if "
"present.  The call blocks until the device reports that the transfer has "
"completed."
msgstr ""
"B<fsync>() は、ファイルディスクリプター I<fd> で参照されるファイルの、メモ"
"リー内で存在す\n"
"る修正されたデータ (つまり修正されたバッファーキャッシュページ) を、ディスク"
"デ\n"
"バイス(またはその他の永続ストレージデバイス) に転送 (「フラッシュ」) し、こ"
"れ\n"
"により、システムがクラッシュしたり、再起動された後も、変更された全ての情報"
"が\n"
"取り出せるようになる。「フラッシュ」には、ライトスルー (write through) や\n"
"(存在する場合には) ディスクキャッシュのフラッシュも含まれる。この呼び出しは\n"
"転送が終わったとデバイスが報告するまでブロックする。またファイルに結びつい"
"た\n"
"メタデータ情報 (B<stat>(2) 参照) もフラッシュする。"

#. type: Plain text
#: build/C/man2/fsync.2:78
msgid ""
"As well as flushing the file data, B<fsync>()  also flushes the metadata "
"information associated with the file (see B<inode>(7))."
msgstr ""

#. type: Plain text
#: build/C/man2/fsync.2:86
msgid ""
"Calling B<fsync>()  does not necessarily ensure that the entry in the "
"directory containing the file has also reached disk.  For that an explicit "
"B<fsync>()  on a file descriptor for the directory is also needed."
msgstr ""
"B<fsync>()  の呼び出しは、ファイルが存在しているディレクトリのエントリーが"
"ディスクへ 書き込まれたことを保証するわけではない。 保証するためには明示的に"
"そのディレクトリのファイルディスクリプターに対しても B<fsync>()  する必要があ"
"る。"

#. type: Plain text
#: build/C/man2/fsync.2:107
msgid ""
"B<fdatasync>()  is similar to B<fsync>(), but does not flush modified "
"metadata unless that metadata is needed in order to allow a subsequent data "
"retrieval to be correctly handled.  For example, changes to I<st_atime> or "
"I<st_mtime> (respectively, time of last access and time of last "
"modification; see B<inode>(7))  do not require flushing because they are not "
"necessary for a subsequent data read to be handled correctly.  On the other "
"hand, a change to the file size (I<st_size>, as made by say "
"B<ftruncate>(2)), would require a metadata flush."
msgstr "B<fdatasync>()  は B<fsync>()  と同様であるが、メタデータの扱いが異なる。 B<fdatasync>()  は、それ以降のデータ読み込みを正しく扱うためにそのメタデータが必要に ならない限り、変更されたメタデータをフラッシュしない。 例えば、 st_atime や st_mtime (それぞれ最終アクセス時刻、最終修正時刻; B<inode>(7) 参照) の変更はフラッシュを必要としない。 なぜならこれらはそれ以降のデータ読み込みを正しく扱うために 必要ではないからである。 一方、ファイルサイズ (B<ftruncate>(2)  では I<st_size>)  の変更はメタデータのフラッシュが必要である。"

#. type: Plain text
#: build/C/man2/fsync.2:112
msgid ""
"The aim of B<fdatasync>()  is to reduce disk activity for applications that "
"do not require all metadata to be synchronized with the disk."
msgstr ""
"B<fdatasync>()  の狙いは、全てのメタデータをディスクと同期する必要のない アプ"
"リケーションに対して、ディスクアクセスを減らすことである。"

#. type: Plain text
#: build/C/man2/fsync.2:117
msgid ""
"On success, these system calls return zero.  On error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""
"成功した場合、これらのシステムコールはゼロを返す。 エラーの場合、-1 が返さ"
"れ、 I<errno> が適切に設定される。"

#.  commit 088737f44bbf6378745f5b57b035e57ee3dc4750
#. type: Plain text
#: build/C/man2/fsync.2:136
msgid ""
"An error occurred during synchronization.  This error may relate to data "
"written to some other file descriptor on the same file.  Since Linux 4.13, "
"errors from write-back will be reported to all file descriptors that might "
"have written the data which triggered the error.  Some filesystems (e.g., "
"NFS) keep close track of which data came through which file descriptor, and "
"give more precise reporting.  Other filesystems (e.g., most local "
"filesystems) will report errors to all file descriptors that were open on "
"the file when the error was recorded."
msgstr ""

#. type: TP
#: build/C/man2/fsync.2:136 build/C/man2/mkdir.2:173 build/C/man2/mkdir.2:178
#, no-wrap
msgid "B<ENOSPC>"
msgstr "B<ENOSPC>"

#. type: Plain text
#: build/C/man2/fsync.2:139
msgid "Disk space was exhausted while synchronizing."
msgstr ""

#. type: TP
#: build/C/man2/fsync.2:139
#, no-wrap
msgid "B<EROFS>, B<EINVAL>"
msgstr "B<EROFS>, B<EINVAL>"

#. type: Plain text
#: build/C/man2/fsync.2:144
msgid ""
"I<fd> is bound to a special file (e.g., a pipe, FIFO, or socket)  which does "
"not support synchronization."
msgstr "I<fd> が同期操作をサポートしてない特殊なファイル (パイプ、FIFO、ソケットなど) を参照している。"

#. type: Plain text
#: build/C/man2/fsync.2:152
msgid ""
"I<fd> is bound to a file on NFS or another filesystem which does not "
"allocate space at the time of a B<write>(2)  system call, and some previous "
"write failed due to insufficient storage space."
msgstr ""

#. type: Plain text
#: build/C/man2/fsync.2:154
msgid "POSIX.1-2001, POSIX.1-2008, 4.3BSD."
msgstr " POSIX.1-2001, POSIX.1-2008, 4.3BSD."

#.  POSIX.1-2001: It shall be defined to -1 or 0 or 200112L.
#.  -1: unavailable, 0: ask using sysconf().
#.  glibc defines them to 1.
#. type: Plain text
#: build/C/man2/fsync.2:167
msgid ""
"On POSIX systems on which B<fdatasync>()  is available, "
"B<_POSIX_SYNCHRONIZED_IO> is defined in I<E<lt>unistd.hE<gt>> to a value "
"greater than 0.  (See also B<sysconf>(3).)"
msgstr ""
"B<fdatasync>()  が利用可能な POSIX システムでは、 B<_POSIX_SYNCHRONIZED_IO> "
"が I<E<lt>unistd.hE<gt>> で 0 より大きな値に定義される (B<sysconf>(3)  参"
"照)。"

#. type: Plain text
#: build/C/man2/fsync.2:173
msgid ""
"On some UNIX systems (but not Linux), I<fd> must be a I<writable> file "
"descriptor."
msgstr ""
"(Linux はそうではないが) いくつかの UNIX システムでは\n"
"I<fd> がI<書き込み可能な>ファイルディスクリプターでなければならない。"

#. type: Plain text
#: build/C/man2/fsync.2:179
msgid ""
"In Linux 2.2 and earlier, B<fdatasync>()  is equivalent to B<fsync>(), and "
"so has no performance advantage."
msgstr ""
"Linux 2.2 以前では、 B<fdatasync>()  は B<fsync>()  と等価であり、性能面での"
"メリットはない。"

#. type: Plain text
#: build/C/man2/fsync.2:189
msgid ""
"The B<fsync>()  implementations in older kernels and lesser used filesystems "
"do not know how to flush disk caches.  In these cases disk caches need to be "
"disabled using B<hdparm>(8)  or B<sdparm>(8)  to guarantee safe operation."
msgstr "古いカーネルやあまり使われていないファイルシステムの B<fsync>() の実装では、ディスクキャッシュをフラッシュする方法が分からない場合がある。そのような場合には、安全に操作が行われることを保証するため、B<hdparm>(8) や B<sdparm>(8) を使ってディスクキャッシュを無効にする必要がある。"

#. type: Plain text
#: build/C/man2/fsync.2:201
msgid ""
"B<sync>(1), B<bdflush>(2), B<open>(2), B<posix_fadvise>(2), B<pwritev>(2), "
"B<sync>(2), B<sync_file_range>(2), B<fflush>(3), B<fileno>(3), B<hdparm>(8), "
"B<mount>(8)"
msgstr ""
" B<sync>(1), B<bdflush>(2), B<open>(2), B<posix_fadvise>(2), B<pwritev>(2), "
"B<sync>(2), B<sync_file_range>(2), B<fflush>(3), B<fileno>(3), B<hdparm>(8), "
"B<mount>(8)"

#. type: TH
#: build/C/man3/get_nprocs_conf.3:26
#, no-wrap
msgid "GET_NPROCS"
msgstr "GET_NPROCS"

#. type: Plain text
#: build/C/man3/get_nprocs_conf.3:29
msgid "get_nprocs, get_nprocs_conf - get number of processors"
msgstr "get_nprocs, get_nprocs_conf - プロセッサ数を取得する"

#. type: Plain text
#: build/C/man3/get_nprocs_conf.3:31 build/C/man2/sysinfo.2:40
msgid "B<#include E<lt>sys/sysinfo.hE<gt>>"
msgstr "B<#include E<lt>sys/sysinfo.hE<gt>>"

#. type: Plain text
#: build/C/man3/get_nprocs_conf.3:33
msgid "B<int get_nprocs(void);>"
msgstr "B<int get_nprocs(void);>"

#. type: Plain text
#: build/C/man3/get_nprocs_conf.3:35
msgid "B<int get_nprocs_conf(void);>"
msgstr "B<int get_nprocs_conf(void);>"

#. type: Plain text
#: build/C/man3/get_nprocs_conf.3:39
msgid ""
"The function B<get_nprocs_conf>()  returns the number of processors "
"configured by the operating system."
msgstr ""
"B<get_nprocs_conf>() 関数は、オペレーティングシステムで\n"
"設定されているプロセッサ数を返す。"

#. type: Plain text
#: build/C/man3/get_nprocs_conf.3:46
msgid ""
"The function B<get_nprocs>()  returns the number of processors currently "
"available in the system.  This may be less than the number returned by "
"B<get_nprocs_conf>()  because processors may be offline (e.g., on "
"hotpluggable systems)."
msgstr ""
"B<get_nprocs>() 関数は、システムで現在利用可能なプロセッサ数を返す。\n"
"(例えば、ホットプラグが可能なシステムでは)\n"
"オフラインになっているプロセッサがある場合があるので、\n"
"この数は B<get_nprocs_conf>() が返す数より小さい場合がある。"

#. type: Plain text
#: build/C/man3/get_nprocs_conf.3:48
msgid "As given in DESCRIPTION."
msgstr "「説明」の節で説明した通りである。"

#. type: tbl table
#: build/C/man3/get_nprocs_conf.3:58
#, no-wrap
msgid "B<get_nprocs>(),\n"
msgstr " B<get_nprocs>(),\n"

#. type: tbl table
#: build/C/man3/get_nprocs_conf.3:58 build/C/man3/getlogin.3:159
#: build/C/man3/getlogin.3:166 build/C/man3/getusershell.3:108
#: build/C/man2/syscalls.2:186 build/C/man2/syscalls.2:194
#: build/C/man2/syscalls.2:204 build/C/man2/syscalls.2:252
#: build/C/man2/syscalls.2:307 build/C/man2/syscalls.2:317
#: build/C/man2/syscalls.2:319 build/C/man2/syscalls.2:325
#: build/C/man2/syscalls.2:327 build/C/man2/syscalls.2:341
#: build/C/man2/syscalls.2:404 build/C/man2/syscalls.2:470
#: build/C/man2/syscalls.2:472 build/C/man2/syscalls.2:481
#: build/C/man2/syscalls.2:501 build/C/man2/syscalls.2:522
#: build/C/man2/syscalls.2:536 build/C/man2/syscalls.2:582
#: build/C/man2/syscalls.2:594 build/C/man2/syscalls.2:620
#: build/C/man2/syscalls.2:649 build/C/man2/syscalls.2:718
#: build/C/man2/syscalls.2:772
#, no-wrap
msgid ".br\n"
msgstr ".br\n"

#. type: tbl table
#: build/C/man3/get_nprocs_conf.3:60
#, no-wrap
msgid "B<get_nprocs_conf>()"
msgstr " B<get_nprocs_conf>()"

#. type: Plain text
#: build/C/man3/get_nprocs_conf.3:65 build/C/man3/getopt.3:378
#: build/C/man3/get_phys_pages.3:60
msgid "These functions are GNU extensions."
msgstr "これらの関数は GNU による拡張である。"

#.  glibc 2.15
#. type: Plain text
#: build/C/man3/get_nprocs_conf.3:72
msgid ""
"The current implementation of these functions is rather expensive, since "
"they open and parse files in the I</sys> filesystem each time they are "
"called."
msgstr ""
"これらの関数の現在の実装はかなりコストがかかる実装になっている。\n"
"関数が呼ばれる度に I</sys> ファイルシステム内のファイルをオープンして\n"
"解析するようになっているからである。"

#. type: Plain text
#: build/C/man3/get_nprocs_conf.3:77
msgid ""
"The following B<sysconf>(3)  calls make use of the functions documented on "
"this page to return the same information."
msgstr ""
"以下の B<sysconf>(3) の呼び出しで、このページに書かれている関数を使った\n"
"場合に返されるのと同じ情報を得ることができる。"

#. type: Plain text
#: build/C/man3/get_nprocs_conf.3:82
#, no-wrap
msgid ""
"np = sysconf(_SC_NPROCESSORS_CONF);     /* processors configured */\n"
"np = sysconf(_SC_NPROCESSORS_ONLN);     /* processors available */\n"
msgstr ""
" np = sysconf(_SC_NPROCESSORS_CONF);     /* processors configured */\n"
"np = sysconf(_SC_NPROCESSORS_ONLN);     /* processors available */\n"

#. type: Plain text
#: build/C/man3/get_nprocs_conf.3:90
msgid ""
"The following example shows how B<get_nprocs>()  and B<get_nprocs_conf>()  "
"can be used."
msgstr ""
"以下の例は、 B<get_nprocs>() と B<get_nprocs_conf>() が\n"
"どのように利用できるかを示すものである。"

#. type: Plain text
#: build/C/man3/get_nprocs_conf.3:95
#, no-wrap
msgid ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>sys/sysinfo.hE<gt>\n"
msgstr ""
" #include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>sys/sysinfo.hE<gt>\n"

#. type: Plain text
#: build/C/man3/get_nprocs_conf.3:104
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    printf(\"This system has %d processors configured and \"\n"
"            \"%d processors available.\\en\",\n"
"            get_nprocs_conf(), get_nprocs());\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
" int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    printf(\"This system has %d processors configured and \"\n"
"            \"%d processors available.\\en\",\n"
"            get_nprocs_conf(), get_nprocs());\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man3/get_nprocs_conf.3:107
msgid "B<nproc>(1)"
msgstr " B<nproc>(1)"

#. type: TH
#: build/C/man3/getcwd.3:32
#, no-wrap
msgid "GETCWD"
msgstr "GETCWD"

#. type: Plain text
#: build/C/man3/getcwd.3:35
msgid "getcwd, getwd, get_current_dir_name - get current working directory"
msgstr ""
"getcwd, getwd, get_current_dir_name - カレントワーキングディレクトリ名の取得"

#. type: Plain text
#: build/C/man3/getcwd.3:40
#, no-wrap
msgid "B<char *getcwd(char *>I<buf>B<, size_t >I<size>B<);>\n"
msgstr "B<char *getcwd(char *>I<buf>B<, size_t >I<size>B<);>\n"

#. type: Plain text
#: build/C/man3/getcwd.3:42
#, no-wrap
msgid "B<char *getwd(char *>I<buf>B<);>\n"
msgstr "B<char *getwd(char *>I<buf>B<);>\n"

#. type: Plain text
#: build/C/man3/getcwd.3:44
#, no-wrap
msgid "B<char *get_current_dir_name(void);>\n"
msgstr "B<char *get_current_dir_name(void);>\n"

#. type: Plain text
#: build/C/man3/getcwd.3:52
msgid "B<get_current_dir_name>():"
msgstr "B<get_current_dir_name>():"

#. type: Plain text
#: build/C/man3/getcwd.3:57
msgid "B<getwd>():"
msgstr "B<getwd>():"

#. type: TP
#: build/C/man3/getcwd.3:60 build/C/man3/getdtablesize.3:44
#: build/C/man3/ualarm.3:43 build/C/man3/usleep.3:52 build/C/man2/vfork.2:48
#, no-wrap
msgid "Since glibc 2.12:"
msgstr "glibc 2.12 以降:"

#. type: Plain text
#: build/C/man3/getcwd.3:66 build/C/man3/ualarm.3:49 build/C/man3/usleep.3:58
#, no-wrap
msgid ""
"(_XOPEN_SOURCE\\ E<gt>=\\ 500) && ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200809L)\n"
"    || /* Glibc since 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE\n"
msgstr ""
"(_XOPEN_SOURCE\\ E<gt>=\\ 500) && ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200809L)\n"
"    || /* Glibc 2.19 以降: */ _DEFAULT_SOURCE\n"
"    || /* Glibc 2.19 以前: */ _BSD_SOURCE\n"

#.      || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: build/C/man3/getcwd.3:71 build/C/man3/getdtablesize.3:55
#: build/C/man3/gethostid.3:49 build/C/man2/getpagesize.2:56
#: build/C/man3/ualarm.3:54 build/C/man3/usleep.3:63 build/C/man2/vfork.2:59
msgid "_BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500"
msgstr " _BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500"

#. type: Plain text
#: build/C/man3/getcwd.3:81
msgid ""
"These functions return a null-terminated string containing an absolute "
"pathname that is the current working directory of the calling process.  The "
"pathname is returned as the function result and via the argument I<buf>, if "
"present."
msgstr ""
"これらの関数は、呼び出したプロセスのカレントワーキングディレクトリの 絶対パス"
"名 (absolute pathname) が入った文字列を返す。 返される文字列はヌルで終端され"
"る。 パス名は関数の結果として返され、引数 I<buf> がある場合は I<buf> 経由でも"
"返される。"

#. type: Plain text
#: build/C/man3/getcwd.3:89
msgid ""
"The B<getcwd>()  function copies an absolute pathname of the current working "
"directory to the array pointed to by I<buf>, which is of length I<size>."
msgstr ""
"B<getcwd>()  関数はカレントワーキングディレクトリの絶対パス名を I<buf> で示さ"
"れた I<size> 長の配列にコピーする。"

#. type: Plain text
#: build/C/man3/getcwd.3:99
msgid ""
"If the length of the absolute pathname of the current working directory, "
"including the terminating null byte, exceeds I<size> bytes, NULL is "
"returned, and I<errno> is set to B<ERANGE>; an application should check for "
"this error, and allocate a larger buffer if necessary."
msgstr ""
"終端のヌルバイトも含めた、カレントワーキングディレクトリの 絶対パス名の長さ"
"が I<size> バイトを超えている場合は、返り値として NULL が返り I<errno> に "
"B<ERANGE> がセットされる。 アプリケーションはこのエラーをチェックし、 必要に"
"応じてより長いバッファーを用意すべきである。"

#. type: Plain text
#: build/C/man3/getcwd.3:117
msgid ""
"As an extension to the POSIX.1-2001 standard, glibc's B<getcwd>()  allocates "
"the buffer dynamically using B<malloc>(3)  if I<buf> is NULL.  In this case, "
"the allocated buffer has the length I<size> unless I<size> is zero, when "
"I<buf> is allocated as big as necessary.  The caller should B<free>(3)  the "
"returned buffer."
msgstr ""
"POSIX.1-2001 標準の拡張として、 glibc では I<buf> が NULL の場合、 "
"B<getcwd>()  は必要なバッファーを B<malloc>(3)  を用いて動的に割り当てる。 こ"
"の場合、 I<size> が 0 の場合を除き、バッファーの長さは I<size> となる。 "
"I<size> が 0 の場合には必要な大きさが確保される。 呼び出し側で、返されたバッ"
"ファーを B<free>(3)  すべきである。"

#. type: Plain text
#: build/C/man3/getcwd.3:130
msgid ""
"B<get_current_dir_name>()  will B<malloc>(3)  an array big enough to hold "
"the absolute pathname of the current working directory.  If the environment "
"variable B<PWD> is set, and its value is correct, then that value will be "
"returned.  The caller should B<free>(3)  the returned buffer."
msgstr ""
"B<get_current_dir_name>()  はカレントワーキングディレクトリの絶対パス名を収め"
"るのに 十分な大きさの配列を B<malloc>(3)  で獲得する。環境変数 B<PWD> が設定"
"されておりその値が正しければ、その値が返される。 呼び出し側で、返されたバッ"
"ファーを B<free>(3)  すべきである。"

#. type: Plain text
#: build/C/man3/getcwd.3:155
msgid ""
"B<getwd>()  does not B<malloc>(3)  any memory.  The I<buf> argument should "
"be a pointer to an array at least B<PATH_MAX> bytes long.  If the length of "
"the absolute pathname of the current working directory, including the "
"terminating null byte, exceeds B<PATH_MAX> bytes, NULL is returned, and "
"I<errno> is set to B<ENAMETOOLONG>.  (Note that on some systems, B<PATH_MAX> "
"may not be a compile-time constant; furthermore, its value may depend on the "
"filesystem, see B<pathconf>(3).)  For portability and security reasons, use "
"of B<getwd>()  is deprecated."
msgstr ""
"B<getwd>()  は B<malloc>(3)  によるメモリー獲得を一切行なわない。 I<buf> 引数"
"は少なくとも B<PATH_MAX> バイトの長さを持つ配列へのポインターである必要があ"
"る。 終端のヌルバイトも含めた、カレントワーキングディレクトリの 絶対パス名の"
"長さが B<PATH_MAX> バイトを超えている場合、 NULL が返され、 I<errno> に "
"B<ENAMETOOLONG> が設定される。 (システムによっては、 B<PATH_MAX> は必ずしもコ"
"ンパイル時に決まる定数ではない点に注意すること。 また、ファイルシステムに依存"
"する場合もある。 B<pathconf>(3)  を参照。)  移植性とセキュリティ上の理由か"
"ら、 B<getwd>()  の利用は推奨されない。"

#. type: Plain text
#: build/C/man3/getcwd.3:164
msgid ""
"On success, these functions return a pointer to a string containing the "
"pathname of the current working directory.  In the case of B<getcwd>()  and "
"B<getwd>()  this is the same value as I<buf>."
msgstr ""
"成功すると、これらの関数はカレントワーキングディレクトリの絶対パス名 が入った"
"文字列へのポインターを返す。 B<getcwd>()  と B<getwd>()  の場合、返り値は "
"I<buf> と同じ値になる。"

#. type: Plain text
#: build/C/man3/getcwd.3:171
msgid ""
"On failure, these functions return NULL, and I<errno> is set to indicate the "
"error.  The contents of the array pointed to by I<buf> are undefined on "
"error."
msgstr ""
"失敗した場合、これらの関数は NULL を返し、 I<errno> にエラーを示す値を設定す"
"る。 I<buf> が指す配列の内容は未定義である。"

#. type: Plain text
#: build/C/man3/getcwd.3:175
msgid "Permission to read or search a component of the filename was denied."
msgstr "ファイル名の構成要素に対する読み込みあるいは検索の権限がない。"

#. type: Plain text
#: build/C/man3/getcwd.3:179
msgid "I<buf> points to a bad address."
msgstr "I<buf> が不正なアドレスを指している。"

#. type: Plain text
#: build/C/man3/getcwd.3:186
msgid "The I<size> argument is zero and I<buf> is not a null pointer."
msgstr "I<size> 引数が 0 かつ、 I<buf> 引数がヌルポインターでない。"

#. type: Plain text
#: build/C/man3/getcwd.3:191
msgid "B<getwd>(): I<buf> is NULL."
msgstr "B<getwd>(): I<buf> が NULL である。"

#. type: Plain text
#: build/C/man3/getcwd.3:197
msgid ""
"B<getwd>(): The size of the null-terminated absolute pathname string exceeds "
"B<PATH_MAX> bytes."
msgstr ""
"B<getwd>(): 絶対パス名が入ったヌル終端された文字列の長さが B<PATH_MAX> バイト"
"を超えている。"

#. type: Plain text
#: build/C/man3/getcwd.3:200
msgid "The current working directory has been unlinked."
msgstr "カレントワーキングディレクトリが削除されている。"

#.  Could not allocate I/O bitmap.
#. type: Plain text
#: build/C/man3/getcwd.3:203 build/C/man2/ioperm.2:96
msgid "Out of memory."
msgstr "メモリー不足。"

#. type: TP
#: build/C/man3/getcwd.3:203 build/C/man3/getlogin.3:121
#, no-wrap
msgid "B<ERANGE>"
msgstr "B<ERANGE>"

#. type: Plain text
#: build/C/man3/getcwd.3:210
msgid ""
"The I<size> argument is less than the length of the absolute pathname of the "
"working directory, including the terminating null byte.  You need to "
"allocate a bigger array and try again."
msgstr ""
"I<size> 引数の値がワーキングディレクトリの絶対パス名の長さより小さい。 長さに"
"は文字列の終端バイトも含まれる。 より大きい配列を確保してもう一度実行する必要"
"がある。"

#. type: tbl table
#: build/C/man3/getcwd.3:221
#, no-wrap
msgid ""
"B<getcwd>(),\n"
"B<getwd>()"
msgstr ""
" B<getcwd>(),\n"
"B<getwd>()"

#. type: tbl table
#: build/C/man3/getcwd.3:224
#, no-wrap
msgid "B<get_current_dir_name>()"
msgstr " B<get_current_dir_name>()"

#. type: Plain text
#: build/C/man3/getcwd.3:234
msgid ""
"B<getcwd>()  conforms to POSIX.1-2001.  Note however that POSIX.1-2001 "
"leaves the behavior of B<getcwd>()  unspecified if I<buf> is NULL."
msgstr ""
"B<getcwd>()  は POSIX.1-2001 に準拠している。 POSIX.1-2001 は、 I<buf> が "
"NULL の場合の B<getcwd>()  の動作を規定しないままとしている。"

#. type: Plain text
#: build/C/man3/getcwd.3:245
msgid ""
"B<getwd>()  is present in POSIX.1-2001, but marked LEGACY.  POSIX.1-2008 "
"removes the specification of B<getwd>().  Use B<getcwd>()  instead.  "
"POSIX.1-2001 does not define any errors for B<getwd>()."
msgstr ""
"B<getwd>()  は POSIX.1-2001 に存在しているが、「過去の名残(LEGACY)」とされて"
"いる。 POSIX.1-2008 では、 B<getwd>()  の仕様が削除されている。 代わりに "
"B<getcwd>()  を使うこと。 POSIX.1-2001 は B<getwd>()  に関するエラーを定義し"
"ていない。"

#. type: Plain text
#: build/C/man3/getcwd.3:248
msgid "B<get_current_dir_name>()  is a GNU extension."
msgstr "B<get_current_dir_name>()  は GNU 拡張である。"

#. type: Plain text
#: build/C/man3/getcwd.3:259
#, fuzzy
#| msgid ""
#| "Under Linux, the function B<getcwd>()  is a system call (since 2.1.92).  "
#| "On older systems it would query I</proc/self/cwd>.  If both system call "
#| "and proc filesystem are missing, a generic implementation is called.  "
#| "Only in that case can these calls fail under Linux with B<EACCES>."
msgid ""
"Under Linux, these functions make use of the B<getcwd>()  system call "
"(available since Linux 2.1.92).  On older systems they would query I</proc/"
"self/cwd>.  If both system call and proc filesystem are missing, a generic "
"implementation is called.  Only in that case can these calls fail under "
"Linux with B<EACCES>."
msgstr ""
"Linux では (2.1.92 以降)、 B<getcwd>()  はシステムコールである。 古いシステム"
"では I</proc/self/cwd> を参照する。 システムコールも proc ファイルシステムも"
"ない場合、 一般的な実装が呼び出される。 この場合においてのみ、(Linux では) こ"
"の関数は B<EACCES> で失敗する可能性がある。"

#. type: Plain text
#: build/C/man3/getcwd.3:268
msgid ""
"These functions are often used to save the location of the current working "
"directory for the purpose of returning to it later.  Opening the current "
"directory (\".\") and calling B<fchdir>(2)  to return is usually a faster "
"and more reliable alternative when sufficiently many file descriptors are "
"available, especially on platforms other than Linux."
msgstr ""
"これらの関数はしばしばカレントワーキングディレクトリの位置を保存し、 後で戻っ"
"てくるために利用される。 未使用のファイルディスクリプターが十分ある場合は、 "
"現在のディレクトリ (\".\") を開いて B<fchdir>(2)  を呼び出すほうが普通は高速"
"で信頼性がある。 特に Linux 以外のプラットフォームの場合はそうである。"

#.  commit 3272c544da48f8915a0e34189182aed029bd0f2b
#. type: Plain text
#: build/C/man3/getcwd.3:288
msgid ""
"On Linux, the kernel provides a B<getcwd>()  system call, which the "
"functions described in this page will use if possible.  The system call "
"takes the same arguments as the library function of the same name, but is "
"limited to returning at most B<PATH_MAX> bytes.  (Before Linux 3.12, the "
"limit on the size of the returned pathname was the system page size.  On "
"many architectures, B<PATH_MAX> and the system page size are both 4096 "
"bytes, but a few architectures have a larger page size.)  If the length of "
"the pathname of the current working directory exceeds this limit, then the "
"system call fails with the error B<ENAMETOOLONG>.  In this case, the library "
"functions fall back to a (slower) alternative implementation that returns "
"the full pathname."
msgstr ""

#.  commit 8df9d1a4142311c084ffeeacb67cd34d190eff74
#. type: Plain text
#: build/C/man3/getcwd.3:305
msgid ""
"Following a change in Linux 2.6.36, the pathname returned by the "
"B<getcwd>()  system call will be prefixed with the string \"(unreachable)\" "
"if the current directory is not below the root directory of the current "
"process (e.g., because the process set a new filesystem root using "
"B<chroot>(2)  without changing its current directory into the new root).  "
"Such behavior can also be caused by an unprivileged user by changing the "
"current directory into another mount namespace.  When dealing with pathname "
"from untrusted sources, callers of the functions described in this page "
"should consider checking whether the returned pathname starts with '/' or "
"'(' to avoid misinterpreting an unreachable path as a relative pathname."
msgstr ""

#. type: Plain text
#: build/C/man3/getcwd.3:316
msgid ""
"Since the Linux 2.6.36 change that added \"(unreachable)\" in the "
"circumstances described above, the glibc implementation of B<getcwd>()  has "
"failed to conform to POSIX and returned a relative pathname when the API "
"contract requires an absolute pathname.  With glibc 2.27 onwards this is "
"corrected; calling B<getcwd>()  from such a pathname will now result in "
"failure with B<ENOENT>."
msgstr ""

#. type: Plain text
#: build/C/man3/getcwd.3:324
msgid ""
"B<pwd>(1), B<chdir>(2), B<fchdir>(2), B<open>(2), B<unlink>(2), B<free>(3), "
"B<malloc>(3)"
msgstr ""
" B<pwd>(1), B<chdir>(2), B<fchdir>(2), B<open>(2), B<unlink>(2), B<free>(3), "
"B<malloc>(3)"

#. type: TH
#: build/C/man2/getdomainname.2:29
#, no-wrap
msgid "GETDOMAINNAME"
msgstr "GETDOMAINNAME"

#. type: Plain text
#: build/C/man2/getdomainname.2:32
msgid "getdomainname, setdomainname - get/set NIS domain name"
msgstr "getdomainname, setdomainname - NIS ドメイン名の取得・設定をする"

#. type: Plain text
#: build/C/man2/getdomainname.2:36
msgid "B<int getdomainname(char *>I<name>B<, size_t >I<len>B<);>"
msgstr "B<int getdomainname(char *>I<name>B<, size_t >I<len>B<);>"

#. type: Plain text
#: build/C/man2/getdomainname.2:38
msgid "B<int setdomainname(const char *>I<name>B<, size_t >I<len>B<);>"
msgstr "B<int setdomainname(const char *>I<name>B<, size_t >I<len>B<);>"

#. type: Plain text
#: build/C/man2/getdomainname.2:47
msgid "B<getdomainname>(), B<setdomainname>():"
msgstr "B<getdomainname>(), B<setdomainname>():"

#. type: Plain text
#: build/C/man2/getdomainname.2:62
#, fuzzy
#| msgid ""
#| "These functions are used to access or to change the NIS domain name of "
#| "the host system."
msgid ""
"These functions are used to access or to change the NIS domain name of the "
"host system.  More precisely, they operate on the NIS domain name associated "
"with the calling process's UTS namespace."
msgstr ""
"これらの関数は、ホストシステムの NIS ドメイン名を取得・変更するために使われ"
"る。"

#. type: Plain text
#: build/C/man2/getdomainname.2:73
msgid ""
"B<setdomainname>()  sets the domain name to the value given in the character "
"array I<name>.  The I<len> argument specifies the number of bytes in "
"I<name>.  (Thus, I<name> does not require a terminating null byte.)"
msgstr ""
"B<setdomainname>()  は、ドメイン名を、文字配列 I<name> で指定された値に設定す"
"る。 引数 I<len> には、 I<name> のバイト数を指定する (そのため、 I<name> で"
"は文字列終端のヌルバイトは必要ない)。"

#. type: Plain text
#: build/C/man2/getdomainname.2:83
msgid ""
"B<getdomainname>()  returns the null-terminated domain name in the character "
"array I<name>, which has a length of I<len> bytes.  If the null-terminated "
"domain name requires more than I<len> bytes, B<getdomainname>()  returns the "
"first I<len> bytes (glibc) or gives an error (libc)."
msgstr ""
"B<getdomainname>()  は、NULL 終端されたドメイン名を、 I<len> バイトの長さの文"
"字配列 I<name> に格納して返す。ヌル終端されたドメイン名が I<len> バイトより長"
"い場合、 B<getdomainname>()  は、(glibc では) 始めの I<len> バイトを返し、"
"(libc では) エラーとなる。"

#. type: Plain text
#: build/C/man2/getdomainname.2:91
msgid "B<setdomainname>()  can fail with the following errors:"
msgstr "B<setdomainname>()  は以下のエラーで失敗する可能性がある。"

#. type: Plain text
#: build/C/man2/getdomainname.2:95
msgid "I<name> pointed outside of user address space."
msgstr "I<name> がユーザーアドレス空間の外を指した。"

#. type: Plain text
#: build/C/man2/getdomainname.2:99
msgid "I<len> was negative or too large."
msgstr "I<len> が負であるか、長すぎる。"

#. type: Plain text
#: build/C/man2/getdomainname.2:105
#, fuzzy
#| msgid ""
#| "The caller does not have the B<CAP_SYS_ADMIN> capability.  Alternatively, "
#| "the maximum number of swap files are already in use; see NOTES below."
msgid ""
"The caller did not have the B<CAP_SYS_ADMIN> capability in the user "
"namespace associated with its UTS namespace (see B<namespaces>(7))."
msgstr ""
"使用者が B<CAP_SYS_ADMIN> ケーパビリティを持っていない。 もしくは、最大数のス"
"ワップファイルがすでに使用されている (下記の「注意」の節を参照)。"

#. type: Plain text
#: build/C/man2/getdomainname.2:108
msgid "B<getdomainname>()  can fail with the following errors:"
msgstr "B<getdomainname>()  は以下のエラーで失敗する可能性がある。"

#. type: Plain text
#: build/C/man2/getdomainname.2:119
msgid ""
"For B<getdomainname>()  under libc: I<name> is NULL or I<name> is longer "
"than I<len> bytes."
msgstr ""
"libc での B<getdomainname>()  において、 I<name> が NULL であるか、 I<len> バ"
"イトより長い。"

#.  But they appear on most systems...
#. type: Plain text
#: build/C/man2/getdomainname.2:122
msgid "POSIX does not specify these calls."
msgstr "POSIX では、これら関数は定義されていない。"

#. type: Plain text
#: build/C/man2/getdomainname.2:126
msgid ""
"Since Linux 1.0, the limit on the length of a domain name, including the "
"terminating null byte, is 64 bytes.  In older kernels, it was 8 bytes."
msgstr ""
"Linux 1.0 以降では、ドメイン名の長さの上限は 終端のヌルバイトを含めて 64 バイ"
"トである。 もっと古いカーネルでは 8 バイトであった。"

#. type: Plain text
#: build/C/man2/getdomainname.2:136
msgid ""
"On most Linux architectures (including x86), there is no B<getdomainname>()  "
"system call; instead, glibc implements B<getdomainname>()  as a library "
"function that returns a copy of the I<domainname> field returned from a call "
"to B<uname>(2)."
msgstr ""
"(x86 を含む) Linux のほとんどのアーキテクチャーでは、 B<getdomainname>()  と"
"いうシステムコールは存在しない。 その代わり、glibc で B<getdomainname>()  が"
"ライブラリ関数として実装されており、この関数は B<uname>(2)  の呼び出しで返さ"
"れた I<domainname> フィールドのコピーを返す。"

#. type: Plain text
#: build/C/man2/getdomainname.2:141
msgid "B<gethostname>(2), B<sethostname>(2), B<uname>(2), B<uts_namespaces>(7)"
msgstr ""
" B<gethostname>(2), B<sethostname>(2), B<uname>(2), B<uts_namespaces>(7)"

#. type: TH
#: build/C/man3/getdtablesize.3:27
#, no-wrap
msgid "GETDTABLESIZE"
msgstr "GETDTABLESIZE"

#. type: Plain text
#: build/C/man3/getdtablesize.3:30
msgid "getdtablesize - get file descriptor table size"
msgstr "getdtablesize - ファイルディスクリプターテーブルのサイズを取得する"

#. type: Plain text
#: build/C/man3/getdtablesize.3:34
msgid "B<int getdtablesize(void);>"
msgstr "B<int getdtablesize(void);>"

#. type: Plain text
#: build/C/man3/getdtablesize.3:41
msgid "B<getdtablesize>():"
msgstr "B<getdtablesize>():"

#. type: Plain text
#: build/C/man3/getdtablesize.3:50
#, no-wrap
msgid ""
"/* Glibc since 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE\n"
"    || ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200112L)\n"
msgstr ""
"/* Glibc 2.19 以降: */ _DEFAULT_SOURCE\n"
"    || /* glibc 2.19 以前: */ _BSD_SOURCE\n"
"    || ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200112L)\n"

#. type: Plain text
#: build/C/man3/getdtablesize.3:62
msgid ""
"B<getdtablesize>()  returns the maximum number of files a process can have "
"open, one more than the largest possible value for a file descriptor."
msgstr ""
"B<getdtablesize>()  は 1 つのプロセスのオープンできるファイル数の最大値を返"
"す。 返り値はファイルディスクリプターの取り得る最大値より 1 大きい値である。"

#. type: Plain text
#: build/C/man3/getdtablesize.3:64
msgid "The current limit on the number of open files per process."
msgstr "プロセス毎にオープンできるファイル数の現在の制限値。"

#. type: Plain text
#: build/C/man3/getdtablesize.3:70
msgid ""
"On Linux, B<getdtablesize>()  can return any of the errors described for "
"B<getrlimit>(2); see NOTES below."
msgstr ""
"Linux では、 B<getdtablesize>()  は B<getrlimit>(2)  で説明されているエラーを"
"返すことがある。 下記の「注意」を参照のこと。"

#. type: tbl table
#: build/C/man3/getdtablesize.3:80
#, no-wrap
msgid "B<getdtablesize>()"
msgstr " B<getdtablesize>()"

#. type: Plain text
#: build/C/man3/getdtablesize.3:90
msgid ""
"SVr4, 4.4BSD (the B<getdtablesize>()  function first appeared in 4.2BSD).  "
"It is not specified in POSIX.1; portable applications should employ "
"I<sysconf(_SC_OPEN_MAX)> instead of this call."
msgstr "SVr4, 4.4BSD (B<getdtablesize>()  関数は 4.2BSD で最初に現われた)。 これは POSIX.1 で規定されていないので、 移植性のあるアプリケーションはこの呼び出しの代わりに I<sysconf(_SC_OPEN_MAX)> を使うべきである。"

#.  The libc4 and libc5 versions return
#.  .B OPEN_MAX
#.  (set to 256 since Linux 0.98.4).
#. type: Plain text
#: build/C/man3/getdtablesize.3:103
msgid ""
"The glibc version of B<getdtablesize>()  calls B<getrlimit>(2)  and returns "
"the current B<RLIMIT_NOFILE> limit, or B<OPEN_MAX> when that fails."
msgstr "glibc 版の B<getdtablesize>() は、 B<getrlimit>(2) を呼び出して、現在の B<RLIMIT_NOFILE> を返す。 呼び出しに失敗した場合は B<OPEN_MAX> を返す。"

#. type: Plain text
#: build/C/man3/getdtablesize.3:108
msgid "B<close>(2), B<dup>(2), B<getrlimit>(2), B<open>(2)"
msgstr "B<close>(2), B<dup>(2), B<getrlimit>(2), B<open>(2)"

#. type: TH
#: build/C/man3/gethostid.3:29
#, no-wrap
msgid "GETHOSTID"
msgstr "GETHOSTID"

#. type: Plain text
#: build/C/man3/gethostid.3:32
msgid ""
"gethostid, sethostid - get or set the unique identifier of the current host"
msgstr "gethostid, sethostid - 現在のホストの固有の識別子を取得/設定する"

#. type: Plain text
#: build/C/man3/gethostid.3:36
msgid "B<long gethostid(void);>"
msgstr "B<long gethostid(void);>"

#. type: Plain text
#: build/C/man3/gethostid.3:38
msgid "B<int sethostid(long >I<hostid>B<);>"
msgstr "B<int sethostid(long >I<hostid>B<);>"

#. type: Plain text
#: build/C/man3/gethostid.3:46
msgid "B<gethostid>():"
msgstr "B<gethostid>():"

#. type: Plain text
#: build/C/man3/gethostid.3:51
msgid "B<sethostid>():"
msgstr "B<sethostid>():"

#. type: Plain text
#: build/C/man3/gethostid.3:72
msgid ""
"B<gethostid>()  and B<sethostid>()  respectively get or set a unique 32-bit "
"identifier for the current machine.  The 32-bit identifier was intended to "
"be unique among all UNIX systems in existence.  This normally resembles the "
"Internet address for the local machine, as returned by B<gethostbyname>(3), "
"and thus usually never needs to be set."
msgstr "B<gethostid>()  と B<sethostid>()  は、それぞれ、現在使用しているホストに固有の 32 ビットの識別子の 取得/設定を行う。 この 32 ビットの識別子は、現在存在している全ての UNIX システム の中で唯一になるようにすることを意図したものだった。通常は B<gethostbyname>(3)  により返されるローカルマシンの Internet アドレスが代わりに使用され、 普通は識別子をあえて設定する必要はない。"

#. type: Plain text
#: build/C/man3/gethostid.3:76
msgid "The B<sethostid>()  call is restricted to the superuser."
msgstr "B<sethostid>()  はスーパーユーザーしか使用できない。"

#. type: Plain text
#: build/C/man3/gethostid.3:80
msgid ""
"B<gethostid>()  returns the 32-bit identifier for the current host as set by "
"B<sethostid>()."
msgstr ""
"B<gethostid>()  は、 B<sethostid>()  によって設定された、現在使用しているホス"
"トの 32 ビットの識別子の値を返す。"

#. type: Plain text
#: build/C/man3/gethostid.3:86
msgid ""
"On success, B<sethostid>()  returns 0; on error, -1 is returned, and "
"I<errno> is set to indicate the error."
msgstr ""
"成功すると、 B<sethostid>()  は 0 を返す。 エラーの場合、-1 を返し、 "
"I<errno> にエラーを示す値を設定する。"

#. type: Plain text
#: build/C/man3/gethostid.3:89
msgid "B<sethostid>()  can fail with the following errors:"
msgstr "B<sethostid>()  は以下のエラーで失敗する可能性がある。"

#. type: Plain text
#: build/C/man3/gethostid.3:93
msgid ""
"The caller did not have permission to write to the file used to store the "
"host ID."
msgstr ""
"呼び出し元がホスト ID を保存するのに使用されるファイルへの 書き込み許可を持っ"
"ていなかった。"

#. type: Plain text
#: build/C/man3/gethostid.3:97
msgid ""
"The calling process's effective user or group ID is not the same as its "
"corresponding real ID."
msgstr "呼び出し元プロセスの実効 UID/GID が対応する実 UID/GID と同じではない。"

#. type: tbl table
#: build/C/man3/gethostid.3:107
#, no-wrap
msgid "B<gethostid>()"
msgstr "B<gethostid>()"

#. type: tbl table
#: build/C/man3/gethostid.3:107
#, no-wrap
msgid "MT-Safe hostid env locale"
msgstr "MT-Safe hostid env locale"

#. type: tbl table
#: build/C/man3/gethostid.3:110
#, no-wrap
msgid "B<sethostid>()"
msgstr "B<sethostid>()"

#. type: tbl table
#: build/C/man3/gethostid.3:110
#, no-wrap
msgid "MT-Unsafe const:hostid"
msgstr "MT-Unsafe const:hostid"

#. type: Plain text
#: build/C/man3/gethostid.3:119
msgid ""
"4.2BSD; these functions were dropped in 4.4BSD.  SVr4 includes "
"B<gethostid>()  but not B<sethostid>()."
msgstr "4.2BSD。4.4BSD ではこれらの関数はなくなった。 SVr4 には B<gethostid>()  は含まれているが、 B<sethostid>()  は含まれていない。"

#. type: Plain text
#: build/C/man3/gethostid.3:124
msgid ""
"POSIX.1-2001 and POSIX.1-2008 specify B<gethostid>()  but not B<sethostid>()."
msgstr "POSIX.1-2001 と POSIX.1-2008 では、 B<gethostid>() は規定されているが、 B<sethostid>() は規定されていない。"

#.  libc5 used /etc/hostid; libc4 didn't have these functions
#. type: Plain text
#: build/C/man3/gethostid.3:133
msgid ""
"In the glibc implementation, the I<hostid> is stored in the file I</etc/"
"hostid>.  (In glibc versions before 2.2, the file I</var/adm/hostid> was "
"used.)"
msgstr ""
"glibc の実装では、 I<hostid> はファイル I</etc/hostid> に保存される (バージョ"
"ン 2.2 より前の glibc では、 I</var/adm/hostid> が使用されていた)。"

#. type: Plain text
#: build/C/man3/gethostid.3:144
msgid ""
"In the glibc implementation, if B<gethostid>()  cannot open the file "
"containing the host ID, then it obtains the hostname using "
"B<gethostname>(2), passes that hostname to B<gethostbyname_r>(3)  in order "
"to obtain the host's IPv4 address, and returns a value obtained by bit-"
"twiddling the IPv4 address.  (This value may not be unique.)"
msgstr ""
"glibc の実装では、ホスト ID を保存したファイルを オープンできなかった場合、 "
"B<gethostid>()  は B<gethostname>(2)  を使ってホスト名を入手し、そのホスト名"
"を B<gethostbyname_r>(3)  に渡しホストの IPv4 アドレスを取得して、 その IPv4 "
"アドレスのビット入れ替えを行った値を返す。"

#. type: Plain text
#: build/C/man3/gethostid.3:146
msgid "It is impossible to ensure that the identifier is globally unique."
msgstr "識別子が世界中で一意であることを保証することはできない。"

#. type: Plain text
#: build/C/man3/gethostid.3:149
msgid "B<hostid>(1), B<gethostbyname>(3)"
msgstr "B<hostid>(1), B<gethostbyname>(3)"

#. type: TH
#: build/C/man2/gethostname.2:32
#, no-wrap
msgid "GETHOSTNAME"
msgstr "GETHOSTNAME"

#. type: Plain text
#: build/C/man2/gethostname.2:35
msgid "gethostname, sethostname - get/set hostname"
msgstr "gethostname, sethostname - ホスト名の取得・設定をする"

#. type: Plain text
#: build/C/man2/gethostname.2:39
msgid "B<int gethostname(char *>I<name>B<, size_t >I<len>B<);>"
msgstr "B<int gethostname(char *>I<name>B<, size_t >I<len>B<);>"

#. type: Plain text
#: build/C/man2/gethostname.2:41
msgid "B<int sethostname(const char *>I<name>B<, size_t >I<len>B<);>"
msgstr "B<int sethostname(const char *>I<name>B<, size_t >I<len>B<);>"

#. type: Plain text
#: build/C/man2/gethostname.2:50
msgid "B<gethostname>():"
msgstr "B<gethostname>():"

#. type: Plain text
#: build/C/man2/gethostname.2:53
msgid "Since glibc 2.12: _BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500"
msgstr "glibc 2.12 以降: _BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500"

#. type: Plain text
#: build/C/man2/gethostname.2:55
msgid "|| /* Since glibc 2.12: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"
msgstr "|| /* glibc 2.12 以降: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"

#. type: Plain text
#: build/C/man2/gethostname.2:58
msgid "B<sethostname>():"
msgstr "B<sethostname>():"

#. type: Plain text
#: build/C/man2/gethostname.2:73
#, fuzzy
#| msgid ""
#| "These system calls are used to access or to change the hostname of the "
#| "current processor."
msgid ""
"These system calls are used to access or to change the system hostname.  "
"More precisely, they operate on the hostname associated with the calling "
"process's UTS namespace."
msgstr ""
"これらのシステムコールは、現在のプロセッサのホスト名を取得・変更するために 使"
"用される。"

#. type: Plain text
#: build/C/man2/gethostname.2:84
msgid ""
"B<sethostname>()  sets the hostname to the value given in the character "
"array I<name>.  The I<len> argument specifies the number of bytes in "
"I<name>.  (Thus, I<name> does not require a terminating null byte.)"
msgstr ""
"B<sethostname>()  は、ホスト名を、文字配列 I<name> で指定された値に設定す"
"る。 引数 I<len> には、 I<name> のバイト数を指定する (そのため、 I<name> で"
"は文字列終端のヌルバイトは必要ない)。"

#. type: Plain text
#: build/C/man2/gethostname.2:96
msgid ""
"B<gethostname>()  returns the null-terminated hostname in the character "
"array I<name>, which has a length of I<len> bytes.  If the null-terminated "
"hostname is too large to fit, then the name is truncated, and no error is "
"returned (but see NOTES below).  POSIX.1 says that if such truncation "
"occurs, then it is unspecified whether the returned buffer includes a "
"terminating null byte."
msgstr "B<gethostname>()  は、NULL 終端されたホスト名を、 I<len> バイトの長さの文字配列 I<name> に格納して返す。ヌル終端されたホスト名が格納先のバッファーよりも長い場合は、 ホスト名は切り詰められ、エラーは返されない (下記の「注意」の節を参照)。 POSIX.1 では、結果の切り詰めが発生した場合に、 返されたバッファーに終端のヌルバイトが含まれているかどうかは 規定されていない。"

#. type: Plain text
#: build/C/man2/gethostname.2:106
msgid "I<name> is an invalid address."
msgstr "I<name> が不正なアドレスである。"

#.  Can't occur for gethostbyname() wrapper, since 'len' has an
#.  unsigned type; can occur for the underlying system call.
#. type: Plain text
#: build/C/man2/gethostname.2:116
msgid ""
"I<len> is negative or, for B<sethostname>(), I<len> is larger than the "
"maximum allowed size."
msgstr ""
"I<len> が負である。 B<sethostname>()  において I<len> が許容された最大サイズ"
"を越えている。"

#. type: Plain text
#: build/C/man2/gethostname.2:124
msgid ""
"(glibc B<gethostname>())  I<len> is smaller than the actual size.  (Before "
"version 2.1, glibc uses B<EINVAL> for this case.)"
msgstr ""
"(glibc B<gethostname>()  で)  I<len> が実際のホスト名の長さよりも小さい "
"(glibc バージョン 2.1 より前では、この状況で B<EINVAL> が使用される)。"

#. type: Plain text
#: build/C/man2/gethostname.2:132
#, fuzzy
#| msgid ""
#| "For B<sethostname>(), the caller did not have the B<CAP_SYS_ADMIN> "
#| "capability."
msgid ""
"For B<sethostname>(), the caller did not have the B<CAP_SYS_ADMIN> "
"capability in the user namespace associated with its UTS namespace (see "
"B<namespaces>(7))."
msgstr ""
"B<sethostname>()  において、呼び出した人が B<CAP_SYS_ADMIN> ケーパビリティ "
"(capability) を持っていなかった。"

#. type: Plain text
#: build/C/man2/gethostname.2:138
msgid ""
"SVr4, 4.4BSD (these interfaces first appeared in 4.2BSD).  POSIX.1-2001 and "
"POSIX.1-2008 specify B<gethostname>()  but not B<sethostname>()."
msgstr "SVr4, 4.4BSD (これらのインターフェースは 4.2BSD で初めて登場した)。 POSIX.1-2001 と POSIX.1-2008 では B<gethostname>()  については規定しているが、 B<sethostname>()  は規定していない。"

#. type: Plain text
#: build/C/man2/gethostname.2:148
msgid ""
"SUSv2 guarantees that \"Host names are limited to 255 bytes\".  POSIX.1 "
"guarantees that \"Host names (not including the terminating null byte) are "
"limited to B<HOST_NAME_MAX> bytes\".  On Linux, B<HOST_NAME_MAX> is defined "
"with the value 64, which has been the limit since Linux 1.0 (earlier kernels "
"imposed a limit of 8 bytes)."
msgstr "SUSv2 では「ホスト名が 255 バイトに制限される」ことを保証している。 POSIX.1 では「ホスト名 (終端のヌルバイトは含まない) が B<HOST_NAME_MAX> バイトに制限される」ことを保証している。 Linux では、 B<HOST_NAME_MAX> は 64 に定義されており、 Linux 1.0 以降ではこれが上限となってきた (もっと古いカーネルでは 8 バイトの上限が適用されていた)。"

#. type: Plain text
#: build/C/man2/gethostname.2:171
msgid ""
"The GNU C library does not employ the B<gethostname>()  system call; "
"instead, it implements B<gethostname>()  as a library function that calls "
"B<uname>(2)  and copies up to I<len> bytes from the returned I<nodename> "
"field into I<name>.  Having performed the copy, the function then checks if "
"the length of the I<nodename> was greater than or equal to I<len>, and if it "
"is, then the function returns -1 with I<errno> set to B<ENAMETOOLONG>; in "
"this case, a terminating null byte is not included in the returned I<name>."
msgstr ""
"GNU C ライブラリは、 B<gethostname>()  システムコールを利用していない。その代"
"わり、 B<gethostname>()  をライブラリ関数として実装しており、 この関数は "
"B<uname>(2)  を呼び出し、 B<uname>(2)  が返した I<nodename> フィールド (の最"
"大 I<len> バイト) を I<name> にコピーする。 コピーを行った際に、この関数は "
"I<nodename> の長さが I<len> 以上かの確認を行い、 I<len> 以上の場合には -1 を"
"返し、 I<errno> に B<ENAMETOOLONG> を設定する。 この場合、返された I<name> に"
"は終端のヌルバイトは含まれない。"

#.  At least glibc 2.0 and 2.1, older versions not checked
#. type: Plain text
#: build/C/man2/gethostname.2:184
msgid ""
"Versions of glibc before 2.2 handle the case where the length of the "
"I<nodename> was greater than or equal to I<len> differently: nothing is "
"copied into I<name> and the function returns -1 with I<errno> set to "
"B<ENAMETOOLONG>."
msgstr ""
"バージョン 2.2 より前の glibc では、 I<nodename> の長さが I<len> 以上の場合の"
"扱いが異なる; I<len> 以上の場合には、 I<name> には何もコピーせず、関数は -1 "
"を返し、 I<errno> に B<ENAMETOOLONG> を設定する。"

#. type: Plain text
#: build/C/man2/gethostname.2:190
msgid ""
"B<hostname>(1), B<getdomainname>(2), B<setdomainname>(2), B<uname>(2), "
"B<uts_namespaces>(7)"
msgstr ""
" B<hostname>(1), B<getdomainname>(2), B<setdomainname>(2), B<uname>(2), "
"B<uts_namespaces>(7)"

#. type: TH
#: build/C/man3/getlogin.3:28
#, no-wrap
msgid "GETLOGIN"
msgstr "GETLOGIN"

#. type: TH
#: build/C/man3/getlogin.3:28 build/C/man3/lockf.3:28
#: build/C/man2/truncate.2:43
#, no-wrap
msgid "2019-03-06"
msgstr " 2019-03-06"

#. type: Plain text
#: build/C/man3/getlogin.3:31
msgid "getlogin, getlogin_r, cuserid - get username"
msgstr "getlogin, getlogin_r, cuserid - ユーザー名を取得する"

#. type: Plain text
#: build/C/man3/getlogin.3:35
msgid "B<char *getlogin(void);>"
msgstr "B<char *getlogin(void);>"

#. type: Plain text
#: build/C/man3/getlogin.3:37
msgid "B<int getlogin_r(char *>I<buf>B<, size_t >I<bufsize>B<);>"
msgstr "B<int getlogin_r(char *>I<buf>B<, size_t >I<bufsize>B<);>"

#. type: Plain text
#: build/C/man3/getlogin.3:39
msgid "B<#include E<lt>stdio.hE<gt>>"
msgstr "B<#include E<lt>stdio.hE<gt>>"

#. type: Plain text
#: build/C/man3/getlogin.3:41
msgid "B<char *cuserid(char *>I<string>B<);>"
msgstr "B<char *cuserid(char *>I<string>B<);>"

#.  Deprecated: _REENTRANT ||
#. type: Plain text
#: build/C/man3/getlogin.3:50
msgid "B<getlogin_r>(): _POSIX_C_SOURCE\\ E<gt>=\\ 199506L"
msgstr " B<getlogin_r>(): _POSIX_C_SOURCE\\ E<gt>=\\ 199506L"

#. type: Plain text
#: build/C/man3/getlogin.3:52
msgid "B<cuserid>():"
msgstr " B<cuserid>():"

#. type: Plain text
#: build/C/man3/getlogin.3:58
#, no-wrap
msgid ""
"    Since glibc 2.24:\n"
"        (_XOPEN_SOURCE && ! (_POSIX_C_SOURCE E<gt>= 200112L)\n"
"        || _GNU_SOURCE\n"
"    Up to and including glibc 2.23:\n"
"        _XOPEN_SOURCE\n"
msgstr ""
"    glibc 2.24 以降:\n"
"        (_XOPEN_SOURCE && ! (_POSIX_C_SOURCE E<gt>= 200112L)\n"
"        || _GNU_SOURCE\n"
"    glibc 2.23 以前:\n"
"        _XOPEN_SOURCE\n"

#. type: Plain text
#: build/C/man3/getlogin.3:68
msgid ""
"B<getlogin>()  returns a pointer to a string containing the name of the user "
"logged in on the controlling terminal of the process, or a null pointer if "
"this information cannot be determined.  The string is statically allocated "
"and might be overwritten on subsequent calls to this function or to "
"B<cuserid>()."
msgstr ""
"B<getlogin>()  は、現在のプロセスの制御端末にログインしているユーザー名の文字"
"列への ポインターを返す。ユーザー名が決定できない場合はヌルポインターを返"
"す。 文字列は静的領域に割り当てられており、この後でこの関数や B<cuserid>()  "
"が呼び出された際に上書きされることがある。"

#. type: Plain text
#: build/C/man3/getlogin.3:74
msgid ""
"B<getlogin_r>()  returns this same username in the array I<buf> of size "
"I<bufsize>."
msgstr ""
"B<getlogin_r>()  は、上記の同じユーザー名を、大きさ I<bufsize> の配列 I<buf> "
"に入れて返す。"

#. type: Plain text
#: build/C/man3/getlogin.3:86
msgid ""
"B<cuserid>()  returns a pointer to a string containing a username associated "
"with the effective user ID of the process.  If I<string> is not a null "
"pointer, it should be an array that can hold at least B<L_cuserid> "
"characters; the string is returned in this array.  Otherwise, a pointer to a "
"string in a static area is returned.  This string is statically allocated "
"and might be overwritten on subsequent calls to this function or to "
"B<getlogin>()."
msgstr ""
"B<cuserid>()  は、現在のプロセスの実効ユーザーID に対応するユーザー名の 文字"
"列へのポインターを返す。 I<string> がヌルポインター以外の場合、I<string> は少"
"なくとも B<L_cuserid> 文字を保持できる配列でなければならない。 I<string> が "
"ヌルポインターの場合には、静的領域に置かれた文字列への ポインターが返される。"
"この文字列は静的領域に割り当てられており、後で この関数や B<getlogin>()  が呼"
"び出された際に上書きされることがある。"

#. type: Plain text
#: build/C/man3/getlogin.3:90
msgid ""
"The macro B<L_cuserid> is an integer constant that indicates how long an "
"array you might need to store a username.  B<L_cuserid> is declared in "
"I<E<lt>stdio.hE<gt>>."
msgstr ""
"マクロ B<L_cuserid> は integer の定数で、ユーザー名を保持するために 必要な配"
"列の長さを示す。 B<L_cuserid> は B<stdio.h> で宣言されて いる。"

#. type: Plain text
#: build/C/man3/getlogin.3:97
msgid ""
"These functions let your program identify positively the user who is running "
"(B<cuserid>())  or the user who logged in this session (B<getlogin>()).  "
"(These can differ when set-user-ID programs are involved.)"
msgstr ""
"これらの関数を使うと、プログラムを実行しているユーザー (B<cuserid>())  や こ"
"のセッションにログインしているユーザー (B<getlogin>())  を明確に特定すること"
"ができる (ただし set-user-ID プログラムでは、状況が違うこともある)。"

#. type: Plain text
#: build/C/man3/getlogin.3:102
msgid ""
"For most purposes, it is more useful to use the environment variable "
"B<LOGNAME> to find out who the user is.  This is more flexible precisely "
"because the user can set B<LOGNAME> arbitrarily."
msgstr ""
"たいていの目的では、ユーザーの特定には環境変数 B<LOGNAME> を調べ るほうが便利"
"である。LOGNAME 変数はユーザーが自由に設定できるので より柔軟な対応が可能にな"
"る。"

#. type: Plain text
#: build/C/man3/getlogin.3:110
msgid ""
"B<getlogin>()  returns a pointer to the username when successful, and NULL "
"on failure, with I<errno> set to indicate the cause of the error.  "
"B<getlogin_r>()  returns 0 when successful, and nonzero on failure."
msgstr ""
"B<getlogin>()  は成功した場合はユーザー名へのポインターを返す。 失敗した場合"
"は NULL を返し、 I<errno> にエラーの原因を示す値を設定する。 "
"B<getlogin_r>()  は成功すると 0 を返し、失敗すると 0 以外を返す。"

#. type: Plain text
#: build/C/man3/getlogin.3:112
msgid "POSIX specifies:"
msgstr "POSIX では以下のエラーが規定されている:"

#. type: TP
#: build/C/man3/getlogin.3:118
#, no-wrap
msgid "B<ENXIO>"
msgstr "B<ENXIO>"

#. type: Plain text
#: build/C/man3/getlogin.3:121
msgid "The calling process has no controlling terminal."
msgstr "呼び出し元プロセスには制御端末がない。"

#. type: Plain text
#: build/C/man3/getlogin.3:127
msgid ""
"(getlogin_r)  The length of the username, including the terminating null "
"byte (\\(aq\\e0\\(aq), is larger than I<bufsize>."
msgstr ""
"(getlogin_r)  (終端のヌルバイト (\\(aq\\e0\\(aq) も含めた) ユーザー名の長さ"
"が I<bufsize> よりも長い。"

#. type: Plain text
#: build/C/man3/getlogin.3:129
msgid "Linux/glibc also has:"
msgstr "Linux/glibc には以下のエラーもある。"

#. type: Plain text
#: build/C/man3/getlogin.3:132
msgid "There was no corresponding entry in the utmp-file."
msgstr "utmp ファイルに対応するエントリーがなかった。"

#. type: Plain text
#: build/C/man3/getlogin.3:135
msgid "Insufficient memory to allocate passwd structure."
msgstr "passwd 構造体を割り当てるのに十分なメモリーがない。"

#. type: TP
#: build/C/man3/getlogin.3:135 build/C/man3/tcgetpgrp.3:95
#, no-wrap
msgid "B<ENOTTY>"
msgstr "B<ENOTTY>"

#. type: Plain text
#: build/C/man3/getlogin.3:139
msgid "Standard input didn't refer to a terminal.  (See BUGS.)"
msgstr "標準入力が端末を参照していない (「バグ」の節を参照)。"

#. type: TP
#: build/C/man3/getlogin.3:140
#, no-wrap
msgid "I</etc/passwd>"
msgstr "I</etc/passwd>"

#. type: Plain text
#: build/C/man3/getlogin.3:143
msgid "password database file"
msgstr "パスワードデータベースのファイル"

#. type: TP
#: build/C/man3/getlogin.3:143
#, no-wrap
msgid "I</var/run/utmp>"
msgstr "I</var/run/utmp>"

#. type: Plain text
#: build/C/man3/getlogin.3:147
msgid "(traditionally I</etc/utmp>; some libc versions used I</var/adm/utmp>)"
msgstr ""
"(伝統的には I</etc/utmp> が使われている; libc の中には I</var/adm/utmp> を使"
"うものもある)"

#. type: tbl table
#: build/C/man3/getlogin.3:157
#, no-wrap
msgid "B<getlogin>()"
msgstr "B<getlogin>()"

#. type: tbl table
#: build/C/man3/getlogin.3:159
#, no-wrap
msgid "MT-Unsafe race:getlogin race:utent\n"
msgstr "MT-Unsafe race:getlogin race:utent\n"

#. type: tbl table
#: build/C/man3/getlogin.3:161
#, no-wrap
msgid "sig:ALRM timer locale"
msgstr "sig:ALRM timer locale"

#. type: tbl table
#: build/C/man3/getlogin.3:164
#, no-wrap
msgid "B<getlogin_r>()"
msgstr "B<getlogin_r>()"

#. type: tbl table
#: build/C/man3/getlogin.3:166
#, no-wrap
msgid "MT-Unsafe race:utent sig:ALRM timer\n"
msgstr "MT-Unsafe race:utent sig:ALRM timer\n"

#. type: tbl table
#: build/C/man3/getlogin.3:168
#, no-wrap
msgid "locale"
msgstr "locale"

#. type: tbl table
#: build/C/man3/getlogin.3:171
#, no-wrap
msgid "B<cuserid>()"
msgstr "B<cuserid>()"

#. type: tbl table
#: build/C/man3/getlogin.3:171
#, no-wrap
msgid "MT-Unsafe race:cuserid/!string locale"
msgstr "MT-Unsafe race:cuserid/!string locale"

#. type: Plain text
#: build/C/man3/getlogin.3:190
msgid ""
"In the above table, I<utent> in I<race:utent> signifies that if any of the "
"functions B<setutent>(3), B<getutent>(3), or B<endutent>(3)  are used in "
"parallel in different threads of a program, then data races could occur.  "
"B<getlogin>()  and B<getlogin_r>()  call those functions, so we use race:"
"utent to remind users."
msgstr ""

#. type: Plain text
#: build/C/man3/getlogin.3:195
msgid "B<getlogin>()  and B<getlogin_r>(): POSIX.1-2001, POSIX.1-2008."
msgstr "B<getlogin>()  and B<getlogin_r>(): POSIX.1-2001, POSIX.1-2008."

#. type: Plain text
#: build/C/man3/getlogin.3:206
msgid ""
"System V has a B<cuserid>()  function which uses the real user ID rather "
"than the effective user ID.  The B<cuserid>()  function was included in the "
"1988 version of POSIX, but removed from the 1990 version.  It was present in "
"SUSv2, but removed in POSIX.1-2001."
msgstr ""
"System V にも B<cuserid>()  があるが、 これは実効ユーザー ID ではなく、実ユー"
"ザー ID を使用する。 B<cuserid>()  関数は 1988 年版の POSIX には含まれていた"
"が、 1990 年版では削除された。 SUSv2 に存在したが、POSIX.1-2001 で削除され"
"た。"

#. type: Plain text
#: build/C/man3/getlogin.3:213
msgid ""
"OpenBSD has B<getlogin>()  and B<setlogin>(), and a username associated with "
"a session, even if it has no controlling terminal."
msgstr ""
"OpenBSD には B<getlogin>()  と B<setlogin>()  があり、 セッションに対応した"
"ユーザー名がある。制御端末がない セッションの場合であっても、対応するユーザー"
"名がある。"

#. type: Plain text
#: build/C/man3/getlogin.3:225
msgid ""
"Unfortunately, it is often rather easy to fool B<getlogin>().  Sometimes it "
"does not work at all, because some program messed up the utmp file.  Often, "
"it gives only the first 8 characters of the login name.  The user currently "
"logged in on the controlling terminal of our program need not be the user "
"who started it.  Avoid B<getlogin>()  for security-related purposes."
msgstr ""
"残念ながら、 B<getlogin>() をだますのはそれほど難しいことではない。別のプログ"
"ラムが utmp ファイルを 壊してしまうと、全く動作しないこともある。またログイン"
"名の最初の 8 文字 しか返さないことも多い。また、プログラムの制御端末に現在ロ"
"グインしているユーザーは、プログラムを実行したユーザーでない場合もある。 セ"
"キュリティの絡む用途には B<getlogin>() を用いるべきではない。"

#. type: Plain text
#: build/C/man3/getlogin.3:235
msgid ""
"Note that glibc does not follow the POSIX specification and uses I<stdin> "
"instead of I</dev/tty>.  A bug.  (Other recent systems, like SunOS 5.8 and "
"HP-UX 11.11 and FreeBSD 4.8 all return the login name also when I<stdin> is "
"redirected.)"
msgstr ""
"glibc は POSIX 仕様には従っておらず、 I</dev/tty> ではなく I<標準入力 "
"(stdin)> を使う。これはバグである。 (SunOS 5.8 や HP-UX 11.11 や FreeBSD 4.8 "
"といった他の最近のシステムはいずれも、 I<標準入力> がリダイレクトされた場合で"
"もログイン名を返す。)"

#. type: Plain text
#: build/C/man3/getlogin.3:245
msgid ""
"Nobody knows precisely what B<cuserid>()  does; avoid it in portable "
"programs.  Or avoid it altogether: use I<getpwuid(geteuid())> instead, if "
"that is what you meant.  B<Do not use> B<cuserid>()."
msgstr ""
"B<cuserid>()  が何を行っているのか、実際のところを知っている者は誰もいない; "
"移植性が求められるプログラムでは B<cuserid>()  は使うべきではない。 というか"
"どんなプログラムでも使うべきではない: 代わりに I<getpwuid(geteuid())> を用い"
"るべきである (これが意図していることならば、だが)。 B<cuserid>()  は「使わな"
"い」こと。"

#. type: Plain text
#: build/C/man3/getlogin.3:250
msgid "B<logname>(1), B<geteuid>(2), B<getuid>(2), B<utmp>(5)"
msgstr " B<logname>(1), B<geteuid>(2), B<getuid>(2), B<utmp>(5)"

#. type: TH
#: build/C/man3/getopt.3:42
#, no-wrap
msgid "GETOPT"
msgstr "GETOPT"

#. type: Plain text
#: build/C/man3/getopt.3:46
msgid ""
"getopt, getopt_long, getopt_long_only, optarg, optind, opterr, optopt - "
"Parse command-line options"
msgstr ""
"getopt, getopt_long, getopt_long_only, optarg, optind, opterr, optopt - コマ"
"ンドラインオプションを解釈する"

#. type: Plain text
#: build/C/man3/getopt.3:52
#, no-wrap
msgid ""
"B<int getopt(int >I<argc>B<, char * const >I<argv[]>B<,>\n"
"B<           const char *>I<optstring>B<);>\n"
msgstr ""
"B<int getopt(int >I<argc>B<, char * const >I<argv[]>B<,>\n"
"B<           const char *>I<optstring>B<);>\n"

#. type: Plain text
#: build/C/man3/getopt.3:55
#, no-wrap
msgid ""
"B<extern char *>I<optarg>B<;>\n"
"B<extern int >I<optind>B<, >I<opterr>B<, >I<optopt>B<;>\n"
msgstr ""
"B<extern char *>I<optarg>B<;>\n"
"B<extern int >I<optind>B<, >I<opterr>B<, >I<optopt>B<;>\n"

#. type: Plain text
#: build/C/man3/getopt.3:57
#, no-wrap
msgid "B<#include E<lt>getopt.hE<gt>>\n"
msgstr "B<#include E<lt>getopt.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/getopt.3:61
#, no-wrap
msgid ""
"B<int getopt_long(int >I<argc>B<, char * const >I<argv[]>B<,>\n"
"B<           const char *>I<optstring>B<,>\n"
"B<           const struct option *>I<longopts>B<, int *>I<longindex>B<);>\n"
msgstr ""
"B<int getopt_long(int >I<argc>B<, char * const >I<argv[]>B<,>\n"
"B<           const char *>I<optstring>B<,>\n"
"B<           const struct option *>I<longopts>B<, int *>I<longindex>B<);>\n"

#. type: Plain text
#: build/C/man3/getopt.3:65
#, no-wrap
msgid ""
"B<int getopt_long_only(int >I<argc>B<, char * const >I<argv[]>B<,>\n"
"B<           const char *>I<optstring>B<,>\n"
"B<           const struct option *>I<longopts>B<, int *>I<longindex>B<);>\n"
msgstr ""
"B<int getopt_long_only(int >I<argc>B<, char * const >I<argv[]>B<,>\n"
"B<           const char *>I<optstring>B<,>\n"
"B<           const struct option *>I<longopts>B<, int *>I<longindex>B<);>\n"

#. type: Plain text
#: build/C/man3/getopt.3:75
msgid "B<getopt>(): _POSIX_C_SOURCE\\ E<gt>=\\ 2 || _XOPEN_SOURCE"
msgstr "B<getopt>(): _POSIX_C_SOURCE\\ E<gt>=\\ 2 || _XOPEN_SOURCE"

#. type: Plain text
#: build/C/man3/getopt.3:79
msgid "B<getopt_long>(), B<getopt_long_only>(): _GNU_SOURCE"
msgstr "B<getopt_long>(), B<getopt_long_only>(): _GNU_SOURCE"

#. type: Plain text
#: build/C/man3/getopt.3:100
msgid ""
"The B<getopt>()  function parses the command-line arguments.  Its arguments "
"I<argc> and I<argv> are the argument count and array as passed to the "
"I<main>()  function on program invocation.  An element of I<argv> that "
"starts with \\(aq-\\(aq (and is not exactly \"-\" or \"--\")  is an option "
"element.  The characters of this element (aside from the initial \\(aq-"
"\\(aq) are option characters.  If B<getopt>()  is called repeatedly, it "
"returns successively each of the option characters from each of the option "
"elements."
msgstr ""
"B<getopt>()  関数はコマンドライン引数を解釈する。 B<getopt>()  がとる引"
"数 I<argc> と I<argv> は、それぞれプログラムの起動時に I<main>()  関数に渡さ"
"れた引数の個数と配列である。 I<argv> の要素のうち \\(aq-\\(aq で始まるもの "
"(かつ \"-\" 単独や \"--\" 単独ではないもの) は オプション要素 (option "
"element) とみなされる。 この要素から先頭の \\(aq-\\(aq を除いた文字は オプ"
"ション文字 (option character) とされる。 B<getopt>()  は、繰り返し呼び出され"
"るごとに、次のオプション文字を返す。"

#. type: Plain text
#: build/C/man3/getopt.3:109
msgid ""
"The variable I<optind> is the index of the next element to be processed in "
"I<argv>.  The system initializes this value to 1.  The caller can reset it "
"to 1 to restart scanning of the same I<argv>, or when scanning a new "
"argument vector."
msgstr ""
"変数 I<optind> は、 I<argv> の次に処理される要素のインデックスである。 システ"
"ムによりこの変数の値は 1 に初期化される。 呼び出し側でこの値を 1 にリセットす"
"ることで、同じ I<argv> のスキャンをやり直したり、新しい引数ベクトルをスキャ"
"ンすることができる。"

#. type: Plain text
#: build/C/man3/getopt.3:119
msgid ""
"If B<getopt>()  finds another option character, it returns that character, "
"updating the external variable I<optind> and a static variable I<nextchar> "
"so that the next call to B<getopt>()  can resume the scan with the following "
"option character or I<argv>-element."
msgstr ""
"新たなオプション文字を見つけると、 B<getopt>()  はその文字を返し、 外部変数 "
"I<optind> とスタティックな変数 I<nextchar> を更新する。 これらによって、 "
"B<getopt>()  は次回の呼び出しの際に、 以降のオプション文字や I<argv> 要素のス"
"キャンを継続できる。"

#. type: Plain text
#: build/C/man3/getopt.3:125
msgid ""
"If there are no more option characters, B<getopt>()  returns -1.  Then "
"I<optind> is the index in I<argv> of the first I<argv>-element that is not "
"an option."
msgstr ""
"オプション文字がそれ以上見つからなくなると、 B<getopt>()  は -1 を返す。そし"
"て I<optind> は、I<argv> の要素のうち、 オプションでない最初の要素を示すよう"
"になる。"

#. type: Plain text
#: build/C/man3/getopt.3:152
msgid ""
"I<optstring> is a string containing the legitimate option characters.  If "
"such a character is followed by a colon, the option requires an argument, so "
"B<getopt>()  places a pointer to the following text in the same I<argv>-"
"element, or the text of the following I<argv>-element, in I<optarg>.  Two "
"colons mean an option takes an optional arg; if there is text in the current "
"I<argv>-element (i.e., in the same word as the option name itself, for "
"example, \"-oarg\"), then it is returned in I<optarg>, otherwise I<optarg> "
"is set to zero.  This is a GNU extension.  If I<optstring> contains B<W> "
"followed by a semicolon, then B<-W foo> is treated as the long option B<--"
"foo>.  (The B<-W> option is reserved by POSIX.2 for implementation "
"extensions.)  This behavior is a GNU extension, not available with libraries "
"before glibc 2."
msgstr ""
"I<optstring> は受け付けるオプション文字からなる文字列である。 文字のあとにコ"
"ロン (:) が置かれている場合は、 オプションには引数が必要であることを示す。 "
"このとき B<getopt>()  は、現在注目している I<argv> 要素で、オプション文字に引"
"き続くテキストへのポインターか、 あるいは次の I<argv> 要素のテキストへのポイ"
"ンターを I<optarg> に代入する。 2 個連続してコロンが置かれている場合は、 その"
"オプションは引数をとってもとらなくてもよい。 現在の I<argv> 要素にテキスト"
"があれば (つまり、\"-oarg\" のように、オプション名自身と同じワード内に テキス"
"トがある場合)、それが I<optarg> に返される。 なければ I<optarg> は 0 に設定さ"
"れる。 これは GNU による拡張である。 I<optstring> に B<W> とそれに続くセミコ"
"ロンが入っていると、 B<-W foo> は長いオプション B<--foo> と同じように扱われ"
"る (POSIX.2 は B<-W> オプションを実装依存の拡張として予約している)。 この動作"
"は GNU による拡張であり、glibc 2 以前のライブラリでは 利用できない。"

#. type: Plain text
#: build/C/man3/getopt.3:170
msgid ""
"By default, B<getopt>()  permutes the contents of I<argv> as it scans, so "
"that eventually all the nonoptions are at the end.  Two other scanning modes "
"are also implemented.  If the first character of I<optstring> is \\(aq+\\(aq "
"or the environment variable B<POSIXLY_CORRECT> is set, then option "
"processing stops as soon as a nonoption argument is encountered.  If the "
"first character of I<optstring> is \\(aq-\\(aq, then each nonoption I<argv>-"
"element is handled as if it were the argument of an option with character "
"code 1.  (This is used by programs that were written to expect options and "
"other I<argv>-elements in any order and that care about the ordering of the "
"two.)  The special argument \"--\" forces an end of option-scanning "
"regardless of the scanning mode."
msgstr "デフォルトでは B<getopt>()  は I<argv> をスキャンする際に順序を変更し、 オプション以外の要素を最後に移動する。 他にも 2 つのスキャンモードが実装されている。 I<optstring> の先頭文字が \\(aq+\\(aq であるか、環境変数 B<POSIXLY_CORRECT> が設定されている場合には、オプションを対象とする動作は、 非オプションの引数が現れた段階で終了する。 I<optstring> の先頭文字が \\(aq-\\(aq である場合には、 オプションでない I<argv> 要素は、 文字コード 1 のオプションであるかのように扱われる (これを用いるプログラムは、 オプションや I<argv> 要素を任意の順序で受け入れ、かつそれらの順序が 意味を持つように書かれている必要がある)。 \"--\" は特殊な引数で、スキャンのモードによらず、 オプションのスキャンを強制的に終了させる。"

#. type: Plain text
#: build/C/man3/getopt.3:179
msgid ""
"While processing the option list, B<getopt>()  can detect two kinds of "
"errors: (1) an option character that was not specified in I<optstring> and "
"(2) a missing option argument (i.e., an option at the end of the command "
"line without an expected argument).  Such errors are handled and reported as "
"follows:"
msgstr ""

#. type: Plain text
#: build/C/man3/getopt.3:186
msgid ""
"By default, B<getopt>()  prints an error message on standard error, places "
"the erroneous option character in I<optopt>, and returns \\(aq?\\(aq as the "
"function result."
msgstr ""

#. type: Plain text
#: build/C/man3/getopt.3:197
msgid ""
"If the caller has set the global variable I<opterr> to zero, then "
"B<getopt>()  does not print an error message.  The caller can determine that "
"there was an error by testing whether the function return value is \\(aq?"
"\\(aq.  (By default, I<opterr> has a nonzero value.)"
msgstr ""

#. type: Plain text
#: build/C/man3/getopt.3:208
msgid ""
"If the first character (following any optional \\(aq+\\(aq or \\(aq-\\(aq "
"described above)  of I<optstring> is a colon (\\(aq:\\(aq), then "
"B<getopt>()  likewise does not print an error message.  In addition, it "
"returns \\(aq:\\(aq instead of \\(aq?\\(aq to indicate a missing option "
"argument.  This allows the caller to distinguish the two different types of "
"errors."
msgstr ""

#. type: SS
#: build/C/man3/getopt.3:208
#, no-wrap
msgid "getopt_long() and getopt_long_only()"
msgstr "getopt_long() と getopt_long_only()"

#. type: Plain text
#: build/C/man3/getopt.3:224
msgid ""
"The B<getopt_long>()  function works like B<getopt>()  except that it also "
"accepts long options, started with two dashes.  (If the program accepts only "
"long options, then I<optstring> should be specified as an empty string "
"(\"\"), not NULL.)  Long option names may be abbreviated if the abbreviation "
"is unique or is an exact match for some defined option.  A long option may "
"take a parameter, of the form B<--arg=param> or B<--arg param>."
msgstr ""
"B<getopt_long>()  関数は、長いオプション (2 つのダッシュ \"--\" で始まるオプ"
"ション) を 受け入れることを除いて B<getopt>()  と同じように動作する (プログラ"
"ムに長いオプションだけが渡された場合、 I<optstring> は NULL ではなく空文字列 "
"(\"\") となる)。 長いオプションの名前は、他と重ならない範囲において短縮でき"
"る。 あるいは定義されたオプションに正確にマッチするものでも (当然) かまわな"
"い。 長いオプションは引数を取ることができ、 B<--arg=param> または B<--arg "
"param> と言う形式で指定する。"

#. type: Plain text
#: build/C/man3/getopt.3:231
msgid ""
"I<longopts> is a pointer to the first element of an array of I<struct "
"option> declared in I<E<lt>getopt.hE<gt>> as"
msgstr ""
"I<longopts> は I<struct option> の要素からなる配列の、先頭要素へのポインター"
"である。 I<struct option> は I<E<lt>getopt.hE<gt>> で以下のように定義されてい"
"る。"

#. type: Plain text
#: build/C/man3/getopt.3:240
#, no-wrap
msgid ""
"struct option {\n"
"    const char *name;\n"
"    int         has_arg;\n"
"    int        *flag;\n"
"    int         val;\n"
"};\n"
msgstr ""
"struct option {\n"
"    const char *name;\n"
"    int         has_arg;\n"
"    int        *flag;\n"
"    int         val;\n"
"};\n"

#. type: Plain text
#: build/C/man3/getopt.3:244
msgid "The meanings of the different fields are:"
msgstr "それぞれのフィールドの意味は以下の通り。"

#. type: TP
#: build/C/man3/getopt.3:244
#, no-wrap
msgid "I<name>"
msgstr "I<name>"

#. type: Plain text
#: build/C/man3/getopt.3:247
msgid "is the name of the long option."
msgstr "長いオプションの名前。"

#. type: TP
#: build/C/man3/getopt.3:247
#, no-wrap
msgid "I<has_arg>"
msgstr "I<has_arg>"

#. type: Plain text
#: build/C/man3/getopt.3:253
msgid ""
"is: B<no_argument> (or 0) if the option does not take an argument; "
"B<required_argument> (or 1) if the option requires an argument; or "
"B<optional_argument> (or 2) if the option takes an optional argument."
msgstr ""
"B<no_argument> (または 0) なら、オプションは引数をとらない。 "
"B<required_argument> (または 1) なら、オプションは引数を必要とする。 "
"B<optional_argument> (または 2) なら、オプションは引数をとっても とらなくて"
"も良い。"

#. type: TP
#: build/C/man3/getopt.3:253
#, no-wrap
msgid "I<flag>"
msgstr "I<flag>"

#. type: Plain text
#: build/C/man3/getopt.3:267
msgid ""
"specifies how results are returned for a long option.  If I<flag> is NULL, "
"then B<getopt_long>()  returns I<val>.  (For example, the calling program "
"may set I<val> to the equivalent short option character.)  Otherwise, "
"B<getopt_long>()  returns 0, and I<flag> points to a variable which is set "
"to I<val> if the option is found, but left unchanged if the option is not "
"found."
msgstr ""
"長いオプションに対する結果の返し方を指定する。I<flag> が NULL なら "
"B<getopt_long>()  は I<val> を返す (例えば呼び出し元のプログラムは、 I<val> "
"に等価なオプション文字を代入することができる)。 NULL 以外の場合には、 "
"B<getopt_long>()  は 0 を返す。 このときオプションが見つかると I<flag> がポイ"
"ントする変数に I<val> が代入される。見つからないとこの変数は変更されない。"

#. type: TP
#: build/C/man3/getopt.3:267
#, no-wrap
msgid "I<val>"
msgstr "I<val>"

#. type: Plain text
#: build/C/man3/getopt.3:271
msgid ""
"is the value to return, or to load into the variable pointed to by I<flag>."
msgstr "返り値、または I<flag> がポイントする変数へロードされる値。"

#. type: Plain text
#: build/C/man3/getopt.3:273
msgid "The last element of the array has to be filled with zeros."
msgstr "配列の最後の要素は、全て 0 で埋められていなければならない。"

#. type: Plain text
#: build/C/man3/getopt.3:277
msgid ""
"If I<longindex> is not NULL, it points to a variable which is set to the "
"index of the long option relative to I<longopts>."
msgstr ""
"I<longindex> は、NULL でなければ、 長いオプションのインデックスを "
"I<longopts> からの相対位置として保持している変数へのポインターとなる。"

#. type: Plain text
#: build/C/man3/getopt.3:286
msgid ""
"B<getopt_long_only>()  is like B<getopt_long>(), but \\(aq-\\(aq as well as "
"\"--\" can indicate a long option.  If an option that starts with \\(aq-"
"\\(aq (not \"--\") doesn't match a long option, but does match a short "
"option, it is parsed as a short option instead."
msgstr ""
"B<getopt_long_only>()  は B<getopt_long>()  と同様の動作をするが、 \\(aq-"
"\\(aq も \"--\" と同様に、 長いオプションとして扱われる。\\(aq-\\(aq で始ま"
"る (\"--\" 以外の) オプションが、長いものにはマッチしないが短いものに マッチ"
"する場合においては、それは短いオプションとして解釈される。"

#. type: Plain text
#: build/C/man3/getopt.3:304
msgid ""
"If an option was successfully found, then B<getopt>()  returns the option "
"character.  If all command-line options have been parsed, then B<getopt>()  "
"returns -1.  If B<getopt>()  encounters an option character that was not in "
"I<optstring>, then \\(aq?\\(aq is returned.  If B<getopt>()  encounters an "
"option with a missing argument, then the return value depends on the first "
"character in I<optstring>: if it is \\(aq:\\(aq, then \\(aq:\\(aq is "
"returned; otherwise \\(aq?\\(aq is returned."
msgstr ""
"オプションが正常に見つかれば B<getopt>()  はそのオプション文字を返す。 すべて"
"のコマンドラインオプションの解析が終わったら、 B<getopt>()  は -1 を返す。 "
"I<optstring> に含まれないオプション文字が見つかると、\\(aq?\\(aq を返す。 引"
"数が足りないオプションが見つかった場合、 返り値は I<optstring> の最初の文字"
"による異なる: 最初の文字が \\(aq:\\(aq であれば \\(aq:\\(aq を返し、 それ以外"
"の場合は \\(aq?\\(aq を返す。"

#. type: Plain text
#: build/C/man3/getopt.3:316
msgid ""
"B<getopt_long>()  and B<getopt_long_only>()  also return the option "
"character when a short option is recognized.  For a long option, they return "
"I<val> if I<flag> is NULL, and 0 otherwise.  Error and -1 returns are the "
"same as for B<getopt>(), plus \\(aq?\\(aq for an ambiguous match or an "
"extraneous parameter."
msgstr ""
"B<getopt_long>()  と B<getopt_long_only>()  も、 短いオプション文字を認識した"
"場合にはその文字を返す。 長いオプションに対しては、 I<flag> が NULL なら "
"I<val> を返し、 I<flag> が NULL 以外なら 0 を返す。 エラーと -1 の返り値は "
"B<getopt>()  と同じである。 さらに \\(aq?\\(aq は、マッチが確定できない場合や"
"余分なパラメーターがある場合にも返る。"

#. type: SH
#: build/C/man3/getopt.3:316
#, no-wrap
msgid "ENVIRONMENT"
msgstr "環境"

#. type: TP
#: build/C/man3/getopt.3:317
#, no-wrap
msgid "B<POSIXLY_CORRECT>"
msgstr "B<POSIXLY_CORRECT>"

#. type: Plain text
#: build/C/man3/getopt.3:321
msgid ""
"If this is set, then option processing stops as soon as a nonoption argument "
"is encountered."
msgstr ""
"これが設定されていると、非オプションの引数に到達した時点でオプション に対す"
"る操作が停止される。"

#. type: TP
#: build/C/man3/getopt.3:321
#, no-wrap
msgid "B<_E<lt>PIDE<gt>_GNU_nonoption_argv_flags_>"
msgstr "B<_E<lt>PIDE<gt>_GNU_nonoption_argv_flags_>"

#. type: Plain text
#: build/C/man3/getopt.3:330
msgid ""
"This variable was used by B<bash>(1)  2.0 to communicate to glibc which "
"arguments are the results of wildcard expansion and so should not be "
"considered as options.  This behavior was removed in B<bash>(1)  version "
"2.01, but the support remains in glibc."
msgstr ""
"この変数は B<bash>(1)  2.0 が glibc と通信するために用いられた。 どの引数が"
"ワイルドカードを展開した結果で、 したがってオプションとみなすべきでないかを知"
"らせるものである。 この機能は B<bash>(1)  のバージョン 2.01 で削除されたが、"
"glibc にはまだ残っている。"

#. type: tbl table
#: build/C/man3/getopt.3:342
#, no-wrap
msgid ""
"B<getopt>(),\n"
"B<getopt_long>(),\n"
"B<getopt_long_only>()"
msgstr ""
"B<getopt>(),\n"
"B<getopt_long>(),\n"
"B<getopt_long_only>()"

#. type: tbl table
#: build/C/man3/getopt.3:342
#, no-wrap
msgid "MT-Unsafe race:getopt env"
msgstr "MT-Unsafe race:getopt env"

#. type: TP
#: build/C/man3/getopt.3:345
#, no-wrap
msgid "B<getopt>():"
msgstr "B<getopt>():"

#. type: Plain text
#: build/C/man3/getopt.3:357
#, fuzzy
#| msgid ""
#| "POSIX.2 and POSIX.1-2001, provided the environment variable "
#| "B<POSIXLY_CORRECT> is set.  Otherwise, the elements of I<argv> aren't "
#| "really const, because we permute them.  We pretend they're const in the "
#| "prototype to be compatible with other systems."
msgid ""
"POSIX.1-2001, POSIX.1-2008, and POSIX.2, provided the environment variable "
"B<POSIXLY_CORRECT> is set.  Otherwise, the elements of I<argv> aren't really "
"I<const>, because these functions permute them.  Nevertheless, I<const> is "
"used in the prototype to be compatible with other systems."
msgstr ""
"環境変数 B<POSIXLY_CORRECT> が設定されている場合は POSIX.2 と POSIX.1-2001 に"
"準拠する。 他の場合は I<argv> の要素は本当の意味での定数にはならない。 なぜな"
"ら順序が変更されてしまうからである。 ただしそれらは、プロトタイプでは定数であ"
"るかのようにしてある。 これは他のシステムとの互換性のためである。"

#. type: Plain text
#: build/C/man3/getopt.3:361
msgid ""
"The use of \\(aq+\\(aq and \\(aq-\\(aq in I<optstring> is a GNU extension."
msgstr ""
"I<optstring> で \\(aq+\\(aq や \\(aq-\\(aq を使うのは GNU による拡張である."

#. type: Plain text
#: build/C/man3/getopt.3:375
msgid ""
"On some older implementations, B<getopt>()  was declared in I<E<lt>stdio."
"hE<gt>>.  SUSv1 permitted the declaration to appear in either I<E<lt>unistd."
"hE<gt>> or I<E<lt>stdio.hE<gt>>.  POSIX.1-1996 marked the use of "
"I<E<lt>stdio.hE<gt>> for this purpose as LEGACY.  POSIX.1-2001 does not "
"require the declaration to appear in I<E<lt>stdio.hE<gt>>."
msgstr "古い実装のいくつかでは、 B<getopt>()  は I<E<lt>stdio.hE<gt>> で宣言されていた。 SUSv1 では、 I<E<lt>unistd.hE<gt>> か I<E<lt>stdio.hE<gt>> のどちらかで 宣言してもよかった。 POSIX.1-1996 では、 B<getopt> の宣言を I<E<lt>stdio.hE<gt>> で行うのは「過去の名残」であるとされた。 POSIX.1-2001 では I<E<lt>stdio.hE<gt>> で宣言を行うことを要求していない。"

#. type: TP
#: build/C/man3/getopt.3:375
#, no-wrap
msgid "B<getopt_long>() and B<getopt_long_only>():"
msgstr "B<getopt_long>(), B<getopt_long_only>():"

#. type: Plain text
#: build/C/man3/getopt.3:397
msgid ""
"A program that scans multiple argument vectors, or rescans the same vector "
"more than once, and wants to make use of GNU extensions such as \\(aq+\\(aq "
"and \\(aq-\\(aq at the start of I<optstring>, or changes the value of "
"B<POSIXLY_CORRECT> between scans, must reinitialize B<getopt>()  by "
"resetting I<optind> to 0, rather than the traditional value of 1.  "
"(Resetting to 0 forces the invocation of an internal initialization routine "
"that rechecks B<POSIXLY_CORRECT> and checks for GNU extensions in "
"I<optstring>.)"
msgstr ""
"複数の引数ベクトルをスキャンしたり、同じ引数ベクトルを二回以上 スキャンす"
"るようなプログラムで、 I<optstring> の先頭で \\(aq+\\(aq や \\(aq-\\(aq と"
"いった GNU による拡張機能を使用したり、 引数ベクトルの切り替え時に "
"B<POSIXLY_CORRECT> の値を変更したりする場合には、 I<optind> を伝統的な 1 では"
"なく 0 にリセットすることで B<getopt>()  を再初期化しなければならない (0 にリ"
"セットすることで、 B<POSIXLY_CORRECT> や I<optstring> の GNU 拡張機能のチェッ"
"クを行う内部初期化ルーチンが起動される)。"

#. type: SS
#: build/C/man3/getopt.3:398
#, no-wrap
msgid "getopt()"
msgstr "getopt()"

#. type: Plain text
#: build/C/man3/getopt.3:406
msgid ""
"The following trivial example program uses B<getopt>()  to handle two "
"program options: I<-n>, with no associated value; and I<-t val>, which "
"expects an associated value."
msgstr ""
"以下に示す簡単なサンプルプログラムでは、 二種類のプログラムオプションを扱うの"
"に B<getopt>()  を使用している。一つは値を伴わない I<-n> で、もう一つは対応す"
"る値が必要な I<-t val> である。"

#. type: Plain text
#: build/C/man3/getopt.3:411
#, no-wrap
msgid ""
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"

#. type: Plain text
#: build/C/man3/getopt.3:417
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int flags, opt;\n"
"    int nsecs, tfnd;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int flags, opt;\n"
"    int nsecs, tfnd;\n"

#. type: Plain text
#: build/C/man3/getopt.3:436
#, no-wrap
msgid ""
"    nsecs = 0;\n"
"    tfnd = 0;\n"
"    flags = 0;\n"
"    while ((opt = getopt(argc, argv, \"nt:\")) != -1) {\n"
"        switch (opt) {\n"
"        case \\(aqn\\(aq:\n"
"            flags = 1;\n"
"            break;\n"
"        case \\(aqt\\(aq:\n"
"            nsecs = atoi(optarg);\n"
"            tfnd = 1;\n"
"            break;\n"
"        default: /* \\(aq?\\(aq */\n"
"            fprintf(stderr, \"Usage: %s [-t nsecs] [-n] name\\en\",\n"
"                    argv[0]);\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"    }\n"
msgstr ""
"    nsecs = 0;\n"
"    tfnd = 0;\n"
"    flags = 0;\n"
"    while ((opt = getopt(argc, argv, \"nt:\")) != -1) {\n"
"        switch (opt) {\n"
"        case \\(aqn\\(aq:\n"
"            flags = 1;\n"
"            break;\n"
"        case \\(aqt\\(aq:\n"
"            nsecs = atoi(optarg);\n"
"            tfnd = 1;\n"
"            break;\n"
"        default: /* \\(aq?\\(aq */\n"
"            fprintf(stderr, \"Usage: %s [-t nsecs] [-n] name\\en\",\n"
"                    argv[0]);\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"    }\n"

#. type: Plain text
#: build/C/man3/getopt.3:439
#, no-wrap
msgid ""
"    printf(\"flags=%d; tfnd=%d; nsecs=%d; optind=%d\\en\",\n"
"            flags, tfnd, nsecs, optind);\n"
msgstr ""
"    printf(\"flags=%d; tfnd=%d; nsecs=%d; optind=%d\\en\",\n"
"            flags, tfnd, nsecs, optind);\n"

#. type: Plain text
#: build/C/man3/getopt.3:444
#, no-wrap
msgid ""
"    if (optind E<gt>= argc) {\n"
"        fprintf(stderr, \"Expected argument after options\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (optind E<gt>= argc) {\n"
"        fprintf(stderr, \"Expected argument after options\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/getopt.3:446
#, no-wrap
msgid "    printf(\"name argument = %s\\en\", argv[optind]);\n"
msgstr "    printf(\"name argument = %s\\en\", argv[optind]);\n"

#. type: Plain text
#: build/C/man3/getopt.3:448
#, no-wrap
msgid "    /* Other code omitted */\n"
msgstr "    /* Other code omitted */\n"

#. type: SS
#: build/C/man3/getopt.3:452
#, no-wrap
msgid "getopt_long()"
msgstr "getopt_long()"

#. type: Plain text
#: build/C/man3/getopt.3:456
msgid ""
"The following example program illustrates the use of B<getopt_long>()  with "
"most of its features."
msgstr ""
"以下は、 B<getopt_long>()  の使用法を、ほぼすべての機能について示したプログラ"
"ムの例である。"

#. type: Plain text
#: build/C/man3/getopt.3:461
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>     /* for printf */\n"
"#include E<lt>stdlib.hE<gt>    /* for exit */\n"
"#include E<lt>getopt.hE<gt>\n"
msgstr ""
"#include E<lt>stdio.hE<gt>     /* for printf */\n"
"#include E<lt>stdlib.hE<gt>    /* for exit */\n"
"#include E<lt>getopt.hE<gt>\n"

#. type: Plain text
#: build/C/man3/getopt.3:467
#, no-wrap
msgid ""
"int\n"
"main(int argc, char **argv)\n"
"{\n"
"    int c;\n"
"    int digit_optind = 0;\n"
msgstr ""
"int\n"
"main(int argc, char **argv) {\n"
"    int c;\n"
"    int digit_optind = 0;\n"

#. type: Plain text
#: build/C/man3/getopt.3:480
#, no-wrap
msgid ""
"    while (1) {\n"
"        int this_option_optind = optind ? optind : 1;\n"
"        int option_index = 0;\n"
"        static struct option long_options[] = {\n"
"            {\"add\",     required_argument, 0,  0 },\n"
"            {\"append\",  no_argument,       0,  0 },\n"
"            {\"delete\",  required_argument, 0,  0 },\n"
"            {\"verbose\", no_argument,       0,  0 },\n"
"            {\"create\",  required_argument, 0, \\(aqc\\(aq},\n"
"            {\"file\",    required_argument, 0,  0 },\n"
"            {0,         0,                 0,  0 }\n"
"        };\n"
msgstr ""
"    while (1) {\n"
"        int this_option_optind = optind ? optind : 1;\n"
"        int option_index = 0;\n"
"        static struct option long_options[] = {\n"
"            {\"add\",     required_argument, 0,  0 },\n"
"            {\"append\",  no_argument,       0,  0 },\n"
"            {\"delete\",  required_argument, 0,  0 },\n"
"            {\"verbose\", no_argument,       0,  0 },\n"
"            {\"create\",  required_argument, 0, \\(aqc\\(aq},\n"
"            {\"file\",    required_argument, 0,  0 },\n"
"            {0,         0,                 0,  0 }\n"
"        };\n"

#. type: Plain text
#: build/C/man3/getopt.3:485
#, no-wrap
msgid ""
"        c = getopt_long(argc, argv, \"abc:d:012\",\n"
"                 long_options, &option_index);\n"
"        if (c == -1)\n"
"            break;\n"
msgstr ""
"        c = getopt_long(argc, argv, \"abc:d:012\",\n"
"                 long_options, &option_index);\n"
"        if (c == -1)\n"
"            break;\n"

#. type: Plain text
#: build/C/man3/getopt.3:493
#, no-wrap
msgid ""
"        switch (c) {\n"
"        case 0:\n"
"            printf(\"option %s\", long_options[option_index].name);\n"
"            if (optarg)\n"
"                printf(\" with arg %s\", optarg);\n"
"            printf(\"\\en\");\n"
"            break;\n"
msgstr ""
"        switch (c) {\n"
"        case 0:\n"
"            printf(\"option %s\", long_options[option_index].name);\n"
"            if (optarg)\n"
"                printf(\" with arg %s\", optarg);\n"
"            printf(\"\\en\");\n"
"            break;\n"

#. type: Plain text
#: build/C/man3/getopt.3:502
#, no-wrap
msgid ""
"        case \\(aq0\\(aq:\n"
"        case \\(aq1\\(aq:\n"
"        case \\(aq2\\(aq:\n"
"            if (digit_optind != 0 && digit_optind != this_option_optind)\n"
"              printf(\"digits occur in two different argv-elements.\\en\");\n"
"            digit_optind = this_option_optind;\n"
"            printf(\"option %c\\en\", c);\n"
"            break;\n"
msgstr ""
"        case \\(aq0\\(aq:\n"
"        case \\(aq1\\(aq:\n"
"        case \\(aq2\\(aq:\n"
"            if (digit_optind != 0 && digit_optind != this_option_optind)\n"
"              printf(\"digits occur in two different argv-elements.\\en\");\n"
"            digit_optind = this_option_optind;\n"
"            printf(\"option %c\\en\", c);\n"
"            break;\n"

#. type: Plain text
#: build/C/man3/getopt.3:506
#, no-wrap
msgid ""
"        case \\(aqa\\(aq:\n"
"            printf(\"option a\\en\");\n"
"            break;\n"
msgstr ""
"        case \\(aqa\\(aq:\n"
"            printf(\"option a\\en\");\n"
"            break;\n"

#. type: Plain text
#: build/C/man3/getopt.3:510
#, no-wrap
msgid ""
"        case \\(aqb\\(aq:\n"
"            printf(\"option b\\en\");\n"
"            break;\n"
msgstr ""
"        case \\(aqb\\(aq:\n"
"            printf(\"option b\\en\");\n"
"            break;\n"

#. type: Plain text
#: build/C/man3/getopt.3:514
#, no-wrap
msgid ""
"        case \\(aqc\\(aq:\n"
"            printf(\"option c with value \\(aq%s\\(aq\\en\", optarg);\n"
"            break;\n"
msgstr ""
"        case \\(aqc\\(aq:\n"
"            printf(\"option c with value \\(aq%s\\(aq\\en\", optarg);\n"
"            break;\n"

#. type: Plain text
#: build/C/man3/getopt.3:518
#, no-wrap
msgid ""
"        case \\(aqd\\(aq:\n"
"            printf(\"option d with value \\(aq%s\\(aq\\en\", optarg);\n"
"            break;\n"
msgstr ""
"        case \\(aqd\\(aq:\n"
"            printf(\"option d with value \\(aq%s\\(aq\\en\", optarg);\n"
"            break;\n"

#. type: Plain text
#: build/C/man3/getopt.3:521
#, no-wrap
msgid ""
"        case \\(aq?\\(aq:\n"
"            break;\n"
msgstr ""
"        case \\(aq?\\(aq:\n"
"            break;\n"

#. type: Plain text
#: build/C/man3/getopt.3:526
#, no-wrap
msgid ""
"        default:\n"
"            printf(\"?? getopt returned character code 0%o ??\\en\", c);\n"
"        }\n"
"    }\n"
msgstr ""
"        default:\n"
"            printf(\"?? getopt returned character code 0%o ??\\en\", c);\n"
"        }\n"
"    }\n"

#. type: Plain text
#: build/C/man3/getopt.3:533
#, no-wrap
msgid ""
"    if (optind E<lt> argc) {\n"
"        printf(\"non-option ARGV-elements: \");\n"
"        while (optind E<lt> argc)\n"
"            printf(\"%s \", argv[optind++]);\n"
"        printf(\"\\en\");\n"
"    }\n"
msgstr ""
"    if (optind E<lt> argc) {\n"
"        printf(\"non-option ARGV-elements: \");\n"
"        while (optind E<lt> argc)\n"
"            printf(\"%s \", argv[optind++]);\n"
"        printf(\"\\en\");\n"
"    }\n"

#. type: Plain text
#: build/C/man3/getopt.3:540
msgid "B<getopt>(1), B<getsubopt>(3)"
msgstr "B<getopt>(1), B<getsubopt>(3)"

#. type: TH
#: build/C/man2/getpagesize.2:25
#, no-wrap
msgid "GETPAGESIZE"
msgstr "GETPAGESIZE"

#. type: Plain text
#: build/C/man2/getpagesize.2:28
msgid "getpagesize - get memory page size"
msgstr "getpagesize - メモリーのページサイズを取得する"

#. type: Plain text
#: build/C/man2/getpagesize.2:32
msgid "B<int getpagesize(void);>"
msgstr "B<int getpagesize(void);>"

#. type: Plain text
#: build/C/man2/getpagesize.2:39
msgid "B<getpagesize>():"
msgstr "B<getpagesize>():"

#. type: Plain text
#: build/C/man2/getpagesize.2:46
#, no-wrap
msgid "_DEFAULT_SOURCE || ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200112L)\n"
msgstr " _DEFAULT_SOURCE || ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200112L)\n"

#. type: Plain text
#: build/C/man2/getpagesize.2:51
#, no-wrap
msgid "_BSD_SOURCE || ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200112L)\n"
msgstr " _BSD_SOURCE || ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200112L)\n"

#.  .SH HISTORY
#.  This call first appeared in 4.2BSD.
#. type: Plain text
#: build/C/man2/getpagesize.2:68
msgid ""
"The function B<getpagesize>()  returns the number of bytes in a memory page, "
"where \"page\" is a fixed-length block, the unit for memory allocation and "
"file mapping performed by B<mmap>(2)."
msgstr ""
"B<getpagesize>() 関数はメモリーページの大きさをバイト数で返す。\n"
"ここでいう「ページ」は固定長のブロックであり、\n"
"B<mmap>(2) で実行されるメモリー割り当てとファイルマッピングの単位である。"

#. type: Plain text
#: build/C/man2/getpagesize.2:75
msgid ""
"SVr4, 4.4BSD, SUSv2.  In SUSv2 the B<getpagesize>()  call is labeled LEGACY, "
"and in POSIX.1-2001 it has been dropped; HP-UX does not have this call."
msgstr ""
"SVr4, 4.4BSD, SUSv2.\n"
"SUSv2 では B<getpagesize>() システムコールは「過去の遺物 (LEGACY)」とされてお"
"り、\n"
"POSIX.1-2001 からは外されている。 HP-UX にはこのシステムコールは存在しない。"

#. type: Plain text
#: build/C/man2/getpagesize.2:80
msgid ""
"Portable applications should employ I<sysconf(_SC_PAGESIZE)> instead of "
"B<getpagesize>():"
msgstr ""
"移植性が必要なアプリケーションでは、\n"
"B<getpagesize>() ではなく I<sysconf(_SC_PAGESIZE)> を利用すべきである。"

#. type: Plain text
#: build/C/man2/getpagesize.2:85
#, no-wrap
msgid ""
"#include E<lt>unistd.hE<gt>\n"
"long sz = sysconf(_SC_PAGESIZE);\n"
msgstr ""
"#include E<lt>unistd.hE<gt>\n"
"long sz = sysconf(_SC_PAGESIZE);\n"

#. type: Plain text
#: build/C/man2/getpagesize.2:92
msgid "(Most systems allow the synonym B<_SC_PAGE_SIZE> for B<_SC_PAGESIZE>.)"
msgstr ""
"(ほとんどのシステムでは B<_SC_PAGESIZE> の同義語として\n"
"B<_SC_PAGE_SIZE> を使用することができる。)"

#. type: Plain text
#: build/C/man2/getpagesize.2:112
msgid ""
"Whether B<getpagesize>()  is present as a Linux system call depends on the "
"architecture.  If it is, it returns the kernel symbol B<PAGE_SIZE>, whose "
"value depends on the architecture and machine model.  Generally, one uses "
"binaries that are dependent on the architecture but not on the machine "
"model, in order to have a single binary distribution per architecture.  This "
"means that a user program should not find B<PAGE_SIZE> at compile time from "
"a header file, but use an actual system call, at least for those "
"architectures (like sun4) where this dependency exists.  Here glibc 2.0 "
"fails because its B<getpagesize>()  returns a statically derived value, and "
"does not use a system call.  Things are OK in glibc 2.1."
msgstr ""
"B<getpagesize>()  が Linux のシステムコールとして存在するかどうかは、そのアー"
"キテクチャーに 依存している。 システムコールとして存在する場合には、カーネル"
"シンボルの B<PAGE_SIZE> を返す。 B<PAGE_SIZE> の値は、アーキテクチャーとマシ"
"ンモデルに依存する。 一般に、バイナリは、アーキテクチャーごとに1つのバイナリ"
"配布で済ませるために、 アーキテクチャーには依存しているがマシンモデルには依存"
"していない。 つまり、ユーザープログラムはコンパイル時にヘッダーファイルから "
"B<PAGE_SIZE> を見つけて使用すべきではない。 少なくとも、マシンモデルについて"
"も依存性が存在する (sun4 のような)  アーキテクチャーにおいては本物のシステム"
"コールを使用する必要がある。 尚、 glibc 2.0 では、 B<getpagesize>()  がシステ"
"ムコールを使用せず、固定の値を返すために、この方法は 失敗する。glibc 2.1 では"
"大丈夫である。"

#. type: Plain text
#: build/C/man2/getpagesize.2:115
msgid "B<mmap>(2), B<sysconf>(3)"
msgstr "B<mmap>(2), B<sysconf>(3)"

#. type: TH
#: build/C/man2/gettid.2:26
#, no-wrap
msgid "GETTID"
msgstr "GETTID"

#. type: Plain text
#: build/C/man2/gettid.2:29
msgid "gettid - get thread identification"
msgstr "gettid - スレッドID を取得する"

#. type: Plain text
#: build/C/man2/gettid.2:34
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>\n"
"B<#include E<lt>unistd.hE<gt>>\n"
"B<#include E<lt>sys/types.hE<gt>>\n"
msgstr ""
" B<#define _GNU_SOURCE>\n"
"B<#include E<lt>unistd.hE<gt>>\n"
"B<#include E<lt>sys/types.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/gettid.2:36
#, no-wrap
msgid "B<pid_t gettid(void);>\n"
msgstr "B<pid_t gettid(void);>\n"

#. type: Plain text
#: build/C/man2/gettid.2:49
msgid ""
"B<gettid>()  returns the caller's thread ID (TID).  In a single-threaded "
"process, the thread ID is equal to the process ID (PID, as returned by "
"B<getpid>(2)).  In a multithreaded process, all threads have the same PID, "
"but each one has a unique TID.  For further details, see the discussion of "
"B<CLONE_THREAD> in B<clone>(2)."
msgstr ""
"B<gettid>()  は呼び出し元のスレッド ID (TID) を返す。 シングルスレッドのプロ"
"セスでは、スレッド ID は (B<getpid>(2)  が返すプロセス ID (PID) と等しい。 マ"
"ルチスレッドのプロセスでは、全てのスレッドは同じ PID を持つが、 それぞれのス"
"レッドは一意な TID を持つ。 さらなる詳細は、 B<clone>(2)  の B<CLONE_THREAD> "
"についての議論を参照すること。"

#. type: Plain text
#: build/C/man2/gettid.2:51
msgid "On success, returns the thread ID of the calling thread."
msgstr "成功の場合、呼び出し元のスレッドのスレッドID を返す。"

#. type: Plain text
#: build/C/man2/gettid.2:53
msgid "This call is always successful."
msgstr "このコールは常に成功する。"

#. type: Plain text
#: build/C/man2/gettid.2:61
msgid ""
"The B<gettid>()  system call first appeared on Linux in kernel 2.4.11.  "
"Library support was added in glibc 2.30.  (Earlier glibc versions did not "
"provide a wrapper for this system call, necessitating the use of "
"B<syscall>(2).)"
msgstr ""

#. type: Plain text
#: build/C/man2/gettid.2:65
msgid ""
"B<gettid>()  is Linux-specific and should not be used in programs that are "
"intended to be portable."
msgstr ""
"B<gettid>()  は Linux 固有であり、 移植を想定したプログラムでは使用すべきでは"
"ない。"

#. type: Plain text
#: build/C/man2/gettid.2:69
msgid ""
"The thread ID returned by this call is not the same thing as a POSIX thread "
"ID (i.e., the opaque value returned by B<pthread_self>(3))."
msgstr ""
"このシステムコールが返すスレッド ID は POSIX スレッド ID "
"(B<pthread_self>(3)  が返す曖昧な値) と同じものではない。"

#. type: Plain text
#: build/C/man2/gettid.2:81
msgid ""
"In a new thread group created by a B<clone>(2)  call that does not specify "
"the B<CLONE_THREAD> flag (or, equivalently, a new process created by "
"B<fork>(2)), the new process is a thread group leader, and its thread group "
"ID (the value returned by B<getpid>(2))  is the same as its thread ID (the "
"value returned by B<gettid>())."
msgstr ""

#.  .BR kcmp (2),
#.  .BR move_pages (2),
#.  .BR migrate_pages (2),
#.  .BR process_vm_readv (2),
#.  .BR ptrace (2),
#. type: Plain text
#: build/C/man2/gettid.2:100
msgid ""
"B<capget>(2), B<clone>(2), B<fcntl>(2), B<fork>(2), B<get_robust_list>(2), "
"B<getpid>(2), B<ioprio_set>(2), B<perf_event_open>(2), "
"B<sched_setaffinity>(2), B<sched_setparam>(2), B<sched_setscheduler>(2), "
"B<tgkill>(2), B<timer_create>(2)"
msgstr ""
"B<capget>(2), B<clone>(2), B<fcntl>(2), B<fork>(2), B<get_robust_list>(2), "
"B<getpid>(2), B<ioprio_set>(2), B<perf_event_open>(2), "
"B<sched_setaffinity>(2), B<sched_setparam>(2), B<sched_setscheduler>(2), "
"B<tgkill>(2), B<timer_create>(2)"

#. type: TH
#: build/C/man3/getumask.3:28
#, no-wrap
msgid "GETUMASK"
msgstr "GETUMASK"

#. type: Plain text
#: build/C/man3/getumask.3:31
msgid "getumask - get file creation mask"
msgstr "getumask - ファイル作成マスクを取得する"

#. type: Plain text
#: build/C/man3/getumask.3:33
msgid "B<#define _GNU_SOURCE> /* See feature_test_macros(7) */"
msgstr "B<#define _GNU_SOURCE> /* feature_test_macros(7) 参照 */"

#. type: Plain text
#: build/C/man3/getumask.3:37 build/C/man2/umask.2:41
msgid "B<#include E<lt>sys/stat.hE<gt>>"
msgstr "B<#include E<lt>sys/stat.hE<gt>>"

#. type: Plain text
#: build/C/man3/getumask.3:39
msgid "B<mode_t getumask(void);>"
msgstr "B<mode_t getumask(void);>"

#. type: Plain text
#: build/C/man3/getumask.3:42
msgid ""
"This function returns the current file creation mask.  It is equivalent to"
msgstr ""
"この関数は現在のファイル作成マスクを返す。 基本的には以下と等価である。"

#. type: Plain text
#: build/C/man3/getumask.3:51
#, no-wrap
msgid ""
"mode_t getumask(void)\n"
"{\n"
"    mode_t mask = umask( 0 );\n"
"    umask(mask);\n"
"    return mask;\n"
"}\n"
msgstr ""
"mode_t getumask(void)\n"
"{\n"
"    mode_t mask = umask( 0 );\n"
"    umask(mask);\n"
"    return mask;\n"
"}\n"

#. type: Plain text
#: build/C/man3/getumask.3:58
msgid ""
"except that it is documented to be thread-safe (that is, shares a lock with "
"the B<umask>(2)  library call)."
msgstr ""
"ドキュメントによると、この関数は スレッドセーフである (B<umask>(2)  ライブラ"
"リコールとロックを共有する)  点が異なる。"

#. type: Plain text
#: build/C/man3/getumask.3:60
msgid "This is a vaporware GNU extension."
msgstr "ドキュメントに書いてあるだけの GNU 拡張である。"

#. type: Plain text
#: build/C/man3/getumask.3:66
msgid ""
"This function is documented in the glibc manual, but, as at glibc version "
"2.24, it is not implemented on Linux.  (See B<umask>(2)  for a thread-safe "
"method of discovering a process's umask.)"
msgstr ""

#. type: tbl table
#: build/C/man3/getumask.3:68 build/C/man2/syscalls.2:748
#, no-wrap
msgid "B<umask>(2)"
msgstr "B<umask>(2)"

#. type: TH
#: build/C/man3/getusershell.3:30
#, no-wrap
msgid "GETUSERSHELL"
msgstr "GETUSERSHELL"

#. type: Plain text
#: build/C/man3/getusershell.3:33
msgid "getusershell, setusershell, endusershell - get permitted user shells"
msgstr ""
"getusershell, setusershell, endusershell - 許可されたユーザーシェルを得る"

#. type: Plain text
#: build/C/man3/getusershell.3:38
#, no-wrap
msgid "B<char *getusershell(void);>\n"
msgstr "B<char *getusershell(void);>\n"

#. type: Plain text
#: build/C/man3/getusershell.3:40
#, no-wrap
msgid "B<void setusershell(void);>\n"
msgstr "B<void setusershell(void);>\n"

#. type: Plain text
#: build/C/man3/getusershell.3:42
#, no-wrap
msgid "B<void endusershell(void);>\n"
msgstr "B<void endusershell(void);>\n"

#. type: Plain text
#: build/C/man3/getusershell.3:53
msgid "B<getusershell>(), B<setusershell>(), B<endusershell>():"
msgstr "B<getusershell>(), B<setusershell>(), B<endusershell>():"

#. type: Plain text
#: build/C/man3/getusershell.3:81
msgid ""
"The B<getusershell>()  function returns the next line from the file I</etc/"
"shells>, opening the file if necessary.  The line should contain the "
"pathname of a valid user shell.  If I</etc/shells> does not exist or is "
"unreadable, B<getusershell>()  behaves as if I</bin/sh> and I</bin/csh> were "
"listed in the file."
msgstr ""
"B<getusershell>()  関数は I</etc/shells> ファイルから (開く必要があればこの"
"ファイルを開いてから) 現在行の次の一行を返す。 返された行の中身は有効なユー"
"ザーシェルのうちの一つのパス名である。 (訳注. 一行に付き一つのシェルのパス名"
"が書かれている。)  もし I</etc/shells> が存在しないか、読み込み不可の場合に"
"は、 B<getusershell>()  は I</bin/sh> と I</bin/csh> がファイルに記されている"
"かのようにふるまう。"

#. type: Plain text
#: build/C/man3/getusershell.3:86
msgid "The B<setusershell>()  function rewinds I</etc/shells>."
msgstr ""
"B<setusershell>()  関数は I</etc/shells> ファイルの ファイルポインターを先頭"
"に戻す。"

#. type: Plain text
#: build/C/man3/getusershell.3:91
msgid "The B<endusershell>()  function closes I</etc/shells>."
msgstr "B<endusershell>()  関数は I</etc/shells> ファイルを閉じる。"

#. type: Plain text
#: build/C/man3/getusershell.3:95
msgid "The B<getusershell>()  function returns NULL on end-of-file."
msgstr "B<getusershell>() 関数はファイルの終端では NULL を返す。"

#. type: Plain text
#: build/C/man3/getusershell.3:97 build/C/man5/shells.5:45
msgid "I</etc/shells>"
msgstr "I</etc/shells>"

#. type: tbl table
#: build/C/man3/getusershell.3:108
#, no-wrap
msgid ""
"B<getusershell>(),\n"
"B<setusershell>(),\n"
msgstr ""
"B<getusershell>(),\n"
"B<setusershell>(),\n"

#. type: tbl table
#: build/C/man3/getusershell.3:110
#, no-wrap
msgid "B<endusershell>()"
msgstr "B<endusershell>()"

#. type: tbl table
#: build/C/man3/getusershell.3:110
#, no-wrap
msgid "MT-Unsafe"
msgstr "MT-Unsafe"

#. type: Plain text
#: build/C/man3/getusershell.3:114
msgid "4.3BSD."
msgstr "4.3BSD."

#. type: Plain text
#: build/C/man3/getusershell.3:116
msgid "B<shells>(5)"
msgstr "B<shells>(5)"

#. type: TH
#: build/C/man2/idle.2:32
#, no-wrap
msgid "IDLE"
msgstr "IDLE"

#. type: TH
#: build/C/man2/idle.2:32
#, no-wrap
msgid "2012-12-31"
msgstr "2012-12-31"

#. type: Plain text
#: build/C/man2/idle.2:35
msgid "idle - make process 0 idle"
msgstr "idle - ID 0 のプロセスをアイドル状態にする"

#. type: Plain text
#: build/C/man2/idle.2:39
msgid "B<int idle(void);>"
msgstr "B<int idle(void);>"

#. type: Plain text
#: build/C/man2/idle.2:46
msgid ""
"B<idle>()  is an internal system call used during bootstrap.  It marks the "
"process's pages as swappable, lowers its priority, and enters the main "
"scheduling loop.  B<idle>()  never returns."
msgstr ""
"B<idle>()  はブートストラップ時に使用される、内部システムコールである。 プロ"
"セスのページをスワップ可能に設定し、優先度を下げ、メインのスケジュー ル処理の"
"ためのループへ移行する。 従って B<idle>()  は return することはない。"

#. type: Plain text
#: build/C/man2/idle.2:52
msgid ""
"Only process 0 may call B<idle>().  Any user process, even a process with "
"superuser permission, will receive B<EPERM>."
msgstr ""
"ID 0 のプロセスのみが B<idle>()  を使用することができる。 他のユーザープロセ"
"スはたとえそれがスーパーユーザー権限を持っていたとして も B<EPERM> を受け取"
"る。"

#. type: Plain text
#: build/C/man2/idle.2:55
msgid ""
"B<idle>()  never returns for process 0, and always returns -1 for a user "
"process."
msgstr ""
"B<idle>()  ID 0 のプロセスに対しては return しない。それ以外のユーザープロセ"
"スには 常に -1 を返す。"

#. type: Plain text
#: build/C/man2/idle.2:59 build/C/man2/setup.2:60
msgid "Always, for a user process."
msgstr "ユーザープロセスに対しては、常にこのエラーとなる。"

#. type: Plain text
#: build/C/man2/idle.2:61
msgid "Since Linux 2.3.13, this system call does not exist anymore."
msgstr "Linux 2.3.13 以降では、もはやこのシステムコールは存在しない。"

#. type: Plain text
#: build/C/man2/idle.2:64 build/C/man2/sysinfo.2:117
msgid ""
"This function is Linux-specific, and should not be used in programs intended "
"to be portable."
msgstr ""
"この関数は Linux 特有であり、移植を意図したプログラムでは 使用すべきでない。"

#. type: TH
#: build/C/man2/ioperm.2:34
#, no-wrap
msgid "IOPERM"
msgstr "IOPERM"

#. type: Plain text
#: build/C/man2/ioperm.2:37
msgid "ioperm - set port input/output permissions"
msgstr "ioperm - ポートの入出力許可を設定する"

#. type: Plain text
#: build/C/man2/ioperm.2:40
msgid "B<#include E<lt>sys/io.hE<gt>> /* for glibc */"
msgstr "B<#include E<lt>sys/io.hE<gt>> /* for glibc */"

#. type: Plain text
#: build/C/man2/ioperm.2:42
msgid ""
"B<int ioperm(unsigned long >I<from>B<, unsigned long >I<num>B<, int "
">I<turn_on>B<);>"
msgstr ""
"B<int ioperm(unsigned long >I<from>B<, unsigned long >I<num>B<, int "
">I<turn_on>B<);>"

#. type: Plain text
#: build/C/man2/ioperm.2:56
msgid ""
"B<ioperm>()  sets the port access permission bits for the calling thread for "
"I<num> bits starting from port address I<from>.  If I<turn_on> is nonzero, "
"then permission for the specified bits is enabled; otherwise it is "
"disabled.  If I<turn_on> is nonzero, the calling thread must be privileged "
"(B<CAP_SYS_RAWIO>)."
msgstr ""
"B<ioperm>()  は、引数 I<from> の I/O ポートアドレスから I<num> ビット分の領"
"域に対する、呼び出し元スレッドのアクセス許可ビットを設定する。 I<turn_on> が "
"0 以外の場合、指定されたビットに対応する許可が有効になる。 I<turn_on> が 0 以"
"外の場合、呼び出し元プロセスは特権 (B<CAP_SYS_RAWIO>)  を持っていなければなら"
"ない。"

#. type: Plain text
#: build/C/man2/ioperm.2:65
msgid ""
"Before Linux 2.6.8, only the first 0x3ff I/O ports could be specified in "
"this manner.  For more ports, the B<iopl>(2)  system call had to be used "
"(with a I<level> argument of 3).  Since Linux 2.6.8, 65,536 I/O ports can be "
"specified."
msgstr ""
"Linux 2.6.8 より前のバージョンでは、この方法で設定できるのは 0x3ff 番地まで"
"の I/Oポートに限られていた。これよりも大きなアドレスのポートに対しては "
"B<iopl>(2) 関数を使わなければならなかった。Linux 2.6.8 以降では、65,536 個の "
"I/O ポートを指定できる。"

#. type: Plain text
#: build/C/man2/ioperm.2:73
#, fuzzy
#| msgid ""
#| "Permissions are not inherited by the child created by B<fork>(2); "
#| "following a B<fork>(2)  the child must turn on those permissions that it "
#| "needs.  Permissions are preserved across B<execve>(2); this is useful for "
#| "giving port access permissions to unprivileged programs."
msgid ""
"Permissions are inherited by the child created by B<fork>(2)  (but see "
"NOTES).  Permissions are preserved across B<execve>(2); this is useful for "
"giving port access permissions to unprivileged programs."
msgstr ""
"アクセス権は B<fork>(2)  で作成された子プロセスには継承されない。子プロセスで"
"は、B<fork>(2) の後で必要なアクセス権を有効にしなければならない。 "
"B<execve>(2)  の前後でアクセス権は保存される。この機能は 非特権プログラムに"
"ポートへのアクセス権を 与えるのに使用できる。"

#. type: Plain text
#: build/C/man2/ioperm.2:77
msgid ""
"This call is mostly for the i386 architecture.  On many other architectures "
"it does not exist or will always return an error."
msgstr ""
"このシステムコールはほとんど i386 アーキテクチャーのためだけのものである。 そ"
"の他の多くのアーキテクチャーでは存在しないか、常にエラーを返す。"

#. type: Plain text
#: build/C/man2/ioperm.2:89
msgid "Invalid values for I<from> or I<num>."
msgstr "I<from> または I<num> の値が不正である。"

#. type: Plain text
#: build/C/man2/ioperm.2:92
msgid "(on PowerPC) This call is not supported."
msgstr "(PowerPC で) このシステムコールはサポートしていない。"

#. type: Plain text
#: build/C/man2/ioperm.2:99
msgid "The calling thread has insufficient privilege."
msgstr "呼び出し元スレッドに十分な権限がなかった。"

#. type: Plain text
#: build/C/man2/ioperm.2:103
msgid ""
"B<ioperm>()  is Linux-specific and should not be used in programs intended "
"to be portable."
msgstr ""
"B<ioperm>()  は Linux 特有の関数であり、移植を意図したプログラムで 使用しては"
"ならない。"

#. type: Plain text
#: build/C/man2/ioperm.2:107
msgid ""
"The I</proc/ioports> file shows the I/O ports that are currently allocated "
"on the system."
msgstr ""
"I</proc/ioports> ファイルには、現在このシステムに割り当てられている I/O ポー"
"トが表示される。"

#. type: Plain text
#: build/C/man2/ioperm.2:111
msgid ""
"Before Linux 2.4, permissions were not inherited by a child created by "
"B<fork>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/ioperm.2:119
msgid ""
"Glibc has an B<ioperm>()  prototype both in I<E<lt>sys/io.hE<gt>> and in "
"I<E<lt>sys/perm.hE<gt>>.  Avoid the latter, it is available on i386 only."
msgstr ""
"glibc2 には I<E<lt>sys/io.hE<gt>> と I<E<lt>sys/perm.hE<gt>> の両方に "
"B<ioperm>() のプロトタイプがある。 後者は i386 のみで利用可能なので、使用すべ"
"きではない。"

#. type: Plain text
#: build/C/man2/ioperm.2:123
msgid "B<iopl>(2), B<outb>(2), B<capabilities>(7)"
msgstr "B<iopl>(2), B<outb>(2), B<capabilities>(7)"

#. type: TH
#: build/C/man3/lockf.3:28
#, no-wrap
msgid "LOCKF"
msgstr "LOCKF"

#. type: Plain text
#: build/C/man3/lockf.3:31
msgid "lockf - apply, test or remove a POSIX lock on an open file"
msgstr ""
"lockf - オープンされたファイルに対する POSIX ロックの適用・テスト・解除を行う"

#. type: Plain text
#: build/C/man3/lockf.3:35
msgid "B<int lockf(int >I<fd>B<, int >I<cmd>B<, off_t >I<len>B<);>"
msgstr "B<int lockf(int >I<fd>B<, int >I<cmd>B<, off_t >I<len>B<);>"

#. type: Plain text
#: build/C/man3/lockf.3:42
msgid "B<lockf>():"
msgstr "B<lockf>():"

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: build/C/man3/lockf.3:48
#, no-wrap
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* Glibc since 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* Glibc 2.19 以降: */ _DEFAULT_SOURCE\n"
"    || /* glibc 2.19 以前: */ _BSD_SOURCE || _SVID_SOURCE\n"

#. type: Plain text
#: build/C/man3/lockf.3:71
msgid ""
"Apply, test or remove a POSIX lock on a section of an open file.  The file "
"is specified by I<fd>, a file descriptor open for writing, the action by "
"I<cmd>, and the section consists of byte positions I<pos>..I<pos>+I<len>-1 "
"if I<len> is positive, and I<pos>-I<len>..I<pos>-1 if I<len> is negative, "
"where I<pos> is the current file position, and if I<len> is zero, the "
"section extends from the current file position to infinity, encompassing the "
"present and future end-of-file positions.  In all cases, the section may "
"extend past current end-of-file."
msgstr ""
"オープンされたファイルのセクションに対して、 POSIX ロックの適用・テスト・解除"
"をする。 ファイルは I<fd> で指定される。 I<fd> は書き込みのためにオープンした"
"ファイルディスクリプターである。 アクションは I<cmd> で指定される。 I<pos> を"
"現在のファイル位置とすると、 I<len> が正の場合、セクションはバイト位置 "
"I<pos>..I<pos>+I<len>-1 となり、 I<len> が負の場合、セクションはバイト位置 "
"I<pos>-I<len>..I<pos>-1 となる。 I<len> が 0 の場合、セクションは現在のファイ"
"ル位置から無限大までとなる (つまり現在の、あるいは変更された場合は将来の、"
"ファイル終端位置まで)。 どの場合においても、セクションは以前のファイル終端よ"
"りも拡大されうる。"

#. type: Plain text
#: build/C/man3/lockf.3:86
msgid ""
"On Linux, B<lockf>()  is just an interface on top of B<fcntl>(2)  locking.  "
"Many other systems implement B<lockf>()  in this way, but note that POSIX.1 "
"leaves the relationship between B<lockf>()  and B<fcntl>(2)  locks "
"unspecified.  A portable application should probably avoid mixing calls to "
"these interfaces."
msgstr "Linux では、 B<lockf>()  は単に B<fcntl>(2)  のロックへのインターフェースである。 多くの他のシステムで B<lockf>()  はこのように実装されているが、 POSIX.1 では B<lockf>()  と B<fcntl>(2)  のロックとの関係は規定されていない。 おそらく、移植性が必要なアプリケーションでは、 B<lockf>()  と B<fcntl>(2)  のロックを混ぜて呼び出すのは避けるべきであろう。"

#. type: Plain text
#: build/C/man3/lockf.3:88
msgid "Valid operations are given below:"
msgstr "有効なオプションを以下に挙げる。"

#. type: TP
#: build/C/man3/lockf.3:88
#, no-wrap
msgid "B<F_LOCK>"
msgstr "B<F_LOCK>"

#. type: Plain text
#: build/C/man3/lockf.3:98
msgid ""
"Set an exclusive lock on the specified section of the file.  If (part of) "
"this section is already locked, the call blocks until the previous lock is "
"released.  If this section overlaps an earlier locked section, both are "
"merged.  File locks are released as soon as the process holding the locks "
"closes some file descriptor for the file.  A child process does not inherit "
"these locks."
msgstr ""
"ファイルの指定されたセクションに排他ロックを設定する。 そのセクション (の一"
"部) が既にロックされていた場合、 前のロックが解除されるまで関数の呼び出しがブ"
"ロックされる。 このセクションが前にロックされているセクションと重なった場"
"合、 2 つのセクションは結合される。 ロックを保持しているプロセスが、 そのファ"
"イルのファイルディスクリプターをクローズすると、 ファイルロックは解放され"
"る。 子プロセスはロックを継承しない。"

#. type: TP
#: build/C/man3/lockf.3:98
#, no-wrap
msgid "B<F_TLOCK>"
msgstr "B<F_TLOCK>"

#. type: Plain text
#: build/C/man3/lockf.3:104
msgid ""
"Same as B<F_LOCK> but the call never blocks and returns an error instead if "
"the file is already locked."
msgstr ""
"B<F_LOCK> と同様であるが、ファイルが既にロックされている場合、 関数の呼び出し"
"はブロックを行わずにエラーを返す。"

#. type: TP
#: build/C/man3/lockf.3:104
#, no-wrap
msgid "B<F_ULOCK>"
msgstr "B<F_ULOCK>"

#. type: Plain text
#: build/C/man3/lockf.3:108
msgid ""
"Unlock the indicated section of the file.  This may cause a locked section "
"to be split into two locked sections."
msgstr ""
"ファイルの指定されたセクションのロックを解除する。 これによりロックされたセク"
"ションが 2 つに分割されるかもしれない。"

#. type: TP
#: build/C/man3/lockf.3:108
#, no-wrap
msgid "B<F_TEST>"
msgstr "B<F_TEST>"

#. type: Plain text
#: build/C/man3/lockf.3:118
msgid ""
"Test the lock: return 0 if the specified section is unlocked or locked by "
"this process; return -1, set I<errno> to B<EAGAIN> (B<EACCES> on some other "
"systems), if another process holds a lock."
msgstr ""
"次のようにロックのテストをする。 指定されたセクションがロックされていない"
"か、 このプロセスによりロックされている場合、0 を返す。 他のプロセスがロック"
"を保持している場合、-1 を返し、 I<errno> を B<EAGAIN> (いくつかの他のシステム"
"では B<EACCES>)  に設定する。"

#. type: Plain text
#: build/C/man3/lockf.3:132
msgid ""
"The file is locked and B<F_TLOCK> or B<F_TEST> was specified, or the "
"operation is prohibited because the file has been memory-mapped by another "
"process."
msgstr ""
"ロックされたファイルに対して、 B<F_TLOCK> または B<F_TEST> が指定されてい"
"る。 または、ファイルが他のプロセスによりメモリーマップされており、 指定され"
"た操作が禁止されている。"

#. type: Plain text
#: build/C/man3/lockf.3:144
msgid ""
"I<fd> is not an open file descriptor; or I<cmd> is B<F_LOCK> or B<F_TLOCK> "
"and I<fd> is not a writable file descriptor."
msgstr ""
"I<fd> がオープンされたファイルのディスクリプターではない。 または、 I<cmd> "
"が B<F_LOCK> か B<F_TLOCK> で、 I<fd> が書き込み可能なファイルディスクリプ"
"ターでない。"

#. type: Plain text
#: build/C/man3/lockf.3:149
msgid ""
"The command was B<F_LOCK> and this lock operation would cause a deadlock."
msgstr ""
"コマンドが B<F_LOCK> であり、このロック操作を行うとデッドロックが発生してしま"
"う。"

#. type: Plain text
#: build/C/man3/lockf.3:158
msgid "An invalid operation was specified in I<cmd>."
msgstr "I<cmd> に無効な操作が指定された。"

#. type: Plain text
#: build/C/man3/lockf.3:161
msgid "Too many segment locks open, lock table is full."
msgstr "非常に多くのセグメントロックが開かれ、ロックテーブルが一杯である。"

#. type: tbl table
#: build/C/man3/lockf.3:171
#, no-wrap
msgid "B<lockf>()"
msgstr " B<lockf>()"

#. type: Plain text
#: build/C/man3/lockf.3:175
msgid "POSIX.1-2001, POSIX.1-2008, SVr4."
msgstr " POSIX.1-2001, POSIX.1-2008, SVr4."

#. type: Plain text
#: build/C/man3/lockf.3:178
msgid "B<fcntl>(2), B<flock>(2)"
msgstr "B<fcntl>(2), B<flock>(2)"

#. type: Plain text
#: build/C/man3/lockf.3:190
msgid ""
"I<locks.txt> and I<mandatory-locking.txt> in the Linux kernel source "
"directory I<Documentation/filesystems> (on older kernels, these files are "
"directly under the I<Documentation> directory, and I<mandatory-locking.txt> "
"is called I<mandatory.txt>)"
msgstr ""
"Linux カーネルソースの I<Documentation/filesystems> ディレクトリにある "
"I<locks.txt> と I<mandatory-locking.txt> (以前のカーネルでは、これらのファイ"
"ルは I<Documentation> ディレクトリ直下にあり、 I<mandatory-locking.txt> は "
"I<mandatory.txt> という名前であった。)"

#. type: TH
#: build/C/man2/mincore.2:34
#, no-wrap
msgid "MINCORE"
msgstr "MINCORE"

#. type: Plain text
#: build/C/man2/mincore.2:37
msgid "mincore - determine whether pages are resident in memory"
msgstr "mincore - ページがメモリー内にあるかどうかを判定する"

#. type: Plain text
#: build/C/man2/mincore.2:41
msgid "B<#include E<lt>sys/mman.hE<gt>>"
msgstr "B<#include E<lt>sys/mman.hE<gt>>"

#. type: Plain text
#: build/C/man2/mincore.2:43
msgid ""
"B<int mincore(void *>I<addr>B<, size_t >I<length>B<, unsigned char "
"*>I<vec>B<);>"
msgstr ""
"B<int mincore(void *>I<addr>B<, size_t >I<length>B<, unsigned char "
"*>I<vec>B<);>"

#. type: Plain text
#: build/C/man2/mincore.2:54
#, no-wrap
msgid ""
"B<mincore>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""
"B<mincore>():\n"
"    glibc 2.19 以降:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 以前:\n"
"        _BSD_SOURCE || _SVID_SOURCE\n"

#. type: Plain text
#: build/C/man2/mincore.2:65
msgid ""
"B<mincore>()  returns a vector that indicates whether pages of the calling "
"process's virtual memory are resident in core (RAM), and so will not cause a "
"disk access (page fault) if referenced.  The kernel returns residency "
"information about the pages starting at the address I<addr>, and continuing "
"for I<length> bytes."
msgstr ""
"B<mincore>()  は、呼び出し元プロセスの仮想メモリーのページがコア (RAM) 内に存"
"在し、 ページ参照時にディスクアクセス (ページフォールト) を起こさないか どう"
"かを示すベクトルを返す。カーネルは、アドレス I<addr> から始まる I<length> バ"
"イトの範囲のページに関する存在情報を返す。"

#. type: Plain text
#: build/C/man2/mincore.2:79
msgid ""
"The I<addr> argument must be a multiple of the system page size.  The "
"I<length> argument need not be a multiple of the page size, but since "
"residency information is returned for whole pages, I<length> is effectively "
"rounded up to the next multiple of the page size.  One may obtain the page "
"size (B<PAGE_SIZE>)  using I<sysconf(_SC_PAGESIZE)>."
msgstr ""
"I<addr> 引数はシステムのページサイズの倍数でなければならない。 I<length> 引"
"数はページサイズの倍数である必要はないが、 ページ全体に関する存在情報が返さ"
"れるので、事実上 I<length> はページサイズの倍数に切り上げられることになる。 "
"ページサイズ (B<PAGE_SIZE>)  は I<sysconf(_SC_PAGESIZE)> を使って入手できる。"

#. type: Plain text
#: build/C/man2/mincore.2:97
msgid ""
"The I<vec> argument must point to an array containing at least I<(length"
"+PAGE_SIZE-1) / PAGE_SIZE> bytes.  On return, the least significant bit of "
"each byte will be set if the corresponding page is currently resident in "
"memory, and be clear otherwise.  (The settings of the other bits in each "
"byte are undefined; these bits are reserved for possible later use.)  Of "
"course the information returned in I<vec> is only a snapshot: pages that are "
"not locked in memory can come and go at any moment, and the contents of "
"I<vec> may already be stale by the time this call returns."
msgstr ""
"I<vec> 引数は、少なくとも I<(length+PAGE_SIZE-1) / PAGE_SIZE> バイトが格納"
"できる配列を指していなければならない。 この呼び出しが返るとき、 各バイトの最"
"下位ビットは、対応するページがメモリー内にそのとき存在すれば セットされ、そう"
"でない場合はクリアされる (各バイトのその他のビットは未定義であり、これらの"
"ビットは将来の使用に そなえて予約されている)。 もちろん、 I<vec> で返された情"
"報はスナップショットでしかない。 メモリー内にロックされていないページは、任意"
"の時点でメモリー内に 入ったり出たりでき、この呼び出しが返るときには I<vec> の"
"内容はすでに古くなっているかもしれない。"

#. type: Plain text
#: build/C/man2/mincore.2:104
msgid ""
"On success, B<mincore>()  returns zero.  On error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""
"成功した場合、 B<mincore>()  は 0 を返す。 エラーの場合は -1 を返して、 "
"I<errno> を適切な値に設定する。"

#. type: Plain text
#: build/C/man2/mincore.2:107
msgid "B<EAGAIN> kernel is temporarily out of resources."
msgstr "B<EAGAIN> カーネルが一時的にリソースを使い果たしている。"

#. type: Plain text
#: build/C/man2/mincore.2:111
msgid "I<vec> points to an invalid address."
msgstr "I<vec> が無効なアドレスを指している。"

#. type: Plain text
#: build/C/man2/mincore.2:115
msgid "I<addr> is not a multiple of the page size."
msgstr "I<addr> がページサイズの倍数でない。"

#. type: Plain text
#: build/C/man2/mincore.2:127
msgid ""
"I<length> is greater than (I<TASK_SIZE> - I<addr>).  (This could occur if a "
"negative value is specified for I<length>, since that value will be "
"interpreted as a large unsigned integer.)  In Linux 2.6.11 and earlier, the "
"error B<EINVAL> was returned for this condition."
msgstr ""
"I<length> が (I<TASK_SIZE> - I<addr>)  より大きい。 (I<length> に負の値が指定"
"された場合、 その値が大きな符号なし整数として解釈されるために起こることがあ"
"る。)  Linux 2.6.11 以前では、この条件の場合はエラー B<EINVAL> が返されてい"
"た。"

#. type: Plain text
#: build/C/man2/mincore.2:135
msgid "I<addr> to I<addr> + I<length> contained unmapped memory."
msgstr ""
"I<addr> から I<addr> + I<length> の間にマップされていないメモリーがあった。"

#. type: Plain text
#: build/C/man2/mincore.2:137
msgid "Available since Linux 2.3.99pre1 and glibc 2.2."
msgstr "Linux 2.3.99pre1 と glibc 2.2 から利用可能である。"

#.  It is on at least NetBSD, FreeBSD, OpenBSD, Solaris 8,
#.  AIX 5.1, SunOS 4.1
#.  .SH HISTORY
#.  The
#.  .BR mincore ()
#.  function first appeared in 4.4BSD.
#. type: Plain text
#: build/C/man2/mincore.2:147
msgid ""
"B<mincore>()  is not specified in POSIX.1, and it is not available on all "
"UNIX implementations."
msgstr "B<mincore>()  は POSIX.1 に記述されておらず、 全ての UNIX 実装で利用可能であるわけではない。"

#.  Linux (up to now, 2.6.5),
#.  .B mincore
#.  does not return correct information for MAP_PRIVATE mappings:
#.  for a MAP_PRIVATE file mapping,
#.  .B mincore
#.  returns the residency of the file pages, rather than any
#.  modified process-private pages that have been copied on write;
#.  for a MAP_PRIVATE mapping of
#.  .IR /dev/zero ,
#.  .B mincore
#.  always reports pages as nonresident;
#.  and for a MAP_PRIVATE, MAP_ANONYMOUS mapping,
#.  .B mincore
#.  always fails with the error
#.  .BR ENOMEM .
#. type: Plain text
#: build/C/man2/mincore.2:169
msgid ""
"Before kernel 2.6.21, B<mincore>()  did not return correct information for "
"B<MAP_PRIVATE> mappings, or for nonlinear mappings (established using "
"B<remap_file_pages>(2))."
msgstr ""
"カーネル 2.6.21 より前は、 B<mincore>()  は、 B<MAP_PRIVATE> マッピングや非線"
"形マッピング (B<remap_file_pages>(2)  を使って作成される) について正しい情報"
"を返さなかった。"

#. type: Plain text
#: build/C/man2/mincore.2:176
msgid ""
"B<fincore>(1), B<madvise>(2), B<mlock>(2), B<mmap>(2), B<posix_fadvise>(2), "
"B<posix_madvise>(3)"
msgstr ""
" B<fincore>(1), B<madvise>(2), B<mlock>(2), B<mmap>(2), B<posix_fadvise>(2), "
"B<posix_madvise>(3)"

#. type: TH
#: build/C/man2/mkdir.2:11
#, no-wrap
msgid "MKDIR"
msgstr "MKDIR"

#. type: Plain text
#: build/C/man2/mkdir.2:14
msgid "mkdir, mkdirat - create a directory"
msgstr "mkdir, mkdirat - ディレクトリを作成する"

#.  .B #include <unistd.h>
#. type: Plain text
#: build/C/man2/mkdir.2:19
#, no-wrap
msgid ""
"B<#include E<lt>sys/stat.hE<gt>>\n"
"B<#include E<lt>sys/types.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/stat.hE<gt>>\n"
"B<#include E<lt>sys/types.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/mkdir.2:21
#, no-wrap
msgid "B<int mkdir(const char *>I<pathname>B<, mode_t >I<mode>B<);>\n"
msgstr "B<int mkdir(const char *>I<pathname>B<, mode_t >I<mode>B<);>\n"

#. type: Plain text
#: build/C/man2/mkdir.2:24
#, no-wrap
msgid ""
"B<#include E<lt>fcntl.hE<gt>           >/* Definition of AT_* constants */\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
msgstr ""
"B<#include E<lt>fcntl.hE<gt>           >/* AT_* 定数の定義 */\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/mkdir.2:26
#, no-wrap
msgid "B<int mkdirat(int >I<dirfd>B<, const char *>I<pathname>B<, mode_t >I<mode>B<);>\n"
msgstr "B<int mkdirat(int >I<dirfd>B<, const char *>I<pathname>B<, mode_t >I<mode>B<);>\n"

#. type: Plain text
#: build/C/man2/mkdir.2:34
msgid "B<mkdirat>():"
msgstr "B<mkdirat>():"

#. type: Plain text
#: build/C/man2/mkdir.2:50
msgid "B<mkdir>()  attempts to create a directory named I<pathname>."
msgstr ""
"B<mkdir>()  は I<pathname> で示される名前のディレクトリを作成しようとする。"

#. type: Plain text
#: build/C/man2/mkdir.2:64
#, fuzzy
#| msgid ""
#| "The argument I<mode> specifies the permissions to use.  It is modified by "
#| "the process's I<umask> in the usual way: the permissions of the created "
#| "directory are (I<mode> & ~I<umask> & 0777).  Other mode bits of the "
#| "created directory depend on the operating system.  For Linux, see below."
msgid ""
"The argument I<mode> specifies the mode for the new directory (see "
"B<inode>(7)).  It is modified by the process's I<umask> in the usual way: in "
"the absence of a default ACL, the mode of the created directory is (I<mode> "
"& \\(tiI<umask> & 0777).  Whether other I<mode> bits are honored for the "
"created directory depends on the operating system.  For Linux, see NOTES "
"below."
msgstr ""
"I<mode> 引数は、作成されたディレクトリの許可属性を決定するのに使われる。 こ"
"の値に、通常通りプロセスの I<umask> による修正が加えられる。 したがって、作成"
"されたディレクトリの許可属性は (I<mode> & ~I<umask> & 0777)  となる。 作成さ"
"れたディレクトリのその他のモードビットはオペレーティングシステムに 依存する。"
"Linux の場合は、以下の通りである。"

#. type: Plain text
#: build/C/man2/mkdir.2:74
msgid ""
"The newly created directory will be owned by the effective user ID of the "
"process.  If the directory containing the file has the set-group-ID bit set, "
"or if the filesystem is mounted with BSD group semantics (I<mount -o "
"bsdgroups> or, synonymously I<mount -o grpid>), the new directory will "
"inherit the group ownership from its parent; otherwise it will be owned by "
"the effective group ID of the process."
msgstr ""
"新しく作成されたディレクトリの所有者はプロセスの実効ユーザー ID に設定され"
"る。 新たに作成されたディレクトリが含まれる親ディレクトリに set group ID ビッ"
"トがセットされていたり、ファイルシステムが BSD の グループセマンティクス "
"(I<mount -o bsdgroups> あるいは、同じ意味の I<mount -o grpid>)  に従ってマウ"
"ントされている場合には、 新たに作成されたディレクトリのグループ所有権は親ディ"
"レクトリの ものが継承される (親ディレクトリと同じになる)。 それ以外の場合は、"
"グループ所有権はプロセスの実効グループ ID となる。"

#. type: Plain text
#: build/C/man2/mkdir.2:79
msgid ""
"If the parent directory has the set-group-ID bit set, then so will the newly "
"created directory."
msgstr ""
"もし親ディレクトリに set group ID ビットがセットされていれば新しく作成される "
"ディレクトリにも set group ID ビットがセットされる。"

#. type: SS
#: build/C/man2/mkdir.2:79
#, no-wrap
msgid "mkdirat()"
msgstr "mkdirat()"

#. type: Plain text
#: build/C/man2/mkdir.2:85
msgid ""
"The B<mkdirat>()  system call operates in exactly the same way as "
"B<mkdir>(), except for the differences described here."
msgstr ""
"B<mkdirat>() システムコールは B<mkdir>() と全く同様に動作するが、以下で説明す"
"る点が異なる。"

#. type: Plain text
#: build/C/man2/mkdir.2:95
msgid ""
"If the pathname given in I<pathname> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<dirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<mkdir>()  for a relative pathname)."
msgstr ""
"I<pathname> で指定されたパス名が相対パスの場合、このパス名はファイルディスク"
"リプター I<dirfd> が参照するディレクトリに対する相対パスと解釈される "
"(B<mkdir>() に相対パス名を渡した場合のように、呼び出したプロセスのカレント"
"ワーキングディレクトリに対する相対パスではない)。"

#. type: Plain text
#: build/C/man2/mkdir.2:107
msgid ""
"If I<pathname> is relative and I<dirfd> is the special value B<AT_FDCWD>, "
"then I<pathname> is interpreted relative to the current working directory of "
"the calling process (like B<mkdir>())."
msgstr ""
"I<pathname> で指定されたパス名が相対パスで、 I<dirfd> が特別な値 B<AT_FDCWD> "
"の場合、 (B<mkdir>() と同様に) I<pathname> は呼び出したプロセスのカレントワー"
"キングディレクトリに対する相対パスと解釈される。"

#. type: Plain text
#: build/C/man2/mkdir.2:118
msgid "See B<openat>(2)  for an explanation of the need for B<mkdirat>()."
msgstr "B<mkdirat>() の必要性についての説明については B<openat>(2) を参照。"

#. type: Plain text
#: build/C/man2/mkdir.2:125
msgid ""
"B<mkdir>()  and B<mkdirat>()  return zero on success, or -1 if an error "
"occurred (in which case, I<errno> is set appropriately)."
msgstr ""
"B<mkdir>() と B<mkdirat>() は成功した場合 0 を、失敗した場合 -1 を返す (ま"
"た、 I<errno> がエラーの内容にしたがって適切に設定される)。"

#. type: Plain text
#: build/C/man2/mkdir.2:134
msgid ""
"The parent directory does not allow write permission to the process, or one "
"of the directories in I<pathname> did not allow search permission.  (See "
"also B<path_resolution>(7).)"
msgstr ""
"プロセスが親ディレクトリへの書き込み許可を持たない、もしくは I<pathname> 中の"
"ディレクトリのどれかに検索許可属性が無い (B<path_resolution>(7)  も参照)。"

#. type: TP
#: build/C/man2/mkdir.2:134
#, no-wrap
msgid "B<EDQUOT>"
msgstr "B<EDQUOT>"

#. type: Plain text
#: build/C/man2/mkdir.2:138
msgid ""
"The user's quota of disk blocks or inodes on the filesystem has been "
"exhausted."
msgstr ""
"ディスクブロックか inode がそのファイルシステムのユーザークォータに達してい"
"た。"

#. type: TP
#: build/C/man2/mkdir.2:138
#, no-wrap
msgid "B<EEXIST>"
msgstr "B<EEXIST>"

#. type: Plain text
#: build/C/man2/mkdir.2:145
msgid ""
"I<pathname> already exists (not necessarily as a directory).  This includes "
"the case where I<pathname> is a symbolic link, dangling or not."
msgstr ""
"I<pathname> が既に存在している(ただしそれがディレクトリであるとは限らない)。 "
"I<pathname> がシンボリックリンクの場合も (その指定先が存在するかどうかに関ら"
"ず)エラーになる。"

#. type: Plain text
#: build/C/man2/mkdir.2:154
msgid ""
"The final component (\"basename\") of the new directory's I<pathname> is "
"invalid (e.g., it contains characters not permitted by the underlying "
"filesystem)."
msgstr ""

#. type: TP
#: build/C/man2/mkdir.2:158
#, no-wrap
msgid "B<EMLINK>"
msgstr "B<EMLINK>"

#. type: Plain text
#: build/C/man2/mkdir.2:162
msgid "The number of links to the parent directory would exceed B<LINK_MAX>."
msgstr "親ディレクトリへのリンク数が B<LINK_MAX> を超えてしまう。"

#. type: Plain text
#: build/C/man2/mkdir.2:165
msgid "I<pathname> was too long."
msgstr "I<pathname> が長すぎる。"

#. type: Plain text
#: build/C/man2/mkdir.2:170
msgid ""
"A directory component in I<pathname> does not exist or is a dangling "
"symbolic link."
msgstr ""
"I<pathname> の構成要素のディレクトリのいずれかが存在しないか、 またはリンク先"
"が存在しないシンボリックリンクである。"

#. type: Plain text
#: build/C/man2/mkdir.2:178
msgid "The device containing I<pathname> has no room for the new directory."
msgstr "I<pathname> を含むデバイスに新たにディレクトリを作成する空きが無い。"

#. type: Plain text
#: build/C/man2/mkdir.2:182
msgid ""
"The new directory cannot be created because the user's disk quota is "
"exhausted."
msgstr ""
"もしくはユーザーのディスク quota が使い切られているため、 新たにディレクトリ"
"を作成することができない。"

#. type: Plain text
#: build/C/man2/mkdir.2:192
msgid ""
"The filesystem containing I<pathname> does not support the creation of "
"directories."
msgstr ""
"I<pathname> を含むファイルシステムがディレクトリの作成をサポートしていない。"

#. type: Plain text
#: build/C/man2/mkdir.2:196
msgid "I<pathname> refers to a file on a read-only filesystem."
msgstr "I<pathname> が読み出し専用ファイルシステム上のファイルを指している。"

#. type: Plain text
#: build/C/man2/mkdir.2:199
msgid "The following additional errors can occur for B<mkdirat>():"
msgstr "B<mkdirat>() では以下のエラーも発生する。"

#. type: Plain text
#: build/C/man2/mkdir.2:213
msgid ""
"B<mkdirat>()  was added to Linux in kernel 2.6.16; library support was added "
"to glibc in version 2.4."
msgstr ""
"B<mkdirat>()  はカーネル 2.6.16 で Linux に追加された。 ライブラリによるサ"
"ポートはバージョン 2.4 で glibc に追加された。"

#.  SVr4 documents additional EIO, EMULTIHOP
#. type: Plain text
#: build/C/man2/mkdir.2:217
msgid "B<mkdir>(): SVr4, BSD, POSIX.1-2001, POSIX.1-2008."
msgstr "B<mkdir>(): SVr4, BSD, POSIX.1-2001, POSIX.1-2008."

#. type: Plain text
#: build/C/man2/mkdir.2:220
msgid "B<mkdirat>(): POSIX.1-2008."
msgstr "B<mkdirat>(): POSIX.1-2008."

#. type: Plain text
#: build/C/man2/mkdir.2:225
msgid ""
"Under Linux, apart from the permission bits, the B<S_ISVTX> I<mode> bit is "
"also honored."
msgstr ""

#. type: Plain text
#: build/C/man2/mkdir.2:229
msgid ""
"There are many infelicities in the protocol underlying NFS.  Some of these "
"affect B<mkdir>()."
msgstr ""
"NFS を実現しているプロトコルには多くの不備が存在し、 それら中には "
"B<mkdir>()  に影響を与えるものもある。"

#. type: Plain text
#: build/C/man2/mkdir.2:242
msgid ""
"On older kernels where B<mkdirat>()  is unavailable, the glibc wrapper "
"function falls back to the use of B<mkdir>().  When I<pathname> is a "
"relative pathname, glibc constructs a pathname based on the symbolic link in "
"I</proc/self/fd> that corresponds to the I<dirfd> argument."
msgstr ""
"B<mkdirat>() が利用できない古いカーネルでは、 glibc ラッパー関数は "
"B<mkdir>() を使用するモードにフォールバックする。 I<pathname> が相対パスの場"
"合、 glibc は I<dirfd> 引数に対応する I</proc/self/fd> のシンボリックリンク"
"に基づいてパス名を構成する。"

#. type: Plain text
#: build/C/man2/mkdir.2:254
msgid ""
"B<mkdir>(1), B<chmod>(2), B<chown>(2), B<mknod>(2), B<mount>(2), "
"B<rmdir>(2), B<stat>(2), B<umask>(2), B<unlink>(2), B<acl>(5), "
"B<path_resolution>(7)"
msgstr ""
" B<mkdir>(1), B<chmod>(2), B<chown>(2), B<mknod>(2), B<mount>(2), "
"B<rmdir>(2), B<stat>(2), B<umask>(2), B<unlink>(2), B<acl>(5), "
"B<path_resolution>(7)"

#. type: TH
#: build/C/man2/nice.2:31
#, no-wrap
msgid "NICE"
msgstr "NICE"

#. type: Plain text
#: build/C/man2/nice.2:34
msgid "nice - change process priority"
msgstr "nice - プロセスの優先度を変更する"

#. type: Plain text
#: build/C/man2/nice.2:38
msgid "B<int nice(int >I<inc>B<);>"
msgstr "B<int nice(int >I<inc>B<);>"

#. type: Plain text
#: build/C/man2/nice.2:48
#, no-wrap
msgid ""
"B<nice>():\n"
"_XOPEN_SOURCE\n"
"    || /* Since glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""
"B<nice>():\n"
"_XOPEN_SOURCE\n"
"    || /* glibc 2.19 以降: */ _DEFAULT_SOURCE\n"
"    || /* glibc 2.19 以前: */ _BSD_SOURCE || _SVID_SOURCE\n"

#. type: Plain text
#: build/C/man2/nice.2:54
msgid ""
"B<nice>()  adds I<inc> to the nice value for the calling thread.  (A higher "
"nice value means a lower priority.)"
msgstr ""

#. type: Plain text
#: build/C/man2/nice.2:57
msgid ""
"The range of the nice value is +19 (low priority) to -20 (high priority).  "
"Attempts to set a nice value outside the range are clamped to the range."
msgstr ""

#. type: Plain text
#: build/C/man2/nice.2:66
msgid ""
"Traditionally, only a privileged process could lower the nice value (i.e., "
"set a higher priority).  However, since Linux 2.6.12, an unprivileged "
"process can decrease the nice value of a target process that has a suitable "
"B<RLIMIT_NICE> soft limit; see B<getrlimit>(2)  for details."
msgstr ""

#. type: Plain text
#: build/C/man2/nice.2:71
msgid ""
"On success, the new nice value is returned (but see NOTES below).  On error, "
"-1 is returned, and I<errno> is set appropriately."
msgstr ""
"成功した場合、新しい nice 値が返る (但し、下記の「注意」を参照)。 失敗した場"
"合 -1 が返り、 I<errno> がエラーの内容に従って設定される。"

#. type: Plain text
#: build/C/man2/nice.2:78
msgid ""
"A successful call can legitimately return -1.  To detect an error, set "
"I<errno> to 0 before the call, and check whether it is nonzero after "
"B<nice>()  returns -1."
msgstr ""

#. type: Plain text
#: build/C/man2/nice.2:92
msgid ""
"The calling process attempted to increase its priority by supplying a "
"negative I<inc> but has insufficient privileges.  Under Linux, the "
"B<CAP_SYS_NICE> capability is required.  (But see the discussion of the "
"B<RLIMIT_NICE> resource limit in B<setrlimit>(2).)"
msgstr ""
"スーパーユーザー以外が I<inc> に負の数値を指定して優先度を上げようとした。 呼"
"び出し元のプロセスが I<inc> に負の数値を指定して優先度を上げようとしたが、 十"
"分な権限を持っていなかった。 Linux では B<CAP_SYS_NICE> ケーパビリティが必要"
"である。 (B<setrlimit>(2)  のリソース上限 B<RLIMIT_NICE> に関する議論も参照の"
"こと)。"

#.  SVr4 documents an additional
#.  .B EINVAL
#.  error code.
#. type: Plain text
#: build/C/man2/nice.2:99
msgid ""
"POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD.  However, the raw system call and "
"(g)libc (earlier than glibc 2.2.4) return value is nonstandard, see below."
msgstr "POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD.  しかし、生のシステムコールと (glibc 2.2.4 より前の) (g)libc では返り値は標準と異なる。 詳細は以下を参照のこと。"

#. type: Plain text
#: build/C/man2/nice.2:102
msgid "For further details on the nice value, see B<sched>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/nice.2:109
msgid ""
"I<Note>: the addition of the \"autogroup\" feature in Linux 2.6.38 means "
"that the nice value no longer has its traditional effect in many "
"circumstances.  For details, see B<sched>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/nice.2:117
#, fuzzy
#| msgid ""
#| "SUSv2 and POSIX.1-2001 specify that B<nice>()  should return the new nice "
#| "value.  However, the Linux syscall and the B<nice>()  library function "
#| "provided in older versions of (g)libc (earlier than glibc 2.2.4) return 0 "
#| "on success.  The new nice value can be found using B<getpriority>(2)."
msgid ""
"POSIX.1 specifies that B<nice>()  should return the new nice value.  "
"However, the raw Linux system call returns 0 on success.  Likewise, the "
"B<nice>()  wrapper function provided in glibc 2.2.3 and earlier returns 0 on "
"success."
msgstr ""
"SUSv2 と POSIX 1003.1-2003 では、 B<nice>()  は新しい nice 値を返すと規定され"
"ている。 一方、Linux システムコールと (2.2.4 より古い) (g)libc ライブラリ関数"
"は 成功時に 0 を返す。新しい nice 値は B<getpriority>(2)  を使って取得でき"
"る。"

#. type: Plain text
#: build/C/man2/nice.2:123
msgid ""
"Since glibc 2.2.4, the B<nice>()  wrapper function provided by glibc "
"provides conformance to POSIX.1 by calling B<getpriority>(2)  to obtain the "
"new nice value, which is then returned to the caller."
msgstr ""

#. type: Plain text
#: build/C/man2/nice.2:132
msgid ""
"B<nice>(1), B<renice>(1), B<fork>(2), B<getpriority>(2), B<getrlimit>(2), "
"B<setpriority>(2), B<capabilities>(7), B<sched>(7)"
msgstr ""
" B<nice>(1), B<renice>(1), B<fork>(2), B<getpriority>(2), B<getrlimit>(2), "
"B<setpriority>(2), B<capabilities>(7), B<sched>(7)"

#. type: TH
#: build/C/man2/pread.2:25
#, no-wrap
msgid "PREAD"
msgstr "PREAD"

#. type: Plain text
#: build/C/man2/pread.2:28
msgid ""
"pread, pwrite - read from or write to a file descriptor at a given offset"
msgstr ""
"pread, pwrite - 指定したオフセットでファイルディスクリプターを読み書きする"

#. type: Plain text
#: build/C/man2/pread.2:33
msgid ""
"B<ssize_t pread(int >I<fd>B<, void *>I<buf>B<, size_t >I<count>B<, off_t "
">I<offset>B<);>"
msgstr ""
"B<ssize_t pread(int >I<fd>B<, void *>I<buf>B<, size_t >I<count>B<, off_t "
">I<offset>B<);>"

#. type: Plain text
#: build/C/man2/pread.2:36
msgid ""
"B<ssize_t pwrite(int >I<fd>B<, const void *>I<buf>B<, size_t >I<count>B<, "
"off_t >I<offset>B<);>"
msgstr ""
"B<ssize_t pwrite(int >I<fd>B<, const void *>I<buf>B<, size_t >I<count>B<, "
"off_t >I<offset>B<);>"

#. type: Plain text
#: build/C/man2/pread.2:46
msgid "B<pread>(), B<pwrite>():"
msgstr "B<pread>(), B<pwrite>():"

#. type: Plain text
#: build/C/man2/pread.2:48
msgid "_XOPEN_SOURCE\\ E<gt>=\\ 500"
msgstr "_XOPEN_SOURCE\\ E<gt>=\\ 500"

#. type: Plain text
#: build/C/man2/pread.2:50
msgid "|| /* Since glibc 2.12: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L"
msgstr "|| /* glibc 2.12 以降: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L"

#. type: Plain text
#: build/C/man2/pread.2:64
msgid ""
"B<pread>()  reads up to I<count> bytes from file descriptor I<fd> at offset "
"I<offset> (from the start of the file) into the buffer starting at I<buf>.  "
"The file offset is not changed."
msgstr ""
"B<pread>()  は、ファイルディスクリプター I<fd> の (ファイルの先頭からの) オフ"
"セット I<offset> から最大 I<count> バイトをバッファー I<buf> へ読み込む。ファ"
"イルオフセットは変化しない。"

#. type: Plain text
#: build/C/man2/pread.2:75
msgid ""
"B<pwrite>()  writes up to I<count> bytes from the buffer starting at I<buf> "
"to the file descriptor I<fd> at offset I<offset>.  The file offset is not "
"changed."
msgstr ""
"B<pwrite>()  は、バッファー I<buf> から最大 I<count> バイトをファイルディスク"
"リプター I<fd> のオフセット I<offset> に書き込む。ファイルオフセットは変化し"
"ない。"

#. type: Plain text
#: build/C/man2/pread.2:79
msgid "The file referenced by I<fd> must be capable of seeking."
msgstr "I<fd> で参照されるファイルはシーク (seek) 可能でなければならない。"

#. type: Plain text
#: build/C/man2/pread.2:87
msgid ""
"On success, B<pread>()  returns the number of bytes read (a return of zero "
"indicates end of file)  and B<pwrite>()  returns the number of bytes written."
msgstr ""

#. type: Plain text
#: build/C/man2/pread.2:93
msgid ""
"Note that it is not an error for a successful call to transfer fewer bytes "
"than requested (see B<read>(2)  and B<write>(2))."
msgstr ""

#. type: Plain text
#: build/C/man2/pread.2:97
msgid ""
"On error, -1 is returned and I<errno> is set to indicate the cause of the "
"error."
msgstr "エラーの時は -1 が返され、 I<errno> にエラーの原因を示す値が設定される。"

#. type: Plain text
#: build/C/man2/pread.2:112
msgid ""
"B<pread>()  can fail and set I<errno> to any error specified for B<read>(2)  "
"or B<lseek>(2).  B<pwrite>()  can fail and set I<errno> to any error "
"specified for B<write>(2)  or B<lseek>(2)."
msgstr ""
"B<pread>()  では、 B<read>(2)  および B<lseek>(2)  で規定された全てのエラーが"
"発生する可能性があり、 I<errno> にはエラーを示す値が設定される。 "
"B<pwrite>()  では、 B<write>(2)  および B<lseek>(2)  で規定された全てのエラー"
"が発生する可能性があり、 I<errno> にはエラーを示す値が設定される。"

#. type: Plain text
#: build/C/man2/pread.2:123
msgid ""
"The B<pread>()  and B<pwrite>()  system calls were added to Linux in version "
"2.1.60; the entries in the i386 system call table were added in 2.1.69.  C "
"library support (including emulation using B<lseek>(2)  on older kernels "
"without the system calls) was added in glibc 2.1."
msgstr ""
"システムコール B<pread>()  と B<pwrite>()  は Linux にバージョン 2.1.60 で追"
"加された。 i386 のシステムコールのエントリーは 2.1.69 で追加された。 (システ"
"ムコールを持たない古いカーネルでの B<lseek>(2)  を使ったエミュレーションを含"
"めると)  C ライブラリにおけるサポートは glibc 2.1 で追加された。"

#. type: Plain text
#: build/C/man2/pread.2:134
msgid ""
"The B<pread>()  and B<pwrite>()  system calls are especially useful in "
"multithreaded applications.  They allow multiple threads to perform I/O on "
"the same file descriptor without being affected by changes to the file "
"offset by other threads."
msgstr ""
"システムコール B<pread>() と B<pwrite>() は、特にマルチスレッドアプリケーショ"
"ンで役に立つ。 これらを使うと、 他のスレッドによるファイルオフセットの変更の"
"影響を受けることなく、 複数のスレッドが同じファイルディスクリプターに対して入"
"出力を行うことができる。"

#. type: Plain text
#: build/C/man2/pread.2:150
msgid ""
"On Linux, the underlying system calls were renamed in kernel 2.6: "
"B<pread>()  became B<pread64>(), and B<pwrite>()  became B<pwrite64>().  The "
"system call numbers remained the same.  The glibc B<pread>()  and "
"B<pwrite>()  wrapper functions transparently deal with the change."
msgstr ""
"Linux では、裏で呼び出されるシステムコールの名前がカーネル 2.6 で変更され"
"た。\n"
"B<pread>() は B<pread64>() になり、 B<pwrite>() は B<pwrite64>() になった。\n"
"システムコールの番号は変更されていない。\n"
"glibc の B<pread>() と B<pwrite>() のラッパー関数はこれらの変更を吸収してい"
"る。"

#. type: Plain text
#: build/C/man2/pread.2:155 build/C/man2/truncate.2:265
msgid ""
"On some 32-bit architectures, the calling signature for these system calls "
"differ, for the reasons described in B<syscall>(2)."
msgstr ""
"いくつかの 32 ビットアーキテクチャーでは、これらのシステムコールの呼び出し時"
"のシグネチャーが違っています。理由は B<syscall>(2) で説明されている通りです。"

#.  FIXME . https://bugzilla.kernel.org/show_bug.cgi?id=43178
#. type: Plain text
#: build/C/man2/pread.2:167
msgid ""
"POSIX requires that opening a file with the B<O_APPEND> flag should have no "
"effect on the location at which B<pwrite>()  writes data.  However, on "
"Linux, if a file is opened with B<O_APPEND>, B<pwrite>()  appends data to "
"the end of the file, regardless of the value of I<offset>."
msgstr ""
"POSIX では、B<O_APPEND> フラグを指定してファイルをオープンした場合、\n"
"B<pwrite>() がデータを書き込む位置に影響を及ぼさないことが\n"
"求められている。しかし、 Linux では、ファイルを B<O_APPEND> 付きで\n"
"オープンした場合、 I<offset> の値に関わらず、\n"
"B<pwrite>() はファイルの末尾にデータを追記する。"

#. type: Plain text
#: build/C/man2/pread.2:172
msgid "B<lseek>(2), B<read>(2), B<readv>(2), B<write>(2)"
msgstr "B<lseek>(2), B<read>(2), B<readv>(2), B<write>(2)"

#. type: TH
#: build/C/man2/set_thread_area.2:9
#, no-wrap
msgid "SET_THREAD_AREA"
msgstr "SET_THREAD_AREA"

#. type: TH
#: build/C/man2/set_thread_area.2:9
#, no-wrap
msgid "2020-02-09"
msgstr " 2020-02-09"

#. type: Plain text
#: build/C/man2/set_thread_area.2:12
msgid ""
"get_thread_area, set_thread_area - manipulate thread-local storage "
"information"
msgstr ""

#. type: Plain text
#: build/C/man2/set_thread_area.2:18
#, no-wrap
msgid ""
"B<#if defined __i386__ || defined __x86_64__>\n"
"B<# include E<lt>asm/ldt.hE<gt>>\n"
msgstr ""
"B<#if defined __i386__ || defined __x86_64__>\n"
"B<# include E<lt>asm/ldt.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/set_thread_area.2:21
#, no-wrap
msgid ""
"B<int get_thread_area(struct user_desc *>I<u_info>B<);>\n"
"B<int set_thread_area(struct user_desc *>I<u_info>B<);>\n"
msgstr ""
" B<int get_thread_area(struct user_desc *>I<u_info>B<);>\n"
"B<int set_thread_area(struct user_desc *>I<u_info>B<);>\n"

#. type: Plain text
#: build/C/man2/set_thread_area.2:23
#, no-wrap
msgid "B<#elif defined __m68k__>\n"
msgstr "B<#elif defined __m68k__>\n"

#. type: Plain text
#: build/C/man2/set_thread_area.2:26
#, no-wrap
msgid ""
"B<int get_thread_area(void);>\n"
"B<int set_thread_area(unsigned long >I<tp>B<);>\n"
msgstr ""
" B<int get_thread_area(void);>\n"
"B<int set_thread_area(unsigned long >I<tp>B<);>\n"

#. type: Plain text
#: build/C/man2/set_thread_area.2:28
#, no-wrap
msgid "B<#elif defined __mips__>\n"
msgstr "B<#elif defined __mips__>\n"

#. type: Plain text
#: build/C/man2/set_thread_area.2:30
#, no-wrap
msgid "B<int set_thread_area(unsigned long >I<addr>B<);>\n"
msgstr " B<int set_thread_area(unsigned long >I<addr>B<);>\n"

#. type: Plain text
#: build/C/man2/set_thread_area.2:32
#, no-wrap
msgid "B<#endif>\n"
msgstr "B<#endif>\n"

#. type: Plain text
#: build/C/man2/set_thread_area.2:36
msgid "I<Note>: There are no glibc wrappers for these system calls; see NOTES."
msgstr "I<注>: これらのシステムコールには glibc のラッパー関数は存在しない。「注意」の節を参照。"

#. type: Plain text
#: build/C/man2/set_thread_area.2:44
msgid ""
"These calls provide architecture-specific support for a thread-local storage "
"implementation.  At the moment, B<set_thread_area>()  is available on m68k, "
"MIPS, and x86 (both 32-bit and 64-bit variants); B<get_thread_area>()  is "
"available on m68k and x86."
msgstr ""

#. type: Plain text
#: build/C/man2/set_thread_area.2:57
msgid ""
"On m68k and MIPS, B<set_thread_area>()  allows storing an arbitrary pointer "
"(provided in the B<tp> argument on m68k and in the B<addr> argument on "
"MIPS)  in the kernel data structure associated with the calling thread; this "
"pointer can later be retrieved using B<get_thread_area>()  (see also NOTES "
"for information regarding obtaining the thread pointer on MIPS)."
msgstr ""

#. type: Plain text
#: build/C/man2/set_thread_area.2:62
msgid ""
"On x86, Linux dedicates three global descriptor table (GDT) entries for "
"thread-local storage.  For more information about the GDT, see the Intel "
"Software Developer's Manual or the AMD Architecture Programming Manual."
msgstr ""

#. type: Plain text
#: build/C/man2/set_thread_area.2:65
msgid ""
"Both of these system calls take an argument that is a pointer to a structure "
"of the following type:"
msgstr ""

#. type: Plain text
#: build/C/man2/set_thread_area.2:82
#, no-wrap
msgid ""
"struct user_desc {\n"
"    unsigned int  entry_number;\n"
"    unsigned int  base_addr;\n"
"    unsigned int  limit;\n"
"    unsigned int  seg_32bit:1;\n"
"    unsigned int  contents:2;\n"
"    unsigned int  read_exec_only:1;\n"
"    unsigned int  limit_in_pages:1;\n"
"    unsigned int  seg_not_present:1;\n"
"    unsigned int  useable:1;\n"
"#ifdef __x86_64__\n"
"    unsigned int  lm:1;\n"
"#endif\n"
"};\n"
msgstr ""
"struct user_desc {\n"
"    unsigned int  entry_number;\n"
"    unsigned int  base_addr;\n"
"    unsigned int  limit;\n"
"    unsigned int  seg_32bit:1;\n"
"    unsigned int  contents:2;\n"
"    unsigned int  read_exec_only:1;\n"
"    unsigned int  limit_in_pages:1;\n"
"    unsigned int  seg_not_present:1;\n"
"    unsigned int  useable:1;\n"
"#ifdef __x86_64__\n"
"    unsigned int  lm:1;\n"
"#endif\n"
"};\n"

#. type: Plain text
#: build/C/man2/set_thread_area.2:90
msgid ""
"B<get_thread_area>()  reads the GDT entry indicated by I<u_info-"
"E<gt>entry_number> and fills in the rest of the fields in I<u_info>."
msgstr ""

#. type: Plain text
#: build/C/man2/set_thread_area.2:93
msgid "B<set_thread_area>()  sets a TLS entry in the GDT."
msgstr ""

#. type: Plain text
#: build/C/man2/set_thread_area.2:104
msgid ""
"The TLS array entry set by B<set_thread_area>()  corresponds to the value of "
"I<u_info-E<gt>entry_number> passed in by the user.  If this value is in "
"bounds, B<set_thread_area>()  writes the TLS descriptor pointed to by "
"I<u_info> into the thread's TLS array."
msgstr "B<set_thread_area>()  により設定される TLS 配列のエントリーは、ユーザーから引数として渡される I<u_info-E<gt>entry_number> の値に対応している。値が範囲内にある場合、 B<set_thread_area>()  は I<u_info> で指された TLS ディスクリプターをスレッドの TLS 配列に書き込む。"

#. type: Plain text
#: build/C/man2/set_thread_area.2:115
msgid ""
"When B<set_thread_area>()  is passed an I<entry_number> of -1, it searches "
"for a free TLS entry.  If B<set_thread_area>()  finds a free TLS entry, the "
"value of I<u_info-E<gt>entry_number> is set upon return to show which entry "
"was changed."
msgstr "I<entry_number> として -1 が渡された場合、 B<set_thread_area>()  は未使用 (free) の TLS エントリーを探す。 未使用の TLS エントリーがあった場合、どのエントリーが変更されたかが分かるように終了時に I<u_info-E<gt>entry_number> の値が変更される。"

#. type: Plain text
#: build/C/man2/set_thread_area.2:127
msgid ""
"A I<user_desc> is considered \"empty\" if I<read_exec_only> and "
"I<seg_not_present> are set to 1 and all of the other fields are 0.  If an "
"\"empty\" descriptor is passed to B<set_thread_area>(), the corresponding "
"TLS entry will be cleared.  See BUGS for additional details."
msgstr ""

#. type: Plain text
#: build/C/man2/set_thread_area.2:132
msgid ""
"Since Linux 3.19, B<set_thread_area>()  cannot be used to write non-present "
"segments, 16-bit segments, or code segments, although clearing a segment is "
"still acceptable."
msgstr ""

#. type: Plain text
#: build/C/man2/set_thread_area.2:137
msgid ""
"On x86, these system calls return 0 on success, and -1 on failure, with "
"I<errno> set appropriately."
msgstr "x86 では、これらのシステムコールは成功した場合 0 を返す。失敗した場合は -1 を返し、 I<errno> を適切に設定する。"

#. type: Plain text
#: build/C/man2/set_thread_area.2:146
msgid ""
"On MIPS and m68k, B<set_thread_area>()  always returns 0.  On m68k, "
"B<get_thread_area>()  returns the thread area pointer value (previously set "
"via B<set_thread_area>())."
msgstr ""

#. type: Plain text
#: build/C/man2/set_thread_area.2:150
msgid "I<u_info> is an invalid pointer."
msgstr "I<u_info> が不正なポインターである。"

#. type: Plain text
#: build/C/man2/set_thread_area.2:153
msgid "I<u_info-E<gt>entry_number> is out of bounds."
msgstr "I<u_info-E<gt>entry_number> が範囲外である。"

#. type: Plain text
#: build/C/man2/set_thread_area.2:159
msgid ""
"B<get_thread_area>()  or B<set_thread_area>()  was invoked as a 64-bit "
"system call."
msgstr ""

#. type: TP
#: build/C/man2/set_thread_area.2:159
#, no-wrap
msgid "B<ESRCH>"
msgstr "B<ESRCH>"

#. type: Plain text
#: build/C/man2/set_thread_area.2:163
msgid "(B<set_thread_area>())  A free TLS entry could not be located."
msgstr "(B<set_thread_area>()) 未使用の TLS エントリーが見つからなかった。"

#. type: Plain text
#: build/C/man2/set_thread_area.2:168
msgid ""
"B<set_thread_area>()  first appeared in Linux 2.5.29.  B<get_thread_area>()  "
"first appeared in Linux 2.5.32."
msgstr "B<set_thread_area>() は Linux 2.5.29 で初めて登場した。 B<get_thread_area>()  は Linux 2.5.32 で初めて登場した。"

#. type: Plain text
#: build/C/man2/set_thread_area.2:174
msgid ""
"B<set_thread_area>()  and B<get_thread_area>()  are Linux-specific and "
"should not be used in programs that are intended to be portable."
msgstr "B<set_thread_area> と B<get_thread_area>() は Linux 独自の関数であり、移植を意図したプログラムでは使用すべきではない。"

#. type: Plain text
#: build/C/man2/set_thread_area.2:179
msgid ""
"Glibc does not provide wrappers for these system calls, since they are "
"generally intended for use only by threading libraries.  In the unlikely "
"event that you want to call them directly, use B<syscall>(2)."
msgstr "これらのシステムコールは通常はスレッドライブラリでのみ使用されることを目的として用意されているため、 glibc はこれらのシステムコールに対するラッパー関数を提供していない。おそらくないと思うが、これらのシステムコールを直接呼び出したい場合は B<syscall>(2) を使うこと。"

#. type: Plain text
#: build/C/man2/set_thread_area.2:190
msgid ""
"B<arch_prctl>(2)  can interfere with B<set_thread_area>()  on x86.  See "
"B<arch_prctl>(2)  for more details.  This is not normally a problem, as "
"B<arch_prctl>(2)  is normally used only by 64-bit programs."
msgstr ""

#. type: Plain text
#: build/C/man2/set_thread_area.2:193
msgid ""
"On MIPS, the current value of the thread area pointer can be obtained using "
"the instruction:"
msgstr ""

#. type: Plain text
#: build/C/man2/set_thread_area.2:197
#, no-wrap
msgid "rdhwr dest, $29\n"
msgstr "rdhwr dest, $29\n"

#. type: Plain text
#: build/C/man2/set_thread_area.2:201
msgid "This instruction traps and is handled by kernel."
msgstr ""

#.  commit e30ab185c490e9a9381385529e0fd32f0a399495
#. type: Plain text
#: build/C/man2/set_thread_area.2:223
msgid ""
"On 64-bit kernels before Linux 3.19, one of the padding bits in "
"I<user_desc>, if set, would prevent the descriptor from being considered "
"empty (see B<modify_ldt>(2)).  As a result, the only reliable way to clear a "
"TLS entry is to use B<memset>(3)  to zero the entire I<user_desc> structure, "
"including padding bits, and then to set the I<read_exec_only> and "
"I<seg_not_present> bits.  On Linux 3.19, a I<user_desc> consisting entirely "
"of zeros except for I<entry_number> will also be interpreted as a request to "
"clear a TLS entry, but this behaved differently on older kernels."
msgstr ""

#. type: Plain text
#: build/C/man2/set_thread_area.2:226
msgid ""
"Prior to Linux 3.19, the DS and ES segment registers must not reference TLS "
"entries."
msgstr ""

#. type: Plain text
#: build/C/man2/set_thread_area.2:231
msgid ""
"B<arch_prctl>(2), B<modify_ldt>(2), B<ptrace>(2)  (B<PTRACE_GET_THREAD_AREA> "
"and B<PTRACE_SET_THREAD_AREA>)"
msgstr "B<arch_prctl>(2), B<modify_ldt>(2), B<ptrace>(2)  (B<PTRACE_GET_THREAD_AREA> と B<PTRACE_SET_THREAD_AREA>)"

#. type: TH
#: build/C/man2/setup.2:34
#, no-wrap
msgid "SETUP"
msgstr "SETUP"

#. type: TH
#: build/C/man2/setup.2:34
#, no-wrap
msgid "2008-12-03"
msgstr "2008-12-03"

#. type: Plain text
#: build/C/man2/setup.2:37
msgid "setup - setup devices and filesystems, mount root filesystem"
msgstr ""
"setup - デバイスとファイルシステムの初期化を行い、 ルートファイルシステムのマ"
"ウントを行う"

#. type: Plain text
#: build/C/man2/setup.2:41
msgid "B<int setup(void);>"
msgstr "B<int setup(void);>"

#. type: Plain text
#: build/C/man2/setup.2:47
msgid ""
"B<setup>()  is called once from within I<linux/init/main.c>.  It calls "
"initialization functions for devices and filesystems configured into the "
"kernel and then mounts the root filesystem."
msgstr ""
"B<setup>()  は I<linux/init/main.c> の中で一度だけ呼ばれる。 カーネル内部のデ"
"バイスとファイルシステムの初期化関数を呼び、 ルートファイルシステムのマウント"
"を行う。"

#. type: Plain text
#: build/C/man2/setup.2:53
msgid ""
"No user process may call B<setup>().  Any user process, even a process with "
"superuser permission, will receive B<EPERM>."
msgstr ""
"ユーザープロセスからは B<setup>()  を呼びだすことはできない。 ユーザープロセ"
"スからのアクセスは、たとえそのプロセスが スーパーユーザー権限を持っていても "
"B<EPERM> を受け取ることになる。"

#. type: Plain text
#: build/C/man2/setup.2:56
msgid "B<setup>()  always returns -1 for a user process."
msgstr "B<setup>()  はユーザープロセスに対して常に -1 を返す。"

#. type: Plain text
#: build/C/man2/setup.2:62
msgid "Since Linux 2.1.121, no such function exists anymore."
msgstr "Linux 2.1.121 以降では、もはやこの関数は存在しない。"

#. type: Plain text
#: build/C/man2/setup.2:65
msgid ""
"This function is Linux-specific, and should not be used in programs intended "
"to be portable, or indeed in any programs at all."
msgstr ""
"この関数は Linux に特有のものであり、移植を考慮したプログラムでは 用いるべき"
"ではない。それどころか、あらゆるプログラムで用いるべきではない。"

#. type: Plain text
#: build/C/man2/setup.2:72
msgid ""
"The calling sequence varied: at some times B<setup>()  has had a single "
"argument I<void\\ *BIOS> and at other times a single argument I<int magic>."
msgstr ""
"呼び出し手続きは変化してきた。 ある時は B<setup>() は一つの引数 I<void\\ "
"*BIOS> を取っており、またある時には I<int magic> を一つの引数として取ってい"
"た。"

#. type: TH
#: build/C/man5/shells.5:28
#, no-wrap
msgid "SHELLS"
msgstr "SHELLS"

#. type: Plain text
#: build/C/man5/shells.5:31
msgid "shells - pathnames of valid login shells"
msgstr "shells - ログインシェルとして有効なファイルのパス名"

#. type: Plain text
#: build/C/man5/shells.5:37
msgid ""
"I</etc/shells> is a text file which contains the full pathnames of valid "
"login shells.  This file is consulted by B<chsh>(1)  and available to be "
"queried by other programs."
msgstr ""
"I</etc/shells> はログインシェルとして有効なファイルのフルパスが書かれた テキ"
"ストファイルである。 B<chsh>(1)  はこのファイルを参照する。 他のプログラムも"
"このファイルを参照できる。"

#. type: Plain text
#: build/C/man5/shells.5:43
msgid ""
"Be aware that there are programs which consult this file to find out if a "
"user is a normal user; for example, FTP daemons traditionally disallow "
"access to users with shells not included in this file."
msgstr ""
"注意して欲しいのだが、プログラムによっては、 ユーザーが通常のユーザーかどうか"
"を判断する際に、このファイルの内容を参考にすることがある。例えば FTP デーモン"
"は、ログインシェルがこのファイルに書かれていないユーザーからのアクセスを許さ"
"ないのが以前から一般的である。"

#. type: Plain text
#: build/C/man5/shells.5:48
msgid "I</etc/shells> may contain the following paths:"
msgstr "I</etc/shells> には以下のようなパスが含まれているだろう。"

#. type: Plain text
#: build/C/man5/shells.5:54
#, no-wrap
msgid ""
"I</bin/sh>\n"
"I</bin/bash>\n"
"I</bin/csh>\n"
msgstr ""
"I</bin/sh>\n"
"I</bin/bash>\n"
"I</bin/csh>\n"

#. type: Plain text
#: build/C/man5/shells.5:60
msgid "B<chsh>(1), B<getusershell>(3), B<pam_shells>(8)"
msgstr " B<chsh>(1), B<getusershell>(3), B<pam_shells>(8)"

#. type: TH
#: build/C/man3/sleep.3:26
#, no-wrap
msgid "SLEEP"
msgstr "SLEEP"

#. type: Plain text
#: build/C/man3/sleep.3:29
msgid "sleep - sleep for a specified number of seconds"
msgstr "sleep - 指定の秒数の間だけ休止する"

#. type: Plain text
#: build/C/man3/sleep.3:34
#, no-wrap
msgid "B<unsigned int sleep(unsigned int >I<seconds>B<);>\n"
msgstr "B<unsigned int sleep(unsigned int >I<seconds>B<);>\n"

#. type: Plain text
#: build/C/man3/sleep.3:41
#, fuzzy
#| msgid ""
#| "B<sleep>()  makes the calling thread sleep until I<seconds> seconds have "
#| "elapsed or a signal arrives which is not ignored."
msgid ""
"B<sleep>()  causes the calling thread to sleep either until the number of "
"real-time seconds specified in I<seconds> have elapsed or until a signal "
"arrives which is not ignored."
msgstr ""
"B<sleep>()  は、呼び出したスレッドを I<seconds> 秒間または無視されないシグナ"
"ルが到着するまで休止する。"

#. type: Plain text
#: build/C/man3/sleep.3:45
msgid ""
"Zero if the requested time has elapsed, or the number of seconds left to "
"sleep, if the call was interrupted by a signal handler."
msgstr ""
"要求された時間が過ぎた場合はゼロを返す。 呼び出しがシグナルハンドラーに割り込"
"まれた場合は、 休止の残り時間を返す。"

#. type: tbl table
#: build/C/man3/sleep.3:55
#, no-wrap
msgid "B<sleep>()"
msgstr "B<sleep>()"

#. type: tbl table
#: build/C/man3/sleep.3:55
#, no-wrap
msgid "MT-Unsafe sig:SIGCHLD/linux"
msgstr "MT-Unsafe sig:SIGCHLD/linux"

#. type: Plain text
#: build/C/man3/sleep.3:68
msgid ""
"On Linux, B<sleep>()  is implemented via B<nanosleep>(2).  See the "
"B<nanosleep>(2)  man page for a discussion of the clock used."
msgstr ""

#. type: SS
#: build/C/man3/sleep.3:68
#, no-wrap
msgid "Portability notes"
msgstr ""

#. type: Plain text
#: build/C/man3/sleep.3:81
#, fuzzy
#| msgid ""
#| "B<sleep>()  may be implemented using B<SIGALRM>; mixing calls to "
#| "B<alarm>(2)  and B<sleep>()  is a bad idea."
msgid ""
"On some systems, B<sleep>()  may be implemented using B<alarm>(2)  and "
"B<SIGALRM> (POSIX.1 permits this); mixing calls to B<alarm>(2)  and "
"B<sleep>()  is a bad idea."
msgstr ""
"B<sleep>()  は B<SIGALRM> を用いて実装されている。そのため、 B<alarm>(2)  と "
"B<sleep>()  を混ぜて使用するのは、まずい考えである。"

#. type: Plain text
#: build/C/man3/sleep.3:87
msgid ""
"Using B<longjmp>(3)  from a signal handler or modifying the handling of "
"B<SIGALRM> while sleeping will cause undefined results."
msgstr ""
"休止中にシグナルハンドラーから B<longjmp>(3)  を使用することや B<SIGALRM> の"
"ハンドリングを変更することは、定義されていない結果を生む。"

#. type: Plain text
#: build/C/man3/sleep.3:93
msgid "B<sleep>(1), B<alarm>(2), B<nanosleep>(2), B<signal>(2), B<signal>(7)"
msgstr " B<sleep>(1), B<alarm>(2), B<nanosleep>(2), B<signal>(2), B<signal>(7)"

#. type: TH
#: build/C/man3/swab.3:31
#, no-wrap
msgid "SWAB"
msgstr "SWAB"

#. type: TH
#: build/C/man3/swab.3:31 build/C/man3/tcgetpgrp.3:25
#, no-wrap
msgid "2015-08-08"
msgstr " 2015-08-08"

#. type: Plain text
#: build/C/man3/swab.3:34
msgid "swab - swap adjacent bytes"
msgstr "swab - 隣接するバイトを交換する"

#. type: Plain text
#: build/C/man3/swab.3:40
#, no-wrap
msgid "B<void swab(const void *>I<from>B<, void *>I<to>B<, ssize_t >I<n>B<);>\n"
msgstr "B<void swab(const void *>I<from>B<, void *>I<to>B<, ssize_t >I<n>B<);>\n"

#. type: Plain text
#: build/C/man3/swab.3:55
msgid ""
"The B<swab>()  function copies I<n> bytes from the array pointed to by "
"I<from> to the array pointed to by I<to>, exchanging adjacent even and odd "
"bytes.  This function is used to exchange data between machines that have "
"different low/high byte ordering."
msgstr ""
"B<swab>()  関数は、I<from> で指された配列から I<n> バイトを I<to> で指された"
"配列に、隣接した偶数/奇数バイトを交換しながらコピーする。 この関数は異なるバ"
"イトオーダーを持つマシン間でのデータ交換に 使用される。"

#. type: Plain text
#: build/C/man3/swab.3:68
msgid ""
"This function does nothing when I<n> is negative.  When I<n> is positive and "
"odd, it handles I<n-1> bytes as above, and does something unspecified with "
"the last byte.  (In other words, I<n> should be even.)"
msgstr ""
"I<n> が負の数の場合、この関数は何もしない。 I<n> が正でかつ奇数の場合、"
"I<n-1> バイトは上記の通り扱い、 最後のバイトについては未規定の動作をする (言"
"い換えれば、I<n> は偶数にするべきである)。"

#. type: Plain text
#: build/C/man3/swab.3:72
msgid "The B<swab>()  function returns no value."
msgstr "B<swab>()  関数は、値を返さない。"

#. type: tbl table
#: build/C/man3/swab.3:82
#, no-wrap
msgid "B<swab>()"
msgstr " B<swab>()"

#. type: Plain text
#: build/C/man3/swab.3:88
msgid "B<bstring>(3)"
msgstr "B<bstring>(3)"

#. type: TH
#: build/C/man2/swapon.2:42
#, no-wrap
msgid "SWAPON"
msgstr "SWAPON"

#. type: Plain text
#: build/C/man2/swapon.2:45
msgid "swapon, swapoff - start/stop swapping to file/device"
msgstr "swapon, swapoff - ファイル/デバイスへのスワップを開始/停止する"

#. type: Plain text
#: build/C/man2/swapon.2:49
msgid "B<#include E<lt>sys/swap.hE<gt>>"
msgstr "B<#include E<lt>sys/swap.hE<gt>>"

#. type: Plain text
#: build/C/man2/swapon.2:51
msgid "B<int swapon(const char *>I<path>B<, int >I<swapflags>B<);>"
msgstr "B<int swapon(const char *>I<path>B<, int >I<swapflags>B<);>"

#. type: Plain text
#: build/C/man2/swapon.2:53
msgid "B<int swapoff(const char *>I<path>B<);>"
msgstr "B<int swapoff(const char *>I<path>B<);>"

#. type: Plain text
#: build/C/man2/swapon.2:60
msgid ""
"B<swapon>()  sets the swap area to the file or block device specified by "
"I<path>.  B<swapoff>()  stops swapping to the file or block device specified "
"by I<path>."
msgstr ""
"B<swapon>()  は I<path> で指定されたファイルやブロックデバイスにスワップ領域"
"を設定する。 B<swapoff>()  は I<path> で指定されたファイルやブロックデバイス"
"へのスワップを停止する。"

#. type: Plain text
#: build/C/man2/swapon.2:70
msgid ""
"If the B<SWAP_FLAG_PREFER> flag is specified in the B<swapon>()  "
"I<swapflags> argument, the new swap area will have a higher priority than "
"default.  The priority is encoded within I<swapflags> as:"
msgstr ""
"B<swapon>() の I<swapflags> 引数に B<SWAP_FLAG_PREFER> フラグが指定された場"
"合、\n"
"新しいスワップ領域はデフォルトよりも高い優先度を持つ。\n"
"優先度は以下のように変換されて I<swapflags> に指定する。"

#. type: Plain text
#: build/C/man2/swapon.2:74
#, no-wrap
msgid "I<(prio E<lt>E<lt> SWAP_FLAG_PRIO_SHIFT) & SWAP_FLAG_PRIO_MASK>\n"
msgstr " I<(prio E<lt>E<lt> SWAP_FLAG_PRIO_SHIFT) & SWAP_FLAG_PRIO_MASK>\n"

#. type: Plain text
#: build/C/man2/swapon.2:87
msgid ""
"If the B<SWAP_FLAG_DISCARD> flag is specified in the B<swapon>()  "
"I<swapflags> argument, freed swap pages will be discarded before they are "
"reused, if the swap device supports the discard or trim operation.  (This "
"may improve performance on some Solid State Devices, but often it does "
"not.)  See also NOTES."
msgstr ""
"B<SWAP_FLAG_DISCARD> フラグが B<swapon>() の I<swapflags> 引数に指定された"
"場合、\n"
"スワップデバイスが破棄 (discard) 操作や trim 操作をサポートしている場合に"
"は、\n"
"解放されたスワップページは再利用される前に破棄される\n"
"(これにより、SSD (Solid State Device) によっては性能が向上することがある"
"が、\n"
"たいていは性能の向上はない)。\n"
"「注意」も参照のこと。"

#. type: Plain text
#: build/C/man2/swapon.2:91
msgid ""
"These functions may be used only by a privileged process (one having the "
"B<CAP_SYS_ADMIN> capability)."
msgstr ""
"これらの関数は特権プロセス (B<CAP_SYS_ADMIN> ケーパビリティ (capability) を持"
"つプロセス) のみが使用できる。"

#. type: SS
#: build/C/man2/swapon.2:91
#, no-wrap
msgid "Priority"
msgstr "優先度"

#. type: Plain text
#: build/C/man2/swapon.2:96
msgid ""
"Each swap area has a priority, either high or low.  The default priority is "
"low.  Within the low-priority areas, newer areas are even lower priority "
"than older areas."
msgstr ""
"それぞれのスワップ領域は高 (high) と低 (low) のどちらかの優先度を持つ。 デ"
"フォルトの優先度は低である。 低い優先度の領域において、新しい領域は古い領域よ"
"りさらに低い 優先度を持つ。"

#. type: Plain text
#: build/C/man2/swapon.2:102
msgid ""
"All priorities set with I<swapflags> are high-priority, higher than "
"default.  They may have any nonnegative value chosen by the caller.  Higher "
"numbers mean higher priority."
msgstr ""
"I<swapflags> が設定されたものは全て高い優先度となり、デフォルトよりも高い優先"
"度を持つ。 使用者はそれらに負でない値が指定できる。 大きな数字は高い優先度を"
"意味する。"

#. type: Plain text
#: build/C/man2/swapon.2:110
msgid ""
"Swap pages are allocated from areas in priority order, highest priority "
"first.  For areas with different priorities, a higher-priority area is "
"exhausted before using a lower-priority area.  If two or more areas have the "
"same priority, and it is the highest priority available, pages are allocated "
"on a round-robin basis between them."
msgstr ""
"高い優先度の領域から順にスワップページとして使用される。 より低い優先度の領域"
"を使用する前により高い優先度の 領域を使い切る。もし二つ以上の領域が同じ優先度"
"を持ち、 使える中で一番高い優先度であれば、それらのページは間で ラウンドロビ"
"ン方式で配分される。"

#. type: Plain text
#: build/C/man2/swapon.2:113
msgid ""
"As of Linux 1.3.6, the kernel usually follows these rules, but there are "
"exceptions."
msgstr ""
"Linux 1.3.6 において、カーネルは通常はこれらの規則に従っている。 しかし例外も"
"存在している。"

#. type: Plain text
#: build/C/man2/swapon.2:126
msgid ""
"(for B<swapon>())  The specified I<path> is already being used as a swap "
"area."
msgstr ""
"(B<swapon>()  において) 指定された I<path> が既にスワップ領域として使用されて"
"いる。"

#. type: Plain text
#: build/C/man2/swapon.2:131
msgid ""
"The file I<path> exists, but refers neither to a regular file nor to a block "
"device;"
msgstr ""
"ファイル I<path> は存在するが、通常のファイルもブロックデバイスも参照していな"
"い。"

#. type: Plain text
#: build/C/man2/swapon.2:137
msgid ""
"(B<swapon>())  The indicated path does not contain a valid swap signature or "
"resides on an in-memory filesystem such as B<tmpfs>(5)."
msgstr "(B<swapon>()) 指定されたパスが有効なスワップの署名 (signature) を含んでいないか、B<tmpfs>(5) のようなインメモリーファイルシステム上にある。"

#. type: TP
#: build/C/man2/swapon.2:137
#, no-wrap
msgid "B<EINVAL> (since Linux 3.4)"
msgstr "B<EINVAL> (Linux 3.4 以降)"

#. type: Plain text
#: build/C/man2/swapon.2:142
msgid "(B<swapon>())  An invalid flag value was specified in I<swapflags>."
msgstr "(B<swapon>()) I<swapflags> に無効なフラグ値が指定された。"

#. type: Plain text
#: build/C/man2/swapon.2:147
msgid "(B<swapoff>())  I<path> is not currently a swap area."
msgstr "(B<swapoff>()) I<path> が現在スワップ領域ではない。"

#. type: Plain text
#: build/C/man2/swapon.2:155
msgid "The file I<path> does not exist."
msgstr "ファイル I<path> が存在しない。"

#. type: Plain text
#: build/C/man2/swapon.2:158
msgid "The system has insufficient memory to start swapping."
msgstr "スワップを開始するのに十分なメモリーがシステムにない。"

#. type: Plain text
#: build/C/man2/swapon.2:165
msgid ""
"The caller does not have the B<CAP_SYS_ADMIN> capability.  Alternatively, "
"the maximum number of swap files are already in use; see NOTES below."
msgstr ""
"使用者が B<CAP_SYS_ADMIN> ケーパビリティを持っていない。 もしくは、最大数のス"
"ワップファイルがすでに使用されている (下記の「注意」の節を参照)。"

#. type: Plain text
#: build/C/man2/swapon.2:171
msgid ""
"These functions are Linux-specific and should not be used in programs "
"intended to be portable.  The second I<swapflags> argument was introduced in "
"Linux 1.3.2."
msgstr ""
"これらの関数は Linux 特有であり、移植を意図したプログラムでは 使用してはいけ"
"ない。 二番目の I<swapflags> 引数は Linux 1.3.2 から導入された。"

#. type: Plain text
#: build/C/man2/swapon.2:174
msgid "The partition or path must be prepared with B<mkswap>(8)."
msgstr ""
"パーティションやパスは B<mkswap>(8)  によって準備されていなければならない。"

#. type: Plain text
#: build/C/man2/swapon.2:194
msgid ""
"There is an upper limit on the number of swap files that may be used, "
"defined by the kernel constant B<MAX_SWAPFILES>.  Before kernel 2.4.10, "
"B<MAX_SWAPFILES> has the value 8; since kernel 2.4.10, it has the value 32.  "
"Since kernel 2.6.18, the limit is decreased by 2 (thus: 30)  if the kernel "
"is built with the B<CONFIG_MIGRATION> option (which reserves two swap table "
"entries for the page migration features of B<mbind>(2)  and "
"B<migrate_pages>(2)).  Since kernel 2.6.32, the limit is further decreased "
"by 1 if the kernel is built with the B<CONFIG_MEMORY_FAILURE> option."
msgstr ""
"使用できるスワップファイルの数には上限があり、その上限は カーネル定数 "
"B<MAX_SWAPFILES> で定義される。 B<MAX_SWAPFILES> の値は、カーネル 2.4.10 より"
"前では 8、 カーネル 2.4.10 以降では 32 である。 カーネル 2.6.18 以降では、"
"カーネルが B<CONFIG_MIGRATION> オプションを有効にして作成された場合、 この上"
"限が 2 少ない値 (つまり 30) となる (このカーネルでは、 B<mbind>(2)  と "
"B<migrate_pages>(2)  のページマイグレーション機能用にスワップテーブルのエント"
"リーが 二つ予約される)。 カーネル 2.6.32 以降では、カーネルが "
"B<CONFIG_MEMORY_FAILURE> オプションを有効にして作成された場合、 この上限がさ"
"らに 1 少ない値となる。"

#.  To be precise: 2.6.35.5
#. type: Plain text
#: build/C/man2/swapon.2:205
msgid ""
"Discard of swap pages was introduced in kernel 2.6.29, then made conditional "
"on the B<SWAP_FLAG_DISCARD> flag in kernel 2.6.36, which still discards the "
"entire swap area when B<swapon>()  is called, even if that flag bit is not "
"set."
msgstr ""
"スワップページの破棄は、カーネル 2.6.29 で導入され、その後カーネル 2.6.36 "
"で\n"
"B<SWAP_FLAG_DISCARD> フラグが指定された場合にだけ実行されるようになったが、\n"
"今でも、このフラグビットが指定されていない場合であっても、\n"
"B<swapon> が呼び出された際にスワップ領域全体の破棄が行われる。"

#. type: Plain text
#: build/C/man2/swapon.2:209
msgid "B<mkswap>(8), B<swapoff>(8), B<swapon>(8)"
msgstr "B<mkswap>(8), B<swapoff>(8), B<swapon>(8)"

#. type: TH
#: build/C/man2/syscall.2:42
#, no-wrap
msgid "SYSCALL"
msgstr "SYSCALL"

#. type: Plain text
#: build/C/man2/syscall.2:45
msgid "syscall - indirect system call"
msgstr "syscall - 間接システムコール"

#. type: Plain text
#: build/C/man2/syscall.2:49
#, no-wrap
msgid ""
"B<#include E<lt>unistd.hE<gt>>\n"
"B<#include E<lt>sys/syscall.hE<gt>   >/* For SYS_xxx definitions */\n"
msgstr ""
"B<#include E<lt>unistd.hE<gt>>\n"
"B<#include E<lt>sys/syscall.hE<gt>   >/* SYS_xxx の定義用 */\n"

#. type: Plain text
#: build/C/man2/syscall.2:51
#, no-wrap
msgid "B<long syscall(long >I<number>B<, ...);>\n"
msgstr "B<long syscall(long >I<number>B<, ...);>\n"

#. type: Plain text
#: build/C/man2/syscall.2:58
msgid "B<syscall>():"
msgstr " B<syscall>():"

#. type: Plain text
#: build/C/man2/syscall.2:64
msgid "_DEFAULT_SOURCE"
msgstr " _DEFAULT_SOURCE"

#. type: TP
#: build/C/man2/syscall.2:64
#, no-wrap
msgid "Before glibc 2.19:"
msgstr "glibc 2.19 より前:"

#. type: Plain text
#: build/C/man2/syscall.2:67
msgid "_BSD_SOURCE || _SVID_SOURCE"
msgstr " _BSD_SOURCE || _SVID_SOURCE"

#. type: Plain text
#: build/C/man2/syscall.2:81
msgid ""
"B<syscall>()  is a small library function that invokes the system call whose "
"assembly language interface has the specified I<number> with the specified "
"arguments.  Employing B<syscall>()  is useful, for example, when invoking a "
"system call that has no wrapper function in the C library."
msgstr ""
"B<syscall>() は、システムコールを起動する小さなライブラリ関数で、 I<number> "
"で指定されたアセンブリ言語インターフェースのシステムコールを、指定された引"
"数をつけて実行する。 B<syscall>() が役に立つのは、例えば C ライブラリにラッ"
"パー関数が存在しないシステムコールを呼び出したい場合である。"

#. type: Plain text
#: build/C/man2/syscall.2:87
msgid ""
"B<syscall>()  saves CPU registers before making the system call, restores "
"the registers upon return from the system call, and stores any error "
"returned by the system call in B<errno>(3)."
msgstr "B<syscall>() は、システムコールを行う前に CPU レジスターを保存し、システムコールから返った際にレジスターを復元し、システムコールが返したエラーを B<errno>(3) に格納する。"

#. type: Plain text
#: build/C/man2/syscall.2:90
msgid ""
"Symbolic constants for system call numbers can be found in the header file "
"I<E<lt>sys/syscall.hE<gt>>."
msgstr ""
"システムコールのシンボル定数は、ヘッダーファイル I<E<lt>sys/syscall.hE<gt>> "
"に書かれている。"

#. type: Plain text
#: build/C/man2/syscall.2:96
msgid ""
"The return value is defined by the system call being invoked.  In general, a "
"0 return value indicates success.  A -1 return value indicates an error, and "
"an error number is stored in I<errno>."
msgstr "返り値は呼び出されたシステムコールによって定義される。 一般に、返り値 0 は成功を表す。 -1 はエラーを表し、エラー番号は I<errno> に入れられる。"

#. type: Plain text
#: build/C/man2/syscall.2:100
msgid "B<syscall>()  first appeared in 4BSD."
msgstr "B<syscall>()  は 4BSD で最初に登場した。"

#. type: SS
#: build/C/man2/syscall.2:100
#, no-wrap
msgid "Architecture-specific requirements"
msgstr "アーキテクチャー固有の要件"

#. type: Plain text
#: build/C/man2/syscall.2:111
msgid ""
"Each architecture ABI has its own requirements on how system call arguments "
"are passed to the kernel.  For system calls that have a glibc wrapper (e.g., "
"most system calls), glibc handles the details of copying arguments to the "
"right registers in a manner suitable for the architecture.  However, when "
"using B<syscall>()  to make a system call, the caller might need to handle "
"architecture-dependent details; this requirement is most commonly "
"encountered on certain 32-bit architectures."
msgstr ""
"各アーキテクチャーの ABI には、 システムコールの引数のカーネルへの渡し方に"
"関する独自の要件がある。\n"
"(ほとんどのシステムコールのように) glibc ラッパー関数があるシステムコールで"
"は、 glibc が詳細を処理し、アーキテクチャーに応じた方法で引数が適切なレジス"
"ターにコピーされる。 しかし、 システムコールを呼び出すのに B<syscall>() を使"
"う場合には、 呼び出し側でアーキテクチャー依存の詳細を処理しなければならない場"
"合がある。 これはいくつかの 32 ビットアーキテクチャーでは非常によくあること"
"だ。"

#. type: Plain text
#: build/C/man2/syscall.2:123
#, fuzzy
#| msgid ""
#| "For example, on the ARM architecture Embedded ABI (EABI), a 64-bit value "
#| "(e.g., I<long long>)  must be aligned to an even register pair.  Thus, "
#| "using B<syscall>()  instead of the wrapper provided by glibc, the "
#| "B<readahead>()  system call would be invoked as follows on the ARM "
#| "architecture with the EABI:"
msgid ""
"For example, on the ARM architecture Embedded ABI (EABI), a 64-bit value (e."
"g., I<long long>)  must be aligned to an even register pair.  Thus, using "
"B<syscall>()  instead of the wrapper provided by glibc, the B<readahead>(2)  "
"system call would be invoked as follows on the ARM architecture with the "
"EABI in little endian mode:"
msgstr ""
"例えば、ARM アーキテクチャーの Embedded ABI (EABI) では、 (I<long long> など"
"の) 64 ビット値は偶数番地のレジスターのペアに境界があっていなければならない。"
"したがって、 glibc が提供するラッパー関数ではなく B<syscall>() を使う場合に"
"は、 B<readahead>() システムコールは ARM アーキテクチャーの EABI では以下のよ"
"うにして起動されることになる。"

#. type: Plain text
#: build/C/man2/syscall.2:130
#, no-wrap
msgid ""
"syscall(SYS_readahead, fd, 0,\n"
"        (unsigned int) (offset & 0xFFFFFFFF),\n"
"        (unsigned int) (offset E<gt>E<gt> 32),\n"
"        count);\n"
msgstr ""
" syscall(SYS_readahead, fd, 0,\n"
"        (unsigned int) (offset & 0xFFFFFFFF),\n"
"        (unsigned int) (offset E<gt>E<gt> 32),\n"
"        count);\n"

#. type: Plain text
#: build/C/man2/syscall.2:146
#, fuzzy
#| msgid ""
#| "Since the offset argument is 64 bits, and the first argument (I<fd>)  is "
#| "passed in I<r0>, the caller must manually split and align the 64-bit "
#| "value so that it is passed in the I<r2>/I<r3> register pair.  That means "
#| "inserting a dummy value into I<r1> (the second argument of 0)."
msgid ""
"Since the offset argument is 64 bits, and the first argument (I<fd>)  is "
"passed in I<r0>, the caller must manually split and align the 64-bit value "
"so that it is passed in the I<r2>/I<r3> register pair.  That means inserting "
"a dummy value into I<r1> (the second argument of 0).  Care also must be "
"taken so that the split follows endian conventions (according to the C ABI "
"for the platform)."
msgstr ""
"オフセット引数は 64 ビットで、最初の引数 (I<fd>) は I<r0> で渡されるの"
"で、呼び出し側では手動で 64 ビット値を分割して境界を合わせて、 64 ビット値が "
"I<r2>/I<r3> レジスターペアで渡されるようにしなければならない。このため、 "
"I<r1> (2 番目の引数 0) としてダミー値を挿入している。"

#.  Mike Frysinger: this issue ends up forcing MIPS
#.  O32 to take 7 arguments to syscall()
#. type: Plain text
#: build/C/man2/syscall.2:151
#, fuzzy
#| msgid ""
#| "Similar issues can occur on MIPS with the O32 ABI, on PowerPC with the 32-"
#| "bit ABI, and on Xtensa."
msgid ""
"Similar issues can occur on MIPS with the O32 ABI, on PowerPC and parisc "
"with the 32-bit ABI, and on Xtensa."
msgstr ""
"同様のことが、 MIPS の O32 ABI、 PowerPC の 32 ビット ABI や Xtensa でも起こ"
"りうる。"

#.  See arch/parisc/kernel/sys_parisc.c.
#. type: Plain text
#: build/C/man2/syscall.2:155
msgid ""
"Note that while the parisc C ABI also uses aligned register pairs, it uses a "
"shim layer to hide the issue from user space."
msgstr ""

#. type: Plain text
#: build/C/man2/syscall.2:166
msgid ""
"The affected system calls are B<fadvise64_64>(2), B<ftruncate64>(2), "
"B<posix_fadvise>(2), B<pread64>(2), B<pwrite64>(2), B<readahead>(2), "
"B<sync_file_range>(2), and B<truncate64>(2)."
msgstr ""
"次のシステムコールに影響がある: B<fadvise64_64>(2), B<ftruncate64>(2), "
"B<posix_fadvise>(2), B<pread64>(2), B<pwrite64>(2), B<readahead>(2), "
"B<sync_file_range>(2), B<truncate64>(2)"

#.  You need to look up the syscalls directly in the kernel source to see if
#.  they should be in this list.  For example, look at fs/read_write.c and
#.  the function signatures that do:
#.  ..., unsigned long, pos_l, unsigned long, pos_h, ...
#.  If they use off_t, then they most likely do not belong in this list.
#. type: Plain text
#: build/C/man2/syscall.2:181
msgid ""
"This does not affect syscalls that manually split and assemble 64-bit values "
"such as B<_llseek>(2), B<preadv>(2), B<preadv2>(2), B<pwritev>(2), and "
"B<pwritev2>(2).  Welcome to the wonderful world of historical baggage."
msgstr ""

#. type: SS
#: build/C/man2/syscall.2:181
#, no-wrap
msgid "Architecture calling conventions"
msgstr "アーキテクチャー毎の呼び出し規約"

#. type: Plain text
#: build/C/man2/syscall.2:185
msgid ""
"Every architecture has its own way of invoking and passing arguments to the "
"kernel.  The details for various architectures are listed in the two tables "
"below."
msgstr ""
"各アーキテクチャーには、それぞれ独自のシステムコール起動方法とカーネルへの引"
"数の渡し方がある。 各種のアーキテクチャーの詳細を以下の 2 つの表にまとめ"
"る。"

#. type: Plain text
#: build/C/man2/syscall.2:193
#, fuzzy
#| msgid ""
#| "The first table lists the instruction used to transition to kernel mode, "
#| "(which might not be the fastest or best way to transition to the kernel, "
#| "so you might have to refer to B<vdso>(7)), the register used to indicate "
#| "the system call number, and the register used to return the system call "
#| "result."
msgid ""
"The first table lists the instruction used to transition to kernel mode "
"(which might not be the fastest or best way to transition to the kernel, so "
"you might have to refer to B<vdso>(7)), the register used to indicate the "
"system call number, the register(s) used to return the system call result, "
"and the register used to signal an error."
msgstr ""
"最初の表は、 カーネルモードに遷移するのに使用される命令、 システムコール番号"
"を示すのに使用されるレジスター、 システムコールの結果を返すのに使用されるレジ"
"スターの一覧である (なお、 ここに載っているカーネルモードに遷移するのに使用さ"
"れる命令は、 カーネルモードに遷移する最速や最善の方法でない場合もあるので、 "
"B<vdso>(7) を参照する必要があるかもしれない)。"

#. type: tbl table
#: build/C/man2/syscall.2:198 build/C/man2/syscall.2:330
#, no-wrap
msgid "Arch/ABI"
msgstr " Arch/ABI"

#. type: tbl table
#: build/C/man2/syscall.2:198
#, fuzzy, no-wrap
#| msgid "instruction"
msgid "Instruction"
msgstr "instruction"

#. type: tbl table
#: build/C/man2/syscall.2:198
#, fuzzy, no-wrap
#| msgid "B<System call>"
msgid "System"
msgstr "B<System call>"

#. type: tbl table
#: build/C/man2/syscall.2:198
#, no-wrap
msgid "Ret"
msgstr ""

#. type: tbl table
#: build/C/man2/syscall.2:198
#, no-wrap
msgid "Error"
msgstr ""

#. type: tbl table
#: build/C/man2/syscall.2:198 build/C/man2/syscall.2:330
#, no-wrap
msgid "Notes"
msgstr "備考"

#. type: tbl table
#: build/C/man2/syscall.2:199
#, fuzzy, no-wrap
#| msgid "syscall #"
msgid "call #"
msgstr "syscall #"

#. type: tbl table
#: build/C/man2/syscall.2:199
#, fuzzy, no-wrap
#| msgid "I<val>"
msgid "val"
msgstr "I<val>"

#. type: tbl table
#: build/C/man2/syscall.2:199
#, no-wrap
msgid "val2"
msgstr ""

#. type: tbl table
#: build/C/man2/syscall.2:201 build/C/man2/syscall.2:332
#, no-wrap
msgid "alpha"
msgstr "alpha"

#. type: tbl table
#: build/C/man2/syscall.2:201
#, no-wrap
msgid "callsys"
msgstr "callsys"

#. type: tbl table
#: build/C/man2/syscall.2:201 build/C/man2/syscall.2:211
#, no-wrap
msgid "v0"
msgstr "v0"

#. type: tbl table
#: build/C/man2/syscall.2:201 build/C/man2/syscall.2:332
#: build/C/man2/syscall.2:343 build/C/man2/syscall.2:348
#: build/C/man2/syscall.2:357
#, no-wrap
msgid "a4"
msgstr "a4"

#. type: tbl table
#: build/C/man2/syscall.2:201 build/C/man2/syscall.2:211
#: build/C/man2/syscall.2:332 build/C/man2/syscall.2:342
#: build/C/man2/syscall.2:343 build/C/man2/syscall.2:348
#: build/C/man2/syscall.2:357
#, no-wrap
msgid "a3"
msgstr "a3"

#. type: tbl table
#: build/C/man2/syscall.2:201 build/C/man2/syscall.2:208
#: build/C/man2/syscall.2:211 build/C/man2/syscall.2:220
#: build/C/man2/syscall.2:221
#, no-wrap
msgid "1, 6"
msgstr "1, 6"

#. type: tbl table
#: build/C/man2/syscall.2:202 build/C/man2/syscall.2:333
#, no-wrap
msgid "arc"
msgstr "arc"

#. type: tbl table
#: build/C/man2/syscall.2:202
#, no-wrap
msgid "trap0"
msgstr "trap0"

#. type: tbl table
#: build/C/man2/syscall.2:202 build/C/man2/syscall.2:208
#: build/C/man2/syscall.2:341 build/C/man2/syscall.2:344
#: build/C/man2/syscall.2:346 build/C/man2/syscall.2:347
#: build/C/man2/syscall.2:355 build/C/man2/syscall.2:356
#, no-wrap
msgid "r8"
msgstr "r8"

#. type: tbl table
#: build/C/man2/syscall.2:202 build/C/man2/syscall.2:203
#: build/C/man2/syscall.2:204 build/C/man2/syscall.2:214
#: build/C/man2/syscall.2:215 build/C/man2/syscall.2:219
#: build/C/man2/syscall.2:333 build/C/man2/syscall.2:334
#: build/C/man2/syscall.2:335 build/C/man2/syscall.2:351
#, no-wrap
msgid "r0"
msgstr "r0"

#. type: tbl table
#: build/C/man2/syscall.2:202 build/C/man2/syscall.2:203
#: build/C/man2/syscall.2:204 build/C/man2/syscall.2:205
#: build/C/man2/syscall.2:206 build/C/man2/syscall.2:207
#: build/C/man2/syscall.2:209 build/C/man2/syscall.2:210
#: build/C/man2/syscall.2:212 build/C/man2/syscall.2:213
#: build/C/man2/syscall.2:214 build/C/man2/syscall.2:215
#: build/C/man2/syscall.2:216 build/C/man2/syscall.2:217
#: build/C/man2/syscall.2:218 build/C/man2/syscall.2:219
#: build/C/man2/syscall.2:222 build/C/man2/syscall.2:223
#: build/C/man2/syscall.2:224 build/C/man2/syscall.2:225
#: build/C/man2/syscall.2:332 build/C/man2/syscall.2:333
#: build/C/man2/syscall.2:336 build/C/man2/syscall.2:337
#: build/C/man2/syscall.2:338 build/C/man2/syscall.2:339
#: build/C/man2/syscall.2:340 build/C/man2/syscall.2:341
#: build/C/man2/syscall.2:342 build/C/man2/syscall.2:343
#: build/C/man2/syscall.2:344 build/C/man2/syscall.2:345
#: build/C/man2/syscall.2:347 build/C/man2/syscall.2:348
#: build/C/man2/syscall.2:349 build/C/man2/syscall.2:350
#: build/C/man2/syscall.2:352 build/C/man2/syscall.2:353
#: build/C/man2/syscall.2:354 build/C/man2/syscall.2:355
#: build/C/man2/syscall.2:356 build/C/man2/syscall.2:357
#, no-wrap
msgid "-"
msgstr "-"

#. type: tbl table
#: build/C/man2/syscall.2:203 build/C/man2/syscall.2:334
#, no-wrap
msgid "arm/OABI"
msgstr "arm/OABI"

#. type: tbl table
#: build/C/man2/syscall.2:203
#, no-wrap
msgid "swi NR"
msgstr "swi NR"

#. type: tbl table
#: build/C/man2/syscall.2:203
#, no-wrap
msgid "2"
msgstr " 2"

#. type: tbl table
#: build/C/man2/syscall.2:204 build/C/man2/syscall.2:335
#, no-wrap
msgid "arm/EABI"
msgstr "arm/EABI"

#. type: tbl table
#: build/C/man2/syscall.2:204
#, no-wrap
msgid "swi 0x0"
msgstr "swi 0x0"

#. type: tbl table
#: build/C/man2/syscall.2:204 build/C/man2/syscall.2:212
#: build/C/man2/syscall.2:341 build/C/man2/syscall.2:344
#: build/C/man2/syscall.2:346 build/C/man2/syscall.2:347
#: build/C/man2/syscall.2:349 build/C/man2/syscall.2:350
#: build/C/man2/syscall.2:351
#, no-wrap
msgid "r7"
msgstr "r7"

#. type: tbl table
#: build/C/man2/syscall.2:204 build/C/man2/syscall.2:217
#: build/C/man2/syscall.2:218 build/C/man2/syscall.2:219
#: build/C/man2/syscall.2:333 build/C/man2/syscall.2:334
#: build/C/man2/syscall.2:335 build/C/man2/syscall.2:351
#, no-wrap
msgid "r1"
msgstr "r1"

#. type: tbl table
#: build/C/man2/syscall.2:205 build/C/man2/syscall.2:336
#, no-wrap
msgid "arm64"
msgstr "arm64"

#. type: tbl table
#: build/C/man2/syscall.2:205
#, no-wrap
msgid "svc #0"
msgstr "svc #0"

#. type: tbl table
#: build/C/man2/syscall.2:205
#, no-wrap
msgid "w8"
msgstr "w8"

#. type: tbl table
#: build/C/man2/syscall.2:205 build/C/man2/syscall.2:336
#, no-wrap
msgid "x0"
msgstr "x0"

#. type: tbl table
#: build/C/man2/syscall.2:205 build/C/man2/syscall.2:336
#, no-wrap
msgid "x1"
msgstr "x1"

#. type: tbl table
#: build/C/man2/syscall.2:206 build/C/man2/syscall.2:337
#, no-wrap
msgid "blackfin"
msgstr "blackfin"

#. type: tbl table
#: build/C/man2/syscall.2:206
#, no-wrap
msgid "excpt 0x0"
msgstr "excpt 0x0"

#. type: tbl table
#: build/C/man2/syscall.2:206
#, no-wrap
msgid "P0"
msgstr "P0"

#. type: tbl table
#: build/C/man2/syscall.2:206 build/C/man2/syscall.2:337
#, no-wrap
msgid "R0"
msgstr "R0"

#. type: tbl table
#: build/C/man2/syscall.2:207 build/C/man2/syscall.2:338
#, no-wrap
msgid "i386"
msgstr "i386"

#. type: tbl table
#: build/C/man2/syscall.2:207
#, no-wrap
msgid "int $0x80"
msgstr "int $0x80"

#. type: tbl table
#: build/C/man2/syscall.2:207
#, no-wrap
msgid "eax"
msgstr "eax"

#. type: tbl table
#: build/C/man2/syscall.2:207 build/C/man2/syscall.2:338
#, no-wrap
msgid "edx"
msgstr "edx"

#. type: tbl table
#: build/C/man2/syscall.2:208 build/C/man2/syscall.2:339
#, no-wrap
msgid "ia64"
msgstr "ia64"

#. type: tbl table
#: build/C/man2/syscall.2:208
#, no-wrap
msgid "break 0x100000"
msgstr "break 0x100000"

#. type: tbl table
#: build/C/man2/syscall.2:208
#, no-wrap
msgid "r15"
msgstr "r15"

#. type: tbl table
#: build/C/man2/syscall.2:208 build/C/man2/syscall.2:341
#: build/C/man2/syscall.2:344 build/C/man2/syscall.2:346
#: build/C/man2/syscall.2:355 build/C/man2/syscall.2:356
#, no-wrap
msgid "r9"
msgstr "r9"

#. type: tbl table
#: build/C/man2/syscall.2:208 build/C/man2/syscall.2:341
#: build/C/man2/syscall.2:355 build/C/man2/syscall.2:356
#, no-wrap
msgid "r10"
msgstr "r10"

#. type: tbl table
#: build/C/man2/syscall.2:209 build/C/man2/syscall.2:340
#, no-wrap
msgid "m68k"
msgstr "m68k"

#. type: tbl table
#: build/C/man2/syscall.2:209
#, no-wrap
msgid "trap #0"
msgstr "trap #0"

#. type: tbl table
#: build/C/man2/syscall.2:209
#, no-wrap
msgid "d0"
msgstr "d0"

#. type: tbl table
#: build/C/man2/syscall.2:210 build/C/man2/syscall.2:341
#, no-wrap
msgid "microblaze"
msgstr "microblaze"

#. type: tbl table
#: build/C/man2/syscall.2:210
#, no-wrap
msgid "brki r14,8"
msgstr "brki r14,8"

#. type: tbl table
#: build/C/man2/syscall.2:210
#, no-wrap
msgid "r12"
msgstr " r12"

#. type: tbl table
#: build/C/man2/syscall.2:210 build/C/man2/syscall.2:214
#: build/C/man2/syscall.2:215 build/C/man2/syscall.2:217
#: build/C/man2/syscall.2:218 build/C/man2/syscall.2:219
#: build/C/man2/syscall.2:333 build/C/man2/syscall.2:334
#: build/C/man2/syscall.2:335 build/C/man2/syscall.2:346
#: build/C/man2/syscall.2:347 build/C/man2/syscall.2:349
#: build/C/man2/syscall.2:350
#, no-wrap
msgid "r3"
msgstr "r3"

#. type: tbl table
#: build/C/man2/syscall.2:211
#, no-wrap
msgid "mips"
msgstr "mips"

#. type: tbl table
#: build/C/man2/syscall.2:211 build/C/man2/syscall.2:223
#: build/C/man2/syscall.2:224 build/C/man2/syscall.2:225
#, no-wrap
msgid "syscall"
msgstr "syscall"

#. type: tbl table
#: build/C/man2/syscall.2:211
#, no-wrap
msgid "v1"
msgstr "v1"

#. type: tbl table
#: build/C/man2/syscall.2:212 build/C/man2/syscall.2:344
#, no-wrap
msgid "nios2"
msgstr "nios2"

#. type: tbl table
#: build/C/man2/syscall.2:212
#, no-wrap
msgid "trap"
msgstr "trap"

#. type: tbl table
#: build/C/man2/syscall.2:212 build/C/man2/syscall.2:217
#: build/C/man2/syscall.2:218 build/C/man2/syscall.2:333
#: build/C/man2/syscall.2:334 build/C/man2/syscall.2:335
#: build/C/man2/syscall.2:349 build/C/man2/syscall.2:350
#: build/C/man2/syscall.2:351
#, no-wrap
msgid "r2"
msgstr "r2"

#. type: tbl table
#: build/C/man2/syscall.2:213 build/C/man2/syscall.2:345
#, no-wrap
msgid "parisc"
msgstr "parisc"

#. type: tbl table
#: build/C/man2/syscall.2:213
#, no-wrap
msgid "ble 0x100(%sr2, %r0)"
msgstr "ble 0x100(%sr2, %r0)"

#. type: tbl table
#: build/C/man2/syscall.2:213
#, no-wrap
msgid "r20"
msgstr "r20"

#. type: tbl table
#: build/C/man2/syscall.2:213
#, no-wrap
msgid "r28"
msgstr "r28"

#. type: tbl table
#: build/C/man2/syscall.2:214 build/C/man2/syscall.2:346
#, no-wrap
msgid "powerpc"
msgstr "powerpc"

#. type: tbl table
#: build/C/man2/syscall.2:214 build/C/man2/syscall.2:215
#, no-wrap
msgid "sc"
msgstr "sc"

#. type: tbl table
#: build/C/man2/syscall.2:214 build/C/man2/syscall.2:215
#: build/C/man2/syscall.2:222 build/C/man2/syscall.2:342
#, no-wrap
msgid "1"
msgstr " 1"

#. type: tbl table
#: build/C/man2/syscall.2:215 build/C/man2/syscall.2:347
#, no-wrap
msgid "powerpc64"
msgstr "powerpc64"

#. type: tbl table
#: build/C/man2/syscall.2:215
#, no-wrap
msgid "cr0.SO"
msgstr "cr0.SO"

#. type: tbl table
#: build/C/man2/syscall.2:216 build/C/man2/syscall.2:348
#, no-wrap
msgid "riscv"
msgstr " riscv"

#. type: tbl table
#: build/C/man2/syscall.2:216
#, no-wrap
msgid "ecall"
msgstr " ecall"

#. type: tbl table
#: build/C/man2/syscall.2:216
#, no-wrap
msgid "a7"
msgstr " a7"

#. type: tbl table
#: build/C/man2/syscall.2:216 build/C/man2/syscall.2:332
#: build/C/man2/syscall.2:340 build/C/man2/syscall.2:342
#: build/C/man2/syscall.2:343 build/C/man2/syscall.2:348
#, no-wrap
msgid "a0"
msgstr "a0"

#. type: tbl table
#: build/C/man2/syscall.2:216 build/C/man2/syscall.2:332
#: build/C/man2/syscall.2:342 build/C/man2/syscall.2:343
#: build/C/man2/syscall.2:348
#, no-wrap
msgid "a1"
msgstr "a1"

#. type: tbl table
#: build/C/man2/syscall.2:217 build/C/man2/syscall.2:349
#, no-wrap
msgid "s390"
msgstr "s390"

#. type: tbl table
#: build/C/man2/syscall.2:217 build/C/man2/syscall.2:218
#, no-wrap
msgid "svc 0"
msgstr "svc 0"

#. type: tbl table
#: build/C/man2/syscall.2:217 build/C/man2/syscall.2:218
#, no-wrap
msgid "3"
msgstr " 3"

#. type: tbl table
#: build/C/man2/syscall.2:218 build/C/man2/syscall.2:350
#, no-wrap
msgid "s390x"
msgstr "s390x"

#. type: tbl table
#: build/C/man2/syscall.2:219 build/C/man2/syscall.2:351
#, no-wrap
msgid "superh"
msgstr "superh"

#. type: tbl table
#: build/C/man2/syscall.2:219
#, no-wrap
msgid "trap #0x17"
msgstr "trap #0x17"

#. type: tbl table
#: build/C/man2/syscall.2:219
#, no-wrap
msgid "4, 6"
msgstr "4, 6"

#. type: tbl table
#: build/C/man2/syscall.2:220 build/C/man2/syscall.2:352
#, no-wrap
msgid "sparc/32"
msgstr "sparc/32"

#. type: tbl table
#: build/C/man2/syscall.2:220
#, no-wrap
msgid "t 0x10"
msgstr "t 0x10"

#. type: tbl table
#: build/C/man2/syscall.2:220 build/C/man2/syscall.2:221
#, no-wrap
msgid "g1"
msgstr "g1"

#. type: tbl table
#: build/C/man2/syscall.2:220 build/C/man2/syscall.2:221
#: build/C/man2/syscall.2:352 build/C/man2/syscall.2:353
#, no-wrap
msgid "o0"
msgstr "o0"

#. type: tbl table
#: build/C/man2/syscall.2:220 build/C/man2/syscall.2:221
#: build/C/man2/syscall.2:352 build/C/man2/syscall.2:353
#, no-wrap
msgid "o1"
msgstr "o1"

#. type: tbl table
#: build/C/man2/syscall.2:220 build/C/man2/syscall.2:221
#, no-wrap
msgid "psr/csr"
msgstr "psr/csr"

#. type: tbl table
#: build/C/man2/syscall.2:221 build/C/man2/syscall.2:353
#, no-wrap
msgid "sparc/64"
msgstr "sparc/64"

#. type: tbl table
#: build/C/man2/syscall.2:221
#, no-wrap
msgid "t 0x6d"
msgstr "t 0x6d"

#. type: tbl table
#: build/C/man2/syscall.2:222 build/C/man2/syscall.2:354
#, no-wrap
msgid "tile"
msgstr "tile"

#. type: tbl table
#: build/C/man2/syscall.2:222
#, no-wrap
msgid "swint1"
msgstr "swint1"

#. type: tbl table
#: build/C/man2/syscall.2:222
#, no-wrap
msgid "R10"
msgstr " R10"

#. type: tbl table
#: build/C/man2/syscall.2:222 build/C/man2/syscall.2:354
#, no-wrap
msgid "R00"
msgstr " R00"

#. type: tbl table
#: build/C/man2/syscall.2:222 build/C/man2/syscall.2:354
#, no-wrap
msgid "R01"
msgstr " R01"

#. type: tbl table
#: build/C/man2/syscall.2:223 build/C/man2/syscall.2:355
#, no-wrap
msgid "x86-64"
msgstr "x86-64"

#. type: tbl table
#: build/C/man2/syscall.2:223 build/C/man2/syscall.2:224
#, no-wrap
msgid "rax"
msgstr "rax"

#. type: tbl table
#: build/C/man2/syscall.2:223 build/C/man2/syscall.2:224
#: build/C/man2/syscall.2:355 build/C/man2/syscall.2:356
#, no-wrap
msgid "rdx"
msgstr "rdx"

#. type: tbl table
#: build/C/man2/syscall.2:223 build/C/man2/syscall.2:224
#, no-wrap
msgid "5"
msgstr " 5"

#. type: tbl table
#: build/C/man2/syscall.2:224 build/C/man2/syscall.2:356
#, no-wrap
msgid "x32"
msgstr " x32"

#. type: tbl table
#: build/C/man2/syscall.2:225 build/C/man2/syscall.2:357
#, no-wrap
msgid "xtensa"
msgstr "xtensa"

#. type: tbl table
#: build/C/man2/syscall.2:225 build/C/man2/syscall.2:332
#: build/C/man2/syscall.2:342 build/C/man2/syscall.2:343
#: build/C/man2/syscall.2:348
#, no-wrap
msgid "a2"
msgstr "a2"

#. type: Plain text
#: build/C/man2/syscall.2:229 build/C/man2/syscall.2:361
#, fuzzy
#| msgid "Notes"
msgid "Notes:"
msgstr "備考"

#. type: IP
#: build/C/man2/syscall.2:229 build/C/man2/syscall.2:361
#, no-wrap
msgid "[1]"
msgstr "[1]"

#. type: Plain text
#: build/C/man2/syscall.2:245
msgid ""
"On a few architectures, a register is used as a boolean (0 indicating no "
"error, and -1 indicating an error) to signal that the system call failed.  "
"The actual error value is still contained in the return register.  On sparc, "
"the carry bit (I<csr>)  in the processor status register (I<psr>)  is used "
"instead of a full register.  On powerpc64, the summary overflow bit (I<SO>)  "
"in field 0 of the condition register (I<cr0>)  is used."
msgstr ""

#. type: IP
#: build/C/man2/syscall.2:245
#, no-wrap
msgid "[2]"
msgstr "[2]"

#. type: Plain text
#: build/C/man2/syscall.2:248
#, fuzzy
#| msgid "I<name> is the name of the system call"
msgid "I<NR> is the system call number."
msgstr "I<name> はシステムコールの名前である。"

#. type: IP
#: build/C/man2/syscall.2:248
#, no-wrap
msgid "[3]"
msgstr "[3]"

#. type: Plain text
#: build/C/man2/syscall.2:254
msgid ""
"For s390 and s390x, I<NR> (the system call number) may be passed directly "
"with I<svc\\ NR> if it is less than 256."
msgstr "s390 と s390x では、 I<NR> (システムコール番号) が 256 未満の場合 I<svc\\ NR> で NR が直接渡される場合がある。"

#. type: IP
#: build/C/man2/syscall.2:254
#, no-wrap
msgid "[4]"
msgstr "[4]"

#. type: Plain text
#: build/C/man2/syscall.2:264
msgid ""
"On SuperH, the trap number controls the maximum number of arguments passed.  "
"A I<trap\\ #0x10> can be used with only 0-argument system calls, a I<trap\\ "
"#0x11> can be used with 0- or 1-argument system calls, and so on up to "
"I<trap #0x17> for 7-argument system calls."
msgstr ""

#. type: IP
#: build/C/man2/syscall.2:264
#, no-wrap
msgid "[5]"
msgstr "[5]"

#. type: Plain text
#: build/C/man2/syscall.2:267
msgid ""
"The x32 ABI shares syscall table with x86-64 ABI, but there are some nuances:"
msgstr ""

#. type: IP
#: build/C/man2/syscall.2:268 build/C/man2/syscall.2:275
#, no-wrap
msgid "\\(bu"
msgstr "\\(bu"

#. type: Plain text
#: build/C/man2/syscall.2:275
msgid ""
"In order to indicate that a system call is called under the x32 ABI, an "
"additional bit, B<__X32_SYSCALL_BIT>, is bitwise-ORed with the system call "
"number.  The ABI used by a process affects some process behaviors, including "
"signal handling or system call restarting."
msgstr ""

#. type: Plain text
#: build/C/man2/syscall.2:303
msgid ""
"Since x32 has different sizes for I<long> and pointer types, layouts of some "
"(but not all; I<struct timeval> or I<struct rlimit> are 64-bit, for example) "
"structures are different.  In order to handle this, additional system calls "
"are added to the system call table, starting from number 512 (without the "
"B<__X32_SYSCALL_BIT>).  For example, B<__NR_readv> is defined as 19 for the "
"x86-64 ABI and as I<__X32_SYSCALL_BIT> | B<515> for the x32 ABI.  Most of "
"these additional system calls are actually identical to the system calls "
"used for providing i386 compat.  There are some notable exceptions, however, "
"such as B<preadv2>(2), which uses I<struct iovec> entities with 4-byte "
"pointers and sizes (\"compat_iovec\" in kernel terms), but passes an 8-byte "
"I<pos> argument in a single register and not two, as is done in every other "
"ABI."
msgstr ""

#. type: IP
#: build/C/man2/syscall.2:304
#, no-wrap
msgid "[6]"
msgstr "[6]"

#. type: Plain text
#: build/C/man2/syscall.2:319
msgid ""
"Some architectures (namely, Alpha, IA-64, MIPS, SuperH, sparc/32, and "
"sparc/64)  use an additional register (\"Retval2\" in the above table)  to "
"pass back a second return value from the B<pipe>(2)  system call; Alpha uses "
"this technique in the architecture-specific B<getxpid>(2), B<getxuid>(2), "
"and B<getxgid>(2)  system calls as well.  Other architectures do not use the "
"second return value register in the system call interface, even if it is "
"defined in the System V ABI."
msgstr ""

#. type: Plain text
#: build/C/man2/syscall.2:325
msgid ""
"The second table shows the registers used to pass the system call arguments."
msgstr ""
"2 つ目の表は、システムコールの引数を渡すのに使用されるレジスターの一覧であ"
"る。"

#. type: tbl table
#: build/C/man2/syscall.2:330
#, no-wrap
msgid "arg1"
msgstr "arg1"

#. type: tbl table
#: build/C/man2/syscall.2:330
#, no-wrap
msgid "arg2"
msgstr "arg2"

#. type: tbl table
#: build/C/man2/syscall.2:330
#, no-wrap
msgid "arg3"
msgstr "arg3"

#. type: tbl table
#: build/C/man2/syscall.2:330
#, no-wrap
msgid "arg4"
msgstr "arg4"

#. type: tbl table
#: build/C/man2/syscall.2:330
#, no-wrap
msgid "arg5"
msgstr "arg5"

#. type: tbl table
#: build/C/man2/syscall.2:330
#, no-wrap
msgid "arg6"
msgstr "arg6"

#. type: tbl table
#: build/C/man2/syscall.2:330
#, no-wrap
msgid "arg7"
msgstr "arg7"

#. type: tbl table
#: build/C/man2/syscall.2:332 build/C/man2/syscall.2:343
#: build/C/man2/syscall.2:348 build/C/man2/syscall.2:357
#, no-wrap
msgid "a5"
msgstr "a5"

#. type: tbl table
#: build/C/man2/syscall.2:333 build/C/man2/syscall.2:334
#: build/C/man2/syscall.2:335 build/C/man2/syscall.2:344
#: build/C/man2/syscall.2:346 build/C/man2/syscall.2:347
#: build/C/man2/syscall.2:349 build/C/man2/syscall.2:350
#: build/C/man2/syscall.2:351
#, no-wrap
msgid "r4"
msgstr "r4"

#. type: tbl table
#: build/C/man2/syscall.2:333 build/C/man2/syscall.2:334
#: build/C/man2/syscall.2:335 build/C/man2/syscall.2:341
#: build/C/man2/syscall.2:344 build/C/man2/syscall.2:346
#: build/C/man2/syscall.2:347 build/C/man2/syscall.2:349
#: build/C/man2/syscall.2:350 build/C/man2/syscall.2:351
#, no-wrap
msgid "r5"
msgstr "r5"

#. type: tbl table
#: build/C/man2/syscall.2:334 build/C/man2/syscall.2:335
#: build/C/man2/syscall.2:341 build/C/man2/syscall.2:344
#: build/C/man2/syscall.2:346 build/C/man2/syscall.2:347
#: build/C/man2/syscall.2:349 build/C/man2/syscall.2:350
#: build/C/man2/syscall.2:351
#, no-wrap
msgid "r6"
msgstr "r6"

#. type: tbl table
#: build/C/man2/syscall.2:336
#, no-wrap
msgid "x2"
msgstr "x2"

#. type: tbl table
#: build/C/man2/syscall.2:336
#, no-wrap
msgid "x3"
msgstr "x3"

#. type: tbl table
#: build/C/man2/syscall.2:336
#, no-wrap
msgid "x4"
msgstr "x4"

#. type: tbl table
#: build/C/man2/syscall.2:336
#, no-wrap
msgid "x5"
msgstr "x5"

#. type: tbl table
#: build/C/man2/syscall.2:337
#, no-wrap
msgid "R1"
msgstr "R1"

#. type: tbl table
#: build/C/man2/syscall.2:337
#, no-wrap
msgid "R2"
msgstr "R2"

#. type: tbl table
#: build/C/man2/syscall.2:337
#, no-wrap
msgid "R3"
msgstr "R3"

#. type: tbl table
#: build/C/man2/syscall.2:337
#, no-wrap
msgid "R4"
msgstr "R4"

#. type: tbl table
#: build/C/man2/syscall.2:337
#, no-wrap
msgid "R5"
msgstr "R5"

#. type: tbl table
#: build/C/man2/syscall.2:338
#, no-wrap
msgid "ebx"
msgstr "ebx"

#. type: tbl table
#: build/C/man2/syscall.2:338
#, no-wrap
msgid "ecx"
msgstr "ecx"

#. type: tbl table
#: build/C/man2/syscall.2:338
#, no-wrap
msgid "esi"
msgstr "esi"

#. type: tbl table
#: build/C/man2/syscall.2:338
#, no-wrap
msgid "edi"
msgstr "edi"

#. type: tbl table
#: build/C/man2/syscall.2:338
#, no-wrap
msgid "ebp"
msgstr "ebp"

#. type: tbl table
#: build/C/man2/syscall.2:339
#, no-wrap
msgid "out0"
msgstr "out0"

#. type: tbl table
#: build/C/man2/syscall.2:339
#, no-wrap
msgid "out1"
msgstr "out1"

#. type: tbl table
#: build/C/man2/syscall.2:339
#, no-wrap
msgid "out2"
msgstr "out2"

#. type: tbl table
#: build/C/man2/syscall.2:339
#, no-wrap
msgid "out3"
msgstr "out3"

#. type: tbl table
#: build/C/man2/syscall.2:339
#, no-wrap
msgid "out4"
msgstr "out4"

#. type: tbl table
#: build/C/man2/syscall.2:339
#, no-wrap
msgid "out5"
msgstr "out5"

#. type: tbl table
#: build/C/man2/syscall.2:340
#, no-wrap
msgid "d1"
msgstr "d1"

#. type: tbl table
#: build/C/man2/syscall.2:340
#, no-wrap
msgid "d2"
msgstr "d2"

#. type: tbl table
#: build/C/man2/syscall.2:340
#, no-wrap
msgid "d3"
msgstr "d3"

#. type: tbl table
#: build/C/man2/syscall.2:340
#, no-wrap
msgid "d4"
msgstr "d4"

#. type: tbl table
#: build/C/man2/syscall.2:340
#, no-wrap
msgid "d5"
msgstr "d5"

#. type: tbl table
#: build/C/man2/syscall.2:342
#, no-wrap
msgid "mips/o32"
msgstr "mips/o32"

#. type: tbl table
#: build/C/man2/syscall.2:343
#, no-wrap
msgid "mips/n32,64"
msgstr "mips/n32,64"

#. type: tbl table
#: build/C/man2/syscall.2:345
#, no-wrap
msgid "r26"
msgstr "r26"

#. type: tbl table
#: build/C/man2/syscall.2:345
#, no-wrap
msgid "r25"
msgstr "r25"

#. type: tbl table
#: build/C/man2/syscall.2:345
#, no-wrap
msgid "r24"
msgstr "r24"

#. type: tbl table
#: build/C/man2/syscall.2:345
#, no-wrap
msgid "r23"
msgstr "r23"

#. type: tbl table
#: build/C/man2/syscall.2:345
#, no-wrap
msgid "r22"
msgstr "r22"

#. type: tbl table
#: build/C/man2/syscall.2:345
#, no-wrap
msgid "r21"
msgstr "r21"

#. type: tbl table
#: build/C/man2/syscall.2:352 build/C/man2/syscall.2:353
#, no-wrap
msgid "o2"
msgstr "o2"

#. type: tbl table
#: build/C/man2/syscall.2:352 build/C/man2/syscall.2:353
#, no-wrap
msgid "o3"
msgstr "o3"

#. type: tbl table
#: build/C/man2/syscall.2:352 build/C/man2/syscall.2:353
#, no-wrap
msgid "o4"
msgstr "o4"

#. type: tbl table
#: build/C/man2/syscall.2:352 build/C/man2/syscall.2:353
#, no-wrap
msgid "o5"
msgstr "o5"

#. type: tbl table
#: build/C/man2/syscall.2:354
#, no-wrap
msgid "R02"
msgstr " R02"

#. type: tbl table
#: build/C/man2/syscall.2:354
#, no-wrap
msgid "R03"
msgstr " R03"

#. type: tbl table
#: build/C/man2/syscall.2:354
#, no-wrap
msgid "R04"
msgstr " R04"

#. type: tbl table
#: build/C/man2/syscall.2:354
#, no-wrap
msgid "R05"
msgstr " R05"

#. type: tbl table
#: build/C/man2/syscall.2:355 build/C/man2/syscall.2:356
#, no-wrap
msgid "rdi"
msgstr "rdi"

#. type: tbl table
#: build/C/man2/syscall.2:355 build/C/man2/syscall.2:356
#, no-wrap
msgid "rsi"
msgstr "rsi"

#. type: tbl table
#: build/C/man2/syscall.2:357
#, no-wrap
msgid "a6"
msgstr " a6"

#. type: tbl table
#: build/C/man2/syscall.2:357
#, no-wrap
msgid "a8"
msgstr "a8"

#. type: tbl table
#: build/C/man2/syscall.2:357
#, no-wrap
msgid "a9"
msgstr "a9"

#. type: Plain text
#: build/C/man2/syscall.2:364
msgid ""
"The mips/o32 system call convention passes arguments 5 through 8 on the user "
"stack."
msgstr ""
"mips/o32 のシステムコールの規約では、 ユーザースタックに引数を 5 個から 8 "
"個渡す。"

#. type: Plain text
#: build/C/man2/syscall.2:371
msgid ""
"Note that these tables don't cover the entire calling convention\\(emsome "
"architectures may indiscriminately clobber other registers not listed here."
msgstr ""
"これらの表にはすべての呼び出し規約が記載されているわけではない点に注意するこ"
"と \\(em アーキテクチャーによっては、ここに記載されていない他のレジスターが見"
"境なく上書きされる場合もある。"

#. type: Plain text
#: build/C/man2/syscall.2:378
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/syscall.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/syscall.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"

#. type: Plain text
#: build/C/man2/syscall.2:383
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pid_t tid;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pid_t tid;\n"

#. type: Plain text
#: build/C/man2/syscall.2:387
#, no-wrap
msgid ""
"    tid = syscall(SYS_gettid);\n"
"    syscall(SYS_tgkill, getpid(), tid, SIGHUP);\n"
"}\n"
msgstr ""
"     tid = syscall(SYS_gettid);\n"
"    syscall(SYS_tgkill, getpid(), tid, SIGHUP);\n"
"}\n"

#. type: Plain text
#: build/C/man2/syscall.2:394
msgid "B<_syscall>(2), B<intro>(2), B<syscalls>(2), B<errno>(3), B<vdso>(7)"
msgstr "B<_syscall>(2), B<intro>(2), B<syscalls>(2), B<errno>(3), B<vdso>(7)"

#. type: TH
#: build/C/man2/syscalls.2:31
#, no-wrap
msgid "SYSCALLS"
msgstr "SYSCALLS"

#. type: Plain text
#: build/C/man2/syscalls.2:34
msgid "syscalls - Linux system calls"
msgstr "syscalls - Linux のシステムコール"

#. type: Plain text
#: build/C/man2/syscalls.2:36
msgid "Linux system calls."
msgstr "Linux のシステムコール。"

#. type: Plain text
#: build/C/man2/syscalls.2:39
msgid ""
"The system call is the fundamental interface between an application and the "
"Linux kernel."
msgstr ""
"システムコールは、アプリケーションと Linux カーネルとの間の 基本的なインター"
"フェースである。"

#. type: SS
#: build/C/man2/syscalls.2:39
#, no-wrap
msgid "System calls and library wrapper functions"
msgstr "システムコールとライブラリのラッパー関数"

#. type: Plain text
#: build/C/man2/syscalls.2:49
msgid ""
"System calls are generally not invoked directly, but rather via wrapper "
"functions in glibc (or perhaps some other library).  For details of direct "
"invocation of a system call, see B<intro>(2).  Often, but not always, the "
"name of the wrapper function is the same as the name of the system call that "
"it invokes.  For example, glibc contains a function B<chdir>()  which "
"invokes the underlying \"chdir\" system call."
msgstr "システムコールは一般には直接起動されず、 glibc (や他の何らかのライブラリ)  経由で起動される。 システムコールの直接起動については、詳細は B<intro>(2)  を参照のこと。 いつもという訳ではないが、普通は、ラッパー関数の名前はその関数が起動する システムコールの名前と同じである。 例えば、glibc には B<chdir>()  という関数があり、この関数は \"chdir\" システムコールを起動する。"

#. type: Plain text
#: build/C/man2/syscalls.2:69
#, fuzzy
#| msgid ""
#| "Often the glibc wrapper function is quite thin, doing little work other "
#| "than copying arguments to the right registers before invoking the system "
#| "call, and then setting I<errno> appropriately after the system call has "
#| "returned.  (These are the same steps that are performed by B<syscall>(2), "
#| "which can be used to invoke system calls for which no wrapper function is "
#| "provided.)  Note: system calls indicate a failure by returning a negative "
#| "error number to the caller; when this happens, the wrapper function "
#| "negates the returned error number (to make it positive), copies it to "
#| "I<errno>, and returns -1 to the caller of the wrapper."
msgid ""
"Often the glibc wrapper function is quite thin, doing little work other than "
"copying arguments to the right registers before invoking the system call, "
"and then setting I<errno> appropriately after the system call has returned.  "
"(These are the same steps that are performed by B<syscall>(2), which can be "
"used to invoke system calls for which no wrapper function is provided.)  "
"Note: system calls indicate a failure by returning a negative error number "
"to the caller on architectures without a separate error register/flag, as "
"noted in B<syscall>(2); when this happens, the wrapper function negates the "
"returned error number (to make it positive), copies it to I<errno>, and "
"returns -1 to the caller of the wrapper."
msgstr ""
"たいていの場合、glibc のラッパー関数はかなり簡単なもので、 システムコールを起"
"動する前に引数を適切なレジスターにコピーし、 システムコールが返った後は "
"I<errno> を適切に設定する以外は、ほとんど処理を行わない (これらは、ラッパー関"
"数が提供されていない場合に システムコールを起動するのに使用する "
"B<syscall>(2)  により実行される処理と同じである)。 [注意] システムコールは失"
"敗を示すのに負のエラー番号を呼び出し元に返す。 失敗が起こった際には、ラッパー"
"関数は返されたエラー番号を反転して (正の値に変換し)、それを I<errno> にコピー"
"し、ラッパー関数の呼び出し元に -1 を返す。"

#. type: Plain text
#: build/C/man2/syscalls.2:81
msgid ""
"Sometimes, however, the wrapper function does some extra work before "
"invoking the system call.  For example, nowadays there are (for reasons "
"described below) two related system calls, B<truncate>(2)  and "
"B<truncate64>(2), and the glibc B<truncate>()  wrapper function checks which "
"of those system calls are provided by the kernel and determines which should "
"be employed."
msgstr ""
"しかしながら、時には、ラッパー関数がシステムコールを起動する前に 何らかの追加"
"の処理を行う場合がある。 例えば、現在、 二つの関連するシステムコール "
"B<truncate>(2)  と B<truncate64>(2)  があり、glibc のラッパー関数 "
"B<truncate>()  は、カーネルがこれらのシステムコールのうちどちらを提供している"
"かをチェックし、 どちらを採用するかを決定する。"

#. type: SS
#: build/C/man2/syscalls.2:81
#, no-wrap
msgid "System call list"
msgstr "システムコールのリスト"

#. type: Plain text
#: build/C/man2/syscalls.2:89
msgid ""
"Below is a list of the Linux system calls.  In the list, the I<Kernel> "
"column indicates the kernel version for those system calls that were new in "
"Linux 2.2, or have appeared since that kernel version.  Note the following "
"points:"
msgstr ""
"以下は Linux のシステムコールのリストである。 このリストで、 I<Kernel> の列"
"は、Linux 2.2 以降で登場したシステムコールが 登場したカーネルバージョンを示"
"す。 以下に詳細な説明を記す。"

#. type: Plain text
#: build/C/man2/syscalls.2:92
msgid ""
"Where no kernel version is indicated, the system call appeared in kernel 1.0 "
"or earlier."
msgstr ""
"カーネルバージョンがない場合、そのシステムコールは カーネル 1.0 もしくはそれ"
"以前に登場した。"

#. type: Plain text
#: build/C/man2/syscalls.2:98
msgid ""
"Where a system call is marked \"1.2\" this means the system call probably "
"appeared in a 1.1.x kernel version, and first appeared in a stable kernel "
"with 1.2.  (Development of the 1.2 kernel was initiated from a branch of "
"kernel 1.0.6 via the 1.1.x unstable kernel series.)"
msgstr ""
"システムコールに \"1.2\" と書かれている場合、 そのシステムコールがおそらく"
"バージョン 1.1.x のカーネルで登場し、 安定版のカーネルでは 1.2 で初めて登場し"
"たことを意味する。 (バージョン 1.2 のカーネルは、カーネル 1.0.6 から分岐し、 "
"バージョン 1.1.x の不安定版のカーネル系列として開発された。)"

#.  Was kernel 2.0 started from a branch of 1.2.10?
#.  At least from the timestamps of the tarballs of
#.  of 1.2.10 and 1.3.0, that's how it looks, but in
#.  fact the diff doesn't seem very clear, the
#.  1.3.0 .tar.bz is much bigger (2.0 MB) than the
#.  1.2.10 .tar.bz2 (1.8 MB), and AEB points out the
#.  timestamps of some files in 1.3.0 seem to be older
#.  than those in 1.2.10.  All of this suggests
#.  that there might not have been a clean branch point.
#. type: Plain text
#: build/C/man2/syscalls.2:114
msgid ""
"Where a system call is marked \"2.0\" this means the system call probably "
"appeared in a 1.3.x kernel version, and first appeared in a stable kernel "
"with 2.0.  (Development of the 2.0 kernel was initiated from a branch of "
"kernel 1.2.x, somewhere around 1.2.10, via the 1.3.x unstable kernel series.)"
msgstr ""
"システムコールに \"2.0\" と書かれている場合、 そのシステムコールがおそらく"
"バージョン 1.3.x のカーネルで登場し、 安定版のカーネルでは 2.0 で初めて登場し"
"たことを意味する。 (バージョン 2.0 のカーネルは、バージョン 1.2.10 あたりの"
"カーネル 1.2.x から分岐し、バージョン 1.3.x の不安定版のカーネル系列として開"
"発された。)"

#. type: Plain text
#: build/C/man2/syscalls.2:120
msgid ""
"Where a system call is marked \"2.2\" this means the system call probably "
"appeared in a 2.1.x kernel version, and first appeared in a stable kernel "
"with 2.2.0.  (Development of the 2.2 kernel was initiated from a branch of "
"kernel 2.0.21 via the 2.1.x unstable kernel series.)"
msgstr ""
"システムコールに \"2.2\" と書かれている場合、 そのシステムコールがおそらく"
"バージョン 2.1.x のカーネルで登場し、 安定版のカーネルでは 2.2.0 で初めて登場"
"したことを意味する。 (バージョン 2.2 のカーネルは、カーネル 2.0.21 から分岐"
"し、 バージョン 2.1.x の不安定版のカーネル系列として開発された。)"

#. type: Plain text
#: build/C/man2/syscalls.2:126
msgid ""
"Where a system call is marked \"2.4\" this means the system call probably "
"appeared in a 2.3.x kernel version, and first appeared in a stable kernel "
"with 2.4.0.  (Development of the 2.4 kernel was initiated from a branch of "
"kernel 2.2.8 via the 2.3.x unstable kernel series.)"
msgstr ""
"システムコールに \"2.4\" と書かれている場合、 そのシステムコールがおそらく"
"バージョン 2.3.x のカーネルで登場し、 安定版のカーネルでは 2.4.0 で初めて登場"
"したことを意味する。 (バージョン 2.4 のカーネルは、カーネル 2.2.8 から分岐"
"し、 バージョン 2.3.x の不安定版のカーネル系列として開発された。)"

#. type: Plain text
#: build/C/man2/syscalls.2:132
msgid ""
"Where a system call is marked \"2.6\" this means the system call probably "
"appeared in a 2.5.x kernel version, and first appeared in a stable kernel "
"with 2.6.0.  (Development of kernel 2.6 was initiated from a branch of "
"kernel 2.4.15 via the 2.5.x unstable kernel series.)"
msgstr ""
"システムコールに \"2.6\" と書かれている場合、 そのシステムコールがおそらく"
"バージョン 2.5.x のカーネルで登場し、 安定版のカーネルでは 2.6.0 で初めて登場"
"したことを意味する。 (バージョン 2.6 のカーネルは、カーネル 2.4.15 から分岐"
"し、 バージョン 2.5.x の不安定版のカーネル系列として開発された。)"

#. type: Plain text
#: build/C/man2/syscalls.2:141
#, fuzzy
#| msgid ""
#| "Starting with kernel 2.6.0, the development model changed, and new system "
#| "calls may appear in each 2.6.x release.  In this case, the exact version "
#| "number where the system call appeared is shown.  This convention "
#| "continues with the 3.x kernel series, which followed on from kernel "
#| "2.6.39."
msgid ""
"Starting with kernel 2.6.0, the development model changed, and new system "
"calls may appear in each 2.6.x release.  In this case, the exact version "
"number where the system call appeared is shown.  This convention continues "
"with the 3.x kernel series, which followed on from kernel 2.6.39; and the 4."
"x kernel series, which followed on from kernel 3.19; and the 5.x kernel "
"series, which followed on from kernel 4.20."
msgstr ""
"カーネル 2.6.0 から開発モデルは変更され、新しいシステムコールが\n"
"個々の 2.6.x のリリースでも登場するようになった。\n"
"その場合、このリストでは、システムコールが登場した\n"
"厳密なバージョン番号が記載されている。この慣習は、カーネル 2.6.39 の\n"
"後継となるバージョン 3.x 系列のカーネルでも継続されている。"

#. type: Plain text
#: build/C/man2/syscalls.2:149
msgid ""
"In some cases, a system call was added to a stable kernel series after it "
"branched from the previous stable kernel series, and then backported into "
"the earlier stable kernel series.  For example some system calls that "
"appeared in 2.6.x were also backported into a 2.4.x release after 2.4.15.  "
"When this is so, the version where the system call appeared in both of the "
"major kernel series is listed."
msgstr ""
"前の安定版カーネル系列から分岐した後に安定版カーネル系列にシステムコール が追"
"加された場合、以前の安定版カーネル系列にそのシステムコールが 移植 (backport) "
"されることがある。 例えば、2.6.x で登場したシステムコールのいくつかは、 "
"2.4.15 以降の 2.4.x リリースにも backport された。 この場合、システムコールが"
"登場したバージョンとして、 両方の安定版系列のバージョンが記載されている。"

#.  Looking at scripts/checksyscalls.sh in the kernel source is
#.  instructive about x86 specifics.
#. type: Plain text
#: build/C/man2/syscalls.2:156
msgid ""
"The list of system calls that are available as at kernel 5.10 (or in a few "
"cases only on older kernels) is as follows:"
msgstr "カーネル 5.10 で利用可能なシステムコールのリストを以下に示す (それ以前のカーネルでだけ利用可能なものも少数だが含まれる):"

#. type: tbl table
#: build/C/man2/syscalls.2:161
#, no-wrap
msgid "B<System call>"
msgstr "B<System call>"

#. type: tbl table
#: build/C/man2/syscalls.2:161
#, no-wrap
msgid "B<Kernel>"
msgstr "B<Kernel>"

#. type: tbl table
#: build/C/man2/syscalls.2:161
#, no-wrap
msgid "B<Notes>"
msgstr "B<Notes>"

#. type: tbl table
#: build/C/man2/syscalls.2:163
#, no-wrap
msgid "B<_llseek>(2)"
msgstr "B<_llseek>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:163 build/C/man2/syscalls.2:184
#: build/C/man2/syscalls.2:197 build/C/man2/syscalls.2:504
#: build/C/man2/syscalls.2:633 build/C/man2/syscalls.2:635
#: build/C/man2/syscalls.2:721
#, no-wrap
msgid "1.2"
msgstr "1.2"

#. type: tbl table
#: build/C/man2/syscalls.2:164
#, no-wrap
msgid "B<_newselect>(2)"
msgstr "B<_newselect>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:164 build/C/man2/syscalls.2:165
#: build/C/man2/syscalls.2:166 build/C/man2/syscalls.2:189
#: build/C/man2/syscalls.2:233 build/C/man2/syscalls.2:250
#: build/C/man2/syscalls.2:277 build/C/man2/syscalls.2:281
#: build/C/man2/syscalls.2:312 build/C/man2/syscalls.2:323
#: build/C/man2/syscalls.2:339 build/C/man2/syscalls.2:345
#: build/C/man2/syscalls.2:346 build/C/man2/syscalls.2:359
#: build/C/man2/syscalls.2:360 build/C/man2/syscalls.2:361
#: build/C/man2/syscalls.2:368 build/C/man2/syscalls.2:369
#: build/C/man2/syscalls.2:370 build/C/man2/syscalls.2:411
#: build/C/man2/syscalls.2:433 build/C/man2/syscalls.2:435
#: build/C/man2/syscalls.2:450 build/C/man2/syscalls.2:451
#: build/C/man2/syscalls.2:452 build/C/man2/syscalls.2:453
#: build/C/man2/syscalls.2:454 build/C/man2/syscalls.2:455
#: build/C/man2/syscalls.2:458 build/C/man2/syscalls.2:459
#: build/C/man2/syscalls.2:462 build/C/man2/syscalls.2:467
#: build/C/man2/syscalls.2:549 build/C/man2/syscalls.2:551
#: build/C/man2/syscalls.2:552 build/C/man2/syscalls.2:553
#: build/C/man2/syscalls.2:585 build/C/man2/syscalls.2:586
#: build/C/man2/syscalls.2:589 build/C/man2/syscalls.2:590
#: build/C/man2/syscalls.2:591 build/C/man2/syscalls.2:599
#: build/C/man2/syscalls.2:600 build/C/man2/syscalls.2:601
#: build/C/man2/syscalls.2:604 build/C/man2/syscalls.2:605
#: build/C/man2/syscalls.2:606 build/C/man2/syscalls.2:608
#: build/C/man2/syscalls.2:612 build/C/man2/syscalls.2:613
#: build/C/man2/syscalls.2:642 build/C/man2/syscalls.2:647
#: build/C/man2/syscalls.2:663 build/C/man2/syscalls.2:670
#: build/C/man2/syscalls.2:671 build/C/man2/syscalls.2:672
#: build/C/man2/syscalls.2:673 build/C/man2/syscalls.2:674
#: build/C/man2/syscalls.2:684 build/C/man2/syscalls.2:687
#: build/C/man2/syscalls.2:781
#, no-wrap
msgid "2.0"
msgstr "2.0"

#. type: tbl table
#: build/C/man2/syscalls.2:165
#, no-wrap
msgid "B<_sysctl>(2)"
msgstr "B<_sysctl>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:165
#, fuzzy, no-wrap
msgid "Removed in 5.5"
msgstr "5.5 で削除"

#. type: tbl table
#: build/C/man2/syscalls.2:166
#, no-wrap
msgid "B<accept>(2)"
msgstr "B<accept>(2)"

#.  Implements BSD socket calls
#. type: tbl table
#: build/C/man2/syscalls.2:166 build/C/man2/syscalls.2:189
#: build/C/man2/syscalls.2:233 build/C/man2/syscalls.2:345
#: build/C/man2/syscalls.2:360 build/C/man2/syscalls.2:361
#: build/C/man2/syscalls.2:411 build/C/man2/syscalls.2:551
#: build/C/man2/syscalls.2:552 build/C/man2/syscalls.2:553
#: build/C/man2/syscalls.2:608 build/C/man2/syscalls.2:612
#: build/C/man2/syscalls.2:613 build/C/man2/syscalls.2:663
#: build/C/man2/syscalls.2:674 build/C/man2/syscalls.2:684
#: build/C/man2/syscalls.2:687
#, no-wrap
msgid "See notes on B<socketcall>(2)"
msgstr "B<socketcall>(2) の「注意」の節を参照"

#. type: tbl table
#: build/C/man2/syscalls.2:167
#, no-wrap
msgid "B<accept4>(2)"
msgstr "B<accept4>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:167
#, no-wrap
msgid "2.6.28"
msgstr "2.6.28"

#. type: tbl table
#: build/C/man2/syscalls.2:168
#, no-wrap
msgid "B<access>(2)"
msgstr "B<access>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:168 build/C/man2/syscalls.2:169
#: build/C/man2/syscalls.2:171 build/C/man2/syscalls.2:172
#: build/C/man2/syscalls.2:191 build/C/man2/syscalls.2:200
#: build/C/man2/syscalls.2:201 build/C/man2/syscalls.2:208
#: build/C/man2/syscalls.2:215 build/C/man2/syscalls.2:217
#: build/C/man2/syscalls.2:235 build/C/man2/syscalls.2:236
#: build/C/man2/syscalls.2:237 build/C/man2/syscalls.2:240
#: build/C/man2/syscalls.2:241 build/C/man2/syscalls.2:255
#: build/C/man2/syscalls.2:257 build/C/man2/syscalls.2:269
#: build/C/man2/syscalls.2:270 build/C/man2/syscalls.2:272
#: build/C/man2/syscalls.2:275 build/C/man2/syscalls.2:282
#: build/C/man2/syscalls.2:290 build/C/man2/syscalls.2:293
#: build/C/man2/syscalls.2:295 build/C/man2/syscalls.2:296
#: build/C/man2/syscalls.2:300 build/C/man2/syscalls.2:330
#: build/C/man2/syscalls.2:332 build/C/man2/syscalls.2:334
#: build/C/man2/syscalls.2:336 build/C/man2/syscalls.2:344
#: build/C/man2/syscalls.2:347 build/C/man2/syscalls.2:348
#: build/C/man2/syscalls.2:349 build/C/man2/syscalls.2:350
#: build/C/man2/syscalls.2:351 build/C/man2/syscalls.2:357
#: build/C/man2/syscalls.2:358 build/C/man2/syscalls.2:363
#: build/C/man2/syscalls.2:364 build/C/man2/syscalls.2:371
#: build/C/man2/syscalls.2:385 build/C/man2/syscalls.2:386
#: build/C/man2/syscalls.2:387 build/C/man2/syscalls.2:390
#: build/C/man2/syscalls.2:401 build/C/man2/syscalls.2:402
#: build/C/man2/syscalls.2:409 build/C/man2/syscalls.2:416
#: build/C/man2/syscalls.2:418 build/C/man2/syscalls.2:429
#: build/C/man2/syscalls.2:431 build/C/man2/syscalls.2:436
#: build/C/man2/syscalls.2:438 build/C/man2/syscalls.2:439
#: build/C/man2/syscalls.2:442 build/C/man2/syscalls.2:460
#: build/C/man2/syscalls.2:466 build/C/man2/syscalls.2:475
#: build/C/man2/syscalls.2:476 build/C/man2/syscalls.2:477
#: build/C/man2/syscalls.2:478 build/C/man2/syscalls.2:484
#: build/C/man2/syscalls.2:485 build/C/man2/syscalls.2:492
#: build/C/man2/syscalls.2:511 build/C/man2/syscalls.2:533
#: build/C/man2/syscalls.2:542 build/C/man2/syscalls.2:543
#: build/C/man2/syscalls.2:545 build/C/man2/syscalls.2:547
#: build/C/man2/syscalls.2:550 build/C/man2/syscalls.2:557
#: build/C/man2/syscalls.2:564 build/C/man2/syscalls.2:603
#: build/C/man2/syscalls.2:632 build/C/man2/syscalls.2:637
#: build/C/man2/syscalls.2:639 build/C/man2/syscalls.2:643
#: build/C/man2/syscalls.2:644 build/C/man2/syscalls.2:646
#: build/C/man2/syscalls.2:652 build/C/man2/syscalls.2:653
#: build/C/man2/syscalls.2:659 build/C/man2/syscalls.2:661
#: build/C/man2/syscalls.2:662 build/C/man2/syscalls.2:664
#: build/C/man2/syscalls.2:665 build/C/man2/syscalls.2:667
#: build/C/man2/syscalls.2:669 build/C/man2/syscalls.2:675
#: build/C/man2/syscalls.2:677 build/C/man2/syscalls.2:680
#: build/C/man2/syscalls.2:681 build/C/man2/syscalls.2:682
#: build/C/man2/syscalls.2:683 build/C/man2/syscalls.2:685
#: build/C/man2/syscalls.2:693 build/C/man2/syscalls.2:694
#: build/C/man2/syscalls.2:696 build/C/man2/syscalls.2:699
#: build/C/man2/syscalls.2:704 build/C/man2/syscalls.2:705
#: build/C/man2/syscalls.2:706 build/C/man2/syscalls.2:708
#: build/C/man2/syscalls.2:716 build/C/man2/syscalls.2:722
#: build/C/man2/syscalls.2:723 build/C/man2/syscalls.2:728
#: build/C/man2/syscalls.2:743 build/C/man2/syscalls.2:745
#: build/C/man2/syscalls.2:748 build/C/man2/syscalls.2:749
#: build/C/man2/syscalls.2:753 build/C/man2/syscalls.2:754
#: build/C/man2/syscalls.2:757 build/C/man2/syscalls.2:758
#: build/C/man2/syscalls.2:762 build/C/man2/syscalls.2:769
#: build/C/man2/syscalls.2:770 build/C/man2/syscalls.2:777
#: build/C/man2/syscalls.2:779 build/C/man2/syscalls.2:780
#, no-wrap
msgid "1.0"
msgstr "1.0"

#. type: tbl table
#: build/C/man2/syscalls.2:169
#, no-wrap
msgid "B<acct>(2)"
msgstr "B<acct>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:170
#, no-wrap
msgid "B<add_key>(2)"
msgstr "B<add_key>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:170 build/C/man2/syscalls.2:400
#: build/C/man2/syscalls.2:560 build/C/man2/syscalls.2:778
#, no-wrap
msgid "2.6.10"
msgstr "2.6.10"

#. type: tbl table
#: build/C/man2/syscalls.2:171
#, no-wrap
msgid "B<adjtimex>(2)"
msgstr "B<adjtimex>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:172
#, no-wrap
msgid "B<alarm>(2)"
msgstr "B<alarm>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:173
#, no-wrap
msgid "B<alloc_hugepages>(2)"
msgstr "B<alloc_hugepages>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:173 build/C/man2/syscalls.2:283
#, no-wrap
msgid "2.5.36"
msgstr "2.5.36"

#. type: tbl table
#: build/C/man2/syscalls.2:173 build/C/man2/syscalls.2:283
#, no-wrap
msgid "Removed in 2.5.44"
msgstr "2.5.44 で削除"

#.  4adeefe161a74369e44cc8e663f240ece0470dc3
#. type: tbl table
#: build/C/man2/syscalls.2:175
#, no-wrap
msgid "B<arc_gettls>(2)"
msgstr " B<arc_gettls>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:175 build/C/man2/syscalls.2:176
#, no-wrap
msgid "3.9"
msgstr " 3.9"

#.  91e040a79df73d371f70792f30380d4e44805250
#. type: tbl table
#: build/C/man2/syscalls.2:175 build/C/man2/syscalls.2:176
#: build/C/man2/syscalls.2:178
#, no-wrap
msgid "ARC only"
msgstr "ARC のみ"

#. type: tbl table
#: build/C/man2/syscalls.2:176
#, no-wrap
msgid "B<arc_settls>(2)"
msgstr " B<arc_settls>(2)"

#.  91e040a79df73d371f70792f30380d4e44805250
#. type: tbl table
#: build/C/man2/syscalls.2:178
#, no-wrap
msgid "B<arc_usr_cmpxchg>(2)"
msgstr " B<arc_usr_cmpxchg>(2)"

#.  91e040a79df73d371f70792f30380d4e44805250
#. type: tbl table
#: build/C/man2/syscalls.2:178
#, no-wrap
msgid "4.9"
msgstr "4.9"

#.  x86: 79170fda313ed5be2394f87aa2a00d597f8ed4a1
#. type: tbl table
#: build/C/man2/syscalls.2:180
#, no-wrap
msgid "B<arch_prctl>(2)"
msgstr " B<arch_prctl>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:180 build/C/man2/syscalls.2:210
#: build/C/man2/syscalls.2:211 build/C/man2/syscalls.2:212
#: build/C/man2/syscalls.2:213 build/C/man2/syscalls.2:243
#: build/C/man2/syscalls.2:245 build/C/man2/syscalls.2:247
#: build/C/man2/syscalls.2:258 build/C/man2/syscalls.2:261
#: build/C/man2/syscalls.2:263 build/C/man2/syscalls.2:294
#: build/C/man2/syscalls.2:298 build/C/man2/syscalls.2:303
#: build/C/man2/syscalls.2:376 build/C/man2/syscalls.2:377
#: build/C/man2/syscalls.2:378 build/C/man2/syscalls.2:380
#: build/C/man2/syscalls.2:381 build/C/man2/syscalls.2:414
#: build/C/man2/syscalls.2:555 build/C/man2/syscalls.2:561
#: build/C/man2/syscalls.2:580 build/C/man2/syscalls.2:587
#: build/C/man2/syscalls.2:592 build/C/man2/syscalls.2:597
#: build/C/man2/syscalls.2:616 build/C/man2/syscalls.2:617
#: build/C/man2/syscalls.2:697 build/C/man2/syscalls.2:727
#: build/C/man2/syscalls.2:729 build/C/man2/syscalls.2:730
#: build/C/man2/syscalls.2:731 build/C/man2/syscalls.2:732
#: build/C/man2/syscalls.2:733
#, no-wrap
msgid "2.6"
msgstr "2.6"

#.  x86: 79170fda313ed5be2394f87aa2a00d597f8ed4a1
#. type: tbl table
#: build/C/man2/syscalls.2:180
#, no-wrap
msgid "x86_64, x86 since 4.12"
msgstr ""

#.  9674cdc74d63f346870943ef966a034f8c71ee57
#. type: tbl table
#: build/C/man2/syscalls.2:182
#, no-wrap
msgid "B<atomic_barrier>(2)"
msgstr " B<atomic_barrier>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:182 build/C/man2/syscalls.2:183
#, no-wrap
msgid "2.6.34"
msgstr " 2.6.34"

#. type: tbl table
#: build/C/man2/syscalls.2:182 build/C/man2/syscalls.2:183
#, no-wrap
msgid "m68k only"
msgstr "m68k のみ"

#. type: tbl table
#: build/C/man2/syscalls.2:183
#, no-wrap
msgid "B<atomic_cmpxchg_32>(2)"
msgstr "B<atomic_cmpxchg_32>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:184
#, no-wrap
msgid "B<bdflush>(2)"
msgstr "B<bdflush>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:186
#, no-wrap
msgid "Deprecated (does nothing)\n"
msgstr "2.6 以降で非推奨\n"

#. type: tbl table
#: build/C/man2/syscalls.2:188
#, no-wrap
msgid "since 2.6"
msgstr "(何もしない)"

#. type: tbl table
#: build/C/man2/syscalls.2:189
#, no-wrap
msgid "B<bind>(2)"
msgstr "B<bind>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:190
#, no-wrap
msgid "B<bpf>(2)"
msgstr "B<bpf>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:190
#, no-wrap
msgid "3.18"
msgstr "3.18"

#. type: tbl table
#: build/C/man2/syscalls.2:191
#, no-wrap
msgid "B<brk>(2)"
msgstr "B<brk>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:192
#, no-wrap
msgid "B<breakpoint>(2)"
msgstr " B<breakpoint>(2)"

#.  FIXME . document utrap_install()
#.  There's a man page for Solaris 5.11
#. type: tbl table
#: build/C/man2/syscalls.2:192 build/C/man2/syscalls.2:198
#: build/C/man2/syscalls.2:199 build/C/man2/syscalls.2:202
#: build/C/man2/syscalls.2:311 build/C/man2/syscalls.2:315
#: build/C/man2/syscalls.2:353 build/C/man2/syscalls.2:355
#: build/C/man2/syscalls.2:422 build/C/man2/syscalls.2:465
#: build/C/man2/syscalls.2:505 build/C/man2/syscalls.2:519
#: build/C/man2/syscalls.2:541 build/C/man2/syscalls.2:566
#: build/C/man2/syscalls.2:567 build/C/man2/syscalls.2:568
#: build/C/man2/syscalls.2:569 build/C/man2/syscalls.2:570
#: build/C/man2/syscalls.2:571 build/C/man2/syscalls.2:572
#: build/C/man2/syscalls.2:609 build/C/man2/syscalls.2:655
#: build/C/man2/syscalls.2:657 build/C/man2/syscalls.2:676
#: build/C/man2/syscalls.2:751 build/C/man2/syscalls.2:764
#: build/C/man2/syscalls.2:765 build/C/man2/syscalls.2:768
#, no-wrap
msgid "2.2"
msgstr "2.2"

#. type: tbl table
#: build/C/man2/syscalls.2:194
#, no-wrap
msgid "ARM OABI only, defined with\n"
msgstr ""

#. type: tbl table
#: build/C/man2/syscalls.2:196 build/C/man2/syscalls.2:309
#, no-wrap
msgid "B<__ARM_NR> prefix"
msgstr ""

#. type: tbl table
#: build/C/man2/syscalls.2:197
#, no-wrap
msgid "B<cacheflush>(2)"
msgstr "B<cacheflush>(2)"

#.  , PowerPC, ARM; not x86
#. type: tbl table
#: build/C/man2/syscalls.2:197 build/C/man2/syscalls.2:346
#: build/C/man2/syscalls.2:493 build/C/man2/syscalls.2:495
#: build/C/man2/syscalls.2:497
#, no-wrap
msgid "Not on x86"
msgstr "x86 にはない"

#. type: tbl table
#: build/C/man2/syscalls.2:198
#, no-wrap
msgid "B<capget>(2)"
msgstr "B<capget>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:199
#, no-wrap
msgid "B<capset>(2)"
msgstr "B<capset>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:200
#, no-wrap
msgid "B<chdir>(2)"
msgstr "B<chdir>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:201
#, no-wrap
msgid "B<chmod>(2)"
msgstr "B<chmod>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:202
#, no-wrap
msgid "B<chown>(2)"
msgstr "B<chown>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:204 build/C/man2/syscalls.2:404
#, no-wrap
msgid "See B<chown>(2) for\n"
msgstr "バージョン毎の詳細は\n"

#. type: tbl table
#: build/C/man2/syscalls.2:206 build/C/man2/syscalls.2:406
#, no-wrap
msgid "version details"
msgstr "B<chown>(2) を参照。"

#. type: tbl table
#: build/C/man2/syscalls.2:207
#, no-wrap
msgid "B<chown32>(2)"
msgstr "B<chown32>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:207 build/C/man2/syscalls.2:214
#: build/C/man2/syscalls.2:273 build/C/man2/syscalls.2:276
#: build/C/man2/syscalls.2:291 build/C/man2/syscalls.2:297
#: build/C/man2/syscalls.2:313 build/C/man2/syscalls.2:331
#: build/C/man2/syscalls.2:333 build/C/man2/syscalls.2:335
#: build/C/man2/syscalls.2:337 build/C/man2/syscalls.2:354
#: build/C/man2/syscalls.2:356 build/C/man2/syscalls.2:365
#: build/C/man2/syscalls.2:407 build/C/man2/syscalls.2:419
#: build/C/man2/syscalls.2:420 build/C/man2/syscalls.2:428
#: build/C/man2/syscalls.2:437 build/C/man2/syscalls.2:468
#: build/C/man2/syscalls.2:507 build/C/man2/syscalls.2:513
#: build/C/man2/syscalls.2:634 build/C/man2/syscalls.2:636
#: build/C/man2/syscalls.2:638 build/C/man2/syscalls.2:640
#: build/C/man2/syscalls.2:654 build/C/man2/syscalls.2:656
#: build/C/man2/syscalls.2:658 build/C/man2/syscalls.2:660
#: build/C/man2/syscalls.2:666 build/C/man2/syscalls.2:695
#: build/C/man2/syscalls.2:746 build/C/man2/syscalls.2:747
#, no-wrap
msgid "2.4"
msgstr "2.4"

#. type: tbl table
#: build/C/man2/syscalls.2:208
#, no-wrap
msgid "B<chroot>(2)"
msgstr "B<chroot>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:209
#, no-wrap
msgid "B<clock_adjtime>(2)"
msgstr "B<clock_adjtime>(2)"

#.  PowerPC, ARM, tile
#.  First appeared on ARM, as arm_sync_file_range(), but later renamed
#.  \fBsys_debug_setcontext\fP(2)	???	PowerPC if CONFIG_PPC32
#. type: tbl table
#: build/C/man2/syscalls.2:209 build/C/man2/syscalls.2:461
#: build/C/man2/syscalls.2:486 build/C/man2/syscalls.2:714
#, no-wrap
msgid "2.6.39"
msgstr "2.6.39"

#. type: tbl table
#: build/C/man2/syscalls.2:210
#, no-wrap
msgid "B<clock_getres>(2)"
msgstr "B<clock_getres>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:211
#, no-wrap
msgid "B<clock_gettime>(2)"
msgstr "B<clock_gettime>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:212
#, no-wrap
msgid "B<clock_nanosleep>(2)"
msgstr "B<clock_nanosleep>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:213
#, no-wrap
msgid "B<clock_settime>(2)"
msgstr "B<clock_settime>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:214
#, no-wrap
msgid "B<clone2>(2)"
msgstr " B<clone2>(2)"

#. 	commit c7d5a0050773e98d1094eaa9f2a1a793fafac300 removed perfctr()
#. type: tbl table
#: build/C/man2/syscalls.2:214 build/C/man2/syscalls.2:507
#, no-wrap
msgid "IA-64 only"
msgstr "IA-64 のみ"

#. type: tbl table
#: build/C/man2/syscalls.2:215
#, no-wrap
msgid "B<clone>(2)"
msgstr "B<clone>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:216
#, no-wrap
msgid "B<clone3>(2)"
msgstr " B<clone3>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:216 build/C/man2/syscalls.2:510
#, no-wrap
msgid "5.3"
msgstr " 5.3"

#. type: tbl table
#: build/C/man2/syscalls.2:217
#, no-wrap
msgid "B<close>(2)"
msgstr "B<close>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:218
#, no-wrap
msgid "B<close_range>(2)"
msgstr " B<close_range>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:218
#, no-wrap
msgid "5.9"
msgstr "5.9"

#.  .\" dcef1f634657dabe7905af3ccda12cf7f0b6fcc1
#.  .\" cc20d42986d5807cbe4f5c7c8e3dab2e59ea0db3
#.  .\" db695c0509d6ec9046ee5e4c520a19fa17d9fce2
#.  \fBcmpxchg\fP(2)	2.6.12	T{
#.  ARM, syscall constant never was
#.  .br
#.  exposed to userspace, in-kernel
#.  .br
#.  definition had \fB__ARM_NR\fP prefix,
#.  .br
#.  removed in 4.4
#.  T}
#.  867e359b97c970a60626d5d76bbe2a8fadbf38fb
#.  bb9d812643d8a121df7d614a2b9c60193a92deb0
#. type: tbl table
#: build/C/man2/syscalls.2:233
#, no-wrap
msgid "B<connect>(2)"
msgstr "B<connect>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:234
#, no-wrap
msgid "B<copy_file_range>(2)"
msgstr " B<copy_file_range>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:234
#, no-wrap
msgid "4.5"
msgstr " 4.5"

#. type: tbl table
#: build/C/man2/syscalls.2:235
#, no-wrap
msgid "B<creat>(2)"
msgstr "B<creat>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:236
#, no-wrap
msgid "B<create_module>(2)"
msgstr "B<create_module>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:236 build/C/man2/syscalls.2:300
#: build/C/man2/syscalls.2:541
#, no-wrap
msgid "Removed in 2.6"
msgstr "2.6 で削除"

#. type: tbl table
#: build/C/man2/syscalls.2:237
#, no-wrap
msgid "B<delete_module>(2)"
msgstr "B<delete_module>(2)"

#.  1394f03221790a988afc3e4b3cb79f2e477246a9
#.  4ba66a9760722ccbb691b8f7116cad2f791cca7b
#. type: tbl table
#: build/C/man2/syscalls.2:240
#, no-wrap
msgid "B<dup>(2)"
msgstr "B<dup>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:241
#, no-wrap
msgid "B<dup2>(2)"
msgstr "B<dup2>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:242
#, no-wrap
msgid "B<dup3>(2)"
msgstr "B<dup3>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:242 build/C/man2/syscalls.2:244
#: build/C/man2/syscalls.2:249 build/C/man2/syscalls.2:374
#: build/C/man2/syscalls.2:512 build/C/man2/syscalls.2:679
#, no-wrap
msgid "2.6.27"
msgstr "2.6.27"

#. type: tbl table
#: build/C/man2/syscalls.2:243
#, no-wrap
msgid "B<epoll_create>(2)"
msgstr "B<epoll_create>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:244
#, no-wrap
msgid "B<epoll_create1>(2)"
msgstr "B<epoll_create1>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:245
#, no-wrap
msgid "B<epoll_ctl>(2)"
msgstr "B<epoll_ctl>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:246
#, no-wrap
msgid "B<epoll_pwait>(2)"
msgstr "B<epoll_pwait>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:246 build/C/man2/syscalls.2:310
#, no-wrap
msgid "2.6.19"
msgstr "2.6.19"

#. type: tbl table
#: build/C/man2/syscalls.2:247
#, no-wrap
msgid "B<epoll_wait>(2)"
msgstr "B<epoll_wait>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:248
#, no-wrap
msgid "B<eventfd>(2)"
msgstr "B<eventfd>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:248 build/C/man2/syscalls.2:678
#: build/C/man2/syscalls.2:710 build/C/man2/syscalls.2:763
#, no-wrap
msgid "2.6.22"
msgstr "2.6.22"

#. type: tbl table
#: build/C/man2/syscalls.2:249
#, no-wrap
msgid "B<eventfd2>(2)"
msgstr "B<eventfd2>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:250
#, no-wrap
msgid "B<execv>(2)"
msgstr " B<execv>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:252
#, no-wrap
msgid "SPARC/SPARC64 only, for\n"
msgstr "SPARC/SPARC64 のみ、\n"

#. type: tbl table
#: build/C/man2/syscalls.2:254
#, no-wrap
msgid "compatibility with SunOS"
msgstr "SunOS との互換性のため"

#. type: tbl table
#: build/C/man2/syscalls.2:255
#, no-wrap
msgid "B<execve>(2)"
msgstr "B<execve>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:256
#, no-wrap
msgid "B<execveat>(2)"
msgstr "B<execveat>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:256 build/C/man2/syscalls.2:576
#: build/C/man2/syscalls.2:577
#, no-wrap
msgid "3.19"
msgstr "3.19"

#. type: tbl table
#: build/C/man2/syscalls.2:258
#, no-wrap
msgid "B<exit_group>(2)"
msgstr "B<exit_group>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:259
#, no-wrap
msgid "B<faccessat>(2)"
msgstr "B<faccessat>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:259 build/C/man2/syscalls.2:271
#: build/C/man2/syscalls.2:274 build/C/man2/syscalls.2:292
#: build/C/man2/syscalls.2:299 build/C/man2/syscalls.2:410
#: build/C/man2/syscalls.2:427 build/C/man2/syscalls.2:430
#: build/C/man2/syscalls.2:432 build/C/man2/syscalls.2:464
#: build/C/man2/syscalls.2:488 build/C/man2/syscalls.2:518
#: build/C/man2/syscalls.2:531 build/C/man2/syscalls.2:548
#: build/C/man2/syscalls.2:558 build/C/man2/syscalls.2:691
#: build/C/man2/syscalls.2:692 build/C/man2/syscalls.2:707
#: build/C/man2/syscalls.2:755 build/C/man2/syscalls.2:756
#, no-wrap
msgid "2.6.16"
msgstr "2.6.16"

#. type: tbl table
#: build/C/man2/syscalls.2:260
#, no-wrap
msgid "B<faccessat2>(2)"
msgstr " B<faccessat2>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:260
#, no-wrap
msgid "5.8"
msgstr " 5.8"

#. type: tbl table
#: build/C/man2/syscalls.2:261
#, no-wrap
msgid "B<fadvise64>(2)"
msgstr "B<fadvise64>(2)"

#.  Implements \fBposix_fadvise\fP(2)
#. type: tbl table
#: build/C/man2/syscalls.2:263
#, no-wrap
msgid "B<fadvise64_64>(2)"
msgstr "B<fadvise64_64>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:264
#, no-wrap
msgid "B<fallocate>(2)"
msgstr "B<fallocate>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:264
#, no-wrap
msgid "2.6.23"
msgstr "2.6.23"

#. type: tbl table
#: build/C/man2/syscalls.2:265
#, no-wrap
msgid "B<fanotify_init>(2)"
msgstr "B<fanotify_init>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:265 build/C/man2/syscalls.2:266
#, no-wrap
msgid "2.6.37"
msgstr "2.6.37"

#. type: tbl table
#: build/C/man2/syscalls.2:266
#, no-wrap
msgid "B<fanotify_mark>(2)"
msgstr "B<fanotify_mark>(2)"

#.  The fanotify calls were added in Linux 2.6.36,
#.  but disabled while the API was finalized.
#. type: tbl table
#: build/C/man2/syscalls.2:269
#, no-wrap
msgid "B<fchdir>(2)"
msgstr "B<fchdir>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:270
#, no-wrap
msgid "B<fchmod>(2)"
msgstr "B<fchmod>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:271
#, no-wrap
msgid "B<fchmodat>(2)"
msgstr "B<fchmodat>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:272
#, no-wrap
msgid "B<fchown>(2)"
msgstr "B<fchown>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:273
#, no-wrap
msgid "B<fchown32>(2)"
msgstr "B<fchown32>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:274
#, no-wrap
msgid "B<fchownat>(2)"
msgstr "B<fchownat>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:275
#, no-wrap
msgid "B<fcntl>(2)"
msgstr "B<fcntl>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:276
#, no-wrap
msgid "B<fcntl64>(2)"
msgstr "B<fcntl64>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:277
#, no-wrap
msgid "B<fdatasync>(2)"
msgstr "B<fdatasync>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:278
#, no-wrap
msgid "B<fgetxattr>(2)"
msgstr "B<fgetxattr>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:278 build/C/man2/syscalls.2:280
#: build/C/man2/syscalls.2:284 build/C/man2/syscalls.2:286
#: build/C/man2/syscalls.2:367 build/C/man2/syscalls.2:408
#: build/C/man2/syscalls.2:412 build/C/man2/syscalls.2:413
#: build/C/man2/syscalls.2:415 build/C/man2/syscalls.2:417
#: build/C/man2/syscalls.2:556 build/C/man2/syscalls.2:668
#, no-wrap
msgid "2.6; 2.4.18"
msgstr "2.6; 2.4.18"

#. type: tbl table
#: build/C/man2/syscalls.2:279
#, no-wrap
msgid "B<finit_module>(2)"
msgstr "B<finit_module>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:279
#, no-wrap
msgid "3.8"
msgstr "3.8"

#. type: tbl table
#: build/C/man2/syscalls.2:280
#, no-wrap
msgid "B<flistxattr>(2)"
msgstr "B<flistxattr>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:281
#, no-wrap
msgid "B<flock>(2)"
msgstr "B<flock>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:282
#, no-wrap
msgid "B<fork>(2)"
msgstr "B<fork>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:283
#, no-wrap
msgid "B<free_hugepages>(2)"
msgstr "B<free_hugepages>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:284
#, no-wrap
msgid "B<fremovexattr>(2)"
msgstr "B<fremovexattr>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:285
#, no-wrap
msgid "B<fsconfig>(2)"
msgstr " B<fsconfig>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:285 build/C/man2/syscalls.2:287
#: build/C/man2/syscalls.2:288 build/C/man2/syscalls.2:289
#: build/C/man2/syscalls.2:440 build/C/man2/syscalls.2:487
#, no-wrap
msgid "5.2"
msgstr " 5.2"

#. type: tbl table
#: build/C/man2/syscalls.2:286
#, no-wrap
msgid "B<fsetxattr>(2)"
msgstr "B<fsetxattr>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:287
#, no-wrap
msgid "B<fsmount>(2)"
msgstr " B<fsmount>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:288
#, no-wrap
msgid "B<fsopen>(2)"
msgstr " B<fsopen>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:289
#, no-wrap
msgid "B<fspick>(2)"
msgstr " B<fspick>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:290
#, no-wrap
msgid "B<fstat>(2)"
msgstr "B<fstat>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:291
#, no-wrap
msgid "B<fstat64>(2)"
msgstr "B<fstat64>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:292
#, no-wrap
msgid "B<fstatat64>(2)"
msgstr "B<fstatat64>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:293
#, no-wrap
msgid "B<fstatfs>(2)"
msgstr "B<fstatfs>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:294
#, no-wrap
msgid "B<fstatfs64>(2)"
msgstr "B<fstatfs64>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:295
#, no-wrap
msgid "B<fsync>(2)"
msgstr "B<fsync>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:296
#, no-wrap
msgid "B<ftruncate>(2)"
msgstr "B<ftruncate>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:297
#, no-wrap
msgid "B<ftruncate64>(2)"
msgstr "B<ftruncate64>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:298
#, no-wrap
msgid "B<futex>(2)"
msgstr "B<futex>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:299
#, no-wrap
msgid "B<futimesat>(2)"
msgstr "B<futimesat>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:300
#, no-wrap
msgid "B<get_kernel_syms>(2)"
msgstr "B<get_kernel_syms>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:301
#, no-wrap
msgid "B<get_mempolicy>(2)"
msgstr "B<get_mempolicy>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:301 build/C/man2/syscalls.2:421
#: build/C/man2/syscalls.2:443 build/C/man2/syscalls.2:445
#: build/C/man2/syscalls.2:446 build/C/man2/syscalls.2:447
#: build/C/man2/syscalls.2:448 build/C/man2/syscalls.2:449
#: build/C/man2/syscalls.2:614
#, no-wrap
msgid "2.6.6"
msgstr "2.6.6"

#. type: tbl table
#: build/C/man2/syscalls.2:302
#, no-wrap
msgid "B<get_robust_list>(2)"
msgstr "B<get_robust_list>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:302 build/C/man2/syscalls.2:615
#: build/C/man2/syscalls.2:690 build/C/man2/syscalls.2:709
#: build/C/man2/syscalls.2:726 build/C/man2/syscalls.2:776
#, no-wrap
msgid "2.6.17"
msgstr "2.6.17"

#. type: tbl table
#: build/C/man2/syscalls.2:303
#, no-wrap
msgid "B<get_thread_area>(2)"
msgstr "B<get_thread_area>(2)"

#.  8fcd6c45f5a65621ec809b7866a3623e9a01d4ed
#. type: tbl table
#: build/C/man2/syscalls.2:305
#, no-wrap
msgid "B<get_tls>(2)"
msgstr " B<get_tls>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:305 build/C/man2/syscalls.2:563
#: build/C/man2/syscalls.2:578
#, no-wrap
msgid "4.15"
msgstr "4.15"

#. type: tbl table
#: build/C/man2/syscalls.2:307
#, no-wrap
msgid "ARM OABI only, has\n"
msgstr ""

#. type: tbl table
#: build/C/man2/syscalls.2:310
#, no-wrap
msgid "B<getcpu>(2)"
msgstr "B<getcpu>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:311
#, no-wrap
msgid "B<getcwd>(2)"
msgstr "B<getcwd>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:312
#, no-wrap
msgid "B<getdents>(2)"
msgstr "B<getdents>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:313
#, no-wrap
msgid "B<getdents64>(2)"
msgstr "B<getdents64>(2)"

#.  parisc: 863722e856e64dae0e252b6bb546737c6c5626ce
#. type: tbl table
#: build/C/man2/syscalls.2:315
#, no-wrap
msgid "B<getdomainname>(2)"
msgstr " B<getdomainname>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:317
#, no-wrap
msgid "SPARC, SPARC64; available\n"
msgstr ""

#. type: tbl table
#: build/C/man2/syscalls.2:319
#, no-wrap
msgid "as B<osf_getdomainname>(2)\n"
msgstr ""

#. type: tbl table
#: build/C/man2/syscalls.2:321
#, no-wrap
msgid "on Alpha since Linux 2.0"
msgstr ""

#.  ec98c6b9b47df6df1c1fa6cf3d427414f8c2cf16
#. type: tbl table
#: build/C/man2/syscalls.2:323
#, no-wrap
msgid "B<getdtablesize>(2)"
msgstr " B<getdtablesize>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:325
#, no-wrap
msgid "SPARC (removed in 2.6.26),\n"
msgstr "SPARC (2.6.26 で削除),\n"

#. type: tbl table
#: build/C/man2/syscalls.2:327
#, no-wrap
msgid "available on Alpha as\n"
msgstr ""

#. type: tbl table
#: build/C/man2/syscalls.2:329
#, no-wrap
msgid "B<osf_getdtablesize>(2)"
msgstr " B<osf_getdtablesize>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:330
#, no-wrap
msgid "B<getegid>(2)"
msgstr "B<getegid>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:331
#, no-wrap
msgid "B<getegid32>(2)"
msgstr "B<getegid32>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:332
#, no-wrap
msgid "B<geteuid>(2)"
msgstr "B<geteuid>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:333
#, no-wrap
msgid "B<geteuid32>(2)"
msgstr "B<geteuid32>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:334
#, no-wrap
msgid "B<getgid>(2)"
msgstr "B<getgid>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:335
#, no-wrap
msgid "B<getgid32>(2)"
msgstr "B<getgid32>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:336
#, no-wrap
msgid "B<getgroups>(2)"
msgstr "B<getgroups>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:337
#, no-wrap
msgid "B<getgroups32>(2)"
msgstr "B<getgroups32>(2)"

#.  SPARC removal: ec98c6b9b47df6df1c1fa6cf3d427414f8c2cf16
#. type: tbl table
#: build/C/man2/syscalls.2:339
#, no-wrap
msgid "B<gethostname>(2)"
msgstr " B<gethostname>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:341
#, no-wrap
msgid "Alpha, was available on\n"
msgstr ""

#. type: tbl table
#: build/C/man2/syscalls.2:343
#, no-wrap
msgid "SPARC up to Linux 2.6.26"
msgstr ""

#. type: tbl table
#: build/C/man2/syscalls.2:344
#, no-wrap
msgid "B<getitimer>(2)"
msgstr "B<getitimer>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:345
#, no-wrap
msgid "B<getpeername>(2)"
msgstr "B<getpeername>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:346
#, no-wrap
msgid "B<getpagesize>(2)"
msgstr "B<getpagesize>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:347
#, no-wrap
msgid "B<getpgid>(2)"
msgstr "B<getpgid>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:348
#, no-wrap
msgid "B<getpgrp>(2)"
msgstr "B<getpgrp>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:349
#, no-wrap
msgid "B<getpid>(2)"
msgstr "B<getpid>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:350
#, no-wrap
msgid "B<getppid>(2)"
msgstr "B<getppid>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:351
#, no-wrap
msgid "B<getpriority>(2)"
msgstr "B<getpriority>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:352
#, no-wrap
msgid "B<getrandom>(2)"
msgstr "B<getrandom>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:352 build/C/man2/syscalls.2:396
#: build/C/man2/syscalls.2:425 build/C/man2/syscalls.2:426
#: build/C/man2/syscalls.2:602
#, no-wrap
msgid "3.17"
msgstr "3.17"

#. type: tbl table
#: build/C/man2/syscalls.2:353
#, no-wrap
msgid "B<getresgid>(2)"
msgstr "B<getresgid>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:354
#, no-wrap
msgid "B<getresgid32>(2)"
msgstr "B<getresgid32>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:355
#, no-wrap
msgid "B<getresuid>(2)"
msgstr "B<getresuid>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:356
#, no-wrap
msgid "B<getresuid32>(2)"
msgstr "B<getresuid32>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:357
#, no-wrap
msgid "B<getrlimit>(2)"
msgstr "B<getrlimit>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:358
#, no-wrap
msgid "B<getrusage>(2)"
msgstr "B<getrusage>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:359
#, no-wrap
msgid "B<getsid>(2)"
msgstr "B<getsid>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:360
#, no-wrap
msgid "B<getsockname>(2)"
msgstr "B<getsockname>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:361
#, no-wrap
msgid "B<getsockopt>(2)"
msgstr "B<getsockopt>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:362
#, no-wrap
msgid "B<gettid>(2)"
msgstr "B<gettid>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:362
#, no-wrap
msgid "2.4.11"
msgstr "2.4.11"

#. type: tbl table
#: build/C/man2/syscalls.2:363
#, no-wrap
msgid "B<gettimeofday>(2)"
msgstr "B<gettimeofday>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:364
#, no-wrap
msgid "B<getuid>(2)"
msgstr "B<getuid>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:365
#, no-wrap
msgid "B<getuid32>(2)"
msgstr "B<getuid32>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:366
#, no-wrap
msgid "B<getunwind>(2)"
msgstr " B<getunwind>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:366
#, no-wrap
msgid "2.4.8"
msgstr " 2.4.8"

#. type: tbl table
#: build/C/man2/syscalls.2:366
#, no-wrap
msgid "IA-64 only; deprecated"
msgstr ""

#. type: tbl table
#: build/C/man2/syscalls.2:367
#, no-wrap
msgid "B<getxattr>(2)"
msgstr "B<getxattr>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:368
#, no-wrap
msgid "B<getxgid>(2)"
msgstr " B<getxgid>(2)"

#.  arch/alpha/include/asm/core_lca.h
#. type: tbl table
#: build/C/man2/syscalls.2:368 build/C/man2/syscalls.2:369
#: build/C/man2/syscalls.2:370 build/C/man2/syscalls.2:467
#: build/C/man2/syscalls.2:642
#, no-wrap
msgid "Alpha only; see NOTES"
msgstr "Alpha のみ; 「注意」を参照"

#. type: tbl table
#: build/C/man2/syscalls.2:369
#, no-wrap
msgid "B<getxpid>(2)"
msgstr " B<getxpid>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:370
#, no-wrap
msgid "B<getxuid>(2)"
msgstr " B<getxuid>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:371
#, no-wrap
msgid "B<init_module>(2)"
msgstr "B<init_module>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:372
#, no-wrap
msgid "B<inotify_add_watch>(2)"
msgstr "B<inotify_add_watch>(2)"

#.  5a0015d62668e64c8b6e02e360fbbea121bfd5e6
#. type: tbl table
#: build/C/man2/syscalls.2:372 build/C/man2/syscalls.2:373
#: build/C/man2/syscalls.2:375 build/C/man2/syscalls.2:388
#: build/C/man2/syscalls.2:389 build/C/man2/syscalls.2:397
#: build/C/man2/syscalls.2:689 build/C/man2/syscalls.2:783
#, no-wrap
msgid "2.6.13"
msgstr "2.6.13"

#. type: tbl table
#: build/C/man2/syscalls.2:373
#, no-wrap
msgid "B<inotify_init>(2)"
msgstr "B<inotify_init>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:374
#, no-wrap
msgid "B<inotify_init1>(2)"
msgstr "B<inotify_init1>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:375
#, no-wrap
msgid "B<inotify_rm_watch>(2)"
msgstr "B<inotify_rm_watch>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:376
#, no-wrap
msgid "B<io_cancel>(2)"
msgstr "B<io_cancel>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:377
#, no-wrap
msgid "B<io_destroy>(2)"
msgstr "B<io_destroy>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:378
#, no-wrap
msgid "B<io_getevents>(2)"
msgstr "B<io_getevents>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:379
#, no-wrap
msgid "B<io_pgetevents>(2)"
msgstr " B<io_pgetevents>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:379 build/C/man2/syscalls.2:565
#, no-wrap
msgid "4.18"
msgstr "4.18"

#. type: tbl table
#: build/C/man2/syscalls.2:380
#, no-wrap
msgid "B<io_setup>(2)"
msgstr "B<io_setup>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:381
#, no-wrap
msgid "B<io_submit>(2)"
msgstr "B<io_submit>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:382
#, no-wrap
msgid "B<io_uring_enter>(2)"
msgstr " B<io_uring_enter>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:382 build/C/man2/syscalls.2:383
#: build/C/man2/syscalls.2:384 build/C/man2/syscalls.2:509
#, no-wrap
msgid "5.1"
msgstr "5.1"

#. type: tbl table
#: build/C/man2/syscalls.2:383
#, no-wrap
msgid "B<io_uring_register>(2)"
msgstr " B<io_uring_register>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:384
#, no-wrap
msgid "B<io_uring_setup>(2)"
msgstr " B<io_uring_setup>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:385
#, no-wrap
msgid "B<ioctl>(2)"
msgstr "B<ioctl>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:386
#, no-wrap
msgid "B<ioperm>(2)"
msgstr "B<ioperm>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:387
#, no-wrap
msgid "B<iopl>(2)"
msgstr "B<iopl>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:388
#, no-wrap
msgid "B<ioprio_get>(2)"
msgstr "B<ioprio_get>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:389
#, no-wrap
msgid "B<ioprio_set>(2)"
msgstr "B<ioprio_set>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:390
#, no-wrap
msgid "B<ipc>(2)"
msgstr "B<ipc>(2)"

#.  Implements System V IPC calls
#. type: tbl table
#: build/C/man2/syscalls.2:392
#, no-wrap
msgid "B<kcmp>(2)"
msgstr "B<kcmp>(2)"

#.  Implements System V IPC calls
#. type: tbl table
#: build/C/man2/syscalls.2:392
#, no-wrap
msgid "3.5"
msgstr "3.5"

#. type: tbl table
#: build/C/man2/syscalls.2:393
#, no-wrap
msgid "B<kern_features>(2)"
msgstr "B<kern_features>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:393 build/C/man2/syscalls.2:575
#, no-wrap
msgid "3.7"
msgstr "3.7"

#. type: tbl table
#: build/C/man2/syscalls.2:393 build/C/man2/syscalls.2:422
#: build/C/man2/syscalls.2:765
#, no-wrap
msgid "SPARC64 only"
msgstr "SPARC64 のみ"

#.  FIXME . document kern_features():
#.  commit 517ffce4e1a03aea979fe3a18a3dd1761a24fafb
#. type: tbl table
#: build/C/man2/syscalls.2:396
#, no-wrap
msgid "B<kexec_file_load>(2)"
msgstr "B<kexec_file_load>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:397
#, no-wrap
msgid "B<kexec_load>(2)"
msgstr "B<kexec_load>(2)"

#.  The entry in the syscall table was reserved starting in 2.6.7
#.  Was named sys_kexec_load() from 2.6.7 to 2.6.16
#. type: tbl table
#: build/C/man2/syscalls.2:400
#, no-wrap
msgid "B<keyctl>(2)"
msgstr "B<keyctl>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:401
#, no-wrap
msgid "B<kill>(2)"
msgstr "B<kill>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:402
#, no-wrap
msgid "B<lchown>(2)"
msgstr "B<lchown>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:407
#, no-wrap
msgid "B<lchown32>(2)"
msgstr "B<lchown32>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:408
#, no-wrap
msgid "B<lgetxattr>(2)"
msgstr "B<lgetxattr>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:409
#, no-wrap
msgid "B<link>(2)"
msgstr "B<link>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:410
#, no-wrap
msgid "B<linkat>(2)"
msgstr "B<linkat>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:411
#, no-wrap
msgid "B<listen>(2)"
msgstr "B<listen>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:412
#, no-wrap
msgid "B<listxattr>(2)"
msgstr "B<listxattr>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:413
#, no-wrap
msgid "B<llistxattr>(2)"
msgstr "B<llistxattr>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:414
#, no-wrap
msgid "B<lookup_dcookie>(2)"
msgstr "B<lookup_dcookie>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:415
#, no-wrap
msgid "B<lremovexattr>(2)"
msgstr "B<lremovexattr>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:416
#, no-wrap
msgid "B<lseek>(2)"
msgstr "B<lseek>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:417
#, no-wrap
msgid "B<lsetxattr>(2)"
msgstr "B<lsetxattr>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:418
#, no-wrap
msgid "B<lstat>(2)"
msgstr "B<lstat>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:419
#, no-wrap
msgid "B<lstat64>(2)"
msgstr "B<lstat64>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:420
#, no-wrap
msgid "B<madvise>(2)"
msgstr "B<madvise>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:421
#, no-wrap
msgid "B<mbind>(2)"
msgstr "B<mbind>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:422
#, no-wrap
msgid "B<memory_ordering>(2)"
msgstr " B<memory_ordering>(2)"

#.  26025bbfbba33a9425be1b89eccb4664ea4c17b6
#.  bb6fb6dfcc17cddac11ac295861f7608194447a7
#. type: tbl table
#: build/C/man2/syscalls.2:425
#, no-wrap
msgid "B<membarrier>(2)"
msgstr " B<membarrier>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:426
#, no-wrap
msgid "B<memfd_create>(2)"
msgstr "B<memfd_create>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:427
#, no-wrap
msgid "B<migrate_pages>(2)"
msgstr "B<migrate_pages>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:428
#, no-wrap
msgid "B<mincore>(2)"
msgstr "B<mincore>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:429
#, no-wrap
msgid "B<mkdir>(2)"
msgstr "B<mkdir>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:430
#, no-wrap
msgid "B<mkdirat>(2)"
msgstr "B<mkdirat>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:431
#, no-wrap
msgid "B<mknod>(2)"
msgstr "B<mknod>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:432
#, no-wrap
msgid "B<mknodat>(2)"
msgstr "B<mknodat>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:433
#, no-wrap
msgid "B<mlock>(2)"
msgstr "B<mlock>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:434
#, no-wrap
msgid "B<mlock2>(2)"
msgstr " B<mlock2>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:434
#, no-wrap
msgid "4.4"
msgstr " 4.4"

#. type: tbl table
#: build/C/man2/syscalls.2:435
#, no-wrap
msgid "B<mlockall>(2)"
msgstr "B<mlockall>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:436
#, no-wrap
msgid "B<mmap>(2)"
msgstr "B<mmap>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:437
#, no-wrap
msgid "B<mmap2>(2)"
msgstr "B<mmap2>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:438
#, no-wrap
msgid "B<modify_ldt>(2)"
msgstr "B<modify_ldt>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:439
#, no-wrap
msgid "B<mount>(2)"
msgstr "B<mount>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:440
#, no-wrap
msgid "B<move_mount>(2)"
msgstr " B<move_mount>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:441
#, no-wrap
msgid "B<move_pages>(2)"
msgstr "B<move_pages>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:441
#, no-wrap
msgid "2.6.18"
msgstr "2.6.18"

#. type: tbl table
#: build/C/man2/syscalls.2:442
#, no-wrap
msgid "B<mprotect>(2)"
msgstr "B<mprotect>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:443
#, no-wrap
msgid "B<mq_getsetattr>(2)"
msgstr "B<mq_getsetattr>(2)"

#.  Implements \fBmq_getattr\fP(3) and \fBmq_setattr\fP(3)
#. type: tbl table
#: build/C/man2/syscalls.2:445
#, no-wrap
msgid "B<mq_notify>(2)"
msgstr "B<mq_notify>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:446
#, no-wrap
msgid "B<mq_open>(2)"
msgstr "B<mq_open>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:447
#, no-wrap
msgid "B<mq_timedreceive>(2)"
msgstr "B<mq_timedreceive>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:448
#, no-wrap
msgid "B<mq_timedsend>(2)"
msgstr "B<mq_timedsend>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:449
#, no-wrap
msgid "B<mq_unlink>(2)"
msgstr "B<mq_unlink>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:450
#, no-wrap
msgid "B<mremap>(2)"
msgstr "B<mremap>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:451
#, no-wrap
msgid "B<msgctl>(2)"
msgstr "B<msgctl>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:451 build/C/man2/syscalls.2:452
#: build/C/man2/syscalls.2:453 build/C/man2/syscalls.2:454
#: build/C/man2/syscalls.2:604 build/C/man2/syscalls.2:605
#: build/C/man2/syscalls.2:606 build/C/man2/syscalls.2:670
#: build/C/man2/syscalls.2:671 build/C/man2/syscalls.2:672
#: build/C/man2/syscalls.2:673
#, no-wrap
msgid "See notes on B<ipc>(2)"
msgstr "B<ipc>(2) の「注意」の節を参照"

#. type: tbl table
#: build/C/man2/syscalls.2:452
#, no-wrap
msgid "B<msgget>(2)"
msgstr "B<msgget>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:453
#, no-wrap
msgid "B<msgrcv>(2)"
msgstr "B<msgrcv>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:454
#, no-wrap
msgid "B<msgsnd>(2)"
msgstr "B<msgsnd>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:455
#, no-wrap
msgid "B<msync>(2)"
msgstr "B<msync>(2)"

#.  \fBmultiplexer\fP(2)	??	__NR_multiplexer reserved on
#. 		PowerPC, but unimplemented?
#. type: tbl table
#: build/C/man2/syscalls.2:458
#, no-wrap
msgid "B<munlock>(2)"
msgstr "B<munlock>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:459
#, no-wrap
msgid "B<munlockall>(2)"
msgstr "B<munlockall>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:460
#, no-wrap
msgid "B<munmap>(2)"
msgstr "B<munmap>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:461
#, no-wrap
msgid "B<name_to_handle_at>(2)"
msgstr "B<name_to_handle_at>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:462
#, no-wrap
msgid "B<nanosleep>(2)"
msgstr "B<nanosleep>(2)"

#.  5590ff0d5528b60153c0b4e7b771472b5a95e297
#. type: tbl table
#: build/C/man2/syscalls.2:464
#, no-wrap
msgid "B<newfstatat>(2)"
msgstr " B<newfstatat>(2)"

#.  5590ff0d5528b60153c0b4e7b771472b5a95e297
#. type: tbl table
#: build/C/man2/syscalls.2:464
#, no-wrap
msgid "See B<stat>(2)"
msgstr " See B<stat>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:465
#, no-wrap
msgid "B<nfsservctl>(2)"
msgstr "B<nfsservctl>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:465
#, no-wrap
msgid "Removed in 3.1"
msgstr "3.1 で削除"

#. type: tbl table
#: build/C/man2/syscalls.2:466
#, no-wrap
msgid "B<nice>(2)"
msgstr "B<nice>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:467
#, no-wrap
msgid "B<old_adjtimex>(2)"
msgstr " B<old_adjtimex>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:468
#, no-wrap
msgid "B<old_getrlimit>(2)"
msgstr " B<old_getrlimit>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:470
#, fuzzy, no-wrap
#| msgid "B<getrlimit>(2)"
msgid "Old variant of B<getrlimit>(2)\n"
msgstr "B<getrlimit>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:472
#, no-wrap
msgid "that used a different value\n"
msgstr ""

#. type: tbl table
#: build/C/man2/syscalls.2:474
#, no-wrap
msgid "for B<RLIM_INFINITY>"
msgstr ""

#. type: tbl table
#: build/C/man2/syscalls.2:475
#, no-wrap
msgid "B<oldfstat>(2)"
msgstr "B<oldfstat>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:476
#, no-wrap
msgid "B<oldlstat>(2)"
msgstr "B<oldlstat>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:477
#, no-wrap
msgid "B<oldolduname>(2)"
msgstr "B<oldolduname>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:478
#, no-wrap
msgid "B<oldstat>(2)"
msgstr "B<oldstat>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:479
#, no-wrap
msgid "B<oldumount>(2)"
msgstr " B<oldumount>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:479
#, no-wrap
msgid "2.4.116"
msgstr " 2.4.116"

#. type: tbl table
#: build/C/man2/syscalls.2:481
#, no-wrap
msgid "Name of the old B<umount>(2)\n"
msgstr ""

#. type: tbl table
#: build/C/man2/syscalls.2:483
#, fuzzy, no-wrap
#| msgid "syscall #"
msgid "syscall on Alpha"
msgstr "syscall #"

#. type: tbl table
#: build/C/man2/syscalls.2:484
#, no-wrap
msgid "B<olduname>(2)"
msgstr "B<olduname>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:485
#, no-wrap
msgid "B<open>(2)"
msgstr "B<open>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:486
#, no-wrap
msgid "B<open_by_handle_at>(2)"
msgstr "B<open_by_handle_at>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:487
#, no-wrap
msgid "B<open_tree>(2)"
msgstr " B<open_tree>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:488
#, no-wrap
msgid "B<openat>(2)"
msgstr "B<openat>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:489
#, no-wrap
msgid "B<openat2>(2)"
msgstr " B<openat2>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:489 build/C/man2/syscalls.2:508
#, no-wrap
msgid "5.6"
msgstr " 5.6"

#.  9d02a4283e9ce4e9ca11ff00615bdacdb0515a1a
#. type: tbl table
#: build/C/man2/syscalls.2:491
#, no-wrap
msgid "B<or1k_atomic>(2)"
msgstr " B<or1k_atomic>(2)"

#.  9d02a4283e9ce4e9ca11ff00615bdacdb0515a1a
#. type: tbl table
#: build/C/man2/syscalls.2:491
#, no-wrap
msgid "3.1"
msgstr " 3.1"

#.  9d02a4283e9ce4e9ca11ff00615bdacdb0515a1a
#. type: tbl table
#: build/C/man2/syscalls.2:491
#, no-wrap
msgid "OpenRISC 1000 only"
msgstr "OpenRISC 1000 のみ"

#. type: tbl table
#: build/C/man2/syscalls.2:492
#, no-wrap
msgid "B<pause>(2)"
msgstr "B<pause>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:493
#, no-wrap
msgid "B<pciconfig_iobase>(2)"
msgstr "B<pciconfig_iobase>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:493
#, no-wrap
msgid "2.2.15; 2.4"
msgstr "2.2.15; 2.4"

#.  Alpha, PowerPC, ARM; not x86
#. type: tbl table
#: build/C/man2/syscalls.2:495
#, no-wrap
msgid "B<pciconfig_read>(2)"
msgstr "B<pciconfig_read>(2)"

#.  , PowerPC, ARM; not x86
#. type: tbl table
#: build/C/man2/syscalls.2:495 build/C/man2/syscalls.2:497
#, no-wrap
msgid "2.0.26; 2.2"
msgstr "2.0.26; 2.2"

#.  , PowerPC, ARM; not x86
#. type: tbl table
#: build/C/man2/syscalls.2:497
#, no-wrap
msgid "B<pciconfig_write>(2)"
msgstr "B<pciconfig_write>(2)"

#.  , PowerPC, ARM; not x86
#. type: tbl table
#: build/C/man2/syscalls.2:499
#, no-wrap
msgid "B<perf_event_open>(2)"
msgstr "B<perf_event_open>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:499 build/C/man2/syscalls.2:573
#, no-wrap
msgid "2.6.31"
msgstr "2.6.31"

#. type: tbl table
#: build/C/man2/syscalls.2:501
#, no-wrap
msgid "Was perf_counter_open() in\n"
msgstr "2.6.31 では perf_counter_open() であった;\n"

#. type: tbl table
#: build/C/man2/syscalls.2:503
#, no-wrap
msgid "2.6.31; renamed in 2.6.32"
msgstr "2.6.32 で名称変更"

#. type: tbl table
#: build/C/man2/syscalls.2:504
#, no-wrap
msgid "B<personality>(2)"
msgstr "B<personality>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:505
#, no-wrap
msgid "B<perfctr>(2)"
msgstr "B<perfctr>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:505
#, no-wrap
msgid "SPARC only; removed in 2.6.34"
msgstr "SPARC のみ; 2.6.34 で削除"

#. 	commit c7d5a0050773e98d1094eaa9f2a1a793fafac300 removed perfctr()
#. type: tbl table
#: build/C/man2/syscalls.2:507
#, no-wrap
msgid "B<perfmonctl>(2)"
msgstr "B<perfmonctl>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:508
#, no-wrap
msgid "B<pidfd_getfd>(2)"
msgstr " B<pidfd_getfd>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:509
#, no-wrap
msgid "B<pidfd_send_signal>(2)"
msgstr " B<pidfd_send_signal>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:510
#, no-wrap
msgid "B<pidfd_open>(2)"
msgstr " B<pidfd_open>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:511
#, no-wrap
msgid "B<pipe>(2)"
msgstr "B<pipe>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:512
#, no-wrap
msgid "B<pipe2>(2)"
msgstr "B<pipe2>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:513
#, no-wrap
msgid "B<pivot_root>(2)"
msgstr "B<pivot_root>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:514
#, no-wrap
msgid "B<pkey_alloc>(2)"
msgstr " B<pkey_alloc>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:514 build/C/man2/syscalls.2:515
#: build/C/man2/syscalls.2:516
#, no-wrap
msgid "4.8"
msgstr " 4.8"

#. type: tbl table
#: build/C/man2/syscalls.2:515
#, no-wrap
msgid "B<pkey_free>(2)"
msgstr " B<pkey_free>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:516
#, no-wrap
msgid "B<pkey_mprotect>(2)"
msgstr " B<pkey_mprotect>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:517
#, no-wrap
msgid "B<poll>(2)"
msgstr "B<poll>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:517
#, no-wrap
msgid "2.0.36; 2.2"
msgstr "2.0.36; 2.2"

#. type: tbl table
#: build/C/man2/syscalls.2:518
#, no-wrap
msgid "B<ppoll>(2)"
msgstr "B<ppoll>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:519
#, no-wrap
msgid "B<prctl>(2)"
msgstr "B<prctl>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:520
#, no-wrap
msgid "B<pread64>(2)"
msgstr "B<pread64>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:522
#, no-wrap
msgid "Added as \"pread\" in 2.2;\n"
msgstr "2.2 で \"pread\" として追加;\n"

#. type: tbl table
#: build/C/man2/syscalls.2:524
#, no-wrap
msgid "renamed \"pread64\" in 2.6"
msgstr "2.6 で \"pread64\" に名称変更"

#. type: tbl table
#: build/C/man2/syscalls.2:525
#, no-wrap
msgid "B<preadv>(2)"
msgstr "B<preadv>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:525 build/C/man2/syscalls.2:539
#, no-wrap
msgid "2.6.30"
msgstr "2.6.30"

#. type: tbl table
#: build/C/man2/syscalls.2:526
#, no-wrap
msgid "B<preadv2>(2)"
msgstr " B<preadv2>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:526 build/C/man2/syscalls.2:540
#, no-wrap
msgid "4.6"
msgstr " 4.6"

#. type: tbl table
#: build/C/man2/syscalls.2:527
#, no-wrap
msgid "B<prlimit64>(2)"
msgstr "B<prlimit64>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:527
#, no-wrap
msgid "2.6.36"
msgstr "2.6.36"

#. type: tbl table
#: build/C/man2/syscalls.2:528
#, no-wrap
msgid "B<process_madvise>(2)"
msgstr " B<process_madvise>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:528
#, no-wrap
msgid "5.10"
msgstr "5.10"

#. type: tbl table
#: build/C/man2/syscalls.2:529
#, no-wrap
msgid "B<process_vm_readv>(2)"
msgstr "B<process_vm_readv>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:529 build/C/man2/syscalls.2:530
#, no-wrap
msgid "3.2"
msgstr "3.2"

#. type: tbl table
#: build/C/man2/syscalls.2:530
#, no-wrap
msgid "B<process_vm_writev>(2)"
msgstr "B<process_vm_writev>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:531
#, no-wrap
msgid "B<pselect6>(2)"
msgstr "B<pselect6>(2)"

#.  Implements \fBpselect\fP(2)
#. type: tbl table
#: build/C/man2/syscalls.2:533
#, no-wrap
msgid "B<ptrace>(2)"
msgstr "B<ptrace>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:534
#, no-wrap
msgid "B<pwrite64>(2)"
msgstr "B<pwrite64>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:536
#, no-wrap
msgid "Added as \"pwrite\" in 2.2;\n"
msgstr "2.2 で \"pwrite\" として追加;\n"

#. type: tbl table
#: build/C/man2/syscalls.2:538
#, no-wrap
msgid "renamed \"pwrite64\" in 2.6"
msgstr "2.6 で \"pwrite64\" に名称変更"

#. type: tbl table
#: build/C/man2/syscalls.2:539
#, no-wrap
msgid "B<pwritev>(2)"
msgstr "B<pwritev>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:540
#, no-wrap
msgid "B<pwritev2>(2)"
msgstr " B<pwritev2>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:541
#, no-wrap
msgid "B<query_module>(2)"
msgstr "B<query_module>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:542
#, no-wrap
msgid "B<quotactl>(2)"
msgstr "B<quotactl>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:543
#, no-wrap
msgid "B<read>(2)"
msgstr "B<read>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:544
#, no-wrap
msgid "B<readahead>(2)"
msgstr "B<readahead>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:544
#, no-wrap
msgid "2.4.13"
msgstr "2.4.13"

#. type: tbl table
#: build/C/man2/syscalls.2:545
#, no-wrap
msgid "B<readdir>(2)"
msgstr "B<readdir>(2)"

#.  Supersedes \fBgetdents\fP(2)
#. type: tbl table
#: build/C/man2/syscalls.2:547
#, no-wrap
msgid "B<readlink>(2)"
msgstr "B<readlink>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:548
#, no-wrap
msgid "B<readlinkat>(2)"
msgstr "B<readlinkat>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:549
#, no-wrap
msgid "B<readv>(2)"
msgstr "B<readv>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:550
#, no-wrap
msgid "B<reboot>(2)"
msgstr "B<reboot>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:551
#, no-wrap
msgid "B<recv>(2)"
msgstr "B<recv>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:552
#, no-wrap
msgid "B<recvfrom>(2)"
msgstr "B<recvfrom>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:553
#, no-wrap
msgid "B<recvmsg>(2)"
msgstr "B<recvmsg>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:554
#, no-wrap
msgid "B<recvmmsg>(2)"
msgstr "B<recvmmsg>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:554
#, no-wrap
msgid "2.6.33"
msgstr "2.6.33"

#. type: tbl table
#: build/C/man2/syscalls.2:555
#, no-wrap
msgid "B<remap_file_pages>(2)"
msgstr "B<remap_file_pages>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:555
#, no-wrap
msgid "Deprecated since 3.16"
msgstr "3.16 以降では非推奨"

#. type: tbl table
#: build/C/man2/syscalls.2:556
#, no-wrap
msgid "B<removexattr>(2)"
msgstr "B<removexattr>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:557
#, no-wrap
msgid "B<rename>(2)"
msgstr "B<rename>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:558
#, no-wrap
msgid "B<renameat>(2)"
msgstr "B<renameat>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:559
#, no-wrap
msgid "B<renameat2>(2)"
msgstr "B<renameat2>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:559
#, no-wrap
msgid "3.15"
msgstr "3.15"

#. type: tbl table
#: build/C/man2/syscalls.2:560
#, no-wrap
msgid "B<request_key>(2)"
msgstr "B<request_key>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:561
#, no-wrap
msgid "B<restart_syscall>(2)"
msgstr "B<restart_syscall>(2)"

#.  921ebd8f2c081b3cf6c3b29ef4103eef3ff26054
#. type: tbl table
#: build/C/man2/syscalls.2:563
#, no-wrap
msgid "B<riscv_flush_icache>(2)"
msgstr " B<riscv_flush_icache>(2)"

#.  921ebd8f2c081b3cf6c3b29ef4103eef3ff26054
#. type: tbl table
#: build/C/man2/syscalls.2:563
#, no-wrap
msgid "RISC-V only"
msgstr "RISC-V のみ"

#. type: tbl table
#: build/C/man2/syscalls.2:564
#, no-wrap
msgid "B<rmdir>(2)"
msgstr "B<rmdir>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:565
#, no-wrap
msgid "B<rseq>(2)"
msgstr " B<rseq>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:566
#, no-wrap
msgid "B<rt_sigaction>(2)"
msgstr "B<rt_sigaction>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:567
#, no-wrap
msgid "B<rt_sigpending>(2)"
msgstr "B<rt_sigpending>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:568
#, no-wrap
msgid "B<rt_sigprocmask>(2)"
msgstr "B<rt_sigprocmask>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:569
#, no-wrap
msgid "B<rt_sigqueueinfo>(2)"
msgstr "B<rt_sigqueueinfo>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:570
#, no-wrap
msgid "B<rt_sigreturn>(2)"
msgstr "B<rt_sigreturn>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:571
#, no-wrap
msgid "B<rt_sigsuspend>(2)"
msgstr "B<rt_sigsuspend>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:572
#, no-wrap
msgid "B<rt_sigtimedwait>(2)"
msgstr "B<rt_sigtimedwait>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:573
#, no-wrap
msgid "B<rt_tgsigqueueinfo>(2)"
msgstr "B<rt_tgsigqueueinfo>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:574
#, no-wrap
msgid "B<rtas>(2)"
msgstr " B<rtas>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:574
#, no-wrap
msgid "2.6.2"
msgstr "2.6.2"

#. type: tbl table
#: build/C/man2/syscalls.2:574 build/C/man2/syscalls.2:691
#: build/C/man2/syscalls.2:692 build/C/man2/syscalls.2:700
#: build/C/man2/syscalls.2:701
#, no-wrap
msgid "PowerPC/PowerPC64 only"
msgstr "PowerPC/PowerPC64 のみ"

#. type: tbl table
#: build/C/man2/syscalls.2:575
#, no-wrap
msgid "B<s390_runtime_instr>(2)"
msgstr "B<s390_runtime_instr>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:575 build/C/man2/syscalls.2:576
#: build/C/man2/syscalls.2:577 build/C/man2/syscalls.2:578
#: build/C/man2/syscalls.2:579
#, no-wrap
msgid "s390 only"
msgstr "s390 のみ"

#. type: tbl table
#: build/C/man2/syscalls.2:576
#, no-wrap
msgid "B<s390_pci_mmio_read>(2)"
msgstr "B<s390_pci_mmio_read>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:577
#, no-wrap
msgid "B<s390_pci_mmio_write>(2)"
msgstr "B<s390_pci_mmio_write>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:578
#, no-wrap
msgid "B<s390_sthyi>(2)"
msgstr " B<s390_sthyi>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:579
#, no-wrap
msgid "B<s390_guarded_storage>(2)"
msgstr " B<s390_guarded_storage>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:579
#, no-wrap
msgid "4.12"
msgstr "4.12"

#. type: tbl table
#: build/C/man2/syscalls.2:580
#, no-wrap
msgid "B<sched_get_affinity>(2)"
msgstr " B<sched_get_affinity>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:582
#, fuzzy, no-wrap
#| msgid "B<sched_getaffinity>(2)"
msgid "Name of B<sched_getaffinity>(2)\n"
msgstr "B<sched_getaffinity>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:584 build/C/man2/syscalls.2:596
#, no-wrap
msgid "on SPARC and SPARC64"
msgstr ""

#. type: tbl table
#: build/C/man2/syscalls.2:585
#, no-wrap
msgid "B<sched_get_priority_max>(2)"
msgstr "B<sched_get_priority_max>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:586
#, no-wrap
msgid "B<sched_get_priority_min>(2)"
msgstr "B<sched_get_priority_min>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:587
#, no-wrap
msgid "B<sched_getaffinity>(2)"
msgstr "B<sched_getaffinity>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:588
#, no-wrap
msgid "B<sched_getattr>(2)"
msgstr "B<sched_getattr>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:588 build/C/man2/syscalls.2:598
#, no-wrap
msgid "3.14"
msgstr "3.14"

#. type: tbl table
#: build/C/man2/syscalls.2:589
#, no-wrap
msgid "B<sched_getparam>(2)"
msgstr "B<sched_getparam>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:590
#, no-wrap
msgid "B<sched_getscheduler>(2)"
msgstr "B<sched_getscheduler>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:591
#, no-wrap
msgid "B<sched_rr_get_interval>(2)"
msgstr "B<sched_rr_get_interval>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:592
#, no-wrap
msgid "B<sched_set_affinity>(2)"
msgstr " B<sched_set_affinity>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:594
#, fuzzy, no-wrap
#| msgid "B<sched_setaffinity>(2)"
msgid "Name of B<sched_setaffinity>(2)\n"
msgstr "B<sched_setaffinity>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:597
#, no-wrap
msgid "B<sched_setaffinity>(2)"
msgstr "B<sched_setaffinity>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:598
#, no-wrap
msgid "B<sched_setattr>(2)"
msgstr "B<sched_setattr>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:599
#, no-wrap
msgid "B<sched_setparam>(2)"
msgstr "B<sched_setparam>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:600
#, no-wrap
msgid "B<sched_setscheduler>(2)"
msgstr "B<sched_setscheduler>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:601
#, no-wrap
msgid "B<sched_yield>(2)"
msgstr "B<sched_yield>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:602
#, no-wrap
msgid "B<seccomp>(2)"
msgstr "B<seccomp>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:603
#, no-wrap
msgid "B<select>(2)"
msgstr "B<select>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:604
#, no-wrap
msgid "B<semctl>(2)"
msgstr "B<semctl>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:605
#, no-wrap
msgid "B<semget>(2)"
msgstr "B<semget>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:606
#, no-wrap
msgid "B<semop>(2)"
msgstr "B<semop>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:607
#, no-wrap
msgid "B<semtimedop>(2)"
msgstr "B<semtimedop>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:607 build/C/man2/syscalls.2:744
#, no-wrap
msgid "2.6; 2.4.22"
msgstr "2.6; 2.4.22"

#. type: tbl table
#: build/C/man2/syscalls.2:608
#, no-wrap
msgid "B<send>(2)"
msgstr "B<send>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:609
#, no-wrap
msgid "B<sendfile>(2)"
msgstr "B<sendfile>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:610
#, no-wrap
msgid "B<sendfile64>(2)"
msgstr "B<sendfile64>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:610
#, no-wrap
msgid "2.6; 2.4.19"
msgstr "2.6; 2.4.19"

#. type: tbl table
#: build/C/man2/syscalls.2:611
#, no-wrap
msgid "B<sendmmsg>(2)"
msgstr "B<sendmmsg>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:611 build/C/man2/syscalls.2:645
#, no-wrap
msgid "3.0"
msgstr "3.0"

#. type: tbl table
#: build/C/man2/syscalls.2:612
#, no-wrap
msgid "B<sendmsg>(2)"
msgstr "B<sendmsg>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:613
#, no-wrap
msgid "B<sendto>(2)"
msgstr "B<sendto>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:614
#, no-wrap
msgid "B<set_mempolicy>(2)"
msgstr "B<set_mempolicy>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:615
#, no-wrap
msgid "B<set_robust_list>(2)"
msgstr "B<set_robust_list>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:616
#, no-wrap
msgid "B<set_thread_area>(2)"
msgstr "B<set_thread_area>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:617
#, no-wrap
msgid "B<set_tid_address>(2)"
msgstr "B<set_tid_address>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:618
#, no-wrap
msgid "B<set_tls>(2)"
msgstr " B<set_tls>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:618 build/C/man2/syscalls.2:715
#, no-wrap
msgid "2.6.11"
msgstr "2.6.11"

#. type: tbl table
#: build/C/man2/syscalls.2:620
#, no-wrap
msgid "ARM OABI/EABI only (constant\n"
msgstr ""

#. type: tbl table
#: build/C/man2/syscalls.2:622
#, no-wrap
msgid "has B<__ARM_NR> prefix)"
msgstr ""

#.  \fBsetaltroot\fP(2)	2.6.10	T{
#.  Removed in 2.6.11, exposed one
#.  of implementation details of
#.  \fBpersonality\fP(2) (creating an
#.  alternative root, precursor of
#.  mount namespaces) to user space.
#.  T}
#.  See http://lkml.org/lkml/2005/8/1/83
#.  "[PATCH] remove sys_set_zone_reclaim()"
#. type: tbl table
#: build/C/man2/syscalls.2:632
#, no-wrap
msgid "B<setdomainname>(2)"
msgstr "B<setdomainname>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:633
#, no-wrap
msgid "B<setfsgid>(2)"
msgstr "B<setfsgid>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:634
#, no-wrap
msgid "B<setfsgid32>(2)"
msgstr "B<setfsgid32>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:635
#, no-wrap
msgid "B<setfsuid>(2)"
msgstr "B<setfsuid>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:636
#, no-wrap
msgid "B<setfsuid32>(2)"
msgstr "B<setfsuid32>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:637
#, no-wrap
msgid "B<setgid>(2)"
msgstr "B<setgid>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:638
#, no-wrap
msgid "B<setgid32>(2)"
msgstr "B<setgid32>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:639
#, no-wrap
msgid "B<setgroups>(2)"
msgstr "B<setgroups>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:640
#, no-wrap
msgid "B<setgroups32>(2)"
msgstr "B<setgroups32>(2)"

#.  arch/alpha/include/asm/core_lca.h
#. type: tbl table
#: build/C/man2/syscalls.2:642
#, no-wrap
msgid "B<sethae>(2)"
msgstr " B<sethae>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:643
#, no-wrap
msgid "B<sethostname>(2)"
msgstr "B<sethostname>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:644
#, no-wrap
msgid "B<setitimer>(2)"
msgstr "B<setitimer>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:645
#, no-wrap
msgid "B<setns>(2)"
msgstr "B<setns>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:646
#, no-wrap
msgid "B<setpgid>(2)"
msgstr "B<setpgid>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:647
#, no-wrap
msgid "B<setpgrp>(2)"
msgstr " B<setpgrp>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:649
#, no-wrap
msgid "Alternative name for\n"
msgstr ""

#. type: tbl table
#: build/C/man2/syscalls.2:651
#, fuzzy, no-wrap
#| msgid "B<setpgid>(2)"
msgid "B<setpgid>(2) on Alpha"
msgstr "B<setpgid>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:652
#, no-wrap
msgid "B<setpriority>(2)"
msgstr "B<setpriority>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:653
#, no-wrap
msgid "B<setregid>(2)"
msgstr "B<setregid>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:654
#, no-wrap
msgid "B<setregid32>(2)"
msgstr "B<setregid32>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:655
#, no-wrap
msgid "B<setresgid>(2)"
msgstr "B<setresgid>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:656
#, no-wrap
msgid "B<setresgid32>(2)"
msgstr "B<setresgid32>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:657
#, no-wrap
msgid "B<setresuid>(2)"
msgstr "B<setresuid>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:658
#, no-wrap
msgid "B<setresuid32>(2)"
msgstr "B<setresuid32>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:659
#, no-wrap
msgid "B<setreuid>(2)"
msgstr "B<setreuid>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:660
#, no-wrap
msgid "B<setreuid32>(2)"
msgstr "B<setreuid32>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:661
#, no-wrap
msgid "B<setrlimit>(2)"
msgstr "B<setrlimit>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:662
#, no-wrap
msgid "B<setsid>(2)"
msgstr "B<setsid>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:663
#, no-wrap
msgid "B<setsockopt>(2)"
msgstr "B<setsockopt>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:664
#, no-wrap
msgid "B<settimeofday>(2)"
msgstr "B<settimeofday>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:665
#, no-wrap
msgid "B<setuid>(2)"
msgstr "B<setuid>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:666
#, no-wrap
msgid "B<setuid32>(2)"
msgstr "B<setuid32>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:667
#, no-wrap
msgid "B<setup>(2)"
msgstr "B<setup>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:667
#, no-wrap
msgid "Removed in 2.2"
msgstr "2.2 で削除"

#. type: tbl table
#: build/C/man2/syscalls.2:668
#, no-wrap
msgid "B<setxattr>(2)"
msgstr "B<setxattr>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:669
#, no-wrap
msgid "B<sgetmask>(2)"
msgstr "B<sgetmask>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:670
#, no-wrap
msgid "B<shmat>(2)"
msgstr "B<shmat>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:671
#, no-wrap
msgid "B<shmctl>(2)"
msgstr "B<shmctl>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:672
#, no-wrap
msgid "B<shmdt>(2)"
msgstr "B<shmdt>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:673
#, no-wrap
msgid "B<shmget>(2)"
msgstr "B<shmget>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:674
#, no-wrap
msgid "B<shutdown>(2)"
msgstr "B<shutdown>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:675
#, no-wrap
msgid "B<sigaction>(2)"
msgstr "B<sigaction>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:676
#, no-wrap
msgid "B<sigaltstack>(2)"
msgstr "B<sigaltstack>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:677
#, no-wrap
msgid "B<signal>(2)"
msgstr "B<signal>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:678
#, no-wrap
msgid "B<signalfd>(2)"
msgstr "B<signalfd>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:679
#, no-wrap
msgid "B<signalfd4>(2)"
msgstr "B<signalfd4>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:680
#, no-wrap
msgid "B<sigpending>(2)"
msgstr "B<sigpending>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:681
#, no-wrap
msgid "B<sigprocmask>(2)"
msgstr "B<sigprocmask>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:682
#, no-wrap
msgid "B<sigreturn>(2)"
msgstr "B<sigreturn>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:683
#, no-wrap
msgid "B<sigsuspend>(2)"
msgstr "B<sigsuspend>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:684
#, no-wrap
msgid "B<socket>(2)"
msgstr "B<socket>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:685
#, no-wrap
msgid "B<socketcall>(2)"
msgstr "B<socketcall>(2)"

#.  Implements BSD socket calls
#. type: tbl table
#: build/C/man2/syscalls.2:687
#, no-wrap
msgid "B<socketpair>(2)"
msgstr "B<socketpair>(2)"

#.  5a0015d62668e64c8b6e02e360fbbea121bfd5e6
#. type: tbl table
#: build/C/man2/syscalls.2:689
#, no-wrap
msgid "B<spill>(2)"
msgstr " B<spill>(2)"

#.  5a0015d62668e64c8b6e02e360fbbea121bfd5e6
#. type: tbl table
#: build/C/man2/syscalls.2:689 build/C/man2/syscalls.2:783
#, no-wrap
msgid "Xtensa only"
msgstr "Xtensa のみ"

#. type: tbl table
#: build/C/man2/syscalls.2:690
#, no-wrap
msgid "B<splice>(2)"
msgstr "B<splice>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:691
#, no-wrap
msgid "B<spu_create>(2)"
msgstr "B<spu_create>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:692
#, no-wrap
msgid "B<spu_run>(2)"
msgstr "B<spu_run>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:693
#, no-wrap
msgid "B<ssetmask>(2)"
msgstr "B<ssetmask>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:694
#, no-wrap
msgid "B<stat>(2)"
msgstr "B<stat>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:695
#, no-wrap
msgid "B<stat64>(2)"
msgstr "B<stat64>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:696
#, no-wrap
msgid "B<statfs>(2)"
msgstr "B<statfs>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:697
#, no-wrap
msgid "B<statfs64>(2)"
msgstr "B<statfs64>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:698
#, no-wrap
msgid "B<statx>(2)"
msgstr " B<statx>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:698
#, no-wrap
msgid "4.11"
msgstr " 4.11"

#. type: tbl table
#: build/C/man2/syscalls.2:699
#, no-wrap
msgid "B<stime>(2)"
msgstr "B<stime>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:700
#, no-wrap
msgid "B<subpage_prot>(2)"
msgstr "B<subpage_prot>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:700 build/C/man2/syscalls.2:740
#: build/C/man2/syscalls.2:741 build/C/man2/syscalls.2:742
#, no-wrap
msgid "2.6.25"
msgstr "2.6.25"

#. type: tbl table
#: build/C/man2/syscalls.2:701
#, no-wrap
msgid "B<swapcontext>(2)"
msgstr " B<swapcontext>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:701
#, no-wrap
msgid "2.6.3"
msgstr " 2.6.3"

#.  529d235a0e190ded1d21ccc80a73e625ebcad09b
#. type: tbl table
#: build/C/man2/syscalls.2:703
#, no-wrap
msgid "B<switch_endian>(2)"
msgstr " B<switch_endian>(2)"

#.  529d235a0e190ded1d21ccc80a73e625ebcad09b
#. type: tbl table
#: build/C/man2/syscalls.2:703
#, no-wrap
msgid "4.1"
msgstr " 4.1"

#.  529d235a0e190ded1d21ccc80a73e625ebcad09b
#. type: tbl table
#: build/C/man2/syscalls.2:703
#, no-wrap
msgid "PowerPC64 only"
msgstr "PowerPC64 のみ"

#. type: tbl table
#: build/C/man2/syscalls.2:704
#, no-wrap
msgid "B<swapoff>(2)"
msgstr "B<swapoff>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:705
#, no-wrap
msgid "B<swapon>(2)"
msgstr "B<swapon>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:706
#, no-wrap
msgid "B<symlink>(2)"
msgstr "B<symlink>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:707
#, no-wrap
msgid "B<symlinkat>(2)"
msgstr "B<symlinkat>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:708
#, no-wrap
msgid "B<sync>(2)"
msgstr "B<sync>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:709
#, no-wrap
msgid "B<sync_file_range>(2)"
msgstr "B<sync_file_range>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:710
#, no-wrap
msgid "B<sync_file_range2>(2)"
msgstr "B<sync_file_range2>(2)"

#.  PowerPC, ARM, tile
#.  First appeared on ARM, as arm_sync_file_range(), but later renamed
#.  \fBsys_debug_setcontext\fP(2)	???	PowerPC if CONFIG_PPC32
#. type: tbl table
#: build/C/man2/syscalls.2:714
#, no-wrap
msgid "B<syncfs>(2)"
msgstr "B<syncfs>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:715
#, no-wrap
msgid "B<sys_debug_setcontext>(2)"
msgstr " B<sys_debug_setcontext>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:715
#, no-wrap
msgid "PowerPC only"
msgstr "PowerPC のみ"

#. type: tbl table
#: build/C/man2/syscalls.2:716
#, no-wrap
msgid "B<syscall>(2)"
msgstr " B<syscall>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:718
#, no-wrap
msgid "Still available on ARM OABI\n"
msgstr ""

#. type: tbl table
#: build/C/man2/syscalls.2:720
#, no-wrap
msgid "and MIPS O32 ABI"
msgstr ""

#. type: tbl table
#: build/C/man2/syscalls.2:721
#, no-wrap
msgid "B<sysfs>(2)"
msgstr "B<sysfs>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:722
#, no-wrap
msgid "B<sysinfo>(2)"
msgstr "B<sysinfo>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:723
#, no-wrap
msgid "B<syslog>(2)"
msgstr "B<syslog>(2)"

#.  glibc interface is \fBklogctl\fP(3)
#. type: tbl table
#: build/C/man2/syscalls.2:725
#, no-wrap
msgid "B<sysmips>(2)"
msgstr " B<sysmips>(2)"

#.  glibc interface is \fBklogctl\fP(3)
#. type: tbl table
#: build/C/man2/syscalls.2:725
#, no-wrap
msgid "2.6.0"
msgstr " 2.6.0"

#.  glibc interface is \fBklogctl\fP(3)
#. type: tbl table
#: build/C/man2/syscalls.2:725
#, no-wrap
msgid "MIPS only"
msgstr "MIPS のみ"

#. type: tbl table
#: build/C/man2/syscalls.2:726
#, no-wrap
msgid "B<tee>(2)"
msgstr "B<tee>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:727
#, no-wrap
msgid "B<tgkill>(2)"
msgstr "B<tgkill>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:728
#, no-wrap
msgid "B<time>(2)"
msgstr "B<time>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:729
#, no-wrap
msgid "B<timer_create>(2)"
msgstr "B<timer_create>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:730
#, no-wrap
msgid "B<timer_delete>(2)"
msgstr "B<timer_delete>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:731
#, no-wrap
msgid "B<timer_getoverrun>(2)"
msgstr "B<timer_getoverrun>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:732
#, no-wrap
msgid "B<timer_gettime>(2)"
msgstr "B<timer_gettime>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:733
#, no-wrap
msgid "B<timer_settime>(2)"
msgstr "B<timer_settime>(2)"

#.  .\" b215e283992899650c4271e7385c79e26fb9a88e
#.  .\" 4d672e7ac79b5ec5cdc90e450823441e20464691
#.  \fBtimerfd\fP(2)	2.6.22	T{
#.  Old timerfd interface,
#.  removed in 2.6.25
#.  T}
#. type: tbl table
#: build/C/man2/syscalls.2:740
#, no-wrap
msgid "B<timerfd_create>(2)"
msgstr "B<timerfd_create>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:741
#, no-wrap
msgid "B<timerfd_gettime>(2)"
msgstr "B<timerfd_gettime>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:742
#, no-wrap
msgid "B<timerfd_settime>(2)"
msgstr "B<timerfd_settime>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:743
#, no-wrap
msgid "B<times>(2)"
msgstr "B<times>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:744
#, no-wrap
msgid "B<tkill>(2)"
msgstr "B<tkill>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:745
#, no-wrap
msgid "B<truncate>(2)"
msgstr "B<truncate>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:746
#, no-wrap
msgid "B<truncate64>(2)"
msgstr "B<truncate64>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:747
#, no-wrap
msgid "B<ugetrlimit>(2)"
msgstr "B<ugetrlimit>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:749
#, no-wrap
msgid "B<umount>(2)"
msgstr "B<umount>(2)"

#.  sys_oldumount() -- __NR_umount
#. type: tbl table
#: build/C/man2/syscalls.2:751
#, no-wrap
msgid "B<umount2>(2)"
msgstr "B<umount2>(2)"

#.  sys_umount() -- __NR_umount2
#. type: tbl table
#: build/C/man2/syscalls.2:753
#, no-wrap
msgid "B<uname>(2)"
msgstr "B<uname>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:754
#, no-wrap
msgid "B<unlink>(2)"
msgstr "B<unlink>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:755
#, no-wrap
msgid "B<unlinkat>(2)"
msgstr "B<unlinkat>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:756
#, no-wrap
msgid "B<unshare>(2)"
msgstr "B<unshare>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:757
#, no-wrap
msgid "B<uselib>(2)"
msgstr "B<uselib>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:758
#, no-wrap
msgid "B<ustat>(2)"
msgstr "B<ustat>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:759
#, no-wrap
msgid "B<userfaultfd>(2)"
msgstr " B<userfaultfd>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:759
#, no-wrap
msgid "4.3"
msgstr " 4.3"

#. type: tbl table
#: build/C/man2/syscalls.2:760
#, no-wrap
msgid "B<usr26>(2)"
msgstr " B<usr26>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:760 build/C/man2/syscalls.2:761
#, no-wrap
msgid "2.4.8.1"
msgstr " 2.4.8.1"

#. type: tbl table
#: build/C/man2/syscalls.2:760 build/C/man2/syscalls.2:761
#, no-wrap
msgid "ARM OABI only"
msgstr "ARM OABI のみ"

#. type: tbl table
#: build/C/man2/syscalls.2:761
#, no-wrap
msgid "B<usr32>(2)"
msgstr " B<usr32>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:762
#, no-wrap
msgid "B<utime>(2)"
msgstr "B<utime>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:763
#, no-wrap
msgid "B<utimensat>(2)"
msgstr "B<utimensat>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:764
#, no-wrap
msgid "B<utimes>(2)"
msgstr "B<utimes>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:765
#, no-wrap
msgid "B<utrap_install>(2)"
msgstr "B<utrap_install>(2)"

#.  FIXME . document utrap_install()
#.  There's a man page for Solaris 5.11
#. type: tbl table
#: build/C/man2/syscalls.2:768
#, no-wrap
msgid "B<vfork>(2)"
msgstr "B<vfork>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:769
#, no-wrap
msgid "B<vhangup>(2)"
msgstr "B<vhangup>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:770
#, no-wrap
msgid "B<vm86old>(2)"
msgstr "B<vm86old>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:772
#, fuzzy, no-wrap
#| msgid ""
#| "Was \"vm86\"; renamed in\n"
#| "2.0.28/2.2"
msgid "Was \"vm86\"; renamed in\n"
msgstr ""
"以前は \"vm86\";\n"
"2.0.28/2.2 で改名された"

#. type: tbl table
#: build/C/man2/syscalls.2:774
#, no-wrap
msgid "2.0.28/2.2"
msgstr " 2.0.28/2.2"

#. type: tbl table
#: build/C/man2/syscalls.2:775
#, no-wrap
msgid "B<vm86>(2)"
msgstr "B<vm86>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:775
#, no-wrap
msgid "2.0.28; 2.2"
msgstr "2.0.28; 2.2"

#. type: tbl table
#: build/C/man2/syscalls.2:776
#, no-wrap
msgid "B<vmsplice>(2)"
msgstr "B<vmsplice>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:777
#, no-wrap
msgid "B<wait4>(2)"
msgstr "B<wait4>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:778
#, no-wrap
msgid "B<waitid>(2)"
msgstr "B<waitid>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:779
#, no-wrap
msgid "B<waitpid>(2)"
msgstr "B<waitpid>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:780
#, no-wrap
msgid "B<write>(2)"
msgstr "B<write>(2)"

#. type: tbl table
#: build/C/man2/syscalls.2:781
#, no-wrap
msgid "B<writev>(2)"
msgstr "B<writev>(2)"

#.  5a0015d62668e64c8b6e02e360fbbea121bfd5e6
#. type: tbl table
#: build/C/man2/syscalls.2:783
#, no-wrap
msgid "B<xtensa>(2)"
msgstr " B<xtensa>(2)"

#. type: Plain text
#: build/C/man2/syscalls.2:792
msgid ""
"On many platforms, including x86-32, socket calls are all multiplexed (via "
"glibc wrapper functions) through B<socketcall>(2)  and similarly System\\ V "
"IPC calls are multiplexed through B<ipc>(2)."
msgstr ""
"x86-32 を含む多くのプラットフォームでは、ソケット関連のシステムコールは "
"(glibc のラッパー関数を介してだが) すべて B<socketcall>(2) 経由に多重されてい"
"る。 同様に、System\\ V IPC 関連のシステムコールは B<ipc>(2) 経由に多重されて"
"いる。"

#.  __NR_afs_syscall is 53 on Linux 2.6.22/i386
#.  __NR_break is 17 on Linux 2.6.22/i386
#.  __NR_ftime is 35 on Linux 2.6.22/i386
#.  __NR_getpmsg is 188 on Linux 2.6.22/i386
#.  __NR_gtty is 32 on Linux 2.6.22/i386
#.  __NR_idle is 112 on Linux 2.6.22/i386
#.  __NR_lock is 53 on Linux 2.6.22/i386
#.  __NR_madvise1 is 219 on Linux 2.6.22/i386
#.  __NR_mpx is 66 on Linux 2.6.22/i386
#.  Slot has been reused
#.  __NR_prof is 44 on Linux 2.6.22/i386
#.  __NR_profil is 98 on Linux 2.6.22/i386
#.  __NR_putpmsg is 189 on Linux 2.6.22/i386
#.  __NR_security is 223 on Linux 2.4/i386
#.  __NR_security is 223 on Linux 2.4/i386; absent on 2.6/i386, present
#.  on a couple of 2.6 architectures
#.  __NR_stty is 31 on Linux 2.6.22/i386
#.  The security call is for future use.
#.  __NR_tuxcall is 184 on x86_64, also on PPC and alpha
#.  __NR_ulimit is 58 on Linux 2.6.22/i386
#.  __NR_vserver is 273 on Linux 2.6.22/i386
#. type: Plain text
#: build/C/man2/syscalls.2:837
msgid ""
"Although slots are reserved for them in the system call table, the following "
"system calls are not implemented in the standard kernel: B<afs_syscall>(2), "
"B<break>(2), B<ftime>(2), B<getpmsg>(2), B<gtty>(2), B<idle>(2), B<lock>(2), "
"B<madvise1>(2), B<mpx>(2), B<phys>(2), B<prof>(2), B<profil>(2), "
"B<putpmsg>(2), B<security>(2), B<stty>(2), B<tuxcall>(2), B<ulimit>(2), and "
"B<vserver>(2)  (see also B<unimplemented>(2)).  However, B<ftime>(3), "
"B<profil>(3), and B<ulimit>(3)  exist as library routines.  The slot for "
"B<phys>(2)  is in use since kernel 2.1.116 for B<umount>(2); B<phys>(2)  "
"will never be implemented.  The B<getpmsg>(2)  and B<putpmsg>(2)  calls are "
"for kernels patched to support STREAMS, and may never be in the standard "
"kernel."
msgstr ""
"以下のシステムコールは、システムコールテーブルにスロットが予約されている"
"が、\n"
"標準のカーネルには実装されていない:\n"
"B<afs_syscall>(2), B<break>(2), B<ftime>(2), B<getpmsg>(2), B<gtty>(2),\n"
"B<idle>(2), B<lock>(2), B<madvise1>(2), B<mpx>(2), B<phys>(2), B<prof>(2),\n"
"B<profil>(2), B<putpmsg>(2), B<security>(2), B<stty>(2), B<tuxcall>(2),\n"
"B<ulimit>(2), B<vserver>(2) (B<unimplemented>(2) も参照)。\n"
"しかし、B<ftime>(3), B<profil>(3), B<ulimit>(3) はライブラリルーチンとして\n"
"実装されている。 B<phys>(2) 用の場所は 2.1.116 以降では B<umount>(2) 用に\n"
"使用されている; 将来においても B<phys>(2) は実装されない。\n"
"B<getpmsg>(2) と B<putpmsg>(2) は STREAMS 対応のパッチが適用された\n"
"カーネル用であり、標準のカーネルに登場することはないかもしれない。"

#. type: Plain text
#: build/C/man2/syscalls.2:843
msgid ""
"There was briefly B<set_zone_reclaim>(2), added in Linux 2.6.13, and removed "
"in 2.6.16; this system call was never available to user space."
msgstr ""
"B<set_zone_reclaim>(2) は少しの間だけ存在した。 Linux 2.6.13 で追加され、"
"2.6.16 で削除された。このシステムコールがユーザー空間から使える状態になったこ"
"とはない。"

#. type: SS
#: build/C/man2/syscalls.2:843
#, no-wrap
msgid "System calls on removed ports"
msgstr ""

#. type: Plain text
#: build/C/man2/syscalls.2:846
msgid ""
"Some system calls only ever existed on Linux architectures that have since "
"been removed from the kernel:"
msgstr ""

#. type: TP
#: build/C/man2/syscalls.2:846
#, no-wrap
msgid "AVR32 (port removed in Linux 4.12)"
msgstr ""

#. type: Plain text
#: build/C/man2/syscalls.2:852
msgid "B<pread>(2)"
msgstr " B<pread>(2)"

#. type: Plain text
#: build/C/man2/syscalls.2:854
msgid "B<pwrite>(2)"
msgstr " B<pwrite>(2)"

#. type: TP
#: build/C/man2/syscalls.2:856
#, no-wrap
msgid "Blackfin (port removed in Linux 4.17)"
msgstr ""

#. type: Plain text
#: build/C/man2/syscalls.2:863
msgid "B<bfin_spinlock>(2)  (added in Linux 2.6.22)"
msgstr ""

#. type: Plain text
#: build/C/man2/syscalls.2:866
msgid "B<dma_memcpy>(2)  (added in Linux 2.6.22)"
msgstr ""

#. type: Plain text
#: build/C/man2/syscalls.2:869
msgid "B<pread>(2)  (added in Linux 2.6.22)"
msgstr ""

#. type: Plain text
#: build/C/man2/syscalls.2:872
msgid "B<pwrite>(2)  (added in Linux 2.6.22)"
msgstr ""

#. type: Plain text
#: build/C/man2/syscalls.2:875
msgid "B<sram_alloc>(2)  (added in Linux 2.6.22)"
msgstr ""

#. type: Plain text
#: build/C/man2/syscalls.2:878
msgid "B<sram_free>(2)  (added in Linux 2.6.22)"
msgstr ""

#. type: TP
#: build/C/man2/syscalls.2:880
#, no-wrap
msgid "Metag (port removed in Linux 4.17)"
msgstr ""

#. type: Plain text
#: build/C/man2/syscalls.2:887
msgid "B<metag_get_tls>(2)  (add in Linux 3.9)"
msgstr ""

#. type: Plain text
#: build/C/man2/syscalls.2:890
msgid "B<metag_set_fpu_flags>(2)  (add in Linux 3.9)"
msgstr ""

#. type: Plain text
#: build/C/man2/syscalls.2:893
msgid "B<metag_set_tls>(2)  (add in Linux 3.9)"
msgstr ""

#. type: Plain text
#: build/C/man2/syscalls.2:896
msgid "B<metag_setglobalbit>(2)  (add in Linux 3.9)"
msgstr ""

#. type: TP
#: build/C/man2/syscalls.2:898
#, no-wrap
msgid "Tile (port removed in Linux 4.17)"
msgstr ""

#. type: Plain text
#: build/C/man2/syscalls.2:905
msgid "B<cmpxchg_badaddr>(2)  (added in Linux 2.6.36)"
msgstr ""

#. type: Plain text
#: build/C/man2/syscalls.2:921
msgid ""
"Roughly speaking, the code belonging to the system call with number __NR_xxx "
"defined in I</usr/include/asm/unistd.h> can be found in the Linux kernel "
"source in the routine I<sys_xxx>().  There are many exceptions, however, "
"mostly because older system calls were superseded by newer ones, and this "
"has been treated somewhat unsystematically.  On platforms with proprietary "
"operating-system emulation, such as sparc, sparc64, and alpha, there are "
"many additional system calls; mips64 also contains a full set of 32-bit "
"system calls."
msgstr "たいていは、 I</usr/include/asm/unistd.h> で定義されている番号 __NR_xxx のシステムコールのコードは、 Linux カーネルソースの I<sys_xxx>() というルーチンに書かれている。 しかしこれには多くの例外がある。古いシステムコールは新版に置き換えられて きたが、この置き換えはあまり体系立てて行われて来なかったからである。 sparc, sparc64, alpha といったプロプリエタリなオペレーティングシステムのエミュレーション機能があるプラットフォームでは、多くの追加システムコールがある。 mips64 には、32 ビットシステムコールのフルセットも含まれている。"

#. type: Plain text
#: build/C/man2/syscalls.2:940
#, fuzzy
#| msgid ""
#| "Over time, changes to the interfaces of some system calls have been "
#| "necessary.  One reason for such changes was the need to increase the size "
#| "of structures or scalar values passed to the system call.  Because of "
#| "these changes, there are now various groups of related system calls (e."
#| "g., B<truncate>(2)  and B<truncate64>(2))  which perform similar tasks, "
#| "but which vary in details such as the size of their arguments.  (As noted "
#| "earlier, applications are generally unaware of this: the glibc wrapper "
#| "functions do some work to ensure that the right system call is invoked, "
#| "and that ABI compatibility is preserved for old binaries.)  Examples of "
#| "systems calls that exist in multiple versions are the following:"
msgid ""
"Over time, changes to the interfaces of some system calls have been "
"necessary.  One reason for such changes was the need to increase the size of "
"structures or scalar values passed to the system call.  Because of these "
"changes, certain architectures (notably, longstanding 32-bit architectures "
"such as i386)  now have various groups of related system calls (e.g., "
"B<truncate>(2)  and B<truncate64>(2))  which perform similar tasks, but "
"which vary in details such as the size of their arguments.  (As noted "
"earlier, applications are generally unaware of this: the glibc wrapper "
"functions do some work to ensure that the right system call is invoked, and "
"that ABI compatibility is preserved for old binaries.)  Examples of systems "
"calls that exist in multiple versions are the following:"
msgstr ""
"時間の経過とともに、いくつかのシステムコールではインターフェースの 変更が必要"
"になってきた。 こうした変更の理由の一つは、システムコールに渡される構造体やス"
"カラー値 のサイズを増やす必要があることだった。 これらの変更の結果、現在で"
"は、同様の処理を実行するが 引数のサイズなどの詳細は異なる、一連のシステム"
"コール群が いくつか存在する (例えば、 B<truncate>(2)  と B<truncate64>(2))。 "
"(すでに述べたように、 一般にはアプリケーションがこのことを意識することはな"
"い。 glibc のラッパー関数が、適切なシステムコールを起動し、古いバイナリに 対"
"して ABI レベルでの互換性を保持することを保証する処理を行っている。)  複数の"
"バージョンが存在するシステムコールの例を以下に挙げる。"

#.  e.g., on 2.6.22/i386: __NR_oldstat 18, __NR_stat 106, __NR_stat64 195
#.  The stat system calls deal with three different data structures,
#.  defined in include/asm-i386/stat.h: __old_kernel_stat, stat, stat64
#. type: Plain text
#: build/C/man2/syscalls.2:961
msgid ""
"By now there are three different versions of B<stat>(2): I<sys_stat>()  "
"(slot I<__NR_oldstat>), I<sys_newstat>()  (slot I<__NR_stat>), and "
"I<sys_stat64>()  (slot I<__NR_stat64>), with the last being the most "
"current.  A similar story applies for B<lstat>(2)  and B<fstat>(2)."
msgstr ""
"これまでに、 B<stat>(2)  には 3 種類の異なるバージョンが存在する。 "
"I<sys_stat>()  (スロットは I<__NR_oldstat>)、 I<sys_newstat>()  (スロットは "
"I<__NR_stat>)、 I<sys_stat64>()  (カーネル 2.4 で導入; スロットは "
"I<__NR_stat64>)。 3つのうち最後のものが最新である。 B<lstat>(2)  と "
"B<fstat>(2)  についても同様である。"

#. type: Plain text
#: build/C/man2/syscalls.2:972
msgid ""
"Similarly, the defines I<__NR_oldolduname>, I<__NR_olduname>, and "
"I<__NR_uname> refer to the routines I<sys_olduname>(), I<sys_uname>(), and "
"I<sys_newuname>()."
msgstr ""
"また、 I<__NR_oldolduname>, I<__NR_olduname>, I<__NR_uname> という定義は、そ"
"れぞれ I<sys_olduname>(), I<sys_uname>(), I<sys_newuname>()  というルーチンを"
"参照している。"

#. type: Plain text
#: build/C/man2/syscalls.2:979
msgid ""
"In Linux 2.0, a new version of B<vm86>(2)  appeared, with the old and the "
"new kernel routines being named I<sys_vm86old>()  and I<sys_vm86>()."
msgstr ""
"Linux 2.0 では、 B<vm86>(2)  の新バージョンが登場した。カーネルルーチンの 古"
"いバージョン、新しいバージョンはそれぞれ I<sys_vm86old>(), I<sys_vm86>()  と"
"いう名前である。"

#. type: Plain text
#: build/C/man2/syscalls.2:990
msgid ""
"In Linux 2.4, a new version of B<getrlimit>(2)  appeared, with the old and "
"the new kernel routines being named I<sys_old_getrlimit>()  (slot "
"I<__NR_getrlimit>)  and I<sys_getrlimit>()  (slot I<__NR_ugetrlimit>)."
msgstr ""
"Linux 2.4 では、 B<getrlimit>(2)  の新バージョンが登場した。カーネルルーチン"
"の 古いバージョン、新しいバージョンはそれぞれ I<sys_old_getrlimit>()  (スロッ"
"トは I<__NR_getrlimit>), I<sys_getrlimit>()  (スロットは "
"I<__NR_ugetrlimit>)  という名前である。"

#.  64-bit off_t changes: ftruncate64, *stat64,
#.  fcntl64 (because of the flock structure), getdents64, *statfs64
#. type: Plain text
#: build/C/man2/syscalls.2:1002
msgid ""
"Linux 2.4 increased the size of user and group IDs from 16 to 32 bits.  To "
"support this change, a range of system calls were added (e.g., "
"B<chown32>(2), B<getuid32>(2), B<getgroups32>(2), B<setresuid32>(2)), "
"superseding earlier calls of the same name without the \"32\" suffix."
msgstr ""
"Linux 2.4 で、ユーザー ID とグループ ID のサイズが 16 ビットから 32 ビットに"
"増えた。 この変更に対応するため、いくつかのシステムコールが追加された "
"(B<chown32>(2), B<getuid32>(2), B<getgroups32>(2), B<setresuid32>(2)  な"
"ど)。 これらのシステムコールが、末尾の \"32\" が付かない同名の 古いバージョン"
"に代わって使われるようになった。"

#. type: Plain text
#: build/C/man2/syscalls.2:1019
msgid ""
"Linux 2.4 added support for applications on 32-bit architectures to access "
"large files (i.e., files for which the sizes and file offsets can't be "
"represented in 32 bits.)  To support this change, replacements were required "
"for system calls that deal with file offsets and sizes.  Thus the following "
"system calls were added: B<fcntl64>(2), B<getdents64>(2), B<stat64>(2), "
"B<statfs64>(2), B<truncate64>(2), and their analogs that work with file "
"descriptors or symbolic links.  These system calls supersede the older "
"system calls which, except in the case of the \"stat\" calls, have the same "
"name without the \"64\" suffix."
msgstr "Linux 2.4 では、32 ビットアーキテクチャー上のアプリケーションが 大きなファイル (つまり、32 ビットでは表現できないサイズや ファイルオフセットが必要なファイル) にアクセスできるようになった。 この変更に対応するため、ファイルオフセットとサイズを扱う システムコールの置き換えが必要となった。その結果、 B<fcntl64>(2), B<getdents64>(2), B<stat64>(2), B<statfs64>(2), B<truncate64>(2) と、ファイルディスクリプターやシンボリックリンクで同じ機能を持つ システムコールが追加された。 これらのシステムコールが、末尾の \"64\" が付かない同名の 古いバージョンに代わって使われるようになった。 但し、\"stat\" 系のシステムコールはその限りではない。"

#. type: Plain text
#: build/C/man2/syscalls.2:1025
#, fuzzy
#| msgid ""
#| "On newer platforms that only have 64-bit file access and 32-bit uids (e."
#| "g., alpha, ia64, s390x) there are no *64 or *32 calls.  Where the *64 and "
#| "*32 calls exist, the other versions are obsolete."
msgid ""
"On newer platforms that only have 64-bit file access and 32-bit UIDs/GIDs (e."
"g., alpha, ia64, s390x, x86-64), there is just a single version of the UID/"
"GID and file access system calls.  On platforms (typically, 32-bit "
"platforms) where the *64 and *32 calls exist, the other versions are "
"obsolete."
msgstr ""
"64-bit ファイルアクセスと 32-bit UID のみを持つ 新しいプラットフォーム "
"(alpha, ia64, s390x など) では、 *64 や *32 という名前のシステムコールはな"
"い。 *64 や *32 というシステムコールが存在する場合、 *64 や *32 がついていな"
"いシステムコールは廃止扱いである。"

#. type: Plain text
#: build/C/man2/syscalls.2:1033
msgid ""
"The I<rt_sig*> calls were added in kernel 2.2 to support the addition of "
"real-time signals (see B<signal>(7)).  These system calls supersede the "
"older system calls of the same name without the \"rt_\" prefix."
msgstr ""
"リアルタイムシグナル (B<signal>(7)  参照) への対応を追加するために、 "
"I<rt_sig*> 系のシステムコールがカーネル 2.2 で追加された。 これらのシステム"
"コールが、先頭に \"rt_\" が付かない同名の 古いバージョンに代わって使われるよ"
"うになった。"

#.  (used by libc 6)
#.  .PP
#.  Two system call numbers,
#.  .IR __NR__llseek
#.  and
#.  .IR __NR__sysctl
#.  have an additional underscore absent in
#.  .IR sys_llseek ()
#.  and
#.  .IR sys_sysctl ().
#.  In kernel 2.1.81,
#.  .BR lchown (2)
#.  and
#.  .BR chown (2)
#.  were swapped; that is,
#.  .BR lchown (2)
#.  was added with the semantics that were then current for
#.  .BR chown (2),
#.  and the semantics of the latter call were changed to what
#.  they are today.
#. type: Plain text
#: build/C/man2/syscalls.2:1087
#, fuzzy
#| msgid ""
#| "The B<select>(2)  and B<mmap>(2)  system calls use five or more "
#| "arguments, which caused problems in the way argument passing on the i386 "
#| "used to be set up.  Thus, while other architectures have I<sys_select>()  "
#| "and I<sys_mmap>()  corresponding to I<__NR_select> and I<__NR_mmap>, on "
#| "i386 one finds I<old_select>()  and I<old_mmap>()  (routines that use a "
#| "pointer to a argument block) instead.  These days passing five arguments "
#| "is not a problem any more, and there is a I<__NR__newselect> that "
#| "corresponds directly to I<sys_select>()  and similarly I<__NR_mmap2>."
msgid ""
"The B<select>(2)  and B<mmap>(2)  system calls use five or more arguments, "
"which caused problems in the way argument passing on the i386 used to be set "
"up.  Thus, while other architectures have I<sys_select>()  and "
"I<sys_mmap>()  corresponding to I<__NR_select> and I<__NR_mmap>, on i386 one "
"finds I<old_select>()  and I<old_mmap>()  (routines that use a pointer to an "
"argument block) instead.  These days passing five arguments is not a problem "
"any more, and there is a I<__NR__newselect> that corresponds directly to "
"I<sys_select>()  and similarly I<__NR_mmap2>.  s390x is the only 64-bit "
"architecture that has I<old_mmap>()."
msgstr ""
"B<select>(2)  と B<mmap>(2)  は 5つもしくはそれ以上の引数を使用しており、 "
"i386 では引数の受け渡しに問題が生じる。 そのため、他のアーキテクチャーでは "
"I<__NR_select> と I<__NR_mmap> に対応する I<sys_select>()  と I<sys_mmap>()  "
"が存在するが、i386 では代わりに I<old_select>()  と I<old_mmap>()  というルー"
"チンがある (これらのルーチンは引数ブロックへのポインターを使用する)。 現在"
"では 5つの引数を渡すことはもはや問題ではなくなっており、 "
"I<__NR__newselect> は I<sys_select>()  に直接対応するようになっている。 "
"I<__NR_mmap2> についても同様である。"

#. type: SS
#: build/C/man2/syscalls.2:1087
#, no-wrap
msgid "Architecture-specific details: Alpha"
msgstr "アーキテクチャー固有の詳細: Alpha"

#. type: Plain text
#: build/C/man2/syscalls.2:1094
msgid ""
"B<getxgid>(2)  returns a pair of GID and effective GID via registers B<r0> "
"and B<r20>; it is provided instead of B<getgid>(2) and B<getegid>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/syscalls.2:1099
msgid ""
"B<getxpid>(2)  returns a pair of PID and parent PID via registers B<r0> and "
"B<r20>; it is provided instead of B<getpid>(2) and B<getppid>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/syscalls.2:1103
msgid ""
"B<old_adjtimex>(2)  is a variant of B<adjtimex>(2) that uses I<struct "
"timeval32>, for compatibility with OSF/1."
msgstr ""

#. type: Plain text
#: build/C/man2/syscalls.2:1108
msgid ""
"B<getxuid>(2)  returns a pair of GID and effective GID via registers B<r0> "
"and B<r20>; it is provided instead of B<getuid>(2) and B<geteuid>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/syscalls.2:1112
msgid ""
"B<sethae>(2)  is used for configuring the Host Address Extension register on "
"low-cost Alphas in order to access address space beyond first 27 bits."
msgstr ""

#. type: Plain text
#: build/C/man2/syscalls.2:1119
msgid ""
"B<intro>(2), B<syscall>(2), B<unimplemented>(2), B<errno>(3), B<libc>(7), "
"B<vdso>(7)"
msgstr ""
"B<intro>(2), B<syscall>(2), B<unimplemented>(2), B<errno>(3), B<libc>(7), "
"B<vdso>(7)"

#. type: TH
#: build/C/man3/sysconf.3:27
#, no-wrap
msgid "SYSCONF"
msgstr "SYSCONF"

#. type: TH
#: build/C/man3/sysconf.3:27
#, no-wrap
msgid "2019-05-09"
msgstr " 2019-05-09"

#. type: Plain text
#: build/C/man3/sysconf.3:30
msgid "sysconf - get configuration information at run time"
msgstr "sysconf - 動作中に設定情報を取得する"

#. type: Plain text
#: build/C/man3/sysconf.3:35
#, no-wrap
msgid "B<long sysconf(int >I<name>B<);>\n"
msgstr "B<long sysconf(int >I<name>B<);>\n"

#. type: Plain text
#: build/C/man3/sysconf.3:40
msgid ""
"POSIX allows an application to test at compile or run time whether certain "
"options are supported, or what the value is of certain configurable "
"constants or limits."
msgstr ""
"POSIX では、アプリケーションがコンパイル時や実行時に、 特定のオプションがサ"
"ポートされているかや、 設定可能な特定の定数や制限 (limits) がどんな値かをテス"
"トすることができる。"

#. type: Plain text
#: build/C/man3/sysconf.3:46
msgid ""
"At compile time this is done by including I<E<lt>unistd.hE<gt>> and/or "
"I<E<lt>limits.hE<gt>> and testing the value of certain macros."
msgstr ""
"コンパイル時に行うには、 I<E<lt>unistd.hE<gt>> と I<E<lt>limits.hE<gt>> の両"
"方もしくは一方をインクルードし、 特定のマクロの値を確認する。"

#. type: Plain text
#: build/C/man3/sysconf.3:56
msgid ""
"At run time, one can ask for numerical values using the present function "
"B<sysconf>().  One can ask for numerical values that may depend on the "
"filesystem in which a file resides using B<fpathconf>(3)  and "
"B<pathconf>(3).  One can ask for string values using B<confstr>(3)."
msgstr "実行時には、ここで説明する関数 B<sysconf>()  を使って数値を問い合わせることができる。 ファイルが存在するファイルシステムに依存する数値は、 B<fpathconf>(3) と B<pathconf>(3) を使って確認できる。 文字列の値は B<confstr>(3) を使って確認できる。"

#.  except that sysconf(_SC_OPEN_MAX) may change answer after a call
#.  to setrlimit( ) which changes the RLIMIT_NOFILE soft limit
#. type: Plain text
#: build/C/man3/sysconf.3:61
msgid ""
"The values obtained from these functions are system configuration "
"constants.  They do not change during the lifetime of a process."
msgstr ""
"これらの関数で取得される値は設定可能なシステム定数である。 これらはプロセスの"
"生存期間の間は変化しない。"

#.  and 999 to indicate support for options no longer present in the latest
#.  standard. (?)
#. type: Plain text
#: build/C/man3/sysconf.3:84
msgid ""
"For options, typically, there is a constant B<_POSIX_FOO> that may be "
"defined in I<E<lt>unistd.hE<gt>>.  If it is undefined, one should ask at run "
"time.  If it is defined to -1, then the option is not supported.  If it is "
"defined to 0, then relevant functions and headers exist, but one has to ask "
"at run time what degree of support is available.  If it is defined to a "
"value other than -1 or 0, then the option is supported.  Usually the value "
"(such as 200112L) indicates the year and month of the POSIX revision "
"describing the option.  Glibc uses the value 1 to indicate support as long "
"as the POSIX revision has not been published yet.  The B<sysconf>()  "
"argument will be B<_SC_FOO>.  For a list of options, see B<posixoptions>(7)."
msgstr ""
"オプションを確認できるように、たいていは I<E<lt>unistd.hE<gt>> で定数 "
"B<_POSIX_FOO> が定義されている。 定義されていないときは、実行時に問い合わせを"
"行う必要がある。 その値が -1 に定義されているときは、そのオプションはサポート"
"されていない。 0 に定義されているときは、関連する関数やヘッダーファイルが存在"
"するが、 どの程度サポートされているかは実行時に確認しなければならない。 -1 で"
"も 0 でもない値に定義されているときは、そのオプションがサポート されている。"
"通常は、そのオプションについて記載した POSIX の改訂年月 を示す値になっている "
"(例えば 200112L)。 glibc では 1 が設定されていると、そのオプションはサポート"
"されているが、 POSIX の改訂版がまだ発行されていないことを示す。 "
"B<sysconf>()  の引数には B<_SC_FOO> を指定する。 オプションのリストについて"
"は B<posixoptions>(7)  を参照のこと。"

#. type: Plain text
#: build/C/man3/sysconf.3:104
msgid ""
"For variables or limits, typically, there is a constant B<_FOO>, maybe "
"defined in I<E<lt>limits.hE<gt>>, or B<_POSIX_FOO>, maybe defined in "
"I<E<lt>unistd.hE<gt>>.  The constant will not be defined if the limit is "
"unspecified.  If the constant is defined, it gives a guaranteed value, and a "
"greater value might actually be supported.  If an application wants to take "
"advantage of values which may change between systems, a call to "
"B<sysconf>()  can be made.  The B<sysconf>()  argument will be B<_SC_FOO>."
msgstr ""
"変数や制限を確認できるように、たいていは、 I<E<lt>limits.hE<gt>> で定数 "
"B<_FOO> が、 I<E<lt>unistd.hE<gt>> で B<_POSIX_FOO> が定義されている。 制限が"
"規定されていない場合は定数は定義されない。 定数が定義されているときには、その"
"定数は保証できる値であり、 実際にはもっと大きな値がサポートされていることもあ"
"る。 アプリケーションがシステム毎に変化する値を利用したい場合には、 "
"B<sysconf>()  を呼び出すことで実現できる。 B<sysconf>()  の引数には "
"B<_SC_FOO> を指定する。"

#. type: SS
#: build/C/man3/sysconf.3:104
#, no-wrap
msgid "POSIX.1 variables"
msgstr "POSIX.1 変数"

#. type: Plain text
#: build/C/man3/sysconf.3:109
msgid ""
"We give the name of the variable, the name of the B<sysconf>()  argument "
"used to inquire about its value, and a short description."
msgstr ""
"変数名、その値を取得するのに使われる B<sysconf>()  のパラメーター名、簡単な説"
"明を以下に示す。"

#.  [for the moment: only the things that are unconditionally present]
#.  .TP
#.  .BR AIO_LISTIO_MAX " - " _SC_AIO_LISTIO_MAX
#.  (if _POSIX_ASYNCHRONOUS_IO)
#.  Maximum number of I/O operations in a single list I/O call.
#.  Must not be less than _POSIX_AIO_LISTIO_MAX.
#.  .TP
#.  .BR AIO_MAX " - " _SC_AIO_MAX
#.  (if _POSIX_ASYNCHRONOUS_IO)
#.  Maximum number of outstanding asynchronous I/O operations.
#.  Must not be less than _POSIX_AIO_MAX.
#.  .TP
#.  .BR AIO_PRIO_DELTA_MAX " - " _SC_AIO_PRIO_DELTA_MAX
#.  (if _POSIX_ASYNCHRONOUS_IO)
#.  The maximum amount by which a process can decrease its
#.  asynchronous I/O priority level from its own scheduling priority.
#.  Must be nonnegative.
#. type: Plain text
#: build/C/man3/sysconf.3:128
msgid "First, the POSIX.1 compatible values."
msgstr "まず POSIX.1 互換の変数を示す。"

#. type: TP
#: build/C/man3/sysconf.3:128
#, no-wrap
msgid "B<ARG_MAX> - B<_SC_ARG_MAX>"
msgstr "B<ARG_MAX> - B<_SC_ARG_MAX>"

#. type: Plain text
#: build/C/man3/sysconf.3:136
msgid ""
"The maximum length of the arguments to the B<exec>(3)  family of functions.  "
"Must not be less than B<_POSIX_ARG_MAX> (4096)."
msgstr ""
"B<exec>(3)  関数群の引数の最大長。 B<_POSIX_ARG_MAX> (4096) 未満であっては"
"ならない。"

#. type: TP
#: build/C/man3/sysconf.3:136
#, no-wrap
msgid "B<CHILD_MAX> - B<_SC_CHILD_MAX>"
msgstr "B<CHILD_MAX> - B<_SC_CHILD_MAX>"

#. type: Plain text
#: build/C/man3/sysconf.3:142
msgid ""
"The maximum number of simultaneous processes per user ID.  Must not be less "
"than B<_POSIX_CHILD_MAX> (25)."
msgstr ""
"ユーザーID あたりの同時に存在できるプロセスの最大数。 B<_POSIX_CHILD_MAX> "
"(25) 未満であってはならない。"

#. type: TP
#: build/C/man3/sysconf.3:142
#, no-wrap
msgid "B<HOST_NAME_MAX> - B<_SC_HOST_NAME_MAX>"
msgstr "B<HOST_NAME_MAX> - B<_SC_HOST_NAME_MAX>"

#. type: Plain text
#: build/C/man3/sysconf.3:150
msgid ""
"Maximum length of a hostname, not including the terminating null byte, as "
"returned by B<gethostname>(2).  Must not be less than "
"B<_POSIX_HOST_NAME_MAX> (255)."
msgstr ""
"B<gethostname>(2)  で返されるホスト名の最大長。末尾のヌルバイトは長さに含まれ"
"ない。 B<_POSIX_HOST_NAME_MAX> (255) 未満であってはならない。"

#. type: TP
#: build/C/man3/sysconf.3:150
#, no-wrap
msgid "B<LOGIN_NAME_MAX> - B<_SC_LOGIN_NAME_MAX>"
msgstr "B<LOGIN_NAME_MAX> - B<_SC_LOGIN_NAME_MAX>"

#. type: Plain text
#: build/C/man3/sysconf.3:156
msgid ""
"Maximum length of a login name, including the terminating null byte.  Must "
"not be less than B<_POSIX_LOGIN_NAME_MAX> (9)."
msgstr ""
"ログイン名の長さの最大値。末尾のヌルバイトも長さに含まれる。 "
"B<_POSIX_LOGIN_NAME_MAX> (9) 未満であってはならない。"

#. type: TP
#: build/C/man3/sysconf.3:156
#, no-wrap
msgid "B<NGROUPS_MAX> - B<_SC_NGROUPS_MAX>"
msgstr "B<NGROUPS_MAX> - B<_SC_NGROUPS_MAX>"

#. type: Plain text
#: build/C/man3/sysconf.3:159
msgid "Maximum number of supplementary group IDs."
msgstr "補助グループ ID の最大数。"

#. type: TP
#: build/C/man3/sysconf.3:159
#, no-wrap
msgid "clock ticks - B<_SC_CLK_TCK>"
msgstr "clock ticks - B<_SC_CLK_TCK>"

#. type: Plain text
#: build/C/man3/sysconf.3:168
msgid ""
"The number of clock ticks per second.  The corresponding variable is "
"obsolete.  It was of course called B<CLK_TCK>.  (Note: the macro "
"B<CLOCKS_PER_SEC> does not give information: it must equal 1000000.)"
msgstr ""
"1秒あたりのクロックティック数。 対応する変数は廃止された。この変数は当然なが"
"ら B<CLK_TCK> と呼ばれていた。 (注意: マクロ B<CLOCKS_PER_SEC> からは情報は得"
"られない: この値は 1000000 でなければならない)"

#. type: TP
#: build/C/man3/sysconf.3:168
#, no-wrap
msgid "B<OPEN_MAX> - B<_SC_OPEN_MAX>"
msgstr "B<OPEN_MAX> - B<_SC_OPEN_MAX>"

#. type: Plain text
#: build/C/man3/sysconf.3:174
msgid ""
"The maximum number of files that a process can have open at any time.  Must "
"not be less than B<_POSIX_OPEN_MAX> (20)."
msgstr ""
"一つのプロセスが同時にオープンできるファイル数の上限。 B<_POSIX_OPEN_MAX> "
"(20) 未満であってはならない。"

#. type: TP
#: build/C/man3/sysconf.3:174
#, no-wrap
msgid "B<PAGESIZE> - B<_SC_PAGESIZE>"
msgstr "B<PAGESIZE> - B<_SC_PAGESIZE>"

#. type: Plain text
#: build/C/man3/sysconf.3:178
msgid "Size of a page in bytes.  Must not be less than 1."
msgstr "バイト単位でのページサイズ。 1 より小さくなってはならない。"

#. type: TP
#: build/C/man3/sysconf.3:178
#, no-wrap
msgid "B<PAGE_SIZE> - B<_SC_PAGE_SIZE>"
msgstr " B<PAGE_SIZE> - B<_SC_PAGE_SIZE>"

#. type: Plain text
#: build/C/man3/sysconf.3:187
msgid ""
"A synonym for B<PAGESIZE>/B<_SC_PAGESIZE>.  (Both B<PAGESIZE> and "
"B<PAGE_SIZE> are specified in POSIX.)"
msgstr ""

#. type: TP
#: build/C/man3/sysconf.3:187 build/C/man3/sysconf.3:274
#, no-wrap
msgid "B<RE_DUP_MAX> - B<_SC_RE_DUP_MAX>"
msgstr "B<RE_DUP_MAX> - B<_SC_RE_DUP_MAX>"

#. type: Plain text
#: build/C/man3/sysconf.3:196
msgid ""
"The number of repeated occurrences of a BRE permitted by B<regexec>(3)  and "
"B<regcomp>(3).  Must not be less than B<_POSIX2_RE_DUP_MAX> (255)."
msgstr ""
"B<regexec>(3)  と B<regcomp>(3)  で許容されている BRE (Basic Regular "
"Expression; 基本正規表現)  の繰り返し出現回数の最大値。 "
"B<_POSIX2_RE_DUP_MAX> (255) 未満であってはならない。"

#. type: TP
#: build/C/man3/sysconf.3:196
#, no-wrap
msgid "B<STREAM_MAX> - B<_SC_STREAM_MAX>"
msgstr "B<STREAM_MAX> - B<_SC_STREAM_MAX>"

#. type: Plain text
#: build/C/man3/sysconf.3:205
msgid ""
"The maximum number of streams that a process can have open at any time.  If "
"defined, it has the same value as the standard C macro B<FOPEN_MAX>.  Must "
"not be less than B<_POSIX_STREAM_MAX> (8)."
msgstr ""
"一つのプロセスが同時にオープンできるストリーム数の上限。 定義されていた場合に"
"は、この値は標準 C マクロの B<FOPEN_MAX> と同じである。 B<_POSIX_STREAM_MAX> "
"(8) 未満であってはならない。"

#. type: TP
#: build/C/man3/sysconf.3:205
#, no-wrap
msgid "B<SYMLOOP_MAX> - B<_SC_SYMLOOP_MAX>"
msgstr "B<SYMLOOP_MAX> - B<_SC_SYMLOOP_MAX>"

#. type: Plain text
#: build/C/man3/sysconf.3:213
msgid ""
"The maximum number of symbolic links seen in a pathname before resolution "
"returns B<ELOOP>.  Must not be less than B<_POSIX_SYMLOOP_MAX> (8)."
msgstr ""
"パス名の解決時に現れてもよいシンボリックリンクの最大数。 この数を超えると、パ"
"ス名解決時に B<ELOOP> が返される。 B<_POSIX_SYMLOOP_MAX> (8) 未満であってはな"
"らない。"

#. type: TP
#: build/C/man3/sysconf.3:213
#, no-wrap
msgid "B<TTY_NAME_MAX> - B<_SC_TTY_NAME_MAX>"
msgstr "B<TTY_NAME_MAX> - B<_SC_TTY_NAME_MAX>"

#. type: Plain text
#: build/C/man3/sysconf.3:220
msgid ""
"The maximum length of terminal device name, including the terminating null "
"byte.  Must not be less than B<_POSIX_TTY_NAME_MAX> (9)."
msgstr ""
"端末デバイス名の最大長。長さには末尾のヌルバイトも含まれる。 "
"B<_POSIX_TTY_NAME_MAX> (9) 未満であってはならない。"

#. type: TP
#: build/C/man3/sysconf.3:220
#, no-wrap
msgid "B<TZNAME_MAX> - B<_SC_TZNAME_MAX>"
msgstr "B<TZNAME_MAX> - B<_SC_TZNAME_MAX>"

#. type: Plain text
#: build/C/man3/sysconf.3:226
msgid ""
"The maximum number of bytes in a timezone name.  Must not be less than "
"B<_POSIX_TZNAME_MAX> (6)."
msgstr ""
"タイムゾーン名として使えるバイト数の最大値。 B<_POSIX_TZNAME_MAX> (6) 未満で"
"あってはならない。"

#. type: TP
#: build/C/man3/sysconf.3:226
#, no-wrap
msgid "B<_POSIX_VERSION> - B<_SC_VERSION>"
msgstr "B<_POSIX_VERSION> - B<_SC_VERSION>"

#. type: Plain text
#: build/C/man3/sysconf.3:234
msgid ""
"indicates the year and month the POSIX.1 standard was approved in the format "
"B<YYYYMML>; the value B<199009L> indicates the Sept. 1990 revision."
msgstr ""
"POSIX.1 標準が承認された年月。 B<YYYYMML> という書式である。 B<199009L> とい"
"う値は、1990年 9月 改訂であることを示す。"

#. type: SS
#: build/C/man3/sysconf.3:234
#, no-wrap
msgid "POSIX.2 variables"
msgstr "POSIX.2 変数"

#. type: Plain text
#: build/C/man3/sysconf.3:236
msgid "Next, the POSIX.2 values, giving limits for utilities."
msgstr ""
"次に、POSIX.2 の値を示す。 これらは各ユーティリティに対する制限を指定する。"

#. type: TP
#: build/C/man3/sysconf.3:236
#, no-wrap
msgid "B<BC_BASE_MAX> - B<_SC_BC_BASE_MAX>"
msgstr "B<BC_BASE_MAX> - B<_SC_BC_BASE_MAX>"

#. type: Plain text
#: build/C/man3/sysconf.3:243
msgid "indicates the maximum I<obase> value accepted by the B<bc>(1)  utility."
msgstr "B<bc>(1)  ユーティリティで許容される I<obase> の最大値。"

#. type: TP
#: build/C/man3/sysconf.3:243
#, no-wrap
msgid "B<BC_DIM_MAX> - B<_SC_BC_DIM_MAX>"
msgstr "B<BC_DIM_MAX> - B<_SC_BC_DIM_MAX>"

#. type: Plain text
#: build/C/man3/sysconf.3:247
msgid ""
"indicates the maximum value of elements permitted in an array by B<bc>(1)."
msgstr "B<bc>(1)  で許容される一つの配列中の要素数の最大値。"

#. type: TP
#: build/C/man3/sysconf.3:247
#, no-wrap
msgid "B<BC_SCALE_MAX> - B<_SC_BC_SCALE_MAX>"
msgstr "B<BC_SCALE_MAX> - B<_SC_BC_SCALE_MAX>"

#. type: Plain text
#: build/C/man3/sysconf.3:253
msgid "indicates the maximum I<scale> value allowed by B<bc>(1)."
msgstr "B<bc>(1)  で許される I<scale> の最大値。"

#. type: TP
#: build/C/man3/sysconf.3:253
#, no-wrap
msgid "B<BC_STRING_MAX> - B<_SC_BC_STRING_MAX>"
msgstr "B<BC_STRING_MAX> - B<_SC_BC_STRING_MAX>"

#. type: Plain text
#: build/C/man3/sysconf.3:257
msgid "indicates the maximum length of a string accepted by B<bc>(1)."
msgstr "B<bc>(1)  で許容される文字列の最大長。"

#. type: TP
#: build/C/man3/sysconf.3:257
#, no-wrap
msgid "B<COLL_WEIGHTS_MAX> - B<_SC_COLL_WEIGHTS_MAX>"
msgstr "B<COLL_WEIGHTS_MAX> - B<_SC_COLL_WEIGHTS_MAX>"

#. type: Plain text
#: build/C/man3/sysconf.3:263
msgid ""
"indicates the maximum numbers of weights that can be assigned to an entry of "
"the B<LC_COLLATE order> keyword in the locale definition file."
msgstr ""
"ロケール定義ファイル中の B<LC_COLLATE order> キーワードのエントリーに割り当て"
"可能な重みの最大値。"

#. type: TP
#: build/C/man3/sysconf.3:263
#, no-wrap
msgid "B<EXPR_NEST_MAX> - B<_SC_EXPR_NEST_MAX>"
msgstr "B<EXPR_NEST_MAX> - B<_SC_EXPR_NEST_MAX>"

#. type: Plain text
#: build/C/man3/sysconf.3:268
msgid ""
"is the maximum number of expressions which can be nested within parentheses "
"by B<expr>(1)."
msgstr "B<expr>(1)  において、括弧で入れ子にできる式の最大数。"

#. type: TP
#: build/C/man3/sysconf.3:268
#, no-wrap
msgid "B<LINE_MAX> - B<_SC_LINE_MAX>"
msgstr "B<LINE_MAX> - B<_SC_LINE_MAX>"

#. type: Plain text
#: build/C/man3/sysconf.3:274
msgid ""
"The maximum length of a utility's input line, either from standard input or "
"from a file.  This includes space for a trailing newline."
msgstr ""
"ユーティリティの入力行の最大長。標準入力だけでなく、ファイルからの入力にも 適"
"用される。長さには行の末尾の改行文字も含まれる。"

#. type: Plain text
#: build/C/man3/sysconf.3:280
msgid ""
"The maximum number of repeated occurrences of a regular expression when the "
"interval notation B<\\e{m,n\\e}> is used."
msgstr ""
"正規表現で区間表記 (interval notation)  B<\\e{m,n\\e}> が使用されたときに許容"
"される繰り返し出現回数の最大値。"

#. type: TP
#: build/C/man3/sysconf.3:280
#, no-wrap
msgid "B<POSIX2_VERSION> - B<_SC_2_VERSION>"
msgstr "B<POSIX2_VERSION> - B<_SC_2_VERSION>"

#. type: Plain text
#: build/C/man3/sysconf.3:284
msgid "indicates the version of the POSIX.2 standard in the format of YYYYMML."
msgstr "POSIX.2 標準のバージョン。YYYYMML という書式で表記される。"

#. type: TP
#: build/C/man3/sysconf.3:284
#, no-wrap
msgid "B<POSIX2_C_DEV> - B<_SC_2_C_DEV>"
msgstr "B<POSIX2_C_DEV> - B<_SC_2_C_DEV>"

#. type: Plain text
#: build/C/man3/sysconf.3:288
msgid ""
"indicates whether the POSIX.2 C language development facilities are "
"supported."
msgstr "POSIX.2 の C 言語開発機能がサポートされているかを示す。"

#. type: TP
#: build/C/man3/sysconf.3:288
#, no-wrap
msgid "B<POSIX2_FORT_DEV> - B<_SC_2_FORT_DEV>"
msgstr "B<POSIX2_FORT_DEV> - B<_SC_2_FORT_DEV>"

#. type: Plain text
#: build/C/man3/sysconf.3:292
msgid ""
"indicates whether the POSIX.2 FORTRAN development utilities are supported."
msgstr "POSIX.2 の FORTRAN 開発ユーティリティがサポートされているかを示す。"

#. type: TP
#: build/C/man3/sysconf.3:292
#, no-wrap
msgid "B<POSIX2_FORT_RUN> - B<_SC_2_FORT_RUN>"
msgstr "B<POSIX2_FORT_RUN> - B<_SC_2_FORT_RUN>"

#. type: Plain text
#: build/C/man3/sysconf.3:295
msgid "indicates whether the POSIX.2 FORTRAN run-time utilities are supported."
msgstr ""
"POSIX.2 の FORTRAN ランタイムユーティリティがサポートされているかを示す。"

#. type: TP
#: build/C/man3/sysconf.3:295
#, no-wrap
msgid "B<_POSIX2_LOCALEDEF> - B<_SC_2_LOCALEDEF>"
msgstr "B<_POSIX2_LOCALEDEF> - B<_SC_2_LOCALEDEF>"

#. type: Plain text
#: build/C/man3/sysconf.3:300
msgid ""
"indicates whether the POSIX.2 creation of locales via B<localedef>(1)  is "
"supported."
msgstr ""
"B<localedef>(1)  を使った、POSIX.2 のロケールの作成をサポートしているかを示"
"す。"

#. type: TP
#: build/C/man3/sysconf.3:300
#, no-wrap
msgid "B<POSIX2_SW_DEV> - B<_SC_2_SW_DEV>"
msgstr "B<POSIX2_SW_DEV> - B<_SC_2_SW_DEV>"

#. type: Plain text
#: build/C/man3/sysconf.3:304
msgid ""
"indicates whether the POSIX.2 software development utilities option is "
"supported."
msgstr ""
"POSIX.2 ソフトウェア開発ユーティリティオプションがサポートされているかを示"
"す。"

#. type: Plain text
#: build/C/man3/sysconf.3:306
msgid "These values also exist, but may not be standard."
msgstr "以下の値も存在するが、標準には含まれていない。"

#. type: TP
#: build/C/man3/sysconf.3:306
#, no-wrap
msgid " - B<_SC_PHYS_PAGES>"
msgstr " - B<_SC_PHYS_PAGES>"

#. type: Plain text
#: build/C/man3/sysconf.3:313
msgid ""
"The number of pages of physical memory.  Note that it is possible for the "
"product of this value and the value of B<_SC_PAGESIZE> to overflow."
msgstr ""
"物理メモリーのページ数。 この値と B<_SC_PAGESIZE> 値の積は桁溢れする可能性が"
"あるので注意すること。"

#. type: TP
#: build/C/man3/sysconf.3:313
#, no-wrap
msgid " - B<_SC_AVPHYS_PAGES>"
msgstr " - B<_SC_AVPHYS_PAGES>"

#. type: Plain text
#: build/C/man3/sysconf.3:316
msgid "The number of currently available pages of physical memory."
msgstr "現在利用可能な物理メモリーのページ数。"

#. type: TP
#: build/C/man3/sysconf.3:316
#, no-wrap
msgid " - B<_SC_NPROCESSORS_CONF>"
msgstr " - B<_SC_NPROCESSORS_CONF>"

#. type: Plain text
#: build/C/man3/sysconf.3:321
msgid "The number of processors configured.  See also B<get_nprocs_conf>(3)."
msgstr "設定されたプロセッサ数。 B<get_nprocs_conf>(3) も参照。"

#. type: TP
#: build/C/man3/sysconf.3:321
#, no-wrap
msgid " - B<_SC_NPROCESSORS_ONLN>"
msgstr " - B<_SC_NPROCESSORS_ONLN>"

#. type: Plain text
#: build/C/man3/sysconf.3:326
msgid ""
"The number of processors currently online (available).  See also "
"B<get_nprocs_conf>(3)."
msgstr "現在オンラインの (利用可能な) プロセッサ数。 B<get_nprocs_conf>(3) も参照。"

#. type: Plain text
#: build/C/man3/sysconf.3:330
msgid "The return value of B<sysconf>()  is one of the following:"
msgstr ""

#. type: tbl table
#: build/C/man3/sysconf.3:381
#, no-wrap
msgid "B<sysconf>()"
msgstr " B<sysconf>()"

#. type: Plain text
#: build/C/man3/sysconf.3:391
msgid ""
"It is difficult to use B<ARG_MAX> because it is not specified how much of "
"the argument space for B<exec>(3)  is consumed by the user's environment "
"variables."
msgstr ""
"B<ARG_MAX> を使うのは難しい、なぜなら、 B<exec>(3)  の引数領域 (argument "
"space) のうちどれくらいが ユーザーの環境変数によって使われるかは分からないか"
"らである。"

#. type: Plain text
#: build/C/man3/sysconf.3:403
msgid ""
"B<bc>(1), B<expr>(1), B<getconf>(1), B<locale>(1), B<confstr>(3), "
"B<fpathconf>(3), B<pathconf>(3), B<posixoptions>(7)"
msgstr ""
"B<bc>(1), B<expr>(1), B<getconf>(1), B<locale>(1), B<confstr>(3), "
"B<fpathconf>(3), B<pathconf>(3), B<posixoptions>(7)"

#. type: TH
#: build/C/man2/sysctl.2:30
#, no-wrap
msgid "SYSCTL"
msgstr "SYSCTL"

#. type: Plain text
#: build/C/man2/sysctl.2:33
msgid "sysctl - read/write system parameters"
msgstr "sysctl - システムパラメーターを読み書きする"

#. type: Plain text
#: build/C/man2/sysctl.2:37
#, no-wrap
msgid ""
"B<#include E<lt>unistd.hE<gt>>\n"
"B<#include E<lt>linux/sysctl.hE<gt>>\n"
msgstr ""
" B<#include E<lt>unistd.hE<gt>>\n"
"B<#include E<lt>linux/sysctl.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/sysctl.2:39
#, no-wrap
msgid "B<int _sysctl(struct __sysctl_args *>I<args>B<);>\n"
msgstr "B<int _sysctl(struct __sysctl_args *>I<args>B<);>\n"

#. type: Plain text
#: build/C/man2/sysctl.2:43
msgid "B<This system call no longer exists on current kernels!> See NOTES."
msgstr ""

#. type: Plain text
#: build/C/man2/sysctl.2:50
msgid ""
"The B<_sysctl>()  call reads and/or writes kernel parameters.  For example, "
"the hostname, or the maximum number of open files.  The argument has the form"
msgstr ""
"B<_sysctl>()  コールはカーネルパラメーターを読み書きする。例えば、 ホストネー"
"ムや同時にオープンできるファイルの最大数など。 引数は以下の形式である。"

#. type: Plain text
#: build/C/man2/sysctl.2:62
#, no-wrap
msgid ""
"struct __sysctl_args {\n"
"    int    *name;    /* integer vector describing variable */\n"
"    int     nlen;    /* length of this vector */\n"
"    void   *oldval;  /* 0 or address where to store old value */\n"
"    size_t *oldlenp; /* available room for old value,\n"
"                        overwritten by actual size of old value */\n"
"    void   *newval;  /* 0 or address of new value */\n"
"    size_t  newlen;  /* size of new value */\n"
"};\n"
msgstr ""
"struct __sysctl_args {\n"
"    int    *name;    /* integer vector describing variable */\n"
"    int     nlen;    /* length of this vector */\n"
"    void   *oldval;  /* 0 or address where to store old value */\n"
"    size_t *oldlenp; /* available room for old value,\n"
"                        overwritten by actual size of old value */\n"
"    void   *newval;  /* 0 or address of new value */\n"
"    size_t  newlen;  /* size of new value */\n"
"};\n"

#. type: Plain text
#: build/C/man2/sysctl.2:70
msgid ""
"This call does a search in a tree structure, possibly resembling a directory "
"tree under I</proc/sys>, and if the requested item is found calls some "
"appropriate routine to read or modify the value."
msgstr ""
"このコールは I</proc/sys> の下のディレクトリツリーに似た木構造(tree "
"structure)を検索する。 そして、要求された項目が見つかった場合は適切なルーチン"
"を呼び出して 値を読んだり修正したりする。"

#. type: Plain text
#: build/C/man2/sysctl.2:77
msgid ""
"Upon successful completion, B<_sysctl>()  returns 0.  Otherwise, a value of "
"-1 is returned and I<errno> is set to indicate the error."
msgstr ""
"成功した場合は B<_sysctl>()  は 0 を返す。失敗した場合、-1 が返され、 "
"I<errno> がそのエラーを示す値に設定される。"

#. type: TP
#: build/C/man2/sysctl.2:78
#, no-wrap
msgid "B<EACCES>, B<EPERM>"
msgstr "B<EACCES> か B<EPERM>"

#. type: Plain text
#: build/C/man2/sysctl.2:86
msgid ""
"No search permission for one of the encountered \"directories\", or no read "
"permission where I<oldval> was nonzero, or no write permission where "
"I<newval> was nonzero."
msgstr ""
"「ディレクトリ」のどれかに検索許可がなかったか、 I<oldval> が 0 でないのに読"
"み込み許可がなかったか、 I<newval> が 0 でないのに書き込み許可がなかった。"

#. type: Plain text
#: build/C/man2/sysctl.2:92
msgid ""
"The invocation asked for the previous value by setting I<oldval> non-NULL, "
"but allowed zero room in I<oldlenp>."
msgstr ""
"I<oldval> に NULL でない値を設定して、以前の値を要求しているのに、 "
"I<oldlenp> に空きがない。"

#. type: Plain text
#: build/C/man2/sysctl.2:96
msgid "I<name> was not found."
msgstr "I<name> が見つからなかった。"

#. type: Plain text
#: build/C/man2/sysctl.2:99
msgid ""
"This system call first appeared in Linux 1.3.57.  It was removed in Linux "
"5.5; glibc support was removed in version 2.32."
msgstr ""

#. type: Plain text
#: build/C/man2/sysctl.2:110
msgid ""
"This call is Linux-specific, and should not be used in programs intended to "
"be portable.  It originated in 4.4BSD.  Only Linux has the I</proc/sys> "
"mirror, and the object naming schemes differ between Linux and 4.4BSD, but "
"the declaration of the B<sysctl>()  function is the same in both."
msgstr "このコールは Linux 特有であり、移植を意図したプログラムで使用しては いけない。これは 4.4BSD に由来している。Linux は I</proc/sys> に写し(mirror)をもっており、項目の名前の付け方が Linux と 4.4BSD では 異っている。しかし B<sysctl>()  関数の宣言は両方で同じである。"

#. type: Plain text
#: build/C/man2/sysctl.2:118
msgid ""
"Use of this system call was long discouraged: since Linux 2.6.24, uses of "
"this system call result in warnings in the kernel log, and in Linux 5.5, the "
"system call was finally removed.  Use the I</proc/sys> interface instead."
msgstr ""

#. type: Plain text
#: build/C/man2/sysctl.2:127
msgid ""
"Note that on older kernels where this system call still exists, it is "
"available only if the kernel was configured with the "
"B<CONFIG_SYSCTL_SYSCALL> option.  Furthermore, glibc does not provide a "
"wrapper for this system call, necessitating the use of B<syscall>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/sysctl.2:130
msgid ""
"The object names vary between kernel versions, making this system call "
"worthless for applications."
msgstr ""
"オブジェクトの名前は、カーネルのバージョンごとに異なっている。 このため、この"
"システムコールはアプリケーションにとって 無価値なものとなっている。"

#. type: Plain text
#: build/C/man2/sysctl.2:132
msgid "Not all available objects are properly documented."
msgstr "全ての可能な項目が正確に記述されているわけではない。"

#. type: Plain text
#: build/C/man2/sysctl.2:135
msgid ""
"It is not yet possible to change operating system by writing to I</proc/sys/"
"kernel/ostype>."
msgstr ""
"今のところ I</proc/sys/kernel/ostype> に書き込むことでオペーレーティングシス"
"テムを変えることはできない。"

#. type: Plain text
#: build/C/man2/sysctl.2:144
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/syscall.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>linux/sysctl.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/syscall.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>linux/sysctl.hE<gt>\n"

#. type: Plain text
#: build/C/man2/sysctl.2:146
#, no-wrap
msgid "int _sysctl(struct __sysctl_args *args );\n"
msgstr "int _sysctl(struct __sysctl_args *args );\n"

#. type: Plain text
#: build/C/man2/sysctl.2:148
#, no-wrap
msgid "#define OSNAMESZ 100\n"
msgstr "#define OSNAMESZ 100\n"

#. type: Plain text
#: build/C/man2/sysctl.2:156
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    struct __sysctl_args args;\n"
"    char osname[OSNAMESZ];\n"
"    size_t osnamelth;\n"
"    int name[] = { CTL_KERN, KERN_OSTYPE };\n"
msgstr ""
"int\n"
"main(void)\n"
"{\n"
"    struct __sysctl_args args;\n"
"    char osname[OSNAMESZ];\n"
"    size_t osnamelth;\n"
"    int name[] = { CTL_KERN, KERN_OSTYPE };\n"

#. type: Plain text
#: build/C/man2/sysctl.2:162
#, no-wrap
msgid ""
"    memset(&args, 0, sizeof(args));\n"
"    args.name = name;\n"
"    args.nlen = sizeof(name)/sizeof(name[0]);\n"
"    args.oldval = osname;\n"
"    args.oldlenp = &osnamelth;\n"
msgstr ""
"     memset(&args, 0, sizeof(args));\n"
"    args.name = name;\n"
"    args.nlen = sizeof(name)/sizeof(name[0]);\n"
"    args.oldval = osname;\n"
"    args.oldlenp = &osnamelth;\n"

#. type: Plain text
#: build/C/man2/sysctl.2:164
#, no-wrap
msgid "    osnamelth = sizeof(osname);\n"
msgstr "    osnamelth = sizeof(osname);\n"

#. type: Plain text
#: build/C/man2/sysctl.2:172
#, no-wrap
msgid ""
"    if (syscall(SYS__sysctl, &args) == -1) {\n"
"        perror(\"_sysctl\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
"    printf(\"This machine is running %*s\\en\", osnamelth, osname);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    if (syscall(SYS__sysctl, &args) == -1) {\n"
"        perror(\"_sysctl\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
"    printf(\"This machine is running %*s\\en\", osnamelth, osname);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man2/sysctl.2:175 build/C/man2/sysinfo.2:124
msgid "B<proc>(5)"
msgstr "B<proc>(5)"

#. type: TH
#: build/C/man2/sysinfo.2:35
#, no-wrap
msgid "SYSINFO"
msgstr "SYSINFO"

#. type: Plain text
#: build/C/man2/sysinfo.2:38
msgid "sysinfo - return system information"
msgstr "sysinfo - システム情報を返す"

#. type: Plain text
#: build/C/man2/sysinfo.2:42
msgid "B<int sysinfo(struct sysinfo *>I<info>B<);>"
msgstr "B<int sysinfo(struct sysinfo *>I<info>B<);>"

#. type: Plain text
#: build/C/man2/sysinfo.2:46
msgid ""
"B<sysinfo>()  returns certain statistics on memory and swap usage, as well "
"as the load average."
msgstr ""

#. type: Plain text
#: build/C/man2/sysinfo.2:50
msgid ""
"Until Linux 2.3.16, B<sysinfo>()  returned information in the following "
"structure:"
msgstr "Linux 2.3.16 までは B<sysinfo>()  は以下の構造体に情報を入れて返した。"

#. type: Plain text
#: build/C/man2/sysinfo.2:65
#, no-wrap
msgid ""
"struct sysinfo {\n"
"    long uptime;             /* Seconds since boot */\n"
"    unsigned long loads[3];  /* 1, 5, and 15 minute load averages */\n"
"    unsigned long totalram;  /* Total usable main memory size */\n"
"    unsigned long freeram;   /* Available memory size */\n"
"    unsigned long sharedram; /* Amount of shared memory */\n"
"    unsigned long bufferram; /* Memory used by buffers */\n"
"    unsigned long totalswap; /* Total swap space size */\n"
"    unsigned long freeswap;  /* Swap space still available */\n"
"    unsigned short procs;    /* Number of current processes */\n"
"    char _f[22];             /* Pads structure to 64 bytes */\n"
"};\n"
msgstr ""
" struct sysinfo {\n"
"    long uptime;             /* Seconds since boot */\n"
"    unsigned long loads[3];  /* 1, 5, and 15 minute load averages */\n"
"    unsigned long totalram;  /* Total usable main memory size */\n"
"    unsigned long freeram;   /* Available memory size */\n"
"    unsigned long sharedram; /* Amount of shared memory */\n"
"    unsigned long bufferram; /* Memory used by buffers */\n"
"    unsigned long totalswap; /* Total swap space size */\n"
"    unsigned long freeswap;  /* Swap space still available */\n"
"    unsigned short procs;    /* Number of current processes */\n"
"    char _f[22];             /* Pads structure to 64 bytes */\n"
"};\n"

#. type: Plain text
#: build/C/man2/sysinfo.2:70
msgid ""
"In the above structure, the sizes of the memory and swap fields are given in "
"bytes."
msgstr ""

#. type: Plain text
#: build/C/man2/sysinfo.2:73
msgid ""
"Since Linux 2.3.23 (i386) and Linux 2.3.48 (all architectures) the structure "
"is:"
msgstr "Linux 2.3.23 (i386)、Linux 2.3.48 (全てのアーキテクチャー) 以降では、構造体は"

#. type: Plain text
#: build/C/man2/sysinfo.2:92
#, no-wrap
msgid ""
"struct sysinfo {\n"
"    long uptime;             /* Seconds since boot */\n"
"    unsigned long loads[3];  /* 1, 5, and 15 minute load averages */\n"
"    unsigned long totalram;  /* Total usable main memory size */\n"
"    unsigned long freeram;   /* Available memory size */\n"
"    unsigned long sharedram; /* Amount of shared memory */\n"
"    unsigned long bufferram; /* Memory used by buffers */\n"
"    unsigned long totalswap; /* Total swap space size */\n"
"    unsigned long freeswap;  /* Swap space still available */\n"
"    unsigned short procs;    /* Number of current processes */\n"
"    unsigned long totalhigh; /* Total high memory size */\n"
"    unsigned long freehigh;  /* Available high memory size */\n"
"    unsigned int mem_unit;   /* Memory unit size in bytes */\n"
"    char _f[20-2*sizeof(long)-sizeof(int)];\n"
"                             /* Padding to 64 bytes */\n"
"};\n"
msgstr ""
" struct sysinfo {\n"
"    long uptime;             /* Seconds since boot */\n"
"    unsigned long loads[3];  /* 1, 5, and 15 minute load averages */\n"
"    unsigned long totalram;  /* Total usable main memory size */\n"
"    unsigned long freeram;   /* Available memory size */\n"
"    unsigned long sharedram; /* Amount of shared memory */\n"
"    unsigned long bufferram; /* Memory used by buffers */\n"
"    unsigned long totalswap; /* Total swap space size */\n"
"    unsigned long freeswap;  /* Swap space still available */\n"
"    unsigned short procs;    /* Number of current processes */\n"
"    unsigned long totalhigh; /* Total high memory size */\n"
"    unsigned long freehigh;  /* Available high memory size */\n"
"    unsigned int mem_unit;   /* Memory unit size in bytes */\n"
"    char _f[20-2*sizeof(long)-sizeof(int)];\n"
"                             /* Padding to 64 bytes */\n"
"};\n"

#. type: Plain text
#: build/C/man2/sysinfo.2:99
#, fuzzy
#| msgid "and the sizes are given as multiples of I<mem_unit> bytes."
msgid ""
"In the above structure, sizes of the memory and swap fields are given as "
"multiples of I<mem_unit> bytes."
msgstr "となり、大きさは I<mem_unit> バイトの倍数で与えられる。"

#. type: Plain text
#: build/C/man2/sysinfo.2:106
msgid ""
"On success, B<sysinfo>()  returns zero.  On error, -1 is returned, and "
"I<errno> is set to indicate the cause of the error."
msgstr "成功すると、 B<sysinfo>()  は 0 を返す。 エラーの場合、-1 を返し、 I<errno> にエラーの原因を示す値を設定する。"

#. type: Plain text
#: build/C/man2/sysinfo.2:111
msgid "I<info> is not a valid address."
msgstr "I<info> が有効なアドレスではない。"

#. type: Plain text
#: build/C/man2/sysinfo.2:114
msgid "B<sysinfo>()  first appeared in Linux 0.98.pl6."
msgstr "B<sysinfo>() は Linux 0.98.pl6 で初めて登場した。"

#. type: Plain text
#: build/C/man2/sysinfo.2:122
msgid ""
"All of the information provided by this system call is also available via I</"
"proc/meminfo> and I</proc/loadavg>."
msgstr ""

#. type: TH
#: build/C/man3/tcgetpgrp.3:25
#, no-wrap
msgid "TCGETPGRP"
msgstr "TCGETPGRP"

#. type: Plain text
#: build/C/man3/tcgetpgrp.3:28
msgid "tcgetpgrp, tcsetpgrp - get and set terminal foreground process group"
msgstr ""
"tcgetpgrp, tcsetpgrp - 端末のフォアグラウンドプロセスグループの 取得/設定を行"
"う"

#. type: Plain text
#: build/C/man3/tcgetpgrp.3:32
msgid "B<pid_t tcgetpgrp(int >I<fd>B<);>"
msgstr "B<pid_t tcgetpgrp(int >I<fd>B<);>"

#. type: Plain text
#: build/C/man3/tcgetpgrp.3:34
msgid "B<int tcsetpgrp(int >I<fd>B<, pid_t >I<pgrp>B<);>"
msgstr "B<int tcsetpgrp(int >I<fd>B<, pid_t >I<pgrp>B<);>"

#.  The process itself may be a background process.
#. type: Plain text
#: build/C/man3/tcgetpgrp.3:42
msgid ""
"The function B<tcgetpgrp>()  returns the process group ID of the foreground "
"process group on the terminal associated to I<fd>, which must be the "
"controlling terminal of the calling process."
msgstr ""
"関数 B<tcgetpgrp>()  は、 I<fd> に対応する端末のフォアグラウンドプロセスグ"
"ループの プロセスグループ ID を返す。 I<fd> で指定された端末は、呼び出しを行"
"うプロセスの制御端末でなければならない。"

#. type: Plain text
#: build/C/man3/tcgetpgrp.3:55
msgid ""
"The function B<tcsetpgrp>()  makes the process group with process group ID "
"I<pgrp> the foreground process group on the terminal associated to I<fd>, "
"which must be the controlling terminal of the calling process, and still be "
"associated with its session.  Moreover, I<pgrp> must be a (nonempty) process "
"group belonging to the same session as the calling process."
msgstr ""
"関数 B<tcsetpgrp>()  は、プロセスグループID が I<pgrp> のプロセスグループを "
"I<fd> に対応する端末のフォアグラウンドプロセスグループにする。 このとき、 "
"I<fd> は B<tcsetpgrp>()  を呼び出すプロセスの制御端末でなければならない。 さ"
"らに、 I<pgrp> は、呼び出しを行うプロセスと同じセッションに 属する (メンバが"
"空でない) プロセスグループでなければならない。"

#. type: Plain text
#: build/C/man3/tcgetpgrp.3:64
msgid ""
"If B<tcsetpgrp>()  is called by a member of a background process group in "
"its session, and the calling process is not blocking or ignoring B<SIGTTOU>, "
"a B<SIGTTOU> signal is sent to all members of this background process group."
msgstr ""
"B<tcsetpgrp>()  がセッションに属するバックグラウンドグループプロセスのメンバ"
"から 呼び出され、かつ呼び出しを行うプロセスが B<SIGTTOU> をブロックしたり 無"
"視したりするようになっていない場合、 B<SIGTTOU> シグナルは バックグラウンドプ"
"ロセスグループの全てのメンバに送られる。"

#. type: Plain text
#: build/C/man3/tcgetpgrp.3:79
msgid ""
"When I<fd> refers to the controlling terminal of the calling process, the "
"function B<tcgetpgrp>()  will return the foreground process group ID of that "
"terminal if there is one, and some value larger than 1 that is not presently "
"a process group ID otherwise.  When I<fd> does not refer to the controlling "
"terminal of the calling process, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""
"I<fd> が呼び出しを行ったプロセスの制御端末を参照している場合、関数 "
"B<tcgetpgrp>()  は、その制御端末のフォアグラウンドプロセスグループがあれば そ"
"のプロセスグループの ID を返す。 そのようなプロセスグループがなければ、現在プ"
"ロセスグループ ID として使用されていない、1より大きな何らかの値が返される。 "
"I<fd> が呼び出しを行ったプロセスの制御端末を参照していない場合、 -1 が返さ"
"れ、 I<errno> が適切に設定される。"

#. type: Plain text
#: build/C/man3/tcgetpgrp.3:86
msgid ""
"When successful, B<tcsetpgrp>()  returns 0.  Otherwise, it returns -1, and "
"I<errno> is set appropriately."
msgstr ""
"成功した場合、 B<tcsetpgrp>()  は 0 を返す。そうでない場合、 -1 を返し、 "
"I<errno> を適切に設定する。"

#. type: Plain text
#: build/C/man3/tcgetpgrp.3:95
msgid "I<pgrp> has an unsupported value."
msgstr "I<pgrp> が無効な値である。"

#. type: Plain text
#: build/C/man3/tcgetpgrp.3:104
msgid ""
"The calling process does not have a controlling terminal, or it has one but "
"it is not described by I<fd>, or, for B<tcsetpgrp>(), this controlling "
"terminal is no longer associated with the session of the calling process."
msgstr ""
"呼び出しを行ったプロセスが制御端末を持っていない、もしくは 制御端末を持ってい"
"るが I<fd> で参照されるものとは異なる、 B<tcsetpgrp>()  の場合は、 I<fd> で指"
"定された制御端末がすでに呼び出しを行ったプロセスのセッション と関係のないもの"
"になっている際にも、このエラーとなる。"

#. type: Plain text
#: build/C/man3/tcgetpgrp.3:109
msgid ""
"I<pgrp> has a supported value, but is not the process group ID of a process "
"in the same session as the calling process."
msgstr ""
"I<pgrp> が有効な値だが、呼び出しを行ったプロセスと同じセッションに属する プロ"
"セスのプロセスグループ ID には該当するものがない。"

#. type: tbl table
#: build/C/man3/tcgetpgrp.3:120
#, no-wrap
msgid ""
"B<tcgetpgrp>(),\n"
"B<tcsetpgrp>()"
msgstr ""
"B<tcgetpgrp>(),\n"
"B<tcsetpgrp>()"

#. type: Plain text
#: build/C/man3/tcgetpgrp.3:130
msgid ""
"These functions are implemented via the B<TIOCGPGRP> and B<TIOCSPGRP> ioctls."
msgstr "この関数は B<TIOCGPGRP> と B<TIOCGSID> の ioctl 経由で実現されている。"

#. type: SS
#: build/C/man3/tcgetpgrp.3:130 build/C/man2/vfork.2:291
#, no-wrap
msgid "History"
msgstr "歴史"

#. type: Plain text
#: build/C/man3/tcgetpgrp.3:133
msgid "The ioctls appeared in 4.2BSD.  The functions are POSIX inventions."
msgstr ""
"これらの ioctl は 4.2BSD で登場した。 これらの関数は POSIX で考案されたもので"
"ある。"

#. type: Plain text
#: build/C/man3/tcgetpgrp.3:137
msgid "B<setpgid>(2), B<setsid>(2), B<credentials>(7)"
msgstr "B<setpgid>(2), B<setsid>(2), B<credentials>(7)"

#. type: TH
#: build/C/man2/truncate.2:43
#, no-wrap
msgid "TRUNCATE"
msgstr "TRUNCATE"

#. type: Plain text
#: build/C/man2/truncate.2:46
msgid "truncate, ftruncate - truncate a file to a specified length"
msgstr "truncate, ftruncate - 指定した長さにファイルを切り詰める"

#. type: Plain text
#: build/C/man2/truncate.2:52
msgid "B<int truncate(const char *>I<path>B<, off_t >I<length>B<);>"
msgstr "B<int truncate(const char *>I<path>B<, off_t >I<length>B<);>"

#. type: Plain text
#: build/C/man2/truncate.2:54
msgid "B<int ftruncate(int >I<fd>B<, off_t >I<length>B<);>"
msgstr "B<int ftruncate(int >I<fd>B<, off_t >I<length>B<);>"

#. type: Plain text
#: build/C/man2/truncate.2:62
msgid "B<truncate>():"
msgstr "B<truncate>():"

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: build/C/man2/truncate.2:67
#, no-wrap
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* Since glibc 2.12: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE\n"
msgstr ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* glibc 2.12 以降: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L\n"
"    || /* glibc 2.19 以前: */ _BSD_SOURCE\n"

#. type: Plain text
#: build/C/man2/truncate.2:70
msgid "B<ftruncate>():"
msgstr "B<ftruncate>():"

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: build/C/man2/truncate.2:75
#, no-wrap
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* Since glibc 2.3.5: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200112L\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE\n"
msgstr ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* glibc 2.3.5 以降: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200112L\n"
"    || /* glibc 2.19 以前: */ _BSD_SOURCE\n"

#. type: Plain text
#: build/C/man2/truncate.2:89
msgid ""
"The B<truncate>()  and B<ftruncate>()  functions cause the regular file "
"named by I<path> or referenced by I<fd> to be truncated to a size of "
"precisely I<length> bytes."
msgstr ""
"B<truncate>()  は I<path> で指定されるファイルを、 B<ftruncate>()  は I<fd> "
"で参照されるファイルを I<length> バイトの長さになるように延長する、もしくは切"
"り詰める。"

#. type: Plain text
#: build/C/man2/truncate.2:93
msgid ""
"If the file previously was larger than this size, the extra data is lost.  "
"If the file previously was shorter, it is extended, and the extended part "
"reads as null bytes (\\(aq\\e0\\(aq)."
msgstr ""
"もし切り詰める前のファイルが I<length> より長ければ、length バイトを越える部"
"分のデータは失われる。 もし切り詰める前のファイルが I<length> より短かけれ"
"ば、伸張される。 伸張された部分を読んだ場合はヌルバイト (\\(aq\\e0\\(aq) の列"
"が返される。"

#. type: Plain text
#: build/C/man2/truncate.2:95
msgid "The file offset is not changed."
msgstr "ファイルオフセットは変更されない。"

#. type: Plain text
#: build/C/man2/truncate.2:102
msgid ""
"If the size changed, then the st_ctime and st_mtime fields (respectively, "
"time of last status change and time of last modification; see B<inode>(7))  "
"for the file are updated, and the set-user-ID and set-group-ID mode bits may "
"be cleared."
msgstr "大きさが変更されると、ファイルの st_ctime と st_mtime フィールド (それぞれ最終状態変更時刻、最終修正時刻; B<inode>(7) 参照) が更新される。 また、set-user-ID と set-group-ID のモードビットがクリアされるかもしれない。"

#. type: Plain text
#: build/C/man2/truncate.2:108
msgid ""
"With B<ftruncate>(), the file must be open for writing; with B<truncate>(), "
"the file must be writable."
msgstr ""
"B<ftruncate>()  の場合、ファイルは書き込み用に開いていなければならない。 "
"B<truncate>()  の場合、ファイルは書き込み可能でなければならない。"

#. type: Plain text
#: build/C/man2/truncate.2:116
msgid "For B<truncate>():"
msgstr "B<truncate>()  では以下のエラーコードが定義されている。"

#. type: Plain text
#: build/C/man2/truncate.2:122
msgid ""
"Search permission is denied for a component of the path prefix, or the named "
"file is not writable by the user.  (See also B<path_resolution>(7).)"
msgstr ""
"パスで指定されているディレクトリに検索許可のないものがある (訳注:x ビットが"
"立っていない)。 あるいは、指定されたファイルに対する書き込み許可を持っていな"
"い。 (B<path_resolution>(7)  も参照のこと)"

#. type: Plain text
#: build/C/man2/truncate.2:127
msgid ""
"The argument I<path> points outside the process's allocated address space."
msgstr ""
"引数 I<path> がプロセスに割り当てられているアドレス空間外を指している。"

#. type: TP
#: build/C/man2/truncate.2:127
#, no-wrap
msgid "B<EFBIG>"
msgstr "B<EFBIG>"

#. type: Plain text
#: build/C/man2/truncate.2:132
msgid "The argument I<length> is larger than the maximum file size. (XSI)"
msgstr "引数 I<length> が最大ファイルサイズより大きい。(XSI)"

#. type: Plain text
#: build/C/man2/truncate.2:139
msgid ""
"While blocked waiting to complete, the call was interrupted by a signal "
"handler; see B<fcntl>(2)  and B<signal>(7)."
msgstr ""
"完了待ちで停止 (block) している間に、呼び出しが シグナルハンドラーにより割り"
"込まれた。 B<fcntl>(2)  と B<signal>(7)  を参照。"

#. type: Plain text
#: build/C/man2/truncate.2:144
msgid ""
"The argument I<length> is negative or larger than the maximum file size."
msgstr "引数 I<length> が負数であるか、最大ファイルサイズより大きい。"

#. type: Plain text
#: build/C/man2/truncate.2:147
msgid "An I/O error occurred updating the inode."
msgstr "inode の更新時に I/O エラーが発生した。"

#. type: Plain text
#: build/C/man2/truncate.2:150
msgid "The named file is a directory."
msgstr "指定されたファイルはディレクトリである。"

#. type: Plain text
#: build/C/man2/truncate.2:153
msgid "Too many symbolic links were encountered in translating the pathname."
msgstr "パス名を解釈する際にシンボリックリンクが多すぎた。"

#. type: Plain text
#: build/C/man2/truncate.2:157
msgid ""
"A component of a pathname exceeded 255 characters, or an entire pathname "
"exceeded 1023 characters."
msgstr ""
"パス名中のディレクトリ名が 255 文字を越えている、もしくはパス名全体が 1023 文"
"字を越えている。"

#. type: Plain text
#: build/C/man2/truncate.2:160
msgid "The named file does not exist."
msgstr "指定された名前のファイルが存在しない。"

#.  This happens for at least MSDOS and VFAT filesystems
#.  on kernel 2.6.13
#. type: Plain text
#: build/C/man2/truncate.2:169
msgid ""
"The underlying filesystem does not support extending a file beyond its "
"current size."
msgstr ""
"下層にあるファイルシステムでは、現在のファイル長を越えて ファイルを伸長するこ"
"とができない。"

#. type: Plain text
#: build/C/man2/truncate.2:173
msgid "The operation was prevented by a file seal; see B<fcntl>(2)."
msgstr "操作が file seal により禁止されている。 B<fcntl>(2) 参照。"

#. type: Plain text
#: build/C/man2/truncate.2:179
msgid "The file is an executable file that is being executed."
msgstr "ファイルが実行中の実行ファイルである。"

#. type: Plain text
#: build/C/man2/truncate.2:186
msgid ""
"For B<ftruncate>()  the same errors apply, but instead of things that can be "
"wrong with I<path>, we now have things that can be wrong with the file "
"descriptor, I<fd>:"
msgstr ""
"B<ftruncate>()  にも同様のエラーが適用される。 但し、 I<path> に関するエラー"
"の場合は、ファイルディスクリプター I<fd> に関するエラーとなる。"

#. type: TP
#: build/C/man2/truncate.2:190
#, no-wrap
msgid "B<EBADF> or B<EINVAL>"
msgstr "B<EBADF> または B<EINVAL>"

#. type: Plain text
#: build/C/man2/truncate.2:194
msgid "I<fd> is not open for writing."
msgstr "I<fd> で指定されているものが書き込みモードで開かれていない。"

#. type: Plain text
#: build/C/man2/truncate.2:198
#, fuzzy
#| msgid "I<fd> does not reference a regular file."
msgid ""
"I<fd> does not reference a regular file or a POSIX shared memory object."
msgstr "I<fd> が通常のファイルを参照していない。"

#. type: TP
#: build/C/man2/truncate.2:198
#, no-wrap
msgid "B<EINVAL> or B<EBADF>"
msgstr "B<EINVAL> または B<EBADF>"

#. type: Plain text
#: build/C/man2/truncate.2:207
msgid ""
"The file descriptor I<fd> is not open for writing.  POSIX permits, and "
"portable applications should handle, either error for this case.  (Linux "
"produces B<EINVAL>.)"
msgstr ""

#.  POSIX.1-1996 has
#.  .BR ftruncate ().
#.  POSIX.1-2001 also has
#.  .BR truncate (),
#.  as an XSI extension.
#.  .LP
#.  SVr4 documents additional
#.  .BR truncate ()
#.  error conditions EMFILE, EMULTIHP, ENFILE, ENOLINK.  SVr4 documents for
#.  .BR ftruncate ()
#.  an additional EAGAIN error condition.
#. type: Plain text
#: build/C/man2/truncate.2:221
msgid ""
"POSIX.1-2001, POSIX.1-2008, 4.4BSD, SVr4 (these calls first appeared in "
"4.2BSD)."
msgstr "POSIX.1-2001, POSIX.1-2008, 4.4BSD, SVr4 (これらのコールは 4.2BSD で初めて登場した)。"

#. type: Plain text
#: build/C/man2/truncate.2:225
msgid ""
"B<ftruncate>()  can also be used to set the size of a POSIX shared memory "
"object; see B<shm_open>(3)."
msgstr ""

#.  At the very least: OSF/1, Solaris 7, and FreeBSD conform, mtk, Jan 2002
#. type: Plain text
#: build/C/man2/truncate.2:246
msgid ""
"The details in DESCRIPTION are for XSI-compliant systems.  For non-XSI-"
"compliant systems, the POSIX standard allows two behaviors for "
"B<ftruncate>()  when I<length> exceeds the file length (note that "
"B<truncate>()  is not specified at all in such an environment): either "
"returning an error, or extending the file.  Like most UNIX implementations, "
"Linux follows the XSI requirement when dealing with native filesystems.  "
"However, some nonnative filesystems do not permit B<truncate>()  and "
"B<ftruncate>()  to be used to extend a file beyond its current length: a "
"notable example on Linux is VFAT."
msgstr ""
"「説明」の節で述べた詳細は XSI 準拠のシステムについてのものである。\n"
"XSI 非準拠のシステムの場合、POSIX 標準は B<ftruncate>() に対して I<length> "
"が\n"
"ファイルの長さより長かった場合、 エラーを返すかファイルを伸張するかの二つの\n"
"動作を許容している。 B<truncate>() に対しては全く規定されていない。\n"
"ほとんどの UNIX 実装と同様、Linux はネイティブ (Linux 由来) の ファイルシステ"
"ム\n"
"の扱いでは XSI 要求仕様にしたがっている。 しかしながら、いくつかの非ネイティ"
"ブ\n"
"のファイルシステムでは、 B<truncate>() や B<ftruncate>() を使って現在のファイ"
"ル\n"
"長を越えてファイルを伸長することができない。 Linux での有名な例としては\n"
"VFAT がある。"

#. type: Plain text
#: build/C/man2/truncate.2:260
msgid ""
"The original Linux B<truncate>()  and B<ftruncate>()  system calls were not "
"designed to handle large file offsets.  Consequently, Linux 2.4 added "
"B<truncate64>()  and B<ftruncate64>()  system calls that handle large "
"files.  However, these details can be ignored by applications using glibc, "
"whose wrapper functions transparently employ the more recent system calls "
"where they are available."
msgstr ""
"元々の Linux の B<truncate>() と B<ftruncate>() システムコールは\n"
"大きなファイルオフセットを扱えるように設計されていなかった。\n"
"その結果、大きなファイルファイルを扱うことができる B<truncate64>() と "
"B<ftruncate64>()\n"
"システムコールが Linux 2.4 で追加された。\n"
"ただし、glibc を使ったアプリケーションではこれらの詳細は気にする必要はな"
"い。\n"
"glibc のラッパー関数は新しいシステムコールが利用できる場合にはそれらを利用す"
"る\n"
"ようになっているからである。"

#.  http://sourceware.org/bugzilla/show_bug.cgi?id=12037
#. type: Plain text
#: build/C/man2/truncate.2:273
msgid ""
"A header file bug in glibc 2.12 meant that the minimum value of "
"B<_POSIX_C_SOURCE> required to expose the declaration of B<ftruncate>()  was "
"200809L instead of 200112L.  This has been fixed in later glibc versions."
msgstr ""
"glibc 2.12 のヘッダーファイルにはバグがあり、 B<ftruncate>()  の宣言を公開す"
"るのに必要な B<_POSIX_C_SOURCE> の最小値が 200112L ではなく 200809L となって"
"いた。 このバグは、これ以降のバージョンの glibc では修正されている。"

#. type: Plain text
#: build/C/man2/truncate.2:278
msgid "B<truncate>(1), B<open>(2), B<stat>(2), B<path_resolution>(7)"
msgstr " B<truncate>(1), B<open>(2), B<stat>(2), B<path_resolution>(7)"

#. type: TH
#: build/C/man3/ualarm.3:24
#, no-wrap
msgid "UALARM"
msgstr "UALARM"

#. type: Plain text
#: build/C/man3/ualarm.3:27
msgid "ualarm - schedule signal after given number of microseconds"
msgstr "ualarm - 指定したマイクロ秒後にシグナルを送る予定をする"

#. type: Plain text
#: build/C/man3/ualarm.3:32
#, no-wrap
msgid "B<useconds_t ualarm(useconds_t >I<usecs>B<, useconds_t >I<interval>B<);>\n"
msgstr "B<useconds_t ualarm(useconds_t >I<usecs>B<, useconds_t >I<interval>B<);>\n"

#. type: Plain text
#: build/C/man3/ualarm.3:40
msgid "B<ualarm>():"
msgstr "B<ualarm>():"

#. type: Plain text
#: build/C/man3/ualarm.3:68
msgid ""
"The B<ualarm>()  function causes the signal B<SIGALRM> to be sent to the "
"invoking process after (not less than)  I<usecs> microseconds.  The delay "
"may be lengthened slightly by any system activity or by the time spent "
"processing the call or by the granularity of system timers."
msgstr ""
"B<ualarm>()  関数は、呼び出し元のプロセスに対して I<usecs> マイクロ秒 (以上) "
"後に B<SIGALRM> シグナルを送る。 遅れはシステムの活性度・呼び出しの処理時"
"間・ システムタイマーの粒度によって長くなるかもしれない。"

#. type: Plain text
#: build/C/man3/ualarm.3:72
msgid ""
"Unless caught or ignored, the B<SIGALRM> signal will terminate the process."
msgstr ""
"捕捉または無視されない限り、 B<SIGALRM> シグナルはプロセスを終了させる。"

#. type: Plain text
#: build/C/man3/ualarm.3:80
msgid ""
"If the I<interval> argument is nonzero, further B<SIGALRM> signals will be "
"sent every I<interval> microseconds after the first."
msgstr ""
"I<interval> 引数が 0 でない場合、最初の B<SIGALRM> シグナルの後、 さらに "
"I<interval> マイクロ秒毎に SIGALRM シグナルが送られる。"

#. type: Plain text
#: build/C/man3/ualarm.3:83
msgid ""
"This function returns the number of microseconds remaining for any alarm "
"that was previously set, or 0 if no alarm was pending."
msgstr ""
"この関数は、過去に設定された alarm の残りマイクロ秒数を返す。 実行中の alarm "
"がない場合は 0 を返す。"

#. type: Plain text
#: build/C/man3/ualarm.3:88 build/C/man3/usleep.3:86
msgid "Interrupted by a signal; see B<signal>(7)."
msgstr "シグナルによって中断された。 B<signal>(7)  参照。"

#. type: Plain text
#: build/C/man3/ualarm.3:92
msgid ""
"I<usecs> or I<interval> is not smaller than 1000000.  (On systems where that "
"is considered an error.)"
msgstr ""
"I<usecs> または I<interval> が 1000000 未満でない (これがエラーとして扱われる"
"システムの場合)。"

#. type: tbl table
#: build/C/man3/ualarm.3:102
#, no-wrap
msgid "B<ualarm>()"
msgstr " B<ualarm>()"

#. type: Plain text
#: build/C/man3/ualarm.3:112
msgid ""
"4.3BSD, POSIX.1-2001.  POSIX.1-2001 marks B<ualarm>()  as obsolete.  "
"POSIX.1-2008 removes the specification of B<ualarm>().  4.3BSD, SUSv2, and "
"POSIX do not define any errors."
msgstr ""
"4.3BSD, POSIX.1-2001.  POSIX.1-2001 では B<ualarm>()  は過去のものとされてい"
"る。 POSIX.1-2008 では、 B<ualarm>()  の仕様が削除されている。 4.3BSD, "
"SUSv2, POSIX はエラーを定義していない。"

#.  This case is not documented in HP-US, Solar, FreeBSD, NetBSD, or OpenBSD!
#. type: Plain text
#: build/C/man3/ualarm.3:119
msgid ""
"POSIX.1-2001 does not specify what happens if the I<usecs> argument is 0.  "
"On Linux (and probably most other systems), the effect is to cancel any "
"pending alarm."
msgstr ""
"POSIX.1-2001 では、 I<usecs> 引数が 0 の場合、何が起こるかは規定されていな"
"い。 Linux (やおそらく他ほとんどのシステム) では、 I<usecs> 引数が 0 の場"
"合、処理待ちのアラームがキャンセルされる。"

#. type: Plain text
#: build/C/man3/ualarm.3:132
msgid ""
"The type I<useconds_t> is an unsigned integer type capable of holding "
"integers in the range [0,1000000].  On the original BSD implementation, and "
"in glibc before version 2.1, the arguments to B<ualarm>()  were instead "
"typed as I<unsigned int>.  Programs will be more portable if they never "
"mention I<useconds_t> explicitly."
msgstr ""
"I<useconds_t> 型は [0,1000000] の範囲の整数を保持できる符号なし整数型であ"
"る。 もともとの BSD での実装や、バージョン 2.1 より前の glibc では、 "
"B<ualarm>()  の引数の型は I<unsigned int> であった。 プログラム中に明示的"
"に I<useconds_t> と書かない方が、移植性が高くなる。"

#. type: Plain text
#: build/C/man3/ualarm.3:146
msgid ""
"The interaction of this function with other timer functions such as "
"B<alarm>(2), B<sleep>(3), B<nanosleep>(2), B<setitimer>(2), "
"B<timer_create>(2), B<timer_delete>(2), B<timer_getoverrun>(2), "
"B<timer_gettime>(2), B<timer_settime>(2), B<usleep>(3)  is unspecified."
msgstr ""
"この関数と B<alarm>(2), B<sleep>(3), B<nanosleep>(2), B<setitimer>(2), "
"B<timer_create>(2), B<timer_delete>(2), B<timer_getoverrun>(2), "
"B<timer_gettime>(2), B<timer_settime>(2), B<usleep>(3)  のような他のタイマー"
"関数との相互作用は規定されていない。"

#. type: Plain text
#: build/C/man3/ualarm.3:154
msgid ""
"This function is obsolete.  Use B<setitimer>(2)  or POSIX interval timers "
"(B<timer_create>(2), etc.)  instead."
msgstr ""
"この関数は廃止予定である。 代わりに B<setitimer>(2)  もしくは POSIX インター"
"バルタイマー (B<timer_create>(2)  など) を使うこと。"

#. type: Plain text
#: build/C/man3/ualarm.3:162
msgid ""
"B<alarm>(2), B<getitimer>(2), B<nanosleep>(2), B<select>(2), "
"B<setitimer>(2), B<usleep>(3), B<time>(7)"
msgstr ""
"B<alarm>(2), B<getitimer>(2), B<nanosleep>(2), B<select>(2), "
"B<setitimer>(2), B<usleep>(3), B<time>(7)"

#. type: TH
#: build/C/man2/umask.2:34
#, no-wrap
msgid "UMASK"
msgstr "UMASK"

#. type: Plain text
#: build/C/man2/umask.2:37
msgid "umask - set file mode creation mask"
msgstr "umask - ファイルモード作成マスクを設定する"

#. type: Plain text
#: build/C/man2/umask.2:43
msgid "B<mode_t umask(mode_t >I<mask>B<);>"
msgstr "B<mode_t umask(mode_t >I<mask>B<);>"

#. type: Plain text
#: build/C/man2/umask.2:50
msgid ""
"B<umask>()  sets the calling process's file mode creation mask (umask) to "
"I<mask> & 0777 (i.e., only the file permission bits of I<mask> are used), "
"and returns the previous value of the mask."
msgstr ""
"B<umask>()  は、呼び出し元プロセスのファイルモード作成マスク (umask) を "
"I<mask> & 0777 に設定し (I<umask> のファイル許可に対応するビットのみを使用す"
"る)、 変更前のマスク値を返す。"

#.  e.g., mkfifo(), creat(), mknod(), sem_open(), mq_open(), shm_open()
#.  but NOT the System V IPC *get() calls
#. type: Plain text
#: build/C/man2/umask.2:65
msgid ""
"The umask is used by B<open>(2), B<mkdir>(2), and other system calls that "
"create files to modify the permissions placed on newly created files or "
"directories.  Specifically, permissions in the umask are turned off from the "
"I<mode> argument to B<open>(2)  and B<mkdir>(2)."
msgstr ""
"umask は、 B<open>(2), B<mkdir>(2)  やファイル作成を行うその他のシステムコー"
"ルで、 新しく作成されるファイルやディレクトリの許可 (permission) を 修正する"
"ために使用される。 具体的には umask に設定されている許可が B<open>(2)  や "
"B<mkdir>(2)  の I<mode> 引数から取り消される。"

#. type: Plain text
#: build/C/man2/umask.2:74
msgid ""
"Alternatively, if the parent directory has a default ACL (see B<acl>(5)), "
"the umask is ignored, the default ACL is inherited, the permission bits are "
"set based on the inherited ACL, and permission bits absent in the I<mode> "
"argument are turned off.  For example, the following default ACL is "
"equivalent to a umask of 022:"
msgstr ""

#. type: Plain text
#: build/C/man2/umask.2:76
#, no-wrap
msgid "    u::rwx,g::r-x,o::r-x\n"
msgstr "    u::rwx,g::r-x,o::r-x\n"

#. type: Plain text
#: build/C/man2/umask.2:81
msgid ""
"Combining the effect of this default ACL with a I<mode> argument of 0666 (rw-"
"rw-rw-), the resulting file permissions would be 0644 (rw-r--r--)."
msgstr ""

#. type: Plain text
#: build/C/man2/umask.2:86
msgid ""
"The constants that should be used to specify I<mask> are described in "
"B<inode>(7)."
msgstr "I<mask> に指定するのに使用すべき定数については B<inode>(7) で説明されている。"

#. type: Plain text
#: build/C/man2/umask.2:95
msgid ""
"The typical default value for the process umask is I<S_IWGRP\\ |\\ S_IWOTH> "
"(octal 022).  In the usual case where the I<mode> argument to B<open>(2)  is "
"specified as:"
msgstr ""
"プロセスの umask のよくあるデフォルト値は I<S_IWGRP\\ |\\ S_IWOTH> (8進で "
"022) である。 新しいファイルを作成する際に B<open>(2)  の I<mode> 引数に"

#. type: Plain text
#: build/C/man2/umask.2:99
#, no-wrap
msgid "S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH\n"
msgstr " S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH\n"

#. type: Plain text
#: build/C/man2/umask.2:104
msgid ""
"(octal 0666) when creating a new file, the permissions on the resulting file "
"will be:"
msgstr "を指定するというよくあるケースでは、作成されたファイルは"

#. type: Plain text
#: build/C/man2/umask.2:108
#, no-wrap
msgid "S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH\n"
msgstr " S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH\n"

#. type: Plain text
#: build/C/man2/umask.2:112
#, fuzzy
#| msgid "(because 0666 & ~022 = 0644; i.e., rw-r--r--)."
msgid "(because 0666 & \\(ti022 = 0644; i.e., rw-r--r--)."
msgstr ""
"という許可を持つことになる (なぜなら 0666 & ~022 = 0644、つまり rw-r--r--)。"

#. type: Plain text
#: build/C/man2/umask.2:115
msgid ""
"This system call always succeeds and the previous value of the mask is "
"returned."
msgstr "このシステムコールは必ず成功し、以前の umask 値を返す。"

#. type: Plain text
#: build/C/man2/umask.2:123
msgid ""
"A child process created via B<fork>(2)  inherits its parent's umask.  The "
"umask is left unchanged by B<execve>(2)."
msgstr ""
"B<fork>(2)  で作成された子プロセスは、親プロセスの umask を継承する。 "
"B<execve>(2)  によって umask は変更されない。"

#. type: Plain text
#: build/C/man2/umask.2:132
msgid ""
"It is impossible to use B<umask>()  to fetch a process's umask without at "
"the same time changing it.  A second call to B<umask>()  would then be "
"needed to restore the umask.  The nonatomicity of these two steps provides "
"the potential for races in multithreaded programs."
msgstr ""

#. type: Plain text
#: build/C/man2/umask.2:140
msgid ""
"Since Linux 4.7, the umask of any process can be viewed via the I<Umask> "
"field of I</proc/[pid]/status>.  Inspecting this field in I</proc/self/"
"status> allows a process to retrieve its umask without at the same time "
"changing it."
msgstr ""

#. type: Plain text
#: build/C/man2/umask.2:155
msgid ""
"The umask setting also affects the permissions assigned to POSIX IPC objects "
"(B<mq_open>(3), B<sem_open>(3), B<shm_open>(3)), FIFOs (B<mkfifo>(3)), and "
"UNIX domain sockets (B<unix>(7))  created by the process.  The umask does "
"not affect the permissions assigned to System\\ V IPC objects created by the "
"process (using B<msgget>(2), B<semget>(2), B<shmget>(2))."
msgstr ""
"umask の設定は、そのプロセスが生成する POSIX IPC オブジェクト "
"(B<mq_open>(3), B<sem_open>(3), B<shm_open>(3))  や FIFO (B<mkfifo>(3))、 "
"UNIX ドメインソケット (B<unix>(7))  に設定される許可にも影響を与える。 一方、"
"umask は、そのプロセスが (B<msgget>(2), B<semget>(2), B<shmget>(2)  を使っ"
"て) 生成する System\\ V IPC オブジェクトに設定される許可には 影響を与えない。"

#. type: Plain text
#: build/C/man2/umask.2:161
msgid "B<chmod>(2), B<mkdir>(2), B<open>(2), B<stat>(2), B<acl>(5)"
msgstr "B<chmod>(2), B<mkdir>(2), B<open>(2), B<stat>(2), B<acl>(5)"

#. type: TH
#: build/C/man2/uname.2:27
#, no-wrap
msgid "UNAME"
msgstr "UNAME"

#. type: Plain text
#: build/C/man2/uname.2:30
msgid "uname - get name and information about current kernel"
msgstr "uname - 現在稼働中のカーネルについての名前と情報を得る"

#. type: Plain text
#: build/C/man2/uname.2:32
msgid "B<#include E<lt>sys/utsname.hE<gt>>"
msgstr "B<#include E<lt>sys/utsname.hE<gt>>"

#. type: Plain text
#: build/C/man2/uname.2:34
msgid "B<int uname(struct utsname *>I<buf>B<);>"
msgstr "B<int uname(struct utsname *>I<buf>B<);>"

#. type: Plain text
#: build/C/man2/uname.2:42
msgid ""
"B<uname>()  returns system information in the structure pointed to by "
"I<buf>.  The I<utsname> struct is defined in I<E<lt>sys/utsname.hE<gt>>:"
msgstr ""
"B<uname>()  は I<buf> で指される構造体にシステム情報を返す。 I<utsname> 構造"
"体は I<E<lt>sys/utsname.hE<gt>> で以下のように定義されている。"

#. type: Plain text
#: build/C/man2/uname.2:57
#, no-wrap
msgid ""
"struct utsname {\n"
"    char sysname[];    /* Operating system name (e.g., \"Linux\") */\n"
"    char nodename[];   /* Name within \"some implementation-defined\n"
"                          network\" */\n"
"    char release[];    /* Operating system release\n"
"                          (e.g., \"2.6.28\") */\n"
"    char version[];    /* Operating system version */\n"
"    char machine[];    /* Hardware identifier */\n"
"#ifdef _GNU_SOURCE\n"
"    char domainname[]; /* NIS or YP domain name */\n"
"#endif\n"
"};\n"
msgstr ""
"struct utsname {\n"
"    char sysname[];    /* OS の名前 (例: \"Linux\") */\n"
"    char nodename[];   /* 「実装時に定義された、何らかの\n"
"                          ネットワーク」におけるマシン名 */\n"
"    char release[];    /* オペレーションシステムのリリース番号\n"
"                          (例: \"2.6.28\") */\n"
"    char version[];    /* オペレーティングシステムのバージョン */\n"
"    char machine[];    /* ハードウェア識別子 */\n"
"#ifdef _GNU_SOURCE\n"
"    char domainname[]; /* NIS や YP のドメイン名 */\n"
"#endif\n"
"};\n"

#. type: Plain text
#: build/C/man2/uname.2:64
msgid ""
"The length of the arrays in a I<struct utsname> is unspecified (see NOTES); "
"the fields are terminated by a null byte (\\(aq\\e0\\(aq)."
msgstr ""
"I<struct utsname> にある配列の長さは指定されていない (「注意」の節を参照)。 "
"フィールドはヌルバイト (\\(aq\\e0\\(aq) で終端される。"

#. type: Plain text
#: build/C/man2/uname.2:74
msgid "I<buf> is not valid."
msgstr "I<buf> が有効でない。"

#. type: Plain text
#: build/C/man2/uname.2:79
msgid ""
"POSIX.1-2001, POSIX.1-2008, SVr4.  There is no B<uname>()  call in 4.3BSD."
msgstr "POSIX.1-2001, POSIX.1-2008, SVr4. 4.3BSD には B<uname>()  コールがない。"

#. type: Plain text
#: build/C/man2/uname.2:83
msgid ""
"The I<domainname> member (the NIS or YP domain name) is a GNU extension."
msgstr ""
"I<domainname> メンバー (NIS または YP ドメイン名) は GNU の拡張である。"

#. type: Plain text
#: build/C/man2/uname.2:99
msgid ""
"This is a system call, and the operating system presumably knows its name, "
"release and version.  It also knows what hardware it runs on.  So, four of "
"the fields of the struct are meaningful.  On the other hand, the field "
"I<nodename> is meaningless: it gives the name of the present machine in some "
"undefined network, but typically machines are in more than one network and "
"have several names.  Moreover, the kernel has no way of knowing about such "
"things, so it has to be told what to answer here.  The same holds for the "
"additional I<domainname> field."
msgstr ""
"これはシステムコールであり、OS は名前・リリース・バージョンなどを たぶん分"
"かっているだろう。 さらにそれが稼働しているハードウェアも分かっているだろ"
"う。 よって構造体の 4 つのフィールドには意味がある。 一方、I<nodename> フィー"
"ルドには意味がない: このフィールドは現在のマシンの (定義されていない)  どこか"
"のネットワークにおける名前を与えるが、 通常マシンは複数のネットワークに属し、"
"複数の名前を持つ。 さらに、カーネルはこのような情報を知る術を持たないので、 "
"ここでの答えは前もって教えてやらなければならない。 これは追加フィールドであ"
"る I<domainname> についても同様である。"

#. type: Plain text
#: build/C/man2/uname.2:117
msgid ""
"To this end, Linux uses the system calls B<sethostname>(2)  and "
"B<setdomainname>(2).  Note that there is no standard that says that the "
"hostname set by B<sethostname>(2)  is the same string as the I<nodename> "
"field of the struct returned by B<uname>()  (indeed, some systems allow a "
"256-byte hostname and an 8-byte nodename), but this is true on Linux.  The "
"same holds for B<setdomainname>(2)  and the I<domainname> field."
msgstr ""
"このため Linux ではシステムコール B<sethostname>(2)  と B<setdomainname>(2)  "
"が使われる。 「B<sethostname>(2)  で設定されるホスト名は、 B<uname>()  で返さ"
"れる構造体の I<nodename> フィールドと同じ文字列である」 と規定している標準規"
"格はない (実際、256 バイトのホスト名と 8 バイトのノード名を許可しているシステ"
"ムもある)。 しかし、Linux では同じ文字列が返される。 B<setdomainname>(2)  と "
"I<domainname> フィールドについても同じことが成り立つ。"

#. type: Plain text
#: build/C/man2/uname.2:132
msgid ""
"The length of the fields in the struct varies.  Some operating systems or "
"libraries use a hardcoded 9 or 33 or 65 or 257.  Other systems use "
"B<SYS_NMLN> or B<_SYS_NMLN> or B<UTSLEN> or B<_UTSNAME_LENGTH>.  Clearly, it "
"is a bad idea to use any of these constants; just use sizeof(...).  Often "
"257 is chosen in order to have room for an internet hostname."
msgstr ""
"構造体のフィールドの長さはさまざまである。 OS やライブラリの中には、 ハード"
"コードされた 9, 33, 65, 257 などの値を使っているものもある。 また "
"B<SYS_NMLN>, B<_SYS_NMLN>, B<UTSLEN>, B<_UTSNAME_LENGTH> などを使っているシス"
"テムもある。 はっきり言って、これらの定数を使うのは悪い考え方であり、 "
"sizeof(...) を使うべきである。 インターネットホスト名で使う領域を持たせるため"
"に、 257 が選ばれることが多い。"

#. type: Plain text
#: build/C/man2/uname.2:139
msgid ""
"Part of the utsname information is also accessible via I</proc/sys/kernel/"
">{I<ostype>, I<hostname>, I<osrelease>, I<version>, I<domainname>}."
msgstr ""
"utsname の情報は、 I</proc/sys/kernel/>{I<ostype>, I<hostname>, "
"I<osrelease>, I<version>, I<domainname>} を使ってアクセスすることもできる。"

#.  That was back before Linux 1.0
#.  That was also back before Linux 1.0
#. type: Plain text
#: build/C/man2/uname.2:167
msgid ""
"Over time, increases in the size of the I<utsname> structure have led to "
"three successive versions of B<uname>(): I<sys_olduname>()  (slot "
"I<__NR_oldolduname>), I<sys_uname>()  (slot I<__NR_olduname>), and "
"I<sys_newuname>()  (slot I<__NR_uname)>.  The first one used length 9 for "
"all fields; the second used 65; the third also uses 65 but adds the "
"I<domainname> field.  The glibc B<uname>()  wrapper function hides these "
"details from applications, invoking the most recent version of the system "
"call provided by the kernel."
msgstr ""
"時間の経過とともに、 I<utsname> 構造体のサイズが大きくなり、この影響で "
"B<uname>()  には 3つのバージョンが存在する: I<sys_olduname>()  (スロットは "
"I<__NR_oldolduname>)、 I<sys_uname>()  (スロットは I<__NR_olduname>)、 "
"I<sys_newuname>()  (スロットは I<__NR_uname>)。 I<sys_olduname>()  はすべての"
"フィールドが長さ 9 を使っていた。 I<sys_uname>()  は長さ 65 を使っていた。 "
"I<sys_newuname>()  も長さ 65 を使っているが、 I<domainname> フィールドが追加"
"されている。 glibc の B<uname>()  ラッパー関数は、これらの詳細をアプリケー"
"ションから隠蔽し、 カーネルが提供しているシステムコールのうち最新のバージョン"
"を起動する。"

#. type: Plain text
#: build/C/man2/uname.2:172
msgid ""
"B<uname>(1), B<getdomainname>(2), B<gethostname>(2), B<uts_namespaces>(7)"
msgstr ""
" B<uname>(1), B<getdomainname>(2), B<gethostname>(2), B<uts_namespaces>(7)"

#. type: TH
#: build/C/man2/uselib.2:31
#, no-wrap
msgid "USELIB"
msgstr "USELIB"

#. type: Plain text
#: build/C/man2/uselib.2:34
msgid "uselib - load shared library"
msgstr "uselib - 共有ライブラリを選択する"

#. type: Plain text
#: build/C/man2/uselib.2:38
msgid "B<int uselib(const char *>I<library>B<);>"
msgstr "B<int uselib(const char *>I<library>B<);>"

#. type: Plain text
#: build/C/man2/uselib.2:41
msgid ""
"I<Note>: No declaration of this system call is provided in glibc headers; "
"see NOTES."
msgstr ""

#. type: Plain text
#: build/C/man2/uselib.2:51
msgid ""
"The system call B<uselib>()  serves to load a shared library to be used by "
"the calling process.  It is given a pathname.  The address where to load is "
"found in the library itself.  The library can have any recognized binary "
"format."
msgstr ""
"システムコール B<uselib>()  は、呼び出し元プロセスが使用する 共有ライブラリを"
"ロードする際に使用される。 このシステムコールにはライブラリのパス名を指定す"
"る。 ライブラリをロードするアドレスはライブラリ自身に書かれている。 ライブラ"
"リは認識可能なバイナリ形式であればどんな形式でもよい。"

#. type: Plain text
#: build/C/man2/uselib.2:62
msgid ""
"In addition to all of the error codes returned by B<open>(2)  and "
"B<mmap>(2), the following may also be returned:"
msgstr ""
"B<open>(2)  と B<mmap>(2)  が返すエラーコードに加えて、以下のエラーコードが設"
"定されることがある。"

#. type: Plain text
#: build/C/man2/uselib.2:70
msgid ""
"The library specified by I<library> does not have read or execute "
"permission, or the caller does not have search permission for one of the "
"directories in the path prefix.  (See also B<path_resolution>(7).)"
msgstr ""
"I<library> で指定されたライブラリに対する読み込み許可、または実行許可がな"
"い。 もしくは I<library> が存在するディレクトリかその上位のいずれかに対する検"
"索許可がない (B<path_resolution>(7)  も参照)。"

#. type: Plain text
#: build/C/man2/uselib.2:79
msgid ""
"The file specified by I<library> is not an executable of a known type; for "
"example, it does not have the correct magic numbers."
msgstr ""
"I<library> で指定されたファイルが、実行可能ファイルと認識されるファイル種別で"
"はない。 例えば、正しいマジックナンバーが付いていない。"

#. type: Plain text
#: build/C/man2/uselib.2:83
msgid ""
"B<uselib>()  is Linux-specific, and should not be used in programs intended "
"to be portable."
msgstr ""
"B<uselib>()  は Linux 特有の関数であり、移植性を持たせたいプログラム には使用"
"すべきでない。"

#. type: Plain text
#: build/C/man2/uselib.2:91
msgid ""
"This obsolete system call is not supported by glibc.  No declaration is "
"provided in glibc headers, but, through a quirk of history, glibc versions "
"before 2.23 did export an ABI for this system call.  Therefore, in order to "
"employ this system call, it was sufficient to manually declare the interface "
"in your code; alternatively, you could invoke the system call using "
"B<syscall>(2)."
msgstr ""

#.  .PP
#.  .\" libc 4.3.1f - changelog 1993-03-02
#.  Since libc 4.3.2, startup code tries to prefix these names
#.  with "/usr/lib", "/lib" and "" before giving up.
#.  .\" libc 4.3.4 - changelog 1993-04-21
#.  In libc 4.3.4 and later these names are looked for in the directories
#.  found in
#.  .BR LD_LIBRARY_PATH ,
#.  and if not found there,
#.  prefixes "/usr/lib", "/lib" and "/" are tried.
#.  .PP
#.  From libc 4.4.4 on only the library "/lib/ld.so" is loaded,
#.  so that this dynamic library can load the remaining libraries needed
#.  (again using this call).
#.  This is also the state of affairs in libc5.
#.  .PP
#.  glibc2 does not use this call.
#. type: Plain text
#: build/C/man2/uselib.2:114
#, fuzzy
#| msgid ""
#| "B<uselib>()  was used by early libc startup code to load the shared "
#| "libraries with names found in an array of names in the binary."
msgid ""
"In ancient libc versions (before glibc 2.0), B<uselib>()  was used to load "
"the shared libraries with names found in an array of names in the binary."
msgstr ""
"初期の libc の起動コードは、 B<uselib>()  を使って、 バイナリ中のリストに書か"
"れている共有ライブラリを リスト中のそのままの名前でロードしていた。"

#.  commit 69369a7003735d0d8ef22097e27a55a8bad9557a
#. type: Plain text
#: build/C/man2/uselib.2:120
#, fuzzy
#| msgid ""
#| "This system call is available only if the kernel was configured with the "
#| "B<CONFIG_SYSCTL_SYSCALL> option."
msgid ""
"Since Linux 3.15, this system call is available only when the kernel is "
"configured with the B<CONFIG_USELIB> option."
msgstr ""
"このシステムコールは、カーネルの B<CONFIG_SYSCTL_SYSCALL> オプションが有効に"
"なっている場合のみ利用できる。"

#. type: Plain text
#: build/C/man2/uselib.2:130
msgid ""
"B<ar>(1), B<gcc>(1), B<ld>(1), B<ldd>(1), B<mmap>(2), B<open>(2), "
"B<dlopen>(3), B<capabilities>(7), B<ld.so>(8)"
msgstr ""
"B<ar>(1), B<gcc>(1), B<ld>(1), B<ldd>(1), B<mmap>(2), B<open>(2), "
"B<dlopen>(3), B<capabilities>(7), B<ld.so>(8)"

#. type: TH
#: build/C/man3/usleep.3:33
#, no-wrap
msgid "USLEEP"
msgstr "USLEEP"

#. type: Plain text
#: build/C/man3/usleep.3:36
msgid "usleep - suspend execution for microsecond intervals"
msgstr "usleep - マイクロ秒単位で実行を延期する"

#. type: Plain text
#: build/C/man3/usleep.3:41
#, no-wrap
msgid "B<int usleep(useconds_t >I<usec>B<);>\n"
msgstr "B<int usleep(useconds_t >I<usec>B<);>\n"

#. type: Plain text
#: build/C/man3/usleep.3:49
msgid "B<usleep>():"
msgstr "B<usleep>():"

#. type: Plain text
#: build/C/man3/usleep.3:74
msgid ""
"The B<usleep>()  function suspends execution of the calling thread for (at "
"least) I<usec> microseconds.  The sleep may be lengthened slightly by any "
"system activity or by the time spent processing the call or by the "
"granularity of system timers."
msgstr ""
"B<usleep>()  関数は (少なくとも) I<usec>マイクロ秒の間、 呼び出し元スレッドの"
"実行を延期する。 システムの動作状況や呼び出しによる時間の消費やシステムタイ"
"マーの粒度によって、 停止時間は設定した値よりも少し延ばされるかもしれない。"

#. type: Plain text
#: build/C/man3/usleep.3:81
msgid ""
"The B<usleep>()  function returns 0 on success.  On error, -1 is returned, "
"with I<errno> set to indicate the cause of the error."
msgstr ""
"B<usleep>() 関数は成功すると 0 を返す。 エラーの場合、 -1 が返され、 "
"I<errno> にエラーの原因を示す値が設定される。"

#. type: Plain text
#: build/C/man3/usleep.3:90
msgid ""
"I<usec> is greater than or equal to 1000000.  (On systems where that is "
"considered an error.)"
msgstr "I<usec> が 1000000 以上だった。 (これをエラーとみなすシステムのみ)"

#. type: tbl table
#: build/C/man3/usleep.3:100
#, no-wrap
msgid "B<usleep>()"
msgstr " B<usleep>()"

#. type: Plain text
#: build/C/man3/usleep.3:109
msgid ""
"4.3BSD, POSIX.1-2001.  POSIX.1-2001 declares this function obsolete; use "
"B<nanosleep>(2)  instead.  POSIX.1-2008 removes the specification of "
"B<usleep>()."
msgstr ""
"4.3BSD, POSIX.1-2001.  POSIX.1-2001 では、この関数は過去のものと宣言されてい"
"る。 代わりに B<nanosleep>(2)  を使うこと。 POSIX.1-2008 では、 B<usleep>()  "
"の規定が削除されている。"

#. type: Plain text
#: build/C/man3/usleep.3:116
msgid ""
"On the original BSD implementation, and in glibc before version 2.2.2, the "
"return type of this function is I<void>.  The POSIX version returns I<int>, "
"and this is also the prototype used since glibc 2.2.2."
msgstr ""
"もともとの BSD の実装や、バージョン 2.2.2 より前の glibc では、 この関数の返"
"り値の型は I<void> である。 POSIX 版は I<int> を返し、このプロトタイプは "
"glibc 2.2.2 以降で使用されている。"

#. type: Plain text
#: build/C/man3/usleep.3:120
msgid ""
"Only the B<EINVAL> error return is documented by SUSv2 and POSIX.1-2001."
msgstr ""
"エラーとして B<EINVAL> を返すというのは SUSv2 と POSIX.1-2001 でのみ文書化さ"
"れている。"

#. type: Plain text
#: build/C/man3/usleep.3:128
msgid ""
"The type I<useconds_t> is an unsigned integer type capable of holding "
"integers in the range [0,1000000].  Programs will be more portable if they "
"never mention this type explicitly.  Use"
msgstr ""
"I<useconds_t> 型は [0,1000000] の範囲の整数を扱うことができる 符号なし整数型"
"である。 明示的にこの型を使わないことでプログラムの移植性がより高まる。 以下"
"のように使うこと。"

#. type: Plain text
#: build/C/man3/usleep.3:136
#, no-wrap
msgid ""
"#include E<lt>unistd.hE<gt>\n"
"\\&...\n"
"    unsigned int usecs;\n"
"\\&...\n"
"    usleep(usecs);\n"
msgstr ""
"#include E<lt>unistd.hE<gt>\n"
"\\&...\n"
"    unsigned int usecs;\n"
"\\&...\n"
"    usleep(usecs);\n"

#. type: Plain text
#: build/C/man3/usleep.3:153
msgid ""
"The interaction of this function with the B<SIGALRM> signal, and with other "
"timer functions such as B<alarm>(2), B<sleep>(3), B<nanosleep>(2), "
"B<setitimer>(2), B<timer_create>(2), B<timer_delete>(2), "
"B<timer_getoverrun>(2), B<timer_gettime>(2), B<timer_settime>(2), "
"B<ualarm>(3)  is unspecified."
msgstr ""
"この関数と、 B<SIGALRM> シグナルあるいは B<alarm>(2), B<sleep>(3), "
"B<nanosleep>(2), B<setitimer>(2), B<timer_create>(2), B<timer_delete>(2), "
"B<timer_getoverrun>(2), B<timer_gettime>(2), B<timer_settime>(2), "
"B<ualarm>(3)  といったその他のタイマー関数を同時に使った場合の動作は未定義で"
"ある。"

#. type: Plain text
#: build/C/man3/usleep.3:162
msgid ""
"B<alarm>(2), B<getitimer>(2), B<nanosleep>(2), B<select>(2), "
"B<setitimer>(2), B<sleep>(3), B<ualarm>(3), B<time>(7)"
msgstr ""
"B<alarm>(2), B<getitimer>(2), B<nanosleep>(2), B<select>(2), "
"B<setitimer>(2), B<sleep>(3), B<ualarm>(3), B<time>(7)"

#. type: TH
#: build/C/man2/vfork.2:29
#, no-wrap
msgid "VFORK"
msgstr "VFORK"

#. type: Plain text
#: build/C/man2/vfork.2:32
msgid "vfork - create a child process and block parent"
msgstr "vfork - 子プロセスを生成し親プロセスを停止させる"

#. type: Plain text
#: build/C/man2/vfork.2:38
msgid "B<pid_t vfork(void);>"
msgstr "B<pid_t vfork(void);>"

#. type: Plain text
#: build/C/man2/vfork.2:45
msgid "B<vfork>():"
msgstr "B<vfork>():"

#. type: Plain text
#: build/C/man2/vfork.2:54
#, no-wrap
msgid ""
"(_XOPEN_SOURCE\\ E<gt>=\\ 500) && ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200809L)\n"
"    || /* Since glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE\n"
msgstr ""
"(_XOPEN_SOURCE\\ E<gt>=\\ 500) && ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200809L)\n"
"    || /* glibc 2.19 以降: */ _DEFAULT_SOURCE\n"
"    || /* glibc 2.19 以前: */ _BSD_SOURCE\n"

#. type: SS
#: build/C/man2/vfork.2:63
#, no-wrap
msgid "Standard description"
msgstr "規格の説明"

#. type: Plain text
#: build/C/man2/vfork.2:82
msgid ""
"(From POSIX.1)  The B<vfork>()  function has the same effect as B<fork>(2), "
"except that the behavior is undefined if the process created by B<vfork>()  "
"either modifies any data other than a variable of type I<pid_t> used to "
"store the return value from B<vfork>(), or returns from the function in "
"which B<vfork>()  was called, or calls any other function before "
"successfully calling B<_exit>(2)  or one of the B<exec>(3)  family of "
"functions."
msgstr ""
"(POSIX.1 より引用)  B<vfork>()  関数は B<fork>(2)  と同じ働きをするが、 "
"B<vfork>()  で作成されたプロセスが B<vfork>()  からの返り値を格納している "
"I<pid_t> 型の変数以外を変更したり、 B<vfork>()  を呼び出している関数から "
"return したり、 B<_exit>(2)  や B<exec>(3)  族の関数をコールする前に他の関数"
"をコールした場合の動作が 未定義であるという点が異なる。"

#. type: SS
#: build/C/man2/vfork.2:82
#, no-wrap
msgid "Linux description"
msgstr "LINUX での説明"

#. type: Plain text
#: build/C/man2/vfork.2:89
msgid ""
"B<vfork>(), just like B<fork>(2), creates a child process of the calling "
"process.  For details and return value and errors, see B<fork>(2)."
msgstr ""
"B<vfork>()  は B<fork>(2)  と全く同じように呼び出したプロセスの子プロセスを生"
"成する。 詳しい説明と返り値、エラーについては B<fork>(2)  を参照すること。"

#. type: Plain text
#: build/C/man2/vfork.2:98
msgid ""
"B<vfork>()  is a special case of B<clone>(2).  It is used to create new "
"processes without copying the page tables of the parent process.  It may be "
"useful in performance-sensitive applications where a child is created which "
"then immediately issues an B<execve>(2)."
msgstr ""
"B<vfork>()  は B<clone>(2)  の特殊な場合である。 親プロセスのページテーブルの"
"コピーを行わずに新しいプロセスを 作成するために使用する。これは性能に敏感なア"
"プリケーションにおいて 子プロセスを生成してすぐに B<execve>(2)  する場合に有"
"用かもしれない。"

#. type: Plain text
#: build/C/man2/vfork.2:118
#, fuzzy
#| msgid ""
#| "B<vfork>()  differs from B<fork>(2)  in that the calling thread is "
#| "suspended until the child terminates (either normally, by calling "
#| "B<_exit>(2), or abnormally, after delivery of a fatal signal), or it "
#| "makes a call to B<execve>(2).  Until that point, the child shares all "
#| "memory with its parent, including the stack.  The child must not return "
#| "from the current function or call B<exit>(3), but may call B<_exit>(2)."
msgid ""
"B<vfork>()  differs from B<fork>(2)  in that the calling thread is suspended "
"until the child terminates (either normally, by calling B<_exit>(2), or "
"abnormally, after delivery of a fatal signal), or it makes a call to "
"B<execve>(2).  Until that point, the child shares all memory with its "
"parent, including the stack.  The child must not return from the current "
"function or call B<exit>(3)  (which would have the effect of calling exit "
"handlers established by the parent process and flushing the parent's "
"B<stdio>(3)  buffers), but may call B<_exit>(2)."
msgstr ""
"B<vfork>() は B<fork>(2) と違い、子プロセスが終了するか、\n"
"B<execve>(2) をコールするまで呼び出し元のスレッドを停止 (suspend) させる。\n"
"子プロセスの終了は、B<_exit>(2) の呼び出しによる通常終了、致命的なシグナル"
"の\n"
"配送後の異常終了の二つのケースがある。\n"
"この時点までは、子プロセスはスタックを含む全てのメモリーを親プロセスと共有す"
"る。\n"
"子プロセスは現在の関数から return してはならず、\n"
"B<exit>(3) もコールしてはならないが、B<_exit>(2) ならばコールしてもよい。"

#. type: Plain text
#: build/C/man2/vfork.2:129
msgid ""
"As with B<fork>(2), the child process created by B<vfork>()  inherits copies "
"of various of the caller's process attributes (e.g., file descriptors, "
"signal dispositions, and current working directory); the B<vfork>()  call "
"differs only in the treatment of the virtual address space, as described "
"above."
msgstr ""
"B<fork>(2) と同様に、 B<vfork>() で作成された子プロセスは、\n"
"(ファイルディスクリプター、シグナル配送定義、カレントワーキングディレクトリな"
"どの)\n"
"呼び出し元のプロセスの各種の属性を継承する。\n"
"B<vfork>() では、上で説明した仮想アドレス空間の扱いだけが異なる。"

#. type: Plain text
#: build/C/man2/vfork.2:135
msgid ""
"Signals sent to the parent arrive after the child releases the parent's "
"memory (i.e., after the child terminates or calls B<execve>(2))."
msgstr ""
"親プロセスへ送られたシグナルは、子プロセスが親プロセスのメモリーを解放した"
"後\n"
"(すなわち、子プロセスが終了するか B<execve>(2) を呼んだ後) に到着する。"

#. type: SS
#: build/C/man2/vfork.2:135
#, no-wrap
msgid "Historic description"
msgstr "歴史的な説明"

#. type: Plain text
#: build/C/man2/vfork.2:162
msgid ""
"Under Linux, B<fork>(2)  is implemented using copy-on-write pages, so the "
"only penalty incurred by B<fork>(2)  is the time and memory required to "
"duplicate the parent's page tables, and to create a unique task structure "
"for the child.  However, in the bad old days a B<fork>(2)  would require "
"making a complete copy of the caller's data space, often needlessly, since "
"usually immediately afterward an B<exec>(3)  is done.  Thus, for greater "
"efficiency, BSD introduced the B<vfork>()  system call, which did not fully "
"copy the address space of the parent process, but borrowed the parent's "
"memory and thread of control until a call to B<execve>(2)  or an exit "
"occurred.  The parent process was suspended while the child was using its "
"resources.  The use of B<vfork>()  was tricky: for example, not modifying "
"data in the parent process depended on knowing which variables were held in "
"a register."
msgstr ""
"Linux において B<fork>(2)  は書き込み時コピー (copy-on-write) ページを使用し"
"て実装されている。 そのため B<fork>(2)  を使用することによって被る損害は親プ"
"ロセスのページテーブルを 複製するために必要な時間とメモリーだけである。 しか"
"しながら、忌しき昔には B<fork>(2)  は呼び出したプロセスのデータ空間の全てのコ"
"ピーしていたが、 これはしばしば不必要であった。なぜなら、たいていはすぐ後に "
"B<exec>(3)  を実行していたからである。 この場合の効率を上げるために BSD は "
"B<vfork>()  システムコールを導入して親プロセスのアドレス空間を完全にコピー す"
"るかわりに、 B<execve>(2)  をコールするか exit が起きるまで親プロセスのメモ"
"リーと制御スレッド を借りるようにした。 親プロセスは子プロセスがその資源を使"
"用している間は停止された。 B<vfork>()  は使いにくいものであった: 例えば、親プ"
"ロセスの変数を変更しな いようにするためにはどの変数がレジスターに保持されてい"
"るかを知らな ければならなかった。"

#. type: Plain text
#: build/C/man2/vfork.2:166
msgid ""
"4.3BSD; POSIX.1-2001 (but marked OBSOLETE).  POSIX.1-2008 removes the "
"specification of B<vfork>()."
msgstr ""
"4.3BSD; POSIX.1-2001 (廃止予定とされている)。\n"
"POSIX.1-2008 では B<vfork>() の規定が削除されている。"

#.  In AIXv3.1 vfork is equivalent to fork.
#. type: Plain text
#: build/C/man2/vfork.2:177
msgid ""
"The requirements put on B<vfork>()  by the standards are weaker than those "
"put on B<fork>(2), so an implementation where the two are synonymous is "
"compliant.  In particular, the programmer cannot rely on the parent "
"remaining blocked until the child either terminates or calls B<execve>(2), "
"and cannot rely on any specific behavior with respect to shared memory."
msgstr ""
"B<vfork>() コールは他のオペレーティングシステムの同名のコールと ちょっと似\n"
"ているかもしれない。規格が B<vfork>() に要求していることは、 B<fork>(2) に"
"要\n"
"求していることよりは弱い。したがって、 両者を同じものとして実装しても、規格"
"に\n"
"準拠していることになる。 特にプログラマーは、子プロセスが終了するか\n"
"B<execve>(2) を呼び出すまで親プロセスが停止していることや、メモリーを共有する"
"こ\n"
"とによる特殊な動作をあてにすべきではない。"

#. type: Plain text
#: build/C/man2/vfork.2:195
msgid ""
"Some consider the semantics of B<vfork>()  to be an architectural blemish, "
"and the 4.2BSD man page stated: \"This system call will be eliminated when "
"proper system sharing mechanisms are implemented.  Users should not depend "
"on the memory sharing semantics of B<vfork>()  as it will, in that case, be "
"made synonymous to B<fork>(2).\" However, even though modern memory "
"management hardware has decreased the performance difference between "
"B<fork>(2)  and B<vfork>(), there are various reasons why Linux and other "
"systems have retained B<vfork>():"
msgstr ""
"B<vfork>() の動作は構造的な欠陥と考える人もいるだろうし、\n"
"BSD のマニュアルには、「このシステムコールは妥当なシステム共有機構が実装さ\n"
"れた場合には削除される。ユーザーは B<vfork>() のメモリー共有機能に依存するべ"
"き\n"
"ではない。何故ならば、このシステムコール が削除された場合には、それは\n"
"B<fork>(2) の同義語とされるからである。」と書かれている。しかしながら、\n"
"最近のメモリー管理ハードウェアにより B<fork>(2) と B<vfork>() の間の性能差"
"が\n"
"減ったとはいえ、 Linux や他のシステムで B<vfork>() が残されているのには\n"
"いくつか理由がある:"

#. type: Plain text
#: build/C/man2/vfork.2:199
msgid ""
"Some performance-critical applications require the small performance "
"advantage conferred by B<vfork>()."
msgstr ""
"性能に厳しいアプリケーションでは、 B<vfork>() により得られる\n"
"小さな性能上のメリットが必要な場合がある。"

#.  http://stackoverflow.com/questions/4259629/what-is-the-difference-between-fork-and-vfork
#.  http://developers.sun.com/solaris/articles/subprocess/subprocess.html
#.  http://mailman.uclinux.org/pipermail/uclinux-dev/2009-April/000684.html
#. type: Plain text
#: build/C/man2/vfork.2:216
msgid ""
"B<vfork>()  can be implemented on systems that lack a memory-management unit "
"(MMU), but B<fork>(2)  can't be implemented on such systems.  (POSIX.1-2008 "
"removed B<vfork>()  from the standard; the POSIX rationale for the "
"B<posix_spawn>(3)  function notes that that function, which provides "
"functionality equivalent to B<fork>(2)+B<exec>(3), is designed to be "
"implementable on systems that lack an MMU.)"
msgstr ""
"B<vfork>() はメモリー管理ユニット (MMU) を持たないシステムでも実装すること\n"
"ができるが、そのようなシステムで B<fork>(2) を実装することはできない。\n"
"(POSIX.1-2008 では B<vfork>() が標準から削除された。\n"
"B<posix_spawn>(3) 関数の POSIX の原理 (rationale) には、\n"
"B<fork>(2)+B<exec>(3) と等価な機能を提供する B<posix_spawn>(3) は、\n"
"MMU を持たないシステムでも実装できるように設計されたとの注記がある。)"

#. type: Plain text
#: build/C/man2/vfork.2:233
msgid ""
"On systems where memory is constrained, B<vfork>()  avoids the need to "
"temporarily commit memory (see the description of I</proc/sys/vm/"
"overcommit_memory> in B<proc>(5))  in order to execute a new program.  (This "
"can be especially beneficial where a large parent process wishes to execute "
"a small helper program in a child process.)  By contrast, using B<fork>(2)  "
"in this scenario requires either committing an amount of memory equal to the "
"size of the parent process (if strict overcommitting is in force)  or "
"overcommitting memory with the risk that a process is terminated by the out-"
"of-memory (OOM) killer."
msgstr ""

#. type: SS
#: build/C/man2/vfork.2:233
#, no-wrap
msgid "Caveats"
msgstr ""

#. type: Plain text
#: build/C/man2/vfork.2:244
msgid ""
"The child process should take care not to modify the memory in unintended "
"ways, since such changes will be seen by the parent process once the child "
"terminates or executes another program.  In this regard, signal handlers can "
"be especially problematic: if a signal handler that is invoked in the child "
"of B<vfork>()  changes memory, those changes may result in an inconsistent "
"process state from the perspective of the parent process (e.g., memory "
"changes would be visible in the parent, but changes to the state of open "
"file descriptors would not be visible)."
msgstr ""

#. type: Plain text
#: build/C/man2/vfork.2:270
msgid ""
"When B<vfork>()  is called in a multithreaded process, only the calling "
"thread is suspended until the child terminates or executes a new program.  "
"This means that the child is sharing an address space with other running "
"code.  This can be dangerous if another thread in the parent process changes "
"credentials (using B<setuid>(2)  or similar), since there are now two "
"processes with different privilege levels running in the same address "
"space.  As an example of the dangers, suppose that a multithreaded program "
"running as root creates a child using B<vfork>().  After the B<vfork>(), a "
"thread in the parent process drops the process to an unprivileged user in "
"order to run some untrusted code (e.g., perhaps via plug-in opened with "
"B<dlopen>(3)).  In this case, attacks are possible where the parent process "
"uses B<mmap>(2)  to map in code that will be executed by the privileged "
"child process."
msgstr ""

#. type: SS
#: build/C/man2/vfork.2:270
#, no-wrap
msgid "Linux notes"
msgstr "Linux での注意"

#. type: Plain text
#: build/C/man2/vfork.2:281
msgid ""
"Fork handlers established using B<pthread_atfork>(3)  are not called when a "
"multithreaded program employing the NPTL threading library calls "
"B<vfork>().  Fork handlers are called in this case in a program using the "
"LinuxThreads threading library.  (See B<pthreads>(7)  for a description of "
"Linux threading libraries.)"
msgstr ""
"B<pthread_atfork>(3)  を使って設定された fork ハンドラーは NPTL スレッドライ"
"ブラリコールを採用したマルチスレッドプログラムでは 呼び出されない。一方、"
"LinuxThreads スレッドライブラリを使った プログラムでは、fork ハンドラーは呼び"
"出される。 (Linux のスレッドライブラリの説明は B<pthreads>(7)  を参照。)"

#. type: Plain text
#: build/C/man2/vfork.2:289
msgid ""
"A call to B<vfork>()  is equivalent to calling B<clone>(2)  with I<flags> "
"specified as:"
msgstr ""
"B<vfork>() の呼び出しは、以下の I<flags> を指定して B<clone>(2) を呼び出す\n"
"のと等価である。"

#. type: Plain text
#: build/C/man2/vfork.2:291
#, no-wrap
msgid "     CLONE_VM | CLONE_VFORK | SIGCHLD\n"
msgstr "     CLONE_VM | CLONE_VFORK | SIGCHLD\n"

#.  In the release notes for 4.2BSD Sam Leffler wrote: `vfork: Is still
#.  present, but definitely on its way out'.
#. type: Plain text
#: build/C/man2/vfork.2:309
msgid ""
"The B<vfork>()  system call appeared in 3.0BSD.  In 4.4BSD it was made "
"synonymous to B<fork>(2)  but NetBSD introduced it again; see E<.UR http://"
"www.netbsd.org\\:/Documentation\\:/kernel\\:/vfork.html> E<.UE .> In Linux, "
"it has been equivalent to B<fork>(2)  until 2.2.0-pre6 or so.  Since 2.2.0-"
"pre9 (on i386, somewhat later on other architectures) it is an independent "
"system call.  Support was added in glibc 2.0.112."
msgstr ""
"B<vfork>()  システムコールは 3.0BSD に現われた。 4.4BSD において B<fork>(2)  "
"の同義語となったが、NetBSD では再び導入された。 E<.UR http://www.netbsd.org"
"\\:/Documentation\\:/kernel\\:/vfork.html> E<.UE> を参照。 Linux では 2.2.0-"
"pre6 あたりまでは B<fork>(2)  と等価であった。(i386 では) 2.2.0-pre9 から (他"
"のアーキテクチャーでは 少し遅れて) 独立したシステムコールとなった。 glibc で"
"のサポートは glibc-2.0.112 で追加された。"

#.  As far as I can tell, the following is not true in 2.6.19:
#.  Currently (Linux 2.3.25),
#.  .BR strace (1)
#.  cannot follow
#.  .BR vfork ()
#.  and requires a kernel patch.
#. type: Plain text
#: build/C/man2/vfork.2:329
msgid ""
"Details of the signal handling are obscure and differ between systems.  The "
"BSD man page states: \"To avoid a possible deadlock situation, processes "
"that are children in the middle of a B<vfork>()  are never sent B<SIGTTOU> "
"or B<SIGTTIN> signals; rather, output or I<ioctl>s are allowed and input "
"attempts result in an end-of-file indication.\""
msgstr ""
"シグナルの扱いの詳細は不明瞭でシステムごとに異っている。 BSD のマニュアルに"
"は、 「デッドロック状態になる可能性があるので B<vfork>()  の途中の子プロセス"
"に B<SIGTTOU> や B<SIGTTIN> シグナルを送信してはならない; さらに出力や "
"I<ioctl> は許されるが、入力を試みた場合には結果はファイル終端 (EOF) にな"
"る。」 と書かれている。"

#. type: Plain text
#: build/C/man2/vfork.2:336
msgid ""
"B<clone>(2), B<execve>(2), B<_exit>(2), B<fork>(2), B<unshare>(2), B<wait>(2)"
msgstr "B<clone>(2), B<execve>(2), B<fork>(2), B<unshare>(2), B<wait>(2)"

#. type: TH
#: build/C/man2/vhangup.2:28
#, no-wrap
msgid "VHANGUP"
msgstr "VHANGUP"

#. type: Plain text
#: build/C/man2/vhangup.2:31
msgid "vhangup - virtually hangup the current terminal"
msgstr "vhangup - 現在の端末を仮想的に (virtualy) ハングアップ (hangup) させる"

#. type: Plain text
#: build/C/man2/vhangup.2:35
msgid "B<int vhangup(void);>"
msgstr "B<int vhangup(void);>"

#. type: Plain text
#: build/C/man2/vhangup.2:43
msgid "B<vhangup>():"
msgstr " B<vhangup>():"

#. type: Plain text
#: build/C/man2/vhangup.2:58
msgid ""
"B<vhangup>()  simulates a hangup on the current terminal.  This call "
"arranges for other users to have a ``clean'' terminal at login time."
msgstr ""
"B<vhangup>()  は現在の端末 (terminal) でハングアップをシミュレートする。この"
"コールは他のユーザーがログインした時に綺麗 (clean) な端末を得ることができるよ"
"う手配する。"

#. type: Plain text
#: build/C/man2/vhangup.2:71
msgid ""
"The calling process has insufficient privilege to call B<vhangup>(); the "
"B<CAP_SYS_TTY_CONFIG> capability is required."
msgstr ""
"呼び出し元プロセスに B<vhangup>()  を呼び出すための十分な特権がない。 "
"B<CAP_SYS_TTY_CONFIG> ケーパビリティ (capability) が必要である。"

#. type: Plain text
#: build/C/man2/vhangup.2:74
msgid ""
"This call is Linux-specific, and should not be used in programs intended to "
"be portable."
msgstr ""
"このコールは Linux 特有であり、移植を意図したプログラムで 使用してはいけな"
"い。"

#. type: Plain text
#: build/C/man2/vhangup.2:77
msgid "B<init>(1), B<capabilities>(7)"
msgstr " B<init>(1), B<capabilities>(7)"

#. type: TH
#: build/C/man2/execveat.2:26
#, no-wrap
msgid "EXECVEAT"
msgstr "EXECVEAT"

#. type: Plain text
#: build/C/man2/execveat.2:29
msgid "execveat - execute program relative to a directory file descriptor"
msgstr ""
"execveat - ディレクトリファイルディスクリプターからの相対パスで指定されるプロ"
"グラムを実行する"

#. type: Plain text
#: build/C/man2/execveat.2:33
msgid "B<int execveat(int >I<dirfd>B<, const char *>I<pathname>B<,>"
msgstr "B<int execveat(int >I<dirfd>B<, const char *>I<pathname>B<,>"

#. type: Plain text
#: build/C/man2/execveat.2:35
msgid "B< char *const >I<argv>B<[], char *const >I<envp>B<[],>"
msgstr "B< char *const >I<argv>B<[], char *const >I<envp>B<[],>"

#. type: Plain text
#: build/C/man2/execveat.2:37
msgid "B< int >I<flags>B<);>"
msgstr "B< int >I<flags>B<);>"

#.  commit 51f39a1f0cea1cacf8c787f652f26dfee9611874
#. type: Plain text
#: build/C/man2/execveat.2:48
msgid ""
"The B<execveat>()  system call executes the program referred to by the "
"combination of I<dirfd> and I<pathname>.  It operates in exactly the same "
"way as B<execve>(2), except for the differences described in this manual "
"page."
msgstr ""
"B<execveat>() システムコールは I<dirfd> と I<pathname> の組み合わせで参照され"
"るプログラムを実行する。 B<execve>(2) と全く同様に動作するが、 以下で説明する"
"点が異なる。"

#. type: Plain text
#: build/C/man2/execveat.2:58
msgid ""
"If the pathname given in I<pathname> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<dirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<execve>(2)  for a relative pathname)."
msgstr ""
"I<pathname> で指定されたパス名が相対パスの場合、このパス名はファイルディスク"
"リプター I<dirfd> が参照するディレクトリに対する相対パスと解釈される "
"(B<execve>(2) に相対パス名を渡した場合のように、呼び出したプロセスのカレント"
"ワーキングディレクトリに対する相対パスではない)。"

#. type: Plain text
#: build/C/man2/execveat.2:70
msgid ""
"If I<pathname> is relative and I<dirfd> is the special value B<AT_FDCWD>, "
"then I<pathname> is interpreted relative to the current working directory of "
"the calling process (like B<execve>(2))."
msgstr ""
"I<pathname> で指定されたパス名が相対パスで、 I<dirfd> が特別な値 B<AT_FDCWD> "
"の場合、 (B<execve>(2) と同様に) I<pathname> は呼び出したプロセスのカレント"
"ワーキングディレクトリに対する相対パスと解釈される。"

#. type: Plain text
#: build/C/man2/execveat.2:86
msgid ""
"If I<pathname> is an empty string and the B<AT_EMPTY_PATH> flag is "
"specified, then the file descriptor I<dirfd> specifies the file to be "
"executed (i.e., I<dirfd> refers to an executable file, rather than a "
"directory)."
msgstr ""
"I<pathname> が空文字列で、 B<AT_EMPTY_PATH> フラグが指定されている場合、 ファ"
"イルディスクリプター I<dirfd> は実行するファイルを指定する (すなわち "
"I<dirfd> はディレクトリではなく実行ファイルを参照する)。"

#. type: Plain text
#: build/C/man2/execveat.2:90
msgid ""
"The I<flags> argument is a bit mask that can include zero or more of the "
"following flags:"
msgstr ""
"I<flags> 引数は、以下に示す値の 0 個以上を指定できるビットマスクである。"

#. type: TP
#: build/C/man2/execveat.2:90
#, no-wrap
msgid "B<AT_EMPTY_PATH>"
msgstr "B<AT_EMPTY_PATH>"

#. type: Plain text
#: build/C/man2/execveat.2:100
msgid ""
"If I<pathname> is an empty string, operate on the file referred to by "
"I<dirfd> (which may have been obtained using the B<open>(2)  B<O_PATH> flag)."
msgstr ""
"I<pathname> が空文字列の場合、 I<dirfd> が参照するファイルに対して動作を行う "
"(I<dirfd> は B<open>(2() B<O_PATH> フラグを使って取得できる)。"

#. type: Plain text
#: build/C/man2/execveat.2:108
msgid ""
"If the file identified by I<dirfd> and a non-NULL I<pathname> is a symbolic "
"link, then the call fails with the error B<ELOOP>."
msgstr ""
"I<dirfd> と NULL でない I<pathname> で指定されたファイルがシンボリックリンク"
"の場合、 呼び出しはエラー B<ELOOP> で失敗する。"

#. type: Plain text
#: build/C/man2/execveat.2:115
msgid ""
"On success, B<execveat>()  does not return.  On error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""
"成功すると B<execveat>()  は返らない。エラーの場合は -1 を返し、 I<errno> を"
"適切に設定する。"

#. type: Plain text
#: build/C/man2/execveat.2:122
msgid ""
"The same errors that occur for B<execve>(2)  can also occur for "
"B<execveat>().  The following additional errors can occur for B<execveat>():"
msgstr ""
"B<execve>() で発生するのと同じエラーが B<execveat>() でも起こる。 "
"B<execveat>() では以下のエラーも発生する。"

#. type: Plain text
#: build/C/man2/execveat.2:140
msgid ""
"I<flags> includes B<AT_SYMLINK_NOFOLLOW> and the file identified by I<dirfd> "
"and a non-NULL I<pathname> is a symbolic link."
msgstr ""
"I<flags> に B<AT_SYMLINK_NOFOLLOW> が指定されていて、 I<dirfd> と NULL でな"
"い I<pathname> で指定されたファイルがシンボリックリンクである。"

#. type: Plain text
#: build/C/man2/execveat.2:154
msgid ""
"The program identified by I<dirfd> and I<pathname> requires the use of an "
"interpreter program (such as a script starting with \"#!\"), but the file "
"descriptor I<dirfd> was opened with the B<O_CLOEXEC> flag, with the result "
"that the program file is inaccessible to the launched interpreter.  See BUGS."
msgstr ""
"I<dirfd> と I<pathname> で指定されるプログラムはインタープリタープログラムを"
"使用する必要があるが (例えば \"#!\" で始まるスクリプト)、 ファイルディスクリ"
"プター I<dirfd> が B<O_CLOEXEC> フラグ付きでオープンされており、 その結果プロ"
"グラムファイルは起動されたインタープリターにアクセスできないことになる。 「バ"
"グ」を参照。"

#.  FIXME . check for glibc support in a future release
#. type: Plain text
#: build/C/man2/execveat.2:165
msgid ""
"B<execveat>()  was added to Linux in kernel 3.19.  GNU C library support is "
"pending."
msgstr ""
"B<execveat>()  はバージョン 3.19 で Linux に追加された。 GNU C ライブラリによ"
"るサポートは検討中である。"

#. type: Plain text
#: build/C/man2/execveat.2:169
msgid "The B<execveat>()  system call is Linux-specific."
msgstr "B<execveat>() システムコールは Linux 固有である。"

#. type: Plain text
#: build/C/man2/execveat.2:179
msgid ""
"In addition to the reasons explained in B<openat>(2), the B<execveat>()  "
"system call is also needed to allow B<fexecve>(3)  to be implemented on "
"systems that do not have the I</proc> filesystem mounted."
msgstr ""
"B<openat>(2) で説明されている理由に加え、 B<execveat>() システムコールは、 "
"B<fexecve>(3) を I</proc> ファイルシステムがマウントされていないシステムで実"
"装するためにも必要である。"

#. type: Plain text
#: build/C/man2/execveat.2:202
msgid ""
"When asked to execute a script file, the I<argv[0]> that is passed to the "
"script interpreter is a string of the form I</dev/fd/N> or I</dev/fd/N/P>, "
"where I<N> is the number of the file descriptor passed via the I<dirfd> "
"argument.  A string of the first form occurs when B<AT_EMPTY_PATH> is "
"employed.  A string of the second form occurs when the script is specified "
"via both I<dirfd> and I<pathname>; in this case, I<P> is the value given in "
"I<pathname>."
msgstr ""
"スクリプトファイルを実行するように要求された際、 スクリプトインタープリターに"
"渡される I<argv[0]> は、 I</dev/fd/N> 形式または I</dev/fd/N/P> 形式の文字列"
"である。 ここで I<N> は I<dirfd> 引数で渡されたファイルディスクリプター数で"
"ある。 最初の形式の文字列となるのは、 B<AT_EMPTY_PATH> が使用された場合であ"
"る。 2 番目の形式の文字列になるのは、 スクリプトが I<dirfd> と I<pathname> の"
"両方を使って指定された場合である。 このとき I<P> は I<pathname> に指定された"
"値である。"

#. type: Plain text
#: build/C/man2/execveat.2:210
msgid ""
"For the same reasons described in B<fexecve>(3), the natural idiom when "
"using B<execveat>()  is to set the close-on-exec flag on I<dirfd>.  (But see "
"BUGS.)"
msgstr ""
"B<fexecve>(3) で説明されているのと同じ理由で、 B<execveat>() を使う際の理にか"
"なった方法は I<dirfd> に close-on-exec フラグをセットすることである (ただし"
"「バグ」を参照のこと)。"

#. type: Plain text
#: build/C/man2/execveat.2:215
msgid ""
"The B<ENOENT> error described above means that it is not possible to set the "
"close-on-exec flag on the file descriptor given to a call of the form:"
msgstr ""
"上記で説明したエラー B<ENOENT> は、 以下の形式の呼び出しに渡すファイルディス"
"クリプターで close-on-exec フラグをセットできないことを意味している。"

#. type: Plain text
#: build/C/man2/execveat.2:217
#, no-wrap
msgid "    execveat(fd, \"\", argv, envp, AT_EMPTY_PATH);\n"
msgstr "    execveat(fd, \"\", argv, envp, AT_EMPTY_PATH);\n"

#
#.  For an example, see Michael Kerrisk's 2015-01-10 reply in this LKML
#.  thread (http://thread.gmane.org/gmane.linux.kernel/1836105/focus=20229):
#.      Subject: [PATCHv10 man-pages 5/5] execveat.2: initial man page.\"                        for execveat(2
#.      Date: Mon, 24 Nov 2014 11:53:59 +0000
#. type: Plain text
#: build/C/man2/execveat.2:229
msgid ""
"However, the inability to set the close-on-exec flag means that a file "
"descriptor referring to the script leaks through to the script itself.  As "
"well as wasting a file descriptor, this leakage can lead to file-descriptor "
"exhaustion in scenarios where scripts recursively employ B<execveat>()."
msgstr ""
"しかしながら、 close-on-exec フラグをセットできないということは、 スクリプト"
"を参照するファイルディスクリプターはスクリプト自身に見えてしまうということで"
"ある。 ファイルディスクリプターを無駄に使うだけでなく、 ファイルディスクリプ"
"ターが見えてしまうことにより、 スクリプトが B<execveat>() を再帰的に利用する"
"状況ではファイルディスクリプターの枯渇につながる可能性がある。"

#. type: Plain text
#: build/C/man2/execveat.2:233
msgid "B<execve>(2), B<openat>(2), B<fexecve>(3)"
msgstr "B<execve>(2), B<openat>(2), B<fexecve>(3)"

#. type: TH
#: build/C/man3/get_phys_pages.3:25
#, no-wrap
msgid "GET_PHYS_PAGES"
msgstr " GET_PHYS_PAGES"

#. type: Plain text
#: build/C/man3/get_phys_pages.3:29
msgid ""
"get_phys_pages, get_avphys_pages - get total and available physical page "
"counts"
msgstr ""

#. type: Plain text
#: build/C/man3/get_phys_pages.3:32
#, no-wrap
msgid "B<#include E<lt>sys/sysinfo.hE<gt>>\n"
msgstr " B<#include E<lt>sys/sysinfo.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/get_phys_pages.3:35
#, no-wrap
msgid ""
"B<long get_phys_pages(void);>\n"
"B<long get_avphys_pages(void);>\n"
msgstr ""
"B<long get_phys_pages(void);>\n"
"B<long get_avphys_pages(void);>\n"

#. type: Plain text
#: build/C/man3/get_phys_pages.3:40
#, fuzzy
#| msgid ""
#| "The function B<get_nprocs_conf>()  returns the number of processors "
#| "configured by the operating system."
msgid ""
"The function B<get_phys_pages>()  returns the total number of physical pages "
"of memory available on the system."
msgstr ""
"B<get_nprocs_conf>() 関数は、オペレーティングシステムで\n"
"設定されているプロセッサ数を返す。"

#. type: Plain text
#: build/C/man3/get_phys_pages.3:45
#, fuzzy
#| msgid ""
#| "The function B<get_nprocs_conf>()  returns the number of processors "
#| "configured by the operating system."
msgid ""
"The function B<get_avphys_pages>()  returns the number of currently "
"available physical pages of memory on the system."
msgstr ""
"B<get_nprocs_conf>() 関数は、オペレーティングシステムで\n"
"設定されているプロセッサ数を返す。"

#. type: Plain text
#: build/C/man3/get_phys_pages.3:51
#, fuzzy
#| msgid ""
#| "The B<usleep>()  function returns 0 on success.  On error, -1 is "
#| "returned, with I<errno> set to indicate the cause of the error."
msgid ""
"On success, these functions return a nonnegative value as given in "
"DESCRIPTION.  On failure, they return -1 and set I<errno> to indicate the "
"cause of the error."
msgstr ""
"B<usleep>() 関数は成功すると 0 を返す。 エラーの場合、 -1 が返され、 "
"I<errno> にエラーの原因を示す値が設定される。"

#. type: Plain text
#: build/C/man3/get_phys_pages.3:58
msgid ""
"The system could not provide the required information (possibly because the "
"I</proc> filesystem was not mounted)."
msgstr ""

#. type: Plain text
#: build/C/man3/get_phys_pages.3:67
msgid ""
"These functions obtain the required information by scanning the I<MemTotal> "
"and I<MemFree> fields of I</proc/meminfo>."
msgstr ""

#. type: Plain text
#: build/C/man3/get_phys_pages.3:72
#, fuzzy
#| msgid ""
#| "The following B<sysconf>(3)  calls make use of the functions documented "
#| "on this page to return the same information."
msgid ""
"The following B<sysconf>(3)  calls provide a portable means of obtaining the "
"same information as the functions described on this page."
msgstr ""
"以下の B<sysconf>(3) の呼び出しで、このページに書かれている関数を使った\n"
"場合に返されるのと同じ情報を得ることができる。"

#. type: Plain text
#: build/C/man3/get_phys_pages.3:77
#, no-wrap
msgid ""
"total_pages = sysconf(_SC_PHYS_PAGES);    /* total pages */\n"
"avl_pages = sysconf(_SC_AVPHYS_PAGES);    /* available pages */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/get_phys_pages.3:85
msgid ""
"The following example shows how B<get_phys_pages>()  and "
"B<get_avphys_pages>()  can be used."
msgstr "以下の例は、 B<get_phys_pages>() と B<get_avphys_pages>() がどのように利用できるかを示すものである。"

#. type: Plain text
#: build/C/man3/get_phys_pages.3:90
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/sysinfo.hE<gt>\n"
msgstr ""
" #include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/sysinfo.hE<gt>\n"

#. type: Plain text
#: build/C/man3/get_phys_pages.3:99
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    printf(\"This system has %ld pages of physical memory and \"\n"
"            \"%ld pages of physical memory available.\\en\",\n"
"            get_phys_pages(), get_avphys_pages());\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
" int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    printf(\"This system has %ld pages of physical memory and \"\n"
"            \"%ld pages of physical memory available.\\en\",\n"
"            get_phys_pages(), get_avphys_pages());\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man3/get_phys_pages.3:102
msgid "B<sysconf>(3)"
msgstr "B<sysconf>(3)"

#~ msgid ""
#~ "/* Note: if you copy directly from the nroff source, remember to\n"
#~ "REMOVE the extra backslashes in the printf statement. */\n"
#~ msgstr ""
#~ "/* Note: nroff のソースファイルから直接コピーする際には、\n"
#~ "printf 文内の余分なバックスラッシュを忘れずに削除するように。 */\n"

#~ msgid "The descriptor is not valid."
#~ msgstr "ディスクリプターが有効でない。"

#~ msgid ""
#~ "This call changes an ingredient in the pathname resolution process and "
#~ "does nothing else."
#~ msgstr ""
#~ "このコールはパス名解決の過程で構成要素を変更するのみで、 その他には何も行"
#~ "わない。"

#~ msgid ""
#~ "So $5$I<salt>$I<encrypted> is an SHA-256 encoded password and $6$I<salt>"
#~ "$I<encrypted> is an SHA-512 encoded one."
#~ msgstr ""
#~ "従って、$5$I<salt>$I<encrypted> は SHA-256 でエンコードされた パスワードで"
#~ "あり、$6$I<salt>$I<encrypted> は SHA-512 で エンコードされたパスワードであ"
#~ "る。"

#~ msgid "These functions are present in glibc 2.1 and later."
#~ msgstr "これらの関数は glibc 2.1 以降に存在する。"

#~ msgid ""
#~ "The functions B<encrypt>()  and B<setkey>()  conform to SVr4, SUSv2, and "
#~ "POSIX.1-2001.  The functions B<encrypt_r>()  and B<setkey_r>()  are GNU "
#~ "extensions."
#~ msgstr ""
#~ "関数 B<encrypt>()  と B<setkey>()  は SVr4, SUSv2, and POSIX.1-2001 に準拠"
#~ "する。 関数 B<encrypt_r>()  と B<setkey_r>()  は GNU 拡張である。"

#~ msgid ""
#~ "You need to link with libcrypt to compile this example with glibc.  To do "
#~ "useful work, the I<key[]> and I<txt[]> arrays must be filled with a "
#~ "useful bit pattern."
#~ msgstr ""
#~ "この例を glibc でコンパイルするには libcrypt とリンクする必要がある。 実際"
#~ "に動作させるためには、配列 I<key[]> と I<txt[]> に有効なビットパターンを指"
#~ "定しなければならない。"

#~ msgid "Special semantics for execlp() and execvp()"
#~ msgstr "execlp() と execvp() の特別な動作"

#~ msgid ""
#~ "On some other systems, the default path (used when the environment does "
#~ "not contain the variable B<PATH>) has the current working directory "
#~ "listed after I</bin> and I</usr/bin>, as an anti-Trojan-horse measure.  "
#~ "Linux uses here the traditional \"current directory first\" default path."
#~ msgstr ""
#~ "Linux 以外のシステムには、 (環境変数 B<PATH> が定義されていないときの)  デ"
#~ "フォルトのパスにおいて、カレントディレクトリが I</bin> と I</usr/bin> の後"
#~ "ろに配置されるものもある。 これはトロイの木馬対策のためである。 Linux で"
#~ "は、デフォルトのパスに、昔ながらの「現在のディレクトリを 先に探索」という"
#~ "ルールを使っている。"

#~ msgid "B<int execve(const char *>I<filename>B<, char *const >I<argv>B<[], >"
#~ msgstr ""
#~ "B<int execve(const char *>I<filename>B<, char *const >I<argv>B<[], >"

#~ msgid ""
#~ "The B<prctl>(2)  B<PR_SET_DUMPABLE> flag is set, unless a set-user-ID or "
#~ "set-group ID program is being executed, in which case it is cleared."
#~ msgstr ""
#~ "set-user-ID か set-group-ID されたプログラムが実行されている場合、 "
#~ "B<prctl>(2)  の B<PR_SET_DUMPABLE> フラグはクリアされる。それ以外の場合、"
#~ "このフラグはセットされる。"

#~ msgid ""
#~ "where I<arg...> is the series of words pointed to by the I<argv> argument "
#~ "of B<execve>(), starting at I<argv>[1]."
#~ msgstr ""
#~ "I<arg...> は、 B<execve>() の I<argv> 引数が指すワード列である。 "
#~ "I<argv>[1] から始まる。"

#~ msgid "The process has the maximum number of files open."
#~ msgstr ""
#~ "そのプロセスがオープンできるファイル数の上限まで既にオープンしている。"

#~ msgid "I<filename> is too long."
#~ msgstr "I<filename> が長過ぎる。"

#~ msgid ""
#~ "The file I<filename> or a script or ELF interpreter does not exist, or a "
#~ "shared library needed for file or interpreter cannot be found."
#~ msgstr ""
#~ "ファイル I<filename> かスクリプトや ELF のインタープリターが存在しない。"

#~ msgid ""
#~ "A maximum line length of 127 characters is allowed for the first line in "
#~ "an interpreter scripts."
#~ msgstr ""
#~ "インタープリタースクリプトの 1行目に許されている文字数は、 最大 127 文字で"
#~ "ある。"

#~ msgid ""
#~ "I<Warning>: the Linux implementation of mandatory locking is unreliable.  "
#~ "See BUGS below."
#~ msgstr ""
#~ "I<警告>: Linux の強制ロックの実装は信頼性に欠けるものである。 下記の「バ"
#~ "グ」の節を参照のこと。"

#~ msgid "The I</proc> filesystem could not be accessed."
#~ msgstr "I</proc> ファイルシステムにアクセスできなかった。"

#~ msgid ""
#~ "On Linux, B<fexecve>()  is implemented using the B<proc>(5)  filesystem, "
#~ "so I</proc> needs to be mounted and available at the time of the call."
#~ msgstr ""
#~ "Linux では、 B<fexecve>()  は B<proc>(5)  ファイルシステムを使って実装され"
#~ "ている。 そのため、この関数を呼び出す時点では I</proc> がマウントされて利"
#~ "用可能となっている必要がある。"

#~ msgid ""
#~ "In Linux kernels up to 2.6.11, B<flock>()  does not lock files over NFS "
#~ "(i.e., the scope of locks was limited to the local system).  Instead, one "
#~ "could use B<fcntl>(2)  byte-range locking, which does work over NFS, "
#~ "given a sufficiently recent version of Linux and a server which supports "
#~ "locking.  Since Linux 2.6.12, NFS clients support B<flock>()  locks by "
#~ "emulating them as byte-range locks on the entire file.  This means that "
#~ "B<fcntl>(2)  and B<flock>()  locks I<do> interact with one another over "
#~ "NFS.  Since Linux 2.6.37, the kernel supports a compatibility mode that "
#~ "allows B<flock>()  locks (and also B<fcntl>(2)  byte region locks) to be "
#~ "treated as local; see the discussion of the I<local_lock> option in "
#~ "B<nfs>(5)."
#~ msgstr ""
#~ "バージョン 2.6.11 以前の Linux カーネルでは、 B<flock>() は NFS 上のファイ"
#~ "ルのロックを行わない (つまり、ロックの対象はローカルシステムに限定されてい"
#~ "た)。 その代わり、十分に最近のバージョンの Linux とロックをサポートする"
#~ "サーバーであれば、 B<fcntl>(2) のバイト範囲ロックを使うことができた。 "
#~ "B<fcntl>(2) のバイト範囲ロックは NFS 上で動作する。 Linux 2.6.12 以降で"
#~ "は、NFS クライアントは、 ファイル全体に対するバイト範囲ロックでエミュレー"
#~ "トすることで、 B<flock>() ロックをサポートしている。 これは、B<fcntl>(2) "
#~ "と B<flock>() ロックが NFS 上では互いに影響しあうことを意味する。 Linux "
#~ "2.6.37 以降では、 B<flock>() ロック (と B<fcntl>(2) のバイト範囲ロック) を"
#~ "ローカルシステムに対するものとして扱う互換性モードが、 カーネルでサポート"
#~ "されている。 B<nfs>(5) の I<local_lock> オプションの議論を参照。"

#~ msgid ""
#~ "B<fork>()  cannot allocate sufficient memory to copy the parent's page "
#~ "tables and allocate a task structure for the child."
#~ msgstr ""
#~ "親プロセスのページテーブルのコピーと 子プロセスのタスク構造に生成に必要な"
#~ "メモリーを B<fork>()  が割り当てることができなかった。"

#~ msgid ""
#~ "A system-imposed limit on the number of threads was encountered.  There "
#~ "are a number of limits that may trigger this error: the B<RLIMIT_NPROC> "
#~ "soft resource limit (set via B<setrlimit>(2)), which limits the number of "
#~ "processes and threads for a real user ID, was reached; the kernel's "
#~ "system-wide limit on the number of processes and threads, I</proc/sys/"
#~ "kernel/threads-max>, was reached (see B<proc>(5)); or the maximum number "
#~ "of PIDs, I</proc/sys/kernel/pid_max>, was reached (see B<proc>(5))."
#~ msgstr ""
#~ "システムで設定されたスレッド数の上限に達していた。 このエラーの原因となる"
#~ "上限値はいくつかある。 実ユーザー ID 当たりのプロセス数とスレッド数の上限"
#~ "である、ソフトリソース上限 B<RLIMIT_NPROC> に達していた (B<setrlimit>(2) "
#~ "で設定できる)。 カーネルのシステム全体のプロセスとスレッドの上限数である "
#~ "I</proc/sys/kernel/threads-max> が達していた (B<proc>(5) 参照)。 PID の最"
#~ "大値 I</proc/sys/kernel/pid_max> に達していた (B<proc>(5) 参照)。"

#~ msgid ""
#~ "returns the size of the pipe buffer, where I<fd> must refer to a pipe or "
#~ "FIFO and I<path> must refer to a FIFO.  The corresponding macro is "
#~ "B<_POSIX_PIPE_BUF>."
#~ msgstr ""
#~ "パイプ (pipe) バッファーのサイズを返す。このとき I<fd> はパイプか FIFO を"
#~ "参照していなければならず、 I<path> は FIFO を参照していなければならない。 "
#~ "対応するマクロは B<_POSIX_PIPE_BUF> である。"

#~ msgid ""
#~ "returns nonzero if the B<chown>(2)  call may not be used on this file.  "
#~ "If I<fd> or I<path> refer to a directory, then this applies to all files "
#~ "in that directory.  The corresponding macro is B<_POSIX_CHOWN_RESTRICTED>."
#~ msgstr ""
#~ "このファイルに対する B<chown>(2)  の呼び出しが許されていない場合には 0 以"
#~ "外の値を返す。 I<fd> または I<path> がディレクトリを参照している場合は、こ"
#~ "の制限はそのディレクトリのすべて のファイルに適用される。 対応するマクロ"
#~ "は B<_POSIX_CHOWN_RESTRICTED> である。"

#~ msgid ""
#~ "The limit is returned, if one exists.  If the system does not have a "
#~ "limit for the requested resource, -1 is returned, and I<errno> is "
#~ "unchanged.  If there is an error, -1 is returned, and I<errno> is set to "
#~ "reflect the nature of the error."
#~ msgstr ""
#~ "(存在していれば) 制限値が返される。要求されたリソースへのシステムの制 限が"
#~ "存在していなければ -1 が返され、 I<errno> は変更されない。エラーが起こった"
#~ "場合には -1 が返され、 I<errno> がエラーに対応した値に設定される。"

#~ msgid "An error occurred during synchronization."
#~ msgstr "同期操作の間にエラーが発生した。"

#~ msgid ""
#~ "B<get_thread_area>()  returns an entry in the current thread's thread-"
#~ "local storage (TLS) array.  The index of the entry corresponds to the "
#~ "value of I<u_info-E<gt>entry_number>, passed in by the user.  If the "
#~ "value is in bounds, B<get_thread_area>()  copies the corresponding TLS "
#~ "entry into the area pointed to by I<u_info>."
#~ msgstr ""
#~ "B<get_thread_area>()  は、カレントスレッドのスレッド局所記憶 (thread-"
#~ "local storage; TLS) 配列の中のエントリーを返す。 エントリーのインデックス"
#~ "は、ユーザーから引数として渡される I<u_info-E<gt>entry_number> の値に対"
#~ "応している。 値が範囲内にある場合、 B<get_thread_info>()  は対応する TLS "
#~ "エントリーを I<u_info> で指された領域にコピーする。"

#~ msgid ""
#~ "B<get_thread_area>()  returns 0 on success.  Otherwise, it returns -1 and "
#~ "sets I<errno> appropriately."
#~ msgstr ""
#~ "成功した場合、 B<get_thread_area>()  は 0 を返す。 そうでない場合、 -1 を"
#~ "返し、 I<errno> に適切な値をセットする。"

#~ msgid ""
#~ "the caller is unprivileged (Linux: does not have the B<CAP_SYS_ADMIN> "
#~ "capability)."
#~ msgstr ""
#~ "B<setdomainname>()  において、呼び出した人に特権がない (Linux では "
#~ "B<CAP_SYS_ADMIN> ケーパビリティ (capability) がない)。"

#~ msgid ""
#~ "The calling process already has the maximum allowed number of open files."
#~ msgstr ""
#~ "呼び出し元プロセスがオープンしているファイル数がすでにプロセスあたりの 上"
#~ "限に達している。"

#~ msgid "The system already has the maximum allowed number of open files."
#~ msgstr "システム全体でオープンしているファイル数がすでに上限に達している。"

#~ msgid ""
#~ "The B<cuserid>()  function is thread-safe with exceptions.  It is not "
#~ "thread-safe if called with a NULL parameter."
#~ msgstr ""
#~ "B<cuserid>() 関数は、例外付きのスレッドセーフである。 パラメーター NULL で"
#~ "呼び出した場合はスレッドセーフではない。"

#~ msgid ""
#~ "If B<getopt>()  does not recognize an option character, it prints an "
#~ "error message to I<stderr>, stores the character in I<optopt>, and "
#~ "returns \\(aq?\\(aq.  The calling program may prevent the error message "
#~ "by setting I<opterr> to 0."
#~ msgstr ""
#~ "認識できないオプション文字があると、 B<getopt>()  はエラーメッセージを標準"
#~ "エラー出力 I<stderr> に表示し、 その文字を I<optopt> に保存して \\(aq?"
#~ "\\(aq を返す。 呼び出したプログラムで I<opterr> を 0 にしておけば、 エラー"
#~ "メッセージの表示を抑制できる。"

#~ msgid ""
#~ "If B<getopt>()  finds an option character in I<argv> that was not "
#~ "included in I<optstring>, or if it detects a missing option argument, it "
#~ "returns \\(aq?\\(aq and sets the external variable I<optopt> to the "
#~ "actual option character.  If the first character (following any optional "
#~ "\\(aq+\\(aq or \\(aq-\\(aq described above)  of I<optstring> is a colon "
#~ "(\\(aq:\\(aq), then B<getopt>()  returns \\(aq:\\(aq instead of \\(aq?"
#~ "\\(aq to indicate a missing option argument.  If an error was detected, "
#~ "and the first character of I<optstring> is not a colon, and the external "
#~ "variable I<opterr> is nonzero (which is the default), B<getopt>()  prints "
#~ "an error message."
#~ msgstr ""
#~ "B<getopt>()  は I<argv> の中に I<optstring> にないオプション文字を見つけた"
#~ "場合、 またはオプション引数が足りないことが分かった場合、 \\&\\(aq?"
#~ "\\(aq を返して外部変数 I<optopt> をそのオプション文字に設定する。 "
#~ "I<optstring> の (上で説明したオプションで指定できる \\&\\(aq+\\(aq または "
#~ "\\(aq-\\(aq 後に続く) 最初の文字が コロン (\\(aq:\\(aq) のとき、 "
#~ "B<getopt>()  はオプション引数が足りない場合に \\(aq?\\(aq ではなく "
#~ "\\(aq:\\(aq を返す。 エラーを見つけた場合で、かつ I<optstring> の最初の文"
#~ "字がコロンでなく、 かつ外部変数 I<opterr> が 0 でない場合 (これがデフォル"
#~ "ト)、 B<getopt>()  はエラーメッセージを表示する。"

#~ msgid ""
#~ "The POSIX.2 specification of B<getopt>()  has a technical error described "
#~ "in POSIX.2 Interpretation 150.  The GNU implementation (and probably all "
#~ "other implementations) implements the correct behavior rather than that "
#~ "specified."
#~ msgstr ""
#~ "POSIX.2 における B<getopt>()  の仕様には技術的な問題があり、 その内容は "
#~ "POSIX.2 Interpretation 150 に記されている。 GNU による実装では (おそらく他"
#~ "のすべての実装でも)、 仕様と異なる正しい動作をするように実装されている。"

#~ msgid ""
#~ "The B<gettid>()  system call first appeared on Linux in kernel 2.4.11."
#~ msgstr ""
#~ "B<gettid>()  システムコールは、カーネル 2.4.11 の Linux で初めて登場した。"

#~ msgid ""
#~ "Glibc does not provide a wrapper for this system call; call it using "
#~ "B<syscall>(2)."
#~ msgstr ""
#~ "glibc はこのシステムコールに対するラッパー関数を提供していない。 このシス"
#~ "テムコールは呼び出すには B<syscall>(2)  を使うこと。"

#~ msgid ""
#~ "This function is documented but not implemented yet in glibc, as at "
#~ "version 2.9."
#~ msgstr ""
#~ "バージョン 2.9 時点の glibc では、 この関数についての記載はあるが、まだ実"
#~ "装されていない。"

#~ msgid "ioctl - control device"
#~ msgstr "ioctl - デバイスを制御する"

#~ msgid ""
#~ "The B<ioctl>()  function manipulates the underlying device parameters of "
#~ "special files.  In particular, many operating characteristics of "
#~ "character special files (e.g., terminals) may be controlled with "
#~ "B<ioctl>()  requests.  The argument I<fd> must be an open file descriptor."
#~ msgstr ""
#~ "B<ioctl>()  関数はスペシャルファイルを構成するデバイスのパラメーターを 操"
#~ "作する。特に、キャラクター型のスペシャルファイル (例えば端末 (terminal))  "
#~ "の多くの動作特性を B<ioctl>()  リクエストによって制御することができる。引"
#~ "き数 I<fd> はオープンされたファイルディスクリプターでなければならない。"

#~ msgid ""
#~ "The second argument is a device-dependent request code.  The third "
#~ "argument is an untyped pointer to memory.  It's traditionally B<char "
#~ "*>I<argp> (from the days before B<void *> was valid C), and will be so "
#~ "named for this discussion."
#~ msgstr ""
#~ "2 番目の引数は、デバイス依存のリクエストコードである。 3 番目の引数"
#~ "は、メモリーへの型を指定しないポインターである。 この引数は伝統的に (C "
#~ "で B<void *> という書き方が有効になる前から)  B<char *>I<argp> と表記され"
#~ "ている。したがって、この文章でもそう名付けることとする。"

#~ msgid ""
#~ "An B<ioctl>()  I<request> has encoded in it whether the argument is an "
#~ "I<in> parameter or I<out> parameter, and the size of the argument I<argp> "
#~ "in bytes.  Macros and defines used in specifying an B<ioctl>()  "
#~ "I<request> are located in the file I<E<lt>sys/ioctl.hE<gt>>."
#~ msgstr ""
#~ "B<ioctl>()  の I<request> には、 その引数が I<入力> パラメーターと I<出"
#~ "力> パラメーターのどちらであるかの区別や、 I<argp> 引数のバイト単位のサ"
#~ "イズ、といった情報がエンコードされている。 B<ioctl>()  の I<request> を指"
#~ "定するためのマクロ (macro) と定義は I<E<lt>sys/ioctl.hE<gt>> ファイルにあ"
#~ "る。"

#~ msgid ""
#~ "Usually, on success zero is returned.  A few B<ioctl>()  requests use the "
#~ "return value as an output parameter and return a nonnegative value on "
#~ "success.  On error, -1 is returned, and I<errno> is set appropriately."
#~ msgstr ""
#~ "たいていの場合、成功するとゼロが返される。 ただし、 B<ioctl>()  リクエスト"
#~ "の中にはパラメーターの出力に返り値を使用しているものが若干あり、 その場合"
#~ "は、成功したときに非負の値が返される。 エラーの場合は -1 が返され、 "
#~ "I<errno> が適切に設定される。"

#~ msgid "I<fd> is not a valid descriptor."
#~ msgstr "I<fd> が無効なディスクリプターである。"

#~ msgid "I<argp> references an inaccessible memory area."
#~ msgstr "I<argp> がアクセス不可能なメモリーを参照している。"

#~ msgid "I<request> or I<argp> is not valid."
#~ msgstr "I<request> または I<argp> が不正である。"

#~ msgid "I<fd> is not associated with a character special device."
#~ msgstr "I<fd> がキャラクター型のスペシャルデバイスを参照していない。"

#~ msgid ""
#~ "The specified request does not apply to the kind of object that the "
#~ "descriptor I<fd> references."
#~ msgstr ""
#~ "指定されたリクエストはディスクリプター I<fd> が参照する種類のオブジェクト"
#~ "には適用することができない。"

#~ msgid ""
#~ "No single standard.  Arguments, returns, and semantics of B<ioctl>()  "
#~ "vary according to the device driver in question (the call is used as a "
#~ "catch-all for operations that don't cleanly fit the UNIX stream I/O "
#~ "model).  See B<ioctl_list>(2)  for a list of many of the known "
#~ "B<ioctl>()  calls.  The B<ioctl>()  function call appeared in Version 7 "
#~ "AT&T UNIX."
#~ msgstr ""
#~ "どれか一つの標準に対応しているわけではない。 B<ioctl>()  の引数、返り"
#~ "値、解釈は、処理対象のデバイスドライバごとに 異なる (この関数は UNIX の ス"
#~ "トリーム I/O モデル に きちんと適合していない操作のための便利屋として使用"
#~ "される)。 よく知られている B<ioctl>()  のリストについては "
#~ "B<ioctl_list>(2)  を参照すること。 B<ioctl>()  関数コールは Version 7 "
#~ "AT&T UNIX で登場した。"

#~ msgid ""
#~ "In order to use this call, one needs an open file descriptor.  Often the "
#~ "B<open>(2)  call has unwanted side effects, that can be avoided under "
#~ "Linux by giving it the B<O_NONBLOCK> flag."
#~ msgstr ""
#~ "このシステムコールを使うには、オープンされたファイルディスクリプターが 必"
#~ "要である。 B<open>(2)  コールはしばしば望んでいない副作用を伴うことがある"
#~ "が、Linux では B<open>(2)  に B<O_NONBLOCK> フラグをつけることでこの副作用"
#~ "を避けることができる。"

#~ msgid "ioctl_list - list of ioctl calls in Linux/i386 kernel"
#~ msgstr "ioctl_list - Linux/i386 カーネルの ioctl のリスト"

#~ msgid ""
#~ "This is Ioctl List 1.3.27, a list of ioctl calls in Linux/i386 kernel "
#~ "1.3.27.  It contains 421 ioctls from I<E<lt>/usr/include/{asm,linux}/*."
#~ "hE<gt>>.  For each ioctl, its numerical value, its name, and its argument "
#~ "type are given."
#~ msgstr ""
#~ "この文章は ioctl リスト 1.3.27、つまり Linux/i386 カーネル 1.3.27 に おけ"
#~ "る ioctl コールの一覧です。このリストは I<E<lt>/usr/include/{asm,linux}/*."
#~ "hE<gt>> にある 421 の ioctl を含んでいます。全ての ioctl に対して、数値、"
#~ "名称、 引数の型を列挙してあります。"

#~ msgid ""
#~ "An argument type of I<const struct foo\\ *> means the argument is input "
#~ "to the kernel.  I<struct foo\\ *> means the kernel outputs the argument.  "
#~ "If the kernel uses the argument for both input and output, this is marked "
#~ "with I<//\\ I-O>."
#~ msgstr ""
#~ "引数型 I<const struct foo\\ *> は、その引数がカーネルへの入力である事"
#~ "を意味します。また、 I<struct foo\\ *> は、その引数がカーネルからの出力"
#~ "である事を意味します。 カーネルがその引数を入力と出力の両方に使用する場"
#~ "合は、 I<//\\ I-O> マークを付けてあります。"

#~ msgid ""
#~ "Some ioctls take more arguments or return more values than a single "
#~ "structure.  These are marked I<//\\ MORE> and documented further in a "
#~ "separate section."
#~ msgstr ""
#~ "いくつかの ioctl は複数の構造体の引数を必要としたり、値を返したり しま"
#~ "す。これらには I<//\\ MORE> マークを付けて、 さらに分離したセクションで説"
#~ "明してあります。"

#~ msgid "This list is very incomplete."
#~ msgstr "このリストは不完全です。"

#~ msgid "ioctl structure"
#~ msgstr "ioctl の構造"

#~ msgid ""
#~ "Ioctl command values are 32-bit constants.  In principle these constants "
#~ "are completely arbitrary, but people have tried to build some structure "
#~ "into them."
#~ msgstr ""
#~ "ioctl コマンドの値は 32 ビットの定数です。 原則として、これらの定数は全く"
#~ "任意のものですが、 設計者は何らかの構造をこれらの定数に組み込もうとしてい"
#~ "ます。"

#~ msgid ""
#~ "The old Linux situation was that of mostly 16-bit constants, where the "
#~ "last byte is a serial number, and the preceding byte(s) give a type "
#~ "indicating the driver.  Sometimes the major number was used: 0x03 for the "
#~ "B<HDIO_*> ioctls, 0x06 for the B<LP*> ioctls.  And sometimes one or more "
#~ "ASCII letters were used.  For example, B<TCGETS> has value 0x00005401, "
#~ "with 0x54 = \\(aqT\\(aq indicating the terminal driver, and "
#~ "B<CYGETTIMEOUT> has value 0x00435906, with 0x43 0x59 = \\(aqC\\(aq \\(aqY"
#~ "\\(aq indicating the cyclades driver."
#~ msgstr ""
#~ "昔の Linux では、大部分は 16 ビットの定数であり、 下位バイトはシリアル番号"
#~ "で、上位バイトはドライバのタイプを表していました。 メジャー番号が使われる"
#~ "こともありました: 0x03 が B<HDIO_*> ioctl, 0x06 が B<LP*> ioctl などで"
#~ "す。 1 文字以上の ASCII 文字列が使われることもありました。 たとえば "
#~ "B<TCGETS> の値は 0x00005401 であり、 0x54 = \\(aqT\\(aq でターミナルドライ"
#~ "バを表します。 B<CYGETTIMEOUT> の値は 0x00435906 であり、 0x43 0x59 = "
#~ "\\(aqC\\(aq \\(aqY\\(aq で cyclades ドライバを表します。"

#~ msgid ""
#~ "Later (0.98p5) some more information was built into the number.  One has "
#~ "2 direction bits (00: none, 01: write, 10: read, 11: read/write)  "
#~ "followed by 14 size bits (giving the size of the argument), followed by "
#~ "an 8-bit type (collecting the ioctls in groups for a common purpose or a "
#~ "common driver), and an 8-bit serial number."
#~ msgstr ""
#~ "後の時代 (0.98p5) になると、 より多くの情報が数値に組み込まれるようになり"
#~ "ました。 1 つの数値は、読み書きの方向を表す 2 ビット (00: 読み書きなし, "
#~ "01: 書き込み, 10: 読み込み, 11: 読み込み/書き込み)、 (引数のサイズを表"
#~ "す) 14 ビット、 (共通の目的または共通のドライバで ioctl をグループにするた"
#~ "めの)  8 ビットのタイプ、8 ビットのシリアル番号から構成されます。"

#~ msgid ""
#~ "The macros describing this structure live in I<E<lt>asm/ioctl.hE<gt>> and "
#~ "are B<_IO(type,nr)> and B<{_IOR,_IOW,_IOWR}(type,nr,size)>.  They use "
#~ "I<sizeof(size)> so that size is a misnomer here: this third argument is a "
#~ "data type."
#~ msgstr ""
#~ "この構造を記述するマクロは I<E<lt>asm/ioctl.hE<gt>> にあり、 B<_IO(type,"
#~ "nr)> と B<{_IOR,_IOW,_IOWR}(type,nr,size)> です。 これらのマクロは "
#~ "I<sizeof(size)> を使うので、 ここで size という名前にしているのは間違って"
#~ "います: この 3 つ目の引数はデータタイプです。"

#~ msgid ""
#~ "Note that the size bits are very unreliable: in lots of cases they are "
#~ "wrong, either because of buggy macros using I<sizeof(sizeof(struct))>, or "
#~ "because of legacy values."
#~ msgstr ""
#~ "size ビットは全く当てにならない点に注意して下さい: 多くの場合、間違ってい"
#~ "ます。 これは I<sizeof(sizeof(struct))> を使ったバグを含んだマクロや、過去"
#~ "から受け継いだ値が原因です。"

#~ msgid ""
#~ "Thus, it seems that the new structure only gave disadvantages: it does "
#~ "not help in checking, but it causes varying values for the various "
#~ "architectures."
#~ msgstr ""
#~ "したがって、新しい構造は不都合な点しかないように思われます: この構造は"
#~ "チェックの手助けにはならず、 様々なアーキテクチャーによって値を変化させて"
#~ "しまいます。"

#~ msgid ""
#~ "Decent ioctls return 0 on success and -1 on error, while any output value "
#~ "is stored via the argument.  However, quite a few ioctls in fact return "
#~ "an output value.  This is not yet indicated below."
#~ msgstr ""
#~ "きちんとした ioctl は、成功した場合は 0 を返し、 エラーの場合は -1 を返し"
#~ "ます。 また出力値は引数に格納します。 しかし実際は、かなり多くの ioctl "
#~ "が出力値を返します。 これは今のところ以下では示されていません。"

#~ msgid ""
#~ "// More arguments.  Some ioctl's take a pointer to a structure which "
#~ "contains additional pointers.  These are documented here in alphabetical "
#~ "order."
#~ msgstr ""
#~ "// More arguments.  いくつかの ioctl は追加のポインターを含む構造体へのポ"
#~ "インターを使用します。 ここでこれらをアルファベット順に説明します。"

#~ msgid ""
#~ "B<CDROMREADAUDIO> takes an input pointer I<const struct cdrom_read_audio"
#~ "\\ *>.  The I<buf> field points to an output buffer of length I<nframes\\ "
#~ "* CD_FRAMESIZE_RAW>."
#~ msgstr ""
#~ "B<CDROMREADAUDIO> は入力ポインター I<const struct cdrom_read_audio\\ *> を"
#~ "使用します。 I<buf> フィールドは大きさ I<nframes\\ * CD_FRAMESIZE_RAW> の"
#~ "出力バッファーへのポインターです。"

#~ msgid ""
#~ "B<CDROMREADCOOKED>, B<CDROMREADMODE1>, B<CDROMREADMODE2>, and "
#~ "B<CDROMREADRAW> take an input pointer I<const struct cdrom_msf\\ *>.  "
#~ "They use the same pointer as an output pointer to I<char []>.  The length "
#~ "varies by request.  For B<CDROMREADMODE1>, most drivers use CD_FRAMESIZE, "
#~ "but the Optics Storage driver uses OPT_BLOCKSIZE instead (both have the "
#~ "numerical value 2048)."
#~ msgstr ""
#~ "B<CDROMREADCOOKED>, B<CDROMREADMODE1>, B<CDROMREADMODE2>, B<CDROMREADRAW> "
#~ "は入力ポインター I<const struct cdrom_msf\\ *> を使用します。これらは同じ"
#~ "ポインターを I<char []> への出力ポインターとして使用します。 長さは要求に"
#~ "よって変化します。 B<CDROMREADMODE1> には、多くのデバイスが CD_FRAMESIZE "
#~ "を使用しますが、光学記憶装置 (光ディスク) のドライバは OPT_BLOCKSIZE を使"
#~ "用します (どちらも同じ値で 2048 です)。"

#~ msgid ""
#~ "B<EQL_ENSLAVE>, B<EQL_EMANCIPATE>, B<EQL_GETSLAVECFG>, "
#~ "B<EQL_SETSLAVECFG>, B<EQL_GETMASTERCFG>, and B<EQL_SETMASTERCFG> take a "
#~ "I<struct ifreq\\ *>.  The I<ifr_data> field is a pointer to another "
#~ "structure as follows:"
#~ msgstr ""
#~ "B<EQL_ENSLAVE>, B<EQL_EMANCIPATE>, B<EQL_GETSLAVECFG>, "
#~ "B<EQL_SETSLAVECFG>, B<EQL_GETMASTERCFG>, B<EQL_SETMASTERCFG> は I<struct "
#~ "ifreq\\ *> を使用します。 I<ifr_data> フィールドは以下に示す別の構造体への"
#~ "ポインターです:"

#~ msgid ""
#~ "B<FDRAWCMD> takes a I<struct floppy raw_cmd\\ *>.  If I<flags & "
#~ "FD_RAW_WRITE> is nonzero, then I<data> points to an input buffer of "
#~ "length I<length>.  If I<flags & FD_RAW_READ> is nonzero, then I<data> "
#~ "points to an output buffer of length I<length>."
#~ msgstr ""
#~ "B<FDRAWCMD> は I<struct floppy raw_cmd\\ *> を使用します。 I<flags & "
#~ "FD_RAW_WRITE> がゼロ以外の場合、 I<data> は大きさ I<length> の入力バッ"
#~ "ファーへのポインターになります。 I<flags & FD_RAW_READ> がゼロ以外の場"
#~ "合、 I<data> は大きさ I<length> の出力バッファーへのポインターになります。"

#~ msgid ""
#~ "B<GIO_FONTX> and B<PIO_FONTX> take a I<struct console_font_desc\\ *> or a "
#~ "I<const struct console_font_desc\\ *>, respectively.  I<chardata> points "
#~ "to a buffer of I<char [charcount]>.  This is an output buffer for "
#~ "B<GIO_FONTX> and an input buffer for B<PIO_FONTX>."
#~ msgstr ""
#~ "B<GIO_FONTX>, B<PIO_FONTX> はそれぞれ I<struct console_font_desc\\ *> と "
#~ "I<const struct console_font_desc\\ *> を使用します。 I<chardata> は "
#~ "I<char [charcount]> バッファーへのポインターです。 これは B<GIO_FONTX> の"
#~ "出力バッファーと B<PIO_FONTX> の入力バッファーです。"

#~ msgid ""
#~ "B<GIO_UNIMAP> and B<PIO_UNIMAP> take a I<struct unimapdesc\\ *> or a "
#~ "I<const struct unimapdesc\\ *>, respectively.  I<entries> points to a "
#~ "buffer of I<struct unipair [entry_ct]>.  This is an output buffer for "
#~ "B<GIO_UNIMAP> and an input buffer for B<PIO_UNIMAP>."
#~ msgstr ""
#~ "B<GIO_UNIMAP>, B<PIO_UNIMAP> はそれぞれ I<struct unimapdesc\\ *> と "
#~ "I<const struct unimapdesc\\ *> を使用します。 I<entries> は I<struct "
#~ "unipair [entry_ct]> バッファーへのポインターです。 これは B<GIO_UNIMAP> の"
#~ "出力バッファーと B<PIO_UNIMAP> の入力バッファーです。"

#~ msgid ""
#~ "KDADDIO, KDDELIO, KDDISABIO, and KDENABIO enable or disable access to I/O "
#~ "ports.  They are essentially alternate interfaces to 'ioperm'."
#~ msgstr ""
#~ "KDADDIO, KDDELIO, KDDISABIO, KDENABIO は I/O ポートへのアクセスを 可能/不"
#~ "可能にします。これらは本質的に、'ioperm' への別の インターフェースです。"

#~ msgid ""
#~ "B<KDMAPDISP> and B<KDUNMAPDISP> enable or disable memory mappings or I/O "
#~ "port access.  They are not implemented in the kernel."
#~ msgstr ""
#~ "B<KDMAPDISP>, B<KDUNMAPDISP> はメモリーマッピングや I/O ポートへのアクセス"
#~ "を可能/不可能にします。 これらはカーネルに実装されていません。"

#~ msgid ""
#~ "B<SCSI_IOCTL_PROBE_HOST> takes an input pointer I<const int\\ *>, which "
#~ "is a length.  It uses the same pointer as an output pointer to a I<char "
#~ "[]> buffer of this length."
#~ msgstr ""
#~ "B<SCSI_IOCTL_PROBE_HOST> は入力ポインター I<const int\\ *> を大きさとして"
#~ "使用します。これは同じ大きさの I<char []> バッファー への出力ポインターと"
#~ "しても使用します。"

#~ msgid ""
#~ "B<SIOCADDRT> and B<SIOCDELRT> take an input pointer whose type depends on "
#~ "the protocol:"
#~ msgstr ""
#~ "B<SIOCADDRT>, B<SIOCDELRT> は型が以下のプロトコルに依存する入力ポインター"
#~ "を使用します:"

#~ msgid ""
#~ "B<SIOCGIFCONF> takes a I<struct ifconf\\ *>.  The I<ifc_buf> field points "
#~ "to a buffer of length I<ifc_len> bytes, into which the kernel writes a "
#~ "list of type I<struct ifreq []>."
#~ msgstr ""
#~ "B<SIOCGIFCONF> は I<struct ifconf\\ *> を使用します。この I<ifc_buf> "
#~ "フィールドは長さ I<ifc_len> バイトのバッファーへのポインターです。 これに"
#~ "カーネルが I<struct ifreq []> 型のリストへ書き込みます。"

#~ msgid ""
#~ "B<SIOCSIFHWADDR> takes an input pointer whose type depends on the "
#~ "protocol:"
#~ msgstr ""
#~ "B<SIOCSIFHWADDR> は型が以下のプロトコルに依存する入力ポインターを使用しま"
#~ "す:"

#~ msgid ""
#~ "B<TIOCLINUX> takes a I<const char\\ *>.  It uses this to distinguish "
#~ "several independent subcases.  In the table below, I<N + foo> means "
#~ "I<foo> after an N-byte pad.  I<struct selection> is implicitly defined in "
#~ "I<drivers/char/selection.c>"
#~ msgstr ""
#~ "B<TIOCLINUX> は I<const char\\ *> を使用します。このポインターをいくつか"
#~ "の 独立したサブクラスを識別する為に使用します。以下のテーブルの中で、 I<N "
#~ "+ foo> は N バイトの詰めものの後にある I<foo> を意味します。 I<struct "
#~ "selection> は暗黙的に I<drivers/char/selection.c> の中で定義されています。"

#~ msgid ""
#~ "This list does not include ioctls in the range B<SIOCDEVPRIVATE> and "
#~ "B<SIOCPROTOPRIVATE>."
#~ msgstr ""
#~ "このリストは B<SIOCDEVPRIVATE> から B<SIOCPROTOPRIVATE> の範囲の ioctl を"
#~ "含んでいません。"

#~ msgid "The B<lockf>()  function is thread-safe."
#~ msgstr "B<lockf>() 関数はスレッドセーフである。"

#~ msgid ""
#~ "Under Linux, apart from the permission bits, only the B<S_ISVTX> mode bit "
#~ "is honored.  That is, under Linux the created directory actually gets "
#~ "mode (I<mode> & ~I<umask> & 01777).  See also B<stat>(2)."
#~ msgstr ""
#~ "Linux では、許可ビット以外で意味を持つのは、 B<S_ISVTX> モードビットだけで"
#~ "ある。 つまり、Linux では作成されたディレクトリは実際には (I<mode> & "
#~ "~I<umask> & 01777)  のモードを持つことになる。 B<stat>(2)  を参照のこと。"

#~ msgid ""
#~ "B<nice>()  adds I<inc> to the nice value for the calling process.  (A "
#~ "higher nice value means a low priority.)  Only the super\\%user may "
#~ "specify a negative increment, or priority increase.  The range for nice "
#~ "values is described in B<getpriority>(2)."
#~ msgstr ""
#~ "B<nice>()  は I<inc> の値を B<nice> を呼んだプロセスの nice 値に加える "
#~ "(nice 値が大きい数値ほど低い優先度を表す)。 負の数を指定する、つまり、以前"
#~ "よりも優先度を上げるという指定ができるのは スーパーユーザーだけである。 "
#~ "nice 値の範囲については B<getpriority>(2)  で説明されている。"

#~ msgid ""
#~ "Since glibc 2.2.4, B<nice>()  is implemented as a library function that "
#~ "calls B<getpriority>(2)  to obtain the new nice value to be returned to "
#~ "the caller.  With this implementation, a successful call can legitimately "
#~ "return -1.  To reliably detect an error, set I<errno> to 0 before the "
#~ "call, and check its value when B<nice>()  returns -1."
#~ msgstr ""
#~ "glibc 2.2.4 以降では、 B<nice>()  は B<getpriority>(2)  を呼び出すライブラ"
#~ "リ関数として実装されており、 呼び出し元に返す新しい nice 値を "
#~ "B<getpriority>(2)  を呼び出して取得するようになっている。 この実装では、正"
#~ "常な動作でも -1 が返される可能性がある。 確実にエラーを検出するためには、 "
#~ "呼び出しの前に I<errno> に 0 を設定し、 B<nice>()  が -1 を返したときに "
#~ "errno をチェックすると良い。"

#~ msgid ""
#~ "On success, the number of bytes read or written is returned (zero "
#~ "indicates that nothing was written, in the case of B<pwrite>(), or end of "
#~ "file, in the case of B<pread>()), or -1 on error, in which case I<errno> "
#~ "is set to indicate the error."
#~ msgstr ""
#~ "成功した場合、読み書きを行ったバイト数が返される (ゼロは、 B<pwrite>()  の"
#~ "場合には何も書かれなかったことを意味し、 B<pread>()  の場合にはファイル の"
#~ "末尾に達したことを意味する)。 エラーの場合は -1 が返され、 I<errno> がその"
#~ "エラーを示すように設定される。"

#~ msgid "set_thread_area - set a thread local storage (TLS) area"
#~ msgstr "set_thread_area - スレッド局所記憶 (TLS) 領域を設定する"

#~ msgid "A version of B<set_thread_area>()  first appeared in Linux 2.5.29."
#~ msgstr "B<set_thread_area>()  は Linux 2.5.29 で初めて登場した。"

#~ msgid ""
#~ "B<set_thread_area>()  is Linux-specific and should not be used in "
#~ "programs that are intended to be portable."
#~ msgstr ""
#~ "B<set_thread_area>()  は Linux 独自であり、移植を意図したプログラムでは使"
#~ "用すべきではない。"

#~ msgid ""
#~ "Glibc does not provide a wrapper for this system call, since it is "
#~ "generally intended only for use by threading libraries.  In the unlikely "
#~ "event that you want to call it directly, use B<syscall>(2)."
#~ msgstr ""
#~ "このシステムコールは通常はスレッドライブラリでのみ使用されることを目的とし"
#~ "て用意されているため、 glibc はこのシステムコールに対するラッパー関数を提"
#~ "供していない。おそらくないと思うが、このシステムコールを直接呼び出したい場"
#~ "合は B<syscall>(2) を使うこと。"

#~ msgid "NR is syscall #"
#~ msgstr "NR はシステムコール番号"

#~ msgid ""
#~ "On a few architectures, a register is used to indicate simple boolean "
#~ "failure of the system call: ia64 uses I<r10> for this purpose, and mips "
#~ "uses I<a3>."
#~ msgstr ""
#~ "少ないがいくつかのアーキテクチャーでは、 システムコールの失敗を示す単純な"
#~ "真偽値がレジスターを使って通知される。この用途に ia64 は I<r10> を使用"
#~ "し、 mips は I<a3> を使用する。"

#~ msgid ""
#~ "If I<name> is invalid, -1 is returned, and I<errno> is set to B<EINVAL>.  "
#~ "Otherwise, the value returned is the value of the system resource and "
#~ "I<errno> is not changed.  In the case of options, a positive value is "
#~ "returned if a queried option is available, and -1 if it is not.  In the "
#~ "case of limits, -1 means that there is no definite limit."
#~ msgstr ""
#~ "I<name> が不正な場合、-1 が返され、 I<errno> に B<EINVAL> が設定される。 "
#~ "それ以外の場合、システムリソースの値が返り値として返され、 I<errno> は変更"
#~ "されない。問い合わせがオプションに関するものであれば、 そのオプションが利"
#~ "用できる場合には正の値が返され、 利用できない場合には -1 が返される。 問い"
#~ "合わせが制限に関するものであれば、その制限が設定されていない場合に -1 が返"
#~ "される。"

#~ msgid "B<Do not use this system call!> See NOTES."
#~ msgstr "B<このシステムコールを使用しないこと!> 「注意」の節を参照。"

#~ msgid ""
#~ "Glibc does not provide a wrapper for this system call; call it using "
#~ "B<syscall>(2).  Or rather...  I<don't> call it: use of this system call "
#~ "has long been discouraged, and it is so unloved that B<it is likely to "
#~ "disappear in a future kernel version>.  Since Linux 2.6.24, uses of this "
#~ "system call result in warnings in the kernel log.  Remove it from your "
#~ "programs now; use the I</proc/sys> interface instead."
#~ msgstr ""
#~ "glibc はこのシステムコールに対するラッパー関数を提供していない。 "
#~ "B<syscall>(2) を使って呼び出すこと。というよりは・・・このシステムコールを"
#~ "呼び出さないこと。 長い間このシステムコールの使用は非推奨とされており、 "
#~ "「将来のバージョンのカーネルで削除されるようだ」と言われるほどである。 あ"
#~ "なたのプログラムにこのシステムコールがあれば、すぐにでも削除すること。 代"
#~ "わりに I</proc/sys> インターフェースを使用すること。"

#~ msgid "and the sizes were given in bytes."
#~ msgstr "ここでバイト単位で与えられる。"

#~ msgid ""
#~ "B<sysinfo>()  provides a simple way of getting overall system "
#~ "statistics.  This is more portable than reading I</dev/kmem>."
#~ msgstr ""
#~ "B<sysinfo>()  はシステム全体の統計を取得する簡単な方法を提供する。 これは "
#~ "I</dev/kmem> を読むよりも移植性の高い方法である。"

#~ msgid "pointer to I<struct\\ sysinfo> is invalid"
#~ msgstr "I<sysinfo 構造体> へのポインターが不正である。"

#~ msgid "The Linux kernel has a B<sysinfo>()  system call since 0.98.pl6."
#~ msgstr ""
#~ "0.98.pl6 以降の Linux カーネルに B<sysinfo>() システムコールは存在する。"

#~ msgid "The B<tcgetpgrp>()  and B<tcsetpgrp>()  functions are thread-safe."
#~ msgstr "関数 B<tcgetpgrp>() と B<tcsetpgrp>() はスレッドセーフである。"

#~ msgid "Interrupted by a signal."
#~ msgstr "シグナルによって割り込まれた。"

#~ msgid ""
#~ "Since libc 4.3.2, startup code tries to prefix these names with \"/usr/lib"
#~ "\", \"/lib\" and \"\" before giving up.  In libc 4.3.4 and later these "
#~ "names are looked for in the directories found in B<LD_LIBRARY_PATH>, and "
#~ "if not found there, prefixes \"/usr/lib\", \"/lib\" and \"/\" are tried."
#~ msgstr ""
#~ "libc 4.3.2 以降では、これらの名前の前に \"/usr/lib\", \"/lib\", \"\" を つ"
#~ "けて共有ライブラリを探すようになった。 libc 4.3.4 以降では、これらの名前の"
#~ "共有ライブラリをまず B<LD_LIBRARY_PATH> で指定されたディレクトリで探し、見"
#~ "つからなければ、 名前の前に \"/usr/lib\", \"/lib\", \"/\" をつけて探す。"

#~ msgid ""
#~ "From libc 4.4.4 on only the library \"/lib/ld.so\" is loaded, so that "
#~ "this dynamic library can load the remaining libraries needed (again using "
#~ "this call).  This is also the state of affairs in libc5."
#~ msgstr ""
#~ "libc 4.4.4 以降では、ライブラリ \"/lib/ld.so\" だけがロードされ、その後で "
#~ "この動的ライブラリが (このシステムコールをもう一度使って)  必要な残りのラ"
#~ "イブラリをロードできるようになっている。"

#~ msgid "glibc2 does not use this call."
#~ msgstr "glibc2 は、このシステムコールを使用しない。"
