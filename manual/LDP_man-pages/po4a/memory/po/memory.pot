# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-03-12 14:01+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man2/alloc_hugepages.2:25
#, no-wrap
msgid "ALLOC_HUGEPAGES"
msgstr ""

#. type: TH
#: build/C/man2/alloc_hugepages.2:25 build/C/man3/malloc_get_state.3:25 build/C/man3/malloc_usable_size.3:25 build/C/man2/mmap2.2:29 build/C/man3/posix_madvise.3:20 build/C/man2/remap_file_pages.2:28 build/C/man2/sync_file_range.2:30 build/C/man2/s390_pci_mmio_write.2:25
#, no-wrap
msgid "2017-09-15"
msgstr ""

#. type: TH
#: build/C/man2/alloc_hugepages.2:25 build/C/man2/cacheflush.2:25 build/C/man2/fallocate.2:11 build/C/man2/madvise.2:35 build/C/man3/mallinfo.3:25 build/C/man3/malloc_stats.3:25 build/C/man3/malloc_trim.3:25 build/C/man3/mallopt.3:25 build/C/man2/mlock.2:26 build/C/man2/mmap.2:40 build/C/man2/mmap2.2:29 build/C/man2/mprotect.2:33 build/C/man2/mremap.2:30 build/C/man2/msync.2:25 build/C/man2/posix_fadvise.2:29 build/C/man3/posix_madvise.3:20 build/C/man2/readahead.2:28 build/C/man2/remap_file_pages.2:28 build/C/man3/shm_open.3:25 build/C/man7/shm_overview.7:26 build/C/man2/shmctl.2:46 build/C/man2/shmget.2:38 build/C/man2/shmop.2:40 build/C/man2/subpage_prot.2:30 build/C/man2/sync_file_range.2:30 build/C/man2/memfd_create.2:21 build/C/man2/membarrier.2:25 build/C/man2/pkey_alloc.2:25 build/C/man7/pkeys.7:25
#, no-wrap
msgid "Linux"
msgstr ""

#. type: TH
#: build/C/man2/alloc_hugepages.2:25 build/C/man3/alloca.3:43 build/C/man2/cacheflush.2:25 build/C/man2/fallocate.2:11 build/C/man2/madvise.2:35 build/C/man3/mallinfo.3:25 build/C/man3/malloc_get_state.3:25 build/C/man3/malloc_hook.3:10 build/C/man3/malloc_info.3:25 build/C/man3/malloc_stats.3:25 build/C/man3/malloc_trim.3:25 build/C/man3/malloc_usable_size.3:25 build/C/man3/mallopt.3:25 build/C/man3/mcheck.3:25 build/C/man2/mlock.2:26 build/C/man2/mmap.2:40 build/C/man2/mmap2.2:29 build/C/man2/mprotect.2:33 build/C/man2/mremap.2:30 build/C/man2/msync.2:25 build/C/man3/mtrace.3:25 build/C/man2/posix_fadvise.2:29 build/C/man3/posix_fallocate.3:25 build/C/man3/posix_madvise.3:20 build/C/man3/posix_memalign.3:29 build/C/man2/readahead.2:28 build/C/man2/remap_file_pages.2:28 build/C/man3/shm_open.3:25 build/C/man7/shm_overview.7:26 build/C/man2/shmctl.2:46 build/C/man2/shmget.2:38 build/C/man2/shmop.2:40 build/C/man2/subpage_prot.2:30 build/C/man2/sync_file_range.2:30 build/C/man2/memfd_create.2:21 build/C/man2/s390_pci_mmio_write.2:25 build/C/man2/membarrier.2:25 build/C/man2/pkey_alloc.2:25 build/C/man7/pkeys.7:25
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr ""

#. type: SH
#: build/C/man2/alloc_hugepages.2:26 build/C/man3/alloca.3:44 build/C/man2/cacheflush.2:26 build/C/man2/fallocate.2:12 build/C/man2/madvise.2:36 build/C/man3/mallinfo.3:26 build/C/man3/malloc_get_state.3:26 build/C/man3/malloc_hook.3:11 build/C/man3/malloc_info.3:26 build/C/man3/malloc_stats.3:26 build/C/man3/malloc_trim.3:26 build/C/man3/malloc_usable_size.3:26 build/C/man3/mallopt.3:26 build/C/man3/mcheck.3:26 build/C/man2/mlock.2:27 build/C/man2/mmap.2:41 build/C/man2/mmap2.2:30 build/C/man2/mprotect.2:34 build/C/man2/mremap.2:31 build/C/man2/msync.2:26 build/C/man3/mtrace.3:26 build/C/man2/posix_fadvise.2:30 build/C/man3/posix_fallocate.3:26 build/C/man3/posix_madvise.3:21 build/C/man3/posix_memalign.3:30 build/C/man2/readahead.2:29 build/C/man2/remap_file_pages.2:29 build/C/man3/shm_open.3:26 build/C/man7/shm_overview.7:27 build/C/man2/shmctl.2:47 build/C/man2/shmget.2:39 build/C/man2/shmop.2:41 build/C/man2/subpage_prot.2:31 build/C/man2/sync_file_range.2:31 build/C/man2/memfd_create.2:22 build/C/man2/s390_pci_mmio_write.2:26 build/C/man2/membarrier.2:26 build/C/man2/pkey_alloc.2:26 build/C/man7/pkeys.7:26
#, no-wrap
msgid "NAME"
msgstr ""

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:28
msgid "alloc_hugepages, free_hugepages - allocate or free huge pages"
msgstr ""

#. type: SH
#: build/C/man2/alloc_hugepages.2:28 build/C/man3/alloca.3:46 build/C/man2/cacheflush.2:28 build/C/man2/fallocate.2:14 build/C/man2/madvise.2:38 build/C/man3/mallinfo.3:28 build/C/man3/malloc_get_state.3:28 build/C/man3/malloc_hook.3:15 build/C/man3/malloc_info.3:28 build/C/man3/malloc_stats.3:28 build/C/man3/malloc_trim.3:28 build/C/man3/malloc_usable_size.3:28 build/C/man3/mallopt.3:28 build/C/man3/mcheck.3:28 build/C/man2/mlock.2:29 build/C/man2/mmap.2:43 build/C/man2/mmap2.2:32 build/C/man2/mprotect.2:36 build/C/man2/mremap.2:33 build/C/man2/msync.2:28 build/C/man3/mtrace.3:28 build/C/man2/posix_fadvise.2:32 build/C/man3/posix_fallocate.3:28 build/C/man3/posix_madvise.3:23 build/C/man3/posix_memalign.3:32 build/C/man2/readahead.2:31 build/C/man2/remap_file_pages.2:31 build/C/man3/shm_open.3:28 build/C/man2/shmctl.2:49 build/C/man2/shmget.2:41 build/C/man2/shmop.2:43 build/C/man2/subpage_prot.2:33 build/C/man2/sync_file_range.2:33 build/C/man2/memfd_create.2:24 build/C/man2/s390_pci_mmio_write.2:29 build/C/man2/membarrier.2:28 build/C/man2/pkey_alloc.2:28
#, no-wrap
msgid "SYNOPSIS"
msgstr ""

#.  asmlinkage unsigned long sys_alloc_hugepages(int key, unsigned long addr,
#.  unsigned long len, int prot, int flag);
#. type: Plain text
#: build/C/man2/alloc_hugepages.2:34
#, no-wrap
msgid ""
"B<void *alloc_hugepages(int >I<key>B<, void *>I<addr>B<, size_t "
">I<len>B<,>\n"
"B<                      int >I<prot>B<, int >I<flag>B<);>\n"
msgstr ""

#.  asmlinkage int sys_free_hugepages(unsigned long addr);
#. type: Plain text
#: build/C/man2/alloc_hugepages.2:37
#, no-wrap
msgid "B<int free_hugepages(void *>I<addr>B<);>\n"
msgstr ""

#. type: SH
#: build/C/man2/alloc_hugepages.2:38 build/C/man3/alloca.3:50 build/C/man2/cacheflush.2:38 build/C/man2/fallocate.2:22 build/C/man2/madvise.2:59 build/C/man3/mallinfo.3:32 build/C/man3/malloc_get_state.3:36 build/C/man3/malloc_hook.3:33 build/C/man3/malloc_info.3:34 build/C/man3/malloc_stats.3:32 build/C/man3/malloc_trim.3:32 build/C/man3/malloc_usable_size.3:32 build/C/man3/mallopt.3:32 build/C/man3/mcheck.3:40 build/C/man2/mlock.2:40 build/C/man2/mmap.2:54 build/C/man2/mmap2.2:39 build/C/man2/mprotect.2:47 build/C/man2/mremap.2:41 build/C/man2/msync.2:32 build/C/man3/mtrace.3:34 build/C/man2/posix_fadvise.2:51 build/C/man3/posix_fallocate.3:46 build/C/man3/posix_madvise.3:42 build/C/man3/posix_memalign.3:83 build/C/man2/readahead.2:38 build/C/man2/remap_file_pages.2:39 build/C/man3/shm_open.3:40 build/C/man7/shm_overview.7:29 build/C/man2/shmctl.2:57 build/C/man2/shmget.2:49 build/C/man2/shmop.2:52 build/C/man2/subpage_prot.2:41 build/C/man2/sync_file_range.2:41 build/C/man2/memfd_create.2:31 build/C/man2/s390_pci_mmio_write.2:38 build/C/man2/membarrier.2:38 build/C/man2/pkey_alloc.2:36 build/C/man7/pkeys.7:28
#, no-wrap
msgid "DESCRIPTION"
msgstr ""

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:49
msgid ""
"The system calls B<alloc_hugepages>()  and B<free_hugepages>()  were "
"introduced in Linux 2.5.36 and removed again in 2.5.54.  They existed only "
"on i386 and ia64 (when built with B<CONFIG_HUGETLB_PAGE>).  In Linux 2.4.20, "
"the syscall numbers exist, but the calls fail with the error B<ENOSYS>."
msgstr ""

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:57
msgid ""
"On i386 the memory management hardware knows about ordinary pages (4\\ KiB)  "
"and huge pages (2 or 4\\ MiB).  Similarly ia64 knows about huge pages of "
"several sizes.  These system calls serve to map huge pages into the "
"process's memory or to free them again.  Huge pages are locked into memory, "
"and are not swapped."
msgstr ""

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:66
msgid ""
"The I<key> argument is an identifier.  When zero the pages are private, and "
"not inherited by children.  When positive the pages are shared with other "
"applications using the same I<key>, and inherited by child processes."
msgstr ""

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:81
msgid ""
"The I<addr> argument of B<free_hugepages>()  tells which page is being "
"freed: it was the return value of a call to B<alloc_hugepages>().  (The "
"memory is first actually freed when all users have released it.)  The "
"I<addr> argument of B<alloc_hugepages>()  is a hint, that the kernel may or "
"may not follow.  Addresses must be properly aligned."
msgstr ""

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:86
msgid ""
"The I<len> argument is the length of the required segment.  It must be a "
"multiple of the huge page size."
msgstr ""

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:94
msgid ""
"The I<prot> argument specifies the memory protection of the segment.  It is "
"one of B<PROT_READ>, B<PROT_WRITE>, B<PROT_EXEC>."
msgstr ""

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:109
msgid ""
"The I<flag> argument is ignored, unless I<key> is positive.  In that case, "
"if I<flag> is B<IPC_CREAT>, then a new huge page segment is created when "
"none with the given key existed.  If this flag is not set, then B<ENOENT> is "
"returned when no segment with the given key exists."
msgstr ""

#. type: SH
#: build/C/man2/alloc_hugepages.2:109 build/C/man3/alloca.3:60 build/C/man2/cacheflush.2:57 build/C/man2/fallocate.2:301 build/C/man2/madvise.2:455 build/C/man3/malloc_get_state.3:64 build/C/man3/malloc_info.3:48 build/C/man3/malloc_trim.3:52 build/C/man3/malloc_usable_size.3:40 build/C/man3/mallopt.3:436 build/C/man3/mcheck.3:129 build/C/man2/mlock.2:177 build/C/man2/mmap.2:490 build/C/man2/mmap2.2:54 build/C/man2/mprotect.2:139 build/C/man2/mremap.2:160 build/C/man2/msync.2:71 build/C/man2/posix_fadvise.2:127 build/C/man3/posix_fallocate.3:66 build/C/man3/posix_madvise.3:83 build/C/man3/posix_memalign.3:142 build/C/man2/readahead.2:66 build/C/man2/remap_file_pages.2:138 build/C/man3/shm_open.3:170 build/C/man2/shmctl.2:364 build/C/man2/shmget.2:215 build/C/man2/shmop.2:167 build/C/man2/subpage_prot.2:66 build/C/man2/sync_file_range.2:141 build/C/man2/memfd_create.2:158 build/C/man2/s390_pci_mmio_write.2:67 build/C/man2/membarrier.2:236 build/C/man2/pkey_alloc.2:70
#, no-wrap
msgid "RETURN VALUE"
msgstr ""

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:118
msgid ""
"On success, B<alloc_hugepages>()  returns the allocated virtual address, and "
"B<free_hugepages>()  returns zero.  On error, -1 is returned, and I<errno> "
"is set appropriately."
msgstr ""

#. type: SH
#: build/C/man2/alloc_hugepages.2:118 build/C/man2/cacheflush.2:63 build/C/man2/fallocate.2:308 build/C/man2/madvise.2:462 build/C/man3/malloc_info.3:55 build/C/man3/malloc_trim.3:57 build/C/man3/mallopt.3:441 build/C/man2/mlock.2:183 build/C/man2/mmap.2:509 build/C/man2/mmap2.2:61 build/C/man2/mprotect.2:148 build/C/man2/mremap.2:168 build/C/man2/msync.2:76 build/C/man2/posix_fadvise.2:130 build/C/man3/posix_fallocate.3:72 build/C/man3/posix_madvise.3:88 build/C/man3/posix_memalign.3:165 build/C/man2/readahead.2:72 build/C/man2/remap_file_pages.2:145 build/C/man3/shm_open.3:179 build/C/man2/shmctl.2:388 build/C/man2/shmget.2:220 build/C/man2/shmop.2:181 build/C/man2/subpage_prot.2:71 build/C/man2/sync_file_range.2:147 build/C/man2/memfd_create.2:165 build/C/man2/s390_pci_mmio_write.2:76 build/C/man2/membarrier.2:263 build/C/man2/pkey_alloc.2:80
#, no-wrap
msgid "ERRORS"
msgstr ""

#. type: TP
#: build/C/man2/alloc_hugepages.2:119 build/C/man2/fallocate.2:415 build/C/man2/membarrier.2:278
#, no-wrap
msgid "B<ENOSYS>"
msgstr ""

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:122
msgid "The system call is not supported on this kernel."
msgstr ""

#. type: SH
#: build/C/man2/alloc_hugepages.2:122
#, no-wrap
msgid "FILES"
msgstr ""

#. type: TP
#: build/C/man2/alloc_hugepages.2:123
#, no-wrap
msgid "I</proc/sys/vm/nr_hugepages>"
msgstr ""

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:127
msgid "Number of configured hugetlb pages.  This can be read and written."
msgstr ""

#. type: TP
#: build/C/man2/alloc_hugepages.2:127
#, no-wrap
msgid "I</proc/meminfo>"
msgstr ""

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:131
msgid ""
"Gives info on the number of configured hugetlb pages and on their size in "
"the three variables HugePages_Total, HugePages_Free, Hugepagesize."
msgstr ""

#. type: SH
#: build/C/man2/alloc_hugepages.2:131 build/C/man3/alloca.3:77 build/C/man2/cacheflush.2:80 build/C/man2/fallocate.2:475 build/C/man2/madvise.2:548 build/C/man3/mallinfo.3:148 build/C/man3/malloc_get_state.3:103 build/C/man3/malloc_hook.3:82 build/C/man3/malloc_info.3:76 build/C/man3/malloc_stats.3:67 build/C/man3/malloc_trim.3:74 build/C/man3/malloc_usable_size.3:60 build/C/man3/mallopt.3:449 build/C/man3/mcheck.3:166 build/C/man2/mlock.2:272 build/C/man2/mmap.2:656 build/C/man2/mmap2.2:77 build/C/man2/mprotect.2:215 build/C/man2/mremap.2:261 build/C/man2/msync.2:99 build/C/man3/mtrace.3:100 build/C/man2/posix_fadvise.2:162 build/C/man3/posix_fallocate.3:126 build/C/man3/posix_madvise.3:107 build/C/man3/posix_memalign.3:212 build/C/man2/readahead.2:88 build/C/man2/remap_file_pages.2:167 build/C/man3/shm_open.3:263 build/C/man2/shmctl.2:462 build/C/man2/shmget.2:280 build/C/man2/shmop.2:227 build/C/man2/subpage_prot.2:96 build/C/man2/sync_file_range.2:177 build/C/man2/memfd_create.2:204 build/C/man2/s390_pci_mmio_write.2:99 build/C/man2/membarrier.2:301 build/C/man2/pkey_alloc.2:109
#, no-wrap
msgid "CONFORMING TO"
msgstr ""

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:134
msgid ""
"These calls are specific to Linux on Intel processors, and should not be "
"used in programs intended to be portable."
msgstr ""

#. type: SH
#: build/C/man2/alloc_hugepages.2:134 build/C/man3/alloca.3:85 build/C/man2/cacheflush.2:93 build/C/man2/madvise.2:569 build/C/man3/malloc_get_state.3:105 build/C/man3/malloc_hook.3:84 build/C/man3/malloc_info.3:78 build/C/man3/malloc_stats.3:69 build/C/man3/malloc_trim.3:76 build/C/man3/malloc_usable_size.3:62 build/C/man3/mcheck.3:168 build/C/man2/mlock.2:302 build/C/man2/mmap.2:674 build/C/man2/mmap2.2:79 build/C/man2/mprotect.2:228 build/C/man2/mremap.2:267 build/C/man2/msync.2:123 build/C/man3/mtrace.3:102 build/C/man2/posix_fadvise.2:171 build/C/man3/posix_fallocate.3:151 build/C/man3/posix_madvise.3:109 build/C/man3/posix_memalign.3:252 build/C/man2/readahead.2:93 build/C/man2/remap_file_pages.2:171 build/C/man3/shm_open.3:273 build/C/man7/shm_overview.7:100 build/C/man2/shmctl.2:467 build/C/man2/shmget.2:288 build/C/man2/shmop.2:242 build/C/man2/subpage_prot.2:98 build/C/man2/sync_file_range.2:180 build/C/man2/memfd_create.2:208 build/C/man2/s390_pci_mmio_write.2:102 build/C/man2/membarrier.2:308 build/C/man2/pkey_alloc.2:115
#, no-wrap
msgid "NOTES"
msgstr ""

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:142
msgid ""
"These system calls are gone; they existed only in Linux 2.5.36 through to "
"2.5.54.  Now the hugetlbfs filesystem can be used instead.  Memory backed by "
"huge pages (if the CPU supports them) is obtained by using B<mmap>(2)  to "
"map files in this virtual filesystem."
msgstr ""

#. .PP
#.  requires CONFIG_HUGETLB_PAGE (under "Processor type and features")
#.  and CONFIG_HUGETLBFS (under "Filesystems").
#.  mount \-t hugetlbfs hugetlbfs /huge
#.  SHM_HUGETLB
#. type: Plain text
#: build/C/man2/alloc_hugepages.2:151
msgid ""
"The maximal number of huge pages can be specified using the B<hugepages=> "
"boot parameter."
msgstr ""

#. type: SH
#: build/C/man2/alloc_hugepages.2:151 build/C/man3/alloca.3:178 build/C/man2/cacheflush.2:161 build/C/man2/fallocate.2:483 build/C/man2/madvise.2:596 build/C/man3/mallinfo.3:324 build/C/man3/malloc_get_state.3:131 build/C/man3/malloc_hook.3:147 build/C/man3/malloc_info.3:272 build/C/man3/malloc_stats.3:79 build/C/man3/malloc_trim.3:104 build/C/man3/malloc_usable_size.3:76 build/C/man3/mallopt.3:627 build/C/man3/mcheck.3:229 build/C/man2/mlock.2:499 build/C/man2/mmap.2:1022 build/C/man2/mmap2.2:101 build/C/man2/mprotect.2:373 build/C/man2/mremap.2:369 build/C/man2/msync.2:154 build/C/man3/mtrace.3:192 build/C/man2/posix_fadvise.2:243 build/C/man3/posix_fallocate.3:193 build/C/man3/posix_madvise.3:129 build/C/man3/posix_memalign.3:308 build/C/man2/readahead.2:113 build/C/man2/remap_file_pages.2:191 build/C/man3/shm_open.3:517 build/C/man7/shm_overview.7:124 build/C/man2/shmctl.2:520 build/C/man2/shmget.2:426 build/C/man2/shmop.2:508 build/C/man2/subpage_prot.2:134 build/C/man2/sync_file_range.2:224 build/C/man2/memfd_create.2:552 build/C/man2/s390_pci_mmio_write.2:108 build/C/man2/membarrier.2:471 build/C/man2/pkey_alloc.2:140 build/C/man7/pkeys.7:297
#, no-wrap
msgid "COLOPHON"
msgstr ""

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:159 build/C/man3/alloca.3:186 build/C/man2/cacheflush.2:169 build/C/man2/fallocate.2:491 build/C/man2/madvise.2:604 build/C/man3/mallinfo.3:332 build/C/man3/malloc_get_state.3:139 build/C/man3/malloc_hook.3:155 build/C/man3/malloc_info.3:280 build/C/man3/malloc_stats.3:87 build/C/man3/malloc_trim.3:112 build/C/man3/malloc_usable_size.3:84 build/C/man3/mallopt.3:635 build/C/man3/mcheck.3:237 build/C/man2/mlock.2:507 build/C/man2/mmap.2:1030 build/C/man2/mmap2.2:109 build/C/man2/mprotect.2:381 build/C/man2/mremap.2:377 build/C/man2/msync.2:162 build/C/man3/mtrace.3:200 build/C/man2/posix_fadvise.2:251 build/C/man3/posix_fallocate.3:201 build/C/man3/posix_madvise.3:137 build/C/man3/posix_memalign.3:316 build/C/man2/readahead.2:121 build/C/man2/remap_file_pages.2:199 build/C/man3/shm_open.3:525 build/C/man7/shm_overview.7:132 build/C/man2/shmctl.2:528 build/C/man2/shmget.2:434 build/C/man2/shmop.2:516 build/C/man2/subpage_prot.2:142 build/C/man2/sync_file_range.2:232 build/C/man2/memfd_create.2:560 build/C/man2/s390_pci_mmio_write.2:116 build/C/man2/membarrier.2:479 build/C/man2/pkey_alloc.2:148 build/C/man7/pkeys.7:305
msgid ""
"This page is part of release 5.10 of the Linux I<man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at "
"\\%https://www.kernel.org/doc/man-pages/."
msgstr ""

#. type: TH
#: build/C/man3/alloca.3:43
#, no-wrap
msgid "ALLOCA"
msgstr ""

#. type: TH
#: build/C/man3/alloca.3:43 build/C/man2/posix_fadvise.2:29 build/C/man2/readahead.2:28
#, no-wrap
msgid "2019-03-06"
msgstr ""

#. type: TH
#: build/C/man3/alloca.3:43 build/C/man3/malloc_get_state.3:25 build/C/man3/malloc_hook.3:10 build/C/man3/malloc_info.3:25 build/C/man3/malloc_usable_size.3:25 build/C/man3/mcheck.3:25 build/C/man3/mtrace.3:25 build/C/man3/posix_fallocate.3:25 build/C/man3/posix_memalign.3:29
#, no-wrap
msgid "GNU"
msgstr ""

#. type: Plain text
#: build/C/man3/alloca.3:46
msgid "alloca - allocate memory that is automatically freed"
msgstr ""

#. type: Plain text
#: build/C/man3/alloca.3:48
msgid "B<#include E<lt>alloca.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man3/alloca.3:50
msgid "B<void *alloca(size_t >I<size>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/alloca.3:60
msgid ""
"The B<alloca>()  function allocates I<size> bytes of space in the stack "
"frame of the caller.  This temporary space is automatically freed when the "
"function that called B<alloca>()  returns to its caller."
msgstr ""

#. type: Plain text
#: build/C/man3/alloca.3:65
msgid ""
"The B<alloca>()  function returns a pointer to the beginning of the "
"allocated space.  If the allocation causes stack overflow, program behavior "
"is undefined."
msgstr ""

#. type: SH
#: build/C/man3/alloca.3:65 build/C/man3/mallinfo.3:122 build/C/man3/malloc_get_state.3:89 build/C/man3/malloc_info.3:63 build/C/man3/malloc_stats.3:54 build/C/man3/malloc_trim.3:61 build/C/man3/malloc_usable_size.3:48 build/C/man3/mcheck.3:145 build/C/man2/mmap.2:643 build/C/man3/mtrace.3:78 build/C/man3/posix_fallocate.3:114 build/C/man3/posix_memalign.3:190 build/C/man3/shm_open.3:249
#, no-wrap
msgid "ATTRIBUTES"
msgstr ""

#. type: Plain text
#: build/C/man3/alloca.3:68 build/C/man3/mallinfo.3:125 build/C/man3/malloc_get_state.3:92 build/C/man3/malloc_info.3:66 build/C/man3/malloc_stats.3:57 build/C/man3/malloc_trim.3:64 build/C/man3/malloc_usable_size.3:51 build/C/man3/mcheck.3:148 build/C/man2/mmap.2:646 build/C/man3/mtrace.3:81 build/C/man3/posix_fallocate.3:117 build/C/man3/posix_memalign.3:193 build/C/man3/shm_open.3:252
msgid "For an explanation of the terms used in this section, see B<attributes>(7)."
msgstr ""

#. type: tbl table
#: build/C/man3/alloca.3:72 build/C/man3/mallinfo.3:129 build/C/man3/malloc_get_state.3:96 build/C/man3/malloc_info.3:70 build/C/man3/malloc_stats.3:61 build/C/man3/malloc_trim.3:68 build/C/man3/malloc_usable_size.3:55 build/C/man3/mcheck.3:152 build/C/man2/mmap.2:650 build/C/man3/mtrace.3:85 build/C/man3/posix_fallocate.3:121 build/C/man3/posix_memalign.3:197 build/C/man3/shm_open.3:256
#, no-wrap
msgid "Interface"
msgstr ""

#. type: tbl table
#: build/C/man3/alloca.3:72 build/C/man3/mallinfo.3:129 build/C/man3/malloc_get_state.3:96 build/C/man3/malloc_info.3:70 build/C/man3/malloc_stats.3:61 build/C/man3/malloc_trim.3:68 build/C/man3/malloc_usable_size.3:55 build/C/man3/mcheck.3:152 build/C/man2/mmap.2:650 build/C/man3/mtrace.3:85 build/C/man3/posix_fallocate.3:121 build/C/man3/posix_memalign.3:197 build/C/man3/shm_open.3:256
#, no-wrap
msgid "Attribute"
msgstr ""

#. type: tbl table
#: build/C/man3/alloca.3:72 build/C/man3/mallinfo.3:129 build/C/man3/malloc_get_state.3:96 build/C/man3/malloc_info.3:70 build/C/man3/malloc_stats.3:61 build/C/man3/malloc_trim.3:68 build/C/man3/malloc_usable_size.3:55 build/C/man3/mcheck.3:152 build/C/man2/mmap.2:650 build/C/man3/mtrace.3:85 build/C/man3/posix_fallocate.3:121 build/C/man3/posix_memalign.3:197 build/C/man3/shm_open.3:256
#, no-wrap
msgid "Value"
msgstr ""

#. type: tbl table
#: build/C/man3/alloca.3:75
#, no-wrap
msgid "B<alloca>()"
msgstr ""

#. type: tbl table
#: build/C/man3/alloca.3:75 build/C/man3/mallinfo.3:132 build/C/man3/malloc_get_state.3:100 build/C/man3/malloc_info.3:73 build/C/man3/malloc_stats.3:64 build/C/man3/malloc_trim.3:71 build/C/man3/malloc_usable_size.3:58 build/C/man3/mcheck.3:159 build/C/man2/mmap.2:654 build/C/man3/mtrace.3:89 build/C/man3/posix_fallocate.3:124 build/C/man3/posix_memalign.3:204 build/C/man3/posix_memalign.3:209 build/C/man3/shm_open.3:260
#, no-wrap
msgid "Thread safety"
msgstr ""

#. type: tbl table
#: build/C/man3/alloca.3:75 build/C/man3/malloc_get_state.3:100 build/C/man3/malloc_info.3:73 build/C/man3/malloc_stats.3:64 build/C/man3/malloc_trim.3:71 build/C/man3/malloc_usable_size.3:58 build/C/man2/mmap.2:654 build/C/man3/posix_memalign.3:204
#, no-wrap
msgid "MT-Safe"
msgstr ""

#. type: Plain text
#: build/C/man3/alloca.3:79
msgid "This function is not in POSIX.1."
msgstr ""

#. type: Plain text
#: build/C/man3/alloca.3:85
msgid ""
"There is evidence that the B<alloca>()  function appeared in 32V, PWB, "
"PWB.2, 3BSD, and 4BSD.  There is a man page for it in 4.3BSD.  Linux uses "
"the GNU version."
msgstr ""

#. type: Plain text
#: build/C/man3/alloca.3:100
msgid ""
"The B<alloca>()  function is machine- and compiler-dependent.  For certain "
"applications, its use can improve efficiency compared to the use of "
"B<malloc>(3)  plus B<free>(3).  In certain cases, it can also simplify "
"memory deallocation in applications that use B<longjmp>(3)  or "
"B<siglongjmp>(3).  Otherwise, its use is discouraged."
msgstr ""

#. type: Plain text
#: build/C/man3/alloca.3:109
msgid ""
"Because the space allocated by B<alloca>()  is allocated within the stack "
"frame, that space is automatically freed if the function return is jumped "
"over by a call to B<longjmp>(3)  or B<siglongjmp>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/alloca.3:116
msgid ""
"The space allocated by B<alloca>()  is I<not> automatically deallocated if "
"the pointer that refers to it simply goes out of scope."
msgstr ""

#. type: Plain text
#: build/C/man3/alloca.3:121
msgid "Do not attempt to B<free>(3)  space allocated by B<alloca>()!"
msgstr ""

#. type: SS
#: build/C/man3/alloca.3:121
#, no-wrap
msgid "Notes on the GNU version"
msgstr ""

#. type: Plain text
#: build/C/man3/alloca.3:143
msgid ""
"Normally, B<gcc>(1)  translates calls to B<alloca>()  with inlined code.  "
"This is not done when either the I<-ansi>, I<-std=c89>, I<-std=c99>, or the "
"I<-std=c11> option is given B<and> the header I<E<lt>alloca.hE<gt>> is not "
"included.  Otherwise, (without an -ansi or -std=c* option) the glibc version "
"of I<E<lt>stdlib.hE<gt>> includes I<E<lt>alloca.hE<gt>> and that contains "
"the lines:"
msgstr ""

#. type: Plain text
#: build/C/man3/alloca.3:149
#, no-wrap
msgid ""
"#ifdef  __GNUC__\n"
"#define alloca(size)   __builtin_alloca (size)\n"
"#endif\n"
msgstr ""

#. type: Plain text
#: build/C/man3/alloca.3:153
msgid "with messy consequences if one has a private version of this function."
msgstr ""

#. type: Plain text
#: build/C/man3/alloca.3:157
msgid ""
"The fact that the code is inlined means that it is impossible to take the "
"address of this function, or to change its behavior by linking with a "
"different library."
msgstr ""

#. type: Plain text
#: build/C/man3/alloca.3:161
msgid ""
"The inlined code often consists of a single instruction adjusting the stack "
"pointer, and does not check for stack overflow.  Thus, there is no NULL "
"error return."
msgstr ""

#. type: SH
#: build/C/man3/alloca.3:161 build/C/man2/cacheflush.2:146 build/C/man3/mallinfo.3:152 build/C/man3/mallopt.3:463 build/C/man2/mlock.2:443 build/C/man2/mmap.2:866 build/C/man2/mremap.2:333 build/C/man3/mtrace.3:124 build/C/man2/posix_fadvise.2:231 build/C/man2/readahead.2:98 build/C/man2/shmget.2:408
#, no-wrap
msgid "BUGS"
msgstr ""

#. type: Plain text
#: build/C/man3/alloca.3:166
msgid ""
"There is no error indication if the stack frame cannot be extended.  "
"(However, after a failed allocation, the program is likely to receive a "
"B<SIGSEGV> signal if it attempts to access the unallocated space.)"
msgstr ""

#. type: Plain text
#: build/C/man3/alloca.3:174
msgid ""
"On many systems B<alloca>()  cannot be used inside the list of arguments of "
"a function call, because the stack space reserved by B<alloca>()  would "
"appear on the stack in the middle of the space for the function arguments."
msgstr ""

#. type: SH
#: build/C/man3/alloca.3:174 build/C/man2/fallocate.2:478 build/C/man2/madvise.2:586 build/C/man3/mallinfo.3:315 build/C/man3/malloc_get_state.3:128 build/C/man3/malloc_hook.3:142 build/C/man3/malloc_info.3:266 build/C/man3/malloc_stats.3:73 build/C/man3/malloc_trim.3:100 build/C/man3/malloc_usable_size.3:74 build/C/man3/mallopt.3:613 build/C/man3/mcheck.3:225 build/C/man2/mlock.2:491 build/C/man2/mmap.2:994 build/C/man2/mmap2.2:95 build/C/man2/mprotect.2:369 build/C/man2/mremap.2:354 build/C/man2/msync.2:150 build/C/man3/mtrace.3:187 build/C/man2/posix_fadvise.2:236 build/C/man3/posix_fallocate.3:188 build/C/man3/posix_madvise.3:126 build/C/man3/posix_memalign.3:303 build/C/man2/readahead.2:107 build/C/man2/remap_file_pages.2:184 build/C/man3/shm_open.3:505 build/C/man7/shm_overview.7:111 build/C/man2/shmctl.2:513 build/C/man2/shmget.2:417 build/C/man2/shmop.2:500 build/C/man2/subpage_prot.2:128 build/C/man2/sync_file_range.2:219 build/C/man2/memfd_create.2:546 build/C/man2/s390_pci_mmio_write.2:106 build/C/man2/pkey_alloc.2:137 build/C/man7/pkeys.7:292
#, no-wrap
msgid "SEE ALSO"
msgstr ""

#. type: Plain text
#: build/C/man3/alloca.3:178
msgid "B<brk>(2), B<longjmp>(3), B<malloc>(3)"
msgstr ""

#. type: TH
#: build/C/man2/cacheflush.2:25
#, no-wrap
msgid "CACHEFLUSH"
msgstr ""

#. type: TH
#: build/C/man2/cacheflush.2:25 build/C/man2/mmap.2:40 build/C/man3/posix_memalign.3:29 build/C/man2/shmctl.2:46 build/C/man2/subpage_prot.2:30
#, no-wrap
msgid "2020-12-21"
msgstr ""

#. type: Plain text
#: build/C/man2/cacheflush.2:28
msgid "cacheflush - flush contents of instruction and/or data cache"
msgstr ""

#. type: Plain text
#: build/C/man2/cacheflush.2:31
#, no-wrap
msgid "B<#include E<lt>asm/cachectl.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/cacheflush.2:33
#, no-wrap
msgid "B<int cacheflush(char *>I<addr>B<, int >I<nbytes>B<, int >I<cache>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/cacheflush.2:38
msgid ""
"I<Note>: On some architectures, there is no glibc wrapper for this system "
"call; see NOTES."
msgstr ""

#. type: Plain text
#: build/C/man2/cacheflush.2:47
msgid ""
"B<cacheflush>()  flushes the contents of the indicated cache(s) for the user "
"addresses in the range I<addr> to I<(addr+nbytes-1)>.  I<cache> may be one "
"of:"
msgstr ""

#. type: TP
#: build/C/man2/cacheflush.2:47
#, no-wrap
msgid "B<ICACHE>"
msgstr ""

#. type: Plain text
#: build/C/man2/cacheflush.2:50
msgid "Flush the instruction cache."
msgstr ""

#. type: TP
#: build/C/man2/cacheflush.2:50
#, no-wrap
msgid "B<DCACHE>"
msgstr ""

#. type: Plain text
#: build/C/man2/cacheflush.2:53
msgid "Write back to memory and invalidate the affected valid cache lines."
msgstr ""

#. type: TP
#: build/C/man2/cacheflush.2:53
#, no-wrap
msgid "B<BCACHE>"
msgstr ""

#. type: Plain text
#: build/C/man2/cacheflush.2:57
msgid "Same as B<(ICACHE|DCACHE)>."
msgstr ""

#. type: Plain text
#: build/C/man2/cacheflush.2:63
msgid ""
"B<cacheflush>()  returns 0 on success or -1 on error.  If errors are "
"detected, I<errno> will indicate the error."
msgstr ""

#. type: TP
#: build/C/man2/cacheflush.2:64 build/C/man2/mmap2.2:62 build/C/man2/mremap.2:175 build/C/man2/shmctl.2:397 build/C/man2/subpage_prot.2:72 build/C/man2/memfd_create.2:166 build/C/man2/s390_pci_mmio_write.2:77 build/C/man2/s390_pci_mmio_write.2:82
#, no-wrap
msgid "B<EFAULT>"
msgstr ""

#. type: Plain text
#: build/C/man2/cacheflush.2:71
msgid ""
"Some or all of the address range I<addr> to I<(addr+nbytes-1)> is not "
"accessible."
msgstr ""

#. type: TP
#: build/C/man2/cacheflush.2:71 build/C/man2/fallocate.2:327 build/C/man2/fallocate.2:339 build/C/man2/fallocate.2:349 build/C/man2/fallocate.2:357 build/C/man2/fallocate.2:369 build/C/man2/fallocate.2:381 build/C/man2/madvise.2:475 build/C/man2/madvise.2:483 build/C/man2/madvise.2:487 build/C/man2/madvise.2:497 build/C/man2/madvise.2:506 build/C/man3/malloc_info.3:56 build/C/man2/mlock.2:219 build/C/man2/mlock.2:226 build/C/man2/mlock.2:247 build/C/man2/mlock.2:253 build/C/man2/mmap.2:548 build/C/man2/mmap.2:556 build/C/man2/mmap.2:561 build/C/man2/mmap2.2:65 build/C/man2/mprotect.2:158 build/C/man2/mprotect.2:162 build/C/man2/mprotect.2:167 build/C/man2/mprotect.2:175 build/C/man2/mprotect.2:179 build/C/man2/mremap.2:184 build/C/man2/msync.2:83 build/C/man2/posix_fadvise.2:134 build/C/man3/posix_fallocate.3:84 build/C/man3/posix_madvise.3:89 build/C/man3/posix_madvise.3:95 build/C/man3/posix_memalign.3:166 build/C/man2/readahead.2:77 build/C/man2/remap_file_pages.2:146 build/C/man2/remap_file_pages.2:153 build/C/man3/shm_open.3:212 build/C/man2/shmctl.2:411 build/C/man2/shmget.2:239 build/C/man2/shmget.2:247 build/C/man2/shmop.2:196 build/C/man2/shmop.2:219 build/C/man2/subpage_prot.2:77 build/C/man2/sync_file_range.2:152 build/C/man2/memfd_create.2:171 build/C/man2/memfd_create.2:175 build/C/man2/memfd_create.2:182 build/C/man2/s390_pci_mmio_write.2:86 build/C/man2/membarrier.2:264 build/C/man2/pkey_alloc.2:81
#, no-wrap
msgid "B<EINVAL>"
msgstr ""

#. type: Plain text
#: build/C/man2/cacheflush.2:80
msgid "I<cache> is not one of B<ICACHE>, B<DCACHE>, or B<BCACHE> (but see BUGS)."
msgstr ""

#. type: Plain text
#: build/C/man2/cacheflush.2:86
msgid ""
"Historically, this system call was available on all MIPS UNIX variants "
"including RISC/os, IRIX, Ultrix, NetBSD, OpenBSD, and FreeBSD (and also on "
"some non-UNIX MIPS operating systems), so that the existence of this call in "
"MIPS operating systems is a de-facto standard."
msgstr ""

#. type: SS
#: build/C/man2/cacheflush.2:86
#, no-wrap
msgid "Caveat"
msgstr ""

#. type: Plain text
#: build/C/man2/cacheflush.2:93
msgid ""
"B<cacheflush>()  should not be used in programs intended to be portable.  On "
"Linux, this call first appeared on the MIPS architecture, but nowadays, "
"Linux provides a B<cacheflush>()  system call on some other architectures, "
"but with different arguments."
msgstr ""

#. type: SS
#: build/C/man2/cacheflush.2:94 build/C/man2/posix_fadvise.2:199
#, no-wrap
msgid "Architecture-specific variants"
msgstr ""

#. type: Plain text
#: build/C/man2/cacheflush.2:99
msgid ""
"Glibc provides a wrapper for this system call, with the prototype shown in "
"SYNOPSIS, for the following architectures: ARC, CSKY, MIPS, and NIOS2."
msgstr ""

#. type: Plain text
#: build/C/man2/cacheflush.2:102
msgid ""
"On some other architectures, Linux provides this system call, with different "
"arguments:"
msgstr ""

#. type: TP
#: build/C/man2/cacheflush.2:102
#, no-wrap
msgid "M68K:"
msgstr ""

#. type: Plain text
#: build/C/man2/cacheflush.2:107
#, no-wrap
msgid ""
"B<int cacheflush(unsigned long >I<addr>B<, int >I<scope>B<, int "
">I<cache>B<,>\n"
"B<               unsigned long >I<len>B<);>\n"
msgstr ""

#. type: TP
#: build/C/man2/cacheflush.2:108
#, no-wrap
msgid "SH:"
msgstr ""

#. type: Plain text
#: build/C/man2/cacheflush.2:112
#, no-wrap
msgid ""
"B<int cacheflush(unsigned long >I<addr>B<, unsigned long >I<len>B<, int "
">I<op>B<);>\n"
msgstr ""

#. type: TP
#: build/C/man2/cacheflush.2:113
#, no-wrap
msgid "NDS32:"
msgstr ""

#. type: Plain text
#: build/C/man2/cacheflush.2:117
#, no-wrap
msgid ""
"B<int cacheflush(unsigned int >I<start>B<, unsigned int >I<end>B<, int "
">I<cache>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/cacheflush.2:122
msgid ""
"On the above architectures, glibc does not provide a wrapper for this system "
"call; call it using B<syscall>(2)."
msgstr ""

#. type: SS
#: build/C/man2/cacheflush.2:122
#, no-wrap
msgid "GCC alternative"
msgstr ""

#. type: Plain text
#: build/C/man2/cacheflush.2:128
msgid ""
"Unless you need the finer grained control that this system call provides, "
"you probably want to use the GCC built-in function "
"B<__builtin___clear_cache>(), which provides a portable interface across "
"platforms supported by GCC and compatible compilers:"
msgstr ""

#. type: Plain text
#: build/C/man2/cacheflush.2:132
#, no-wrap
msgid "B<void __builtin___clear_cache(void *>I<begin>B<, void *>I<end>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/cacheflush.2:138
msgid ""
"On platforms that don't require instruction cache flushes, "
"B<__builtin___clear_cache>()  has no effect."
msgstr ""

#. type: Plain text
#: build/C/man2/cacheflush.2:146
msgid ""
"I<Note>: On some GCC-compatible compilers, the prototype for this built-in "
"function uses I<char *> instead of I<void *> for the parameters."
msgstr ""

#. type: Plain text
#: build/C/man2/cacheflush.2:153
msgid ""
"Linux kernels older than version 2.6.11 ignore the I<addr> and I<nbytes> "
"arguments, making this function fairly expensive.  Therefore, the whole "
"cache is always flushed."
msgstr ""

#. type: Plain text
#: build/C/man2/cacheflush.2:161
msgid ""
"This function always behaves as if B<BCACHE> has been passed for the "
"I<cache> argument and does not do any error checking on the I<cache> "
"argument."
msgstr ""

#. type: TH
#: build/C/man2/fallocate.2:11
#, no-wrap
msgid "FALLOCATE"
msgstr ""

#. type: TH
#: build/C/man2/fallocate.2:11
#, no-wrap
msgid "2019-11-19"
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:14
msgid "fallocate - manipulate file space"
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:18 build/C/man2/readahead.2:35
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:21
#, no-wrap
msgid ""
"B<int fallocate(int >I<fd>B<, int >I<mode>B<, off_t >I<offset>B<, off_t "
">I<len>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:27
msgid ""
"This is a nonportable, Linux-specific system call.  For the portable, "
"POSIX.1-specified method of ensuring that space is allocated for a file, see "
"B<posix_fallocate>(3)."
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:37
msgid ""
"B<fallocate>()  allows the caller to directly manipulate the allocated disk "
"space for the file referred to by I<fd> for the byte range starting at "
"I<offset> and continuing for I<len> bytes."
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:42
msgid ""
"The I<mode> argument determines the operation to be performed on the given "
"range.  Details of the supported operations are given in the subsections "
"below."
msgstr ""

#. type: SS
#: build/C/man2/fallocate.2:42
#, no-wrap
msgid "Allocating disk space"
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:65
msgid ""
"The default operation (i.e., I<mode> is zero) of B<fallocate>()  allocates "
"the disk space within the range specified by I<offset> and I<len>.  The file "
"size (as reported by B<stat>(2))  will be changed if I<offset>+I<len> is "
"greater than the file size.  Any subregion within the range specified by "
"I<offset> and I<len> that did not contain data before the call will be "
"initialized to zero.  This default behavior closely resembles the behavior "
"of the B<posix_fallocate>(3)  library function, and is intended as a method "
"of optimally implementing that function."
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:71
msgid ""
"After a successful call, subsequent writes into the range specified by "
"I<offset> and I<len> are guaranteed not to fail because of lack of disk "
"space."
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:82
msgid ""
"If the B<FALLOC_FL_KEEP_SIZE> flag is specified in I<mode>, the behavior of "
"the call is similar, but the file size will not be changed even if "
"I<offset>+I<len> is greater than the file size.  Preallocating zeroed blocks "
"beyond the end of the file in this manner is useful for optimizing append "
"workloads."
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:92
msgid ""
"If the B<FALLOC_FL_UNSHARE> flag is specified in I<mode>, shared file data "
"extents will be made private to the file to guarantee that a subsequent "
"write will not fail due to lack of space.  Typically, this will be done by "
"performing a copy-on-write operation on all shared data in the file.  This "
"flag may not be supported by all filesystems."
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:96
msgid ""
"Because allocation is done in block size chunks, B<fallocate>()  may "
"allocate a larger range of disk space than was specified."
msgstr ""

#. type: SS
#: build/C/man2/fallocate.2:96
#, no-wrap
msgid "Deallocating file space"
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:111
msgid ""
"Specifying the B<FALLOC_FL_PUNCH_HOLE> flag (available since Linux 2.6.38) "
"in I<mode> deallocates space (i.e., creates a hole)  in the byte range "
"starting at I<offset> and continuing for I<len> bytes.  Within the specified "
"range, partial filesystem blocks are zeroed, and whole filesystem blocks are "
"removed from the file.  After a successful call, subsequent reads from this "
"range will return zeros."
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:122
msgid ""
"The B<FALLOC_FL_PUNCH_HOLE> flag must be ORed with B<FALLOC_FL_KEEP_SIZE> in "
"I<mode>; in other words, even when punching off the end of the file, the "
"file size (as reported by B<stat>(2))  does not change."
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:127
msgid ""
"Not all filesystems support B<FALLOC_FL_PUNCH_HOLE>; if a filesystem doesn't "
"support the operation, an error is returned.  The operation is supported on "
"at least the following filesystems:"
msgstr ""

#. type: IP
#: build/C/man2/fallocate.2:127 build/C/man2/fallocate.2:129 build/C/man2/fallocate.2:132 build/C/man2/fallocate.2:134 build/C/man2/fallocate.2:138 build/C/man2/fallocate.2:237 build/C/man2/fallocate.2:240 build/C/man2/fallocate.2:243 build/C/man2/fallocate.2:246 build/C/man3/mallopt.3:297 build/C/man3/mallopt.3:303 build/C/man2/mremap.2:189 build/C/man2/mremap.2:192 build/C/man2/mremap.2:201 build/C/man2/mremap.2:204 build/C/man2/mremap.2:209 build/C/man2/mremap.2:218 build/C/man2/mremap.2:224 build/C/man2/mremap.2:231 build/C/man2/mremap.2:237 build/C/man2/mremap.2:240 build/C/man2/mremap.2:250 build/C/man2/mremap.2:255 build/C/man2/mremap.2:311 build/C/man2/mremap.2:320 build/C/man3/posix_fallocate.3:160 build/C/man3/posix_fallocate.3:162 build/C/man3/posix_fallocate.3:165 build/C/man3/posix_fallocate.3:169 build/C/man2/memfd_create.2:299 build/C/man2/memfd_create.2:309 build/C/man2/memfd_create.2:317
#, no-wrap
msgid "*"
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:129
msgid "XFS (since Linux 2.6.38)"
msgstr ""

#.  commit a4bb6b64e39abc0e41ca077725f2a72c868e7622
#. type: Plain text
#: build/C/man2/fallocate.2:132
msgid "ext4 (since Linux 3.0)"
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:134
msgid "Btrfs (since Linux 3.7)"
msgstr ""

#.  commit 83e4fa9c16e4af7122e31be3eca5d57881d236fe
#. type: Plain text
#: build/C/man2/fallocate.2:138
msgid "B<tmpfs>(5)  (since Linux 3.5)"
msgstr ""

#.  commit 4e56a6411fbce6f859566e17298114c2434391a4
#. type: Plain text
#: build/C/man2/fallocate.2:142
msgid "B<gfs2>(5)  (since Linux 4.16)"
msgstr ""

#. type: SS
#: build/C/man2/fallocate.2:142
#, no-wrap
msgid "Collapsing file space"
msgstr ""

#.  commit 00f5e61998dd17f5375d9dfc01331f104b83f841
#. type: Plain text
#: build/C/man2/fallocate.2:162
msgid ""
"Specifying the B<FALLOC_FL_COLLAPSE_RANGE> flag (available since Linux 3.15) "
"in I<mode> removes a byte range from a file, without leaving a hole.  The "
"byte range to be collapsed starts at I<offset> and continues for I<len> "
"bytes.  At the completion of the operation, the contents of the file "
"starting at the location I<offset+len> will be appended at the location "
"I<offset>, and the file will be I<len> bytes smaller."
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:176
msgid ""
"A filesystem may place limitations on the granularity of the operation, in "
"order to ensure efficient implementation.  Typically, I<offset> and I<len> "
"must be a multiple of the filesystem logical block size, which varies "
"according to the filesystem type and configuration.  If a filesystem has "
"such a requirement, B<fallocate>()  fails with the error B<EINVAL> if this "
"requirement is violated."
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:185
msgid ""
"If the region specified by I<offset> plus I<len> reaches or passes the end "
"of file, an error is returned; instead, use B<ftruncate>(2)  to truncate a "
"file."
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:190
msgid ""
"No other flags may be specified in I<mode> in conjunction with "
"B<FALLOC_FL_COLLAPSE_RANGE>."
msgstr ""

#.  commit 9eb79482a97152930b113b51dff530aba9e28c8e
#.  commit e1d8fb88a64c1f8094b9f6c3b6d2d9e6719c970d
#. type: Plain text
#: build/C/man2/fallocate.2:198
msgid ""
"As at Linux 3.15, B<FALLOC_FL_COLLAPSE_RANGE> is supported by ext4 (only for "
"extent-based files)  and XFS."
msgstr ""

#. type: SS
#: build/C/man2/fallocate.2:198
#, no-wrap
msgid "Zeroing file space"
msgstr ""

#.  commit 409332b65d3ed8cfa7a8030f1e9d52f372219642
#. type: Plain text
#: build/C/man2/fallocate.2:214
msgid ""
"Specifying the B<FALLOC_FL_ZERO_RANGE> flag (available since Linux 3.15)  in "
"I<mode> zeros space in the byte range starting at I<offset> and continuing "
"for I<len> bytes.  Within the specified range, blocks are preallocated for "
"the regions that span the holes in the file.  After a successful call, "
"subsequent reads from this range will return zeros."
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:220
msgid ""
"Zeroing is done within the filesystem preferably by converting the range "
"into unwritten extents.  This approach means that the specified range will "
"not be physically zeroed out on the device (except for partial blocks at the "
"either end of the range), and I/O is (otherwise) required only to update "
"metadata."
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:232
msgid ""
"If the B<FALLOC_FL_KEEP_SIZE> flag is additionally specified in I<mode>, the "
"behavior of the call is similar, but the file size will not be changed even "
"if I<offset>+I<len> is greater than the file size.  This behavior is the "
"same as when preallocating space with B<FALLOC_FL_KEEP_SIZE> specified."
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:237
msgid ""
"Not all filesystems support B<FALLOC_FL_ZERO_RANGE>; if a filesystem doesn't "
"support the operation, an error is returned.  The operation is supported on "
"at least the following filesystems:"
msgstr ""

#.  commit 376ba313147b4172f3e8cf620b9fb591f3e8cdfa
#. type: Plain text
#: build/C/man2/fallocate.2:240
msgid "XFS (since Linux 3.15)"
msgstr ""

#.  commit b8a8684502a0fc852afa0056c6bb2a9273f6fcc0
#. type: Plain text
#: build/C/man2/fallocate.2:243
msgid "ext4, for extent-based files (since Linux 3.15)"
msgstr ""

#.  commit 30175628bf7f521e9ee31ac98fa6d6fe7441a556
#. type: Plain text
#: build/C/man2/fallocate.2:246
msgid "SMB3 (since Linux 3.17)"
msgstr ""

#.  commit f27451f229966874a8793995b8e6b74326d125df
#. type: Plain text
#: build/C/man2/fallocate.2:249
msgid "Btrfs (since Linux 4.16)"
msgstr ""

#. type: SS
#: build/C/man2/fallocate.2:249
#, no-wrap
msgid "Increasing file space"
msgstr ""

#.  commit dd46c787788d5bf5b974729d43e4c405814a4c7d
#. type: Plain text
#: build/C/man2/fallocate.2:272
msgid ""
"Specifying the B<FALLOC_FL_INSERT_RANGE> flag (available since Linux 4.1)  "
"in I<mode> increases the file space by inserting a hole within the file size "
"without overwriting any existing data.  The hole will start at I<offset> and "
"continue for I<len> bytes.  When inserting the hole inside file, the "
"contents of the file starting at I<offset> will be shifted upward (i.e., to "
"a higher file offset) by I<len> bytes.  Inserting a hole inside a file "
"increases the file size by I<len> bytes."
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:286
msgid ""
"This mode has the same limitations as B<FALLOC_FL_COLLAPSE_RANGE> regarding "
"the granularity of the operation.  If the granularity requirements are not "
"met, B<fallocate>()  fails with the error B<EINVAL>.  If the I<offset> is "
"equal to or greater than the end of file, an error is returned.  For such "
"operations (i.e., inserting a hole at the end of file), B<ftruncate>(2)  "
"should be used."
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:291
msgid ""
"No other flags may be specified in I<mode> in conjunction with "
"B<FALLOC_FL_INSERT_RANGE>."
msgstr ""

#.  commit a904b1ca5751faf5ece8600e18cd3b674afcca1b
#.  commit 331573febb6a224bc50322e3670da326cb7f4cfc
#.  f2fs also has support since Linux 4.2
#.      commit f62185d0e283e9d311e3ac1020f159d95f0aab39
#. type: Plain text
#: build/C/man2/fallocate.2:301
msgid ""
"B<FALLOC_FL_INSERT_RANGE> requires filesystem support.  Filesystems that "
"support this operation include XFS (since Linux 4.1)  and ext4 (since Linux "
"4.2)."
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:308
msgid ""
"On success, B<fallocate>()  returns zero.  On error, -1 is returned and "
"I<errno> is set to indicate the error."
msgstr ""

#. type: TP
#: build/C/man2/fallocate.2:309 build/C/man2/madvise.2:472 build/C/man2/mmap.2:532 build/C/man2/posix_fadvise.2:131 build/C/man3/posix_fallocate.3:73 build/C/man2/readahead.2:73 build/C/man2/sync_file_range.2:148
#, no-wrap
msgid "B<EBADF>"
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:313 build/C/man3/posix_fallocate.3:77
msgid "I<fd> is not a valid file descriptor, or is not opened for writing."
msgstr ""

#. type: TP
#: build/C/man2/fallocate.2:313 build/C/man2/fallocate.2:317 build/C/man3/posix_fallocate.3:77
#, no-wrap
msgid "B<EFBIG>"
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:317
msgid "I<offset>+I<len> exceeds the maximum file size."
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:323
msgid ""
"I<mode> is B<FALLOC_FL_INSERT_RANGE>, and the current file size+I<len> "
"exceeds the maximum file size."
msgstr ""

#. type: TP
#: build/C/man2/fallocate.2:323 build/C/man3/posix_fallocate.3:81
#, no-wrap
msgid "B<EINTR>"
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:327
msgid "A signal was caught during execution; see B<signal>(7)."
msgstr ""

#.  FIXME . (raise a kernel bug) Probably the len==0 case should be
#.  a no-op, rather than an error. That would be consistent with
#.  similar APIs for the len==0 case.
#.  See "Re: [PATCH] fallocate.2: add FALLOC_FL_PUNCH_HOLE flag definition"
#.  21 Sep 2012
#.  http://thread.gmane.org/gmane.linux.file-systems/48331/focus=1193526
#. type: Plain text
#: build/C/man2/fallocate.2:339
msgid "I<offset> was less than 0, or I<len> was less than or equal to 0."
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:349
msgid ""
"I<mode> is B<FALLOC_FL_COLLAPSE_RANGE> and the range specified by I<offset> "
"plus I<len> reaches or passes the end of the file."
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:357
msgid ""
"I<mode> is B<FALLOC_FL_INSERT_RANGE> and the range specified by I<offset> "
"reaches or passes the end of the file."
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:369
msgid ""
"I<mode> is B<FALLOC_FL_COLLAPSE_RANGE> or B<FALLOC_FL_INSERT_RANGE>, but "
"either I<offset> or I<len> is not a multiple of the filesystem block size."
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:381
msgid ""
"I<mode> contains one of B<FALLOC_FL_COLLAPSE_RANGE> or "
"B<FALLOC_FL_INSERT_RANGE> and also other flags; no other flags are permitted "
"with B<FALLOC_FL_COLLAPSE_RANGE> or B<FALLOC_FL_INSERT_RANGE>."
msgstr ""

#.  There was an inconsistency in 3.15-rc1, that should be resolved so that all
#.  filesystems use this error for this case. (Tytso says ex4 will change.)
#.  http://thread.gmane.org/gmane.comp.file-systems.xfs.general/60485/focus=5521
#.  From: Michael Kerrisk (man-pages <mtk.manpages@...>
#.  Subject: Re: [PATCH v5 10/10] manpage: update FALLOC_FL_COLLAPSE_RANGE flag in fallocate
#.  Newsgroups: gmane.linux.man, gmane.linux.file-systems
#.  Date: 2014-04-17 13:40:05 GMT
#. type: Plain text
#: build/C/man2/fallocate.2:400
msgid ""
"I<mode> is B<FALLOC_FL_COLLAPSE_RANGE> or B<FALLOC_FL_ZERO_RANGE> or "
"B<FALLOC_FL_INSERT_RANGE>, but the file referred to by I<fd> is not a "
"regular file."
msgstr ""

#. type: TP
#: build/C/man2/fallocate.2:400 build/C/man2/madvise.2:518 build/C/man2/sync_file_range.2:160
#, no-wrap
msgid "B<EIO>"
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:403
msgid "An I/O error occurred while reading from or writing to a filesystem."
msgstr ""

#. type: TP
#: build/C/man2/fallocate.2:403 build/C/man2/mmap.2:577 build/C/man3/posix_fallocate.3:91 build/C/man2/s390_pci_mmio_write.2:91
#, no-wrap
msgid "B<ENODEV>"
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:410
msgid ""
"I<fd> does not refer to a regular file or a directory.  (If I<fd> is a pipe "
"or FIFO, a different error results.)"
msgstr ""

#. type: TP
#: build/C/man2/fallocate.2:410 build/C/man3/posix_fallocate.3:95 build/C/man2/shmget.2:265 build/C/man2/sync_file_range.2:166 build/C/man2/pkey_alloc.2:88
#, no-wrap
msgid "B<ENOSPC>"
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:415 build/C/man3/posix_fallocate.3:100
msgid ""
"There is not enough space left on the device containing the file referred to "
"by I<fd>."
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:419
msgid "This kernel does not implement B<fallocate>()."
msgstr ""

#. type: TP
#: build/C/man2/fallocate.2:419 build/C/man3/posix_fallocate.3:100
#, no-wrap
msgid "B<EOPNOTSUPP>"
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:428
msgid ""
"The filesystem containing the file referred to by I<fd> does not support "
"this operation; or the I<mode> is not supported by the filesystem containing "
"the file referred to by I<fd>."
msgstr ""

#. type: TP
#: build/C/man2/fallocate.2:428 build/C/man2/fallocate.2:434 build/C/man2/fallocate.2:449 build/C/man2/madvise.2:533 build/C/man2/mlock.2:204 build/C/man2/mlock.2:264 build/C/man2/mmap.2:612 build/C/man2/mmap.2:621 build/C/man2/shmctl.2:438 build/C/man2/shmget.2:273 build/C/man2/membarrier.2:283
#, no-wrap
msgid "B<EPERM>"
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:434
msgid "The file referred to by I<fd> is marked immutable (see B<chattr>(1))."
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:449
msgid ""
"I<mode> specifies B<FALLOC_FL_PUNCH_HOLE> or B<FALLOC_FL_COLLAPSE_RANGE> or "
"B<FALLOC_FL_INSERT_RANGE> and the file referred to by I<fd> is marked "
"append-only (see B<chattr>(1))."
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:453 build/C/man2/mmap.2:625
msgid "The operation was prevented by a file seal; see B<fcntl>(2)."
msgstr ""

#. type: TP
#: build/C/man2/fallocate.2:453 build/C/man2/posix_fadvise.2:137 build/C/man3/posix_fallocate.3:107 build/C/man2/sync_file_range.2:169
#, no-wrap
msgid "B<ESPIPE>"
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:457
msgid "I<fd> refers to a pipe or FIFO."
msgstr ""

#. type: TP
#: build/C/man2/fallocate.2:457 build/C/man2/mmap.2:625
#, no-wrap
msgid "B<ETXTBSY>"
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:467
msgid ""
"I<mode> specifies B<FALLOC_FL_COLLAPSE_RANGE> or B<FALLOC_FL_INSERT_RANGE>, "
"but the file referred to by I<fd> is currently being executed."
msgstr ""

#. type: SH
#: build/C/man2/fallocate.2:467 build/C/man2/madvise.2:541 build/C/man3/malloc_info.3:60 build/C/man3/mcheck.3:134 build/C/man2/mlock.2:268 build/C/man2/mmap2.2:74 build/C/man2/mprotect.2:211 build/C/man2/posix_fadvise.2:147 build/C/man3/posix_fallocate.3:111 build/C/man3/posix_madvise.3:103 build/C/man3/posix_memalign.3:175 build/C/man2/readahead.2:83 build/C/man2/remap_file_pages.2:162 build/C/man3/shm_open.3:247 build/C/man2/subpage_prot.2:90 build/C/man2/sync_file_range.2:174 build/C/man2/memfd_create.2:199 build/C/man2/s390_pci_mmio_write.2:97 build/C/man2/membarrier.2:287 build/C/man2/pkey_alloc.2:103
#, no-wrap
msgid "VERSIONS"
msgstr ""

#.  See http://sourceware.org/bugzilla/show_bug.cgi?id=14964
#. type: Plain text
#: build/C/man2/fallocate.2:475
msgid ""
"B<fallocate>()  is available on Linux since kernel 2.6.23.  Support is "
"provided by glibc since version 2.10.  The B<FALLOC_FL_*> flags are defined "
"in glibc headers only since version 2.18."
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:478
msgid "B<fallocate>()  is Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:483
msgid "B<fallocate>(1), B<ftruncate>(2), B<posix_fadvise>(3), B<posix_fallocate>(3)"
msgstr ""

#. type: TH
#: build/C/man2/madvise.2:35
#, no-wrap
msgid "MADVISE"
msgstr ""

#. type: TH
#: build/C/man2/madvise.2:35 build/C/man2/mlock.2:26 build/C/man2/shmget.2:38 build/C/man2/shmop.2:40
#, no-wrap
msgid "2020-04-11"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:38
msgid "madvise - give advice about use of memory"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:40 build/C/man2/msync.2:30 build/C/man3/shm_open.3:30
msgid "B<#include E<lt>sys/mman.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:42
msgid "B<int madvise(void *>I<addr>B<, size_t >I<length>B<, int >I<advice>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:46 build/C/man2/posix_fadvise.2:44 build/C/man3/posix_fallocate.3:39 build/C/man3/posix_madvise.3:33 build/C/man3/posix_memalign.3:49
msgid "Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:49
msgid "B<madvise>():"
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:51
#, no-wrap
msgid "Since glibc 2.19:"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:54
msgid "_DEFAULT_SOURCE"
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:54
#, no-wrap
msgid "Up to and including glibc 2.19:"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:57
msgid "_BSD_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:70
msgid ""
"The B<madvise>()  system call is used to give advice or directions to the "
"kernel about the address range beginning at address I<addr> and with size "
"I<length> bytes In most cases, the goal of such advice is to improve system "
"or application performance."
msgstr ""

#
#.  ======================================================================
#. type: Plain text
#: build/C/man2/madvise.2:83
msgid ""
"Initially, the system call supported a set of \"conventional\" I<advice> "
"values, which are also available on several other implementations.  (Note, "
"though, that B<madvise>()  is not specified in POSIX.)  Subsequently, a "
"number of Linux-specific I<advice> values have been added."
msgstr ""

#. type: SS
#: build/C/man2/madvise.2:83
#, no-wrap
msgid "Conventional advice values"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:102
msgid ""
"The I<advice> values listed below allow an application to tell the kernel "
"how it expects to use some mapped or shared memory areas, so that the kernel "
"can choose appropriate read-ahead and caching techniques.  These I<advice> "
"values do not influence the semantics of the application (except in the case "
"of B<MADV_DONTNEED>), but may influence its performance.  All of the "
"I<advice> values listed here have analogs in the POSIX-specified "
"B<posix_madvise>(3)  function, and the values have the same meanings, with "
"the exception of B<MADV_DONTNEED>."
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:106
msgid ""
"The advice is indicated in the I<advice> argument, which is one of the "
"following:"
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:106
#, no-wrap
msgid "B<MADV_NORMAL>"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:110
msgid "No special treatment.  This is the default."
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:110
#, no-wrap
msgid "B<MADV_RANDOM>"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:114
msgid ""
"Expect page references in random order.  (Hence, read ahead may be less "
"useful than normally.)"
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:114
#, no-wrap
msgid "B<MADV_SEQUENTIAL>"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:119
msgid ""
"Expect page references in sequential order.  (Hence, pages in the given "
"range can be aggressively read ahead, and may be freed soon after they are "
"accessed.)"
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:119
#, no-wrap
msgid "B<MADV_WILLNEED>"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:123
msgid ""
"Expect access in the near future.  (Hence, it might be a good idea to read "
"some pages ahead.)"
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:123
#, no-wrap
msgid "B<MADV_DONTNEED>"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:128
msgid ""
"Do not expect access in the near future.  (For the time being, the "
"application is finished with the given range, so the kernel can free "
"resources associated with it.)"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:139
msgid ""
"After a successful B<MADV_DONTNEED> operation, the semantics of memory "
"access in the specified region are changed: subsequent accesses of pages in "
"the range will succeed, but will result in either repopulating the memory "
"contents from the up-to-date contents of the underlying mapped file (for "
"shared file mappings, shared anonymous mappings, and shmem-based techniques "
"such as System V shared memory segments)  or zero-fill-on-demand pages for "
"anonymous private mappings."
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:146
msgid ""
"Note that, when applied to shared mappings, B<MADV_DONTNEED> might not lead "
"to immediate freeing of the pages in the range.  The kernel is free to delay "
"freeing the pages until an appropriate moment.  The resident set size (RSS) "
"of the calling process will be immediately reduced however."
msgstr ""

#.  http://lwn.net/Articles/162860/
#
#.  ======================================================================
#. type: Plain text
#: build/C/man2/madvise.2:161
msgid ""
"B<MADV_DONTNEED> cannot be applied to locked pages, Huge TLB pages, or "
"B<VM_PFNMAP> pages.  (Pages marked with the kernel-internal B<VM_PFNMAP> "
"flag are special memory areas that are not managed by the virtual memory "
"subsystem.  Such pages are typically created by device drivers that map the "
"pages into user space.)"
msgstr ""

#. type: SS
#: build/C/man2/madvise.2:161
#, no-wrap
msgid "Linux-specific advice values"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:170
msgid ""
"The following Linux-specific I<advice> values have no counterparts in the "
"POSIX-specified B<posix_madvise>(3), and may or may not have counterparts in "
"the B<madvise>()  interface available on other implementations.  Note that "
"some of these operations change the semantics of memory accesses."
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:170
#, no-wrap
msgid "B<MADV_REMOVE> (since Linux 2.6.16)"
msgstr ""

#.  commit f6b3ec238d12c8cc6cc71490c6e3127988460349
#.  Databases want to use this feature to drop a section of their
#.  bufferpool (shared memory segments) - without writing back to
#.  disk/swap space.  This feature is also useful for supporting
#.  hot-plug memory on UML.
#. type: Plain text
#: build/C/man2/madvise.2:184
msgid ""
"Free up a given range of pages and its associated backing store.  This is "
"equivalent to punching a hole in the corresponding byte range of the backing "
"store (see B<fallocate>(2)).  Subsequent accesses in the specified address "
"range will see bytes containing zero."
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:189
msgid ""
"The specified address range must be mapped shared and writable.  This flag "
"cannot be applied to locked pages, Huge TLB pages, or B<VM_PFNMAP> pages."
msgstr ""

#.  commit 3f31d07571eeea18a7d34db9af21d2285b807a17
#. type: Plain text
#: build/C/man2/madvise.2:205
msgid ""
"In the initial implementation, only B<tmpfs>(5)  was supported "
"B<MADV_REMOVE>; but since Linux 3.5, any filesystem which supports the "
"B<fallocate>(2)  B<FALLOC_FL_PUNCH_HOLE> mode also supports B<MADV_REMOVE>.  "
"Hugetlbfs fails with the error B<EINVAL> and other filesystems fail with the "
"error B<EOPNOTSUPP>."
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:205
#, no-wrap
msgid "B<MADV_DONTFORK> (since Linux 2.6.16)"
msgstr ""

#.  commit f822566165dd46ff5de9bf895cfa6c51f53bb0c4
#.  See http://lwn.net/Articles/171941/
#.  [PATCH] madvise MADV_DONTFORK/MADV_DOFORK
#.  Currently, copy-on-write may change the physical address of
#.  a page even if the user requested that the page is pinned in
#.  memory (either by mlock or by get_user_pages).  This happens
#.  if the process forks meanwhile, and the parent writes to that
#.  page.  As a result, the page is orphaned: in case of
#.  get_user_pages, the application will never see any data hardware
#.  DMA's into this page after the COW.  In case of mlock'd memory,
#.  the parent is not getting the realtime/security benefits of mlock.
#
#.  In particular, this affects the Infiniband modules which do DMA from
#.  and into user pages all the time.
#
#.  This patch adds madvise options to control whether memory range is
#.  inherited across fork. Useful e.g. for when hardware is doing DMA
#.  from/into these pages.  Could also be useful to an application
#.  wanting to speed up its forks by cutting large areas out of
#.  consideration.
#
#.  SEE ALSO: http://lwn.net/Articles/171941/
#.  "Tweaks to madvise() and posix_fadvise()", 14 Feb 2006
#. type: Plain text
#: build/C/man2/madvise.2:237
msgid ""
"Do not make the pages in this range available to the child after a "
"B<fork>(2).  This is useful to prevent copy-on-write semantics from changing "
"the physical location of a page if the parent writes to it after a "
"B<fork>(2).  (Such page relocations cause problems for hardware that DMAs "
"into the page.)"
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:237
#, no-wrap
msgid "B<MADV_DOFORK> (since Linux 2.6.16)"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:243
msgid ""
"Undo the effect of B<MADV_DONTFORK>, restoring the default behavior, whereby "
"a mapping is inherited across B<fork>(2)."
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:243
#, no-wrap
msgid "B<MADV_HWPOISON> (since Linux 2.6.32)"
msgstr ""

#.  commit 9893e49d64a4874ea67849ee2cfbf3f3d6817573
#. type: Plain text
#: build/C/man2/madvise.2:258
msgid ""
"Poison the pages in the range specified by I<addr> and I<length> and handle "
"subsequent references to those pages like a hardware memory corruption.  "
"This operation is available only for privileged (B<CAP_SYS_ADMIN>)  "
"processes.  This operation may result in the calling process receiving a "
"B<SIGBUS> and the page being unmapped."
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:262 build/C/man2/madvise.2:319
msgid ""
"This feature is intended for testing of memory error-handling code; it is "
"available only if the kernel was configured with B<CONFIG_MEMORY_FAILURE>."
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:262
#, no-wrap
msgid "B<MADV_MERGEABLE> (since Linux 2.6.32)"
msgstr ""

#.  commit f8af4da3b4c14e7267c4ffb952079af3912c51c5
#. type: Plain text
#: build/C/man2/madvise.2:276
msgid ""
"Enable Kernel Samepage Merging (KSM) for the pages in the range specified by "
"I<addr> and I<length>.  The kernel regularly scans those areas of user "
"memory that have been marked as mergeable, looking for pages with identical "
"content.  These are replaced by a single write-protected page (which is "
"automatically copied if a process later wants to update the content of the "
"page).  KSM merges only private anonymous pages (see B<mmap>(2))."
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:283
msgid ""
"The KSM feature is intended for applications that generate many instances of "
"the same data (e.g., virtualization systems such as KVM).  It can consume a "
"lot of processing power; use with care.  See the Linux kernel source file "
"I<Documentation/admin-guide/mm/ksm.rst> for more details."
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:290
msgid ""
"The B<MADV_MERGEABLE> and B<MADV_UNMERGEABLE> operations are available only "
"if the kernel was configured with B<CONFIG_KSM>."
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:290
#, no-wrap
msgid "B<MADV_UNMERGEABLE> (since Linux 2.6.32)"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:299
msgid ""
"Undo the effect of an earlier B<MADV_MERGEABLE> operation on the specified "
"address range; KSM unmerges whatever pages it had merged in the address "
"range specified by I<addr> and I<length>."
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:299
#, no-wrap
msgid "B<MADV_SOFT_OFFLINE> (since Linux 2.6.33)"
msgstr ""

#.  commit afcf938ee0aac4ef95b1a23bac704c6fbeb26de6
#. type: Plain text
#: build/C/man2/madvise.2:315
msgid ""
"Soft offline the pages in the range specified by I<addr> and I<length>.  The "
"memory of each page in the specified range is preserved (i.e., when next "
"accessed, the same content will be visible, but in a new physical page "
"frame), and the original page is offlined (i.e., no longer used, and taken "
"out of normal memory management).  The effect of the B<MADV_SOFT_OFFLINE> "
"operation is invisible to (i.e., does not change the semantics of)  the "
"calling process."
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:319
#, no-wrap
msgid "B<MADV_HUGEPAGE> (since Linux 2.6.38)"
msgstr ""

#.  commit 0af4e98b6b095c74588af04872f83d333c958c32
#.  http://lwn.net/Articles/358904/
#.  https://lwn.net/Articles/423584/
#. type: Plain text
#: build/C/man2/madvise.2:335
msgid ""
"Enable Transparent Huge Pages (THP) for pages in the range specified by "
"I<addr> and I<length>.  Currently, Transparent Huge Pages work only with "
"private anonymous pages (see B<mmap>(2)).  The kernel will regularly scan "
"the areas marked as huge page candidates to replace them with huge pages.  "
"The kernel will also allocate huge pages directly when the region is "
"naturally aligned to the huge page size (see B<posix_memalign>(2))."
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:344
msgid ""
"This feature is primarily aimed at applications that use large mappings of "
"data and access large regions of that memory at a time (e.g., virtualization "
"systems such as QEMU).  It can very easily waste memory (e.g., a 2\\ MB "
"mapping that only ever accesses 1 byte will result in 2\\ MB of wired memory "
"instead of one 4\\ KB page).  See the Linux kernel source file "
"I<Documentation/admin-guide/mm/transhuge.rst> for more details."
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:361
msgid ""
"Most common kernels configurations provide B<MADV_HUGEPAGE>-style behavior "
"by default, and thus B<MADV_HUGEPAGE> is normally not necessary.  It is "
"mostly intended for embedded systems, where B<MADV_HUGEPAGE>-style behavior "
"may not be enabled by default in the kernel.  On such systems, this flag can "
"be used in order to selectively enable THP.  Whenever B<MADV_HUGEPAGE> is "
"used, it should always be in regions of memory with an access pattern that "
"the developer knows in advance won't risk to increase the memory footprint "
"of the application when transparent hugepages are enabled."
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:368
msgid ""
"The B<MADV_HUGEPAGE> and B<MADV_NOHUGEPAGE> operations are available only if "
"the kernel was configured with B<CONFIG_TRANSPARENT_HUGEPAGE>."
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:368
#, no-wrap
msgid "B<MADV_NOHUGEPAGE> (since Linux 2.6.38)"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:375
msgid ""
"Ensures that memory in the address range specified by I<addr> and I<length> "
"will not be backed by transparent hugepages."
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:375
#, no-wrap
msgid "B<MADV_DONTDUMP> (since Linux 3.4)"
msgstr ""

#.  commit 909af768e88867016f427264ae39d27a57b6a8ed
#.  commit accb61fe7bb0f5c2a4102239e4981650f9048519
#. type: Plain text
#: build/C/man2/madvise.2:391
msgid ""
"Exclude from a core dump those pages in the range specified by I<addr> and "
"I<length>.  This is useful in applications that have large areas of memory "
"that are known not to be useful in a core dump.  The effect of "
"B<MADV_DONTDUMP> takes precedence over the bit mask that is set via the "
"I</proc/[pid]/coredump_filter> file (see B<core>(5))."
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:391
#, no-wrap
msgid "B<MADV_DODUMP> (since Linux 3.4)"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:395
msgid "Undo the effect of an earlier B<MADV_DONTDUMP>."
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:395
#, no-wrap
msgid "B<MADV_FREE> (since Linux 4.5)"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:417
msgid ""
"The application no longer requires the pages in the range specified by "
"I<addr> and I<len>.  The kernel can thus free these pages, but the freeing "
"could be delayed until memory pressure occurs.  For each of the pages that "
"has been marked to be freed but has not yet been freed, the free operation "
"will be canceled if the caller writes into the page.  After a successful "
"B<MADV_FREE> operation, any stale data (i.e., dirty, unwritten pages) will "
"be lost when the kernel frees the pages.  However, subsequent writes to "
"pages in the range will succeed and then kernel cannot free those dirtied "
"pages, so that the caller can always see just written data.  If there is no "
"subsequent write, the kernel can free the pages at any time.  Once pages in "
"the range have been freed, the caller will see zero-fill-on-demand pages "
"upon subsequent page references."
msgstr ""

#.  commit 93e06c7a645343d222c9a838834a51042eebbbf7
#. type: Plain text
#: build/C/man2/madvise.2:428
msgid ""
"The B<MADV_FREE> operation can be applied only to private anonymous pages "
"(see B<mmap>(2)).  In Linux before version 4.12, when freeing pages on a "
"swapless system, the pages in the given range are freed instantly, "
"regardless of memory pressure."
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:428
#, no-wrap
msgid "B<MADV_WIPEONFORK> (since Linux 4.14)"
msgstr ""

#.  commit d2cd9ede6e193dd7d88b6d27399e96229a551b19
#. type: Plain text
#: build/C/man2/madvise.2:437
msgid ""
"Present the child process with zero-filled memory in this range after a "
"B<fork>(2).  This is useful in forking servers in order to ensure that "
"sensitive per-process data (for example, PRNG seeds, cryptographic secrets, "
"and so on)  is not handed to child processes."
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:442
msgid ""
"The B<MADV_WIPEONFORK> operation can be applied only to private anonymous "
"pages (see B<mmap>(2))."
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:450
msgid ""
"Within the child created by B<fork>(2), the B<MADV_WIPEONFORK> setting "
"remains in place on the specified address range.  This setting is cleared "
"during B<execve>(2)."
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:450
#, no-wrap
msgid "B<MADV_KEEPONFORK> (since Linux 4.14)"
msgstr ""

#.  commit d2cd9ede6e193dd7d88b6d27399e96229a551b19
#. type: Plain text
#: build/C/man2/madvise.2:455
msgid "Undo the effect of an earlier B<MADV_WIPEONFORK>."
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:462
msgid ""
"On success, B<madvise>()  returns zero.  On error, it returns -1 and "
"I<errno> is set appropriately."
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:463 build/C/man2/mmap.2:510 build/C/man2/mprotect.2:149 build/C/man3/shm_open.3:186 build/C/man3/shm_open.3:191 build/C/man2/shmctl.2:389 build/C/man2/shmget.2:224 build/C/man2/shmop.2:187
#, no-wrap
msgid "B<EACCES>"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:469
msgid ""
"I<advice> is B<MADV_REMOVE>, but the specified address range is not a shared "
"writable mapping."
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:469 build/C/man2/mlock.2:216 build/C/man2/mmap.2:528 build/C/man2/mremap.2:169
#, no-wrap
msgid "B<EAGAIN>"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:472
msgid "A kernel resource was temporarily unavailable."
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:475
msgid "The map exists, but the area maps something that isn't a file."
msgstr ""

#.  .I length
#.  is zero,
#. type: Plain text
#: build/C/man2/madvise.2:483
msgid "I<addr> is not page-aligned or I<length> is negative."
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:487
msgid "I<advice> is not a valid."
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:497
msgid ""
"I<advice> is B<MADV_DONTNEED> or B<MADV_REMOVE> and the specified address "
"range includes locked, Huge TLB pages, or B<VM_PFNMAP> pages."
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:506
msgid ""
"I<advice> is B<MADV_MERGEABLE> or B<MADV_UNMERGEABLE>, but the kernel was "
"not configured with B<CONFIG_KSM>."
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:518
msgid ""
"I<advice> is B<MADV_FREE> or B<MADV_WIPEONFORK> but the specified address "
"range includes file, Huge TLB, B<MAP_SHARED>, or B<VM_PFNMAP> ranges."
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:524
msgid ""
"(for B<MADV_WILLNEED>)  Paging in this area would exceed the process's "
"maximum resident set size."
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:524 build/C/man2/madvise.2:529 build/C/man2/mlock.2:184 build/C/man2/mlock.2:192 build/C/man2/mlock.2:231 build/C/man2/mlock.2:235 build/C/man2/mmap.2:581 build/C/man2/mmap.2:584 build/C/man2/mmap.2:592 build/C/man2/mprotect.2:186 build/C/man2/mprotect.2:189 build/C/man2/mprotect.2:199 build/C/man2/mremap.2:245 build/C/man2/msync.2:96 build/C/man3/posix_madvise.3:99 build/C/man3/posix_memalign.3:172 build/C/man2/shmctl.2:422 build/C/man2/shmget.2:262 build/C/man2/shmop.2:210 build/C/man2/subpage_prot.2:87 build/C/man2/sync_file_range.2:163 build/C/man2/memfd_create.2:196 build/C/man2/s390_pci_mmio_write.2:94
#, no-wrap
msgid "B<ENOMEM>"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:529
msgid "(for B<MADV_WILLNEED>)  Not enough memory: paging in failed."
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:533
msgid ""
"Addresses in the specified range are not currently mapped, or are outside "
"the address space of the process."
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:541
msgid ""
"I<advice> is B<MADV_HWPOISON>, but the caller does not have the "
"B<CAP_SYS_ADMIN> capability."
msgstr ""

#.  commit d3ac21cacc24790eb45d735769f35753f5b56ceb
#. type: Plain text
#: build/C/man2/madvise.2:548
msgid ""
"Since Linux 3.18, support for this system call is optional, depending on the "
"setting of the B<CONFIG_ADVISE_SYSCALLS> configuration option."
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:558
msgid ""
"B<madvise>()  is not specified by any standards.  Versions of this system "
"call, implementing a wide variety of I<advice> values, exist on many other "
"implementations.  Other implementations typically implement at least the "
"flags listed above under I<Conventional advice flags>, albeit with some "
"variation in semantics."
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:569
msgid ""
"POSIX.1-2001 describes B<posix_madvise>(3)  with constants "
"B<POSIX_MADV_NORMAL>, B<POSIX_MADV_RANDOM>, B<POSIX_MADV_SEQUENTIAL>, "
"B<POSIX_MADV_WILLNEED>, and B<POSIX_MADV_DONTNEED>, and so on, with behavior "
"close to the similarly named flags listed above."
msgstr ""

#. type: SS
#: build/C/man2/madvise.2:570 build/C/man2/mlock.2:400 build/C/man2/shmget.2:402
#, no-wrap
msgid "Linux notes"
msgstr ""

#.  .SH HISTORY
#.  The
#.  .BR madvise ()
#.  function first appeared in 4.4BSD.
#. type: Plain text
#: build/C/man2/madvise.2:586
msgid ""
"The Linux implementation requires that the address I<addr> be page-aligned, "
"and allows I<length> to be zero.  If there are some parts of the specified "
"address range that are not mapped, the Linux version of B<madvise>()  "
"ignores them and applies the call to the rest (but returns B<ENOMEM> from "
"the system call, as it should)."
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:596
msgid ""
"B<getrlimit>(2), B<mincore>(2), B<mmap>(2), B<mprotect>(2), B<msync>(2), "
"B<munmap>(2), B<prctl>(2), B<posix_madvise>(3), B<core>(5)"
msgstr ""

#. type: TH
#: build/C/man3/mallinfo.3:25
#, no-wrap
msgid "MALLINFO"
msgstr ""

#. type: TH
#: build/C/man3/mallinfo.3:25 build/C/man3/malloc_hook.3:10 build/C/man3/malloc_info.3:25 build/C/man2/mprotect.2:33 build/C/man3/mtrace.3:25 build/C/man3/posix_fallocate.3:25 build/C/man3/shm_open.3:25 build/C/man2/memfd_create.2:21 build/C/man2/membarrier.2:25
#, no-wrap
msgid "2020-11-01"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:28
msgid "mallinfo - obtain memory allocation information"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:30 build/C/man3/malloc_stats.3:30 build/C/man3/malloc_trim.3:30 build/C/man3/malloc_usable_size.3:30 build/C/man3/mallopt.3:30
msgid "B<#include E<lt>malloc.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:32
msgid "B<struct mallinfo mallinfo(void);>"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:39
msgid ""
"The B<mallinfo>()  function returns a copy of a structure containing "
"information about memory allocations performed by B<malloc>(3)  and related "
"functions."
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:45
msgid ""
"Note that not all allocations are visible to B<mallinfo>(); see BUGS and "
"consider using B<malloc_info>(3)  instead."
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:47
msgid "The returned structure is defined as follows:"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:62
#, no-wrap
msgid ""
"struct mallinfo {\n"
"    int arena;     /* Non-mmapped space allocated (bytes) */\n"
"    int ordblks;   /* Number of free chunks */\n"
"    int smblks;    /* Number of free fastbin blocks */\n"
"    int hblks;     /* Number of mmapped regions */\n"
"    int hblkhd;    /* Space allocated in mmapped regions (bytes) */\n"
"    int usmblks;   /* See below */\n"
"    int fsmblks;   /* Space in freed fastbin blocks (bytes) */\n"
"    int uordblks;  /* Total allocated space (bytes) */\n"
"    int fordblks;  /* Total free space (bytes) */\n"
"    int keepcost;  /* Top-most, releasable space (bytes) */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:68
msgid "The fields of the I<mallinfo> structure contain the following information:"
msgstr ""

#. type: TP
#: build/C/man3/mallinfo.3:68
#, no-wrap
msgid "I<arena>"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:74
msgid ""
"The total amount of memory allocated by means other than B<mmap>(2)  (i.e., "
"memory allocated on the heap).  This figure includes both in-use blocks and "
"blocks on the free list."
msgstr ""

#. type: TP
#: build/C/man3/mallinfo.3:74
#, no-wrap
msgid "I<ordblks>"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:77
msgid "The number of ordinary (i.e., non-fastbin) free blocks."
msgstr ""

#. type: TP
#: build/C/man3/mallinfo.3:77
#, no-wrap
msgid "I<smblks>"
msgstr ""

#.  the glibc info page wrongly says this field is unused
#.  https://sourceware.org/bugzilla/show_bug.cgi?id=26746
#. type: Plain text
#: build/C/man3/mallinfo.3:83
msgid "The number of fastbin free blocks (see B<mallopt>(3))."
msgstr ""

#. type: TP
#: build/C/man3/mallinfo.3:83
#, no-wrap
msgid "I<hblks>"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:91
msgid ""
"The number of blocks currently allocated using B<mmap>(2).  (See the "
"discussion of B<M_MMAP_THRESHOLD> in B<mallopt>(3).)"
msgstr ""

#. type: TP
#: build/C/man3/mallinfo.3:91
#, no-wrap
msgid "I<hblkhd>"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:95
msgid "The number of bytes in blocks currently allocated using B<mmap>(2)."
msgstr ""

#. type: TP
#: build/C/man3/mallinfo.3:95
#, no-wrap
msgid "I<usmblks>"
msgstr ""

#.  It seems to have been zero since at least as far back as glibc 2.15
#. type: Plain text
#: build/C/man3/mallinfo.3:102
msgid ""
"This field is unused, and is always 0.  Historically, it was the \"highwater "
"mark\" for allocated space\\(emthat is, the maximum amount of space that was "
"ever allocated (in bytes); this field was maintained only in nonthreading "
"environments."
msgstr ""

#. type: TP
#: build/C/man3/mallinfo.3:102
#, no-wrap
msgid "I<fsmblks>"
msgstr ""

#.  the glibc info page wrongly says this field is unused
#.  https://sourceware.org/bugzilla/show_bug.cgi?id=26746
#. type: Plain text
#: build/C/man3/mallinfo.3:107
msgid "The total number of bytes in fastbin free blocks."
msgstr ""

#. type: TP
#: build/C/man3/mallinfo.3:107
#, no-wrap
msgid "I<uordblks>"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:110
msgid "The total number of bytes used by in-use allocations."
msgstr ""

#. type: TP
#: build/C/man3/mallinfo.3:110
#, no-wrap
msgid "I<fordblks>"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:113
msgid "The total number of bytes in free blocks."
msgstr ""

#. type: TP
#: build/C/man3/mallinfo.3:113
#, no-wrap
msgid "I<keepcost>"
msgstr ""

#.  .SH VERSIONS
#.  Available already in glibc 2.0, possibly earlier
#. type: Plain text
#: build/C/man3/mallinfo.3:122
msgid ""
"The total amount of releasable free space at the top of the heap.  This is "
"the maximum number of bytes that could ideally (i.e., ignoring page "
"alignment restrictions, and so on) be released by B<malloc_trim>(3)."
msgstr ""

#. type: tbl table
#: build/C/man3/mallinfo.3:132
#, no-wrap
msgid "B<mallinfo>()"
msgstr ""

#. type: tbl table
#: build/C/man3/mallinfo.3:132
#, no-wrap
msgid "MT-Unsafe init const:mallopt"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:148
msgid ""
"B<mallinfo>()  would access some global internal objects.  If modify them "
"with non-atomically, may get inconsistent results.  The identifier "
"I<mallopt> in I<const:mallopt> mean that B<mallopt>()  would modify the "
"global internal objects with atomics, that make sure B<mallinfo>()  is safe "
"enough, others modify with non-atomically maybe not."
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:152
msgid ""
"This function is not specified by POSIX or the C standards.  A similar "
"function exists on many System V derivatives, and was specified in the SVID."
msgstr ""

#.  FIXME . http://sourceware.org/bugzilla/show_bug.cgi?id=208
#.  See the 24 Aug 2011 mail by Paul Pluzhnikov:
#.      "[patch] Fix mallinfo() to accumulate results for all arenas"
#.  on libc-alpha@sourceware.org
#. type: Plain text
#: build/C/man3/mallinfo.3:164
msgid ""
"B<Information is returned for only the main memory allocation area.> "
"Allocations in other arenas are excluded.  See B<malloc_stats>(3)  and "
"B<malloc_info>(3)  for alternatives that include information about other "
"arenas."
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:172
msgid ""
"The fields of the I<mallinfo> structure are typed as I<int>.  However, "
"because some internal bookkeeping values may be of type I<long>, the "
"reported values may wrap around zero and thus be inaccurate."
msgstr ""

#. type: SH
#: build/C/man3/mallinfo.3:172 build/C/man3/malloc_hook.3:94 build/C/man3/malloc_info.3:97 build/C/man3/mallopt.3:513 build/C/man3/mcheck.3:180 build/C/man2/mmap.2:910 build/C/man2/mprotect.2:286 build/C/man3/mtrace.3:130 build/C/man3/shm_open.3:287 build/C/man2/shmget.2:414 build/C/man2/shmop.2:293 build/C/man2/memfd_create.2:344 build/C/man2/membarrier.2:328 build/C/man2/pkey_alloc.2:134 build/C/man7/pkeys.7:165
#, no-wrap
msgid "EXAMPLES"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:178
msgid ""
"The program below employs B<mallinfo>()  to retrieve memory allocation "
"statistics before and after allocating and freeing some blocks of memory.  "
"The statistics are displayed on standard output."
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:182
msgid ""
"The first two command-line arguments specify the number and size of blocks "
"to be allocated with B<malloc>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:196
msgid ""
"The remaining three arguments specify which of the allocated blocks should "
"be freed with B<free>(3).  These three arguments are optional, and specify "
"(in order): the step size to be used in the loop that frees blocks (the "
"default is 1, meaning free all blocks in the range); the ordinal position of "
"the first block to be freed (default 0, meaning the first allocated block); "
"and a number one greater than the ordinal position of the last block to be "
"freed (default is one greater than the maximum block number).  If these "
"three arguments are omitted, then the defaults cause all allocated blocks to "
"be freed."
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:200
msgid ""
"In the following example run of the program, 1000 allocations of 100 bytes "
"are performed, and then every second allocated block is freed:"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:215
#, no-wrap
msgid ""
"$ B<./a.out 1000 100 2>\n"
"============== Before allocating blocks ==============\n"
"Total non-mmapped bytes (arena):       0\n"
"# of free chunks (ordblks):            1\n"
"# of free fastbin blocks (smblks):     0\n"
"# of mapped regions (hblks):           0\n"
"Bytes in mapped regions (hblkhd):      0\n"
"Max. total allocated space (usmblks):  0\n"
"Free bytes held in fastbins (fsmblks): 0\n"
"Total allocated space (uordblks):      0\n"
"Total free space (fordblks):           0\n"
"Topmost releasable block (keepcost):   0\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:227
#, no-wrap
msgid ""
"============== After allocating blocks ==============\n"
"Total non-mmapped bytes (arena):       135168\n"
"# of free chunks (ordblks):            1\n"
"# of free fastbin blocks (smblks):     0\n"
"# of mapped regions (hblks):           0\n"
"Bytes in mapped regions (hblkhd):      0\n"
"Max. total allocated space (usmblks):  0\n"
"Free bytes held in fastbins (fsmblks): 0\n"
"Total allocated space (uordblks):      104000\n"
"Total free space (fordblks):           31168\n"
"Topmost releasable block (keepcost):   31168\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:239
#, no-wrap
msgid ""
"============== After freeing blocks ==============\n"
"Total non-mmapped bytes (arena):       135168\n"
"# of free chunks (ordblks):            501\n"
"# of free fastbin blocks (smblks):     0\n"
"# of mapped regions (hblks):           0\n"
"Bytes in mapped regions (hblkhd):      0\n"
"Max. total allocated space (usmblks):  0\n"
"Free bytes held in fastbins (fsmblks): 0\n"
"Total allocated space (uordblks):      52000\n"
"Total free space (fordblks):           83168\n"
"Topmost releasable block (keepcost):   31168\n"
msgstr ""

#. type: SS
#: build/C/man3/mallinfo.3:241 build/C/man3/malloc_info.3:180 build/C/man3/mallopt.3:579 build/C/man3/mcheck.3:197 build/C/man2/mmap.2:921 build/C/man2/mprotect.2:304 build/C/man7/pkeys.7:183
#, no-wrap
msgid "Program source"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:247
#, no-wrap
msgid ""
"#include E<lt>malloc.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:252
#, no-wrap
msgid ""
"static void\n"
"display_mallinfo(void)\n"
"{\n"
"    struct mallinfo mi;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:254
#, no-wrap
msgid "    mi = mallinfo();\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:266
#, no-wrap
msgid ""
"    printf(\"Total non-mmapped bytes (arena):       %d\\en\", mi.arena);\n"
"    printf(\"# of free chunks (ordblks):            %d\\en\", mi.ordblks);\n"
"    printf(\"# of free fastbin blocks (smblks):     %d\\en\", mi.smblks);\n"
"    printf(\"# of mapped regions (hblks):           %d\\en\", mi.hblks);\n"
"    printf(\"Bytes in mapped regions (hblkhd):      %d\\en\", mi.hblkhd);\n"
"    printf(\"Max. total allocated space (usmblks):  %d\\en\", mi.usmblks);\n"
"    printf(\"Free bytes held in fastbins (fsmblks): %d\\en\", mi.fsmblks);\n"
"    printf(\"Total allocated space (uordblks):      %d\\en\", "
"mi.uordblks);\n"
"    printf(\"Total free space (fordblks):           %d\\en\", "
"mi.fordblks);\n"
"    printf(\"Topmost releasable block (keepcost):   %d\\en\", "
"mi.keepcost);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:274
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"#define MAX_ALLOCS 2000000\n"
"    char *alloc[MAX_ALLOCS];\n"
"    int numBlocks, freeBegin, freeEnd, freeStep;\n"
"    size_t blockSize;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:280
#, no-wrap
msgid ""
"    if (argc E<lt> 3 || strcmp(argv[1], \"--help\") == 0) {\n"
"        fprintf(stderr, \"%s num-blocks block-size [free-step \"\n"
"                \"[start-free [end-free]]]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:286
#, no-wrap
msgid ""
"    numBlocks = atoi(argv[1]);\n"
"    blockSize = atoi(argv[2]);\n"
"    freeStep = (argc E<gt> 3) ? atoi(argv[3]) : 1;\n"
"    freeBegin = (argc E<gt> 4) ? atoi(argv[4]) : 0;\n"
"    freeEnd = (argc E<gt> 5) ? atoi(argv[5]) : numBlocks;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:289
#, no-wrap
msgid ""
"    printf(\"============== Before allocating blocks "
"==============\\en\");\n"
"    display_mallinfo();\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:295
#, no-wrap
msgid ""
"    for (int j = 0; j E<lt> numBlocks; j++) {\n"
"        if (numBlocks E<gt>= MAX_ALLOCS) {\n"
"            fprintf(stderr, \"Too many allocations\\en\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:302
#, no-wrap
msgid ""
"        alloc[j] = malloc(blockSize);\n"
"        if (alloc[j] == NULL) {\n"
"            perror(\"malloc\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:305
#, no-wrap
msgid ""
"    printf(\"\\en============== After allocating blocks "
"==============\\en\");\n"
"    display_mallinfo();\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:308
#, no-wrap
msgid ""
"    for (int j = freeBegin; j E<lt> freeEnd; j += freeStep)\n"
"        free(alloc[j]);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:311
#, no-wrap
msgid ""
"    printf(\"\\en============== After freeing blocks "
"==============\\en\");\n"
"    display_mallinfo();\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:314 build/C/man3/malloc_info.3:265 build/C/man3/mallopt.3:612 build/C/man3/mcheck.3:224 build/C/man2/mmap.2:993 build/C/man3/shm_open.3:423 build/C/man3/shm_open.3:503 build/C/man2/shmop.2:435 build/C/man2/shmop.2:498 build/C/man2/memfd_create.2:493 build/C/man2/memfd_create.2:545 build/C/man2/membarrier.2:380 build/C/man2/membarrier.2:469 build/C/man7/pkeys.7:291
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:324
msgid ""
"B<mmap>(2), B<malloc>(3), B<malloc_info>(3), B<malloc_stats>(3), "
"B<malloc_trim>(3), B<mallopt>(3)"
msgstr ""

#. type: TH
#: build/C/man3/malloc_get_state.3:25
#, no-wrap
msgid "MALLOC_GET_STATE"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_get_state.3:28
msgid ""
"malloc_get_state, malloc_set_state - record and restore state of malloc "
"implementation"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_get_state.3:31 build/C/man3/malloc_hook.3:18 build/C/man3/malloc_info.3:31 build/C/man3/posix_memalign.3:41
#, no-wrap
msgid "B<#include E<lt>malloc.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_get_state.3:33
#, no-wrap
msgid "B<void *malloc_get_state(void);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_get_state.3:35
#, no-wrap
msgid "B<int malloc_set_state(void *>I<state>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_get_state.3:39
msgid "I<Note>: these function are removed in glibc version 2.25."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_get_state.3:56
msgid ""
"The B<malloc_get_state>()  function records the current state of all "
"B<malloc>(3)  internal bookkeeping variables (but not the actual contents of "
"the heap or the state of B<malloc_hook>(3)  functions pointers).  The state "
"is recorded in a system-dependent opaque data structure dynamically "
"allocated via B<malloc>(3), and a pointer to that data structure is returned "
"as the function result.  (It is the caller's responsibility to B<free>(3)  "
"this memory.)"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_get_state.3:64
msgid ""
"The B<malloc_set_state>()  function restores the state of all B<malloc>(3)  "
"internal bookkeeping variables to the values recorded in the opaque data "
"structure pointed to by I<state>."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_get_state.3:71
msgid ""
"On success, B<malloc_get_state>()  returns a pointer to a newly allocated "
"opaque data structure.  On error (for example, memory could not be allocated "
"for the data structure), B<malloc_get_state>()  returns NULL."
msgstr ""

#.  if(ms->magic != MALLOC_STATE_MAGIC) return -1;
#.  /* Must fail if the major version is too high. */
#.  if((ms->version & ~0xffl) > (MALLOC_STATE_VERSION & ~0xffl)) return -2;
#. type: Plain text
#: build/C/man3/malloc_get_state.3:89
msgid ""
"On success, B<malloc_set_state>()  returns 0.  If the implementation detects "
"that I<state> does not point to a correctly formed data structure, "
"B<malloc_set_state>()  returns -1.  If the implementation detects that the "
"version of the data structure referred to by I<state> is a more recent "
"version than this implementation knows about, B<malloc_set_state>()  returns "
"-2."
msgstr ""

#. type: tbl table
#: build/C/man3/malloc_get_state.3:100
#, no-wrap
msgid ""
"B<malloc_get_state>(),\n"
"B<malloc_set_state>()"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_get_state.3:105 build/C/man3/malloc_hook.3:84 build/C/man3/mcheck.3:168 build/C/man3/mtrace.3:102
msgid "These functions are GNU extensions."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_get_state.3:111
msgid ""
"These functions are useful when using this B<malloc>(3)  implementation as "
"part of a shared library, and the heap contents are saved/restored via some "
"other method.  This technique is used by GNU Emacs to implement its "
"\"dumping\" function."
msgstr ""

#.  i.e., calls __malloc_check_init()
#.  i.e., malloc checking is not already in use
#.  and the caller requested malloc checking
#. type: Plain text
#: build/C/man3/malloc_get_state.3:128
msgid ""
"Hook function pointers are never saved or restored by these functions, with "
"two exceptions: if malloc checking (see B<mallopt>(3))  was in use when "
"B<malloc_get_state>()  was called, then B<malloc_set_state>()  resets malloc "
"checking hooks if possible; if malloc checking was not in use in the "
"recorded state, but the caller has requested malloc checking, then the hooks "
"are reset to 0."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_get_state.3:131
msgid "B<malloc>(3), B<mallopt>(3)"
msgstr ""

#. type: TH
#: build/C/man3/malloc_hook.3:10
#, no-wrap
msgid "MALLOC_HOOK"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:15
msgid ""
"__malloc_hook, __malloc_initialize_hook, __memalign_hook, __free_hook, "
"__realloc_hook, __after_morecore_hook - malloc debugging variables"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:20
#, no-wrap
msgid "B<void *(*__malloc_hook)(size_t >I<size>B<, const void *>I<caller>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:23
#, no-wrap
msgid ""
"B<void *(*__realloc_hook)(void *>I<ptr>B<, size_t >I<size>B<, const void "
"*>I<caller>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:26
#, no-wrap
msgid ""
"B<void *(*__memalign_hook)(size_t >I<alignment>B<, size_t >I<size>B<,>\n"
"B<                         const void *>I<caller>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:28
#, no-wrap
msgid "B<void (*__free_hook)(void *>I<ptr>B<, const void *>I<caller>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:30
#, no-wrap
msgid "B<void (*__malloc_initialize_hook)(void);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:32
#, no-wrap
msgid "B<void (*__after_morecore_hook)(void);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:43
msgid ""
"The GNU C library lets you modify the behavior of B<malloc>(3), "
"B<realloc>(3), and B<free>(3)  by specifying appropriate hook functions.  "
"You can use these hooks to help you debug programs that use dynamic memory "
"allocation, for example."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:50
msgid ""
"The variable B<__malloc_initialize_hook> points at a function that is called "
"once when the malloc implementation is initialized.  This is a weak "
"variable, so it can be overridden in the application with a definition like "
"the following:"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:54
#, no-wrap
msgid "void (*__malloc_initialize_hook)(void) = my_init_hook;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:60
msgid "Now the function I<my_init_hook>()  can do the initialization of all hooks."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:76
msgid ""
"The four functions pointed to by B<__malloc_hook>, B<__realloc_hook>, "
"B<__memalign_hook>, B<__free_hook> have a prototype like the functions "
"B<malloc>(3), B<realloc>(3), B<memalign>(3), B<free>(3), respectively, "
"except that they have a final argument I<caller> that gives the address of "
"the caller of B<malloc>(3), etc."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:82
msgid ""
"The variable B<__after_morecore_hook> points at a function that is called "
"each time after B<sbrk>(2)  was asked for more memory."
msgstr ""

#.  https://bugzilla.redhat.com/show_bug.cgi?id=450187
#.  http://sourceware.org/bugzilla/show_bug.cgi?id=9957
#. type: Plain text
#: build/C/man3/malloc_hook.3:94
msgid ""
"The use of these hook functions is not safe in multithreaded programs, and "
"they are now deprecated.  From glibc 2.24 onwards, the "
"B<__malloc_initialize_hook> variable has been removed from the API.  "
"Programmers should instead preempt calls to the relevant functions by "
"defining and exporting functions such as \"malloc\" and \"free\"."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:96
msgid "Here is a short example of how to use these variables."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:100
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>malloc.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:104
#, no-wrap
msgid ""
"/* Prototypes for our hooks.  */\n"
"static void my_init_hook(void);\n"
"static void *my_malloc_hook(size_t, const void *);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:107
#, no-wrap
msgid ""
"/* Variables to save original hooks. */\n"
"static void *(*old_malloc_hook)(size_t, const void *);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:110
#, no-wrap
msgid ""
"/* Override initializing hook from the C library. */\n"
"void (*__malloc_initialize_hook) (void) = my_init_hook;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:117
#, no-wrap
msgid ""
"static void\n"
"my_init_hook(void)\n"
"{\n"
"    old_malloc_hook = __malloc_hook;\n"
"    __malloc_hook = my_malloc_hook;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:122
#, no-wrap
msgid ""
"static void *\n"
"my_malloc_hook(size_t size, const void *caller)\n"
"{\n"
"    void *result;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:125
#, no-wrap
msgid ""
"    /* Restore all old hooks */\n"
"    __malloc_hook = old_malloc_hook;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:128
#, no-wrap
msgid ""
"    /* Call recursively */\n"
"    result = malloc(size);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:131
#, no-wrap
msgid ""
"    /* Save underlying hooks */\n"
"    old_malloc_hook = __malloc_hook;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:135
#, no-wrap
msgid ""
"    /* printf() might call malloc(), so protect it too. */\n"
"    printf(\"malloc(%zu) called from %p returns %p\\en\",\n"
"            size, caller, result);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:138
#, no-wrap
msgid ""
"    /* Restore our own hooks */\n"
"    __malloc_hook = my_malloc_hook;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:141
#, no-wrap
msgid ""
"    return result;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:147
msgid "B<mallinfo>(3), B<malloc>(3), B<mcheck>(3), B<mtrace>(3)"
msgstr ""

#. type: TH
#: build/C/man3/malloc_info.3:25
#, no-wrap
msgid "MALLOC_INFO"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:28
msgid "malloc_info - export malloc state to a stream"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:33
#, no-wrap
msgid "B<int malloc_info(int >I<options>B<, FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:44
msgid ""
"The B<malloc_info>()  function exports an XML string that describes the "
"current state of the memory-allocation implementation in the caller.  The "
"string is printed on the file stream I<stream>.  The exported string "
"includes information about all arenas (see B<malloc>(3))."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:48
msgid "As currently implemented, I<options> must be zero."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:55
msgid ""
"On success, B<malloc_info>()  returns 0; on error, it returns -1, with "
"I<errno> set to indicate the cause."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:60
msgid "I<options> was nonzero."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:63
msgid "B<malloc_info>()  was added to glibc in version 2.10."
msgstr ""

#. type: tbl table
#: build/C/man3/malloc_info.3:73
#, no-wrap
msgid "B<malloc_info>()"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:78 build/C/man3/malloc_stats.3:69 build/C/man3/malloc_trim.3:76 build/C/man3/malloc_usable_size.3:62
msgid "This function is a GNU extension."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:84
msgid ""
"The memory-allocation information is provided as an XML string (rather than "
"a C structure)  because the information may change over time (according to "
"changes in the underlying implementation).  The output XML string includes a "
"version field."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:90
msgid ""
"The B<open_memstream>(3)  function can be used to send the output of "
"B<malloc_info>()  directly into a buffer in memory, rather than to a file."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:97
msgid ""
"The B<malloc_info>()  function is designed to address deficiencies in "
"B<malloc_stats>(3)  and B<mallinfo>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:108
msgid ""
"The program below takes up to four command-line arguments, of which the "
"first three are mandatory.  The first argument specifies the number of "
"threads that the program should create.  All of the threads, including the "
"main thread, allocate the number of blocks of memory specified by the second "
"argument.  The third argument controls the size of the blocks to be "
"allocated.  The main thread creates blocks of this size, the second thread "
"created by the program allocates blocks of twice this size, the third thread "
"allocates blocks of three times this size, and so on."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:115
msgid ""
"The program calls B<malloc_info>()  twice to display the memory-allocation "
"state.  The first call takes place before any threads are created or memory "
"allocated.  The second call is performed after all threads have allocated "
"memory."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:123
msgid ""
"In the following example, the command-line arguments specify the creation of "
"one additional thread, and both the main thread and the additional thread "
"allocate 10000 blocks of memory.  After the blocks of memory have been "
"allocated, B<malloc_info>()  shows the state of two allocation arenas."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:148
#, no-wrap
msgid ""
"$ B<getconf GNU_LIBC_VERSION>\n"
"glibc 2.13\n"
"$ B<./a.out 1 10000 100>\n"
"============ Before allocating blocks ============\n"
"E<lt>malloc version=\"1\"E<gt>\n"
"E<lt>heap nr=\"0\"E<gt>\n"
"E<lt>sizesE<gt>\n"
"E<lt>/sizesE<gt>\n"
"E<lt>total type=\"fast\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>total type=\"rest\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>system type=\"current\" size=\"135168\"/E<gt>\n"
"E<lt>system type=\"max\" size=\"135168\"/E<gt>\n"
"E<lt>aspace type=\"total\" size=\"135168\"/E<gt>\n"
"E<lt>aspace type=\"mprotect\" size=\"135168\"/E<gt>\n"
"E<lt>/heapE<gt>\n"
"E<lt>total type=\"fast\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>total type=\"rest\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>system type=\"current\" size=\"135168\"/E<gt>\n"
"E<lt>system type=\"max\" size=\"135168\"/E<gt>\n"
"E<lt>aspace type=\"total\" size=\"135168\"/E<gt>\n"
"E<lt>aspace type=\"mprotect\" size=\"135168\"/E<gt>\n"
"E<lt>/mallocE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:178
#, no-wrap
msgid ""
"============ After allocating blocks ============\n"
"E<lt>malloc version=\"1\"E<gt>\n"
"E<lt>heap nr=\"0\"E<gt>\n"
"E<lt>sizesE<gt>\n"
"E<lt>/sizesE<gt>\n"
"E<lt>total type=\"fast\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>total type=\"rest\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>system type=\"current\" size=\"1081344\"/E<gt>\n"
"E<lt>system type=\"max\" size=\"1081344\"/E<gt>\n"
"E<lt>aspace type=\"total\" size=\"1081344\"/E<gt>\n"
"E<lt>aspace type=\"mprotect\" size=\"1081344\"/E<gt>\n"
"E<lt>/heapE<gt>\n"
"E<lt>heap nr=\"1\"E<gt>\n"
"E<lt>sizesE<gt>\n"
"E<lt>/sizesE<gt>\n"
"E<lt>total type=\"fast\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>total type=\"rest\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>system type=\"current\" size=\"1032192\"/E<gt>\n"
"E<lt>system type=\"max\" size=\"1032192\"/E<gt>\n"
"E<lt>aspace type=\"total\" size=\"1032192\"/E<gt>\n"
"E<lt>aspace type=\"mprotect\" size=\"1032192\"/E<gt>\n"
"E<lt>/heapE<gt>\n"
"E<lt>total type=\"fast\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>total type=\"rest\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>system type=\"current\" size=\"2113536\"/E<gt>\n"
"E<lt>system type=\"max\" size=\"2113536\"/E<gt>\n"
"E<lt>aspace type=\"total\" size=\"2113536\"/E<gt>\n"
"E<lt>aspace type=\"mprotect\" size=\"2113536\"/E<gt>\n"
"E<lt>/mallocE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:187
#, no-wrap
msgid ""
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>malloc.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:190
#, no-wrap
msgid ""
"static size_t blockSize;\n"
"static int numThreads, numBlocks;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:193 build/C/man3/shm_open.3:324 build/C/man2/shmop.2:349 build/C/man2/memfd_create.2:421 build/C/man2/memfd_create.2:507
#, no-wrap
msgid ""
"#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                        } while (0)\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:198
#, no-wrap
msgid ""
"static void *\n"
"thread_func(void *arg)\n"
"{\n"
"    int tn = (int) arg;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:201
#, no-wrap
msgid ""
"    /* The multiplier \\(aq(2 + tn)\\(aq ensures that each thread "
"(including\n"
"       the main thread) allocates a different amount of memory */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:205
#, no-wrap
msgid ""
"    for (int j = 0; j E<lt> numBlocks; j++)\n"
"        if (malloc(blockSize * (2 + tn)) == NULL)\n"
"            errExit(\"malloc-thread\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:209
#, no-wrap
msgid ""
"    sleep(100);         /* Sleep until main thread terminates */\n"
"    return NULL;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:214
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int sleepTime;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:221
#, no-wrap
msgid ""
"    if (argc E<lt> 4) {\n"
"        fprintf(stderr,\n"
"                \"%s num-threads num-blocks block-size [sleep-time]\\en\",\n"
"                argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:226
#, no-wrap
msgid ""
"    numThreads = atoi(argv[1]);\n"
"    numBlocks = atoi(argv[2]);\n"
"    blockSize = atoi(argv[3]);\n"
"    sleepTime = (argc E<gt> 4) ? atoi(argv[4]) : 0;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:230
#, no-wrap
msgid ""
"    pthread_t *thr = calloc(numThreads, sizeof(*thr));\n"
"    if (thr == NULL)\n"
"        errExit(\"calloc\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:233
#, no-wrap
msgid ""
"    printf(\"============ Before allocating blocks ============\\en\");\n"
"    malloc_info(0, stdout);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:235
#, no-wrap
msgid "    /* Create threads that allocate different amounts of memory */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:241
#, no-wrap
msgid ""
"    for (int tn = 0; tn E<lt> numThreads; tn++) {\n"
"        errno = pthread_create(&thr[tn], NULL, thread_func,\n"
"                               (void *) tn);\n"
"        if (errno != 0)\n"
"            errExit(\"pthread_create\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:246
#, no-wrap
msgid ""
"        /* If we add a sleep interval after the start-up of each\n"
"           thread, the threads likely won\\(aqt contend for malloc\n"
"           mutexes, and therefore additional arenas won\\(aqt be\n"
"           allocated (see malloc(3)). */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:250
#, no-wrap
msgid ""
"        if (sleepTime E<gt> 0)\n"
"            sleep(sleepTime);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:252
#, no-wrap
msgid "    /* The main thread also allocates some memory */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:256
#, no-wrap
msgid ""
"    for (int j = 0; j E<lt> numBlocks; j++)\n"
"        if (malloc(blockSize) == NULL)\n"
"            errExit(\"malloc\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:259
#, no-wrap
msgid ""
"    sleep(2);           /* Give all threads a chance to\n"
"                           complete allocations */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:262
#, no-wrap
msgid ""
"    printf(\"\\en============ After allocating blocks ============\\en\");\n"
"    malloc_info(0, stdout);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:272
msgid ""
"B<mallinfo>(3), B<malloc>(3), B<malloc_stats>(3), B<mallopt>(3), "
"B<open_memstream>(3)"
msgstr ""

#. type: TH
#: build/C/man3/malloc_stats.3:25
#, no-wrap
msgid "MALLOC_STATS"
msgstr ""

#. type: TH
#: build/C/man3/malloc_stats.3:25 build/C/man3/malloc_trim.3:25 build/C/man7/shm_overview.7:26
#, no-wrap
msgid "2020-08-13"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_stats.3:28
msgid "malloc_stats - print memory allocation statistics"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_stats.3:32
msgid "B<void malloc_stats(void);>"
msgstr ""

#.  .SH VERSIONS
#.  Available already in glibc 2.0, possibly earlier
#. type: Plain text
#: build/C/man3/malloc_stats.3:54
msgid ""
"The B<malloc_stats>()  function prints (on standard error) statistics about "
"memory allocated by B<malloc>(3)  and related functions.  For each arena "
"(allocation area), this function prints the total amount of memory allocated "
"and the total number of bytes consumed by in-use allocations.  (These two "
"values correspond to the I<arena> and I<uordblks> fields retrieved by "
"B<mallinfo>(3).)  In addition, the function prints the sum of these two "
"statistics for all arenas, and the maximum number of blocks and bytes that "
"were ever simultaneously allocated using B<mmap>(2)."
msgstr ""

#. type: tbl table
#: build/C/man3/malloc_stats.3:64
#, no-wrap
msgid "B<malloc_stats>()"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_stats.3:73
msgid ""
"More detailed information about memory allocations in the main arena can be "
"obtained using B<mallinfo>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_stats.3:79
msgid "B<mmap>(2), B<mallinfo>(3), B<malloc>(3), B<malloc_info>(3), B<mallopt>(3)"
msgstr ""

#. type: TH
#: build/C/man3/malloc_trim.3:25
#, no-wrap
msgid "MALLOC_TRIM"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_trim.3:28
msgid "malloc_trim - release free memory from the heap"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_trim.3:32
msgid "B<int malloc_trim(size_t >I<pad>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_trim.3:41
msgid ""
"The B<malloc_trim>()  function attempts to release free memory from the heap "
"(by calling B<sbrk>(2)  or B<madvise>(2)  with suitable arguments)."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_trim.3:52
msgid ""
"The I<pad> argument specifies the amount of free space to leave untrimmed at "
"the top of the heap.  If this argument is 0, only the minimum amount of "
"memory is maintained at the top of the heap (i.e., one page or less).  A "
"nonzero argument can be used to maintain some trailing space at the top of "
"the heap in order to allow future allocations to be made without having to "
"extend the heap with B<sbrk>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_trim.3:57
msgid ""
"The B<malloc_trim>()  function returns 1 if memory was actually released "
"back to the system, or 0 if it was not possible to release any memory."
msgstr ""

#.  .SH VERSIONS
#.  Available already in glibc 2.0, possibly earlier
#. type: Plain text
#: build/C/man3/malloc_trim.3:61
msgid "No errors are defined."
msgstr ""

#. type: tbl table
#: build/C/man3/malloc_trim.3:71
#, no-wrap
msgid "B<malloc_trim>()"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_trim.3:85
msgid ""
"This function is automatically called by B<free>(3)  in certain "
"circumstances; see the discussion of B<M_TOP_PAD> and B<M_TRIM_THRESHOLD> in "
"B<mallopt>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_trim.3:91
msgid ""
"Only the main heap (using B<sbrk>(2))  honors the I<pad> argument; thread "
"heaps do not."
msgstr ""

#.  See commit 68631c8eb92ff38d9da1ae34f6aa048539b199cc
#.  (dated 2007-12-16) which adds iteration over all
#.  arenas and frees all pages in chunks which are free.
#. type: Plain text
#: build/C/man3/malloc_trim.3:97
msgid ""
"Since glibc 2.8 this function frees memory in all arenas and in all chunks "
"with whole free pages."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_trim.3:100
msgid ""
"Before glibc 2.8 this function only freed memory at the top of the heap in "
"the main arena."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_trim.3:104
msgid "B<sbrk>(2), B<malloc>(3), B<mallopt>(3)"
msgstr ""

#. type: TH
#: build/C/man3/malloc_usable_size.3:25
#, no-wrap
msgid "MALLOC_USABLE_SIZE"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_usable_size.3:28
msgid "malloc_usable_size - obtain size of block of memory allocated from heap"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_usable_size.3:32
msgid "B<size_t malloc_usable_size (void *>I<ptr>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_usable_size.3:40
msgid ""
"The B<malloc_usable_size>()  function returns the number of usable bytes in "
"the block pointed to by I<ptr>, a pointer to a block of memory allocated by "
"B<malloc>(3)  or a related function."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_usable_size.3:48
msgid ""
"B<malloc_usable_size>()  returns the number of usable bytes in the block of "
"allocated memory pointed to by I<ptr>.  If I<ptr> is NULL, 0 is returned."
msgstr ""

#. type: tbl table
#: build/C/man3/malloc_usable_size.3:58
#, no-wrap
msgid "B<malloc_usable_size>()"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_usable_size.3:72
msgid ""
"The value returned by B<malloc_usable_size>()  may be greater than the "
"requested size of the allocation because of alignment and minimum size "
"constraints.  Although the excess bytes can be overwritten by the "
"application without ill effects, this is not good programming practice: the "
"number of excess bytes in an allocation depends on the underlying "
"implementation."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_usable_size.3:74
msgid "The main use of this function is for debugging and introspection."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_usable_size.3:76
msgid "B<malloc>(3)"
msgstr ""

#. type: TH
#: build/C/man3/mallopt.3:25
#, no-wrap
msgid "MALLOPT"
msgstr ""

#. type: TH
#: build/C/man3/mallopt.3:25 build/C/man3/mcheck.3:25 build/C/man2/mremap.2:30 build/C/man2/msync.2:25 build/C/man2/pkey_alloc.2:25 build/C/man7/pkeys.7:25
#, no-wrap
msgid "2020-06-09"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:28
msgid "mallopt - set memory allocation parameters"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:32
msgid "B<int mallopt(int >I<param>B<, int >I<value>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:43
msgid ""
"The B<mallopt>()  function adjusts parameters that control the behavior of "
"the memory-allocation functions (see B<malloc>(3)).  The I<param> argument "
"specifies the parameter to be modified, and I<value> specifies the new value "
"for that parameter."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:46
msgid "The following values can be specified for I<param>:"
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:46
#, no-wrap
msgid "B<M_ARENA_MAX>"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:58
msgid ""
"If this parameter has a nonzero value, it defines a hard limit on the "
"maximum number of arenas that can be created.  An arena represents a pool of "
"memory that can be used by B<malloc>(3)  (and similar) calls to service "
"allocation requests.  Arenas are thread safe and therefore may have multiple "
"concurrent memory requests.  The trade-off is between the number of threads "
"and the number of arenas.  The more arenas you have, the lower the "
"per-thread contention, but the higher the memory usage."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:63
msgid ""
"The default value of this parameter is 0, meaning that the limit on the "
"number of arenas is determined according to the setting of B<M_ARENA_TEST>."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:69
msgid ""
"This parameter has been available since glibc 2.10 via "
"B<--enable-experimental-malloc>, and since glibc 2.15 by default.  In some "
"versions of the allocator there was no limit on the number of created arenas "
"(e.g., CentOS 5, RHEL 5)."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:77
msgid ""
"When employing newer glibc versions, applications may in some cases exhibit "
"high contention when accessing arenas.  In these cases, it may be beneficial "
"to increase B<M_ARENA_MAX> to match the number of threads.  This is similar "
"in behavior to strategies taken by tcmalloc and jemalloc (e.g., per-thread "
"allocation pools)."
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:77
#, no-wrap
msgid "B<M_ARENA_TEST>"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:85
msgid ""
"This parameter specifies a value, in number of arenas created, at which "
"point the system configuration will be examined to determine a hard limit on "
"the number of created arenas.  (See B<M_ARENA_MAX> for the definition of an "
"arena.)"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:90
msgid ""
"The computation of the arena hard limit is implementation-defined and is "
"usually calculated as a multiple of the number of available CPUs.  Once the "
"hard limit is computed, the result is final and constrains the total number "
"of arenas."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:96
msgid ""
"The default value for the B<M_ARENA_TEST> parameter is 2 on systems where "
"I<sizeof(long)> is 4; otherwise the default value is 8."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:100
msgid ""
"This parameter has been available since glibc 2.10 via "
"B<--enable-experimental-malloc>, and since glibc 2.15 by default."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:106
msgid ""
"The value of B<M_ARENA_TEST> is not used when B<M_ARENA_MAX> has a nonzero "
"value."
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:106
#, no-wrap
msgid "B<M_CHECK_ACTION>"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:112
msgid ""
"Setting this parameter controls how glibc responds when various kinds of "
"programming errors are detected (e.g., freeing the same pointer twice).  The "
"3 least significant bits (2, 1, and 0) of the value assigned to this "
"parameter determine the glibc behavior, as follows:"
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:113
#, no-wrap
msgid "Bit 0"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:123
msgid ""
"If this bit is set, then print a one-line message on I<stderr> that provides "
"details about the error.  The message starts with the string \"***\\ glibc "
"detected\\ ***\", followed by the program name, the name of the "
"memory-allocation function in which the error was detected, a brief "
"description of the error, and the memory address where the error was "
"detected."
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:123
#, no-wrap
msgid "Bit 1"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:138
msgid ""
"If this bit is set, then, after printing any error message specified by bit "
"0, the program is terminated by calling B<abort>(3).  In glibc versions "
"since 2.4, if bit 0 is also set, then, between printing the error message "
"and aborting, the program also prints a stack trace in the manner of "
"B<backtrace>(3), and prints the process's memory mapping in the style of "
"I</proc/[pid]/maps> (see B<proc>(5))."
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:138
#, no-wrap
msgid "Bit 2 (since glibc 2.4)"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:145
msgid ""
"This bit has an effect only if bit 0 is also set.  If this bit is set, then "
"the one-line message describing the error is simplified to contain just the "
"name of the function where the error was detected and the brief description "
"of the error."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:150
msgid "The remaining bits in I<value> are ignored."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:154
msgid ""
"Combining the above details, the following numeric values are meaningful for "
"B<M_CHECK_ACTION>:"
msgstr ""

#. type: IP
#: build/C/man3/mallopt.3:155
#, no-wrap
msgid "0"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:157
msgid "Ignore error conditions; continue execution (with undefined results)."
msgstr ""

#. type: IP
#: build/C/man3/mallopt.3:157
#, no-wrap
msgid "1"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:159
msgid "Print a detailed error message and continue execution."
msgstr ""

#. type: IP
#: build/C/man3/mallopt.3:159
#, no-wrap
msgid "2"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:161
msgid "Abort the program."
msgstr ""

#. type: IP
#: build/C/man3/mallopt.3:161
#, no-wrap
msgid "3"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:164
msgid ""
"Print detailed error message, stack trace, and memory mappings, and abort "
"the program."
msgstr ""

#. type: IP
#: build/C/man3/mallopt.3:164
#, no-wrap
msgid "5"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:166
msgid "Print a simple error message and continue execution."
msgstr ""

#. type: IP
#: build/C/man3/mallopt.3:166
#, no-wrap
msgid "7"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:169
msgid ""
"Print simple error message, stack trace, and memory mappings, and abort the "
"program."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:175
msgid ""
"Since glibc 2.3.4, the default value for the B<M_CHECK_ACTION> parameter is "
"3.  In glibc version 2.3.3 and earlier, the default value is 1."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:180
msgid ""
"Using a nonzero B<M_CHECK_ACTION> value can be useful because otherwise a "
"crash may happen much later, and the true cause of the problem is then very "
"hard to track down."
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:180
#, no-wrap
msgid "B<M_MMAP_MAX>"
msgstr ""

#.  The following text adapted from comments in the glibc source:
#. type: Plain text
#: build/C/man3/mallopt.3:190
msgid ""
"This parameter specifies the maximum number of allocation requests that may "
"be simultaneously serviced using B<mmap>(2).  This parameter exists because "
"some systems have a limited number of internal tables for use by B<mmap>(2), "
"and using more than a few of them may degrade performance."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:197
msgid ""
"The default value is 65,536, a value which has no special significance and "
"which serves only as a safeguard.  Setting this parameter to 0 disables the "
"use of B<mmap>(2)  for servicing large allocation requests."
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:197
#, no-wrap
msgid "B<M_MMAP_THRESHOLD>"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:206
msgid ""
"For allocations greater than or equal to the limit specified (in bytes) by "
"B<M_MMAP_THRESHOLD> that can't be satisfied from the free list, the "
"memory-allocation functions employ B<mmap>(2)  instead of increasing the "
"program break using B<sbrk>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:226
msgid ""
"Allocating memory using B<mmap>(2)  has the significant advantage that the "
"allocated memory blocks can always be independently released back to the "
"system.  (By contrast, the heap can be trimmed only if memory is freed at "
"the top end.)  On the other hand, there are some disadvantages to the use of "
"B<mmap>(2): deallocated space is not placed on the free list for reuse by "
"later allocations; memory may be wasted because B<mmap>(2)  allocations must "
"be page-aligned; and the kernel must perform the expensive task of zeroing "
"out memory allocated via B<mmap>(2).  Balancing these factors leads to a "
"default setting of 128*1024 for the B<M_MMAP_THRESHOLD> parameter."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:233
msgid ""
"The lower limit for this parameter is 0.  The upper limit is "
"B<DEFAULT_MMAP_THRESHOLD_MAX>: 512*1024 on 32-bit systems or "
"I<4*1024*1024*sizeof(long)> on 64-bit systems."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:251
msgid ""
"I<Note:> Nowadays, glibc uses a dynamic mmap threshold by default.  The "
"initial value of the threshold is 128*1024, but when blocks larger than the "
"current threshold and less than or equal to B<DEFAULT_MMAP_THRESHOLD_MAX> "
"are freed, the threshold is adjusted upward to the size of the freed block.  "
"When dynamic mmap thresholding is in effect, the threshold for trimming the "
"heap is also dynamically adjusted to be twice the dynamic mmap threshold.  "
"Dynamic adjustment of the mmap threshold is disabled if any of the "
"B<M_TRIM_THRESHOLD>, B<M_TOP_PAD>, B<M_MMAP_THRESHOLD>, or B<M_MMAP_MAX> "
"parameters is set."
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:251
#, no-wrap
msgid "B<M_MXFAST> (since glibc 2.3)"
msgstr ""

#.  The following text adapted from comments in the glibc sources:
#. type: Plain text
#: build/C/man3/mallopt.3:263
msgid ""
"Set the upper limit for memory allocation requests that are satisfied using "
"\"fastbins\".  (The measurement unit for this parameter is bytes.)  Fastbins "
"are storage areas that hold deallocated blocks of memory of the same size "
"without merging adjacent free blocks.  Subsequent reallocation of blocks of "
"the same size can be handled very quickly by allocating from the fastbin, "
"although memory fragmentation and the overall memory footprint of the "
"program can increase."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:272
msgid ""
"The default value for this parameter is I<64*sizeof(size_t)/4> (i.e., 64 on "
"32-bit architectures).  The range for this parameter is 0 to "
"I<80*sizeof(size_t)/4>.  Setting B<M_MXFAST> to 0 disables the use of "
"fastbins."
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:272
#, no-wrap
msgid "B<M_PERTURB> (since glibc 2.4)"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:287
msgid ""
"If this parameter is set to a nonzero value, then bytes of allocated memory "
"(other than allocations via B<calloc>(3))  are initialized to the complement "
"of the value in the least significant byte of I<value>, and when allocated "
"memory is released using B<free>(3), the freed bytes are set to the least "
"significant byte of I<value>.  This can be useful for detecting errors where "
"programs incorrectly rely on allocated memory being initialized to zero, or "
"reuse values in memory that has already been freed."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:289
msgid "The default value for this parameter is 0."
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:289
#, no-wrap
msgid "B<M_TOP_PAD>"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:296
msgid ""
"This parameter defines the amount of padding to employ when calling "
"B<sbrk>(2)  to modify the program break.  (The measurement unit for this "
"parameter is bytes.)  This parameter has an effect in the following "
"circumstances:"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:303
msgid ""
"When the program break is increased, then B<M_TOP_PAD> bytes are added to "
"the B<sbrk>(2)  request."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:309
msgid ""
"When the heap is trimmed as a consequence of calling B<free>(3)  (see the "
"discussion of B<M_TRIM_THRESHOLD>)  this much free space is preserved at the "
"top of the heap."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:313
msgid ""
"In either case, the amount of padding is always rounded to a system page "
"boundary."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:320
msgid ""
"Modifying B<M_TOP_PAD> is a trade-off between increasing the number of "
"system calls (when the parameter is set low)  and wasting unused memory at "
"the top of the heap (when the parameter is set high)."
msgstr ""

#.  DEFAULT_TOP_PAD in glibc source
#. type: Plain text
#: build/C/man3/mallopt.3:323
msgid "The default value for this parameter is 128*1024."
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:323
#, no-wrap
msgid "B<M_TRIM_THRESHOLD>"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:339
msgid ""
"When the amount of contiguous free memory at the top of the heap grows "
"sufficiently large, B<free>(3)  employs B<sbrk>(2)  to release this memory "
"back to the system.  (This can be useful in programs that continue to "
"execute for a long period after freeing a significant amount of memory.)  "
"The B<M_TRIM_THRESHOLD> parameter specifies the minimum size (in bytes) that "
"this block of memory must reach before B<sbrk>(2)  is used to trim the heap."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:344
msgid ""
"The default value for this parameter is 128*1024.  Setting "
"B<M_TRIM_THRESHOLD> to -1 disables trimming completely."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:352
msgid ""
"Modifying B<M_TRIM_THRESHOLD> is a trade-off between increasing the number "
"of system calls (when the parameter is set low)  and wasting unused memory "
"at the top of the heap (when the parameter is set high)."
msgstr ""

#. type: SS
#: build/C/man3/mallopt.3:352
#, no-wrap
msgid "Environment variables"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:367
msgid ""
"A number of environment variables can be defined to modify some of the same "
"parameters as are controlled by B<mallopt>().  Using these variables has the "
"advantage that the source code of the program need not be changed.  To be "
"effective, these variables must be defined before the first call to a "
"memory-allocation function.  (If the same parameters are adjusted via "
"B<mallopt>(), then the B<mallopt>()  settings take precedence.)  For "
"security reasons, these variables are ignored in set-user-ID and "
"set-group-ID programs."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:370
msgid ""
"The environment variables are as follows (note the trailing underscore at "
"the end of the name of some variables):"
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:370
#, no-wrap
msgid "B<MALLOC_ARENA_MAX>"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:375
msgid "Controls the same parameter as B<mallopt>()  B<M_ARENA_MAX>."
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:375
#, no-wrap
msgid "B<MALLOC_ARENA_TEST>"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:380
msgid "Controls the same parameter as B<mallopt>()  B<M_ARENA_TEST>."
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:380
#, no-wrap
msgid "B<MALLOC_CHECK_>"
msgstr ""

#.  On glibc 2.12/x86, a simple malloc()+free() loop is about 70% slower
#.  when MALLOC_CHECK_ was set.
#. type: Plain text
#: build/C/man3/mallopt.3:397
msgid ""
"This environment variable controls the same parameter as B<mallopt>()  "
"B<M_CHECK_ACTION>.  If this variable is set to a nonzero value, then a "
"special implementation of the memory-allocation functions is used.  (This is "
"accomplished using the B<malloc_hook>(3)  feature.)  This implementation "
"performs additional error checking, but is slower than the standard set of "
"memory-allocation functions.  (This implementation does not detect all "
"possible errors; memory leaks can still occur.)"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:402
msgid ""
"The value assigned to this environment variable should be a single digit, "
"whose meaning is as described for B<M_CHECK_ACTION>.  Any characters beyond "
"the initial digit are ignored."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:411
msgid ""
"For security reasons, the effect of B<MALLOC_CHECK_> is disabled by default "
"for set-user-ID and set-group-ID programs.  However, if the file "
"I</etc/suid-debug> exists (the content of the file is irrelevant), then "
"B<MALLOC_CHECK_> also has an effect for set-user-ID and set-group-ID "
"programs."
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:411
#, no-wrap
msgid "B<MALLOC_MMAP_MAX_>"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:416
msgid "Controls the same parameter as B<mallopt>()  B<M_MMAP_MAX>."
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:416
#, no-wrap
msgid "B<MALLOC_MMAP_THRESHOLD_>"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:421
msgid "Controls the same parameter as B<mallopt>()  B<M_MMAP_THRESHOLD>."
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:421
#, no-wrap
msgid "B<MALLOC_PERTURB_>"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:426
msgid "Controls the same parameter as B<mallopt>()  B<M_PERTURB>."
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:426
#, no-wrap
msgid "B<MALLOC_TRIM_THRESHOLD_>"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:431
msgid "Controls the same parameter as B<mallopt>()  B<M_TRIM_THRESHOLD>."
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:431
#, no-wrap
msgid "B<MALLOC_TOP_PAD_>"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:436
msgid "Controls the same parameter as B<mallopt>()  B<M_TOP_PAD>."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:441
msgid "On success, B<mallopt>()  returns 1.  On error, it returns 0."
msgstr ""

#.  .SH VERSIONS
#.  Available already in glibc 2.0, possibly earlier
#. type: Plain text
#: build/C/man3/mallopt.3:449
msgid "On error, I<errno> is I<not> set."
msgstr ""

#.  .SH NOTES
#. type: Plain text
#: build/C/man3/mallopt.3:463
msgid ""
"This function is not specified by POSIX or the C standards.  A similar "
"function exists on many System V derivatives, but the range of values for "
"I<param> varies across systems.  The SVID defined options B<M_MXFAST>, "
"B<M_NLBLKS>, B<M_GRAIN>, and B<M_KEEP>, but only the first of these is "
"implemented in glibc."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:467
msgid "Specifying an invalid value for I<param> does not generate an error."
msgstr ""

#.  FIXME . This looks buggy:
#.  setting the M_MXFAST limit rounds up:    (s + SIZE_SZ) & ~MALLOC_ALIGN_MASK)
#.  malloc requests are rounded up:
#.     (req) + SIZE_SZ + MALLOC_ALIGN_MASK) & ~MALLOC_ALIGN_MASK
#.  http://sources.redhat.com/bugzilla/show_bug.cgi?id=12129
#. type: Plain text
#: build/C/man3/mallopt.3:475
msgid ""
"A calculation error within the glibc implementation means that a call of the "
"form:"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:479
#, no-wrap
msgid "mallopt(M_MXFAST, n)\n"
msgstr ""

#.  Bins are multiples of 2 * sizeof(size_t) + sizeof(size_t)
#. type: Plain text
#: build/C/man3/mallopt.3:492
msgid ""
"does not result in fastbins being employed for all allocations of size up to "
"I<n>.  To ensure desired results, I<n> should be rounded up to the next "
"multiple greater than or equal to I<(2k+1)*sizeof(size_t)>, where I<k> is an "
"integer."
msgstr ""

#.  FIXME . http://sources.redhat.com/bugzilla/show_bug.cgi?id=12140
#. type: Plain text
#: build/C/man3/mallopt.3:513
msgid ""
"If B<mallopt>()  is used to set B<M_PERTURB>, then, as expected, the bytes "
"of allocated memory are initialized to the complement of the byte in "
"I<value>, and when that memory is freed, the bytes of the region are "
"initialized to the byte specified in I<value>.  However, there is an "
"off-by-I<sizeof(size_t)> error in the implementation: instead of "
"initializing precisely the block of memory being freed by the call "
"I<free(p)>, the block starting at I<p+sizeof(size_t)> is initialized."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:522
msgid ""
"The program below demonstrates the use of B<M_CHECK_ACTION>.  If the program "
"is supplied with an (integer) command-line argument, then that argument is "
"used to set the B<M_CHECK_ACTION> parameter.  The program then allocates a "
"block of memory, and frees it twice (an error)."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:526
msgid ""
"The following shell session shows what happens when we run this program "
"under glibc, with the default value for B<M_CHECK_ACTION>:"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:546
#, no-wrap
msgid ""
"$ B<./a.out>\n"
"main(): returned from first free() call\n"
"*** glibc detected *** ./a.out: double free or corruption (top): 0x09d30008 "
"***\n"
"======= Backtrace: =========\n"
"/lib/libc.so.6(+0x6c501)[0x523501]\n"
"/lib/libc.so.6(+0x6dd70)[0x524d70]\n"
"/lib/libc.so.6(cfree+0x6d)[0x527e5d]\n"
"\\&./a.out[0x80485db]\n"
"/lib/libc.so.6(__libc_start_main+0xe7)[0x4cdce7]\n"
"\\&./a.out[0x8048471]\n"
"======= Memory map: ========\n"
"001e4000-001fe000 r-xp 00000000 08:06 1083555    /lib/libgcc_s.so.1\n"
"001fe000-001ff000 r--p 00019000 08:06 1083555    /lib/libgcc_s.so.1\n"
"[some lines omitted]\n"
"b7814000-b7817000 rw-p 00000000 00:00 0\n"
"bff53000-bff74000 rw-p 00000000 00:00 0          [stack]\n"
"Aborted (core dumped)\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:551
msgid ""
"The following runs show the results when employing other values for "
"B<M_CHECK_ACTION>:"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:564
#, no-wrap
msgid ""
"$ B<./a.out 1>             # Diagnose error and continue\n"
"main(): returned from first free() call\n"
"*** glibc detected *** ./a.out: double free or corruption (top): 0x09cbe008 "
"***\n"
"main(): returned from second free() call\n"
"$ B<./a.out 2>             # Abort without error message\n"
"main(): returned from first free() call\n"
"Aborted (core dumped)\n"
"$ B<./a.out 0>             # Ignore error and continue\n"
"main(): returned from first free() call\n"
"main(): returned from second free() call\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:570
msgid ""
"The next run shows how to set the same parameter using the B<MALLOC_CHECK_> "
"environment variable:"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:577
#, no-wrap
msgid ""
"$ B<MALLOC_CHECK_=1 ./a.out>\n"
"main(): returned from first free() call\n"
"*** glibc detected *** ./a.out: free(): invalid pointer: 0x092c2008 ***\n"
"main(): returned from second free() call\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:585
#, no-wrap
msgid ""
"#include E<lt>malloc.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:590 build/C/man3/mcheck.3:208
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *p;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:597
#, no-wrap
msgid ""
"    if (argc E<gt> 1) {\n"
"        if (mallopt(M_CHECK_ACTION, atoi(argv[1])) != 1) {\n"
"            fprintf(stderr, \"mallopt() failed\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:603
#, no-wrap
msgid ""
"    p = malloc(1000);\n"
"    if (p == NULL) {\n"
"        fprintf(stderr, \"malloc() failed\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:606
#, no-wrap
msgid ""
"    free(p);\n"
"    printf(\"main(): returned from first free() call\\en\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:609
#, no-wrap
msgid ""
"    free(p);\n"
"    printf(\"main(): returned from second free() call\\en\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:627
msgid ""
"B<mmap>(2), B<sbrk>(2), B<mallinfo>(3), B<malloc>(3), B<malloc_hook>(3), "
"B<malloc_info>(3), B<malloc_stats>(3), B<malloc_trim>(3), B<mcheck>(3), "
"B<mtrace>(3), B<posix_memalign>(3)"
msgstr ""

#. type: TH
#: build/C/man3/mcheck.3:25
#, no-wrap
msgid "MCHECK"
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:28
msgid ""
"mcheck, mcheck_check_all, mcheck_pedantic, mprobe - heap consistency "
"checking"
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:31
#, no-wrap
msgid "B<#include E<lt>mcheck.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:33
#, no-wrap
msgid "B<int mcheck(void (*>I<abortfunc>B<)(enum mcheck_status >I<mstatus>B<));>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:35
#, no-wrap
msgid ""
"B<int mcheck_pedantic(void (*>I<abortfunc>B<)(enum mcheck_status "
">I<mstatus>B<));>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:37
#, no-wrap
msgid "B<void mcheck_check_all(void);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:39
#, no-wrap
msgid "B<enum mcheck_status mprobe(void *>I<ptr>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:51
msgid ""
"The B<mcheck>()  function installs a set of debugging hooks for the "
"B<malloc>(3)  family of memory-allocation functions.  These hooks cause "
"certain consistency checks to be performed on the state of the heap.  The "
"checks can detect application errors such as freeing a block of memory more "
"than once or corrupting the bookkeeping data structures that immediately "
"precede a block of allocated memory."
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:63
msgid ""
"To be effective, the B<mcheck>()  function must be called before the first "
"call to B<malloc>(3)  or a related function.  In cases where this is "
"difficult to ensure, linking the program with I<-lmcheck> inserts an "
"implicit call to B<mcheck>()  (with a NULL argument)  before the first call "
"to a memory-allocation function."
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:71
msgid ""
"The B<mcheck_pedantic>()  function is similar to B<mcheck>(), but performs "
"checks on all allocated blocks whenever one of the memory-allocation "
"functions is called.  This can be very slow!"
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:78
msgid ""
"The B<mcheck_check_all>()  function causes an immediate check on all "
"allocated blocks.  This call is effective only if B<mcheck>()  is called "
"beforehand."
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:91
msgid ""
"If the system detects an inconsistency in the heap, the caller-supplied "
"function pointed to by I<abortfunc> is invoked with a single argument, "
"I<mstatus>, that indicates what type of inconsistency was detected.  If "
"I<abortfunc> is NULL, a default function prints an error message on "
"I<stderr> and calls B<abort>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:103
msgid ""
"The B<mprobe>()  function performs a consistency check on the block of "
"allocated memory pointed to by I<ptr>.  The B<mcheck>()  function should be "
"called beforehand (otherwise B<mprobe>()  returns B<MCHECK_DISABLED>)."
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:111
msgid ""
"The following list describes the values returned by B<mprobe>()  or passed "
"as the I<mstatus> argument when I<abortfunc> is invoked:"
msgstr ""

#. type: TP
#: build/C/man3/mcheck.3:111
#, no-wrap
msgid "B<MCHECK_DISABLED> (B<mprobe>() only)"
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:116
msgid ""
"B<mcheck>()  was not called before the first memory allocation function was "
"called.  Consistency checking is not possible."
msgstr ""

#. type: TP
#: build/C/man3/mcheck.3:116
#, no-wrap
msgid "B<MCHECK_OK> (B<mprobe>() only)"
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:119
msgid "No inconsistency detected."
msgstr ""

#. type: TP
#: build/C/man3/mcheck.3:119
#, no-wrap
msgid "B<MCHECK_HEAD>"
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:122
msgid "Memory preceding an allocated block was clobbered."
msgstr ""

#. type: TP
#: build/C/man3/mcheck.3:122
#, no-wrap
msgid "B<MCHECK_TAIL>"
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:125
msgid "Memory following an allocated block was clobbered."
msgstr ""

#. type: TP
#: build/C/man3/mcheck.3:125
#, no-wrap
msgid "B<MCHECK_FREE>"
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:129
msgid "A block of memory was freed twice."
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:134
msgid "B<mcheck>()  and B<mcheck_pedantic>()  return 0 on success, or -1 on error."
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:145
msgid ""
"The B<mcheck_pedantic>()  and B<mcheck_check_all>()  functions are available "
"since glibc 2.2.  The B<mcheck>()  and B<mprobe>()  functions are present "
"since at least glibc 2.0"
msgstr ""

#. type: tbl table
#: build/C/man3/mcheck.3:156
#, no-wrap
msgid ""
"B<mcheck>(),\n"
"B<mcheck_pedantic>(),\n"
msgstr ""

#. type: tbl table
#: build/C/man3/mcheck.3:156 build/C/man3/mcheck.3:161 build/C/man3/posix_memalign.3:200 build/C/man3/posix_memalign.3:202 build/C/man3/posix_memalign.3:207
#, no-wrap
msgid ".br\n"
msgstr ""

#. type: tbl table
#: build/C/man3/mcheck.3:159
#, no-wrap
msgid ""
"B<mcheck_check_all>(),\n"
"B<mprobe>()"
msgstr ""

#. type: tbl table
#: build/C/man3/mcheck.3:161
#, no-wrap
msgid "MT-Unsafe race:mcheck\n"
msgstr ""

#. type: tbl table
#: build/C/man3/mcheck.3:163
#, no-wrap
msgid "const:malloc_hooks"
msgstr ""

#.  But is MALLOC_CHECK_ slower?
#. type: Plain text
#: build/C/man3/mcheck.3:180
msgid ""
"Linking a program with I<-lmcheck> and using the B<MALLOC_CHECK_> "
"environment variable (described in B<mallopt>(3))  cause the same kinds of "
"errors to be detected.  But, using B<MALLOC_CHECK_> does not require the "
"application to be relinked."
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:186
msgid ""
"The program below calls B<mcheck>()  with a NULL argument and then frees the "
"same block of memory twice.  The following shell session demonstrates what "
"happens when running the program:"
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:191
#, no-wrap
msgid ""
"$B< ./a.out>\n"
"About to free\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:195
#, no-wrap
msgid ""
"About to free a second time\n"
"block freed twice\n"
"Aborted (core dumped)\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:203
#, no-wrap
msgid ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>mcheck.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:211
#, no-wrap
msgid ""
"    if (mcheck(NULL) != 0) {\n"
"        fprintf(stderr, \"mcheck() failed\\en\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:214
#, no-wrap
msgid ""
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:216
#, no-wrap
msgid "    p = malloc(1000);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:221
#, no-wrap
msgid ""
"    fprintf(stderr, \"About to free\\en\");\n"
"    free(p);\n"
"    fprintf(stderr, \"\\enAbout to free a second time\\en\");\n"
"    free(p);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:229
msgid "B<malloc>(3), B<mallopt>(3), B<mtrace>(3)"
msgstr ""

#. type: TH
#: build/C/man2/mlock.2:26
#, no-wrap
msgid "MLOCK"
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:29
msgid "mlock, mlock2, munlock, mlockall, munlockall - lock and unlock memory"
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:32 build/C/man2/mmap.2:46 build/C/man2/mmap2.2:35 build/C/man2/mprotect.2:39 build/C/man3/posix_madvise.3:26
#, no-wrap
msgid "B<#include E<lt>sys/mman.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:36
#, no-wrap
msgid ""
"B<int mlock(const void *>I<addr>B<, size_t >I<len>B<);>\n"
"B<int mlock2(const void *>I<addr>B<, size_t >I<len>B<, int >I<flags>B<);>\n"
"B<int munlock(const void *>I<addr>B<, size_t >I<len>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:39
#, no-wrap
msgid ""
"B<int mlockall(int >I<flags>B<);>\n"
"B<int munlockall(void);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:48
msgid ""
"B<mlock>(), B<mlock2>(), and B<mlockall>()  lock part or all of the calling "
"process's virtual address space into RAM, preventing that memory from being "
"paged to the swap area."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:56
msgid ""
"B<munlock>()  and B<munlockall>()  perform the converse operation, unlocking "
"part or all of the calling process's virtual address space, so that pages in "
"the specified virtual address range may once more to be swapped out if "
"required by the kernel memory manager."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:58
msgid "Memory locking and unlocking are performed in units of whole pages."
msgstr ""

#. type: SS
#: build/C/man2/mlock.2:58
#, no-wrap
msgid "mlock(), mlock2(), and munlock()"
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:68
msgid ""
"B<mlock>()  locks pages in the address range starting at I<addr> and "
"continuing for I<len> bytes.  All pages that contain a part of the specified "
"address range are guaranteed to be resident in RAM when the call returns "
"successfully; the pages are guaranteed to stay in RAM until later unlocked."
msgstr ""

#.  commit a8ca5d0ecbdde5cc3d7accacbd69968b0c98764e
#.  commit de60f5f10c58d4f34b68622442c0e04180367f3f
#.  commit b0f205c2a3082dd9081f9a94e50658c5fa906ff1
#. type: Plain text
#: build/C/man2/mlock.2:82
msgid ""
"B<mlock2>()  also locks pages in the specified range starting at I<addr> and "
"continuing for I<len> bytes.  However, the state of the pages contained in "
"that range after the call returns successfully will depend on the value in "
"the I<flags> argument."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:86
msgid "The I<flags> argument can be either 0 or the following constant:"
msgstr ""

#. type: TP
#: build/C/man2/mlock.2:86
#, no-wrap
msgid "B<MLOCK_ONFAULT>"
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:91
msgid ""
"Lock pages that are currently resident and mark the entire range so that the "
"remaining nonresident pages are locked when they are populated by a page "
"fault."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:98
msgid "If I<flags> is 0, B<mlock2>()  behaves exactly the same as B<mlock>()."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:107
msgid ""
"B<munlock>()  unlocks pages in the address range starting at I<addr> and "
"continuing for I<len> bytes.  After this call, all pages that contain a part "
"of the specified memory range can be moved to external swap space again by "
"the kernel."
msgstr ""

#. type: SS
#: build/C/man2/mlock.2:107
#, no-wrap
msgid "mlockall() and munlockall()"
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:117
msgid ""
"B<mlockall>()  locks all pages mapped into the address space of the calling "
"process.  This includes the pages of the code, data and stack segment, as "
"well as shared libraries, user space kernel data, shared memory, and "
"memory-mapped files.  All mapped pages are guaranteed to be resident in RAM "
"when the call returns successfully; the pages are guaranteed to stay in RAM "
"until later unlocked."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:122
msgid ""
"The I<flags> argument is constructed as the bitwise OR of one or more of the "
"following constants:"
msgstr ""

#. type: TP
#: build/C/man2/mlock.2:122
#, no-wrap
msgid "B<MCL_CURRENT>"
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:126
msgid ""
"Lock all pages which are currently mapped into the address space of the "
"process."
msgstr ""

#. type: TP
#: build/C/man2/mlock.2:126
#, no-wrap
msgid "B<MCL_FUTURE>"
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:133
msgid ""
"Lock all pages which will become mapped into the address space of the "
"process in the future.  These could be, for instance, new pages required by "
"a growing heap and stack as well as new memory-mapped files or shared memory "
"regions."
msgstr ""

#. type: TP
#: build/C/man2/mlock.2:133
#, no-wrap
msgid "B<MCL_ONFAULT> (since Linux 4.4)"
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:160
msgid ""
"Used together with B<MCL_CURRENT>, B<MCL_FUTURE>, or both.  Mark all current "
"(with B<MCL_CURRENT>)  or future (with B<MCL_FUTURE>)  mappings to lock "
"pages when they are faulted in.  When used with B<MCL_CURRENT>, all present "
"pages are locked, but B<mlockall>()  will not fault in non-present pages.  "
"When used with B<MCL_FUTURE>, all future mappings will be marked to lock "
"pages when they are faulted in, but they will not be populated by the lock "
"when the mapping is created.  B<MCL_ONFAULT> must be used with either "
"B<MCL_CURRENT> or B<MCL_FUTURE> or both."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:173
msgid ""
"If B<MCL_FUTURE> has been specified, then a later system call (e.g., "
"B<mmap>(2), B<sbrk>(2), B<malloc>(3)), may fail if it would cause the number "
"of locked bytes to exceed the permitted maximum (see below).  In the same "
"circumstances, stack growth may likewise fail: the kernel will deny stack "
"expansion and deliver a B<SIGSEGV> signal to the process."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:177
msgid ""
"B<munlockall>()  unlocks all pages mapped into the address space of the "
"calling process."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:183
msgid ""
"On success, these system calls return 0.  On error, -1 is returned, I<errno> "
"is set appropriately, and no changes are made to any locks in the address "
"space of the process."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:192
msgid ""
"(Linux 2.6.9 and later) the caller had a nonzero B<RLIMIT_MEMLOCK> soft "
"resource limit, but tried to lock more memory than the limit permitted.  "
"This limit is not enforced if the process is privileged (B<CAP_IPC_LOCK>)."
msgstr ""

#.  In the case of mlock(), this check is somewhat buggy: it doesn't
#.  take into account whether the to-be-locked range overlaps with
#.  already locked pages.  Thus, suppose we allocate
#.  (num_physpages / 4 + 1) of memory, and lock those pages once using
#.  mlock(), and then lock the *same* page range a second time.
#.  In the case, the second mlock() call will fail, since the check
#.  calculates that the process is trying to lock (num_physpages / 2 + 2)
#.  pages, which of course is not true.  (MTK, Nov 04, kernel 2.4.28)
#. type: Plain text
#: build/C/man2/mlock.2:204
msgid ""
"(Linux 2.4 and earlier) the calling process tried to lock more than half of "
"RAM."
msgstr ""

#. SVr4 documents an additional EAGAIN error code.
#. type: Plain text
#: build/C/man2/mlock.2:210
msgid ""
"The caller is not privileged, but needs privilege (B<CAP_IPC_LOCK>)  to "
"perform the requested operation."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:216
msgid "For B<mlock>(), B<mlock2>(), and B<munlock>():"
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:219
msgid "Some or all of the specified address range could not be locked."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:226
msgid ""
"The result of the addition I<addr>+I<len> was less than I<addr> (e.g., the "
"addition may have resulted in an overflow)."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:231
msgid "(Not on Linux)  I<addr> was not a multiple of the page size."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:235
msgid ""
"Some of the specified address range does not correspond to mapped pages in "
"the address space of the process."
msgstr ""

#.  I.e., the number of VMAs would exceed the 64kB maximum
#. type: Plain text
#: build/C/man2/mlock.2:244
msgid ""
"Locking or unlocking a region would result in the total number of mappings "
"with distinct attributes (e.g., locked versus unlocked)  exceeding the "
"allowed maximum.  (For example, unlocking a range in the middle of a "
"currently locked mapping would result in three mappings: two locked mappings "
"at each end and an unlocked mapping in the middle.)"
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:247
msgid "For B<mlock2>():"
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:250
msgid "Unknown I<flags> were specified."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:253
msgid "For B<mlockall>():"
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:261
msgid ""
"Unknown I<flags> were specified or B<MCL_ONFAULT> was specified without "
"either B<MCL_FUTURE> or B<MCL_CURRENT>."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:264
msgid "For B<munlockall>():"
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:268
msgid "(Linux 2.6.8 and earlier) The caller was not privileged (B<CAP_IPC_LOCK>)."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:272
msgid ""
"B<mlock2>()  is available since Linux 4.4; glibc support was added in "
"version 2.27."
msgstr ""

#.  SVr4 documents an additional error condition EMFILE.
#. type: Plain text
#: build/C/man2/mlock.2:274 build/C/man2/shmctl.2:467 build/C/man2/shmget.2:283 build/C/man2/shmop.2:230
msgid "POSIX.1-2001, POSIX.1-2008, SVr4."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:277
msgid "B<mlock2>()  is Linux specific."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:289
msgid ""
"On POSIX systems on which B<mlock>()  and B<munlock>()  are available, "
"B<_POSIX_MEMLOCK_RANGE> is defined in I<E<lt>unistd.hE<gt>> and the number "
"of bytes in a page can be determined from the constant B<PAGESIZE> (if "
"defined) in I<E<lt>limits.hE<gt>> or by calling I<sysconf(_SC_PAGESIZE)>."
msgstr ""

#.  POSIX.1-2001: It shall be defined to -1 or 0 or 200112L.
#.  -1: unavailable, 0: ask using sysconf().
#.  glibc defines it to 1.
#. type: Plain text
#: build/C/man2/mlock.2:302
msgid ""
"On POSIX systems on which B<mlockall>()  and B<munlockall>()  are available, "
"B<_POSIX_MEMLOCK> is defined in I<E<lt>unistd.hE<gt>> to a value greater "
"than 0.  (See also B<sysconf>(3).)"
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:320
msgid ""
"Memory locking has two main applications: real-time algorithms and "
"high-security data processing.  Real-time applications require deterministic "
"timing, and, like scheduling, paging is one major cause of unexpected "
"program execution delays.  Real-time applications will usually also switch "
"to a real-time scheduler with B<sched_setscheduler>(2).  Cryptographic "
"security software often handles critical bytes like passwords or secret keys "
"as data structures.  As a result of paging, these secrets could be "
"transferred onto a persistent swap store medium, where they might be "
"accessible to the enemy long after the security software has erased the "
"secrets in RAM and terminated.  (But be aware that the suspend mode on "
"laptops and some desktop computers will save a copy of the system's RAM to "
"disk, regardless of memory locks.)"
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:333
msgid ""
"Real-time processes that are using B<mlockall>()  to prevent delays on page "
"faults should reserve enough locked stack pages before entering the "
"time-critical section, so that no page fault can be caused by function "
"calls.  This can be achieved by calling a function that allocates a "
"sufficiently large automatic variable (an array) and writes to the memory "
"occupied by this array in order to touch these stack pages.  This way, "
"enough pages will be mapped for the stack and can be locked into RAM.  The "
"dummy writes ensure that not even copy-on-write page faults can occur in the "
"critical section."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:348
msgid ""
"Memory locks are not inherited by a child created via B<fork>(2)  and are "
"automatically removed (unlocked) during an B<execve>(2)  or when the process "
"terminates.  The B<mlockall>()  B<MCL_FUTURE> and B<MCL_FUTURE | "
"MCL_ONFAULT> settings are not inherited by a child created via B<fork>(2)  "
"and are cleared during an B<execve>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:362
msgid ""
"Note that B<fork>(2)  will prepare the address space for a copy-on-write "
"operation.  The consequence is that any write access that follows will cause "
"a page fault that in turn may cause high latencies for a real-time process.  "
"Therefore, it is crucial not to invoke B<fork>(2)  after an B<mlockall>()  "
"or B<mlock>()  operation\\(emnot even from a thread which runs at a low "
"priority within a process which also has a thread running at elevated "
"priority."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:366
msgid ""
"The memory lock on an address range is automatically removed if the address "
"range is unmapped via B<munmap>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:380
msgid ""
"Memory locks do not stack, that is, pages which have been locked several "
"times by calls to B<mlock>(), B<mlock2>(), or B<mlockall>()  will be "
"unlocked by a single call to B<munlock>()  for the corresponding range or by "
"B<munlockall>().  Pages which are mapped to several locations or by several "
"processes stay locked into RAM as long as they are locked at least at one "
"location or by at least one process."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:389
msgid ""
"If a call to B<mlockall>()  which uses the B<MCL_FUTURE> flag is followed by "
"another call that does not specify this flag, the changes made by the "
"B<MCL_FUTURE> call will be lost."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:400
msgid ""
"The B<mlock2>()  B<MLOCK_ONFAULT> flag and the B<mlockall>()  B<MCL_ONFAULT> "
"flag allow efficient memory locking for applications that deal with large "
"mappings where only a (small) portion of pages in the mapping are touched.  "
"In such cases, locking all of the pages in a mapping would incur a "
"significant penalty for memory locking."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:416
msgid ""
"Under Linux, B<mlock>(), B<mlock2>(), and B<munlock>()  automatically round "
"I<addr> down to the nearest page boundary.  However, the POSIX.1 "
"specification of B<mlock>()  and B<munlock>()  allows an implementation to "
"require that I<addr> is page aligned, so portable applications should ensure "
"this."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:430
msgid ""
"The I<VmLck> field of the Linux-specific I</proc/[pid]/status> file shows "
"how many kilobytes of memory the process with ID I<PID> has locked using "
"B<mlock>(), B<mlock2>(), B<mlockall>(), and B<mmap>(2)  B<MAP_LOCKED>."
msgstr ""

#. type: SS
#: build/C/man2/mlock.2:430
#, no-wrap
msgid "Limits and permissions"
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:437
msgid ""
"In Linux 2.6.8 and earlier, a process must be privileged (B<CAP_IPC_LOCK>)  "
"in order to lock memory and the B<RLIMIT_MEMLOCK> soft resource limit "
"defines a limit on how much memory the process may lock."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:443
msgid ""
"Since Linux 2.6.9, no limits are placed on the amount of memory that a "
"privileged process can lock and the B<RLIMIT_MEMLOCK> soft resource limit "
"instead defines a limit on how much memory an unprivileged process may lock."
msgstr ""

#.  commit 0cf2f6f6dc605e587d2c1120f295934c77e810e8
#. type: Plain text
#: build/C/man2/mlock.2:466
msgid ""
"In Linux 4.8 and earlier, a bug in the kernel's accounting of locked memory "
"for unprivileged processes (i.e., without B<CAP_IPC_LOCK>)  meant that if "
"the region specified by I<addr> and I<len> overlapped an existing lock, then "
"the already locked bytes in the overlapping region were counted twice when "
"checking against the limit.  Such double accounting could incorrectly "
"calculate a \"total locked memory\" value for the process that exceeded the "
"B<RLIMIT_MEMLOCK> limit, with the result that B<mlock>()  and B<mlock2>()  "
"would fail on requests that should have succeeded.  This bug was fixed in "
"Linux 4.9."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:474
msgid ""
"In the 2.4 series Linux kernels up to and including 2.4.17, a bug caused the "
"B<mlockall>()  B<MCL_FUTURE> flag to be inherited across a B<fork>(2).  This "
"was rectified in kernel 2.4.18."
msgstr ""

#.  See the following LKML thread:
#.  http://marc.theaimsgroup.com/?l=linux-kernel&m=113801392825023&w=2
#.  "Rationale for RLIMIT_MEMLOCK"
#.  23 Jan 2006
#. type: Plain text
#: build/C/man2/mlock.2:491
msgid ""
"Since kernel 2.6.9, if a privileged process calls I<mlockall(MCL_FUTURE)> "
"and later drops privileges (loses the B<CAP_IPC_LOCK> capability by, for "
"example, setting its effective UID to a nonzero value), then subsequent "
"memory allocations (e.g., B<mmap>(2), B<brk>(2))  will fail if the "
"B<RLIMIT_MEMLOCK> resource limit is encountered."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:499
msgid ""
"B<mincore>(2), B<mmap>(2), B<setrlimit>(2), B<shmctl>(2), B<sysconf>(3), "
"B<proc>(5), B<capabilities>(7)"
msgstr ""

#. type: TH
#: build/C/man2/mmap.2:40
#, no-wrap
msgid "MMAP"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:43
msgid "mmap, munmap - map or unmap files or devices into memory"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:51
#, no-wrap
msgid ""
"B<void *mmap(void *>I<addr>B<, size_t >I<length>B<, int >I<prot>B<, int "
">I<flags>B<,>\n"
"B<           int >I<fd>B<, off_t >I<offset>B<);>\n"
"B<int munmap(void *>I<addr>B<, size_t >I<length>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:54
msgid "See NOTES for information on feature test macro requirements."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:63
msgid ""
"B<mmap>()  creates a new mapping in the virtual address space of the calling "
"process.  The starting address for the new mapping is specified in I<addr>.  "
"The I<length> argument specifies the length of the mapping (which must be "
"greater than 0)."
msgstr ""

#.  Before Linux 2.6.24, the address was rounded up to the next page
#.  boundary; since 2.6.24, it is rounded down!
#. type: Plain text
#: build/C/man2/mmap.2:83
msgid ""
"If I<addr> is NULL, then the kernel chooses the (page-aligned) address at "
"which to create the mapping; this is the most portable method of creating a "
"new mapping.  If I<addr> is not NULL, then the kernel takes it as a hint "
"about where to place the mapping; on Linux, the kernel will pick a nearby "
"page boundary (but always above or equal to the value specified by "
"I</proc/sys/vm/mmap_min_addr>)  and attempt to create the mapping there.  If "
"another mapping already exists there, the kernel picks a new address that "
"may or may not depend on the hint.  The address of the new mapping is "
"returned as the result of the call."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:95
msgid ""
"The contents of a file mapping (as opposed to an anonymous mapping; see "
"B<MAP_ANONYMOUS> below), are initialized using I<length> bytes starting at "
"offset I<offset> in the file (or other object) referred to by the file "
"descriptor I<fd>.  I<offset> must be a multiple of the page size as returned "
"by I<sysconf(_SC_PAGE_SIZE)>."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:101
msgid ""
"After the B<mmap>()  call has returned, the file descriptor, I<fd>, can be "
"closed immediately without invalidating the mapping."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:109
msgid ""
"The I<prot> argument describes the desired memory protection of the mapping "
"(and must not conflict with the open mode of the file).  It is either "
"B<PROT_NONE> or the bitwise OR of one or more of the following flags:"
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:109 build/C/man2/mprotect.2:73
#, no-wrap
msgid "B<PROT_EXEC>"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:112
msgid "Pages may be executed."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:112 build/C/man2/mprotect.2:67
#, no-wrap
msgid "B<PROT_READ>"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:115
msgid "Pages may be read."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:115 build/C/man2/mprotect.2:70
#, no-wrap
msgid "B<PROT_WRITE>"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:118
msgid "Pages may be written."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:118 build/C/man2/mprotect.2:64
#, no-wrap
msgid "B<PROT_NONE>"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:122
msgid "Pages may not be accessed."
msgstr ""

#. type: SS
#: build/C/man2/mmap.2:122
#, no-wrap
msgid "The flags argument"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:131
msgid ""
"The I<flags> argument determines whether updates to the mapping are visible "
"to other processes mapping the same region, and whether updates are carried "
"through to the underlying file.  This behavior is determined by including "
"exactly one of the following values in I<flags>:"
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:131
#, no-wrap
msgid "B<MAP_SHARED>"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:140
msgid ""
"Share this mapping.  Updates to the mapping are visible to other processes "
"mapping the same region, and (in the case of file-backed mappings)  are "
"carried through to the underlying file.  (To precisely control when updates "
"are carried through to the underlying file requires the use of B<msync>(2).)"
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:140
#, no-wrap
msgid "B<MAP_SHARED_VALIDATE> (since Linux 4.15)"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:157
msgid ""
"This flag provides the same behavior as B<MAP_SHARED> except that "
"B<MAP_SHARED> mappings ignore unknown flags in I<flags>.  By contrast, when "
"creating a mapping using B<MAP_SHARED_VALIDATE>, the kernel verifies all "
"passed flags are known and fails the mapping with the error B<EOPNOTSUPP> "
"for unknown flags.  This mapping type is also required to be able to use "
"some mapping flags (e.g., B<MAP_SYNC>)."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:157
#, no-wrap
msgid "B<MAP_PRIVATE>"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:166
msgid ""
"Create a private copy-on-write mapping.  Updates to the mapping are not "
"visible to other processes mapping the same file, and are not carried "
"through to the underlying file.  It is unspecified whether changes made to "
"the file after the B<mmap>()  call are visible in the mapped region."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:174
msgid ""
"Both B<MAP_SHARED> and B<MAP_PRIVATE> are described in POSIX.1-2001 and "
"POSIX.1-2008.  B<MAP_SHARED_VALIDATE> is a Linux extension."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:177
msgid "In addition, zero or more of the following values can be ORed in I<flags>:"
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:177
#, no-wrap
msgid "B<MAP_32BIT> (since Linux 2.4.20, 2.6)"
msgstr ""

#.  See http://lwn.net/Articles/294642 "Tangled up in threads", 19 Aug 08
#. type: Plain text
#: build/C/man2/mmap.2:193
msgid ""
"Put the mapping into the first 2 Gigabytes of the process address space.  "
"This flag is supported only on x86-64, for 64-bit programs.  It was added to "
"allow thread stacks to be allocated somewhere in the first 2\\ GB of memory, "
"so as to improve context-switch performance on some early 64-bit "
"processors.  Modern x86-64 processors no longer have this performance "
"problem, so use of this flag is not required on those systems.  The "
"B<MAP_32BIT> flag is ignored when B<MAP_FIXED> is set."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:193
#, no-wrap
msgid "B<MAP_ANON>"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:198
msgid ""
"Synonym for B<MAP_ANONYMOUS>; provided for compatibility with other "
"implementations."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:198
#, no-wrap
msgid "B<MAP_ANONYMOUS>"
msgstr ""

#.  See the pgoff overflow check in do_mmap().
#.  See the offset check in sys_mmap in arch/x86/kernel/sys_x86_64.c.
#. type: Plain text
#: build/C/man2/mmap.2:223
msgid ""
"The mapping is not backed by any file; its contents are initialized to "
"zero.  The I<fd> argument is ignored; however, some implementations require "
"I<fd> to be -1 if B<MAP_ANONYMOUS> (or B<MAP_ANON>)  is specified, and "
"portable applications should ensure this.  The I<offset> argument should be "
"zero.  The use of B<MAP_ANONYMOUS> in conjunction with B<MAP_SHARED> is "
"supported on Linux only since kernel 2.4."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:223
#, no-wrap
msgid "B<MAP_DENYWRITE>"
msgstr ""

#.  Introduced in 1.1.36, removed in 1.3.24.
#. type: Plain text
#: build/C/man2/mmap.2:231
msgid ""
"This flag is ignored.  (Long ago\\(emLinux 2.0 and earlier\\(emit signaled "
"that attempts to write to the underlying file should fail with B<ETXTBSY>.  "
"But this was a source of denial-of-service attacks.)"
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:231
#, no-wrap
msgid "B<MAP_EXECUTABLE>"
msgstr ""

#.  Introduced in 1.1.38, removed in 1.3.24. Flag tested in proc_follow_link.
#.  (Long ago, it signaled that the underlying file is an executable.
#.  However, that information was not really used anywhere.)
#.  Linus talked about DOS related to MAP_EXECUTABLE, but he was thinking of
#.  MAP_DENYWRITE?
#. type: Plain text
#: build/C/man2/mmap.2:239
msgid "This flag is ignored."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:239
#, no-wrap
msgid "B<MAP_FILE>"
msgstr ""

#.  On some systems, this was required as the opposite of
#.  MAP_ANONYMOUS -- mtk, 1 May 2007
#. type: Plain text
#: build/C/man2/mmap.2:245
msgid "Compatibility flag.  Ignored."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:245
#, no-wrap
msgid "B<MAP_FIXED>"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:263
msgid ""
"Don't interpret I<addr> as a hint: place the mapping at exactly that "
"address.  I<addr> must be suitably aligned: for most architectures a "
"multiple of the page size is sufficient; however, some architectures may "
"impose additional restrictions.  If the memory region specified by I<addr> "
"and I<len> overlaps pages of any existing mapping(s), then the overlapped "
"part of the existing mapping(s) will be discarded.  If the specified address "
"cannot be used, B<mmap>()  will fail."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:271
msgid ""
"Software that aspires to be portable should use the B<MAP_FIXED> flag with "
"care, keeping in mind that the exact layout of a process's memory mappings "
"is allowed to change significantly between kernel versions, C library "
"versions, and operating system releases.  I<Carefully read the discussion of "
"this flag in NOTES!>"
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:271
#, no-wrap
msgid "B<MAP_FIXED_NOREPLACE> (since Linux 4.17)"
msgstr ""

#.  commit a4ff8e8620d3f4f50ac4b41e8067b7d395056843
#. type: Plain text
#: build/C/man2/mmap.2:287
msgid ""
"This flag provides behavior that is similar to B<MAP_FIXED> with respect to "
"the I<addr> enforcement, but differs in that B<MAP_FIXED_NOREPLACE> never "
"clobbers a preexisting mapped range.  If the requested range would collide "
"with an existing mapping, then this call fails with the error B<EEXIST.> "
"This flag can therefore be used as a way to atomically (with respect to "
"other threads) attempt to map an address range: one thread will succeed; all "
"others will report failure."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:297
msgid ""
"Note that older kernels which do not recognize the B<MAP_FIXED_NOREPLACE> "
"flag will typically (upon detecting a collision with a preexisting mapping)  "
"fall back to a \"non-B<MAP_FIXED>\" type of behavior: they will return an "
"address that is different from the requested address.  Therefore, "
"backward-compatible software should check the returned address against the "
"requested address."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:297
#, no-wrap
msgid "B<MAP_GROWSDOWN>"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:311
msgid ""
"This flag is used for stacks.  It indicates to the kernel virtual memory "
"system that the mapping should extend downward in memory.  The return "
"address is one page lower than the memory area that is actually created in "
"the process's virtual address space.  Touching an address in the \"guard\" "
"page below the mapping will cause the mapping to grow by a page.  This "
"growth can be repeated until the mapping grows to within a page of the high "
"end of the next lower mapping, at which point touching the \"guard\" page "
"will result in a B<SIGSEGV> signal."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:311
#, no-wrap
msgid "B<MAP_HUGETLB> (since Linux 2.6.32)"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:317
msgid ""
"Allocate the mapping using \"huge pages.\" See the Linux kernel source file "
"I<Documentation/admin-guide/mm/hugetlbpage.rst> for further information, as "
"well as NOTES, below."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:317
#, no-wrap
msgid "B<MAP_HUGE_2MB>, B<MAP_HUGE_1GB> (since Linux 3.8)"
msgstr ""

#.  See https://lwn.net/Articles/533499/
#. type: Plain text
#: build/C/man2/mmap.2:324
msgid ""
"Used in conjunction with B<MAP_HUGETLB> to select alternative hugetlb page "
"sizes (respectively, 2\\ MB and 1\\ GB)  on systems that support multiple "
"hugetlb page sizes."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:334
msgid ""
"More generally, the desired huge page size can be configured by encoding the "
"base-2 logarithm of the desired page size in the six bits at the offset "
"B<MAP_HUGE_SHIFT>.  (A value of zero in this bit field provides the default "
"huge page size; the default huge page size can be discovered via the "
"I<Hugepagesize> field exposed by I</proc/meminfo>.)  Thus, the above two "
"constants are defined as:"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:339
#, no-wrap
msgid ""
"#define MAP_HUGE_2MB    (21 E<lt>E<lt> MAP_HUGE_SHIFT)\n"
"#define MAP_HUGE_1GB    (30 E<lt>E<lt> MAP_HUGE_SHIFT)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:345
msgid ""
"The range of huge page sizes that are supported by the system can be "
"discovered by listing the subdirectories in I</sys/kernel/mm/hugepages>."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:345
#, no-wrap
msgid "B<MAP_LOCKED> (since Linux 2.5.37)"
msgstr ""

#.  If set, the mapped pages will not be swapped out.
#. type: Plain text
#: build/C/man2/mmap.2:366
msgid ""
"Mark the mapped region to be locked in the same way as B<mlock>(2).  This "
"implementation will try to populate (prefault) the whole range but the "
"B<mmap>()  call doesn't fail with B<ENOMEM> if this fails.  Therefore major "
"faults might happen later on.  So the semantic is not as strong as "
"B<mlock>(2).  One should use B<mmap>()  plus B<mlock>(2)  when major faults "
"are not acceptable after the initialization of the mapping.  The "
"B<MAP_LOCKED> flag is ignored in older kernels."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:366
#, no-wrap
msgid "B<MAP_NONBLOCK> (since Linux 2.5.46)"
msgstr ""

#.  commit 54cb8821de07f2ffcd28c380ce9b93d5784b40d7
#. type: Plain text
#: build/C/man2/mmap.2:383
msgid ""
"This flag is meaningful only in conjunction with B<MAP_POPULATE>.  Don't "
"perform read-ahead: create page tables entries only for pages that are "
"already present in RAM.  Since Linux 2.6.23, this flag causes "
"B<MAP_POPULATE> to do nothing.  One day, the combination of B<MAP_POPULATE> "
"and B<MAP_NONBLOCK> may be reimplemented."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:383
#, no-wrap
msgid "B<MAP_NORESERVE>"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:398
msgid ""
"Do not reserve swap space for this mapping.  When swap space is reserved, "
"one has the guarantee that it is possible to modify the mapping.  When swap "
"space is not reserved one might get B<SIGSEGV> upon a write if no physical "
"memory is available.  See also the discussion of the file "
"I</proc/sys/vm/overcommit_memory> in B<proc>(5).  In kernels before 2.6, "
"this flag had effect only for private writable mappings."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:398
#, no-wrap
msgid "B<MAP_POPULATE> (since Linux 2.5.46)"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:405
msgid ""
"Populate (prefault) page tables for a mapping.  For a file mapping, this "
"causes read-ahead on the file.  This will help to reduce blocking on page "
"faults later.  B<MAP_POPULATE> is supported for private mappings only since "
"Linux 2.6.23."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:405
#, no-wrap
msgid "B<MAP_STACK> (since Linux 2.6.27)"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:409
msgid "Allocate the mapping at an address suitable for a process or thread stack."
msgstr ""

#.  See http://lwn.net/Articles/294642 "Tangled up in threads", 19 Aug 08
#.  commit cd98a04a59e2f94fa64d5bf1e26498d27427d5e7
#.  http://thread.gmane.org/gmane.linux.kernel/720412
#.  "pthread_create() slow for many threads; also time to revisit 64b
#.   context switch optimization?"
#. type: Plain text
#: build/C/man2/mmap.2:425
msgid ""
"This flag is currently a no-op on Linux.  However, by employing this flag, "
"applications can ensure that they transparently obtain support if the flag "
"is implemented in the future.  Thus, it is used in the glibc threading "
"implementation to allow for the fact that some architectures may (later) "
"require special treatment for stack allocations.  A further reason to employ "
"this flag is portability: B<MAP_STACK> exists (and has an effect) on some "
"other systems (e.g., some of the BSDs)."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:425
#, no-wrap
msgid "B<MAP_SYNC> (since Linux 4.15)"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:438
msgid ""
"This flag is available only with the B<MAP_SHARED_VALIDATE> mapping type; "
"mappings of type B<MAP_SHARED> will silently ignore this flag.  This flag is "
"supported only for files supporting DAX (direct mapping of persistent "
"memory).  For other files, creating a mapping with this flag results in an "
"B<EOPNOTSUPP> error."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:446
msgid ""
"Shared file mappings with this flag provide the guarantee that while some "
"memory is mapped writable in the address space of the process, it will be "
"visible in the same file at the same offset even after the system crashes or "
"is rebooted.  In conjunction with the use of appropriate CPU instructions, "
"this provides users of such mappings with a more efficient way of making "
"data modifications persistent."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:446
#, no-wrap
msgid "B<MAP_UNINITIALIZED> (since Linux 2.6.33)"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:456
msgid ""
"Don't clear anonymous pages.  This flag is intended to improve performance "
"on embedded devices.  This flag is honored only if the kernel was configured "
"with the B<CONFIG_MMAP_ALLOW_UNINITIALIZED> option.  Because of the security "
"implications, that option is normally enabled only on embedded devices "
"(i.e., devices where one has complete control of the contents of user "
"memory)."
msgstr ""

#.  FIXME . for later review when Issue 8 is one day released...
#.  POSIX may add MAP_ANON in the future
#.  http://austingroupbugs.net/tag_view_page.php?tag_id=8
#.  http://austingroupbugs.net/view.php?id=850
#. type: Plain text
#: build/C/man2/mmap.2:468
msgid ""
"Of the above flags, only B<MAP_FIXED> is specified in POSIX.1-2001 and "
"POSIX.1-2008.  However, most systems also support B<MAP_ANONYMOUS> (or its "
"synonym B<MAP_ANON>)."
msgstr ""

#. type: SS
#: build/C/man2/mmap.2:468
#, no-wrap
msgid "munmap()"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:478
msgid ""
"The B<munmap>()  system call deletes the mappings for the specified address "
"range, and causes further references to addresses within the range to "
"generate invalid memory references.  The region is also automatically "
"unmapped when the process is terminated.  On the other hand, closing the "
"file descriptor does not unmap the region."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:490
msgid ""
"The address I<addr> must be a multiple of the page size (but I<length> need "
"not be).  All pages containing a part of the indicated range are unmapped, "
"and subsequent references to these pages will generate B<SIGSEGV>.  It is "
"not an error if the indicated range does not contain any mapped pages."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:501
msgid ""
"On success, B<mmap>()  returns a pointer to the mapped area.  On error, the "
"value B<MAP_FAILED> (that is, I<(void\\ *)\\ -1>)  is returned, and I<errno> "
"is set to indicate the cause of the error."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:509
msgid ""
"On success, B<munmap>()  returns 0.  On failure, it returns -1, and I<errno> "
"is set to indicate the cause of the error (probably to B<EINVAL>)."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:528
msgid ""
"A file descriptor refers to a non-regular file.  Or a file mapping was "
"requested, but I<fd> is not open for reading.  Or B<MAP_SHARED> was "
"requested and B<PROT_WRITE> is set, but I<fd> is not open in read/write "
"(B<O_RDWR>)  mode.  Or B<PROT_WRITE> is set, but the file is append-only."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:532
msgid ""
"The file has been locked, or too much memory has been locked (see "
"B<setrlimit>(2))."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:538
msgid "I<fd> is not a valid file descriptor (and B<MAP_ANONYMOUS> was not set)."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:538 build/C/man3/shm_open.3:201 build/C/man2/shmget.2:230
#, no-wrap
msgid "B<EEXIST>"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:548
msgid ""
"B<MAP_FIXED_NOREPLACE> was specified in I<flags>, and the range covered by "
"I<addr> and I<length> clashes with an existing mapping."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:556
msgid ""
"We don't like I<addr>, I<length>, or I<offset> (e.g., they are too large, or "
"not aligned on a page boundary)."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:561
msgid "(since Linux 2.6.12)  I<length> was 0."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:569
msgid ""
"I<flags> contained none of B<MAP_PRIVATE>, B<MAP_SHARED> or "
"B<MAP_SHARED_VALIDATE>."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:569 build/C/man3/shm_open.3:228 build/C/man2/shmget.2:253 build/C/man2/memfd_create.2:193
#, no-wrap
msgid "B<ENFILE>"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:577 build/C/man3/shm_open.3:231 build/C/man2/shmget.2:257 build/C/man2/memfd_create.2:196
msgid "The system-wide limit on the total number of open files has been reached."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:581
msgid ""
"The underlying filesystem of the specified file does not support memory "
"mapping."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:584
msgid "No memory is available."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:592
msgid ""
"The process's maximum number of mappings would have been exceeded.  This "
"error can also occur for B<munmap>(), when unmapping a region in the middle "
"of an existing mapping, since this results in two smaller mappings on either "
"side of the region being unmapped."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:600
msgid ""
"(since Linux 4.7)  The process's B<RLIMIT_DATA> limit, described in "
"B<getrlimit>(2), would have been exceeded."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:600 build/C/man2/shmctl.2:433
#, no-wrap
msgid "B<EOVERFLOW>"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:612
msgid ""
"On 32-bit architecture together with the large file extension (i.e., using "
"64-bit I<off_t>): the number of pages used for I<length> plus number of "
"pages used for I<offset> would overflow I<unsigned long> (32 bits)."
msgstr ""

#.  (Since 2.4.25 / 2.6.0.)
#. type: Plain text
#: build/C/man2/mmap.2:621
msgid ""
"The I<prot> argument asks for B<PROT_EXEC> but the mapped area belongs to a "
"file on a filesystem that was mounted no-exec."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:631
msgid ""
"B<MAP_DENYWRITE> was set but the object specified by I<fd> is open for "
"writing."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:633
msgid "Use of a mapped region can result in these signals:"
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:633
#, no-wrap
msgid "B<SIGSEGV>"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:636
msgid "Attempted write into a region mapped as read-only."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:636
#, no-wrap
msgid "B<SIGBUS>"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:643
msgid ""
"Attempted access to a page of the buffer that lies beyond the end of the "
"mapped file.  For an explanation of the treatment of the bytes in the page "
"that corresponds to the end of a mapped file that is not a multiple of the "
"page size, see NOTES."
msgstr ""

#. type: tbl table
#: build/C/man2/mmap.2:654
#, no-wrap
msgid ""
"B<mmap>(),\n"
"B<munmap>()"
msgstr ""

#.  SVr4 documents additional error codes ENXIO and ENODEV.
#.  SUSv2 documents additional error codes EMFILE and EOVERFLOW.
#. type: Plain text
#: build/C/man2/mmap.2:660
msgid "POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD."
msgstr ""

#.  POSIX.1-2001: It shall be defined to -1 or 0 or 200112L.
#.  -1: unavailable, 0: ask using sysconf().
#.  glibc defines it to 1.
#. type: Plain text
#: build/C/man2/mmap.2:674
msgid ""
"On POSIX systems on which B<mmap>(), B<msync>(2), and B<munmap>()  are "
"available, B<_POSIX_MAPPED_FILES> is defined in I<E<lt>unistd.hE<gt>> to a "
"value greater than 0.  (See also B<sysconf>(3).)"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:680
msgid ""
"Memory mapped by B<mmap>()  is preserved across B<fork>(2), with the same "
"attributes."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:690
msgid ""
"A file is mapped in multiples of the page size.  For a file that is not a "
"multiple of the page size, the remaining bytes in the partial page at the "
"end of the mapping are zeroed when mapped, and modifications to that region "
"are not written out to the file.  The effect of changing the size of the "
"underlying file of a mapping on the pages that correspond to added or "
"removed regions of the file is unspecified."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:703
msgid ""
"On some hardware architectures (e.g., i386), B<PROT_WRITE> implies "
"B<PROT_READ>.  It is architecture dependent whether B<PROT_READ> implies "
"B<PROT_EXEC> or not.  Portable programs should always set B<PROT_EXEC> if "
"they intend to execute code in the new mapping."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:718
msgid ""
"The portable way to create a mapping is to specify I<addr> as 0 (NULL), and "
"omit B<MAP_FIXED> from I<flags>.  In this case, the system chooses the "
"address for the mapping; the address is chosen so as not to conflict with "
"any existing mapping, and will not be 0.  If the B<MAP_FIXED> flag is "
"specified, and I<addr> is 0 (NULL), then the mapped address will be 0 "
"(NULL)."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:751
msgid ""
"Certain I<flags> constants are defined only if suitable feature test macros "
"are defined (possibly by default): B<_DEFAULT_SOURCE> with glibc 2.19 or "
"later; or B<_BSD_SOURCE> or B<_SVID_SOURCE> in glibc 2.19 and earlier.  "
"(Employing B<_GNU_SOURCE> also suffices, and requiring that macro "
"specifically would have been more logical, since these flags are all "
"Linux-specific.)  The relevant flags are: B<MAP_32BIT>, B<MAP_ANONYMOUS> "
"(and the synonym B<MAP_ANON>), B<MAP_DENYWRITE>, B<MAP_EXECUTABLE>, "
"B<MAP_FILE>, B<MAP_GROWSDOWN>, B<MAP_HUGETLB>, B<MAP_LOCKED>, "
"B<MAP_NONBLOCK>, B<MAP_NORESERVE>, B<MAP_POPULATE>, and B<MAP_STACK>."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:756
msgid ""
"An application can determine which pages of a mapping are currently resident "
"in the buffer/page cache using B<mincore>(2)."
msgstr ""

#. type: SS
#: build/C/man2/mmap.2:756
#, no-wrap
msgid "Using MAP_FIXED safely"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:768
msgid ""
"The only safe use for B<MAP_FIXED> is where the address range specified by "
"I<addr> and I<length> was previously reserved using another mapping; "
"otherwise, the use of B<MAP_FIXED> is hazardous because it forcibly removes "
"preexisting mappings, making it easy for a multithreaded process to corrupt "
"its own address space."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:796
msgid ""
"For example, suppose that thread A looks through I</proc/E<lt>pidE<gt>/maps> "
"in order to locate an unused address range that it can map using "
"B<MAP_FIXED>, while thread B simultaneously acquires part or all of that "
"same address range.  When thread A subsequently employs B<mmap(MAP_FIXED)>, "
"it will effectively clobber the mapping that thread B created.  In this "
"scenario, thread B need not create a mapping directly; simply making a "
"library call that, internally, uses B<dlopen>(3)  to load some other shared "
"library, will suffice.  The B<dlopen>(3)  call will map the library into the "
"process's address space.  Furthermore, almost any library call may be "
"implemented in a way that adds memory mappings to the address space, either "
"with this technique, or by simply allocating memory.  Examples include "
"B<brk>(2), B<malloc>(3), B<pthread_create>(3), and the PAM libraries E<.UR "
"http://www.linux-pam.org> E<.UE .>"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:803
msgid ""
"Since Linux 4.17, a multithreaded program can use the B<MAP_FIXED_NOREPLACE> "
"flag to avoid the hazard described above when attempting to create a mapping "
"at a fixed address that has not been reserved by a preexisting mapping."
msgstr ""

#. type: SS
#: build/C/man2/mmap.2:803
#, no-wrap
msgid "Timestamps changes for file-backed mappings"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:810
msgid ""
"For file-backed mappings, the I<st_atime> field for the mapped file may be "
"updated at any time between the B<mmap>()  and the corresponding unmapping; "
"the first reference to a mapped page will update the field if it has not "
"been already."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:828
msgid ""
"The I<st_ctime> and I<st_mtime> field for a file mapped with B<PROT_WRITE> "
"and B<MAP_SHARED> will be updated after a write to the mapped region, and "
"before a subsequent B<msync>(2)  with the B<MS_SYNC> or B<MS_ASYNC> flag, if "
"one occurs."
msgstr ""

#. type: SS
#: build/C/man2/mmap.2:828
#, no-wrap
msgid "Huge page (Huge TLB) mappings"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:835
msgid ""
"For mappings that employ huge pages, the requirements for the arguments of "
"B<mmap>()  and B<munmap>()  differ somewhat from the requirements for "
"mappings that use the native system page size."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:843
msgid ""
"For B<mmap>(), I<offset> must be a multiple of the underlying huge page "
"size.  The system automatically aligns I<length> to be a multiple of the "
"underlying huge page size."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:851
msgid ""
"For B<munmap>(), I<addr>, and I<length> must both be a multiple of the "
"underlying huge page size."
msgstr ""

#. type: SS
#: build/C/man2/mmap.2:851 build/C/man2/posix_fadvise.2:189
#, no-wrap
msgid "C library/kernel differences"
msgstr ""

#.  Since around glibc 2.1/2.2, depending on the platform.
#. type: Plain text
#: build/C/man2/mmap.2:866
msgid ""
"This page describes the interface provided by the glibc B<mmap>()  wrapper "
"function.  Originally, this function invoked a system call of the same "
"name.  Since kernel 2.4, that system call has been superseded by "
"B<mmap2>(2), and nowadays the glibc B<mmap>()  wrapper function invokes "
"B<mmap2>(2)  with a suitably adjusted value for I<offset>."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:871
msgid ""
"On Linux, there are no guarantees like those suggested above under "
"B<MAP_NORESERVE>.  By default, any process can be killed at any moment when "
"the system runs out of memory."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:878
msgid ""
"In kernels before 2.6.7, the B<MAP_POPULATE> flag has effect only if I<prot> "
"is specified as B<PROT_NONE>."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:893
msgid ""
"SUSv3 specifies that B<mmap>()  should fail if I<length> is 0.  However, in "
"kernels before 2.6.12, B<mmap>()  succeeded in this case: no mapping was "
"created and the call returned I<addr>.  Since kernel 2.6.12, B<mmap>()  "
"fails with the error B<EINVAL> for this case."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:910
msgid ""
"POSIX specifies that the system shall always zero fill any partial page at "
"the end of the object and that system will never write any modification of "
"the object beyond its end.  On Linux, when you write data to such partial "
"page after the end of the object, the data stays in the page cache even "
"after the file is closed and unmapped and even though the data is never "
"written to the file itself, subsequent mappings may see the modified "
"content.  In some cases, this could be fixed by calling B<msync>(2)  before "
"the unmap takes place; however, this doesn't work on B<tmpfs>(5)  (for "
"example, when using the POSIX shared memory interface documented in "
"B<shm_overview>(7))."
msgstr ""

#.  FIXME . Add an example here that uses an anonymous shared region for
#.  IPC between parent and child.
#. type: Plain text
#: build/C/man2/mmap.2:921
msgid ""
"The following program prints part of the file specified in its first "
"command-line argument to standard output.  The range of bytes to be printed "
"is specified via offset and length values in the second and third "
"command-line arguments.  The program creates a memory mapping of the "
"required pages of the file and then uses B<write>(2)  to output the desired "
"bytes."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:929
#, no-wrap
msgid ""
"#include E<lt>sys/mman.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:932 build/C/man2/mprotect.2:317
#, no-wrap
msgid ""
"#define handle_error(msg) \\e\n"
"    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:942
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *addr;\n"
"    int fd;\n"
"    struct stat sb;\n"
"    off_t offset, pa_offset;\n"
"    size_t length;\n"
"    ssize_t s;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:947
#, no-wrap
msgid ""
"    if (argc E<lt> 3 || argc E<gt> 4) {\n"
"        fprintf(stderr, \"%s file offset [length]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:951
#, no-wrap
msgid ""
"    fd = open(argv[1], O_RDONLY);\n"
"    if (fd == -1)\n"
"        handle_error(\"open\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:954
#, no-wrap
msgid ""
"    if (fstat(fd, &sb) == -1)           /* To obtain file size */\n"
"        handle_error(\"fstat\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:958
#, no-wrap
msgid ""
"    offset = atoi(argv[2]);\n"
"    pa_offset = offset & \\(ti(sysconf(_SC_PAGE_SIZE) - 1);\n"
"        /* offset for mmap() must be page aligned */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:963
#, no-wrap
msgid ""
"    if (offset E<gt>= sb.st_size) {\n"
"        fprintf(stderr, \"offset is past end of file\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:969
#, no-wrap
msgid ""
"    if (argc == 4) {\n"
"        length = atoi(argv[3]);\n"
"        if (offset + length E<gt> sb.st_size)\n"
"            length = sb.st_size - offset;\n"
"                /* Can\\(aqt display bytes past end of file */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:973
#, no-wrap
msgid ""
"    } else {    /* No length arg ==E<gt> display to end of file */\n"
"        length = sb.st_size - offset;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:978
#, no-wrap
msgid ""
"    addr = mmap(NULL, length + offset - pa_offset, PROT_READ,\n"
"                MAP_PRIVATE, fd, pa_offset);\n"
"    if (addr == MAP_FAILED)\n"
"        handle_error(\"mmap\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:983
#, no-wrap
msgid ""
"    s = write(STDOUT_FILENO, addr + offset - pa_offset, length);\n"
"    if (s != length) {\n"
"        if (s == -1)\n"
"            handle_error(\"write\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:987
#, no-wrap
msgid ""
"        fprintf(stderr, \"partial write\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:990
#, no-wrap
msgid ""
"    munmap(addr, length + offset - pa_offset);\n"
"    close(fd);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:1010
msgid ""
"B<ftruncate>(2), B<getpagesize>(2), B<memfd_create>(2), B<mincore>(2), "
"B<mlock>(2), B<mmap2>(2), B<mprotect>(2), B<mremap>(2), B<msync>(2), "
"B<remap_file_pages>(2), B<setrlimit>(2), B<shmat>(2), B<userfaultfd>(2), "
"B<shm_open>(3), B<shm_overview>(7)"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:1017
msgid ""
"The descriptions of the following files in B<proc>(5): I</proc/[pid]/maps>, "
"I</proc/[pid]/map_files>, and I</proc/[pid]/smaps>."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:1022 build/C/man2/msync.2:154
msgid "B.O. Gallmeister, POSIX.4, O'Reilly, pp. 128\\(en129 and 389\\(en391."
msgstr ""

#. type: TH
#: build/C/man2/mmap2.2:29
#, no-wrap
msgid "MMAP2"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap2.2:32
msgid "mmap2 - map files or devices into memory"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap2.2:38
#, no-wrap
msgid ""
"B<void *mmap2(void *>I<addr>B<, size_t >I<length>B<, int >I<prot>B<,>\n"
"B<             int >I<flags>B<, int >I<fd>B<, off_t >I<pgoffset>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap2.2:43
msgid ""
"This is probably not the system call that you are interested in; instead, "
"see B<mmap>(2), which describes the glibc wrapper function that invokes this "
"system call."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap2.2:54
msgid ""
"The B<mmap2>()  system call provides the same interface as B<mmap>(2), "
"except that the final argument specifies the offset into the file in "
"4096-byte units (instead of bytes, as is done by B<mmap>(2)).  This enables "
"applications that use a 32-bit I<off_t> to map large files (up to 2^44 "
"bytes)."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap2.2:61
msgid ""
"On success, B<mmap2>()  returns a pointer to the mapped area.  On error, -1 "
"is returned and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap2.2:65
msgid "Problem with getting the data from user space."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap2.2:70
msgid ""
"(Various platforms where the page size is not 4096 bytes.)  I<offset\\ *\\ "
"4096> is not a multiple of the system page size."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap2.2:74
msgid "B<mmap2>()  can also return any of the errors described in B<mmap>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap2.2:77
msgid "B<mmap2>()  is available since Linux 2.3.31."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap2.2:79 build/C/man2/subpage_prot.2:98
msgid "This system call is Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap2.2:86
msgid ""
"On architectures where this system call is present, the glibc B<mmap>()  "
"wrapper function invokes this system call rather than the B<mmap>(2)  system "
"call."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap2.2:88
msgid "This system call does not exist on x86-64."
msgstr ""

#.  ia64 can have page sizes ranging from 4 kB to 64 kB.
#.  On cris, it looks like the unit might also be the page size,
#.  which is 8192 bytes. -- mtk, June 2007
#. type: Plain text
#: build/C/man2/mmap2.2:95
msgid ""
"On ia64, the unit for I<offset> is actually the system page size, rather "
"than 4096 bytes."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap2.2:101
msgid "B<getpagesize>(2), B<mmap>(2), B<mremap>(2), B<msync>(2), B<shm_open>(3)"
msgstr ""

#. type: TH
#: build/C/man2/mprotect.2:33
#, no-wrap
msgid "MPROTECT"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:36
msgid "mprotect, pkey_mprotect - set protection on a region of memory"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:41
#, no-wrap
msgid "B<int mprotect(void *>I<addr>B<, size_t >I<len>B<, int >I<prot>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:44 build/C/man2/pkey_alloc.2:32
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>sys/mman.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:46
#, no-wrap
msgid ""
"B<int pkey_mprotect(void *>I<addr>B<, size_t >I<len>B<, int >I<prot>B<, int "
">I<pkey>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:54
msgid ""
"B<mprotect>()  changes the access protections for the calling process's "
"memory pages containing any part of the address range in the interval "
"[I<addr>,\\ I<addr>+I<len>-1].  I<addr> must be aligned to a page boundary."
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:59
msgid ""
"If the calling process tries to access memory in a manner that violates the "
"protections, then the kernel generates a B<SIGSEGV> signal for the process."
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:64
msgid ""
"I<prot> is a combination of the following access flags: B<PROT_NONE> or a "
"bitwise-or of the other values in the following list:"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:67
msgid "The memory cannot be accessed at all."
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:70
msgid "The memory can be read."
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:73
msgid "The memory can be modified."
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:76
msgid "The memory can be executed."
msgstr ""

#. type: TP
#: build/C/man2/mprotect.2:76
#, no-wrap
msgid "B<PROT_SEM> (since Linux 2.5.7)"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:85
msgid ""
"The memory can be used for atomic operations.  This flag was introduced as "
"part of the B<futex>(2)  implementation (in order to guarantee the ability "
"to perform atomic operations required by commands such as B<FUTEX_WAIT>), "
"but is not currently used in on any architecture."
msgstr ""

#. type: TP
#: build/C/man2/mprotect.2:85
#, no-wrap
msgid "B<PROT_SAO> (since Linux 2.6.26)"
msgstr ""

#.  commit aba46c5027cb59d98052231b36efcbbde9c77a1d
#.  commit ef3d3246a0d06be622867d21af25f997aeeb105f
#. type: Plain text
#: build/C/man2/mprotect.2:94
msgid ""
"The memory should have strong access ordering.  This feature is specific to "
"the PowerPC architecture (version 2.06 of the architecture specification "
"adds the SAO CPU feature, and it is available on POWER 7 or PowerPC A2, for "
"example)."
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:98
msgid ""
"Additionally (since Linux 2.6.0), I<prot> can have one of the following "
"flags set:"
msgstr ""

#.  mm/mmap.c:
#. 	vm_flags |= calc_vm_prot_bits(prot, pkey) | calc_vm_flag_bits(flags) |
#. 			mm->def_flags | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC;
#.  And calc_vm_flag_bits converts only GROWSDOWN/DENYWRITE/LOCKED.
#. type: TP
#: build/C/man2/mprotect.2:98
#, no-wrap
msgid "B<PROT_GROWSUP>"
msgstr ""

#.  The VMA is one that was marked with VM_GROWSUP by the kernel
#.  when the stack was created. Note that (unlike VM_GROWSDOWN),
#.  there is no mmap() flag (analogous to MAP_GROWSDOWN) for
#.  creating a VMA that is marked VM_GROWSUP.
#. type: Plain text
#: build/C/man2/mprotect.2:113
msgid ""
"Apply the protection mode up to the end of a mapping that grows upwards.  "
"(Such mappings are created for the stack area on architectures\\(emfor "
"example, HP-PARISC\\(emthat have an upwardly growing stack.)"
msgstr ""

#. type: TP
#: build/C/man2/mprotect.2:113
#, no-wrap
msgid "B<PROT_GROWSDOWN>"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:120
msgid ""
"Apply the protection mode down to the beginning of a mapping that grows "
"downward (which should be a stack segment or a segment mapped with the "
"B<MAP_GROWSDOWN> flag set)."
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:139
msgid ""
"Like B<mprotect>(), B<pkey_mprotect>()  changes the protection on the pages "
"specified by I<addr> and I<len>.  The I<pkey> argument specifies the "
"protection key (see B<pkeys>(7))  to assign to the memory.  The protection "
"key must be allocated with B<pkey_alloc>(2)  before it is passed to "
"B<pkey_mprotect>().  For an example of the use of this system call, see "
"B<pkeys>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:148
msgid ""
"On success, B<mprotect>()  and B<pkey_mprotect>()  return zero.  On error, "
"these system calls return -1, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:158
msgid ""
"The memory cannot be given the specified access.  This can happen, for "
"example, if you B<mmap>(2)  a file to which you have read-only access, then "
"ask B<mprotect>()  to mark it B<PROT_WRITE>."
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:162
msgid "I<addr> is not a valid pointer, or not a multiple of the system page size."
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:167
msgid "(B<pkey_mprotect>())  I<pkey> has not been allocated with B<pkey_alloc>(2)"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:175
msgid "Both B<PROT_GROWSUP> and B<PROT_GROWSDOWN> were specified in I<prot>."
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:179
msgid "Invalid flags specified in I<prot>."
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:186
msgid ""
"(PowerPC architecture)  B<PROT_SAO> was specified in I<prot>, but SAO "
"hardware feature is not available."
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:189
msgid "Internal kernel structures could not be allocated."
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:199
msgid ""
"Addresses in the range [I<addr>, I<addr>+I<len>-1] are invalid for the "
"address space of the process, or specify one or more pages that are not "
"mapped.  (Before kernel 2.4.19, the error B<EFAULT> was incorrectly produced "
"for these cases.)"
msgstr ""

#.  I.e., the number of VMAs would exceed the 64 kB maximum
#. type: Plain text
#: build/C/man2/mprotect.2:211
msgid ""
"Changing the protection of a memory region would result in the total number "
"of mappings with distinct attributes (e.g., read versus read/write "
"protection)  exceeding the allowed maximum.  (For example, making the "
"protection of a range B<PROT_READ> in the middle of a region currently "
"protected as B<PROT_READ|PROT_WRITE> would result in three mappings: two "
"read/write mappings at each end and a read-only mapping in the middle.)"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:215
msgid ""
"B<pkey_mprotect>()  first appeared in Linux 4.9; library support was added "
"in glibc 2.27."
msgstr ""

#.  SVr4 defines an additional error
#.  code EAGAIN. The SVr4 error conditions don't map neatly onto Linux's.
#. type: Plain text
#: build/C/man2/mprotect.2:225
msgid ""
"B<mprotect>(): POSIX.1-2001, POSIX.1-2008, SVr4.  POSIX says that the "
"behavior of B<mprotect>()  is unspecified if it is applied to a region of "
"memory that was not obtained via B<mmap>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:228
msgid "B<pkey_mprotect>()  is a nonportable Linux extension."
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:235
msgid ""
"On Linux, it is always permissible to call B<mprotect>()  on any address in "
"a process's address space (except for the kernel vsyscall area).  In "
"particular, it can be used to change existing code mappings to be writable."
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:249
msgid ""
"Whether B<PROT_EXEC> has any effect different from B<PROT_READ> depends on "
"processor architecture, kernel version, and process state.  If "
"B<READ_IMPLIES_EXEC> is set in the process's personality flags (see "
"B<personality>(2)), specifying B<PROT_READ> will implicitly add "
"B<PROT_EXEC>."
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:254
msgid ""
"On some hardware architectures (e.g., i386), B<PROT_WRITE> implies "
"B<PROT_READ>."
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:263
msgid ""
"POSIX.1 says that an implementation may permit access other than that "
"specified in I<prot>, but at a minimum can allow write access only if "
"B<PROT_WRITE> has been set, and must not allow any access if B<PROT_NONE> "
"has been set."
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:276
msgid ""
"Applications should be careful when mixing use of B<mprotect>()  and "
"B<pkey_mprotect>().  On x86, when B<mprotect>()  is used with I<prot> set to "
"B<PROT_EXEC> a pkey may be allocated and set on the memory implicitly by the "
"kernel, but only when the pkey was 0 previously."
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:286
msgid ""
"On systems that do not support protection keys in hardware, "
"B<pkey_mprotect>()  may still be used, but I<pkey> must be set to -1.  When "
"called this way, the operation of B<pkey_mprotect>()  is equivalent to "
"B<mprotect>()."
msgstr ""

#.  sigaction.2 refers to this example
#. type: Plain text
#: build/C/man2/mprotect.2:293
msgid ""
"The program below demonstrates the use of B<mprotect>().  The program "
"allocates four pages of memory, makes the third of these pages read-only, "
"and then executes a loop that walks upward through the allocated region "
"modifying bytes."
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:296
msgid "An example of what we might see when running the program is the following:"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:302
#, no-wrap
msgid ""
"$B< ./a.out>\n"
"Start of region:        0x804c000\n"
"Got SIGSEGV at address: 0x804e000\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:314
#, no-wrap
msgid ""
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>malloc.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>sys/mman.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:319
#, no-wrap
msgid "static char *buffer;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:328
#, no-wrap
msgid ""
"static void\n"
"handler(int sig, siginfo_t *si, void *unused)\n"
"{\n"
"    /* Note: calling printf() from a signal handler is not safe\n"
"       (and should not be done in production programs), since\n"
"       printf() is not async-signal-safe; see signal-safety(7).\n"
"       Nevertheless, we use printf() here as a simple way of\n"
"       showing that the handler was called. */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:332
#, no-wrap
msgid ""
"    printf(\"Got SIGSEGV at address: %p\\en\", si-E<gt>si_addr);\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:338
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int pagesize;\n"
"    struct sigaction sa;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:344
#, no-wrap
msgid ""
"    sa.sa_flags = SA_SIGINFO;\n"
"    sigemptyset(&sa.sa_mask);\n"
"    sa.sa_sigaction = handler;\n"
"    if (sigaction(SIGSEGV, &sa, NULL) == -1)\n"
"        handle_error(\"sigaction\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:348
#, no-wrap
msgid ""
"    pagesize = sysconf(_SC_PAGE_SIZE);\n"
"    if (pagesize == -1)\n"
"        handle_error(\"sysconf\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:351
#, no-wrap
msgid ""
"    /* Allocate a buffer aligned on a page boundary;\n"
"       initial protection is PROT_READ | PROT_WRITE */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:355
#, no-wrap
msgid ""
"    buffer = memalign(pagesize, 4 * pagesize);\n"
"    if (buffer == NULL)\n"
"        handle_error(\"memalign\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:357
#, no-wrap
msgid "    printf(\"Start of region:        %p\\en\", buffer);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:361
#, no-wrap
msgid ""
"    if (mprotect(buffer + pagesize * 2, pagesize,\n"
"                PROT_READ) == -1)\n"
"        handle_error(\"mprotect\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:364
#, no-wrap
msgid ""
"    for (char *p = buffer ; ; )\n"
"        *(p++) = \\(aqa\\(aq;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:368
#, no-wrap
msgid ""
"    printf(\"Loop completed\\en\");     /* Should never happen */\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:373
msgid "B<mmap>(2), B<sysconf>(3), B<pkeys>(7)"
msgstr ""

#. type: TH
#: build/C/man2/mremap.2:30
#, no-wrap
msgid "MREMAP"
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:33
msgid "mremap - remap a virtual memory address"
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:37 build/C/man2/remap_file_pages.2:35 build/C/man2/memfd_create.2:28
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>sys/mman.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:40
#, no-wrap
msgid ""
"B<void *mremap(void *>I<old_address>B<, size_t >I<old_size>B<,>\n"
"B<             size_t >I<new_size>B<, int >I<flags>B<, ... /* void "
"*>I<new_address>B< */);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:46
msgid ""
"B<mremap>()  expands (or shrinks) an existing memory mapping, potentially "
"moving it at the same time (controlled by the I<flags> argument and the "
"available virtual address space)."
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:60
msgid ""
"I<old_address> is the old address of the virtual memory block that you want "
"to expand (or shrink).  Note that I<old_address> has to be page aligned.  "
"I<old_size> is the old size of the virtual memory block.  I<new_size> is the "
"requested size of the virtual memory block after the resize.  An optional "
"fifth argument, I<new_address>, may be provided; see the description of "
"B<MREMAP_FIXED> below."
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:76
msgid ""
"If the value of I<old_size> is zero, and I<old_address> refers to a "
"shareable mapping (see B<mmap>(2)  B<MAP_SHARED>), then B<mremap>()  will "
"create a new mapping of the same pages.  I<new_size> will be the size of the "
"new mapping and the location of the new mapping may be specified with "
"I<new_address>; see the description of B<MREMAP_FIXED> below.  If a new "
"mapping is requested via this method, then the B<MREMAP_MAYMOVE> flag must "
"also be specified."
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:78
msgid "The I<flags> bit-mask argument may be 0, or include the following flags:"
msgstr ""

#. type: TP
#: build/C/man2/mremap.2:78
#, no-wrap
msgid "B<MREMAP_MAYMOVE>"
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:90
msgid ""
"By default, if there is not sufficient space to expand a mapping at its "
"current location, then B<mremap>()  fails.  If this flag is specified, then "
"the kernel is permitted to relocate the mapping to a new virtual address, if "
"necessary.  If the mapping is relocated, then absolute pointers into the old "
"mapping location become invalid (offsets relative to the starting address of "
"the mapping should be employed)."
msgstr ""

#. type: TP
#: build/C/man2/mremap.2:90
#, no-wrap
msgid "B<MREMAP_FIXED> (since Linux 2.3.31)"
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:107
msgid ""
"This flag serves a similar purpose to the B<MAP_FIXED> flag of B<mmap>(2).  "
"If this flag is specified, then B<mremap>()  accepts a fifth argument, "
"I<void\\ *new_address>, which specifies a page-aligned address to which the "
"mapping must be moved.  Any previous mapping at the address range specified "
"by I<new_address> and I<new_size> is unmapped."
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:113
msgid ""
"If B<MREMAP_FIXED> is specified, then B<MREMAP_MAYMOVE> must also be "
"specified."
msgstr ""

#. type: TP
#: build/C/man2/mremap.2:113
#, no-wrap
msgid "B<MREMAP_DONTUNMAP> (since Linux 5.7)"
msgstr ""

#.  commit e346b3813067d4b17383f975f197a9aa28a3b077
#. type: Plain text
#: build/C/man2/mremap.2:120
msgid ""
"This flag, which must be used in conjunction with B<MREMAP_MAYMOVE>, remaps "
"a mapping to a new address but does not unmap the mapping at I<old_address>."
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:130
msgid ""
"The B<MREMAP_DONTUNMAP> flag can be used only with private anonymous "
"mappings (see the description of B<MAP_PRIVATE> and B<MAP_ANONYMOUS> in "
"B<mmap>(2))."
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:143
msgid ""
"After completion, any access to the range specified by I<old_address> and "
"I<old_size> will result in a page fault.  The page fault will be handled by "
"a B<userfaultfd>(2)  handler if the address is in a range previously "
"registered with B<userfaultfd>(2).  Otherwise, the kernel allocates a "
"zero-filled page to handle the fault."
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:150
msgid ""
"The B<MREMAP_DONTUNMAP> flag may be used to atomically move a mapping while "
"leaving the source mapped.  See NOTES for some possible applications of "
"B<MREMAP_DONTUNMAP>."
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:160
msgid ""
"If the memory segment specified by I<old_address> and I<old_size> is locked "
"(using B<mlock>(2)  or similar), then this lock is maintained when the "
"segment is resized and/or relocated.  As a consequence, the amount of memory "
"locked by the process may change."
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:168
msgid ""
"On success B<mremap>()  returns a pointer to the new virtual memory area.  "
"On error, the value B<MAP_FAILED> (that is, I<(void\\ *)\\ -1>) is returned, "
"and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:175
msgid ""
"The caller tried to expand a memory segment that is locked, but this was not "
"possible without exceeding the B<RLIMIT_MEMLOCK> resource limit."
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:184
msgid ""
"Some address in the range I<old_address> to I<old_address>+I<old_size> is an "
"invalid virtual memory address for this process.  You can also get B<EFAULT> "
"even if there exist mappings that cover the whole address space requested, "
"but those mappings are of different types."
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:188
msgid "An invalid argument was given.  Possible causes are:"
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:192
msgid "I<old_address> was not page aligned;"
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:201
msgid ""
"a value other than B<MREMAP_MAYMOVE> or B<MREMAP_FIXED> or "
"B<MREMAP_DONTUNMAP> was specified in I<flags>;"
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:204
msgid "I<new_size> was zero;"
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:209
msgid "I<new_size> or I<new_address> was invalid;"
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:218
msgid ""
"the new address range specified by I<new_address> and I<new_size> overlapped "
"the old address range specified by I<old_address> and I<old_size>;"
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:224
msgid ""
"B<MREMAP_FIXED> or B<MREMAP_DONTUNMAP> was specified without also specifying "
"B<MREMAP_MAYMOVE>;"
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:231
msgid ""
"B<MREMAP_DONTUNMAP> was specified, but one or more pages in the range "
"specified by I<old_address> and I<old_size> were not private anonymous;"
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:237
msgid ""
"B<MREMAP_DONTUNMAP> was specified and I<old_size> was not equal to "
"I<new_size>;"
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:240
msgid ""
"I<old_size> was zero and I<old_address> does not refer to a shareable "
"mapping (but see BUGS);"
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:244
msgid "I<old_size> was zero and the B<MREMAP_MAYMOVE> flag was not specified."
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:249
msgid ""
"Not enough memory was available to complete the operation.  Possible causes "
"are:"
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:255
msgid ""
"The memory area cannot be expanded at the current virtual address, and the "
"B<MREMAP_MAYMOVE> flag is not set in I<flags>.  Or, there is not enough "
"(virtual) memory available."
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:260
msgid ""
"B<MREMAP_DONTUNMAP> was used causing a new mapping to be created that would "
"exceed the (virtual) memory available.  Or, it would exceed the maximum "
"number of allowed mappings."
msgstr ""

#.  4.2BSD had a (never actually implemented)
#.  .BR mremap (2)
#.  call with completely different semantics.
#. type: Plain text
#: build/C/man2/mremap.2:267
msgid ""
"This call is Linux-specific, and should not be used in programs intended to "
"be portable."
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:273
msgid ""
"B<mremap>()  changes the mapping between virtual addresses and memory "
"pages.  This can be used to implement a very efficient B<realloc>(3)."
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:287
msgid ""
"In Linux, memory is divided into pages.  A process has (one or)  several "
"linear virtual memory segments.  Each virtual memory segment has one or more "
"mappings to real memory pages (in the page table).  Each virtual memory "
"segment has its own protection (access rights), which may cause a "
"segmentation violation (B<SIGSEGV>)  if the memory is accessed incorrectly "
"(e.g., writing to a read-only segment).  Accessing virtual memory outside of "
"the segments will also cause a segmentation violation."
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:298
msgid ""
"If B<mremap>()  is used to move or expand an area locked with B<mlock>(2)  "
"or equivalent, the B<mremap>()  call will make a best effort to populate the "
"new area but will not fail with B<ENOMEM> if the area cannot be populated."
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:307
msgid ""
"Prior to version 2.4, glibc did not expose the definition of "
"B<MREMAP_FIXED>, and the prototype for B<mremap>()  did not allow for the "
"I<new_address> argument."
msgstr ""

#. type: SS
#: build/C/man2/mremap.2:307
#, no-wrap
msgid "MREMAP_DONTUNMAP use cases"
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:311
msgid "Possible applications for B<MREMAP_DONTUNMAP> include:"
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:320
msgid ""
"Non-cooperative B<userfaultfd>(2): an application can yank out a virtual "
"address range using B<MREMAP_DONTUNMAP> and then employ a B<userfaultfd>(2)  "
"handler to handle the page faults that subsequently occur as other threads "
"in the process touch pages in the yanked range."
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:333
msgid ""
"Garbage collection: B<MREMAP_DONTUNMAP> can be used in conjunction with "
"B<userfaultfd>(2)  to implement garbage collection algorithms (e.g., in a "
"Java virtual machine).  Such an implementation can be cheaper (and simpler)  "
"than conventional garbage collection techniques that involve marking pages "
"with protection B<PROT_NONE> in conjunction with the of a B<SIGSEGV> handler "
"to catch accesses to those pages."
msgstr ""

#.  commit dba58d3b8c5045ad89c1c95d33d01451e3964db7
#. type: Plain text
#: build/C/man2/mremap.2:354
msgid ""
"Before Linux 4.14, if I<old_size> was zero and the mapping referred to by "
"I<old_address> was a private mapping (B<mmap>(2) B<MAP_PRIVATE>), "
"B<mremap>()  created a new private mapping unrelated to the original "
"mapping.  This behavior was unintended and probably unexpected in user-space "
"applications (since the intention of B<mremap>()  is to create a new mapping "
"based on the original mapping).  Since Linux 4.14, B<mremap>()  fails with "
"the error B<EINVAL> in this scenario."
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:363
msgid ""
"B<brk>(2), B<getpagesize>(2), B<getrlimit>(2), B<mlock>(2), B<mmap>(2), "
"B<sbrk>(2), B<malloc>(3), B<realloc>(3)"
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:369
msgid ""
"Your favorite text book on operating systems for more information on paged "
"memory (e.g., I<Modern Operating Systems> by Andrew S.\\& Tanenbaum, "
"I<Inside Linux> by Randolph Bentson, I<The Design of the UNIX Operating "
"System> by Maurice J.\\& Bach)"
msgstr ""

#. type: TH
#: build/C/man2/msync.2:25
#, no-wrap
msgid "MSYNC"
msgstr ""

#. type: Plain text
#: build/C/man2/msync.2:28
msgid "msync - synchronize a file with a memory map"
msgstr ""

#. type: Plain text
#: build/C/man2/msync.2:32
msgid "B<int msync(void *>I<addr>B<, size_t >I<length>B<, int >I<flags>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/msync.2:48
msgid ""
"B<msync>()  flushes changes made to the in-core copy of a file that was "
"mapped into memory using B<mmap>(2)  back to the filesystem.  Without use of "
"this call, there is no guarantee that changes are written back before "
"B<munmap>(2)  is called.  To be more precise, the part of the file that "
"corresponds to the memory area starting at I<addr> and having length "
"I<length> is updated."
msgstr ""

#. type: Plain text
#: build/C/man2/msync.2:59
msgid ""
"The I<flags> argument should specify exactly one of B<MS_ASYNC> and "
"B<MS_SYNC>, and may additionally include the B<MS_INVALIDATE> bit.  These "
"bits have the following meanings:"
msgstr ""

#. type: TP
#: build/C/man2/msync.2:59
#, no-wrap
msgid "B<MS_ASYNC>"
msgstr ""

#. type: Plain text
#: build/C/man2/msync.2:62
msgid "Specifies that an update be scheduled, but the call returns immediately."
msgstr ""

#. type: TP
#: build/C/man2/msync.2:62
#, no-wrap
msgid "B<MS_SYNC>"
msgstr ""

#. type: Plain text
#: build/C/man2/msync.2:65
msgid "Requests an update and waits for it to complete."
msgstr ""

#. type: TP
#: build/C/man2/msync.2:65
#, no-wrap
msgid "B<MS_INVALIDATE>"
msgstr ""

#.  Since Linux 2.4, this seems to be a no-op (other than the
#.  EBUSY check for VM_LOCKED).
#. type: Plain text
#: build/C/man2/msync.2:71
msgid ""
"Asks to invalidate other mappings of the same file (so that they can be "
"updated with the fresh values just written)."
msgstr ""

#. type: Plain text
#: build/C/man2/msync.2:76
msgid ""
"On success, zero is returned.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""

#. type: TP
#: build/C/man2/msync.2:77
#, no-wrap
msgid "B<EBUSY>"
msgstr ""

#. type: Plain text
#: build/C/man2/msync.2:83
msgid ""
"B<MS_INVALIDATE> was specified in I<flags>, and a memory lock exists for the "
"specified address range."
msgstr ""

#. type: Plain text
#: build/C/man2/msync.2:96
msgid ""
"I<addr> is not a multiple of PAGESIZE; or any bit other than B<MS_ASYNC> | "
"B<MS_INVALIDATE> | B<MS_SYNC> is set in I<flags>; or both B<MS_SYNC> and "
"B<MS_ASYNC> are set in I<flags>."
msgstr ""

#. type: Plain text
#: build/C/man2/msync.2:99
msgid "The indicated memory (or part of it) was not mapped."
msgstr ""

#. type: Plain text
#: build/C/man2/msync.2:101 build/C/man3/shm_open.3:265
msgid "POSIX.1-2001, POSIX.1-2008."
msgstr ""

#. type: Plain text
#: build/C/man2/msync.2:108
msgid ""
"This call was introduced in Linux 1.3.21, and then used B<EFAULT> instead of "
"B<ENOMEM>.  In Linux 2.4.19, this was changed to the POSIX value B<ENOMEM>."
msgstr ""

#.  POSIX.1-2001: It shall be defined to -1 or 0 or 200112L.
#.  -1: unavailable, 0: ask using sysconf().
#.  glibc defines them to 1.
#. type: Plain text
#: build/C/man2/msync.2:123
msgid ""
"On POSIX systems on which B<msync>()  is available, both "
"B<_POSIX_MAPPED_FILES> and B<_POSIX_SYNCHRONIZED_IO> are defined in "
"I<E<lt>unistd.hE<gt>> to a value greater than 0.  (See also B<sysconf>(3).)"
msgstr ""

#.  commit 204ec841fbea3e5138168edbc3a76d46747cc987
#. type: Plain text
#: build/C/man2/msync.2:150
msgid ""
"According to POSIX, either B<MS_SYNC> or B<MS_ASYNC> must be specified in "
"I<flags>, and indeed failure to include one of these flags will cause "
"B<msync>()  to fail on some systems.  However, Linux permits a call to "
"B<msync>()  that specifies neither of these flags, with semantics that are "
"(currently) equivalent to specifying B<MS_ASYNC>.  (Since Linux 2.6.19, "
"B<MS_ASYNC> is in fact a no-op, since the kernel properly tracks dirty pages "
"and flushes them to storage as necessary.)  Notwithstanding the Linux "
"behavior, portable, future-proof applications should ensure that they "
"specify either B<MS_SYNC> or B<MS_ASYNC> in I<flags>."
msgstr ""

#. type: TP
#: build/C/man2/msync.2:152 build/C/man7/shm_overview.7:45
#, no-wrap
msgid "B<mmap>(2)"
msgstr ""

#. type: TH
#: build/C/man3/mtrace.3:25
#, no-wrap
msgid "MTRACE"
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:28
msgid "mtrace, muntrace - malloc tracing"
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:30
msgid "B<#include E<lt>mcheck.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:32
msgid "B<void mtrace(void);>"
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:34
msgid "B<void muntrace(void);>"
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:46
msgid ""
"The B<mtrace>()  function installs hook functions for the memory-allocation "
"functions (B<malloc>(3), B<realloc>(3)  B<memalign>(3), B<free>(3)).  These "
"hook functions record tracing information about memory allocation and "
"deallocation.  The tracing information can be used to discover memory leaks "
"and attempts to free nonallocated memory in a program."
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:57
msgid ""
"The B<muntrace>()  function disables the hook functions installed by "
"B<mtrace>(), so that tracing information is no longer recorded for the "
"memory-allocation functions.  If no hook functions were successfully "
"installed by B<mtrace>(), B<muntrace>()  does nothing."
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:65
msgid ""
"When B<mtrace>()  is called, it checks the value of the environment variable "
"B<MALLOC_TRACE>, which should contain the pathname of a file in which the "
"tracing information is to be recorded.  If the pathname is successfully "
"opened, it is truncated to zero length."
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:78
msgid ""
"If B<MALLOC_TRACE> is not set, or the pathname it specifies is invalid or "
"not writable, then no hook functions are installed, and B<mtrace>()  has no "
"effect.  In set-user-ID and set-group-ID programs, B<MALLOC_TRACE> is "
"ignored, and B<mtrace>()  has no effect."
msgstr ""

#. type: tbl table
#: build/C/man3/mtrace.3:89
#, no-wrap
msgid ""
"B<mtrace>(),\n"
"B<muntrace>()"
msgstr ""

#. type: tbl table
#: build/C/man3/mtrace.3:89
#, no-wrap
msgid "MT-Unsafe"
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:108
msgid ""
"In normal usage, B<mtrace>()  is called once at the start of execution of a "
"program, and B<muntrace>()  is never called."
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:118
msgid ""
"The tracing output produced after a call to B<mtrace>()  is textual, but not "
"designed to be human readable.  The GNU C library provides a Perl script, "
"B<mtrace>(1), that interprets the trace log and produces human-readable "
"output.  For best results, the traced program should be compiled with "
"debugging enabled, so that line-number information is recorded in the "
"executable."
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:124
msgid ""
"The tracing performed by B<mtrace>()  incurs a performance penalty (if "
"B<MALLOC_TRACE> points to a valid, writable pathname)."
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:130
msgid ""
"The line-number information produced by B<mtrace>(1)  is not always precise: "
"the line number references may refer to the previous or following (nonblank)  "
"line of the source code."
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:137
msgid ""
"The shell session below demonstrates the use of the B<mtrace>()  function "
"and the B<mtrace>(1)  command in a program that has memory leaks at two "
"different locations.  The demonstration uses the following program:"
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:144
#, no-wrap
msgid ""
"$ B<cat t_mtrace.c>\n"
"#include E<lt>mcheck.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:149
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    mtrace();\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:152
#, no-wrap
msgid ""
"    for (int j = 0; j E<lt> 2; j++)\n"
"        malloc(100);            /* Never freed--a memory leak */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:156
#, no-wrap
msgid ""
"    calloc(16, 16);             /* Never freed--a memory leak */\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:162
msgid ""
"When we run the program as follows, we see that B<mtrace>()  diagnosed "
"memory leaks at two different locations in the program:"
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:175
#, no-wrap
msgid ""
"$ B<cc -g t_mtrace.c -o t_mtrace>\n"
"$ B<export MALLOC_TRACE=/tmp/t>\n"
"$ B<./t_mtrace>\n"
"$ B<mtrace ./t_mtrace $MALLOC_TRACE>\n"
"Memory not freed:\n"
"-----------------\n"
"   Address     Size     Caller\n"
"0x084c9378     0x64  at /home/cecilia/t_mtrace.c:12\n"
"0x084c93e0     0x64  at /home/cecilia/t_mtrace.c:12\n"
"0x084c9448    0x100  at /home/cecilia/t_mtrace.c:16\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:187
msgid ""
"The first two messages about unfreed memory correspond to the two "
"B<malloc>(3)  calls inside the I<for> loop.  The final message corresponds "
"to the call to B<calloc>(3)  (which in turn calls B<malloc>(3))."
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:192
msgid "B<mtrace>(1), B<malloc>(3), B<malloc_hook>(3), B<mcheck>(3)"
msgstr ""

#. type: TH
#: build/C/man2/posix_fadvise.2:29
#, no-wrap
msgid "POSIX_FADVISE"
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:32
msgid "posix_fadvise - predeclare an access pattern for file data"
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:35 build/C/man3/posix_fallocate.3:31
#, no-wrap
msgid "B<#include E<lt>fcntl.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:38
#, no-wrap
msgid ""
"B<int posix_fadvise(int >I<fd>B<, off_t >I<offset>B<, off_t >I<len>B<, int "
">I<advice>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:47
msgid "B<posix_fadvise>():"
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:49 build/C/man3/posix_fallocate.3:44
msgid "_POSIX_C_SOURCE\\ E<gt>=\\ 200112L"
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:57
msgid ""
"Programs can use B<posix_fadvise>()  to announce an intention to access file "
"data in a specific pattern in the future, thus allowing the kernel to "
"perform appropriate optimizations."
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:64
msgid ""
"The I<advice> applies to a (not necessarily existent) region starting at "
"I<offset> and extending for I<len> bytes (or until the end of the file if "
"I<len> is 0) within the file referred to by I<fd>.  The I<advice> is not "
"binding; it merely constitutes an expectation on behalf of the application."
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:66
msgid "Permissible values for I<advice> include:"
msgstr ""

#. type: TP
#: build/C/man2/posix_fadvise.2:66
#, no-wrap
msgid "B<POSIX_FADV_NORMAL>"
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:72
msgid ""
"Indicates that the application has no advice to give about its access "
"pattern for the specified data.  If no advice is given for an open file, "
"this is the default assumption."
msgstr ""

#. type: TP
#: build/C/man2/posix_fadvise.2:72
#, no-wrap
msgid "B<POSIX_FADV_SEQUENTIAL>"
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:76
msgid ""
"The application expects to access the specified data sequentially (with "
"lower offsets read before higher ones)."
msgstr ""

#. type: TP
#: build/C/man2/posix_fadvise.2:76
#, no-wrap
msgid "B<POSIX_FADV_RANDOM>"
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:79
msgid "The specified data will be accessed in random order."
msgstr ""

#. type: TP
#: build/C/man2/posix_fadvise.2:79
#, no-wrap
msgid "B<POSIX_FADV_NOREUSE>"
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:82
msgid "The specified data will be accessed only once."
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:86
msgid ""
"In kernels before 2.6.18, B<POSIX_FADV_NOREUSE> had the same semantics as "
"B<POSIX_FADV_WILLNEED>.  This was probably a bug; since kernel 2.6.18, this "
"flag is a no-op."
msgstr ""

#. type: TP
#: build/C/man2/posix_fadvise.2:86
#, no-wrap
msgid "B<POSIX_FADV_WILLNEED>"
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:89
msgid "The specified data will be accessed in the near future."
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:96
msgid ""
"B<POSIX_FADV_WILLNEED> initiates a nonblocking read of the specified region "
"into the page cache.  The amount of data read may be decreased by the kernel "
"depending on virtual memory load.  (A few megabytes will usually be fully "
"satisfied, and more is rarely useful.)"
msgstr ""

#. type: TP
#: build/C/man2/posix_fadvise.2:96
#, no-wrap
msgid "B<POSIX_FADV_DONTNEED>"
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:99
msgid "The specified data will not be accessed in the near future."
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:107
msgid ""
"B<POSIX_FADV_DONTNEED> attempts to free cached pages associated with the "
"specified region.  This is useful, for example, while streaming large "
"files.  A program may periodically request the kernel to free cached data "
"that has already been used, so that more useful cached pages are not "
"discarded instead."
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:115
msgid ""
"Requests to discard partial pages are ignored.  It is preferable to preserve "
"needed data than discard unneeded data.  If the application requires that "
"data be considered for discarding, then I<offset> and I<len> must be "
"page-aligned."
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:127
msgid ""
"The implementation I<may> attempt to write back dirty pages in the specified "
"region, but this is not guaranteed.  Any unwritten dirty pages will not be "
"freed.  If the application wishes to ensure that dirty pages will be "
"released, it should call B<fsync>(2)  or B<fdatasync>(2)  first."
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:130
msgid "On success, zero is returned.  On error, an error number is returned."
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:134
msgid "The I<fd> argument was not a valid file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:137
msgid "An invalid value was specified for I<advice>."
msgstr ""

#.  commit 87ba81dba431232548ce29d5d224115d0c2355ac
#. type: Plain text
#: build/C/man2/posix_fadvise.2:147
msgid ""
"The specified file descriptor refers to a pipe or FIFO.  (B<ESPIPE> is the "
"error specified by POSIX, but before kernel version 2.6.16, Linux returned "
"B<EINVAL> in this case.)"
msgstr ""

#.  of fadvise64_64()
#. type: Plain text
#: build/C/man2/posix_fadvise.2:155
msgid ""
"Kernel support first appeared in Linux 2.5.60; the underlying system call is "
"called B<fadvise64>().  Library support has been provided since glibc "
"version 2.2, via the wrapper function B<posix_fadvise>()."
msgstr ""

#.  commit d3ac21cacc24790eb45d735769f35753f5b56ceb
#. type: Plain text
#: build/C/man2/posix_fadvise.2:162
msgid ""
"Since Linux 3.18, support for the underlying system call is optional, "
"depending on the setting of the B<CONFIG_ADVISE_SYSCALLS> configuration "
"option."
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:171
msgid ""
"POSIX.1-2001, POSIX.1-2008.  Note that the type of the I<len> argument was "
"changed from I<size_t> to I<off_t> in POSIX.1-2001 TC1."
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:177
msgid ""
"Under Linux, B<POSIX_FADV_NORMAL> sets the readahead window to the default "
"size for the backing device; B<POSIX_FADV_SEQUENTIAL> doubles this size, and "
"B<POSIX_FADV_RANDOM> disables file readahead entirely.  These changes affect "
"the entire file, not just the specified region (but other open file handles "
"to the same file are unaffected)."
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:182
msgid ""
"The contents of the kernel buffer cache can be cleared via the "
"I</proc/sys/vm/drop_caches> interface described in B<proc>(5)."
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:189
msgid ""
"One can obtain a snapshot of which pages of a file are resident in the "
"buffer cache by opening a file, mapping it with B<mmap>(2), and then "
"applying B<mincore>(2)  to the mapping."
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:199
msgid ""
"The name of the wrapper function in the C library is B<posix_fadvise>().  "
"The underlying system call is called B<fadvise64>()  (or, on some "
"architectures, B<fadvise64_64>()); the difference between the two is that "
"the former system call assumes that the type of the I<len> argument is "
"I<size_t>, while the latter expects I<loff_t> there."
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:216
msgid ""
"Some architectures require 64-bit arguments to be aligned in a suitable pair "
"of registers (see B<syscall>(2)  for further detail).  On such "
"architectures, the call signature of B<posix_fadvise>()  shown in the "
"SYNOPSIS would force a register to be wasted as padding between the I<fd> "
"and I<offset> arguments.  Therefore, these architectures define a version of "
"the system call that orders the arguments suitably, but is otherwise exactly "
"the same as B<posix_fadvise>()."
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:218
msgid "For example, since Linux 2.6.14, ARM has the following system call:"
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:223
#, no-wrap
msgid ""
"B<long arm_fadvise64_64(int >I<fd>B<, int >I<advice>B<,>\n"
"B<                      loff_t >I<offset>B<, loff_t >I<len>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:231
msgid ""
"These architecture-specific details are generally hidden from applications "
"by the glibc B<posix_fadvise>()  wrapper function, which invokes the "
"appropriate architecture-specific system call."
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:236
msgid ""
"In kernels before 2.6.6, if I<len> was specified as 0, then this was "
"interpreted literally as \"zero bytes\", rather than as meaning \"all bytes "
"through to the end of the file\"."
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:243
msgid ""
"B<fincore>(1), B<mincore>(2), B<readahead>(2), B<sync_file_range>(2), "
"B<posix_fallocate>(3), B<posix_madvise>(3)"
msgstr ""

#. type: TH
#: build/C/man3/posix_fallocate.3:25
#, no-wrap
msgid "POSIX_FALLOCATE"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_fallocate.3:28
msgid "posix_fallocate - allocate file space"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_fallocate.3:33
#, no-wrap
msgid "B<int posix_fallocate(int >I<fd>B<, off_t >I<offset>B<, off_t >I<len>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_fallocate.3:42
msgid "B<posix_fallocate>():"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_fallocate.3:61
msgid ""
"The function B<posix_fallocate>()  ensures that disk space is allocated for "
"the file referred to by the file descriptor I<fd> for the bytes in the range "
"starting at I<offset> and continuing for I<len> bytes.  After a successful "
"call to B<posix_fallocate>(), subsequent writes to bytes in the specified "
"range are guaranteed not to fail because of lack of disk space."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_fallocate.3:66
msgid ""
"If the size of the file is less than I<offset>+I<len>, then the file is "
"increased to this size; otherwise the file size is left unchanged."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_fallocate.3:72
msgid ""
"B<posix_fallocate>()  returns zero on success, or an error number on "
"failure.  Note that I<errno> is not set."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_fallocate.3:81
msgid "I<offset+len> exceeds the maximum file size."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_fallocate.3:84
msgid "A signal was caught during execution."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_fallocate.3:91
msgid ""
"I<offset> was less than 0, or I<len> was less than or equal to 0, or the "
"underlying filesystem does not support the operation."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_fallocate.3:95
msgid "I<fd> does not refer to a regular file."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_fallocate.3:107
msgid ""
"The filesystem containing the file referred to by I<fd> does not support "
"this operation.  This error code can be returned by C libraries that don't "
"perform the emulation shown in NOTES, such as musl libc."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_fallocate.3:111
msgid "I<fd> refers to a pipe."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_fallocate.3:114
msgid "B<posix_fallocate>()  is available since glibc 2.1.94."
msgstr ""

#. type: tbl table
#: build/C/man3/posix_fallocate.3:124
#, no-wrap
msgid "B<posix_fallocate>()"
msgstr ""

#. type: tbl table
#: build/C/man3/posix_fallocate.3:124
#, no-wrap
msgid "MT-Safe (but see NOTES)"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_fallocate.3:128 build/C/man3/posix_madvise.3:109
msgid "POSIX.1-2001."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_fallocate.3:151
msgid ""
"POSIX.1-2008 says that an implementation I<shall> give the B<EINVAL> error "
"if I<len> was 0, or I<offset> was less than 0.  POSIX.1-2001 says that an "
"implementation I<shall> give the B<EINVAL> error if I<len> is less than 0, "
"or I<offset> was less than 0, and I<may> give the error if I<len> equals "
"zero."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_fallocate.3:160
msgid ""
"In the glibc implementation, B<posix_fallocate>()  is implemented using the "
"B<fallocate>(2)  system call, which is MT-safe.  If the underlying "
"filesystem does not support B<fallocate>(2), then the operation is emulated "
"with the following caveats:"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_fallocate.3:162
msgid "The emulation is inefficient."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_fallocate.3:165
msgid ""
"There is a race condition where concurrent writes from another thread or "
"process could be overwritten with null bytes."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_fallocate.3:169
msgid ""
"There is a race condition where concurrent file size increases by another "
"thread or process could result in a file whose size is smaller than "
"expected."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_fallocate.3:178
msgid ""
"If I<fd> has been opened with the B<O_APPEND> or B<O_WRONLY> flags, the "
"function fails with the error B<EBADF>."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_fallocate.3:188
msgid ""
"In general, the emulation is not MT-safe.  On Linux, applications may use "
"B<fallocate>(2)  if they cannot tolerate the emulation caveats.  In general, "
"this is only recommended if the application plans to terminate the operation "
"if B<EOPNOTSUPP> is returned, otherwise the application itself will need to "
"implement a fallback with all the same problems as the emulation provided by "
"glibc."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_fallocate.3:193
msgid "B<fallocate>(1), B<fallocate>(2), B<lseek>(2), B<posix_fadvise>(2)"
msgstr ""

#. type: TH
#: build/C/man3/posix_madvise.3:20
#, no-wrap
msgid "POSIX_MADVISE"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_madvise.3:23
msgid "posix_madvise - give advice about patterns of memory usage"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_madvise.3:28
#, no-wrap
msgid ""
"B<int posix_madvise(void *>I<addr>B<, size_t >I<len>B<, int "
">I<advice>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_madvise.3:36
msgid "B<posix_madvise>():"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_madvise.3:40
msgid "_POSIX_C_SOURCE E<gt>= 200112L"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_madvise.3:55
msgid ""
"The B<posix_madvise>()  function allows an application to advise the system "
"about its expected patterns of usage of memory in the address range starting "
"at I<addr> and continuing for I<len> bytes.  The system is free to use this "
"advice in order to improve the performance of memory accesses (or to ignore "
"the advice altogether), but calling B<posix_madvise>()  shall not affect the "
"semantics of access to memory in the specified range."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_madvise.3:59
msgid "The I<advice> argument is one of the following:"
msgstr ""

#. type: TP
#: build/C/man3/posix_madvise.3:59
#, no-wrap
msgid "B<POSIX_MADV_NORMAL>"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_madvise.3:64
msgid ""
"The application has no special advice regarding its memory usage patterns "
"for the specified address range.  This is the default behavior."
msgstr ""

#. type: TP
#: build/C/man3/posix_madvise.3:64
#, no-wrap
msgid "B<POSIX_MADV_SEQUENTIAL>"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_madvise.3:70
msgid ""
"The application expects to access the specified address range sequentially, "
"running from lower addresses to higher addresses.  Hence, pages in this "
"region can be aggressively read ahead, and may be freed soon after they are "
"accessed."
msgstr ""

#. type: TP
#: build/C/man3/posix_madvise.3:70
#, no-wrap
msgid "B<POSIX_MADV_RANDOM>"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_madvise.3:74
msgid ""
"The application expects to access the specified address range randomly.  "
"Thus, read ahead may be less useful than normally."
msgstr ""

#. type: TP
#: build/C/man3/posix_madvise.3:74
#, no-wrap
msgid "B<POSIX_MADV_WILLNEED>"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_madvise.3:79
msgid ""
"The application expects to access the specified address range in the near "
"future.  Thus, read ahead may be beneficial."
msgstr ""

#. type: TP
#: build/C/man3/posix_madvise.3:79
#, no-wrap
msgid "B<POSIX_MADV_DONTNEED>"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_madvise.3:83
msgid ""
"The application expects that it will not access the specified address range "
"in the near future."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_madvise.3:88
msgid ""
"On success, B<posix_madvise>()  returns 0.  On failure, it returns a "
"positive error number."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_madvise.3:95
msgid "I<addr> is not a multiple of the system page size or I<len> is negative."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_madvise.3:99
msgid "I<advice> is invalid."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_madvise.3:103
msgid ""
"Addresses in the specified range are partially or completely outside the "
"caller's address space."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_madvise.3:107
msgid "Support for B<posix_madvise>()  first appeared in glibc version 2.2."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_madvise.3:116
msgid ""
"POSIX.1 permits an implementation to generate an error if I<len> is 0.  On "
"Linux, specifying I<len> as 0 is permitted (as a successful no-op)."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_madvise.3:126
msgid ""
"In glibc, this function is implemented using B<madvise>(2).  However, since "
"glibc 2.6, B<POSIX_MADV_DONTNEED> is treated as a no-op, because the "
"corresponding B<madvise>(2)  value, B<MADV_DONTNEED>, has destructive "
"semantics."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_madvise.3:129
msgid "B<madvise>(2), B<posix_fadvise>(2)"
msgstr ""

#. type: TH
#: build/C/man3/posix_memalign.3:29
#, no-wrap
msgid "POSIX_MEMALIGN"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:32
msgid ""
"posix_memalign, aligned_alloc, memalign, valloc, pvalloc - allocate aligned "
"memory"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:35
#, no-wrap
msgid "B<#include E<lt>stdlib.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:39
#, no-wrap
msgid ""
"B<int posix_memalign(void **>I<memptr>B<, size_t >I<alignment>B<, size_t "
">I<size>B<);>\n"
"B<void *aligned_alloc(size_t >I<alignment>B<, size_t >I<size>B<);>\n"
"B<void *valloc(size_t >I<size>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:44
#, no-wrap
msgid ""
"B<void *memalign(size_t >I<alignment>B<, size_t >I<size>B<);>\n"
"B<void *pvalloc(size_t >I<size>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:54
msgid "B<posix_memalign>(): _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:57
msgid "B<aligned_alloc>(): _ISOC11_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:59
msgid "B<valloc>():"
msgstr ""

#. type: TP
#: build/C/man3/posix_memalign.3:62
#, no-wrap
msgid "Since glibc 2.12:"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:68
#, no-wrap
msgid ""
"(_XOPEN_SOURCE\\ E<gt>=\\ 500) && !(_POSIX_C_SOURCE\\ E<gt>=\\ 200112L)\n"
"    || /* Glibc since 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _SVID_SOURCE || _BSD_SOURCE\n"
msgstr ""

#. type: TP
#: build/C/man3/posix_memalign.3:70
#, no-wrap
msgid "Before glibc 2.12:"
msgstr ""

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: build/C/man3/posix_memalign.3:74
msgid "_BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:81
msgid ""
"(The (nonstandard) header file I<E<lt>malloc.hE<gt>> also exposes the "
"declaration of B<valloc>(); no feature test macros are required.)"
msgstr ""

#.  glibc does this:
#. type: Plain text
#: build/C/man3/posix_memalign.3:104
msgid ""
"The function B<posix_memalign>()  allocates I<size> bytes and places the "
"address of the allocated memory in I<*memptr>.  The address of the allocated "
"memory will be a multiple of I<alignment>, which must be a power of two and "
"a multiple of I<sizeof(void\\ *)>.  This address can later be successfully "
"passed to B<free>(3).  If I<size> is 0, then the value placed in I<*memptr> "
"is either NULL or a unique pointer value."
msgstr ""

#.  The behavior of memalign() for size==0 is as for posix_memalign()
#.  but no standards govern this.
#. type: Plain text
#: build/C/man3/posix_memalign.3:115
msgid ""
"The obsolete function B<memalign>()  allocates I<size> bytes and returns a "
"pointer to the allocated memory.  The memory address will be a multiple of "
"I<alignment>, which must be a power of two."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:124
msgid ""
"The function B<aligned_alloc>()  is the same as B<memalign>(), except for "
"the added restriction that I<size> should be a multiple of I<alignment>."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:133
msgid ""
"The obsolete function B<valloc>()  allocates I<size> bytes and returns a "
"pointer to the allocated memory.  The memory address will be a multiple of "
"the page size.  It is equivalent to I<memalign(sysconf(_SC_PAGESIZE),size)>."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:140
msgid ""
"The obsolete function B<pvalloc>()  is similar to B<valloc>(), but rounds "
"the size of the allocation up to the next multiple of the system page size."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:142
msgid "For all of these functions, the memory is not zeroed."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:151
msgid ""
"B<aligned_alloc>(), B<memalign>(), B<valloc>(), and B<pvalloc>()  return a "
"pointer to the allocated memory on success.  On error, NULL is returned, and "
"I<errno> is set to indicate the cause of the error."
msgstr ""

#.  http://austingroupbugs.net/view.php?id=520
#. type: Plain text
#: build/C/man3/posix_memalign.3:165
msgid ""
"B<posix_memalign>()  returns zero on success, or one of the error values "
"listed in the next section on failure.  The value of I<errno> is not set.  "
"On Linux (and other systems), B<posix_memalign>()  does not modify I<memptr> "
"on failure.  A requirement standardizing this behavior was added in "
"POSIX.1-2008 TC2."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:172
msgid ""
"The I<alignment> argument was not a power of two, or was not a multiple of "
"I<sizeof(void\\ *)>."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:175
msgid "There was insufficient memory to fulfill the allocation request."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:182
msgid ""
"The functions B<memalign>(), B<valloc>(), and B<pvalloc>()  have been "
"available since at least glibc 2.0."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:186
msgid "The function B<aligned_alloc>()  was added to glibc in version 2.16."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:190
msgid "The function B<posix_memalign>()  is available since glibc 2.1.91."
msgstr ""

#. type: tbl table
#: build/C/man3/posix_memalign.3:200
#, no-wrap
msgid "B<aligned_alloc>(),\n"
msgstr ""

#. type: tbl table
#: build/C/man3/posix_memalign.3:202
#, no-wrap
msgid "B<memalign>(),\n"
msgstr ""

#. type: tbl table
#: build/C/man3/posix_memalign.3:204
#, no-wrap
msgid "B<posix_memalign>()"
msgstr ""

#. type: tbl table
#: build/C/man3/posix_memalign.3:207
#, no-wrap
msgid "B<valloc>(),\n"
msgstr ""

#. type: tbl table
#: build/C/man3/posix_memalign.3:209
#, no-wrap
msgid "B<pvalloc>()"
msgstr ""

#. type: tbl table
#: build/C/man3/posix_memalign.3:209
#, no-wrap
msgid "MT-Unsafe init"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:219
msgid ""
"The function B<valloc>()  appeared in 3.0BSD.  It is documented as being "
"obsolete in 4.3BSD, and as legacy in SUSv2.  It does not appear in POSIX.1."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:223
msgid "The function B<pvalloc>()  is a GNU extension."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:227
msgid "The function B<memalign>()  appears in SunOS 4.1.3 but not in 4.4BSD."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:231
msgid ""
"The function B<posix_memalign>()  comes from POSIX.1d and is specified in "
"POSIX.1-2001 and POSIX.1-2008."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:236
msgid "The function B<aligned_alloc>()  is specified in the C11 standard."
msgstr ""

#. type: SS
#: build/C/man3/posix_memalign.3:236
#, no-wrap
msgid "Headers"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:240
msgid ""
"Everybody agrees that B<posix_memalign>()  is declared in "
"I<E<lt>stdlib.hE<gt>>."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:244
msgid ""
"On some systems B<memalign>()  is declared in I<E<lt>stdlib.hE<gt>> instead "
"of I<E<lt>malloc.hE<gt>>."
msgstr ""

#.  Libc4,5 and
#. type: Plain text
#: build/C/man3/posix_memalign.3:252
msgid ""
"According to SUSv2, B<valloc>()  is declared in I<E<lt>stdlib.hE<gt>>.  "
"Glibc declares it in I<E<lt>malloc.hE<gt>>, and also in "
"I<E<lt>stdlib.hE<gt>> if suitable feature test macros are defined (see "
"above)."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:261
msgid ""
"On many systems there are alignment restrictions, for example, on buffers "
"used for direct block device I/O.  POSIX specifies the "
"I<pathconf(path,_PC_REC_XFER_ALIGN)> call that tells what alignment is "
"needed.  Now one can use B<posix_memalign>()  to satisfy this requirement."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:270
msgid ""
"B<posix_memalign>()  verifies that I<alignment> matches the requirements "
"detailed above.  B<memalign>()  may not check that the I<alignment> argument "
"is correct."
msgstr ""

#.  Other systems allow passing the result of
#.  .IR valloc ()
#.  to
#.  .IR free (3),
#.  but not to
#.  .IR realloc (3).
#. type: Plain text
#: build/C/man3/posix_memalign.3:298
msgid ""
"POSIX requires that memory obtained from B<posix_memalign>()  can be freed "
"using B<free>(3).  Some systems provide no way to reclaim memory allocated "
"with B<memalign>()  or B<valloc>()  (because one can pass to B<free>(3)  "
"only a pointer obtained from B<malloc>(3), while, for example, B<memalign>()  "
"would call B<malloc>(3)  and then align the obtained value).  The glibc "
"implementation allows memory obtained from any of these functions to be "
"reclaimed with B<free>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:303
msgid ""
"The glibc B<malloc>(3)  always returns 8-byte aligned memory addresses, so "
"these functions are needed only if you require larger alignment values."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:308
msgid "B<brk>(2), B<getpagesize>(2), B<free>(3), B<malloc>(3)"
msgstr ""

#. type: TH
#: build/C/man2/readahead.2:28
#, no-wrap
msgid "READAHEAD"
msgstr ""

#. type: Plain text
#: build/C/man2/readahead.2:31
msgid "readahead - initiate file readahead into page cache"
msgstr ""

#. type: Plain text
#: build/C/man2/readahead.2:37
#, no-wrap
msgid ""
"B<ssize_t readahead(int >I<fd>B<, off64_t >I<offset>B<, size_t "
">I<count>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/readahead.2:44
msgid ""
"B<readahead>()  initiates readahead on a file so that subsequent reads from "
"that file will be satisfied from the cache, and not block on disk I/O "
"(assuming the readahead was initiated early enough and that other activity "
"on the system did not in the meantime flush pages from the cache)."
msgstr ""

#. type: Plain text
#: build/C/man2/readahead.2:66
msgid ""
"The I<fd> argument is a file descriptor identifying the file which is to be "
"read.  The I<offset> argument specifies the starting point from which data "
"is to be read and I<count> specifies the number of bytes to be read.  I/O is "
"performed in whole pages, so that I<offset> is effectively rounded down to a "
"page boundary and bytes are read up to the next page boundary greater than "
"or equal to I<(offset+count)>.  B<readahead>()  does not read beyond the end "
"of the file.  The file offset of the open file description referred to by "
"the file descriptor I<fd> is left unchanged."
msgstr ""

#. type: Plain text
#: build/C/man2/readahead.2:72
msgid ""
"On success, B<readahead>()  returns 0; on failure, -1 is returned, with "
"I<errno> set to indicate the cause of the error."
msgstr ""

#. type: Plain text
#: build/C/man2/readahead.2:77
msgid "I<fd> is not a valid file descriptor or is not open for reading."
msgstr ""

#. type: Plain text
#: build/C/man2/readahead.2:83
msgid "I<fd> does not refer to a file type to which B<readahead>()  can be applied."
msgstr ""

#. type: Plain text
#: build/C/man2/readahead.2:88
msgid ""
"The B<readahead>()  system call appeared in Linux 2.4.13; glibc support has "
"been provided since version 2.3."
msgstr ""

#. type: Plain text
#: build/C/man2/readahead.2:93
msgid ""
"The B<readahead>()  system call is Linux-specific, and its use should be "
"avoided in portable applications."
msgstr ""

#. type: Plain text
#: build/C/man2/readahead.2:98
msgid ""
"On some 32-bit architectures, the calling signature for this system call "
"differs, for the reasons described in B<syscall>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/readahead.2:107
msgid ""
"B<readahead>()  attempts to schedule the reads in the background and return "
"immediately.  However, it may block while it reads the filesystem metadata "
"needed to locate the requested blocks.  This occurs frequently with ext[234] "
"on large files using indirect blocks instead of extents, giving the "
"appearance that the call blocks until the requested data has been read."
msgstr ""

#. type: Plain text
#: build/C/man2/readahead.2:113
msgid "B<lseek>(2), B<madvise>(2), B<mmap>(2), B<posix_fadvise>(2), B<read>(2)"
msgstr ""

#. type: TH
#: build/C/man2/remap_file_pages.2:28
#, no-wrap
msgid "REMAP_FILE_PAGES"
msgstr ""

#. type: Plain text
#: build/C/man2/remap_file_pages.2:31
msgid "remap_file_pages - create a nonlinear file mapping"
msgstr ""

#. type: Plain text
#: build/C/man2/remap_file_pages.2:38
#, no-wrap
msgid ""
"B<int remap_file_pages(void *>I<addr>B<, size_t >I<size>B<, int "
">I<prot>B<,>\n"
"B<                     size_t >I<pgoff>B<, int >I<flags>B<);>\n"
msgstr ""

#.  commit 33041a0d76d3c3e0aff28ac95a2ffdedf1282dbc
#.  http://lwn.net/Articles/597632/
#.  commit c8d78c1823f46519473949d33f0d1d33fe21ea16
#. type: Plain text
#: build/C/man2/remap_file_pages.2:53
msgid ""
"B<Note>: this system call was marked as deprecated starting with Linux "
"3.16.  In Linux 4.0, the implementation was replaced by a slower in-kernel "
"emulation.  Those few applications that use this system call should consider "
"migrating to alternatives.  This change was made because the kernel code for "
"this system call was complex, and it is believed to be little used or "
"perhaps even completely unused.  While it had some use cases in database "
"applications on 32-bit systems, those use cases don't exist on 64-bit "
"systems."
msgstr ""

#. type: Plain text
#: build/C/man2/remap_file_pages.2:65
msgid ""
"The B<remap_file_pages>()  system call is used to create a nonlinear "
"mapping, that is, a mapping in which the pages of the file are mapped into a "
"nonsequential order in memory.  The advantage of using B<remap_file_pages>()  "
"over using repeated calls to B<mmap>(2)  is that the former approach does "
"not require the kernel to create additional VMA (Virtual Memory Area) data "
"structures."
msgstr ""

#. type: Plain text
#: build/C/man2/remap_file_pages.2:67
msgid "To create a nonlinear mapping we perform the following steps:"
msgstr ""

#. type: IP
#: build/C/man2/remap_file_pages.2:67 build/C/man2/memfd_create.2:261
#, no-wrap
msgid "1."
msgstr ""

#. type: Plain text
#: build/C/man2/remap_file_pages.2:75
msgid ""
"Use B<mmap>(2)  to create a mapping (which is initially linear).  This "
"mapping must be created with the B<MAP_SHARED> flag."
msgstr ""

#. type: IP
#: build/C/man2/remap_file_pages.2:75 build/C/man2/memfd_create.2:267
#, no-wrap
msgid "2."
msgstr ""

#. type: Plain text
#: build/C/man2/remap_file_pages.2:83
msgid ""
"Use one or more calls to B<remap_file_pages>()  to rearrange the "
"correspondence between the pages of the mapping and the pages of the file.  "
"It is possible to map the same page of a file into multiple locations within "
"the mapped region."
msgstr ""

#. type: Plain text
#: build/C/man2/remap_file_pages.2:94
msgid ""
"The I<pgoff> and I<size> arguments specify the region of the file that is to "
"be relocated within the mapping: I<pgoff> is a file offset in units of the "
"system page size; I<size> is the length of the region in bytes."
msgstr ""

#. type: Plain text
#: build/C/man2/remap_file_pages.2:112
msgid ""
"The I<addr> argument serves two purposes.  First, it identifies the mapping "
"whose pages we want to rearrange.  Thus, I<addr> must be an address that "
"falls within a region previously mapped by a call to B<mmap>(2).  Second, "
"I<addr> specifies the address at which the file pages identified by I<pgoff> "
"and I<size> will be placed."
msgstr ""

#.  This rounding is weird, and not consistent with the treatment of
#.  the analogous arguments for munmap()/mprotect() and for mlock().
#.  MTK, 14 Sep 2005
#. type: Plain text
#: build/C/man2/remap_file_pages.2:126
msgid ""
"The values specified in I<addr> and I<size> should be multiples of the "
"system page size.  If they are not, then the kernel rounds I<both> values "
"I<down> to the nearest multiple of the page size."
msgstr ""

#. type: Plain text
#: build/C/man2/remap_file_pages.2:130
msgid "The I<prot> argument must be specified as 0."
msgstr ""

#. type: Plain text
#: build/C/man2/remap_file_pages.2:138
msgid ""
"The I<flags> argument has the same meaning as for B<mmap>(2), but all flags "
"other than B<MAP_NONBLOCK> are ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/remap_file_pages.2:145
msgid ""
"On success, B<remap_file_pages>()  returns 0.  On error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/remap_file_pages.2:153
msgid ""
"I<addr> does not refer to a valid mapping created with the B<MAP_SHARED> "
"flag."
msgstr ""

#.  And possibly others from vma->vm_ops->populate()
#. type: Plain text
#: build/C/man2/remap_file_pages.2:162
msgid "I<addr>, I<size>, I<prot>, or I<pgoff> is invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/remap_file_pages.2:167
msgid ""
"The B<remap_file_pages>()  system call appeared in Linux 2.5.46; glibc "
"support was added in version 2.3.3."
msgstr ""

#. type: Plain text
#: build/C/man2/remap_file_pages.2:171
msgid "The B<remap_file_pages>()  system call is Linux-specific."
msgstr ""

#.  commit 3ee6dafc677a68e461a7ddafc94a580ebab80735
#. type: Plain text
#: build/C/man2/remap_file_pages.2:184
msgid ""
"Since Linux 2.6.23, B<remap_file_pages>()  creates non-linear mappings only "
"on in-memory filesystems such as B<tmpfs>(5), hugetlbfs or ramfs.  On "
"filesystems with a backing store, B<remap_file_pages>()  is not much more "
"efficient than using B<mmap>(2)  to adjust which parts of the file are "
"mapped to which addresses."
msgstr ""

#. type: Plain text
#: build/C/man2/remap_file_pages.2:191
msgid ""
"B<getpagesize>(2), B<mmap>(2), B<mmap2>(2), B<mprotect>(2), B<mremap>(2), "
"B<msync>(2)"
msgstr ""

#. type: TH
#: build/C/man3/shm_open.3:25
#, no-wrap
msgid "SHM_OPEN"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:28
msgid "shm_open, shm_unlink - create/open or unlink POSIX shared memory objects"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:32
msgid "B<#include E<lt>sys/stat.hE<gt>> /* For mode constants */"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:34
msgid "B<#include E<lt>fcntl.hE<gt>> /* For O_* constants */"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:36
msgid "B<int shm_open(const char *>I<name>B<, int >I<oflag>B<, mode_t >I<mode>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:38
msgid "B<int shm_unlink(const char *>I<name>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:40
msgid "Link with I<-lrt>."
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:52
msgid ""
"B<shm_open>()  creates and opens a new, or opens an existing, POSIX shared "
"memory object.  A POSIX shared memory object is in effect a handle which can "
"be used by unrelated processes to B<mmap>(2)  the same region of shared "
"memory.  The B<shm_unlink>()  function performs the converse operation, "
"removing an object previously created by B<shm_open>()."
msgstr ""

#.  glibc allows the initial slash to be omitted, and makes
#.  multiple initial slashes equivalent to a single slash.
#.  This differs from the implementation of POSIX message queues.
#.  glibc allows subdirectory components in the name, in which
#.  case the subdirectory must exist under /dev/shm, and allow the
#.  required permissions if a user wants to create a shared memory
#.  object in that subdirectory.
#. type: Plain text
#: build/C/man3/shm_open.3:73
msgid ""
"The operation of B<shm_open>()  is analogous to that of B<open>(2).  I<name> "
"specifies the shared memory object to be created or opened.  For portable "
"use, a shared memory object should be identified by a name of the form "
"I</somename>; that is, a null-terminated string of up to B<NAME_MAX> (i.e., "
"255) characters consisting of an initial slash, followed by one or more "
"characters, none of which are slashes."
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:80
msgid ""
"I<oflag> is a bit mask created by ORing together exactly one of B<O_RDONLY> "
"or B<O_RDWR> and any of the other flags listed here:"
msgstr ""

#. type: TP
#: build/C/man3/shm_open.3:80
#, no-wrap
msgid "B<O_RDONLY>"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:88
msgid ""
"Open the object for read access.  A shared memory object opened in this way "
"can be B<mmap>(2)ed only for read (B<PROT_READ>)  access."
msgstr ""

#. type: TP
#: build/C/man3/shm_open.3:88
#, no-wrap
msgid "B<O_RDWR>"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:91
msgid "Open the object for read-write access."
msgstr ""

#. type: TP
#: build/C/man3/shm_open.3:91
#, no-wrap
msgid "B<O_CREAT>"
msgstr ""

#.  In truth it is actually the filesystem IDs on Linux, but these
#.  are nearly always the same as the effective IDs.  (MTK, Jul 05)
#. type: Plain text
#: build/C/man3/shm_open.3:111
msgid ""
"Create the shared memory object if it does not exist.  The user and group "
"ownership of the object are taken from the corresponding effective IDs of "
"the calling process, and the object's permission bits are set according to "
"the low-order 9 bits of I<mode>, except that those bits set in the process "
"file mode creation mask (see B<umask>(2))  are cleared for the new object.  "
"A set of macro constants which can be used to define I<mode> is listed in "
"B<open>(2).  (Symbolic definitions of these constants can be obtained by "
"including I<E<lt>sys/stat.hE<gt>>.)"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:117
msgid ""
"A new shared memory object initially has zero length\\(emthe size of the "
"object can be set using B<ftruncate>(2).  The newly allocated bytes of a "
"shared memory object are automatically initialized to 0."
msgstr ""

#. type: TP
#: build/C/man3/shm_open.3:117
#, no-wrap
msgid "B<O_EXCL>"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:126
msgid ""
"If B<O_CREAT> was also specified, and a shared memory object with the given "
"I<name> already exists, return an error.  The check for the existence of the "
"object, and its creation if it does not exist, are performed atomically."
msgstr ""

#. type: TP
#: build/C/man3/shm_open.3:126
#, no-wrap
msgid "B<O_TRUNC>"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:129
msgid "If the shared memory object already exists, truncate it to zero bytes."
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:132
msgid ""
"Definitions of these flag values can be obtained by including "
"I<E<lt>fcntl.hE<gt>>."
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:143
msgid ""
"On successful completion B<shm_open>()  returns a new file descriptor "
"referring to the shared memory object.  This file descriptor is guaranteed "
"to be the lowest-numbered file descriptor not previously opened within the "
"process.  The B<FD_CLOEXEC> flag (see B<fcntl>(2))  is set for the file "
"descriptor."
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:152
msgid ""
"The file descriptor is normally used in subsequent calls to B<ftruncate>(2)  "
"(for a newly created object) and B<mmap>(2).  After a call to B<mmap>(2)  "
"the file descriptor may be closed without affecting the memory mapping."
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:170
msgid ""
"The operation of B<shm_unlink>()  is analogous to B<unlink>(2): it removes a "
"shared memory object name, and, once all processes have unmapped the object, "
"de-allocates and destroys the contents of the associated memory region.  "
"After a successful B<shm_unlink>(), attempts to B<shm_open>()  an object "
"with the same I<name> fail (unless B<O_CREAT> was specified, in which case a "
"new, distinct object is created)."
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:179
msgid ""
"On success, B<shm_open>()  returns a file descriptor (a nonnegative "
"integer).  On failure, B<shm_open>()  returns -1.  B<shm_unlink>()  returns "
"0 on success, or -1 on error."
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:186
msgid ""
"On failure, I<errno> is set to indicate the cause of the error.  Values "
"which may appear in I<errno> include the following:"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:191
msgid "Permission to B<shm_unlink>()  the shared memory object was denied."
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:201
msgid ""
"Permission was denied to B<shm_open>()  I<name> in the specified I<mode>, or "
"B<O_TRUNC> was specified and the caller does not have write permission on "
"the object."
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:212
msgid ""
"Both B<O_CREAT> and B<O_EXCL> were specified to B<shm_open>()  and the "
"shared memory object specified by I<name> already exists."
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:219
msgid "The I<name> argument to B<shm_open>()  was invalid."
msgstr ""

#. type: TP
#: build/C/man3/shm_open.3:219 build/C/man2/memfd_create.2:190
#, no-wrap
msgid "B<EMFILE>"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:222 build/C/man2/memfd_create.2:193
msgid ""
"The per-process limit on the number of open file descriptors has been "
"reached."
msgstr ""

#. type: TP
#: build/C/man3/shm_open.3:222
#, no-wrap
msgid "B<ENAMETOOLONG>"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:228
msgid "The length of I<name> exceeds B<PATH_MAX>."
msgstr ""

#. type: TP
#: build/C/man3/shm_open.3:231 build/C/man3/shm_open.3:240 build/C/man2/shmget.2:257
#, no-wrap
msgid "B<ENOENT>"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:240
msgid ""
"An attempt was made to B<shm_open>()  a I<name> that did not exist, and "
"B<O_CREAT> was not specified."
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:247
msgid "An attempt was to made to B<shm_unlink>()  a I<name> that does not exist."
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:249
msgid "These functions are provided in glibc 2.2 and later."
msgstr ""

#. type: tbl table
#: build/C/man3/shm_open.3:260
#, no-wrap
msgid ""
"B<shm_open>(),\n"
"B<shm_unlink>()"
msgstr ""

#. type: tbl table
#: build/C/man3/shm_open.3:260
#, no-wrap
msgid "MT-Safe locale"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:273
msgid ""
"POSIX.1-2001 says that the group ownership of a newly created shared memory "
"object is set to either the calling process's effective group ID or \"a "
"system default group ID\".  POSIX.1-2008 says that the group ownership may "
"be set to either the calling process's effective group ID or, if the object "
"is visible in the filesystem, the group ID of the parent directory."
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:281
msgid ""
"POSIX leaves the behavior of the combination of B<O_RDONLY> and B<O_TRUNC> "
"unspecified.  On Linux, this will successfully truncate an existing shared "
"memory object\\(emthis may not be so on other UNIX systems."
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:287
msgid ""
"The POSIX shared memory object implementation on Linux makes use of a "
"dedicated B<tmpfs>(5)  filesystem that is normally mounted under "
"I</dev/shm>."
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:295
msgid ""
"The programs below employ POSIX shared memory and POSIX unnamed semaphores "
"to exchange a piece of data.  The \"bounce\" program (which must be run "
"first) raises the case of a string that is placed into the shared memory by "
"the \"send\" program.  Once the data has been modified, the \"send\" program "
"then prints the contents of the modified shared memory.  An example "
"execution of the two programs is the following:"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:302
#, no-wrap
msgid ""
"$ B<./pshm_ucase_bounce /myshm &>\n"
"[1] 270171\n"
"$ B<./pshm_ucase_send /myshm hello>\n"
"HELLO\n"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:307
msgid "Further detail about these programs is provided below."
msgstr ""

#. type: SS
#: build/C/man3/shm_open.3:307
#, no-wrap
msgid "Program source: pshm_ucase.h"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:311
msgid ""
"The following header file is included by both programs below.  Its primary "
"purpose is to define a structure that will be imposed on the memory object "
"that is shared between the two programs."
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:321
#, no-wrap
msgid ""
"#include E<lt>sys/mman.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>semaphore.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:326
#, no-wrap
msgid "#define BUF_SIZE 1024   /* Maximum size for exchanged string */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:329
#, no-wrap
msgid ""
"/* Define a structure that will be imposed on the shared\n"
"   memory object */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:336
#, no-wrap
msgid ""
"struct shmbuf {\n"
"    sem_t  sem1;            /* POSIX unnamed semaphore */\n"
"    sem_t  sem2;            /* POSIX unnamed semaphore */\n"
"    size_t cnt;             /* Number of bytes used in \\(aqbuf\\(aq */\n"
"    char   buf[BUF_SIZE];   /* Data being transferred */\n"
"};\n"
msgstr ""

#. type: SS
#: build/C/man3/shm_open.3:339
#, no-wrap
msgid "Program source: pshm_ucase_bounce.c"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:347
msgid ""
"The \"bounce\" program creates a new shared memory object with the name "
"given in its command-line argument and sizes the object to match the size of "
"the I<shmbuf> structure defined in the header file.  It then maps the object "
"into the process's address space, and initializes two POSIX semaphores "
"inside the object to 0."
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:352
msgid ""
"After the \"send\" program has posted the first of the semaphores, the "
"\"bounce\" program upper cases the data that has been placed in the memory "
"by the \"send\" program and then posts the second semaphore to tell the "
"\"send\" program that it may now access the shared memory."
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:356
#, no-wrap
msgid "/* pshm_ucase_bounce.c\n"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:361
#, no-wrap
msgid ""
"   Licensed under GNU General Public License v2 or later.\n"
"*/\n"
"#include E<lt>ctype.hE<gt>\n"
"#include \"pshm_ucase.h\"\n"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:369
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s /shm-path\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:371
#, no-wrap
msgid "    char *shmpath = argv[1];\n"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:374
#, no-wrap
msgid ""
"    /* Create shared memory object and set its size to the size\n"
"       of our structure */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:379
#, no-wrap
msgid ""
"    int fd = shm_open(shmpath, O_CREAT | O_EXCL | O_RDWR,\n"
"                      S_IRUSR | S_IWUSR);\n"
"    if (fd == -1)\n"
"        errExit(\"shm_open\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:382
#, no-wrap
msgid ""
"    if (ftruncate(fd, sizeof(struct shmbuf)) == -1)\n"
"        errExit(\"ftruncate\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:384
#, no-wrap
msgid "    /* Map the object into the caller\\(aqs address space */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:390 build/C/man3/shm_open.3:479
#, no-wrap
msgid ""
"    struct shmbuf *shmp = mmap(NULL, sizeof(*shmp),\n"
"                               PROT_READ | PROT_WRITE,\n"
"                               MAP_SHARED, fd, 0);\n"
"    if (shmp == MAP_FAILED)\n"
"        errExit(\"mmap\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:392
#, no-wrap
msgid "    /* Initialize semaphores as process-shared, with value 0 */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:397
#, no-wrap
msgid ""
"    if (sem_init(&shmp-E<gt>sem1, 1, 0) == -1)\n"
"        errExit(\"sem_init-sem1\");\n"
"    if (sem_init(&shmp-E<gt>sem2, 1, 0) == -1)\n"
"        errExit(\"sem_init-sem2\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:400
#, no-wrap
msgid ""
"    /* Wait for \\(aqsem1\\(aq to be posted by peer before touching\n"
"       shared memory */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:403
#, no-wrap
msgid ""
"    if (sem_wait(&shmp-E<gt>sem1) == -1)\n"
"        errExit(\"sem_wait\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:405
#, no-wrap
msgid "    /* Convert data in shared memory into upper case */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:408
#, no-wrap
msgid ""
"    for (int j = 0; j E<lt> shmp-E<gt>cnt; j++)\n"
"        shmp-E<gt>buf[j] = toupper((unsigned char) shmp-E<gt>buf[j]);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:411
#, no-wrap
msgid ""
"    /* Post \\(aqsem2\\(aq to tell the to tell peer that it can now\n"
"       access the modified data in shared memory */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:414
#, no-wrap
msgid ""
"    if (sem_post(&shmp-E<gt>sem2) == -1)\n"
"        errExit(\"sem_post\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:418
#, no-wrap
msgid ""
"    /* Unlink the shared memory object. Even if the peer process\n"
"       is still using the object, this is okay. The object will\n"
"       be removed only after all open references are closed. */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:420
#, no-wrap
msgid "    shm_unlink(shmpath);\n"
msgstr ""

#. type: SS
#: build/C/man3/shm_open.3:426
#, no-wrap
msgid "Program source: pshm_ucase_send.c"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:430
msgid ""
"The \"send\" program takes two command-line arguments: the pathname of a "
"shared memory object previously created by the \"bounce\" program and a "
"string that is to be copied into that object."
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:440
msgid ""
"The program opens the shared memory object and maps the object into its "
"address space.  It then copies the data specified in its second argument "
"into the shared memory, and posts the first semaphore, which tells the "
"\"bounce\" program that it can now access that data.  After the \"bounce\" "
"program posts the second semaphore, the \"send\" program prints the contents "
"of the shared memory on standard output."
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:444
#, no-wrap
msgid "/* pshm_ucase_send.c\n"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:449
#, no-wrap
msgid ""
"   Licensed under GNU General Public License v2 or later.\n"
"*/\n"
"#include E<lt>string.hE<gt>\n"
"#include \"pshm_ucase.h\"\n"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:457
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    if (argc != 3) {\n"
"        fprintf(stderr, \"Usage: %s /shm-path string\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:461
#, no-wrap
msgid ""
"    char *shmpath = argv[1];\n"
"    char *string = argv[2];\n"
"    size_t len = strlen(string);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:466
#, no-wrap
msgid ""
"    if (len E<gt> BUF_SIZE) {\n"
"        fprintf(stderr, \"String is too long\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:469
#, no-wrap
msgid ""
"    /* Open the existing shared memory object and map it\n"
"       into the caller\\(aqs address space */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:473
#, no-wrap
msgid ""
"    int fd = shm_open(shmpath, O_RDWR, 0);\n"
"    if (fd == -1)\n"
"        errExit(\"shm_open\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:481
#, no-wrap
msgid "    /* Copy data into the shared memory object */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:484
#, no-wrap
msgid ""
"    shmp-E<gt>cnt = len;\n"
"    memcpy(&shmp-E<gt>buf, string, len);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:486
#, no-wrap
msgid "    /* Tell peer that it can now access shared memory */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:489
#, no-wrap
msgid ""
"    if (sem_post(&shmp-E<gt>sem1) == -1)\n"
"        errExit(\"sem_post\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:492
#, no-wrap
msgid ""
"    /* Wait until peer says that it has finished accessing\n"
"       the shared memory */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:495
#, no-wrap
msgid ""
"    if (sem_wait(&shmp-E<gt>sem2) == -1)\n"
"        errExit(\"sem_wait\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:497
#, no-wrap
msgid "    /* Write modified data in shared memory to standard output */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:500
#, no-wrap
msgid ""
"    write(STDOUT_FILENO, &shmp-E<gt>buf, len);\n"
"    write(STDOUT_FILENO, \"\\en\", 1);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:517
msgid ""
"B<close>(2), B<fchmod>(2), B<fchown>(2), B<fcntl>(2), B<fstat>(2), "
"B<ftruncate>(2), B<memfd_create>(2), B<mmap>(2), B<open>(2), B<umask>(2), "
"B<shm_overview>(7)"
msgstr ""

#. type: TH
#: build/C/man7/shm_overview.7:26
#, no-wrap
msgid "SHM_OVERVIEW"
msgstr ""

#. type: Plain text
#: build/C/man7/shm_overview.7:29
msgid "shm_overview - overview of POSIX shared memory"
msgstr ""

#. type: Plain text
#: build/C/man7/shm_overview.7:32
msgid ""
"The POSIX shared memory API allows processes to communicate information by "
"sharing a region of memory."
msgstr ""

#. type: Plain text
#: build/C/man7/shm_overview.7:34
msgid "The interfaces employed in the API are:"
msgstr ""

#. type: TP
#: build/C/man7/shm_overview.7:34
#, no-wrap
msgid "B<shm_open>(3)"
msgstr ""

#. type: Plain text
#: build/C/man7/shm_overview.7:41
msgid ""
"Create and open a new object, or open an existing object.  This is analogous "
"to B<open>(2).  The call returns a file descriptor for use by the other "
"interfaces listed below."
msgstr ""

#. type: TP
#: build/C/man7/shm_overview.7:41
#, no-wrap
msgid "B<ftruncate>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/shm_overview.7:45
msgid ""
"Set the size of the shared memory object.  (A newly created shared memory "
"object has a length of zero.)"
msgstr ""

#. type: Plain text
#: build/C/man7/shm_overview.7:49
msgid ""
"Map the shared memory object into the virtual address space of the calling "
"process."
msgstr ""

#. type: TP
#: build/C/man7/shm_overview.7:49
#, no-wrap
msgid "B<munmap>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/shm_overview.7:53
msgid ""
"Unmap the shared memory object from the virtual address space of the calling "
"process."
msgstr ""

#. type: TP
#: build/C/man7/shm_overview.7:53
#, no-wrap
msgid "B<shm_unlink>(3)"
msgstr ""

#. type: Plain text
#: build/C/man7/shm_overview.7:56
msgid "Remove a shared memory object name."
msgstr ""

#. type: TP
#: build/C/man7/shm_overview.7:56
#, no-wrap
msgid "B<close>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/shm_overview.7:61
msgid ""
"Close the file descriptor allocated by B<shm_open>(3)  when it is no longer "
"needed."
msgstr ""

#. type: TP
#: build/C/man7/shm_overview.7:61
#, no-wrap
msgid "B<fstat>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/shm_overview.7:75
msgid ""
"Obtain a I<stat> structure that describes the shared memory object.  Among "
"the information returned by this call are the object's size (I<st_size>), "
"permissions (I<st_mode>), owner (I<st_uid>), and group (I<st_gid>)."
msgstr ""

#. type: TP
#: build/C/man7/shm_overview.7:75
#, no-wrap
msgid "B<fchown>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/shm_overview.7:78
msgid "To change the ownership of a shared memory object."
msgstr ""

#. type: TP
#: build/C/man7/shm_overview.7:78
#, no-wrap
msgid "B<fchmod>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/shm_overview.7:81
msgid "To change the permissions of a shared memory object."
msgstr ""

#. type: SS
#: build/C/man7/shm_overview.7:81
#, no-wrap
msgid "Versions"
msgstr ""

#. type: Plain text
#: build/C/man7/shm_overview.7:83
msgid "POSIX shared memory is supported since Linux 2.4 and glibc 2.2."
msgstr ""

#. type: SS
#: build/C/man7/shm_overview.7:83
#, no-wrap
msgid "Persistence"
msgstr ""

#. type: Plain text
#: build/C/man7/shm_overview.7:88
msgid ""
"POSIX shared memory objects have kernel persistence: a shared memory object "
"will exist until the system is shut down, or until all processes have "
"unmapped the object and it has been deleted with B<shm_unlink>(3)"
msgstr ""

#. type: SS
#: build/C/man7/shm_overview.7:88
#, no-wrap
msgid "Linking"
msgstr ""

#. type: Plain text
#: build/C/man7/shm_overview.7:93
msgid ""
"Programs using the POSIX shared memory API must be compiled with I<cc -lrt> "
"to link against the real-time library, I<librt>."
msgstr ""

#. type: SS
#: build/C/man7/shm_overview.7:93
#, no-wrap
msgid "Accessing shared memory objects via the filesystem"
msgstr ""

#. type: Plain text
#: build/C/man7/shm_overview.7:100
msgid ""
"On Linux, shared memory objects are created in a (I<tmpfs>(5))  virtual "
"filesystem, normally mounted under I</dev/shm>.  Since kernel 2.6.19, Linux "
"supports the use of access control lists (ACLs)  to control the permissions "
"of objects in the virtual filesystem."
msgstr ""

#. type: Plain text
#: build/C/man7/shm_overview.7:103
msgid ""
"Typically, processes must synchronize their access to a shared memory "
"object, using, for example, POSIX semaphores."
msgstr ""

#. type: Plain text
#: build/C/man7/shm_overview.7:111
msgid ""
"System V shared memory (B<shmget>(2), B<shmop>(2), etc.) is an older shared "
"memory API.  POSIX shared memory provides a simpler, and better designed "
"interface; on the other hand POSIX shared memory is somewhat less widely "
"available (especially on older systems) than System V shared memory."
msgstr ""

#. type: Plain text
#: build/C/man7/shm_overview.7:124
msgid ""
"B<fchmod>(2), B<fchown>(2), B<fstat>(2), B<ftruncate>(2), B<mmap>(2), "
"B<mprotect>(2), B<munmap>(2), B<shmget>(2), B<shmop>(2), B<shm_open>(3), "
"B<shm_unlink>(3), B<sem_overview>(7)"
msgstr ""

#. type: TH
#: build/C/man2/shmctl.2:46
#, no-wrap
msgid "SHMCTL"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:49
msgid "shmctl - System V shared memory control"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:52 build/C/man2/shmget.2:44
msgid "B<#include E<lt>sys/ipc.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:54 build/C/man2/shmget.2:46
msgid "B<#include E<lt>sys/shm.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:56
msgid "B<int shmctl(int >I<shmid>B<, int >I<cmd>B<, struct shmid_ds *>I<buf>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:63
msgid ""
"B<shmctl>()  performs the control operation specified by I<cmd> on the "
"System\\ V shared memory segment whose identifier is given in I<shmid>."
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:68
msgid ""
"The I<buf> argument is a pointer to a I<shmid_ds> structure, defined in "
"I<E<lt>sys/shm.hE<gt>> as follows:"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:83
#, no-wrap
msgid ""
"struct shmid_ds {\n"
"    struct ipc_perm shm_perm;    /* Ownership and permissions */\n"
"    size_t          shm_segsz;   /* Size of segment (bytes) */\n"
"    time_t          shm_atime;   /* Last attach time */\n"
"    time_t          shm_dtime;   /* Last detach time */\n"
"    time_t          shm_ctime;   /* Creation time/time of last\n"
"                                    modification via shmctl() */\n"
"    pid_t           shm_cpid;    /* PID of creator */\n"
"    pid_t           shm_lpid;    /* PID of last shmat(2)/shmdt(2) */\n"
"    shmatt_t        shm_nattch;  /* No. of current attaches */\n"
"    ...\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:89
msgid "The fields of the I<shmid_ds> structure are as follows:"
msgstr ""

#. type: TP
#: build/C/man2/shmctl.2:89
#, no-wrap
msgid "I<shm_perm>"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:95
msgid ""
"This is an I<ipc_perm> structure (see below) that specifies the access "
"permissions on the shared memory segment."
msgstr ""

#. type: TP
#: build/C/man2/shmctl.2:95
#, no-wrap
msgid "I<shm_segsz>"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:98
msgid "Size in bytes of the shared memory segment."
msgstr ""

#. type: TP
#: build/C/man2/shmctl.2:98
#, no-wrap
msgid "I<shm_atime>"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:103
msgid "Time of the last B<shmat>(2)  system call that attached this segment."
msgstr ""

#. type: TP
#: build/C/man2/shmctl.2:103
#, no-wrap
msgid "I<shm_dtime>"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:108
msgid "Time of the last B<shmdt>(2)  system call that detached tgis segment."
msgstr ""

#. type: TP
#: build/C/man2/shmctl.2:108
#, no-wrap
msgid "I<shm_ctime>"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:114
msgid ""
"Time of creation of segment or time of the last B<shmctl>()  B<IPC_SET> "
"operation."
msgstr ""

#. type: TP
#: build/C/man2/shmctl.2:114
#, no-wrap
msgid "I<shm_cpid>"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:117
msgid "ID of the process that created the shared memory segment."
msgstr ""

#. type: TP
#: build/C/man2/shmctl.2:117
#, no-wrap
msgid "I<shm_lpid>"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:124
msgid ""
"ID of the last process that executed a B<shmat>(2)  or B<shmdt>(2)  system "
"call on this segment."
msgstr ""

#. type: TP
#: build/C/man2/shmctl.2:124
#, no-wrap
msgid "I<shm_nattch>"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:127
msgid "Number of processes that have this segment attached."
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:133
msgid ""
"The I<ipc_perm> structure is defined as follows (the highlighted fields are "
"settable using B<IPC_SET>):"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:146
#, no-wrap
msgid ""
"struct ipc_perm {\n"
"    key_t          __key;    /* Key supplied to shmget(2) */\n"
"    uid_t          B<uid>;      /* Effective UID of owner */\n"
"    gid_t          B<gid>;      /* Effective GID of owner */\n"
"    uid_t          cuid;     /* Effective UID of creator */\n"
"    gid_t          cgid;     /* Effective GID of creator */\n"
"    unsigned short B<mode>;     /* B<Permissions> + SHM_DEST and\n"
"                                SHM_LOCKED flags */\n"
"    unsigned short __seq;    /* Sequence number */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:155
msgid ""
"The least significant 9 bits of the I<mode> field of the I<ipc_perm> "
"structure define the access permissions for the shared memory segment.  The "
"permission bits are as follows:"
msgstr ""

#. type: tbl table
#: build/C/man2/shmctl.2:157
#, no-wrap
msgid "0400"
msgstr ""

#. type: tbl table
#: build/C/man2/shmctl.2:157
#, no-wrap
msgid "Read by user"
msgstr ""

#. type: tbl table
#: build/C/man2/shmctl.2:158
#, no-wrap
msgid "0200"
msgstr ""

#. type: tbl table
#: build/C/man2/shmctl.2:158
#, no-wrap
msgid "Write by user"
msgstr ""

#. type: tbl table
#: build/C/man2/shmctl.2:159
#, no-wrap
msgid "0040"
msgstr ""

#. type: tbl table
#: build/C/man2/shmctl.2:159
#, no-wrap
msgid "Read by group"
msgstr ""

#. type: tbl table
#: build/C/man2/shmctl.2:160
#, no-wrap
msgid "0020"
msgstr ""

#. type: tbl table
#: build/C/man2/shmctl.2:160
#, no-wrap
msgid "Write by group"
msgstr ""

#. type: tbl table
#: build/C/man2/shmctl.2:161
#, no-wrap
msgid "0004"
msgstr ""

#. type: tbl table
#: build/C/man2/shmctl.2:161
#, no-wrap
msgid "Read by others"
msgstr ""

#. type: tbl table
#: build/C/man2/shmctl.2:162
#, no-wrap
msgid "0002"
msgstr ""

#. type: tbl table
#: build/C/man2/shmctl.2:162
#, no-wrap
msgid "Write by others"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:172
msgid ""
"Bits 0100, 0010, and 0001 (the execute bits) are unused by the system.  (It "
"is not necessary to have execute permission on a segment in order to perform "
"a B<shmat>(2)  call with the B<SHM_EXEC> flag.)"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:176
msgid "Valid values for I<cmd> are:"
msgstr ""

#. type: TP
#: build/C/man2/shmctl.2:176
#, no-wrap
msgid "B<IPC_STAT>"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:185
msgid ""
"Copy information from the kernel data structure associated with I<shmid> "
"into the I<shmid_ds> structure pointed to by I<buf>.  The caller must have "
"read permission on the shared memory segment."
msgstr ""

#. type: TP
#: build/C/man2/shmctl.2:185
#, no-wrap
msgid "B<IPC_SET>"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:195
msgid ""
"Write the values of some members of the I<shmid_ds> structure pointed to by "
"I<buf> to the kernel data structure associated with this shared memory "
"segment, updating also its I<shm_ctime> member."
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:199
msgid ""
"The following fields are updated: I<shm_perm.uid>, I<shm_perm.gid>, and (the "
"least significant 9 bits of) I<shm_perm.mode>."
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:205
msgid ""
"The effective UID of the calling process must match the owner "
"(I<shm_perm.uid>)  or creator (I<shm_perm.cuid>)  of the shared memory "
"segment, or the caller must be privileged."
msgstr ""

#. type: TP
#: build/C/man2/shmctl.2:205
#, no-wrap
msgid "B<IPC_RMID>"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:218
msgid ""
"Mark the segment to be destroyed.  The segment will actually be destroyed "
"only after the last process detaches it (i.e., when the I<shm_nattch> member "
"of the associated structure I<shmid_ds> is zero).  The caller must be the "
"owner or creator of the segment, or be privileged.  The I<buf> argument is "
"ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:226
msgid ""
"If a segment has been marked for destruction, then the (nonstandard)  "
"B<SHM_DEST> flag of the I<shm_perm.mode> field in the associated data "
"structure retrieved by B<IPC_STAT> will be set."
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:229
msgid ""
"The caller I<must> ensure that a segment is eventually destroyed; otherwise "
"its pages that were faulted in will remain in memory or swap."
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:234
msgid ""
"See also the description of I</proc/sys/kernel/shm_rmid_forced> in "
"B<proc>(5)."
msgstr ""

#. type: TP
#: build/C/man2/shmctl.2:234
#, no-wrap
msgid "B<IPC_INFO> (Linux-specific)"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:247
msgid ""
"Return information about system-wide shared memory limits and parameters in "
"the structure pointed to by I<buf>.  This structure is of type I<shminfo> "
"(thus, a cast is required), defined in I<E<lt>sys/shm.hE<gt>> if the "
"B<_GNU_SOURCE> feature test macro is defined:"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:261
#, no-wrap
msgid ""
"struct shminfo {\n"
"    unsigned long shmmax; /* Maximum segment size */\n"
"    unsigned long shmmin; /* Minimum segment size;\n"
"                             always 1 */\n"
"    unsigned long shmmni; /* Maximum number of segments */\n"
"    unsigned long shmseg; /* Maximum number of segments\n"
"                             that a process can attach;\n"
"                             unused within kernel */\n"
"    unsigned long shmall; /* Maximum number of pages of\n"
"                             shared memory, system-wide */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:274
msgid ""
"The I<shmmni>, I<shmmax>, and I<shmall> settings can be changed via I</proc> "
"files of the same name; see B<proc>(5)  for details."
msgstr ""

#. type: TP
#: build/C/man2/shmctl.2:274
#, no-wrap
msgid "B<SHM_INFO> (Linux-specific)"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:285
msgid ""
"Return a I<shm_info> structure whose fields contain information about system "
"resources consumed by shared memory.  This structure is defined in "
"I<E<lt>sys/shm.hE<gt>> if the B<_GNU_SOURCE> feature test macro is defined:"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:302
#, no-wrap
msgid ""
"struct shm_info {\n"
"    int           used_ids; /* # of currently existing\n"
"                               segments */\n"
"    unsigned long shm_tot;  /* Total number of shared\n"
"                               memory pages */\n"
"    unsigned long shm_rss;  /* # of resident shared\n"
"                               memory pages */\n"
"    unsigned long shm_swp;  /* # of swapped shared\n"
"                               memory pages */\n"
"    unsigned long swap_attempts;\n"
"                            /* Unused since Linux 2.4 */\n"
"    unsigned long swap_successes;\n"
"                            /* Unused since Linux 2.4 */\n"
"};\n"
msgstr ""

#. type: TP
#: build/C/man2/shmctl.2:304
#, no-wrap
msgid "B<SHM_STAT> (Linux-specific)"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:315
msgid ""
"Return a I<shmid_ds> structure as for B<IPC_STAT>.  However, the I<shmid> "
"argument is not a segment identifier, but instead an index into the kernel's "
"internal array that maintains information about all shared memory segments "
"on the system."
msgstr ""

#. type: TP
#: build/C/man2/shmctl.2:315
#, no-wrap
msgid "B<SHM_STAT_ANY> (Linux-specific, since Linux 4.17)"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:328
msgid ""
"Return a I<shmid_ds> structure as for B<SHM_STAT>.  However, "
"I<shm_perm.mode> is not checked for read access for I<shmid>, meaning that "
"any user can employ this operation (just as any user may read "
"I</proc/sysvipc/shm> to obtain the same information)."
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:331
msgid ""
"The caller can prevent or allow swapping of a shared memory segment with the "
"following I<cmd> values:"
msgstr ""

#. type: TP
#: build/C/man2/shmctl.2:331
#, no-wrap
msgid "B<SHM_LOCK> (Linux-specific)"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:343
msgid ""
"Prevent swapping of the shared memory segment.  The caller must fault in any "
"pages that are required to be present after locking is enabled.  If a "
"segment has been locked, then the (nonstandard)  B<SHM_LOCKED> flag of the "
"I<shm_perm.mode> field in the associated data structure retrieved by "
"B<IPC_STAT> will be set."
msgstr ""

#. type: TP
#: build/C/man2/shmctl.2:343
#, no-wrap
msgid "B<SHM_UNLOCK> (Linux-specific)"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:346
msgid "Unlock the segment, allowing it to be swapped out."
msgstr ""

#.  There was some weirdness in 2.6.9: SHM_LOCK and SHM_UNLOCK could
#.  be applied to a segment, regardless of ownership of the segment.
#.  This was a botch-up in the move to RLIMIT_MEMLOCK, and was fixed
#.  in 2.6.10.  MTK, May 2005
#. type: Plain text
#: build/C/man2/shmctl.2:364
msgid ""
"In kernels before 2.6.10, only a privileged process could employ B<SHM_LOCK> "
"and B<SHM_UNLOCK>.  Since kernel 2.6.10, an unprivileged process can employ "
"these operations if its effective UID matches the owner or creator UID of "
"the segment, and (for B<SHM_LOCK>)  the amount of memory to be locked falls "
"within the B<RLIMIT_MEMLOCK> resource limit (see B<setrlimit>(2))."
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:384
msgid ""
"A successful B<IPC_INFO> or B<SHM_INFO> operation returns the index of the "
"highest used entry in the kernel's internal array recording information "
"about all shared memory segments.  (This information can be used with "
"repeated B<SHM_STAT> or B<SHM_STAT_ANY> operations to obtain information "
"about all shared memory segments on the system.)  A successful B<SHM_STAT> "
"operation returns the identifier of the shared memory segment whose index "
"was given in I<shmid>.  Other operations return 0 on success."
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:388
msgid "On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:397
msgid ""
"B<IPC_STAT> or B<SHM_STAT> is requested and I<shm_perm.mode> does not allow "
"read access for I<shmid>, and the calling process does not have the "
"B<CAP_IPC_OWNER> capability in the user namespace that governs its IPC "
"namespace."
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:408
msgid ""
"The argument I<cmd> has value B<IPC_SET> or B<IPC_STAT> but the address "
"pointed to by I<buf> isn't accessible."
msgstr ""

#. type: TP
#: build/C/man2/shmctl.2:408 build/C/man2/shmop.2:193
#, no-wrap
msgid "B<EIDRM>"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:411 build/C/man2/shmop.2:196
msgid "I<shmid> points to a removed identifier."
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:422
msgid ""
"I<shmid> is not a valid identifier, or I<cmd> is not a valid command.  Or: "
"for a B<SHM_STAT> or B<SHM_STAT_ANY> operation, the index value specified in "
"I<shmid> referred to an array slot that is currently unused."
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:433
msgid ""
"(In kernels since 2.6.9), B<SHM_LOCK> was specified and the size of the "
"to-be-locked segment would mean that the total bytes in locked shared memory "
"segments would exceed the limit for the real user ID of the calling "
"process.  This limit is defined by the B<RLIMIT_MEMLOCK> soft resource limit "
"(see B<setrlimit>(2))."
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:438
msgid ""
"B<IPC_STAT> is attempted, and the GID or UID value is too large to be stored "
"in the structure pointed to by I<buf>."
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:450
msgid ""
"B<IPC_SET> or B<IPC_RMID> is attempted, and the effective user ID of the "
"calling process is not that of the creator (found in I<shm_perm.cuid>), or "
"the owner (found in I<shm_perm.uid>), and the process was not privileged "
"(Linux: did not have the B<CAP_SYS_ADMIN> capability)."
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:462
msgid ""
"Or (in kernels before 2.6.9), B<SHM_LOCK> or B<SHM_UNLOCK> was specified, "
"but the process was not privileged (Linux: did not have the B<CAP_IPC_LOCK> "
"capability).  (Since Linux 2.6.9, this error can also occur if the "
"B<RLIMIT_MEMLOCK> is 0 and the caller is not privileged.)"
msgstr ""

#.  Like Linux, the FreeBSD man pages still document
#.  the inclusion of these header files.
#. type: Plain text
#: build/C/man2/shmctl.2:480 build/C/man2/shmget.2:301
msgid ""
"The inclusion of I<E<lt>sys/types.hE<gt>> and I<E<lt>sys/ipc.hE<gt>> isn't "
"required on Linux or by any version of POSIX.  However, some old "
"implementations required the inclusion of these header files, and the SVID "
"also documented their inclusion.  Applications intended to be portable to "
"such old systems may need to include these header files."
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:492
msgid ""
"The B<IPC_INFO>, B<SHM_STAT>, and B<SHM_INFO> operations are used by the "
"B<ipcs>(1)  program to provide information on allocated resources.  In the "
"future, these may modified or moved to a I</proc> filesystem interface."
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:500
msgid ""
"Linux permits a process to attach (B<shmat>(2))  a shared memory segment "
"that has already been marked for deletion using I<shmctl(IPC_RMID)>.  This "
"feature is not available on other UNIX implementations; portable "
"applications should avoid relying on it."
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:513
msgid ""
"Various fields in a I<struct shmid_ds> were typed as I<short> under Linux "
"2.2 and have become I<long> under Linux 2.4.  To take advantage of this, a "
"recompilation under glibc-2.1.91 or later should suffice.  (The kernel "
"distinguishes old and new calls by an B<IPC_64> flag in I<cmd>.)"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:520
msgid ""
"B<mlock>(2), B<setrlimit>(2), B<shmget>(2), B<shmop>(2), B<capabilities>(7), "
"B<sysvipc>(7)"
msgstr ""

#. type: TH
#: build/C/man2/shmget.2:38
#, no-wrap
msgid "SHMGET"
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:41
msgid "shmget - allocates a System V shared memory segment"
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:48
msgid "B<int shmget(key_t >I<key>B<, size_t >I<size>B<, int >I<shmflg>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:62
msgid ""
"B<shmget>()  returns the identifier of the System\\ V shared memory segment "
"associated with the value of the argument I<key>.  It may be used either to "
"obtain the identifier of a previously created shared memory segment (when "
"I<shmflg> is zero and I<key> does not have the value B<IPC_PRIVATE>), or to "
"create a new set."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:81
msgid ""
"A new shared memory segment, with size equal to the value of I<size> rounded "
"up to a multiple of B<PAGE_SIZE>, is created if I<key> has the value "
"B<IPC_PRIVATE> or I<key> isn't B<IPC_PRIVATE>, no shared memory segment "
"corresponding to I<key> exists, and B<IPC_CREAT> is specified in I<shmflg>."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:100
msgid ""
"If I<shmflg> specifies both B<IPC_CREAT> and B<IPC_EXCL> and a shared memory "
"segment already exists for I<key>, then B<shmget>()  fails with I<errno> set "
"to B<EEXIST>.  (This is analogous to the effect of the combination B<O_CREAT "
"| O_EXCL> for B<open>(2).)"
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:104
msgid "The value I<shmflg> is composed of:"
msgstr ""

#. type: TP
#: build/C/man2/shmget.2:104
#, no-wrap
msgid "B<IPC_CREAT>"
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:111
msgid ""
"Create a new segment.  If this flag is not used, then B<shmget>()  will find "
"the segment associated with I<key> and check to see if the user has "
"permission to access the segment."
msgstr ""

#. type: TP
#: build/C/man2/shmget.2:111
#, no-wrap
msgid "B<IPC_EXCL>"
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:117
msgid ""
"This flag is used with B<IPC_CREAT> to ensure that this call creates the "
"segment.  If the segment already exists, the call fails."
msgstr ""

#. type: TP
#: build/C/man2/shmget.2:117
#, no-wrap
msgid "B<SHM_HUGETLB> (since Linux 2.6)"
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:123
msgid ""
"Allocate the segment using \"huge pages.\" See the Linux kernel source file "
"I<Documentation/admin-guide/mm/hugetlbpage.rst> for further information."
msgstr ""

#. type: TP
#: build/C/man2/shmget.2:123
#, no-wrap
msgid "B<SHM_HUGE_2MB>, B<SHM_HUGE_1GB> (since Linux 3.8)"
msgstr ""

#.  See https://lwn.net/Articles/533499/
#. type: Plain text
#: build/C/man2/shmget.2:130
msgid ""
"Used in conjunction with B<SHM_HUGETLB> to select alternative hugetlb page "
"sizes (respectively, 2\\ MB and 1\\ GB)  on systems that support multiple "
"hugetlb page sizes."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:135
msgid ""
"More generally, the desired huge page size can be configured by encoding the "
"base-2 logarithm of the desired page size in the six bits at the offset "
"B<SHM_HUGE_SHIFT>.  Thus, the above two constants are defined as:"
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:140
#, no-wrap
msgid ""
"#define SHM_HUGE_2MB    (21 E<lt>E<lt> SHM_HUGE_SHIFT)\n"
"#define SHM_HUGE_1GB    (30 E<lt>E<lt> SHM_HUGE_SHIFT)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:146
msgid ""
"For some additional details, see the discussion of the similarly named "
"constants in B<mmap>(2)."
msgstr ""

#. type: TP
#: build/C/man2/shmget.2:146
#, no-wrap
msgid "B<SHM_NORESERVE> (since Linux 2.6.15)"
msgstr ""

#.  As at 2.6.17-rc2, this flag has no effect if SHM_HUGETLB was also
#.  specified.
#. type: Plain text
#: build/C/man2/shmget.2:165
msgid ""
"This flag serves the same purpose as the B<mmap>(2)  B<MAP_NORESERVE> flag.  "
"Do not reserve swap space for this segment.  When swap space is reserved, "
"one has the guarantee that it is possible to modify the segment.  When swap "
"space is not reserved one might get B<SIGSEGV> upon a write if no physical "
"memory is available.  See also the discussion of the file "
"I</proc/sys/vm/overcommit_memory> in B<proc>(5)."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:175
msgid ""
"In addition to the above flags, the least significant 9 bits of I<shmflg> "
"specify the permissions granted to the owner, group, and others.  These bits "
"have the same format, and the same meaning, as the I<mode> argument of "
"B<open>(2).  Presently, execute permissions are not used by the system."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:183
msgid ""
"When a new shared memory segment is created, its contents are initialized to "
"zero values, and its associated data structure, I<shmid_ds> (see "
"B<shmctl>(2)), is initialized as follows:"
msgstr ""

#. type: IP
#: build/C/man2/shmget.2:183 build/C/man2/shmget.2:188 build/C/man2/shmget.2:193 build/C/man2/shmget.2:198 build/C/man2/shmget.2:202 build/C/man2/shmget.2:209 build/C/man2/shmop.2:61 build/C/man2/shmop.2:67 build/C/man2/shmop.2:79 build/C/man2/shmop.2:129 build/C/man2/shmop.2:132 build/C/man2/shmop.2:135 build/C/man2/shmop.2:156 build/C/man2/shmop.2:159 build/C/man2/shmop.2:162
#, no-wrap
msgid "\\(bu"
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:188
msgid ""
"I<shm_perm.cuid> and I<shm_perm.uid> are set to the effective user ID of the "
"calling process."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:193
msgid ""
"I<shm_perm.cgid> and I<shm_perm.gid> are set to the effective group ID of "
"the calling process."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:198
msgid ""
"The least significant 9 bits of I<shm_perm.mode> are set to the least "
"significant 9 bit of I<shmflg>."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:202
msgid "I<shm_segsz> is set to the value of I<size>."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:209
msgid "I<shm_lpid>, I<shm_nattch>, I<shm_atime>, and I<shm_dtime> are set to 0."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:212
msgid "I<shm_ctime> is set to the current time."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:215
msgid ""
"If the shared memory segment already exists, the permissions are verified, "
"and a check is made to see if it is marked for destruction."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:220
msgid ""
"On success, a valid shared memory identifier is returned.  On error, -1 is "
"returned, and I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:224
msgid "On failure, I<errno> is set to one of the following:"
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:230
msgid ""
"The user does not have permission to access the shared memory segment, and "
"does not have the B<CAP_IPC_OWNER> capability in the user namespace that "
"governs its IPC namespace."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:239
msgid ""
"B<IPC_CREAT> and B<IPC_EXCL> were specified in I<shmflg>, but a shared "
"memory segment already exists for I<key>."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:247
msgid ""
"A new segment was to be created and I<size> is less than B<SHMMIN> or "
"greater than B<SHMMAX>."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:253
msgid ""
"A segment for the given I<key> exists, but I<size> is greater than the size "
"of that segment."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:262
msgid "No segment exists for the given I<key>, and B<IPC_CREAT> was not specified."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:265
msgid "No memory could be allocated for segment overhead."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:273
msgid ""
"All possible shared memory IDs have been taken (B<SHMMNI>), or allocating a "
"segment of the requested I<size> would cause the system to exceed the "
"system-wide limit on shared memory (B<SHMALL>)."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:280
msgid ""
"The B<SHM_HUGETLB> flag was specified, but the caller was not privileged "
"(did not have the B<CAP_IPC_LOCK> capability)."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:288
msgid "B<SHM_HUGETLB> and B<SHM_NORESERVE> are Linux extensions."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:312
msgid ""
"B<IPC_PRIVATE> isn't a flag field but a I<key_t> type.  If this special "
"value is used for I<key>, the system call ignores all but the least "
"significant 9 bits of I<shmflg> and creates a new shared memory segment."
msgstr ""

#. type: SS
#: build/C/man2/shmget.2:312
#, no-wrap
msgid "Shared memory limits"
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:316
msgid ""
"The following limits on shared memory segment resources affect the "
"B<shmget>()  call:"
msgstr ""

#. type: TP
#: build/C/man2/shmget.2:316
#, no-wrap
msgid "B<SHMALL>"
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:320
msgid ""
"System-wide limit on the total amount of shared memory, measured in units of "
"the system page size."
msgstr ""

#.  commit 060028bac94bf60a65415d1d55a359c3a17d5c31
#. type: Plain text
#: build/C/man2/shmget.2:326
msgid ""
"On Linux, this limit can be read and modified via "
"I</proc/sys/kernel/shmall>.  Since Linux 3.16, the default value for this "
"limit is:"
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:328 build/C/man2/shmget.2:363
#, no-wrap
msgid "    ULONG_MAX - 2^24\n"
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:339
msgid ""
"The effect of this value (which is suitable for both 32-bit and 64-bit "
"systems)  is to impose no limitation on allocations.  This value, rather "
"than B<ULONG_MAX>, was chosen as the default to prevent some cases where "
"historical applications simply raised the existing limit without first "
"checking its current value.  Such applications would cause the value to "
"overflow if the limit was set at B<ULONG_MAX>."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:342
msgid "From Linux 2.4 up to Linux 3.15, the default value for this limit was:"
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:344
#, no-wrap
msgid "    SHMMAX / PAGE_SIZE * (SHMMNI / 16)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:352
msgid ""
"If B<SHMMAX> and B<SHMMNI> were not modified, then multiplying the result of "
"this formula by the page size (to get a value in bytes) yielded a value of "
"8\\ GB as the limit on the total memory used by all shared memory segments."
msgstr ""

#. type: TP
#: build/C/man2/shmget.2:352
#, no-wrap
msgid "B<SHMMAX>"
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:355
msgid "Maximum size in bytes for a shared memory segment."
msgstr ""

#.  commit 060028bac94bf60a65415d1d55a359c3a17d5c31
#. type: Plain text
#: build/C/man2/shmget.2:361
msgid ""
"On Linux, this limit can be read and modified via "
"I</proc/sys/kernel/shmmax>.  Since Linux 3.16, the default value for this "
"limit is:"
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:372
msgid ""
"The effect of this value (which is suitable for both 32-bit and 64-bit "
"systems)  is to impose no limitation on allocations.  See the description of "
"B<SHMALL> for a discussion of why this default value (rather than "
"B<ULONG_MAX>)  is used."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:375
msgid ""
"From Linux 2.2 up to Linux 3.15, the default value of this limit was "
"0x2000000 (32\\ MB)."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:381
msgid ""
"Because it is not possible to map just part of a shared memory segment, the "
"amount of virtual memory places another limit on the maximum size of a "
"usable segment: for example, on i386 the largest segments that can be mapped "
"have a size of around 2.8\\ GB, and on x86-64 the limit is around 127 TB."
msgstr ""

#. type: TP
#: build/C/man2/shmget.2:381
#, no-wrap
msgid "B<SHMMIN>"
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:387
msgid ""
"Minimum size in bytes for a shared memory segment: implementation dependent "
"(currently 1 byte, though B<PAGE_SIZE> is the effective minimum size)."
msgstr ""

#. type: TP
#: build/C/man2/shmget.2:387
#, no-wrap
msgid "B<SHMMNI>"
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:392
msgid ""
"System-wide limit on the number of shared memory segments.  In Linux 2.2, "
"the default value for this limit was 128; since Linux 2.4, the default value "
"is 4096."
msgstr ""

#.  Kernels between 2.4.x and 2.6.8 had an off-by-one error that meant
#.  that we could create one more segment than SHMMNI -- MTK
#.  This /proc file is not available in Linux 2.2 and earlier -- MTK
#. type: Plain text
#: build/C/man2/shmget.2:398
msgid ""
"On Linux, this limit can be read and modified via "
"I</proc/sys/kernel/shmmni>."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:402
msgid ""
"The implementation has no specific limits for the per-process maximum number "
"of shared memory segments (B<SHMSEG>)."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:408
msgid ""
"Until version 2.3.30, Linux would return B<EIDRM> for a B<shmget>()  on a "
"shared memory segment scheduled for deletion."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:414
msgid ""
"The name choice B<IPC_PRIVATE> was perhaps unfortunate, B<IPC_NEW> would "
"more clearly show its function."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:417
msgid "See B<shmop>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:426
msgid ""
"B<memfd_create>(2), B<shmat>(2), B<shmctl>(2), B<shmdt>(2), B<ftok>(3), "
"B<capabilities>(7), B<shm_overview>(7), B<sysvipc>(7)"
msgstr ""

#. type: TH
#: build/C/man2/shmop.2:40
#, no-wrap
msgid "SHMOP"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:43
msgid "shmat, shmdt - System V shared memory operations"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:47
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/shm.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:49
#, no-wrap
msgid ""
"B<void *shmat(int >I<shmid>B<, const void *>I<shmaddr>B<, int "
">I<shmflg>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:51
#, no-wrap
msgid "B<int shmdt(const void *>I<shmaddr>B<);>\n"
msgstr ""

#. type: SS
#: build/C/man2/shmop.2:53
#, no-wrap
msgid "shmat()"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:61
msgid ""
"B<shmat>()  attaches the System\\ V shared memory segment identified by "
"I<shmid> to the address space of the calling process.  The attaching address "
"is specified by I<shmaddr> with one of the following criteria:"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:67
msgid ""
"If I<shmaddr> is NULL, the system chooses a suitable (unused) page-aligned "
"address to attach the segment."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:79
msgid ""
"If I<shmaddr> isn't NULL and B<SHM_RND> is specified in I<shmflg>, the "
"attach occurs at the address equal to I<shmaddr> rounded down to the nearest "
"multiple of B<SHMLBA>."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:83
msgid ""
"Otherwise, I<shmaddr> must be a page-aligned address at which the attach "
"occurs."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:89
msgid ""
"In addition to B<SHM_RND>, the following flags may be specified in the "
"I<shmflg> bit-mask argument:"
msgstr ""

#. type: TP
#: build/C/man2/shmop.2:89
#, no-wrap
msgid "B<SHM_EXEC> (Linux-specific; since Linux 2.6.9)"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:93
msgid ""
"Allow the contents of the segment to be executed.  The caller must have "
"execute permission on the segment."
msgstr ""

#. type: TP
#: build/C/man2/shmop.2:93
#, no-wrap
msgid "B<SHM_RDONLY>"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:101
msgid ""
"Attach the segment for read-only access.  The process must have read "
"permission for the segment.  If this flag is not specified, the segment is "
"attached for read and write access, and the process must have read and write "
"permission for the segment.  There is no notion of a write-only shared "
"memory segment."
msgstr ""

#. type: TP
#: build/C/man2/shmop.2:101
#, no-wrap
msgid "B<SHM_REMAP> (Linux-specific)"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:114
msgid ""
"This flag specifies that the mapping of the segment should replace any "
"existing mapping in the range starting at I<shmaddr> and continuing for the "
"size of the segment.  (Normally, an B<EINVAL> error would result if a "
"mapping already exists in this address range.)  In this case, I<shmaddr> "
"must not be NULL."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:121
msgid ""
"The B<brk>(2)  value of the calling process is not altered by the attach.  "
"The segment will automatically be detached at process exit.  The same "
"segment may be attached as a read and as a read-write one, and more than "
"once, in the process's address space."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:129
msgid ""
"A successful B<shmat>()  call updates the members of the I<shmid_ds> "
"structure (see B<shmctl>(2))  associated with the shared memory segment as "
"follows:"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:132
msgid "I<shm_atime> is set to the current time."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:135 build/C/man2/shmop.2:162
msgid "I<shm_lpid> is set to the process-ID of the calling process."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:139
msgid "I<shm_nattch> is incremented by one."
msgstr ""

#. type: SS
#: build/C/man2/shmop.2:139
#, no-wrap
msgid "shmdt()"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:150
msgid ""
"B<shmdt>()  detaches the shared memory segment located at the address "
"specified by I<shmaddr> from the address space of the calling process.  The "
"to-be-detached segment must be currently attached with I<shmaddr> equal to "
"the value returned by the attaching B<shmat>()  call."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:156
msgid ""
"On a successful B<shmdt>()  call, the system updates the members of the "
"I<shmid_ds> structure associated with the shared memory segment as follows:"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:159
msgid "I<shm_dtime> is set to the current time."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:167
msgid ""
"I<shm_nattch> is decremented by one.  If it becomes 0 and the segment is "
"marked for deletion, the segment is deleted."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:175
msgid ""
"On success, B<shmat>()  returns the address of the attached shared memory "
"segment; on error, I<(void\\ *)\\ -1> is returned, and I<errno> is set to "
"indicate the cause of the error."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:181
msgid ""
"On success, B<shmdt>()  returns 0; on error -1 is returned, and I<errno> is "
"set to indicate the cause of the error."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:187
msgid "When B<shmat>()  fails, I<errno> is set to one of the following:"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:193
msgid ""
"The calling process does not have the required permissions for the requested "
"attach type, and does not have the B<CAP_IPC_OWNER> capability in the user "
"namespace that governs its IPC namespace."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:210
msgid ""
"Invalid I<shmid> value, unaligned (i.e., not page-aligned and B<SHM_RND> was "
"not specified) or invalid I<shmaddr> value, or can't attach segment at "
"I<shmaddr>, or B<SHM_REMAP> was specified and I<shmaddr> was NULL."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:213
msgid "Could not allocate memory for the descriptor or for the page tables."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:219
msgid "When B<shmdt>()  fails, I<errno> is set as follows:"
msgstr ""

#.  The following since 2.6.17-rc1:
#. type: Plain text
#: build/C/man2/shmop.2:227
msgid ""
"There is no shared memory segment attached at I<shmaddr>; or, I<shmaddr> is "
"not aligned on a page boundary."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:242
msgid ""
"In SVID 3 (or perhaps earlier), the type of the I<shmaddr> argument was "
"changed from I<char\\ *> into I<const void\\ *>, and the returned type of "
"B<shmat>()  from I<char\\ *> into I<void\\ *>."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:246
msgid "After a B<fork>(2), the child inherits the attached shared memory segments."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:250
msgid ""
"After an B<execve>(2), all attached shared memory segments are detached from "
"the process."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:254
msgid ""
"Upon B<_exit>(2), all attached shared memory segments are detached from the "
"process."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:266
msgid ""
"Using B<shmat>()  with I<shmaddr> equal to NULL is the preferred, portable "
"way of attaching a shared memory segment.  Be aware that the shared memory "
"segment attached in this way may be attached at different addresses in "
"different processes.  Therefore, any pointers maintained within the shared "
"memory must be made relative (typically to the starting address of the "
"segment), rather than absolute."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:271
msgid ""
"On Linux, it is possible to attach a shared memory segment even if it is "
"already marked to be deleted.  However, POSIX.1 does not specify this "
"behavior and many other implementations do not support it."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:274
msgid "The following system parameter affects B<shmat>():"
msgstr ""

#. type: TP
#: build/C/man2/shmop.2:274
#, no-wrap
msgid "B<SHMLBA>"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:289
msgid ""
"Segment low boundary address multiple.  When explicitly specifying an attach "
"address in a call to B<shmat>(), the caller should ensure that the address "
"is a multiple of this value.  This is necessary on some architectures, in "
"order either to ensure good CPU cache performance or to ensure that "
"different attaches of the same segment have consistent views within the CPU "
"cache.  B<SHMLBA> is normally some multiple of the system page size.  (On "
"many Linux architectures, B<SHMLBA> is the same as the system page size.)"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:293
msgid ""
"The implementation places no intrinsic per-process limit on the number of "
"shared memory segments (B<SHMSEG>)."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:297
msgid ""
"The two programs shown below exchange a string using a shared memory "
"segment.  Further details about the programs are given below.  First, we "
"show a shell session demonstrating their use."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:302
msgid ""
"In one terminal window, we run the \"reader\" program, which creates a "
"System V shared memory segment and a System V semaphore set.  The program "
"prints out the IDs of the created objects, and then waits for the semaphore "
"to change value."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:307
#, no-wrap
msgid ""
"$ B<./svshm_string_read>\n"
"shmid = 1114194; semid = 15\n"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:316
msgid ""
"In another terminal window, we run the \"writer\" program.  The \"writer\" "
"program takes three command-line arguments: the IDs of the shared memory "
"segment and semaphore set created by the \"reader\", and a string.  It "
"attaches the existing shared memory segment, copies the string to the shared "
"memory, and modifies the semaphore value."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:320
#, no-wrap
msgid "$ B<./svshm_string_write 1114194 15 \\(aqHello, world\\(aq>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:327
msgid ""
"Returning to the terminal where the \"reader\" is running, we see that the "
"program has ceased waiting on the semaphore and has printed the string that "
"was copied into the shared memory segment by the writer:"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:331
#, no-wrap
msgid "Hello, world\n"
msgstr ""

#. type: SS
#: build/C/man2/shmop.2:334
#, no-wrap
msgid "Program source: svshm_string.h"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:336
msgid ""
"The following header file is included by the \"reader\" and \"writer\" "
"programs."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:346
#, no-wrap
msgid ""
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/ipc.hE<gt>\n"
"#include E<lt>sys/shm.hE<gt>\n"
"#include E<lt>sys/sem.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:358
#, no-wrap
msgid ""
"union semun {                   /* Used in calls to semctl() */\n"
"    int                 val;\n"
"    struct semid_ds *   buf;\n"
"    unsigned short *    array;\n"
"#if defined(__linux__)\n"
"    struct seminfo *    __buf;\n"
"#endif\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:360
#, no-wrap
msgid "#define MEM_SIZE 4096\n"
msgstr ""

#. type: SS
#: build/C/man2/shmop.2:363
#, no-wrap
msgid "Program source: svshm_string_read.c"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:371
msgid ""
"The \"reader\" program creates a shared memory segment and a semaphore set "
"containing one semaphore.  It then attaches the shared memory object into "
"its address space and initializes the semaphore value to 1.  Finally, the "
"program waits for the semaphore value to become 0, and afterwards prints the "
"string that has been copied into the shared memory segment by the "
"\"writer\"."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:375
#, no-wrap
msgid "/* svshm_string_read.c\n"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:379 build/C/man2/shmop.2:453
#, no-wrap
msgid ""
"   Licensed under GNU General Public License v2 or later.\n"
"*/\n"
"#include \"svshm_string.h\"\n"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:387
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int semid, shmid;\n"
"    union semun arg, dummy;\n"
"    struct sembuf sop;\n"
"    char *addr;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:390
#, no-wrap
msgid ""
"    /* Create shared memory and semaphore set containing one\n"
"       semaphore */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:394
#, no-wrap
msgid ""
"    shmid = shmget(IPC_PRIVATE, MEM_SIZE, IPC_CREAT | 0600);\n"
"    if (shmid == -1)\n"
"        errExit(\"shmget\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:398
#, no-wrap
msgid ""
"    semid = semget(IPC_PRIVATE, 1, IPC_CREAT | 0600);\n"
"    if (shmid == -1)\n"
"        errExit(\"shmget\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:400
#, no-wrap
msgid "    /* Attach shared memory into our address space */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:404
#, no-wrap
msgid ""
"    addr = shmat(shmid, NULL, SHM_RDONLY);\n"
"    if (addr == (void *) -1)\n"
"        errExit(\"shmat\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:406
#, no-wrap
msgid "    /* Initialize semaphore 0 in set with value 1 */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:410
#, no-wrap
msgid ""
"    arg.val = 1;\n"
"    if (semctl(semid, 0, SETVAL, arg) == -1)\n"
"        errExit(\"semctl\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:412
#, no-wrap
msgid "    printf(\"shmid = %d; semid = %d\\en\", shmid, semid);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:414
#, no-wrap
msgid "    /* Wait for semaphore value to become 0 */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:418
#, no-wrap
msgid ""
"    sop.sem_num = 0;\n"
"    sop.sem_op = 0;\n"
"    sop.sem_flg = 0;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:421 build/C/man2/shmop.2:495
#, no-wrap
msgid ""
"    if (semop(semid, &sop, 1) == -1)\n"
"        errExit(\"semop\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:423
#, no-wrap
msgid "    /* Print the string from shared memory */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:425
#, no-wrap
msgid "    printf(\"%s\\en\", addr);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:427
#, no-wrap
msgid "    /* Remove shared memory and semaphore set */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:432
#, no-wrap
msgid ""
"    if (shmctl(shmid, IPC_RMID, NULL) == -1)\n"
"        errExit(\"shmctl\");\n"
"    if (semctl(semid, 0, IPC_RMID, dummy) == -1)\n"
"        errExit(\"semctl\");\n"
msgstr ""

#. type: SS
#: build/C/man2/shmop.2:438
#, no-wrap
msgid "Program source: svshm_string_write.c"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:445
msgid ""
"The writer program takes three command-line arguments: the IDs of the shared "
"memory segment and semaphore set that have already been created by the "
"\"reader\", and a string.  It attaches the shared memory segment into its "
"address space, and then decrements the semaphore value to 0 in order to "
"inform the \"reader\" that it can now examine the contents of the shared "
"memory."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:449
#, no-wrap
msgid "/* svshm_string_write.c\n"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:461
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int semid, shmid;\n"
"    struct sembuf sop;\n"
"    char *addr;\n"
"    size_t len;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:466
#, no-wrap
msgid ""
"    if (argc != 4) {\n"
"        fprintf(stderr, \"Usage: %s shmid semid string\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:472
#, no-wrap
msgid ""
"    len = strlen(argv[3]) + 1;  /* +1 to include trailing \\(aq\\e0\\(aq "
"*/\n"
"    if (len E<gt> MEM_SIZE) {\n"
"        fprintf(stderr, \"String is too big!\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:474
#, no-wrap
msgid "    /* Get object IDs from command-line */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:477
#, no-wrap
msgid ""
"    shmid = atoi(argv[1]);\n"
"    semid = atoi(argv[2]);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:480
#, no-wrap
msgid ""
"    /* Attach shared memory into our address space and copy string\n"
"       (including trailing null byte) into memory. */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:484
#, no-wrap
msgid ""
"    addr = shmat(shmid, NULL, 0);\n"
"    if (addr == (void *) -1)\n"
"        errExit(\"shmat\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:486
#, no-wrap
msgid "    memcpy(addr, argv[3], len);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:488
#, no-wrap
msgid "    /* Decrement semaphore to 0 */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:492
#, no-wrap
msgid ""
"    sop.sem_num = 0;\n"
"    sop.sem_op = -1;\n"
"    sop.sem_flg = 0;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:508
msgid ""
"B<brk>(2), B<mmap>(2), B<shmctl>(2), B<shmget>(2), B<capabilities>(7), "
"B<shm_overview>(7), B<sysvipc>(7)"
msgstr ""

#. type: TH
#: build/C/man2/subpage_prot.2:30
#, no-wrap
msgid "SUBPAGE_PROT"
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:33
msgid "subpage_prot - define a subpage protection for an address range"
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:37
#, no-wrap
msgid ""
"B<int subpage_prot(unsigned long >I<addr>B<, unsigned long >I<len>B<,>\n"
"B<                  uint32_t *>I<map>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:41 build/C/man2/membarrier.2:38
msgid "I<Note>: There is no glibc wrapper for this system call; see NOTES."
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:47
msgid ""
"The PowerPC-specific B<subpage_prot>()  system call provides the facility to "
"control the access permissions on individual 4\\ kB subpages on systems "
"configured with a page size of 64\\ kB."
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:54
msgid ""
"The protection map is applied to the memory pages in the region starting at "
"I<addr> and continuing for I<len> bytes.  Both of these arguments must be "
"aligned to a 64-kB boundary."
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:66
msgid ""
"The protection map is specified in the buffer pointed to by I<map>.  The map "
"has 2 bits per 4\\ kB subpage; thus each 32-bit word specifies the "
"protections of 16 4\\ kB subpages inside a 64\\ kB page (so, the number of "
"32-bit words pointed to by I<map> should equate to the number of 64-kB pages "
"specified by I<len>).  Each 2-bit field in the protection map is either 0 to "
"allow any access, 1 to prevent writes, or 2 or 3 to prevent all accesses."
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:71
msgid ""
"On success, B<subpage_prot>()  returns 0.  Otherwise, one of the error codes "
"specified below is returned."
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:77
msgid "The buffer referred to by I<map> is not accessible."
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:87
msgid ""
"The I<addr> or I<len> arguments are incorrect.  Both of these arguments must "
"be aligned to a multiple of the system page size, and they must not refer to "
"a region outside of the address space of the process or to a region that "
"consists of huge pages."
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:90 build/C/man2/sync_file_range.2:166
msgid "Out of memory."
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:96
msgid ""
"This system call is provided on the PowerPC architecture since Linux "
"2.6.25.  The system call is provided only if the kernel is configured with "
"B<CONFIG_PPC_64K_PAGES>.  No library support is provided."
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:101 build/C/man2/membarrier.2:328
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:106
msgid ""
"Normal page protections (at the 64-kB page level) also apply; the subpage "
"protection mechanism is an additional constraint, so putting 0 in a 2-bit "
"field won't allow writes to a page that is otherwise write-protected."
msgstr ""

#. type: SS
#: build/C/man2/subpage_prot.2:106
#, no-wrap
msgid "Rationale"
msgstr ""

#.  In the initial implementation, it was the case that:
#.      In fact the whole process is switched to use 4 kB hardware pages when the
#.      subpage_prot system call is used, but this could be improved in future
#.      to switch only the affected segments.
#.  But Paul Mackerass says (Oct 2010): I'm pretty sure we now only switch
#.  the affected segment, not the whole process.
#. type: Plain text
#: build/C/man2/subpage_prot.2:128
msgid ""
"This system call is provided to assist writing emulators that operate using "
"64-kB pages on PowerPC systems.  When emulating systems such as x86, which "
"uses a smaller page size, the emulator can no longer use the "
"memory-management unit (MMU)  and normal system calls for controlling page "
"protections.  (The emulator could emulate the MMU by checking and possibly "
"remapping the address for each memory access in software, but that is slow.)  "
"The idea is that the emulator supplies an array of protection masks to apply "
"to a specified range of virtual addresses.  These masks are applied at the "
"level where hardware page-table entries (PTEs)  are inserted into the "
"hardware page table based on the Linux PTEs, so the Linux PTEs are not "
"affected.  Implicit in this is that the regions of the address space that "
"are protected are switched to use 4-kB hardware pages rather than 64-kB "
"hardware pages (on machines with hardware 64-kB page support)."
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:131
msgid "B<mprotect>(2), B<syscall>(2)"
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:134
msgid ""
"I<Documentation/admin-guide/mm/hugetlbpage.rst> in the Linux kernel source "
"tree"
msgstr ""

#. type: TH
#: build/C/man2/sync_file_range.2:30
#, no-wrap
msgid "SYNC_FILE_RANGE"
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:33
msgid "sync_file_range - sync a file segment with disk"
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:37
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:40
#, no-wrap
msgid ""
"B<int sync_file_range(int >I<fd>B<, off64_t >I<offset>B<, off64_t "
">I<nbytes>B<,>\n"
"B<                    unsigned int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:47
msgid ""
"B<sync_file_range>()  permits fine control when synchronizing the open file "
"referred to by the file descriptor I<fd> with disk."
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:61
msgid ""
"I<offset> is the starting byte of the file range to be synchronized.  "
"I<nbytes> specifies the length of the range to be synchronized, in bytes; if "
"I<nbytes> is zero, then all bytes from I<offset> through to the end of file "
"are synchronized.  Synchronization is in units of the system page size: "
"I<offset> is rounded down to a page boundary; I<(offset+nbytes-1)> is "
"rounded up to a page boundary."
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:65
msgid "The I<flags> bit-mask argument can include any of the following values:"
msgstr ""

#. type: TP
#: build/C/man2/sync_file_range.2:65
#, no-wrap
msgid "B<SYNC_FILE_RANGE_WAIT_BEFORE>"
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:70
msgid ""
"Wait upon write-out of all pages in the specified range that have already "
"been submitted to the device driver for write-out before performing any "
"write."
msgstr ""

#. type: TP
#: build/C/man2/sync_file_range.2:70 build/C/man2/sync_file_range.2:120
#, no-wrap
msgid "B<SYNC_FILE_RANGE_WRITE>"
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:76
msgid ""
"Initiate write-out of all dirty pages in the specified range which are not "
"presently submitted write-out.  Note that even this may block if you attempt "
"to write more than request queue size."
msgstr ""

#. type: TP
#: build/C/man2/sync_file_range.2:76
#, no-wrap
msgid "B<SYNC_FILE_RANGE_WAIT_AFTER>"
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:80
msgid "Wait upon write-out of all pages in the range after performing any write."
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:84
msgid "Specifying I<flags> as 0 is permitted, as a no-op."
msgstr ""

#. type: SS
#: build/C/man2/sync_file_range.2:84
#, no-wrap
msgid "Warning"
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:100
msgid ""
"This system call is extremely dangerous and should not be used in portable "
"programs.  None of these operations writes out the file's metadata.  "
"Therefore, unless the application is strictly performing overwrites of "
"already-instantiated disk blocks, there are no guarantees that the data will "
"be available after a crash.  There is no user interface to know if a write "
"is purely an overwrite.  On filesystems using copy-on-write semantics (e.g., "
"I<btrfs>)  an overwrite of existing allocated blocks is impossible.  When "
"writing into preallocated space, many filesystems also require calls into "
"the block allocator, which this system call does not sync out to disk.  This "
"system call does not flush disk write caches and thus does not provide any "
"data integrity on systems with volatile disk write caches."
msgstr ""

#. type: SS
#: build/C/man2/sync_file_range.2:100
#, no-wrap
msgid "Some details"
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:108
msgid ""
"B<SYNC_FILE_RANGE_WAIT_BEFORE> and B<SYNC_FILE_RANGE_WAIT_AFTER> will detect "
"any I/O errors or B<ENOSPC> conditions and will return these to the caller."
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:112
msgid "Useful combinations of the I<flags> bits are:"
msgstr ""

#. type: TP
#: build/C/man2/sync_file_range.2:112
#, no-wrap
msgid "B<SYNC_FILE_RANGE_WAIT_BEFORE | SYNC_FILE_RANGE_WRITE>"
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:120
msgid ""
"Ensures that all pages in the specified range which were dirty when "
"B<sync_file_range>()  was called are placed under write-out.  This is a "
"start-write-for-data-integrity operation."
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:127
msgid ""
"Start write-out of all dirty pages in the specified range which are not "
"presently under write-out.  This is an asynchronous flush-to-disk "
"operation.  This is not suitable for data integrity operations."
msgstr ""

#. type: TP
#: build/C/man2/sync_file_range.2:127
#, no-wrap
msgid "B<SYNC_FILE_RANGE_WAIT_BEFORE> (or B<SYNC_FILE_RANGE_WAIT_AFTER>)"
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:134
msgid ""
"Wait for completion of write-out of all pages in the specified range.  This "
"can be used after an earlier B<SYNC_FILE_RANGE_WAIT_BEFORE | "
"SYNC_FILE_RANGE_WRITE> operation to wait for completion of that operation, "
"and obtain its result."
msgstr ""

#. type: TP
#: build/C/man2/sync_file_range.2:134
#, no-wrap
msgid ""
"B<SYNC_FILE_RANGE_WAIT_BEFORE | SYNC_FILE_RANGE_WRITE | "
"SYNC_FILE_RANGE_WAIT_AFTER>"
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:141
msgid ""
"This is a write-for-data-integrity operation that will ensure that all pages "
"in the specified range which were dirty when B<sync_file_range>()  was "
"called are committed to disk."
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:147
msgid ""
"On success, B<sync_file_range>()  returns 0; on failure -1 is returned and "
"I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:152
msgid "I<fd> is not a valid file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:160
msgid "I<flags> specifies an invalid bit; or I<offset> or I<nbytes> is invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:163
msgid "I/O error."
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:169
msgid "Out of disk space."
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:174
msgid ""
"I<fd> refers to something other than a regular file, a block device, or a "
"directory."
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:177
msgid "B<sync_file_range>()  appeared on Linux in kernel 2.6.17."
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:180
msgid ""
"This system call is Linux-specific, and should be avoided in portable "
"programs."
msgstr ""

#. type: SS
#: build/C/man2/sync_file_range.2:181
#, no-wrap
msgid "sync_file_range2()"
msgstr ""

#.  See kernel commit edd5cd4a9424f22b0fa08bef5e299d41befd5622
#. type: Plain text
#: build/C/man2/sync_file_range.2:198
msgid ""
"Some architectures (e.g., PowerPC, ARM)  need 64-bit arguments to be aligned "
"in a suitable pair of registers.  On such architectures, the call signature "
"of B<sync_file_range>()  shown in the SYNOPSIS would force a register to be "
"wasted as padding between the I<fd> and I<offset> arguments.  (See "
"B<syscall>(2)  for details.)  Therefore, these architectures define a "
"different system call that orders the arguments suitably:"
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:203
#, no-wrap
msgid ""
"B<int sync_file_range2(int >I<fd>B<, unsigned int >I<flags>B<,>\n"
"B<                     off64_t >I<offset>B<, off64_t >I<nbytes>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:208
msgid ""
"The behavior of this system call is otherwise exactly the same as "
"B<sync_file_range>()."
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:219
msgid ""
"A system call with this signature first appeared on the ARM architecture in "
"Linux 2.6.20, with the name B<arm_sync_file_range>().  It was renamed in "
"Linux 2.6.22, when the analogous system call was added for PowerPC.  On "
"architectures where glibc support is provided, glibc transparently wraps "
"B<sync_file_range2>()  under the name B<sync_file_range>()."
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:224
msgid "B<fdatasync>(2), B<fsync>(2), B<msync>(2), B<sync>(2)"
msgstr ""

#. type: TH
#: build/C/man2/memfd_create.2:21
#, no-wrap
msgid "MEMFD_CREATE"
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:24
msgid "memfd_create - create an anonymous file"
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:30
#, no-wrap
msgid "B<int memfd_create(const char *>I<name>B<, unsigned int >I<flags>B<);>\n"
msgstr ""

#.  David Herrmann:
#.      memfd uses VM_NORESERVE so each page is accounted on first access.
#.      This means, the overcommit-limits (see __vm_enough_memory()) and the
#.      memory-cgroup limits (mem_cgroup_try_charge()) are applied. Note that
#.      those are accounted on "current" and "current->mm", that is, the
#.      process doing the first page access.
#. type: Plain text
#: build/C/man2/memfd_create.2:54
msgid ""
"B<memfd_create>()  creates an anonymous file and returns a file descriptor "
"that refers to it.  The file behaves like a regular file, and so can be "
"modified, truncated, memory-mapped, and so on.  However, unlike a regular "
"file, it lives in RAM and has a volatile backing storage.  Once all "
"references to the file are dropped, it is automatically released.  Anonymous "
"memory is used for all backing pages of the file.  Therefore, files created "
"by B<memfd_create>()  have the same semantics as other anonymous memory "
"allocations such as those allocated using B<mmap>(2)  with the "
"B<MAP_ANONYMOUS> flag."
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:61
msgid ""
"The initial size of the file is set to 0.  Following the call, the file size "
"should be set using B<ftruncate>(2).  (Alternatively, the file may be "
"populated by calls to B<write>(2)  or similar.)"
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:72
msgid ""
"The name supplied in I<name> is used as a filename and will be displayed as "
"the target of the corresponding symbolic link in the directory "
"I</proc/self/fd/>.  The displayed name is always prefixed with I<memfd:> and "
"serves only for debugging purposes.  Names do not affect the behavior of the "
"file descriptor, and as such multiple files can have the same name without "
"any side effects."
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:77
msgid ""
"The following values may be bitwise ORed in I<flags> to change the behavior "
"of B<memfd_create>():"
msgstr ""

#. type: TP
#: build/C/man2/memfd_create.2:77
#, no-wrap
msgid "B<MFD_CLOEXEC>"
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:87
msgid ""
"Set the close-on-exec (B<FD_CLOEXEC>)  flag on the new file descriptor.  See "
"the description of the B<O_CLOEXEC> flag in B<open>(2)  for reasons why this "
"may be useful."
msgstr ""

#. type: TP
#: build/C/man2/memfd_create.2:87
#, no-wrap
msgid "B<MFD_ALLOW_SEALING>"
msgstr ""

#.  FIXME Why is the MFD_ALLOW_SEALING behavior not simply the default?
#.  Is it worth adding some text explaining this?
#. type: Plain text
#: build/C/man2/memfd_create.2:103
msgid ""
"Allow sealing operations on this file.  See the discussion of the "
"B<F_ADD_SEALS> and B<F_GET_SEALS> operations in B<fcntl>(2), and also NOTES, "
"below.  The initial set of seals is empty.  If this flag is not set, the "
"initial set of seals will be B<F_SEAL_SEAL>, meaning that no other seals can "
"be set on the file."
msgstr ""

#. type: TP
#: build/C/man2/memfd_create.2:103
#, no-wrap
msgid "B<MFD_HUGETLB> (since Linux 4.14)"
msgstr ""

#.  commit 749df87bd7bee5a79cef073f5d032ddb2b211de8
#.  commit 47b9012ecdc747f6936395265e677d41e11a31ff
#. type: Plain text
#: build/C/man2/memfd_create.2:119
msgid ""
"The anonymous file will be created in the hugetlbfs filesystem using huge "
"pages.  See the Linux kernel source file "
"I<Documentation/admin-guide/mm/hugetlbpage.rst> for more information about "
"hugetlbfs.  Specifying both B<MFD_HUGETLB> and B<MFD_ALLOW_SEALING> in "
"I<flags> is supported since Linux 4.16."
msgstr ""

#. type: TP
#: build/C/man2/memfd_create.2:119
#, no-wrap
msgid "B<MFD_HUGE_2MB>, B<MFD_HUGE_1GB>, B<...>"
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:128
msgid ""
"Used in conjunction with B<MFD_HUGETLB> to select alternative hugetlb page "
"sizes (respectively, 2\\ MB, 1\\ GB, ...)  on systems that support multiple "
"hugetlb page sizes.  Definitions for known huge page sizes are included in "
"the header file I<E<lt>linux/memfd.hE<gt>.>"
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:132
msgid ""
"For details on encoding huge page sizes not included in the header file, see "
"the discussion of the similarly named constants in B<mmap>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:136
msgid "Unused bits in I<flags> must be 0."
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:145
msgid ""
"As its return value, B<memfd_create>()  returns a new file descriptor that "
"can be used to refer to the file.  This file descriptor is opened for both "
"reading and writing (B<O_RDWR>)  and B<O_LARGEFILE> is set for the file "
"descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:158
msgid ""
"With respect to B<fork>(2)  and B<execve>(2), the usual semantics apply for "
"the file descriptor created by B<memfd_create>().  A copy of the file "
"descriptor is inherited by the child produced by B<fork>(2)  and refers to "
"the same file.  The file descriptor is preserved across B<execve>(2), unless "
"the close-on-exec flag has been set."
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:165
msgid ""
"On success, B<memfd_create>()  returns a new file descriptor.  On error, -1 "
"is returned and I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:171
msgid "The address in I<name> points to invalid memory."
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:175
msgid "I<flags> included unknown bits."
msgstr ""

#.  NAME_MAX - strlen("memfd:")
#. type: Plain text
#: build/C/man2/memfd_create.2:182
msgid ""
"I<name> was too long.  (The limit is 249 bytes, excluding the terminating "
"null byte.)"
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:190
msgid "Both B<MFD_HUGETLB> and B<MFD_ALLOW_SEALING> were specified in I<flags>."
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:199
msgid "There was insufficient memory to create a new anonymous file."
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:204
msgid ""
"The B<memfd_create>()  system call first appeared in Linux 3.17; glibc "
"support was added in version 2.27."
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:208
msgid "The B<memfd_create>()  system call is Linux-specific."
msgstr ""

#.  See also http://lwn.net/Articles/593918/
#.  and http://lwn.net/Articles/594919/ and http://lwn.net/Articles/591108/
#. type: Plain text
#: build/C/man2/memfd_create.2:221
msgid ""
"The B<memfd_create>()  system call provides a simple alternative to manually "
"mounting a B<tmpfs>(5)  filesystem and creating and opening a file in that "
"filesystem.  The primary purpose of B<memfd_create>()  is to create files "
"and associated file descriptors that are used with the file-sealing APIs "
"provided by B<fcntl>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:235
msgid ""
"The B<memfd_create>()  system call also has uses without file sealing (which "
"is why file-sealing is disabled, unless explicitly requested with the "
"B<MFD_ALLOW_SEALING> flag).  In particular, it can be used as an alternative "
"to creating files in I<tmp> or as an alternative to using the B<open>(2)  "
"B<O_TMPFILE> in cases where there is no intention to actually link the "
"resulting file into the filesystem."
msgstr ""

#. type: SS
#: build/C/man2/memfd_create.2:235
#, no-wrap
msgid "File sealing"
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:253
msgid ""
"In the absence of file sealing, processes that communicate via shared memory "
"must either trust each other, or take measures to deal with the possibility "
"that an untrusted peer may manipulate the shared memory region in "
"problematic ways.  For example, an untrusted peer might modify the contents "
"of the shared memory at any time, or shrink the shared memory region.  The "
"former possibility leaves the local process vulnerable to "
"time-of-check-to-time-of-use race conditions (typically dealt with by "
"copying data from the shared memory region before checking and using it).  "
"The latter possibility leaves the local process vulnerable to B<SIGBUS> "
"signals when an attempt is made to access a now-nonexistent location in the "
"shared memory region.  (Dealing with this possibility necessitates the use "
"of a handler for the B<SIGBUS> signal.)"
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:259
msgid ""
"Dealing with untrusted peers imposes extra complexity on code that employs "
"shared memory.  Memory sealing enables that extra complexity to be "
"eliminated, by allowing a process to operate secure in the knowledge that "
"its peer can't modify the shared memory in an undesired fashion."
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:261
msgid "An example of the usage of the sealing mechanism is as follows:"
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:267
msgid ""
"The first process creates a B<tmpfs>(5)  file using B<memfd_create>().  The "
"call yields a file descriptor used in subsequent steps."
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:274
msgid ""
"The first process sizes the file created in the previous step using "
"B<ftruncate>(2), maps it using B<mmap>(2), and populates the shared memory "
"with the desired data."
msgstr ""

#. type: IP
#: build/C/man2/memfd_create.2:274
#, no-wrap
msgid "3."
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:293
msgid ""
"The first process uses the B<fcntl>(2)  B<F_ADD_SEALS> operation to place "
"one or more seals on the file, in order to restrict further modifications on "
"the file.  (If placing the seal B<F_SEAL_WRITE>, then it will be necessary "
"to first unmap the shared writable mapping created in the previous step.  "
"Otherwise, behavior similar to B<F_SEAL_WRITE> can be achieved by using "
"B<F_SEAL_FUTURE_WRITE>, which will prevent future writes via B<mmap>(2)  and "
"B<write>(2)  from succeeding while keeping existing shared writable "
"mappings)."
msgstr ""

#. type: IP
#: build/C/man2/memfd_create.2:293
#, no-wrap
msgid "4."
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:298
msgid ""
"A second process obtains a file descriptor for the B<tmpfs>(5)  file and "
"maps it.  Among the possible ways in which this could happen are the "
"following:"
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:309
msgid ""
"The process that called B<memfd_create>()  could transfer the resulting file "
"descriptor to the second process via a UNIX domain socket (see B<unix>(7)  "
"and B<cmsg>(3)).  The second process then maps the file using B<mmap>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:317
msgid ""
"The second process is created via B<fork>(2)  and thus automatically "
"inherits the file descriptor and mapping.  (Note that in this case and the "
"next, there is a natural trust relationship between the two processes, since "
"they are running under the same user ID.  Therefore, file sealing would not "
"normally be necessary.)"
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:331
msgid ""
"The second process opens the file I</proc/E<lt>pidE<gt>/fd/E<lt>fdE<gt>>, "
"where I<E<lt>pidE<gt>> is the PID of the first process (the one that called "
"B<memfd_create>()), and I<E<lt>fdE<gt>> is the number of the file descriptor "
"returned by the call to B<memfd_create>()  in that process.  The second "
"process then maps the file using B<mmap>(2)."
msgstr ""

#. type: IP
#: build/C/man2/memfd_create.2:332
#, no-wrap
msgid "5."
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:344
msgid ""
"The second process uses the B<fcntl>(2)  B<F_GET_SEALS> operation to "
"retrieve the bit mask of seals that has been applied to the file.  This bit "
"mask can be inspected in order to determine what kinds of restrictions have "
"been placed on file modifications.  If desired, the second process can apply "
"further seals to impose additional restrictions (so long as the "
"B<F_SEAL_SEAL> seal has not yet been applied)."
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:348
msgid ""
"Below are shown two example programs that demonstrate the use of "
"B<memfd_create>()  and the file sealing API."
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:363
msgid ""
"The first program, I<t_memfd_create.c>, creates a B<tmpfs>(5)  file using "
"B<memfd_create>(), sets a size for the file, maps it into memory, and "
"optionally places some seals on the file.  The program accepts up to three "
"command-line arguments, of which the first two are required.  The first "
"argument is the name to associate with the file, the second argument is the "
"size to be set for the file, and the optional third argument is a string of "
"characters that specify seals to be set on file."
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:369
msgid ""
"The second program, I<t_get_seals.c>, can be used to open an existing file "
"that was created via B<memfd_create>()  and inspect the set of seals that "
"have been applied to that file."
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:374
msgid ""
"The following shell session demonstrates the use of these programs.  First "
"we create a B<tmpfs>(5)  file and set some seals on it:"
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:380
#, no-wrap
msgid ""
"$ B<./t_memfd_create my_memfd_file 4096 sw &>\n"
"[1] 11775\n"
"PID: 11775; fd: 3; /proc/11775/fd/3\n"
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:398
msgid ""
"At this point, the I<t_memfd_create> program continues to run in the "
"background.  From another program, we can obtain a file descriptor for the "
"file created by B<memfd_create>()  by opening the I</proc/[pid]/fd> file "
"that corresponds to the file descriptor opened by B<memfd_create>().  Using "
"that pathname, we inspect the content of the I</proc/[pid]/fd> symbolic "
"link, and use our I<t_get_seals> program to view the seals that have been "
"placed on the file:"
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:405
#, no-wrap
msgid ""
"$ B<readlink /proc/11775/fd/3>\n"
"/memfd:my_memfd_file (deleted)\n"
"$ B<./t_get_seals /proc/11775/fd/3>\n"
"Existing seals: WRITE SHRINK\n"
msgstr ""

#. type: SS
#: build/C/man2/memfd_create.2:407
#, no-wrap
msgid "Program source: t_memfd_create.c"
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:418
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>sys/mman.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:430
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int fd;\n"
"    unsigned int seals;\n"
"    char *addr;\n"
"    char *name, *seals_arg;\n"
"    ssize_t len;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:442
#, no-wrap
msgid ""
"    if (argc E<lt> 3) {\n"
"        fprintf(stderr, \"%s name size [seals]\\en\", argv[0]);\n"
"        fprintf(stderr, \"\\et\\(aqseals\\(aq can contain any of the \"\n"
"                \"following characters:\\en\");\n"
"        fprintf(stderr, \"\\et\\etg - F_SEAL_GROW\\en\");\n"
"        fprintf(stderr, \"\\et\\ets - F_SEAL_SHRINK\\en\");\n"
"        fprintf(stderr, \"\\et\\etw - F_SEAL_WRITE\\en\");\n"
"        fprintf(stderr, \"\\et\\etW - F_SEAL_FUTURE_WRITE\\en\");\n"
"        fprintf(stderr, \"\\et\\etS - F_SEAL_SEAL\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:446
#, no-wrap
msgid ""
"    name = argv[1];\n"
"    len = atoi(argv[2]);\n"
"    seals_arg = argv[3];\n"
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:449
#, no-wrap
msgid ""
"    /* Create an anonymous file in tmpfs; allow seals to be\n"
"       placed on the file */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:453
#, no-wrap
msgid ""
"    fd = memfd_create(name, MFD_ALLOW_SEALING);\n"
"    if (fd == -1)\n"
"        errExit(\"memfd_create\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:455
#, no-wrap
msgid "    /* Size the file as specified on the command line */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:458
#, no-wrap
msgid ""
"    if (ftruncate(fd, len) == -1)\n"
"        errExit(\"truncate\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:461
#, no-wrap
msgid ""
"    printf(\"PID: %jd; fd: %d; /proc/%jd/fd/%d\\en\",\n"
"            (intmax_t) getpid(), fd, (intmax_t) getpid(), fd);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:464
#, no-wrap
msgid ""
"    /* Code to map the file and populate the mapping with data\n"
"       omitted */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:467
#, no-wrap
msgid ""
"    /* If a \\(aqseals\\(aq command-line argument was supplied, set some\n"
"       seals on the file */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:470
#, no-wrap
msgid ""
"    if (seals_arg != NULL) {\n"
"        seals = 0;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:481
#, no-wrap
msgid ""
"        if (strchr(seals_arg, \\(aqg\\(aq) != NULL)\n"
"            seals |= F_SEAL_GROW;\n"
"        if (strchr(seals_arg, \\(aqs\\(aq) != NULL)\n"
"            seals |= F_SEAL_SHRINK;\n"
"        if (strchr(seals_arg, \\(aqw\\(aq) != NULL)\n"
"            seals |= F_SEAL_WRITE;\n"
"        if (strchr(seals_arg, \\(aqW\\(aq) != NULL)\n"
"            seals |= F_SEAL_FUTURE_WRITE;\n"
"        if (strchr(seals_arg, \\(aqS\\(aq) != NULL)\n"
"            seals |= F_SEAL_SEAL;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:485
#, no-wrap
msgid ""
"        if (fcntl(fd, F_ADD_SEALS, seals) == -1)\n"
"            errExit(\"fcntl\");\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:488
#, no-wrap
msgid ""
"    /* Keep running, so that the file created by memfd_create()\n"
"       continues to exist */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:490
#, no-wrap
msgid "    pause();\n"
msgstr ""

#. type: SS
#: build/C/man2/memfd_create.2:494
#, no-wrap
msgid "Program source: t_get_seals.c"
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:504
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>sys/mman.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:513
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int fd;\n"
"    unsigned int seals;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:518
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"%s /proc/PID/fd/FD\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:522
#, no-wrap
msgid ""
"    fd = open(argv[1], O_RDWR);\n"
"    if (fd == -1)\n"
"        errExit(\"open\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:526
#, no-wrap
msgid ""
"    seals = fcntl(fd, F_GET_SEALS);\n"
"    if (seals == -1)\n"
"        errExit(\"fcntl\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:539
#, no-wrap
msgid ""
"    printf(\"Existing seals:\");\n"
"    if (seals & F_SEAL_SEAL)\n"
"        printf(\" SEAL\");\n"
"    if (seals & F_SEAL_GROW)\n"
"        printf(\" GROW\");\n"
"    if (seals & F_SEAL_WRITE)\n"
"        printf(\" WRITE\");\n"
"    if (seals & F_SEAL_FUTURE_WRITE)\n"
"        printf(\" FUTURE_WRITE\");\n"
"    if (seals & F_SEAL_SHRINK)\n"
"        printf(\" SHRINK\");\n"
"    printf(\"\\en\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:542
#, no-wrap
msgid ""
"    /* Code to map the file and access the contents of the\n"
"       resulting mapping omitted */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/memfd_create.2:552
msgid "B<fcntl>(2), B<ftruncate>(2), B<mmap>(2), B<shmget>(2), B<shm_open>(3)"
msgstr ""

#. type: TH
#: build/C/man2/s390_pci_mmio_write.2:25
#, no-wrap
msgid "S390_PCI_MMIO_WRITE"
msgstr ""

#. type: Plain text
#: build/C/man2/s390_pci_mmio_write.2:29
msgid ""
"s390_pci_mmio_write, s390_pci_mmio_read - transfer data to/from PCI MMIO "
"memory page"
msgstr ""

#. type: Plain text
#: build/C/man2/s390_pci_mmio_write.2:32
#, no-wrap
msgid "B<#include E<lt>asm/unistd.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/s390_pci_mmio_write.2:37
#, no-wrap
msgid ""
"B<int s390_pci_mmio_write(unsigned long >I<mmio_addr>B<,>\n"
"B<                        void *>I<user_buffer>B<, size_t >I<length>B<);>\n"
"B<int s390_pci_mmio_read(unsigned long >I<mmio_addr>B<,>\n"
"B<                        void *>I<user_buffer>B<, size_t >I<length>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/s390_pci_mmio_write.2:56
msgid ""
"The B<s390_pci_mmio_write>()  system call writes I<length> bytes of data "
"from the user-space buffer I<user_buffer> to the PCI MMIO memory location "
"specified by I<mmio_addr>.  The B<s390_pci_mmio_read>()  system call reads "
"I<length> bytes of data from the PCI MMIO memory location specified by "
"I<mmio_addr> to the user-space buffer I<user_buffer>."
msgstr ""

#. type: Plain text
#: build/C/man2/s390_pci_mmio_write.2:67
msgid ""
"These system calls must be used instead of the simple assignment or "
"data-transfer operations that are used to access the PCI MMIO memory areas "
"mapped to user space on the Linux System z platform.  The address specified "
"by I<mmio_addr> must belong to a PCI MMIO memory page mapping in the "
"caller's address space, and the data being written or read must not cross a "
"page boundary.  The I<length> value cannot be greater than the system page "
"size."
msgstr ""

#. type: Plain text
#: build/C/man2/s390_pci_mmio_write.2:76
msgid ""
"On success, B<s390_pci_mmio_write>()  and B<s390_pci_mmio_read>()  return "
"0.  On error, -1 is returned and I<errno> is set to one of the error codes "
"listed below."
msgstr ""

#. type: Plain text
#: build/C/man2/s390_pci_mmio_write.2:82
msgid "The address in I<mmio_addr> is invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/s390_pci_mmio_write.2:86
msgid ""
"I<user_buffer> does not point to a valid location in the caller's address "
"space."
msgstr ""

#. type: Plain text
#: build/C/man2/s390_pci_mmio_write.2:91
msgid "Invalid I<length> argument."
msgstr ""

#. type: Plain text
#: build/C/man2/s390_pci_mmio_write.2:94
msgid "PCI support is not enabled."
msgstr ""

#. type: Plain text
#: build/C/man2/s390_pci_mmio_write.2:97
msgid "Insufficient memory."
msgstr ""

#. type: Plain text
#: build/C/man2/s390_pci_mmio_write.2:99
msgid "These system calls are available since Linux 3.19."
msgstr ""

#. type: Plain text
#: build/C/man2/s390_pci_mmio_write.2:102
msgid ""
"This Linux-specific system call is available only on the s390 architecture.  "
"The required PCI support is available beginning with System z EC12."
msgstr ""

#. type: Plain text
#: build/C/man2/s390_pci_mmio_write.2:106
msgid ""
"Glibc does not provide a wrapper for this system call, use B<syscall>(2)  to "
"call it."
msgstr ""

#. type: Plain text
#: build/C/man2/s390_pci_mmio_write.2:108
msgid "B<syscall>(2)"
msgstr ""

#. type: TH
#: build/C/man2/membarrier.2:25
#, no-wrap
msgid "MEMBARRIER"
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:28
msgid "membarrier - issue memory barriers on a set of threads"
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:32
#, no-wrap
msgid "B<#include E<lt>linux/membarrier.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:34
#, no-wrap
msgid ""
"B<int membarrier(int >I<cmd>B<, unsigned int >I<flags>B<, int "
">I<cpu_id>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:48
msgid ""
"The B<membarrier>()  system call helps reducing the overhead of the memory "
"barrier instructions required to order memory accesses on multi-core "
"systems.  However, this system call is heavier than a memory barrier, so "
"using it effectively is I<not> as simple as replacing memory barriers with "
"this system call, but requires understanding of the details below."
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:53
msgid ""
"Use of memory barriers needs to be done taking into account that a memory "
"barrier always needs to be either matched with its memory barrier "
"counterparts, or that the architecture's memory model doesn't require the "
"matching barriers."
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:62
msgid ""
"There are cases where one side of the matching barriers (which we will refer "
"to as \"fast side\") is executed much more often than the other (which we "
"will refer to as \"slow side\").  This is a prime target for the use of "
"B<membarrier>().  The key idea is to replace, for these matching barriers, "
"the fast-side memory barriers by simple compiler barriers, for example:"
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:66
#, no-wrap
msgid "asm volatile (\"\" : : : \"memory\")\n"
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:71
msgid "and replace the slow-side memory barriers by calls to B<membarrier>()."
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:77
msgid ""
"This will add overhead to the slow side, and remove overhead from the fast "
"side, thus resulting in an overall performance increase as long as the slow "
"side is infrequent enough that the overhead of the B<membarrier>()  calls "
"does not outweigh the performance gain on the fast side."
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:81
msgid "The I<cmd> argument is one of the following:"
msgstr ""

#. type: TP
#: build/C/man2/membarrier.2:81
#, no-wrap
msgid "B<MEMBARRIER_CMD_QUERY> (since Linux 4.3)"
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:92
msgid ""
"Query the set of supported commands.  The return value of the call is a bit "
"mask of supported commands.  B<MEMBARRIER_CMD_QUERY>, which has the value 0, "
"is not itself included in this bit mask.  This command is always supported "
"(on kernels where B<membarrier>()  is provided)."
msgstr ""

#. type: TP
#: build/C/man2/membarrier.2:92
#, no-wrap
msgid "B<MEMBARRIER_CMD_GLOBAL> (since Linux 4.16)"
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:100
msgid ""
"Ensure that all threads from all processes on the system pass through a "
"state where all memory accesses to user-space addresses match program order "
"between entry to and return from the B<membarrier>()  system call.  All "
"threads on the system are targeted by this command."
msgstr ""

#. type: TP
#: build/C/man2/membarrier.2:100
#, no-wrap
msgid "B<MEMBARRIER_CMD_GLOBAL_EXPEDITED> (since Linux 4.16)"
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:105
msgid ""
"Execute a memory barrier on all running threads of all processes that "
"previously registered with B<MEMBARRIER_CMD_REGISTER_GLOBAL_EXPEDITED>."
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:113
msgid ""
"Upon return from the system call, the calling thread has a guarantee that "
"all running threads have passed through a state where all memory accesses to "
"user-space addresses match program order between entry to and return from "
"the system call (non-running threads are de facto in such a state).  This "
"guarantee is provided only for the threads of processes that previously "
"registered with B<MEMBARRIER_CMD_REGISTER_GLOBAL_EXPEDITED>."
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:119
msgid ""
"Given that registration is about the intent to receive the barriers, it is "
"valid to invoke B<MEMBARRIER_CMD_GLOBAL_EXPEDITED> from a process that has "
"not employed B<MEMBARRIER_CMD_REGISTER_GLOBAL_EXPEDITED>."
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:122 build/C/man2/membarrier.2:142
msgid ""
"The \"expedited\" commands complete faster than the non-expedited ones; they "
"never block, but have the downside of causing extra overhead."
msgstr ""

#. type: TP
#: build/C/man2/membarrier.2:122
#, no-wrap
msgid "B<MEMBARRIER_CMD_REGISTER_GLOBAL_EXPEDITED> (since Linux 4.16)"
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:127
msgid ""
"Register the process's intent to receive B<MEMBARRIER_CMD_GLOBAL_EXPEDITED> "
"memory barriers."
msgstr ""

#. type: TP
#: build/C/man2/membarrier.2:127
#, no-wrap
msgid "B<MEMBARRIER_CMD_PRIVATE_EXPEDITED> (since Linux 4.14)"
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:131
msgid ""
"Execute a memory barrier on each running thread belonging to the same "
"process as the calling thread."
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:139
msgid ""
"Upon return from the system call, the calling thread has a guarantee that "
"all its running thread siblings have passed through a state where all memory "
"accesses to user-space addresses match program order between entry to and "
"return from the system call (non-running threads are de facto in such a "
"state).  This guarantee is provided only for threads in the same process as "
"the calling thread."
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:145
msgid ""
"A process must register its intent to use the private expedited command "
"prior to using it."
msgstr ""

#. type: TP
#: build/C/man2/membarrier.2:145
#, no-wrap
msgid "B<MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED> (since Linux 4.14)"
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:149
msgid "Register the process's intent to use B<MEMBARRIER_CMD_PRIVATE_EXPEDITED>."
msgstr ""

#. type: TP
#: build/C/man2/membarrier.2:149
#, no-wrap
msgid "B<MEMBARRIER_CMD_PRIVATE_EXPEDITED_SYNC_CORE> (since Linux 4.16)"
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:157
msgid ""
"In addition to providing the memory ordering guarantees described in "
"B<MEMBARRIER_CMD_PRIVATE_EXPEDITED>, upon return from system call the "
"calling thread has a guarantee that all its running thread siblings have "
"executed a core serializing instruction.  This guarantee is provided only "
"for threads in the same process as the calling thread."
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:160
msgid ""
"The \"expedited\" commands complete faster than the non-expedited ones, they "
"never block, but have the downside of causing extra overhead."
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:163
msgid ""
"A process must register its intent to use the private expedited sync core "
"command prior to using it."
msgstr ""

#. type: TP
#: build/C/man2/membarrier.2:163
#, no-wrap
msgid "B<MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_SYNC_CORE> (since Linux 4.16)"
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:167
msgid ""
"Register the process's intent to use "
"B<MEMBARRIER_CMD_PRIVATE_EXPEDITED_SYNC_CORE>."
msgstr ""

#. type: TP
#: build/C/man2/membarrier.2:167
#, no-wrap
msgid "B<MEMBARRIER_CMD_PRIVATE_EXPEDITED_RSEQ> (since Linux 5.10)"
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:181
msgid ""
"Ensure the caller thread, upon return from system call, that all its running "
"thread siblings have any currently running rseq critical sections restarted "
"if I<flags> parameter is 0; if I<flags> parameter is "
"B<MEMBARRIER_CMD_FLAG_CPU>, then this operation is performed only on CPU "
"indicated by I<cpu_id>.  This guarantee is provided only for threads in the "
"same process as the calling thread."
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:183
msgid "RSEQ membarrier is only available in the \"private expedited\" form."
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:186
msgid ""
"A process must register its intent to use the private expedited rseq command "
"prior to using it."
msgstr ""

#. type: TP
#: build/C/man2/membarrier.2:186
#, no-wrap
msgid "B<MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_RSEQ> (since Linux 5.10)"
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:190
msgid ""
"Register the process's intent to use "
"B<MEMBARRIER_CMD_PRIVATE_EXPEDITED_RSEQ>."
msgstr ""

#. type: TP
#: build/C/man2/membarrier.2:190
#, no-wrap
msgid "B<MEMBARRIER_CMD_SHARED> (since Linux 4.3)"
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:195
msgid ""
"This is an alias for B<MEMBARRIER_CMD_GLOBAL> that exists for header "
"backward compatibility."
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:204
msgid ""
"The I<flags> argument must be specified as 0 unless the command is "
"B<MEMBARRIER_CMD_PRIVATE_EXPEDITED_RSEQ>, in which case I<flags> can be "
"either 0 or B<MEMBARRIER_CMD_FLAG_CPU>."
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:213
msgid ""
"The I<cpu_id> argument is ignored unless I<flags> is "
"B<MEMBARRIER_CMD_FLAG_CPU>, in which case it must specify the CPU targeted "
"by this membarrier command."
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:217
msgid ""
"All memory accesses performed in program order from each targeted thread are "
"guaranteed to be ordered with respect to B<membarrier>()."
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:231
msgid ""
"If we use the semantic I<barrier()> to represent a compiler barrier forcing "
"memory accesses to be performed in program order across the barrier, and "
"I<smp_mb()> to represent explicit memory barriers forcing full memory "
"ordering across the barrier, we have the following ordering table for each "
"pairing of I<barrier()>, B<membarrier>(), and I<smp_mb()>.  The pair "
"ordering is detailed as (O: ordered, X: not ordered):"
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:236
#, no-wrap
msgid ""
"                       barrier()  smp_mb()  membarrier()\n"
"       barrier()          X          X          O\n"
"       smp_mb()           X          O          O\n"
"       membarrier()       O          O          O\n"
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:253
msgid ""
"On success, the B<MEMBARRIER_CMD_QUERY> operation returns a bit mask of "
"supported commands, and the B<MEMBARRIER_CMD_GLOBAL>, "
"B<MEMBARRIER_CMD_GLOBAL_EXPEDITED>, "
"B<MEMBARRIER_CMD_REGISTER_GLOBAL_EXPEDITED>, "
"B<MEMBARRIER_CMD_PRIVATE_EXPEDITED>, "
"B<MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED>, "
"B<MEMBARRIER_CMD_PRIVATE_EXPEDITED_SYNC_CORE>, and "
"B<MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_SYNC_CORE> operations return "
"zero.  On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:263
msgid ""
"For a given command, with I<flags> set to 0, this system call is guaranteed "
"to always return the same value until reboot.  Further calls with the same "
"arguments will lead to the same result.  Therefore, with I<flags> set to 0, "
"error handling is required only for the first call to B<membarrier>()."
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:278
msgid ""
"I<cmd> is invalid, or I<flags> is nonzero, or the B<MEMBARRIER_CMD_GLOBAL> "
"command is disabled because the I<nohz_full> CPU parameter has been set, or "
"the B<MEMBARRIER_CMD_PRIVATE_EXPEDITED_SYNC_CORE> and "
"B<MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_SYNC_CORE> commands are not "
"implemented by the architecture."
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:283
msgid "The B<membarrier>()  system call is not implemented by this kernel."
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:287
msgid ""
"The current process was not registered prior to using private expedited "
"commands."
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:291
msgid "The B<membarrier>()  system call was added in Linux 4.3."
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:295
msgid "Before Linux 5.10, the prototype for B<membarrier>()  was:"
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:299
#, no-wrap
msgid "B<int membarrier(int >I<cmd>B<, int >I<flags>B<);>\n"
msgstr ""

#.  .SH SEE ALSO
#.  FIXME See if the following syscalls make it into Linux 4.15 or later
#.  .BR cpu_opv (2),
#.  .BR rseq (2)
#. type: Plain text
#: build/C/man2/membarrier.2:308
msgid "B<membarrier>()  is Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:317
msgid ""
"A memory barrier instruction is part of the instruction set of architectures "
"with weakly ordered memory models.  It orders memory accesses prior to the "
"barrier and after the barrier with respect to matching barriers on other "
"cores.  For instance, a load fence can order loads prior to and following "
"that fence with respect to stores ordered by store fences."
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:320
msgid ""
"Program order is the order in which instructions are ordered in the program "
"assembly code."
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:325
msgid ""
"Examples where B<membarrier>()  can be useful include implementations of "
"Read-Copy-Update libraries and garbage collectors."
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:333
msgid ""
"Assuming a multithreaded application where \"fast_path()\" is executed very "
"frequently, and where \"slow_path()\" is executed infrequently, the "
"following code (x86) can be transformed using B<membarrier>():"
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:337
#, no-wrap
msgid "#include E<lt>stdlib.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:339 build/C/man2/membarrier.2:397
#, no-wrap
msgid "static volatile int a, b;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:347
#, no-wrap
msgid ""
"static void\n"
"fast_path(int *read_b)\n"
"{\n"
"    a = 1;\n"
"    asm volatile (\"mfence\" : : : \"memory\");\n"
"    *read_b = b;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:355
#, no-wrap
msgid ""
"static void\n"
"slow_path(int *read_a)\n"
"{\n"
"    b = 1;\n"
"    asm volatile (\"mfence\" : : : \"memory\");\n"
"    *read_a = a;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:360 build/C/man2/membarrier.2:446
#, no-wrap
msgid ""
"int\n"
"main(int argc, char **argv)\n"
"{\n"
"    int read_a, read_b;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:366 build/C/man2/membarrier.2:455
#, no-wrap
msgid ""
"    /*\n"
"     * Real applications would call fast_path() and slow_path()\n"
"     * from different threads. Call those from main() to keep\n"
"     * this example short.\n"
"     */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:369 build/C/man2/membarrier.2:458
#, no-wrap
msgid ""
"    slow_path(&read_a);\n"
"    fast_path(&read_b);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:374 build/C/man2/membarrier.2:463
#, no-wrap
msgid ""
"    /*\n"
"     * read_b == 0 implies read_a == 1 and\n"
"     * read_a == 0 implies read_b == 1.\n"
"     */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:377 build/C/man2/membarrier.2:466
#, no-wrap
msgid ""
"    if (read_b == 0 && read_a == 0)\n"
"        abort();\n"
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:386
msgid "The code above transformed to use B<membarrier>()  becomes:"
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:395
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/syscall.hE<gt>\n"
"#include E<lt>linux/membarrier.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:403
#, no-wrap
msgid ""
"static int\n"
"membarrier(int cmd, unsigned int flags, int cpu_id)\n"
"{\n"
"    return syscall(__NR_membarrier, cmd, flags, cpu_id);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:408
#, no-wrap
msgid ""
"static int\n"
"init_membarrier(void)\n"
"{\n"
"    int ret;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:410
#, no-wrap
msgid "    /* Check that membarrier() is supported. */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:416
#, no-wrap
msgid ""
"    ret = membarrier(MEMBARRIER_CMD_QUERY, 0, 0);\n"
"    if (ret E<lt> 0) {\n"
"        perror(\"membarrier\");\n"
"        return -1;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:422
#, no-wrap
msgid ""
"    if (!(ret & MEMBARRIER_CMD_GLOBAL)) {\n"
"        fprintf(stderr,\n"
"            \"membarrier does not support MEMBARRIER_CMD_GLOBAL\\en\");\n"
"        return -1;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:425
#, no-wrap
msgid ""
"    return 0;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:433
#, no-wrap
msgid ""
"static void\n"
"fast_path(int *read_b)\n"
"{\n"
"    a = 1;\n"
"    asm volatile (\"\" : : : \"memory\");\n"
"    *read_b = b;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:441
#, no-wrap
msgid ""
"static void\n"
"slow_path(int *read_a)\n"
"{\n"
"    b = 1;\n"
"    membarrier(MEMBARRIER_CMD_GLOBAL, 0, 0);\n"
"    *read_a = a;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/membarrier.2:449
#, no-wrap
msgid ""
"    if (init_membarrier())\n"
"        exit(EXIT_FAILURE);\n"
msgstr ""

#. type: TH
#: build/C/man2/pkey_alloc.2:25
#, no-wrap
msgid "PKEY_ALLOC"
msgstr ""

#. type: Plain text
#: build/C/man2/pkey_alloc.2:28
msgid "pkey_alloc, pkey_free - allocate or free a protection key"
msgstr ""

#. type: Plain text
#: build/C/man2/pkey_alloc.2:35
#, no-wrap
msgid ""
"B<int pkey_alloc(unsigned int >I<flags>B<, unsigned int "
">I<access_rights>B<);>\n"
"B<int pkey_free(int >I<pkey>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pkey_alloc.2:40
msgid ""
"B<pkey_alloc>()  allocates a protection key (pkey) and allows it to be "
"passed to B<pkey_mprotect>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/pkey_alloc.2:45
msgid ""
"The B<pkey_alloc>()  I<flags> is reserved for future use and currently must "
"always be specified as 0."
msgstr ""

#. type: Plain text
#: build/C/man2/pkey_alloc.2:50
msgid ""
"The B<pkey_alloc>()  I<access_rights> argument may contain zero or more "
"disable operations:"
msgstr ""

#. type: TP
#: build/C/man2/pkey_alloc.2:50
#, no-wrap
msgid "B<PKEY_DISABLE_ACCESS>"
msgstr ""

#. type: Plain text
#: build/C/man2/pkey_alloc.2:53
msgid "Disable all data access to memory covered by the returned protection key."
msgstr ""

#. type: TP
#: build/C/man2/pkey_alloc.2:53
#, no-wrap
msgid "B<PKEY_DISABLE_WRITE>"
msgstr ""

#. type: Plain text
#: build/C/man2/pkey_alloc.2:56
msgid "Disable write access to memory covered by the returned protection key."
msgstr ""

#. type: Plain text
#: build/C/man2/pkey_alloc.2:62
msgid ""
"B<pkey_free>()  frees a protection key and makes it available for later "
"allocations.  After a protection key has been freed, it may no longer be "
"used in any protection-key-related operations."
msgstr ""

#. type: Plain text
#: build/C/man2/pkey_alloc.2:70
msgid ""
"An application should not call B<pkey_free>()  on any protection key which "
"has been assigned to an address range by B<pkey_mprotect>(2)  and which is "
"still in use.  The behavior in this case is undefined and may result in an "
"error."
msgstr ""

#. type: Plain text
#: build/C/man2/pkey_alloc.2:80
msgid ""
"On success, B<pkey_alloc>()  returns a positive protection key value.  On "
"success, B<pkey_free>()  returns zero.  On error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/pkey_alloc.2:88
msgid "I<pkey>, I<flags>, or I<access_rights> is invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/pkey_alloc.2:97
msgid ""
"(B<pkey_alloc>())  All protection keys available for the current process "
"have been allocated.  The number of keys available is architecture-specific "
"and implementation-specific and may be reduced by kernel-internal use of "
"certain keys.  There are currently 15 keys available to user programs on "
"x86."
msgstr ""

#. type: Plain text
#: build/C/man2/pkey_alloc.2:103
msgid ""
"This error will also be returned if the processor or operating system does "
"not support protection keys.  Applications should always be prepared to "
"handle this error, since factors outside of the application's control can "
"reduce the number of available pkeys."
msgstr ""

#. type: Plain text
#: build/C/man2/pkey_alloc.2:109
msgid ""
"B<pkey_alloc>()  and B<pkey_free>()  were added to Linux in kernel 4.9; "
"library support was added in glibc 2.27."
msgstr ""

#. type: Plain text
#: build/C/man2/pkey_alloc.2:115
msgid "The B<pkey_alloc>()  and B<pkey_free>()  system calls are Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man2/pkey_alloc.2:123
msgid ""
"B<pkey_alloc>()  is always safe to call regardless of whether or not the "
"operating system supports protection keys.  It can be used in lieu of any "
"other mechanism for detecting pkey support and will simply fail with the "
"error B<ENOSPC> if the operating system has no pkey support."
msgstr ""

#. type: Plain text
#: build/C/man2/pkey_alloc.2:134
msgid ""
"The kernel guarantees that the contents of the hardware rights register "
"(PKRU) will be preserved only for allocated protection keys.  Any time a key "
"is unallocated (either before the first call returning that key from "
"B<pkey_alloc>()  or after it is freed via B<pkey_free>()), the kernel may "
"make arbitrary changes to the parts of the rights register affecting access "
"to that key."
msgstr ""

#. type: Plain text
#: build/C/man2/pkey_alloc.2:137
msgid "See B<pkeys>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/pkey_alloc.2:140
msgid "B<pkey_mprotect>(2), B<pkeys>(7)"
msgstr ""

#. type: TH
#: build/C/man7/pkeys.7:25
#, no-wrap
msgid "PKEYS"
msgstr ""

#. type: Plain text
#: build/C/man7/pkeys.7:28
msgid "pkeys - overview of Memory Protection Keys"
msgstr ""

#. type: Plain text
#: build/C/man7/pkeys.7:37
msgid ""
"Memory Protection Keys (pkeys) are an extension to existing page-based "
"memory permissions.  Normal page permissions using page tables require "
"expensive system calls and TLB invalidations when changing permissions.  "
"Memory Protection Keys provide a mechanism for changing protections without "
"requiring modification of the page tables on every permission change."
msgstr ""

#. type: Plain text
#: build/C/man7/pkeys.7:43
msgid ""
"To use pkeys, software must first \"tag\" a page in the page tables with a "
"pkey.  After this tag is in place, an application only has to change the "
"contents of a register in order to remove write access, or all access to a "
"tagged page."
msgstr ""

#. type: Plain text
#: build/C/man7/pkeys.7:54
msgid ""
"Protection keys work in conjunction with the existing B<PROT_READ>/ "
"B<PROT_WRITE>/ B<PROT_EXEC> permissions passed to system calls such as "
"B<mprotect>(2)  and B<mmap>(2), but always act to further restrict these "
"traditional permission mechanisms."
msgstr ""

#. type: Plain text
#: build/C/man7/pkeys.7:62
msgid ""
"If a process performs an access that violates pkey restrictions, it receives "
"a B<SIGSEGV> signal.  See B<sigaction>(2)  for details of the information "
"available with that signal."
msgstr ""

#. type: Plain text
#: build/C/man7/pkeys.7:72
msgid ""
"To use the pkeys feature, the processor must support it, and the kernel must "
"contain support for the feature on a given processor.  As of early 2016 only "
"future Intel x86 processors are supported, and this hardware supports 16 "
"protection keys in each process.  However, pkey 0 is used as the default "
"key, so a maximum of 15 are available for actual application use.  The "
"default key is assigned to any memory region for which a pkey has not been "
"explicitly assigned via B<pkey_mprotect>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/pkeys.7:80
msgid ""
"Protection keys have the potential to add a layer of security and "
"reliability to applications.  But they have not been primarily designed as a "
"security feature.  For instance, WRPKRU is a completely unprivileged "
"instruction, so pkeys are useless in any case that an attacker controls the "
"PKRU register or can execute arbitrary instructions."
msgstr ""

#. type: Plain text
#: build/C/man7/pkeys.7:99
msgid ""
"Applications should be very careful to ensure that they do not \"leak\" "
"protection keys.  For instance, before calling B<pkey_free>(2), the "
"application should be sure that no memory has that pkey assigned.  If the "
"application left the freed pkey assigned, a future user of that pkey might "
"inadvertently change the permissions of an unrelated data structure, which "
"could impact security or stability.  The kernel currently allows in-use "
"pkeys to have B<pkey_free>(2)  called on them because it would have "
"processor or memory performance implications to perform the additional "
"checks needed to disallow it.  Implementation of the necessary checks is "
"left up to applications.  Applications may implement these checks by "
"searching the I</proc/[pid]/smaps> file for memory regions with the pkey "
"assigned.  Further details can be found in B<proc>(5)."
msgstr ""

#. type: Plain text
#: build/C/man7/pkeys.7:113
msgid ""
"Any application wanting to use protection keys needs to be able to function "
"without them.  They might be unavailable because the hardware that the "
"application runs on does not support them, the kernel code does not contain "
"support, the kernel support has been disabled, or because the keys have all "
"been allocated, perhaps by a library the application is using.  It is "
"recommended that applications wanting to use protection keys should simply "
"call B<pkey_alloc>(2)  and test whether the call succeeds, instead of "
"attempting to detect support for the feature in any other way."
msgstr ""

#. type: Plain text
#: build/C/man7/pkeys.7:126
msgid ""
"Although unnecessary, hardware support for protection keys may be enumerated "
"with the I<cpuid> instruction.  Details of how to do this can be found in "
"the Intel Software Developers Manual.  The kernel performs this enumeration "
"and exposes the information in I</proc/cpuinfo> under the \"flags\" field.  "
"The string \"pku\" in this field indicates hardware support for protection "
"keys and the string \"ospke\" indicates that the kernel contains and has "
"enabled protection keys support."
msgstr ""

#. type: Plain text
#: build/C/man7/pkeys.7:139
msgid ""
"Applications using threads and protection keys should be especially "
"careful.  Threads inherit the protection key rights of the parent at the "
"time of the B<clone>(2), system call.  Applications should either ensure "
"that their own permissions are appropriate for child threads at the time "
"when B<clone>(2)  is called, or ensure that each child thread can perform "
"its own initialization of protection key rights."
msgstr ""

#. type: SS
#: build/C/man7/pkeys.7:139
#, no-wrap
msgid "Signal Handler Behavior"
msgstr ""

#. type: Plain text
#: build/C/man7/pkeys.7:148
msgid ""
"Each time a signal handler is invoked (including nested signals), the thread "
"is temporarily given a new, default set of protection key rights that "
"override the rights from the interrupted context.  This means that "
"applications must re-establish their desired protection key rights upon "
"entering a signal handler if the desired rights differ from the defaults.  "
"The rights of any interrupted context are restored when the signal handler "
"returns."
msgstr ""

#. type: Plain text
#: build/C/man7/pkeys.7:154
msgid ""
"This signal behavior is unusual and is due to the fact that the x86 PKRU "
"register (which stores protection key access rights) is managed with the "
"same hardware mechanism (XSAVE) that manages floating-point registers.  The "
"signal behavior is the same as that of floating-point registers."
msgstr ""

#. type: SS
#: build/C/man7/pkeys.7:154
#, no-wrap
msgid "Protection Keys system calls"
msgstr ""

#. type: Plain text
#: build/C/man7/pkeys.7:160
msgid ""
"The Linux kernel implements the following pkey-related system calls: "
"B<pkey_mprotect>(2), B<pkey_alloc>(2), and B<pkey_free>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/pkeys.7:165
msgid ""
"The Linux pkey system calls are available only if the kernel was configured "
"and built with the B<CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS> option."
msgstr ""

#. type: Plain text
#: build/C/man7/pkeys.7:174
msgid ""
"The program below allocates a page of memory with read and write "
"permissions.  It then writes some data to the memory and successfully reads "
"it back.  After that, it attempts to allocate a protection key and disallows "
"access to the page by using the WRPKRU instruction.  It then tries to access "
"the page, which we now expect to cause a fatal signal to the application."
msgstr ""

#. type: Plain text
#: build/C/man7/pkeys.7:181
#, no-wrap
msgid ""
"$B< ./a.out>\n"
"buffer contains: 73\n"
"about to read buffer again...\n"
"Segmentation fault (core dumped)\n"
msgstr ""

#. type: Plain text
#: build/C/man7/pkeys.7:191
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/syscall.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>sys/mman.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/pkeys.7:198
#, no-wrap
msgid ""
"static inline void\n"
"wrpkru(unsigned int pkru)\n"
"{\n"
"    unsigned int eax = pkru;\n"
"    unsigned int ecx = 0;\n"
"    unsigned int edx = 0;\n"
msgstr ""

#. type: Plain text
#: build/C/man7/pkeys.7:202
#, no-wrap
msgid ""
"    asm volatile(\".byte 0x0f,0x01,0xef\\en\\et\"\n"
"                 : : \"a\" (eax), \"c\" (ecx), \"d\" (edx));\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man7/pkeys.7:209
#, no-wrap
msgid ""
"int\n"
"pkey_set(int pkey, unsigned long rights, unsigned long flags)\n"
"{\n"
"    unsigned int pkru = (rights E<lt>E<lt> (2 * pkey));\n"
"    return wrpkru(pkru);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man7/pkeys.7:216
#, no-wrap
msgid ""
"int\n"
"pkey_mprotect(void *ptr, size_t size, unsigned long orig_prot,\n"
"              unsigned long pkey)\n"
"{\n"
"    return syscall(SYS_pkey_mprotect, ptr, size, orig_prot, pkey);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man7/pkeys.7:222
#, no-wrap
msgid ""
"int\n"
"pkey_alloc(void)\n"
"{\n"
"    return syscall(SYS_pkey_alloc, 0, 0);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man7/pkeys.7:228
#, no-wrap
msgid ""
"int\n"
"pkey_free(unsigned long pkey)\n"
"{\n"
"    return syscall(SYS_pkey_free, pkey);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man7/pkeys.7:231
#, no-wrap
msgid ""
"#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                           } while (0)\n"
msgstr ""

#. type: Plain text
#: build/C/man7/pkeys.7:238
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    int status;\n"
"    int pkey;\n"
"    int *buffer;\n"
msgstr ""

#. type: Plain text
#: build/C/man7/pkeys.7:246
#, no-wrap
msgid ""
"    /*\n"
"     *Allocate one page of memory\n"
"     */\n"
"    buffer = mmap(NULL, getpagesize(), PROT_READ | PROT_WRITE,\n"
"                  MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);\n"
"    if (buffer == MAP_FAILED)\n"
"        errExit(\"mmap\");\n"
msgstr ""

#. type: Plain text
#: build/C/man7/pkeys.7:252
#, no-wrap
msgid ""
"    /*\n"
"     * Put some random data into the page (still OK to touch)\n"
"     */\n"
"    *buffer = __LINE__;\n"
"    printf(\"buffer contains: %d\\en\", *buffer);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/pkeys.7:259
#, no-wrap
msgid ""
"    /*\n"
"     * Allocate a protection key:\n"
"     */\n"
"    pkey = pkey_alloc();\n"
"    if (pkey == -1)\n"
"        errExit(\"pkey_alloc\");\n"
msgstr ""

#. type: Plain text
#: build/C/man7/pkeys.7:267
#, no-wrap
msgid ""
"    /*\n"
"     * Disable access to any memory with \"pkey\" set,\n"
"     * even though there is none right now\n"
"     */\n"
"    status = pkey_set(pkey, PKEY_DISABLE_ACCESS, 0);\n"
"    if (status)\n"
"        errExit(\"pkey_set\");\n"
msgstr ""

#. type: Plain text
#: build/C/man7/pkeys.7:277
#, no-wrap
msgid ""
"    /*\n"
"     * Set the protection key on \"buffer\".\n"
"     * Note that it is still read/write as far as mprotect() is\n"
"     * concerned and the previous pkey_set() overrides it.\n"
"     */\n"
"    status = pkey_mprotect(buffer, getpagesize(),\n"
"                           PROT_READ | PROT_WRITE, pkey);\n"
"    if (status == -1)\n"
"        errExit(\"pkey_mprotect\");\n"
msgstr ""

#. type: Plain text
#: build/C/man7/pkeys.7:279
#, no-wrap
msgid "    printf(\"about to read buffer again...\\en\");\n"
msgstr ""

#. type: Plain text
#: build/C/man7/pkeys.7:284
#, no-wrap
msgid ""
"    /*\n"
"     * This will crash, because we have disallowed access\n"
"     */\n"
"    printf(\"buffer contains: %d\\en\", *buffer);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/pkeys.7:288
#, no-wrap
msgid ""
"    status = pkey_free(pkey);\n"
"    if (status == -1)\n"
"        errExit(\"pkey_free\");\n"
msgstr ""

#. type: Plain text
#: build/C/man7/pkeys.7:297
msgid "B<pkey_alloc>(2), B<pkey_free>(2), B<pkey_mprotect>(2), B<sigaction>(2)"
msgstr ""
