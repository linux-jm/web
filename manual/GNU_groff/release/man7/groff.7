'\"t
.\"nakano: もともと書いてないですが、これが必要な man system が多いので。
.\" st                        -*- nroff -*-
.ig
groff.7

This file is part of groff, the GNU roff type-setting system.

Copyright (C) 2000 Free Software Foundation, Inc.
written by Bernd Warken <bwarken@mayn.de>

Last update: 17 May 2000

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with the
Invariant Sections being this .ig-section and AUTHOR, with no
Front-Cover Texts, and with no Back-Cover Texts.

A copy of the Free Documentation License is included as a file called
FDL in the main directory of the groff source package.
..
.\" Japanese Version Copyright (c) 2001 UCHIDA Norihiro all rights reserved.
.\" Translated Thu Feb 15 2001 by UCHIDA Norihiro <KY4N-UCD@asahi-net.or.jp>
.
.\" --------------------------------------------------------------------
.\" Setup
.\" --------------------------------------------------------------------
.
.if n \{\
.  mso tmac.tty-char
.  ftr CR R
.  ftr CI I
.  ftr CB B
.\}
.
.if '\*[.T]'dvi' \{\
.  ftr CB CW
.\}
.
.\" a comment macro which does nothing
.de c
..
.
.\" a tab string
.ds t "\t
.
.eo
.
.c text lines in macro definitions or bracketed sections \{...\}
.de text
.  if 1 \&\$*\&
..
.
.de option
.  ds @tmp@ \f(CB\$1\fP
.  shift 1
.  text \*[@tmp@]\$*
.  rm @tmp@
..
.
.als shellcommand option
.
.c --------- characters ---------
.
.de character
.  ds @tmp@ \f(CB\$1\fP
.  shift
.  text \*[@tmp@]\$*
.  rm @tmp@
..
.
.de 'char
.  ds @tmp@ `\f(CB\$1\fP'
.  shift
.  text \*[@tmp@]\$*
.  rm @tmp@
..
.
.de ''char
.  ds @tmp@ \(lq\f(CB\$1\fP\(rq
.  shift
.  text \*[@tmp@]\$*
.  rm @tmp@
..
.
.c --------- requests ---------
.
.c request synopsis
.de REQ
.  ds @tmp@ \&\$1
.  shift 1
.  IP "\f(CB\&\*[@tmp@] \fP\f(CI\&\$*\fP" 10n
.  rm @tmp@
..
.
.de request
.  ds @tmp@ \f(CB\$1\fP
.  shift 1
.  text \*[@tmp@]\$*
.  rm @tmp@
..
.
.c --------- macro or function arguments ---------
.
.de argument
.  ds @tmp@ \f(CI\$1\fP
.  shift 1
.  while (\n[.$] >= 2) \{\
.    as @tmp@ \/\f(CR\$1\fP\f(CI\,\$2\fP
.    shift 2
.  \}
.  if \n[.$] .as @tmp@ \/\f(CR\$1\fP
.  text \*[@tmp@]
.  rm @tmp@
..
.
.c argument followed by a numerical expression
.de argterm
.  ds @tmp@ \f(CI\$1\fP\|\f(CR\$2\fP
.  shift 2
.  text \*[@tmp@]\$*
.  rm @tmp@
..
.
.c --------- numerical elements ---------
.
.de number
.  ds @tmp@ \f(CR\$1\fP
.  shift 1
.  text \*[@tmp@]\$*
.  rm @tmp@
..
.
.de prefixednumber
.  ds @tmp@ \&\$1\ \f(CR\$2\fP
.  shift 2
.  text \*[@tmp@]\$*
.  rm @tmp@
..
.
.als scaleindicator request
.
.de scalednumber
.  ds @tmp@ \f(CR\$1\fP\f(CB\$2\fP
.  shift 2
.  text \*[@tmp@]\$*
.  rm @tmp@
..
.
.de operator
.  ds @tmp@ `\f(CB\$1\fP'
.  shift
.  text \*[@tmp@]\$*
.  rm @tmp@
..
.
.c --------- escape sequences ---------
.
.de esc[arg]
.  ds @tmp@ \f(CB\(rs\$1[\fP\f(CI\$2\fP\f(CB]\fP
.  shift 2
.  text \*[@tmp@]\$*
.  rm @tmp@
..
.
.de esc(arg
.  ds @tmp@ \f(CB\(rs\$1(\fP\f(CI\$2\fP
.  shift 2
.  text \*[@tmp@]\$*
.  rm @tmp@
..
.
.de escarg
.  ds @tmp@ \f(CB\(rs\$1\fP\f(CI\$2\fP
.  shift 2
.  text \*[@tmp@]\$*
.  rm @tmp@
..
.
.de esc[]
.  ds @tmp@ \f(CB\(rs[\fP\f(CI\$1\fP\f(CB]\fP
.  shift
.  text \*[@tmp@]\$*
.  rm @tmp@
..
.
.de esc(
.  ds @tmp@ \f(CB\(rs(\fP\f(CI\$1\fP
.  shift
.  text \*[@tmp@]\$*
.  rm @tmp@
..
.
.de esc
.  ds @tmp@ \f(CB\(rs\$1\fP
.  shift
.  text \*[@tmp@]\$*
.  rm @tmp@
..
.
.de (esc
.  ds @tmp@ \f(CB\(rs(\$1\fP
.  shift
.  text \*[@tmp@]\$*
.  rm @tmp@
..
.
.de [esc]
.  ds @tmp@ \f(CB\(rs[\$1]\fP
.  shift
.  text \*[@tmp@]\$*
.  rm @tmp@
..
.
.c escape sequence synopsis
.de ESC
.  ds @tmp@ \&\$1
.  shift 1
.  IP "\f(CB\(rs\&\*[@tmp@]\fP\f(CI\&\$*\fP"
.  rm @tmp@
..
.
.c synopsis for escape sequences with a long name
.de ESC[]
.  ds @arg1@ \&\$1
.  ds @arg2@ \&\$2
.  shift 2
.  IP "\f(CB\(rs\&\*[@arg1@][\fP\f(CI\&\*[@arg2@]\fP\f(CB]\&\$*\fP"
.  rm @arg1@
.  rm @arg2@
..
.
.c synopsis escape sequence with quoted argument
.  de ESCq
.  ds @tmp@ \&\$1
.  shift 1
.  IP "\f(CB\(rs\&\*[@tmp@]'\fP\f(CI\h'-0.2m'\$*\/\fP\f(CB'\fP"
.  rm @tmp@
..
.
.c synopsis for 2-escapes (special characters)
.de ESc
.  ds @tmp@ \$1
.  TP 14n
.  text \f(CB\(rs(\&\*[@tmp@]\ \ \ \fP\fR\(\*[@tmp@]\fP
.  shift 1
.  text \$*
.  rm @tmp@
..
.
.c --------- registers ---------
.
.c synopsis for registers
.de REG
.  TP 10n
.  text \&\f(CR\(rsn[\fP\f(CB\$1\fP\f(CR]\fP
.  shift 1
.if \n[.$] \&\$*
..
.
.als register request
.
.c --------- warnings ---------
.
.als warning request
.
.c description of warnings
.de Warning
.  ne (2v + 1)
.  TP 12n
.  text \f(CB\$1\fP
.  text \f(CI\$2\fP
.  br
..
.
.ec
.
.\" --------------------------------------------------------------------
.\" Title
.\" --------------------------------------------------------------------
.
.TH GROFF 7 "24 May 2000" "Groff Version 1.16.1"
.SH 名前
groff \- GNU groff 言語の簡易リファレンス
.
.\" --------------------------------------------------------------------
.SH 説明
.\" --------------------------------------------------------------------
.I groff
とは
.I GNU roff
の事であり、roff 組版システムのフリーな実装である。
groff システムの概観と背景については
.BR roff (7)
を参照のこと。
.LP
このドキュメントでは、groff で使われる定義済みの roff 言語要素を
簡潔に説明する。
伝統的な機能と groff の拡張との双方を取り扱う。
.LP
歴史的に、
.I roff 言語
は
.I troff
と呼ばれていた。
.I groff
は伝統的なシステムと互換性があり、固有の拡張も提供している。
そのため GNU 版では、
.IR roff ,
.IR troff ,
.I gorff 言語
という用語は同義語として扱われている。
しかし、どちらかといえば
.I troff
は伝統的な側面を表すときに、
.I groff
は GNU の拡張を強調するときに、
.I roff
は一般的な言語を意味するときに使われる傾向がある。
.LP
このファイルは完全なドキュメントである
.I groff
.BR info (1)
ファイルの簡易版である。info ファイルには、より詳細で、実情に近く、
分かりやすい情報が含まれている。
.LP
groff ドキュメントを書くための通常の文法は比較的易しいが、
roff 言語を拡張する書き方は多少難しいかもしれない。
.LP
roff 言語は行指向である。
行には、制御行とテキスト行の 2 種類しかない。
制御行は制御文字で始まり、制御文字とはデフォルトではピリオド
.''char .
かシングルクォート
.''char '
である。それ以外で始まる行はすべてテキスト行である。
.LP
.B 制御行
はコマンドを表し、コマンドは引き数をとる場合もある。
これらの行は次のような文法となる。
まず先行する制御文字に続いてコマンド名、それから必要なら引き数がそれぞれ空白で
区切られる。例をあげると以下のとおり。
.RS
.LP
\&\.command_name arg1 arg2
.RE
.LP
インデント用に、スペース文字・タブ文字を制御文字とコマンド名との間にいくつでも
挿入できる。しかし、制御文字は必ず行の先頭に置かなければならない。
.LP
.B テキスト行
は、表示される部分を表す。
これらの行は、エスケープシーケンスによって修飾することができる。
バックスラッシュ
.'char \(rs
からはじまる文字列がエスケープシーケンスとして認識される。
これらは行や単語の一部に含まれ、整形要素となったり関数となったりする。
エスケープシーケンスには引き数をとるものもあり、
引き数はシングルクォート
.''char '
で区切られる。
他には、開き括弧
.'char (
で始まる長さ規定で制御されるものや、カギ括弧
.'char [
と
.'char ]
で括られるものがある。
.\"nakano: この辺私もよくわかってません、ごめんなさい。
.LP
roff 言語は、マクロのような言語の拡張を記述するための柔軟な手段を提供している。
マクロ定義を処理するときには、roff システムは
.B コピーモード
と呼ばれる特別な処理モードへと切り替わる。
.LP
コピーモードのふるまいは実に巧妙である。
しかし、安全な使用法を保証するいくつかのルールがある。
.IP 1.
表示するためのバックスラッシュは
.esc e
と表記しなければならない。
より正確に言うなら、
.esc e
は現在のエスケープ文字を意味する。
バックスラッシュのグリフが必要ならば、
.esc (rs
を用いること。
.IP 2.
すべてのバックスラッシュを 2 回繰り返しておく。
.IP 3.
すべてのテキスト行を特別な非空白文字である
.esc &
で開始する。
.LP
このやり方は一番効率的なコードができるというわけではないが、当初の目的は達成できる。
より良い方法のためには、groff info ファイルと
.BR groff_tmac (5)
を参照してほしい。
.LP
roff ソースファイルを読むのは簡単である。
単に、すべてのマクロ定義部分にある 2 重になったバックスラッシュを 1 つに
置き換えるだけである。
.
.\" --------------------------------------------------------------------
.SH GROFF 要素
.\" --------------------------------------------------------------------
roff 言語の要素はテキストファイルに整形情報を追加する。
基本的な要素は定義済みのコマンドと変数であり、これらがあるので
roff は成熟したプログラミング言語となっている。
.LP
roff コマンドには 2 種類あり、可能ならば引き数をとることもできる。
.B リクエスト
は、ドット
.'char .
か
.''char '
で始まる 1 行に記述される。
一方、
.B エスケープシーケンス
は行埋め込み式の関数であり、バックスラッシュ
.'char \(rs
で始まる単語整形要素である。
.LP
リクエスト
.request .de
を使うと、ユーザは自分専用の整形コマンドを定義することができる。
これらのコマンドは
.B マクロ
と呼ばれるが、リクエストとまったく同じように使われる。
マクロパッケージは groff 言語で記述された定義済みマクロの集まりである。
ユーザ独自のエスケープシーケンスを作る試みは非常に制限されており、
特殊文字のマップができる程度である。
.LP
groff 言語は、それぞれ使い方の異なる変数を何種類か提供している。
定義済みの変数もあるが、ユーザは独自の変数を定義することもできる。
.LP
.B 文字列
変数は文字のシーケンスを格納する。これらはリクエスト
.request .ds
によって値を設定し、エスケープシーケンス
.esc *
によって値が取り出される。
.LP
.B レジスタ
変数は、数値、単位付きの数字、そして場合によっては文字列のようなオブジェクトを
格納できる。
これらは、リクエスト
.request .nr
によって値を設定し、エスケープシーケンス
.esc n
によって値が取り出される。
.LP
.B 環境
には、ユーザが後から再利用するために、行の長さやフォントサイズといった
グローバルな整形用パラメータを一時的に格納することができる。
これは、リクエスト
.request .ev
によって行われる。
.LP
.B フォント
は、名前でも内部的な番号ででも指定できる。
現在のフォントは、リクエスト
.request .ft
かエスケープシーケンス
.esc f
によって選ぶことができる。
デバイスごとに固有のフォントがあるが、以下のフォントはすべてのデバイスで
有効である。
.B R
は標準のローマン体フォントである。
.B B
はローマン体の
.B ボールド表示
である。
.B I
は
.I イタリック体
フォントである。
イタリックはどのデバイスでも使用できるが、
テキストデバイスではアンダーライン付きの
ローマン体フォントで表示される。
グラフィック出力デバイスでは、上記のフォントに対応する固定幅フォントもある。
それぞれ、
.BR CR ・ CB ・ CR
である。
テキストデバイスでは、どのみちすべての文字は固定幅になる。
.LP
さらに、いくつかの拡張された roff 要素がある。
.B ディバージョン
は後で使うための情報をマクロ内部に格納する。
.B トラップ
は位置条件であり、ページ先頭からの特定の行番号とか、
ディバージョンや入力における特定の行番号などのかたちで指定される。
いくつかの動作を、条件を満したときに自動的に実行されるように指示することができる。
.\" uchida diversion の定訳は？
.LP
より詳細な情報は groff info ファイルに示されている。
.
.\" --------------------------------------------------------------------
.SH 制御文字
.\" --------------------------------------------------------------------
ある条件下において、特別な制御機能を持つ文字がいくつかある。
.TP
.character .
ドットは、行の先頭にある場合と、以下のリクエスト (
.request .if ,
.request .ie ,
.request .el ,
.request .while )
の後にある場合には特別な意味を持つ。
これらの場合では、ドットはリクエスト (またはマクロ) の開始を意味する
制御文字となる。
この特殊な働きは
.esc .
のようにエスケープすることで抑制できる。
リクエスト
.request .cc
を用いると、この制御文字を別の文字に割り当てることができる。
この時、ドット
.'char .
は制御文字ではなくなる。
.IP ""
他の場所にある場合は、ドットは単にドット文字そのものを意味する。
テキストの段落においては、各センテンスを 1 行に書くと都合が良い。
.TP
.character '
シングルクォートには 2 つの制御機能がある。
行の先頭にある場合と、条件つきリクエストに続く場合には、非改行制御文字を意味する。
つまり、この文字はドットと同じようにリクエストの開始を意味するが、
それに加えて改行を行わないという特性がある。
リクエスト
.request .c2
を用いると、この非改行制御文字を別の文字に割り当てることができる。
.IP ""
2 つめの機能としては、エスケープシーケンスにおいて引き数の
区切り文字としてよく使用される (ただし、引き数の一部になっていない
文字の対であればどれでも区切り文字として機能する)。
.\"nakano: ここちょっとわかりませんでした...
これら以外の場所にある時は、シングルクォート文字またはアポストロフィ文字を意味する。
groff はこの文字の表示用の表現手段としてエスケープシーケンス
.esc (cq
を提供している。
.TP
\fB"\fR
ダブルクォートは、リクエストやマクロの引き数を括る時に使用される。
エスケープされたダブルクォート
.B \e"
はコメントの開始を意味する。
それ以外の場合は、特別な機能はない。
groff はこの文字の表示用の表現手段としてエスケープシーケンス
.esc (dq
を提供している。
.TP
.character \(rs
バックスラッシュは、通常はエスケープシーケンスの開始を意味する
(リスエスト
.request ec
によって変更することができる)。
表示用のエスケープ文字は、エスケープシーケンス
.esc e
であり、バックスラッシュのグリフは
.esc (rs
で得られる。
.TP
.character (
開き括弧は、エスケープシーケンスの内部で特別な意味を持つ。
ちょうど 2 文字からなるエスケープシーケンス名や引き数の開始を意味する。
groff では、この動作は \f(CB[]\fP の組で置き換えることができる。
.TP
.character [
開き角括弧は、groff の場合エスケープシーケンス内部で特別な意味を持つ。
これは、長いエスケープシーケンス名や長いエスケープシーケンス引き数の
開始を意味する。
それ以外では、例えばマクロ呼び出しなどでも特別な作用はない。
.TP
.character ]
閉じ角括弧は groff のエスケープシーケンスにおいて特別な意味を持つ。
これは、長いエスケープシーケンス名や長いエスケープシーケンス引き数の終了を
意味する。
それ以外では、特別な作用はない。
.TP
\f(CIspace\fP
空白 (space) 文字は機能的な働きしか持たない文字である。
これは、リクエストやマクロの引き数の区切り文字であり、
テキスト行における単語の区切りである。
また、groff の水平方向の語間計算の作用対象となる。
定義された空白幅を得るには、
.'char "\(rs\ "
(エスケープ文字とそれに続く空白文字)、
.'char "\(rs|" 、
.'char "\(rs^" 、
.'char "\(rsh"
といったエスケープシーケンスを用いればよい。
.IP \f(CInewline\fP
テキストの段落においては、改行 (newline) は空白文字と同じような作用をする。
行が連結しているものとみなすには、改行をエスケープすることで指定できる。
つまり、行の最後の文字としてバックスラッシュ
.'char \(rs
を記述する。
.IP \f(CItab\fP
テキスト中にタブ文字があれば、インタプリタは次の定義済みのタブ位置へと
水平方向のインデントを作りだす。
タブ位置の調整には洗練されたインターフェースがある。
.
.\" --------------------------------------------------------------------
.SH 数式
.\" --------------------------------------------------------------------
.B 数値
とは、単位指定子の付加されていない
符号付き整数・符号なし整数・浮動小数点実数、
およびそれに単位指定子の付加されたものである。
.B 単位指定子
とは、計測単位を表す 1 文字の略語である。
単位が後置された数値は、サイズに関する値である。
デフォルトでは数値は単位指定を持たない。つまり、単なる数字である。
.LP
roff 言語は、以下のような単位を定義している。
.LP
.na
.nh
.TS
center, tab(@);
LfCB Lw(4i).
c@センチメートル
i@インチ
P@パイカ\ \(eq\ 1/6\ インチ
p@ポイント\ \(eq\ 1/72\ インチ
m@T{
Em\ \(eq\ \fRフォントサイズ (文字 `\f(CRm\fR` の幅)
T}
M@\f(CREm\fR の 100 倍
n@En\ \(eq\ Em/2
u@\fR実際の出力デバイス用の基本単位
v@\fR基本単位による行送り幅
z@T{
スケールされたポイント数\ \(eq\ 1/\f(CIsizescale\fR
(フォントの \fIDESC\fR ファイルで定義されている)
T}
.TE
.LP
.ad
.hy
.B 数式
は、上記の数値と算術演算子
.operator + ,
.operator \- ,
.operator * ,
.operator / ,
.operator %
.RI ( 剰余 )、
比較演算子
.operator ==
(
.operator =
と同じ),
.operator <= ,
.operator >= ,
.operator < ,
.operator > 、
論理演算子
.operator &
.RI ( 論理積 ),
.operator :
.RI ( 論理和 ),
.operator !
.RI ( 論理否定 )、
および括弧
.operator ( ,
.operator )
の組み合わせである。
.LP
さらに、
.I grof
には数式に以下の演算子が追加された:
.LP
.na
.nh
.TS
center, tab(@);
LfCB Lw(4i).
e1\f(CB>?\fPe2@\fCIe1\fP と \f(CIe2\fP の最大値
e1\f(CB<?\fPe2@\f(CIe1\fP と \f(CIe2\fP の最小値
\f(CB(\fPc\f(CB;\fPe\f(CB)@T{
\f(CIc\fP をデフォルトの単位指定子として \f(CIe\fP を評価する
.\" UCHIDA ？？？
T}
.TE
.LP
.ad
.hy
詳細は groff の info ファイルを参照のこと。
.
.\" --------------------------------------------------------------------
.SH 条件式
.\" --------------------------------------------------------------------
.B 条件式
は、リクエスト
.request .if ,
.request .ie ,
.request .while
によって生じる条件判定である。
以下の表に、いろいろな条件式を示す。
.LP
.na
.nh
.TS
center, tab(@);
LfCB Lw(4i).
\f(CIN\fP@T{
数式 \f(CIN\fP は値が 0 より大きければ真を返す。
T}
!\f(CIN\fP@T{
\f(CIN\fP の値が 0 以下であれば真。
T}
\&'\f(CIs1\fP'\f(CIs2\fP'@T{
文字列\ \f(CIs1\fP と文字列\ \f(CIs2\fP が等しければ真。
T}
!'\f(CIs1\fP'\f(CIs2\fP'@T{
文字列\ \f(CIs1\fP と文字列\ \f(CIs2\fP が等しくなければ真。
T}
c\f(CIch@T{
文字\ \f(CIch\fP が有効であれば真。
T}
d\f(CIname@T{
\f(CIname\fP という文字列・マクロ・ディバージョン・リクエストが存在すれば真。
T}
e@現在のページ番号が偶数なら真。
o@現在のページ番号が奇数なら真。
n@フォーマッタが \fBnroff\fP なら真。
r\f(CIreg@T{
\f(CIreg\fP というレジスタがあれば真。
T}
t@フォーマッタが \fBtroff\fP なら真。
.TE
.LP
.ad
.hy
.
.\" --------------------------------------------------------------------
.SH リクエスト
.\" --------------------------------------------------------------------
このセクションでは、定義済みのリクエストについての短いリファレンスを
提供する。
groff では、リクエストとマクロの名前は任意の長さをとることができる。
長い名前に対して括弧で括ったりマークを付けたりする必要はない。
.LP
たいていのリクエストは、ひとつまたは複数の引き数を持つ。
引き数は空白文字で区切られる (タブ文字は不可)。
その長さや数に制限はない。
引き数はダブルクォートで括ることができる。
これは、引き数に空白文字が含まれるときにとても便利である。
例えば、
\f(CI"arg with space"\fP
はひとつの引き数を意味する。
.LP
いくつかのリクエストは、動作を修正するためのオプション引き数を持つ。
それらの詳細はここでは説明しない。
詳細は、groff の info ファイルを参照のこと。
.LP
後述するリクエストの説明では、多くの引き数の名前は意味を表すように選んである。
下に挙げた用語についてはその意味を示す。
.LP
.na
.nh
.TS
center, tab(@);
LfCI Lw(4i).
c@1 文字を意味する。
font@T{
名前または番号で指定されたフォント。
T}
anything@T{
行末までのすべての文字、または \f(CB\(rs{\fP と \f(CB\(rs}\fP で
括られた文字。
T}
n@T{
整数値を返す数式。
T}
N@T{
符号付きまたは符号なしの任意の数式。
T}
\(+-N@T{
以下に説明するように符号に応じて 3 つの意味がある。
T}
.TE
.LP
.ad
.hy
.argument \(+-N
で定義された式が
.operator +
符号で始まる場合は、式の結果の値は関連するすでに存在するリクエストに固有の
値に対して加算される。例えば、数値レジスタに追加される。
式が
.operator -
で始まる場合は、式の値がリクエストの値から減算される。
.LP
符号が無い場合は、
.argument N
は既存の値を直接置き変える。
負の値を指定する場合には、0 を前置するか負数を括弧で括ればよい。
.
.\" --------------------------------------------------------------------
.SS リクエストの簡易リファレンス
.\" --------------------------------------------------------------------
.PD 0
.
.REQ .
空行 (無視される)。ドキュメントの整形に便利。
.
.REQ .\(rs" anything
行全体がコメントとなる。
.
.REQ .ab string
.argument string
を標準エラーに出力しプログラムを終了する。
.
.REQ .ad
現在の位置ぞろえモードで出力行の位置ぞろえを開始する。
.
.REQ .ad c
位置ぞろえモード
.argument c
で行を開始する。
(\f(CIc\fP\f(CR\|\^\(eq\|l,r,b,n\fP)
.
.REQ .af register c
フォーマット
.argument c
をレジスタ
.argument register
に割り当てる。
(\f(CIc\fP\f(CR\|\^\(eq\|l,i,I,a,A\fP)
.
.REQ .aln alias register
レジスタ
.argument register
の別名
.argument alias
を作成する。
.
.REQ .als alias object
リクエストや文字列、マクロ、ディバージョンなどのオブジェクト
.argument object
の別名
.argument alias
を作成する。
.
.REQ .am macro
.request ..
が呼ばれるまでをマクロ
.argument macro
に追加する。
.
.REQ .am macro end
.request .end
が呼ばれるまでをマクロ
.argument macro
に追加する。
.
.REQ .as stringvar anything
文字列
.argument anything
を文字列変数
.argument stringvar
に追加する。
.
.REQ .asciify diversion
ディバージョン
.argument diversion
に含まれる特殊 ASCII 文字を整形しない。
.
.REQ .backtrace
入力のバックトレースを標準エラー出力に出力する。
.
.REQ .bd font N
フォント
.argument font
を
.argterm N -1
単位に強調する。
.
.REQ .bd S font N
現在のフォントが
.argument font
のときにスペシャルフォント
.argument S
で強調する。
.\"nakano やってみないと判らないのかもですが、この辺いまいちピンときませんね..
.
.REQ .bp
現在のページを終了して新しいページを開始する。
.
.REQ .bp \(+-N
現在のページを終了する。次のページ番号を
.argument \(+-N
にする。
.
.REQ .blm macro
空白行を意味するマクロを
.argument macro
に設定する。
.
.REQ .br
改行。
.
.REQ .break
while ループを終了する。
.
.REQ .c2
非改行制御文字を
.''char '
に戻す。
.
.REQ .c2 c
非改行制御文字を
.argument c
に設定する。
.
.REQ .cc
制御文字を
.'char .
に戻す。
.
.REQ .cc c
制御文字を
.argument c
に設定する。
.
.REQ .ce
次の入力行をセンタリングする。
.
.REQ .ce N
以下の
.argument N
行の入力行をセンタリングする。
.
.REQ .cf filename
ファイル
.argument filename
の内容をそのまま標準出力またはディバージョンへコピーする。
.
.REQ .cflags mode c1 c2 ...
.argument mode
のモード番号に従って、文字
.argument c1 ,
.argument c2 ,
.argument ...
を扱う。
.
.REQ .ch trap N
.argument trap
の場所を
.argument N
に変更する。
.
.REQ .char c anything
文字列
.argument anything
を文字
.argument c
と定義する。
.
.REQ .chop object
マクロ、文字列、ディバージョンなどの
.argument object
の最後の 1 文字をとりのぞく。
.
.REQ .close stream
ストリーム
.argument stream
をクローズする。
.
.REQ .continue
while ループにおける現在の繰り返し処理を終了する。
.
.REQ .cp
互換モードを有効にする。
.
.REQ .cp N
.I N
が 0 なら互換モードを無効にする。それ以外なら有効にする。
.
.REQ .cs font N M
フォント
.argument font
の固定ピッチ文字幅を
.argterm N /36
に設定する。(単位は全角文字幅
.argument M )
.
.REQ .cu N
nroff の場合の連続アンダーライン。
troff のリクエスト
.request .ul
に相当する。
.
.REQ .da macro
マクロ
.argument macro
を転換・追加する。
.\"nakano: divert?
.
.REQ .de macro
リクエスト
.request ..
が呼ばれるまでマクロ
.argument macro
を定義 (再定義) する。
.
.REQ .de macro end
リクエスト
.request .end
が呼ばれるまでマクロ
.argument macro
を定義 (再定義) する。
.
.REQ .di
現在のディバージョンを終了する。
.
.REQ .di macro
マクロ
.argument macro
にディバージョンする。
.
.REQ .do name
リクエスト
.request .name
を互換モードを有効にして解釈する。
.
.REQ .ds stringvar anything
文字列変数
.argument stringvar
に文字列
.argument anything
を設定する。
.
.REQ .dt N trap
ディバージョンのトラップ位置を
.argument N
に設定する。
(デフォルトの単位指定子は
.scaleindicator v )
.
.REQ .ec
エスケープ文字を
.'char \(rs
に戻す。
.
.REQ .ec c
エスケープ文字を
.argument c
に設定する。
.
.REQ .el anything
if-else リクエスト (\c
.argument .ie )
の else ブロック。
.
.REQ .em macro
入力が終わった後にマクロ
.argument macro
を実行する。
.
.REQ .eo
エスケープ文字の処理を抑制する。
.
.REQ .ev
直前の環境に変更する。
.
.REQ .ev env
環境の番号または名前
.argument env
をプッシュして切り替える。
.
.REQ .evc env
環境
.argument env
の内容を現在の環境にコピーする。
環境のプッシュまたはポップは行わない。
.
.REQ .ex
roff の処理を終了する。
.
.REQ .fam name
現在のフォントファミリーを
.argument name
に設定する。
.
.REQ .fc
フィールド機構を無効にする。
.\" UCHIDA ???
.
.REQ .fc a
フィールド区切りを
.argument a
に設定する。パディング文字をスペースにする。
.
.REQ .fc a b
フィールド区切りを
.argument a
に、パディング文字を
.argument b
に設定する。
.
.REQ .fi
出力行を埋める。
.
.REQ .fl
出力バッファをフラッシュする。
.
.REQ .fp n font
位置
.argument n
にフォント
.argument font
をマウントする。
.
.REQ .fp n internal external
位置
.argument n
にフォントを長い名前
.argument external
から短い名前
.argument internal
にマウントする。
.\"nakano: フォントのマウントとは?
.
.REQ .fspecial font s1 s2...
現在のフォントが
.argument font
の場合に、
.argument s1 ,
.argument s2 ,
.argument ...
をスペシャルフォントにする。
.
.REQ .ft
直前のフォントに戻す。
リクエスト
.request \(rsfP
と同じ。
.
.REQ .ft font
フォント名または番号
.argument font
に変更する。
エスケープシーケンス
.esc[arg] f font
と同じ。
.
.REQ .ftr font1 font2
フォント
.argument font1
をフォント
.argument font2
に変換する。
.
.REQ .hc
追加したハイフネーション指定文字を削除する。
.
.REQ .hc c
ハイフネーション指定文字\ \c
.argument c
を追加する。
.
.REQ .hcode c1 code1 c2 code2 ...
文字
.argument c1
のハイフネーションコードを
.argument code1
に、文字
.argument c2
のコードを
.argument code2
のように設定する。
.
.REQ .hla lang
現在のハイフネーション言語を
.argument lang
に設定する。
.
.REQ .hlm n
ハイフンされた行の最大連続数を
.argument n
に設定する。
.
.REQ .hpf file
ハイフネーションのパターンをファイル
.argument file
から読み込む。
.
.REQ .hw words
例外的なハイフネーションをする単語のリストを
.argument words
で指定する。
.
.REQ .hy N
ハイフネーションモードを
.argument N
に変更する。
.
.REQ .hym n
ハイフネーションのマージンを
.argument n
に設定する。
(デフォルトの単位指定子は\ \c
.scaleindicator m )
.
.REQ .hys n
ハイフネーションのスペースを
.argument n
に設定する。
.
.REQ .ie cond anything
条件式
.argument cond
が真ならば
.argument anything
を処理する。偽の場合はリクエスト
.request .el
へ移動する。
.
.REQ .if cond anything
条件式
.argument cond
が真ならば
.argument anything
を処理する。偽の場合は何もしない。
.
.REQ .ig
リクエスト
.request ..
が呼ばれるまでテキストを無視する。
.
.REQ .ig end
リクエスト
.request .end
が呼ばれるまでテキストを無視する。
.
.REQ .in
直前のインデント量に変更する。
.
.REQ .in \(+-N
引き数
.argument \(+-N
に従ってインデント量を変更する。
(デフォルトの単位指定子は\ \c
.scaleindicator m )
.
.REQ .it N trap
入力行のカウントトラップを位置
.argument N
に設定する。
.
.REQ .kern
pairwise kerning を有効にする。
.\" UCHIDA ???
.\"nakano 整形アルゴリズムの名前みたいです。TeX から採った、って言ってるけど...
.
.REQ .kern n
.argument n
が 0 ならば pairwise kerning を無効にする。0 でなければ
有効にする。
.
.REQ .lc
先頭の繰り返し文字を取り除く。
.
.REQ .lc c
先頭の繰り返し文字を\ \c
.argument c
に設定する。
.
.REQ .length register anything
文字列
.argument anything
の文字列長をレジスタ
.argument register
に書き込む。
.
.REQ .lf N file
入力する行数を
.argument N
に、ファイル名を
.argument file
に設定する。
.
.REQ .lg N
引き数
.argument N
が 0 より大きければリガチャ (合字) モードにする。
.
.REQ .ll
直前の行幅に変更する。
.
.REQ .ll \(+-N
行幅を引き数
.argument \(+-N
に従って設定する。
(デフォルトの設定は
.scalednumber 6.5 i
で、単位指定子は
.scaleindicator m )
.
.REQ .ls
追加の内部行スキップ量を直前の値に変更する。
.
.REQ .ls N
追加の内部行スキップ量を
.argument N
に設定する。
つまり、テキストの出力行それぞれの後に
.argument N -1
行の空白行を挿入する。
.
.REQ .lt \(+-N
タイトルの長さ。(デフォルトの単位指定子は\ \c
.scaleindicator m )
.
.REQ .mc
マージンの文字を無効にする。
.
.REQ .mc c
それぞれのテキスト行の後と右側マージンの間に文字
.argument c
を出力する。
.
.REQ .mc c N
マージン文字を
.argument c
に、右側マージンからの距離を
.argument N
に設定する。(デフォルトの単位指定子は\ \c
.scaleindicator m )
.
.REQ .mk register
現在の垂直位置を
.argument register
にマークする。
.
.REQ .mso file
リクエスト .so と同じだが、tmac ディレクトリにある
.I file
も検索される。
.
.REQ .na
出力行の位置ぞろえを行わない。
.
.REQ .ne
1 行分の行送りが必要。
.
.REQ .ne N
.argument N
行分の行送りが必要。(デフォルトの単位指定子は\ \c
.scaleindicator v )
.
.REQ .nf
出力行にフィルタリングや位置ぞろえを行わない。
.
.REQ .nh
ハイフネーションをしない。
.
.REQ .nm
行番号モードを無効にする。
.
.REQ .nm \(+-N M S I
行番号モードの、行番号、行番号出力間隔、空白、インデントを設定する。
.
.REQ .nn
次の行に行番号をつけない。
.
.REQ .nn N
次の
.argument N
行に行番号をつけない。
.
.REQ .nr register \(+-N M
レジスタの値を、インクリメント値
.argument M
で
.argument \(+-N
に設定・変更する。
.
.REQ .nroff
内部条件式
.B n
を真に、
.B t
を偽にする。
.
.REQ .ns
空白なしモードにする。
.
.REQ .nx filename
次のファイル。
.
.REQ .open stream filename
ファイル
.register filename
を書き込みモードでオープンし、ストリーム名
.register stream
に関連付ける。
.
.REQ .opena stream filename
リクエスト
.request .open
と同じだが、追加モードでファイルをオープンする。
.
.REQ .os
リクエスト
.request .sv
で指定された行送り量を出力する。
.
.REQ .pc
ページ番号文字を
.'char %
に戻す。
.
.REQ .pc c
ページ番号文字を設定する。
.
.REQ .pi program
プログラム
.argument program
に出力をパイプする。(nroff のみ)
.
.REQ .pl
ページ長をデフォルトの
.scalednumber 11 i
に設定する。
現在のページ長はレジスタ
.register .p
に格納されている。
.
.REQ .pl \(+-N
ページ長を
.argument \(+-N
に変更する。(デフォルトの単位指定子は\ \c
.scaleindicator v )
.
.REQ .pm
マクロ名とサイズを出力する。(サイズは 1 ブロック 128 バイトのブロック数)
.
.REQ ".pm t"
マクロ全体のサイズだけを出力する。(サイズは 1 ブロック 128 バイトのブロック数)
.
.REQ .pn \(+-N
次のページ番号を
.argument N
に設定する。
.
.REQ .pnr
現在定義されている数値レジスタの名前と内容を標準エラー出力に出力する。
.
.REQ .po
直前のページオフセットに変更する。現在のページオフセットはレジスタ
.register .o
に格納されている。
.
.REQ .po \(+-N
ページオフセットを
.argument N
に設定する。
.
.REQ .ps
直前のポイントサイズに戻す。
.
.REQ .ps \(+-N
ポイントサイズを指定する。エスケープシーケンス
.esc[arg] s \(+-N
と同じ。
.
.REQ .psbb filename
PostScript 画像
.argument filename
のための矩形領域を得る。
.
.REQ .pso command
リクエスト
.request .so
と同様だが、
.argument command
の標準出力から入力する。
.
.REQ .ptr
すべてのトラップの名前と位置を標準エラー出力に出力する。
(入力行のトラップとディバージョンのトラップは含まれない)
.
.REQ .rchar c1 c2...
文字定義
.argument c1 ,
.argument c2 ,
.argument ...
を削除する。
.
.REQ .rd prompt
挿入を読み込む。
.
.REQ .rj n
次の
.argument n
行の入力行を右寄せする。
.
.REQ .rm name
.argument name
で指定されたリクエスト、マクロ、文字列を削除する。
.
.REQ .rn old new
.argument old
で指定されたリクエスト、マクロ、文字列の名前を
.argument new
に変更する。
.
.REQ .rnn reg1 reg2
レジスタ名
.argument reg1
を
.argument reg2
に変更する。
.
.REQ .rr register
レジスタ
.argument register
を削除する。
.
.REQ .rs
空白をもとに戻す。つまり空白なしモードを無効にする。
.
.REQ .rt \(+-N
マークされた垂直位置まで大文字を返す。
(デフォルトの単位指定子は\ \c
.scaleindicator v )
.
.REQ .shc
ハイフン文字を
.esc (hy
に戻す。
.
.REQ .shc c
ハイフン文字を
.argument c
に設定する。
.
.REQ .shift n
マクロにおいて、引き数を位置
.argument n
にシフトする。
.
.REQ .so filename
ソースファイルをインクルードする。
.
.REQ .sp
1 行スキップする。
.
.REQ .sp N
.argument N
の行送りを挿入する。
.argument N
の符号によって上下方向が決まる。
(デフォルトの単位指定子は
.scaleindicator v )
.
.REQ .special s1 s2 ...
フォント
.argument s1 ,
.argument s2 ,
等はスペシャルフォントであり、現在のフォントにない文字をこれらから検索する。
.
.REQ .ss N
空白文字のサイズを
.argument N /12
に設定する。単位は現在のフォントの空白幅。
.
.REQ .ss N M
空白文字のサイズを
.argument N /12
に、文の空白サイズを
.argument M /12
に設定する。単位は現在のフォントの空白幅 (\f(CR\(eq1/3 em\fP)
.
.REQ .sty n style
位置
.argument n
のフォントをスタイル
.argument style
に関連付ける。
.
.REQ .substring register n1 n2
レジスタ
.argument register
の文字列の中の部分文字列
.argument n1
を
.argument n2
に置き換える。
.
.REQ .sv
行送り量を
.scalednumber 1 v
に設定する。
.
.REQ .sv N
リクエスト
.os
で出力される空白行の送り量を
.argument N
に設定する。
.
.REQ .sy command-line
プログラム
.argument command-line
を実行する。
.
.REQ ".ta T" N
タブ位置を
.argument N
の倍数に設定する。
(デフォルトの単位指定子は\ \c
.scaleindicator m )
.
.REQ .ta n1 n2 ... nn \f(CBT\fP r1 r2 ... rn
位置
.argument n1 ,
.argument n2 ,
\&... ,
.argument nn
のタブ位置をそれぞれ
.argument nn + r1 ,
.argument nn + r2 ,
\&...
.argument nn + rn
に、さらにそれ以降を
.argument nn + rn + r1 ,
.argument nn + rn + r2 ,
\&...
.argument nn + rn + rn
のように設定する。
.
.\".REQ .tar
.\"Restore internally saved tab positions.
.\".
.\".REQ .tas
.\"Save tab positions internally.
.
.REQ .tc
タブ繰り返し文字を削除する。
.
.REQ .tc c
タブ繰り返し文字を\ \c
.argument c
に設定する。
.
.REQ .ti \(+-N
次の行を一時的にインデントする。
(デフォルトの単位指定子は\ \c
.scaleindicator m )
.
.REQ .tkf font s1 n1 s2 n2
フォント
.argument font
のトラックカーニングを有効にする。
.
.REQ .tl \f(CB'\fPleft\f(CB'\fPcenter\f(CB'\fPright\f(CB'\fP
3 つの部位をもつタイトル。
.
.REQ .trf filename
ファイル
.argument filename
の内容をそのまま出力する。
.
.REQ .tm anything
.argument anything
をターミナル (UNIX の標準的なメッセージ出力先) に出力する。
.
.REQ .tr abcd....
出力で
.argument a
を
.argument b
に、
.argument c
を
.argument d
に、のように変換する。
.
.REQ .trnt abcd....
リクエスト
.request .tr
と同じだが、
.esc !
によってディバージョンへと出力されるテキストは変換されない。
.
.REQ .troff
内部条件式
.B t
を真に、
.B n
を偽に設定する。
.
.REQ .uf font
アンダーライン付きのフォントを
.argument font
に設定する。
(リクエスト
.request .ul
で切り替わる)
.
.REQ .ul N
入力行を
.argument N
行、アンダーライン付きにする。(troff では イタリック体になる)
.
.REQ .vpt n
.argument n
が 0 でなければ垂直位置のトラップを有効にする。
0 ならば無効にする。
.
.REQ .vs
直前の行送り幅に変更する。
.
.REQ .vs N
行送りの基準となる間隔を
.argument N
に設定する。
デフォルト値は
.scalednumber 12 p
である。
.
.REQ .warn n
警告コードを
.argument n
に設定する。
.
.REQ .wh N trap
局所的なトラップを設定する。負の値の場合はページ末尾からになる。
.
.REQ .while cond anything
条件式
.argument cond
が真ならば
.argument anything
を入力として許可する。
.
.REQ .write stream anything
ストリーム
.argument stream
へ
.argument anything
を書き込む。
.
.PD
.LP
これらの基本的な groff リクエストの他にも、マクロの呼び出しがある。
これらはマクロパッケージ (概要は
.BR roff (7)
を参照) やプリプロセッサ由来のものである。
.LP
プリプロセッサマクロは認識しやすい。
これらは独特のマクロの対で括られている。
.LP
.TS
box, center, tab (@);
c | c | c
CfCB | CfCB | CfCB.
プリプロセッサ@開始マクロ@終了マクロ
=
eqn@.PS@.PE
grap@.G1@.G2
grn@.GS@.GE
pic@.PS@.PE
refer@.R1@.R2
soelim@\fIなし@\fIなし
tbl@.TS@.TE
.TE
.LP
.
.\" --------------------------------------------------------------------
.SH エスケープシーケンス
.\" --------------------------------------------------------------------
.
エスケープシーケンスは行内の言語要素であり、通常はバックスラッシュ
.'char \(rs
から始まりエスケープ名が続く。引き数が必要なものもある。
入力の処理は、エスケープされた文字や引き数の直後に連続し、
区切り文字はない。
したがって、エスケープ名や引き数の終了を決定する方法が必要である。
.LP
これには、名前 (エスケープ名や変数名を含む引き数)
をカギ括弧の対で括ったり (例:
.esc[] name )、
定数の引き数 (数値式や複数の文字)
アポストロフィ (ASCII コード 0x27) で括ったり (例:
.IR 'constant' )
する 。
.LP
エスケープ名には短い名前の省略形がある。
2 文字のエスケープ名は開き括弧で指定される。
例として
.esc( xy
のようになり、閉じ括弧は必要ない。
そして、特別な文字である
.'char [
と
.'char (
以外の、すべての 1 文字の名前は
.esc \fP\f(CIc
のようにマーカーなしで指定することができる。
.LP
長さが
.number 1
の定数の引き数もアポストロフィのマーカーを省略できるが、
2 文字の場合にはエスケープ名と同じような省略指定はできない。
.LP
1 文字のエスケープシーケンスは主に内部関数やシステムに関連した機能であり、
.esc( ""
で構成される 2 文字名は roff システムで定義済みの特殊文字に使われる。
.esc[] name
のような 2 文字より長い名前の場合は、たいていユーザが定義したものである。
(リクエスト
.request .char
を参照)
.
.\" --------------------------------------------------------------------
.SS 1 文字のエスケープシーケンス
.\" --------------------------------------------------------------------
.
.PD 0
.
.\" --------- comments ---------
.
.ESC \fB"\fP
. "
コメントの開始。行末までのすべてが無視される。
.
.ESC #
行末の改行文字までが無視される。
コピーモードとして処理される。
.B \(rs"
と似ているが行末の改行文字までが無視される。
.
.\" --------- strings ---------
.
.ESC * s
文字列を 1 文字の名前の文字列変数
.argument s
に格納する。
.
.ESC *( st
文字列を 2 文字の名前の文字列変数
.argument st
に格納する。
.
.ESC[] * stringvar
文字列を任意の長さの名前の文字列変数
.argument stringvar
に格納する。
.
.\" --------- macro arguments ---------
.
.ESC $0
現在呼びだされているマクロの名前。リクエスト
.request .als
でマクロに 1 つ以上の名前をつけることができる。
.
.ESC $ x
.argument x
番目のマクロの引き数。
.argument x
は 1 から 9 までの数値。
.
.ESC $( xy
2 桁の数値
.argument xy
で指定されるマクロの引き数。
.
.ESC[] $ nexp
.argument nexp
番目のマクロの引き数。
ここで、
.argument nexp
は 1 以上の整数を返す数式。
.
.ESC $*
あるマクロにおける、すべての引き数をスペースで区切って連結した文字列。
.
.ESC $@
あるマクロにおける、すべての引き数それぞれをダブルクォートで括り、
スペースで区切って連結した文字列。
.
.\" --------- escaped characters ---------
.
.ESC \(rs
1 文字のバックスラッシュに短縮される。
コピーモード時のエスケープ文字による処理を抑制するのに使われる。
表示可能なバックスラッシュには
.esc e
を使用する。
.
.ESC '
鋭音記号 \(aa 。
.esc( aa
と同じ。エスケープされない場合は、アポストロフィ、右引用記号、シングルクォート
(ASCII コード 0x27) となる。
.
.ESC `
抑音記号 \(ga 。
.esc( ga
と同じ。エスケープされない場合は、左引用記号、バッククォート
(ASCII コード 0x60) となる。
.
.ESC \-
現在のフォントにおける \- 符号。
.
.ESC .
処理されないドット (ピリオド)。行頭の場合のみ。
.
.ESC %
デフォルトの省略可能なハイフン文字。
.
.ESC !
透過行指定子。
.
.ESC ? anything\fB?\fP
ディバージョンにおいて、
.argument anything
をディバージョンにそのまま埋め込む。
.argument anything
はコピーモードで読み込まれる。
エスケープシーケンス
.esc !
と
.esc ?
も参照。
.
.
.\" --------- spacing ---------
.
.ESC \& space
連結されない空白文字 (改行も行われない)。
.
.ESC 0
数字の幅。
.
.ESC |
l/6\ em の狭い空白文字。nroff では幅ゼロ。
.
.ESC ^
1/12\ em の狭い空白文字。nroff では幅ゼロ。
.
.ESC &
表示されないゼロ幅の文字。
.
.ESC )
.esc &
と似ているが、cflags リクエストで宣言した文字のようにふるまい、
文の終りを明示するために使用される。
.
.ESC /
先行する文字との幅を増加し、この文字の後に続く文字がローマン体であるならば
この文字と後に続く文字の間の空白は修正される。
.
.ESC ,
後に続く文字との幅を調整し、この文字に先行する文字がローマン体であるならば
この文字と先行する文字の間の空白は修正される。
.
.ESC ~
改行の入らない空白で、行が調整されたときには通常の単語間の空白のように
引き延ばされる。
.
.ESC \& newline
改行を無視して行を連結する。
.
.\" --------- structuring ---------
.
.ESC {
条件入力の開始。
.
.ESC }
条件入力の終了。
.
.\" --------- longer escape names ---------
.
.ESC ( st
2 文字の名前
.argument st
の特殊文字。
.B 特殊文字
のセクションを参照。
.
.ESC[] \& name
任意の長さの名前
.argument name
の名前付き文字。
.
.\" --------- alphabetical escapes ---------
.
.ESC a
処理されない先行文字。
.
.ESCq A anything
.argument anything
が文字列・マクロ・ディバージョン・レジスタ・環境・フォントのどれか
の名前として有効であるならば 1 を、そうでなければ 0 を返す。
.
.ESCq b abc...
カギ括弧を構築する関数。
.
.ESC c
テキスト処理を中断する。
.
.ESCq C char
.argument char
で呼ばれる文字。
.esc[] char
と同じだが、他の roff システムと互換性がある。
.
.ESC d
1/2 em だけ行送りをする (nroff では 1/2 行)。
.
.ESCq D charseq
.argument charseq
の文字で定義されたグラフィック要素を描画する。
詳細は groff info ファイルを参照のこと。
.
.ESC e
現在のエスケープ文字の表示可能なバージョン。
.
.ESC E
エスケープ文字と同じだが、コピーモードでは処理されない。
.
.ESC f F
フォントを 1 文字名または 1 桁の数値
.argument F
で指定されたものに変更する。
.
.ESC f( fo
フォントを 2 文字名または 2 桁の数値
.argument fo
で指定されたものに変更する。
.
.ESC[] f font
フォントを任意の長さの名前または数式
.argument font
で指定されたものに変更する。
.
.ESC[] g reg
リクエスト
.request .af
に最適な
.argument reg
という名前のレジスタのフォーマットを返す。
別の形式では、
.esc(arg g xy
と
.escarg g x
となる。
.
.ESCq h N
局所的な水平移動。右側へ
.argument N
だけ移動する。(負数のときは左側へ移動する)
.
.ESCq H N
現在のフォントの高さを
.argument N
に設定する。
.
.ESC[] k reg
任意の長さの名前
.argument reg
を持つレジスタの水平入力位置をマークする。
別の形式では、
.esc(arg k xy
と
.escarg k x
となる。
.
.ESCq l Nc
水平線描画関数。(文字
.argument c
を用いることも可能)
.
.ESCq L Nc
垂直線描画関数。(文字
.argument c
を用いることも可能)
.
.ESC n r
1 文字の名前
.argument r
のレジスタ変数に格納されている数値。
.
.ESC n( re
2 文字の名前
.argument re
のレジスタ変数に格納されている数値。
.
.ESC[] n reg
任意の長さの名前
.argument reg
のレジスタ変数に格納されている数値。
.
.ESCq N n
現在のフォントで、コード
.argument n
で指定された文字を出力する。スペシャルフォントは検索されない。
リクエスト
.request .char
が使っているフォントで文字を追加するときに有用。
.
.ESCq o abc...
文字
.argument a ,
.argument b ,
.argument c
等を 2 度打ちする。
.
.ESC p
改行して出力行を引き延す。
.
.ESC r
垂直方向に 1\ em 逆戻りする。(nroff では 1 行)
.
.ESCq R name \(+-n
リクエスト
.request .nr
.argument name
.argument \(+-n
と同じ。
.
.ESC[] s \(+-N
ポイントサイズを
.I N
に設定する。別の書式では
.BI \(rss \(+- [ N ]\c
,
.BI \(rss' \(+-N '\c
,
.BI \(rss \(+- ' N '\c
,
.esc(arg s \(+-xy ,
.BI \(rss \(+- ( xy\c
,
.escarg s \(+-x
となることに注意。リクエスト
.request .ps
と同じ。
.
.ESCq S N
.argument N
度傾いた出力をする。
.
.ESC t
解釈されない水平タブ。
.
.ESC u
垂直方向に 1/2 em 逆戻りする。(nroff では 1/2 行)
.
.ESCq v N
局所的な垂直移動。
.argument N
だけ下げる。(負数なら上げる)
.
.ESC[] V env
環境
.argument env
の内容。
別の書式では、
.esc(arg V xy
と
.escarg V x
となる。
.
.ESCq w string
文字列
.argument string
の幅。
.
.ESCq x N
行送り関数 (負数なら前へ、正数なら後へ)。
.
.ESCq X string
.argument string
をデバイス制御関数として出力する。
.
.ESC[] Y name
文字列変数かマクロ
.argumentg name
をデバイス制御関数として処理しないように出力する。
別の書式では、
.esc(arg Y xy
と
.escarg Y x
となる。
.
.ESC z c
.argument c
をゼロ幅 (空白なし) で出力する。
.
.ESCq Z anything
.argument anything
を出力し、水平・垂直位置を元に戻す。
.argument anything
はタブや先頭文字を含まない。
.PD
.LP
エスケープシーケンス
.esc e ,
.esc . ,
.esc \fB"\fP \fR,
.esc $ ,
.esc * ,
.esc a ,
.esc n ,
.esc t ,
.esc g ,
.escarg \& newline
はコピーモードで処理される。
.LP
.esc (
と
.esc [
で始まるエスケープシーケンスは 1 文字のエスケープシーケンスを意味しない。
2 文字またはそれ以上の長さのエスケープ名の開始を表す。
.LP
バックスラッシュの後に、定義済みエスケープシーケンスを構成しない文字が続いた
場合は、バックスラッシュは単に無視されて、その後の文字はそのものを意味する。
.
.\" --------------------------------------------------------------------
.SS 特殊文字
.\" --------------------------------------------------------------------
一般的な特殊文字は、エスケープシーケンス
.(esc \fP\f(CIxy
という形式ですでに定義されている。
これらのいくつかは通常のフォントにも含まれるが、ほとんどはスペシャルフォント
でないと表示ができない。以下に重要なグリフを示す。完全なリストについては
.BR groff_char (7)
で参照できる。
.RS
.LP
.PD 0
.
.ESc bu 中黒
.ESc co 著作権記号
.ESc ct セント記号 (通貨)
.ESc dd 2 重ダガー
.ESc de 度記号
.ESc dg ダガー
.ESc em 全角ダッシュ
.ESc hy ハイフン
.ESc rg 登録記号
.ESc sc セクション記号
.ESc ul アンダーライン文字
.ESc == 等号
.ESc >= 以上
.ESc <= 以下
.ESc != 不等号
.ESc -> 右矢印
.ESc <- 左矢印
.ESc +- プラスマイナス記号
.PD
.RE
.
.\" --------------------------------------------------------------------
.SH レジスタ
.\" --------------------------------------------------------------------
レジスタとは値を格納する変数である。
groff では、ほとんどのレジスタは数値を格納するが (上記セクション
.B 数式
を参照)、いくつかは文字列を格納することができる。
.LP
それぞれのレジスタには名前が与えられる。
任意のレジスタをリクエスト
.request .nr
.argument registrer
によって定義・設定することができる。
.LP
レジスタに格納した値は、エスケープシーケンス
.esc n
によってとりだすことができる。
.LP
便利な定義済みのレジスタがある。
以下では、レジスタの説明を明確にするために、
.argument name
という表記法は
.register name
という名前のレジスタを参照する場合に使用する。
.esc n[]
という修飾はレジスタ名の一部ではないことに注意してほしい。
.
.\" --------------------------------------------------------------------
.SS 読み出し専用のレジスタ
.\" --------------------------------------------------------------------
以下のレジスタは定義済みの値を持っており、ユーザが値を変更することはできない
(通常は、ドットで始まるレジスタは読み出し専用である)。
たいていのものは、現在の設定情報やリクエスト呼び出しの結果が格納されている。
.LP
.PD 0
.REG .$ 現在のマクロの引き数の数。
.REG .A
.B troff
にオプション
.B \-A
が使用されていたら
.number 1
が設定される。
.B nroff
では常に
.number 1
になる。
.REG .H 利用可能な水平解像度 (基本単位)。
.REG .T
オプション
.B \-T
が使用されていたら
.number 1
が設定される。
.REG .V 利用可能な垂直解像度 (基本単位)。
.REG .a
.escarg x 'N'
などで用いられる行送り幅。
.REG .C 互換モードが有効になっていれば 1、そうでなければ 0。
.REG .c 現在の入力行番号。
.REG .cdp
現在の環境に最後に追加された文字の深さ。
文字がベースラインから下に出ていれば正数になる。
.REG .ce
リクエスト
.request .ce
によって設定された、センタリングされる残りの行の行数。
.REG .cht
現在の環境に最後に追加された文字の高さ。
文字がベースラインの上方に広がっていれば正数になる。
.REG .csk
現在の環境に最後に追加された文字の傾き。
文字の傾きとは、文字の上に置かれるアクセント記号の中心が、文字の中心から
どれだけ右にずれているかである。
.REG .d
現在のディバージョンにおける現在の垂直位置。レジスタ
.register nl
と同じ。
.REG .ev 現在の環境の名前または数値 (文字列値)。
.REG .f 現在のフォント番号。
.REG .fam 現在のフォントファミリー (文字列値)。
.REG .fp 次の自由なフォント位置の数。
.REG .g
GNU troff では常に 1 を返す。groff のもとで実行されているのかを
マクロがテストするときに使われる。
.REG .h 現在のページまたはディバージョンにおけるテキストベースラインの高水準位置。
.REG .hla
リクエスト
.B .hla
で設定された現在のハイフネーション言語。
.REG .hlc
直前にある連続するハイフネーションされた行の行数。
.REG .hlm
連続するハイフネーションされた行が許される最大の行数。
リクエスト
.request .hlm
で設定される。
.REG .hy
現在のハイフネーションフラグ (リクエスト
.request .hy
で設定される)。
.REG .hym
現在のハイフネーションマージン (リクエスト
.request .hym
で設定される)。
.REG .hys
現在のハイフネーション間隔 (リクエスト
.request .hys
で設定される)。
.REG .i 現在のインデント量。
.REG .in 現在の出力行に適用されるインデント量。
.REG .kern
1 対のカーニングが有効なら
.number 1
を返す。そうでなければ
.number 0
を返す。
.REG .l 現在の行幅。
.REG .lg
現在のリガチャ (合字) モード (リクエスト
.request .lg
で設定される)。
.REG .ll 現在の出力行に適用される行幅。
.REG .lt
タイトル行の長さ (リクエスト
.request .lt
で設定される)。
.REG .n 直前の出力行の部分の長さ。
.REG .ne
トラップの原因となった直前のリクエスト
.request .ne
に必要なスペースの量。
レジスタ
.register .trunc
と一緒に使用すると便利。
.REG .o 現在のページのオフセット。
.REG .p 現在のページの長さ。
.REG .pn
次のページのページ番号。リクエスト
.request .pn
によって設定された値か、現在のページ番号に 1 を追加した値になる。
.REG .ps スケールポイントにおける現在のポイントサイズ。
.REG .psr スケールポイントにおける直前に要求されたポイントサイズ。
.REG .rj
リクエスト
.request rj
によって設定された右寄せされた行の行数。
.REG .s 小数で表わした現在のポイントサイズ。
.REG .sr
小数で表わした直前に要求されたポイントサイズ (文字列値)。
.REG .t 次のトラップまでの距離。
.REG .tabs
リクエスト
.request .ta
の引き数として使用するのに便利な、現在のタブ設定の文字列表現。
.REG .trunc
もっとも最近の垂直位置トラップによって切り詰められた垂直スペースの量。
または、リクエスト
.request .ne
によるトラップがひきおこされた場合は、そのリクエストによって生じた
垂直移動量をさらにマイナスした値。
別の言い方をすれば、トラップが発生した時点での、
トラップが起きなかったとした場合の垂直位置と実際の垂直位置との差を
表している。
リクエスト
.register .ne
と一緒に使用すると便利。
.REG .ss
リクエスト
.request .ss
の第 1 引き数によって設定されたパラメータの値。
.REG .sss
リクエスト
.request .ss
の第 2 引き数によって設定されたパラメータの値。
.REG .u 行連結モードのときは 1、そうでなければ 0。
.REG .v 現在の垂直行送り量。
.REG .vpt
垂直位置トラップが有効なら
.number 1
、そうでなければ
.number 0
になる。
.REG .w 直前の文字の幅。
.REG .warn
現在の有効になっている警告のコード値の総和。
.REG .x メジャーバージョン番号。
.REG .y マイナーバージョン番号。
.REG .Y groff のリビジョン番号。
.REG .z 現在のディバージョンの名前。
.REG llx
指定された PostScript 画像の左下 x 座標 (PostScript 単位)。
リクエスト
.request .psbb
により設定される。
.REG lly
指定された PostScript 画像の左下 y 座標 (PostScript 単位)。
リクエスト
.request .psbb
により設定される。
.REG rsb
レジスタ
.register sb
と似ているが、文字の高さと深さを考慮している。
.REG rst
レジスタ
.register st
と似ているが、文字の高さと深さを考慮している。
.REG sb
文字列のベースラインより下の深さ (幅関数
.esc w
により生成される)。
.REG skw
.esc w
の引き数において、直前の文字の中心からの右スキップ幅。
.REG ssc
添字の前の直前の文字に追加される水平移動量 (負の値も可能)。
幅関数
.esc w
により生成される。
.REG st
文字列のベースラインより上の高さ (幅関数
.esc w
により生成される)。
.REG urx
指定された PostScript 画像の右上 x 座標 (PostScript 単位)。
リクエスト
.request .psbb
により設定される。
.REG ury
指定された PostScript 画像の右上 y 座標 (PostScript 単位)。
リクエスト
.request .psbb
により設定される。
.PD
.
.\" --------------------------------------------------------------------
.SS 書き込み可能レジスタ
.\" --------------------------------------------------------------------
以下のレジスタはユーザによって読み書きが可能である。
これらは定義済みのデフォルト値を持っているが、ドキュメントを
カスタマイズするために変更することができる。
.LP
.PD 0
.REG % 現在のページ番号。
.REG c. 現在の入力行番号。
.REG ct 文字タイプ (幅関数
.esc w
によって設定される)。
.REG dl 直前に終了したディバージョンの最大幅。
.REG dw 現在の曜日 (1-7)。
.REG dy 現在の日 (1-31)。
.REG hp 現在の入力行における水平位置。
.REG ln 出力行番号。
.REG mo 現在の月 (1-12)。
.REG nl 直前に出力したテキストのベースラインの垂直位置。
.REG slimit
0 より大きければ、入力スタックにあるオブジェクトの最大数。
0 以下であれば制限はない。つまり、仮想メモリを使いはたすまで再帰を続けることができる。
.REG systat
直前のリクエスト
.request .sy
により実行された
.I system()
関数の戻り値。
.REG year 現在の年 (2000 年問題なし)。
.REG yr
現在の年から 1900 を引いた値。2000 年問題を避けるにはレジスタ
.register year
を代りに用いること。
.PD
.
.\" --------------------------------------------------------------------
.SH 警告
.\" --------------------------------------------------------------------
groff によって生成される警告はすべて名前とコード番号が与えられている。
コード番号は 2 の累乗で、単一の int 型変数でビットエンコードができるように
なっている。名前のほうも、警告のグループで参照することができる。
.LP
警告名は
.option \-w
と
.option \-W
オプションで使うことができる。
警告コード番号は、リクエスト
.request .warn
とレジスタ
.esc[arg] n warn
で使うことができる。
.LP
.PD 0
.Warning all group
.warning di ,
.warning mac ,
.warning reg
以外のすべての警告。
伝統的なマクロパッケージのすべての警告をカバーしている。
.Warning break 4
行連結モードにおいて、1 行の長さと比べて改行を入れられない行の長さが短い場合。
この警告はデフォルトで有効。
.Warning char 1
存在しない文字が含まれている。この警告はデフォルトで有効。
.Warning delim 8
閉じ区切り記号がない、または開き区切り記号と一致しない。
.Warning di 256
現在のディバージョンがない時に、引き数のない
.request .di
や
.request .da
のリクエストが使用された。
.Warning el 16
一致するリクエスト
.request .ie
がないのにリクエスト
.request .el
が使用された。
.Warning escape 32768
認識されないエスケープシーケンスが使用された。エスケープ文字は無視される。
.Warning font 131072
存在しないフォントが使用された。
この警告はデフォルトで有効。
.Warning ig 262144
リクエスト
.request \.ig
で無視されるテキスト中に不正なエスケープがある。
無視されるテキスト外でこれが発生する場合はエラーとなる。
.Warning mac 512
定義されていない文字列・マクロ・ディバージョンが使用された。
自動的に空であるものと扱われる。通常は、名前ひとつに対してひとつの警告となる。
.Warning missing 8192
省略できない引き数が指定されていない。
.Warning input 16384
不正な入力文字。
.Warning number 2
不正な数式。この警告はデフォルトで有効。
.Warning range 64
範囲外の引き数が指定された。
.Warning reg 1024
定義されていない数値レジスタが使用された。自動的に値として 0 が定義される。
通常は、名前ひとつに対してひとつの警告となる。
.Warning right-brace 4096
数値が期待される場所に
.esc }
が使用された。
.Warning scale 32
意味のない単位指定子が指定された。
.Warning space 65536
リクエストやマクロと引き数の間に空白文字がない。したがって自動的に定義される
マクロはない。この警告はデフォルトで有効。
また、この警告は互換モードでは決して発生しない。
.Warning syntax 128
数式であいまいな文法が使用された。
.Warning tab 2048
タブ文字が不正に使用された (クォートされていないマクロの引き数のところや
数値が要求されているところに使用された)。
.Warning w group
すべての警告。
.PD
.LP
.TS
tab(@), box, expand;
c c c | c  c  c | c  c  c
R RI CB | R RI CB | R RI CB.
ビット@コード@警告@ビット@コード@警告@ビット@コード@警告
_
0@1@char@8@256@di@16@65536@space
1@2@number@9@512@mac@17@131072@font
2@4@break@10@1024@reg@18@262144@ig
3@8@delim@11@2048@tab
4@16@el@12@4096@right-brace
5@32@scale@13@8192@missing
6@64@range@14@16384@input
7@128@syntax@15@32768@escape
.TE
.LP
.
.\" --------------------------------------------------------------------
.SH 互換性
.\" --------------------------------------------------------------------
.I groff
は
.B 互換モード
を提供しており、古典的な
.troff
や他の roff の実装のために書かれた roff コードをきちんと処理することができる。
.LP
互換モードはコマンドラインオプション
.option \-C
によって有効にでき、さらにリクエスト
.request .cp
によって無効にすることができる。
互換モードが有効のときは、
数値レジスタ
.esc(arg n .C
に
.number 1
が設定される。無効のときは
.number 0
になる。
.LP
GNU の長い名前に対する設計ではいくつか非互換な部分が生じるので、
この機能が必要とされた。
.I 古典的な troff
は
.IP
.B
\&.dsabcd
.LP
を、文字列
.B ab
に内容
.B cd
を定義するとみなして処理する。
通常は、
.I groff
はこれを
.request dsabcd
という名前のマクロの呼び出しとみなして処理する。
.LP
また、
.I 古典的な troff
は
.esc *[
や
.esc n[
を
.register [
という文字列レジスタまたは数値レジスタへの参照とみなして処理する。
しかし、
.I GNU のネイティブモード
では通常は長い名前の開始とみなして処理する。
.LP
.I 互換モード
では、groff はこれらを伝統的な方法で処理するようになる。
そのかわり、長い名前は認識されない。
.LP
一方で、
.I GNU ネイティブモード
での groff は以下のエスケープシーケンス (
.esc e ,
.esc | ,
.esc ^ ,
.esc & ,
.esc } ,
.esc { ,
.esc "\ " (space),
.esc ' ,
.esc ` ,
.esc - ,
.esc _ ,
.esc ! ,
.esc % ,
.esc c )
は文字列・マクロ・ディバージョン・数値レジスタ・フォント・環境の名前としては
使用できない。しかし、
.I 古典的な troff
は可能である。
.LP
小数のポイントサイズは顕著な非互換性の原因となる。
.I 古典的な troff
では、リクエスト
.request .ps
は単位指定子を無視するので
.RS
.LP
.B .ps\ 10u
.RE
.LP
はポイントサイズを 10 ポイントに設定する。しかし、groff のネイティブモード
ではポイントサイズは 10 スケールポイントに設定される。
.LP
.I groff
モードでは、整形されていない入力文字と整形された出力文字の間には根本的な
差異がある。
出力文字がどのように出力されるのかということに影響するものはすべて文字と
一緒に格納される。ある出力文字が構築されると、それ以降にどんなリクエストが
実行されてももはや影響されることはない。これは、以下のようなリクエストの
場合も含まれる。
.request .bd ,
.request .cs ,
.request .tkf ,
.request .tr ,
.request .fp
.LP
通常は、現在の出力行に文字を追加する前に、出力文字は入力文字ごとに順次
構築されていく。
実は、マクロ・ディバージョン・文字列はすべて同じタイプのオブジェクトである。
これらは入力文字と出力文字の取り得る組み合わせのリストを含んでいる。
.LP
出力文字は、(マクロ処理の対象となる) 入力文字のような動作はしない。
出力文字は、それの構築元になった、入力文字が持っていたような特別な属性は
いっさい引き継がない。
以下の例で詳しく説明する。
.LP
.RS
.nf
.ft B
\&.di x
\(rs\(rs\(rs\(rs
\&.br
\&.di
\&.x
.ft
.fi
.RE
.LP
.I GNU モード
では、この例は
.esc \(rs
のように出力されるだろう。
入力のバックスラッシュの対
.'char \(rs\(rs
はひとつのバックスラッシュ
.'char \(rs
に変換される。そして、結果として出力されるバックスラッシュは
これらが参照された時でもエスケープ文字として処理されることはない。
.LP
.I 古典的な troff
では、これらは参照された時にエスケープ文字として処理されるので、最後には
ひとつのバックスラッシュ
.'char \(rs
が出力されるだろう。
.LP
.'char \(rs
一文字を表示する正しい方法は、エスケープシーケンス
.esc e
を使用することである。このやりかたなら、ディバージョンの中で使用にかかわらず
常に現在のエスケープ文字をひとつだけ出力するだろう。
これは、GNU モードと互換モードのどちらでも動作するはずである。
.LP
ディバージョンにエスケープシーケンスを格納する場合は、ディバージョンが参照されるごとに
エスケープシーケンスが処理される。
伝統的な
.esc !
の透過出力や新しい
.esc ?
のエスケープシーケンスを使用するべきである。
.\" --------------------------------------------------------------------
.SH バグ
.\" --------------------------------------------------------------------
現在、groff システムのドキュメントは変化と進化の途上にある。
一時的にドキュメント同士でささやかな矛盾点が見られるだろう。
.LP
.B 警告
セクションは
.BR troff (1)
に基づいている。
.
.\" --------------------------------------------------------------------
.SH 著者
.\" --------------------------------------------------------------------
このドキュメントは groff (GNU roff パッケージ) の一部である。
Bernd Warken <bwarken@mayn.de> によって記述された。
.LP
このドキュメントは FDL (GNU Free Documentation License) のバージョン 1.1 
以降の元に配布される。あなたのシステムにも FDL のコピーがあるはずである。
以下でもオンラインで参照できる。
.RS
.LP
.IR http://www.gnu.org/copyleft/fdl.html .
.RE
.LP
以前は、groff 言語の拡張機能についてはマニュアルページ
.BR troff (1)
に記述されていた。
拡張機能の基本的な事項はこのドキュメントにも含まれるが、
より詳細な情報は groff info ファイルで参照できる。
.
.\" --------------------------------------------------------------------
.SH 関連項目
.\" --------------------------------------------------------------------
groff 言語の主な情報源は
.B groff
.B info (1)
ファイルである。
.LP
roff と groff システムの概要とさらなるドキュメントのポインタは
.BR roff (7)
を参照のこと。
.LP
フォーマッタプログラムについては
.BR groff (1)
と
.BR troff (1)
に記述されている。
すべての定義済みグリフ名については
.BR groff_char (7)
に示してある。
.LP
古典的な
.I troff
についてのドキュメントは以下の URL にある。
.RS
.LP
.I http://cm.bell-labs.com/cm/cs/cstr.html
.RE
.RS
.IR http://www.kohala.com/start/troff/




