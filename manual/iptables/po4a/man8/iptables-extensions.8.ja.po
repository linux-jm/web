# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-03-24 13:11+0900\n"
"PO-Revision-Date: 2021-03-24 17:17+0900\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#, no-wrap
msgid "iptables-extensions"
msgstr "iptables-extensions"

#. type: TH
#, no-wrap
msgid "iptables 1.8.4"
msgstr "iptables 1.8.4"

#. type: SH
#, no-wrap
msgid "NAME"
msgstr "名前"

#. type: Plain text
msgid "iptables-extensions \\(em list of extensions in the standard iptables distribution"
msgstr "iptables-extensions \\(em 標準の iptables に含まれる拡張モジュールのリスト"

#. type: SH
#, no-wrap
msgid "SYNOPSIS"
msgstr "書式"

#. type: Plain text
msgid "B<ip6tables> [B<-m> I<name> [I<module-options>...]] [B<-j> I<target-name> [I<target-options>...]"
msgstr "B<ip6tables> [B<-m> I<name> [I<module-options>...]] [B<-j> I<target-name> [I<target-options>...]"

#. type: Plain text
msgid "B<iptables> [B<-m> I<name> [I<module-options>...]] [B<-j> I<target-name> [I<target-options>...]"
msgstr "B<iptables> [B<-m> I<name> [I<module-options>...]] [B<-j> I<target-name> [I<target-options>...]"

#. type: SH
#, no-wrap
msgid "MATCH EXTENSIONS"
msgstr "マッチングの拡張"

#. type: Plain text
msgid "iptables can use extended packet matching modules with the B<-m> or B<--match> options, followed by the matching module name; after these, various extra command line options become available, depending on the specific module.  You can specify multiple extended match modules in one line, and you can use the B<-h> or B<--help> options after the module has been specified to receive help specific to that module.  The extended match modules are evaluated in the order they are specified in the rule."
msgstr "iptables は拡張されたパケットマッチングモジュールを使うことができる。 使用するモジュールは B<-m> か B<--match> の後ろにモジュール名に続けて指定する。 モジュール名の後ろには、 モジュールに応じて他のいろいろなコマンドラインオプションを指定することができる。 複数の拡張マッチングモジュールを一行で指定することができる。 モジュールの指定より後ろで B<-h> か B<--help> を指定すると、 モジュール固有のヘルプが表示される。 拡張マッチングモジュールはルールで指定された順序で評価される。"

#.  @MATCH@
#. type: Plain text
msgid "If the B<-p> or B<--protocol> was specified and if and only if an unknown option is encountered, iptables will try load a match module of the same name as the protocol, to try making the option available."
msgstr "B<-p> か B<--protocol> が指定され、 かつ未知のオプションだけが指定されていた場合にのみ、 iptables はプロトコルと同じ名前のマッチモジュールをロードし、 そのオプションを使えるようにしようとする。"

#. type: SS
#, no-wrap
msgid "addrtype"
msgstr "addrtype"

#. type: Plain text
msgid "This module matches packets based on their B<address type.> Address types are used within the kernel networking stack and categorize addresses into various groups.  The exact definition of that group depends on the specific layer three protocol."
msgstr "このモジュールは、 アドレス種別 (B<address type>) に基づいてパケットマッチングを行う。 アドレス種別はカーネルのネットワークスタック内で使われており、 アドレスはいくつかグループに分類される。 厳密なグループの定義は個々のレイヤ 3 プロトコルに依存する。"

#. type: Plain text
msgid "The following address types are possible:"
msgstr "以下のアドレスタイプが利用できる。"

#. type: TP
#, no-wrap
msgid "B<UNSPEC>"
msgstr "B<UNSPEC>"

#. type: Plain text
msgid "an unspecified address (i.e. 0.0.0.0)"
msgstr "アドレスを指定しない (つまりアドレス 0.0.0.0)"

#. type: TP
#, no-wrap
msgid "B<UNICAST>"
msgstr "B<UNICAST>"

#. type: Plain text
msgid "an unicast address"
msgstr "ユニキャストアドレス"

#. type: TP
#, no-wrap
msgid "B<LOCAL>"
msgstr "B<LOCAL>"

#. type: Plain text
msgid "a local address"
msgstr "ローカルアドレス"

#. type: TP
#, no-wrap
msgid "B<BROADCAST>"
msgstr "B<BROADCAST>"

#. type: Plain text
msgid "a broadcast address"
msgstr "ブロードキャストアドレス"

#. type: TP
#, no-wrap
msgid "B<ANYCAST>"
msgstr "B<ANYCAST>"

#. type: Plain text
msgid "an anycast packet"
msgstr "エニーキャストアドレス"

#. type: TP
#, no-wrap
msgid "B<MULTICAST>"
msgstr "B<MULTICAST>"

#. type: Plain text
msgid "a multicast address"
msgstr "マルチキャストアドレス"

#. type: TP
#, no-wrap
msgid "B<BLACKHOLE>"
msgstr "B<BLACKHOLE>"

#. type: Plain text
msgid "a blackhole address"
msgstr "ブラックホールアドレス"

#. type: TP
#, no-wrap
msgid "B<UNREACHABLE>"
msgstr "B<UNREACHABLE>"

#. type: Plain text
msgid "an unreachable address"
msgstr "到達できないアドレス"

#. type: TP
#, no-wrap
msgid "B<PROHIBIT>"
msgstr "B<PROHIBIT>"

#. type: Plain text
msgid "a prohibited address"
msgstr "禁止されたアドレス"

#. type: TP
#, no-wrap
msgid "B<THROW>"
msgstr "B<THROW>"

#. type: Plain text
msgid "FIXME"
msgstr "要修正"

#. type: TP
#, no-wrap
msgid "B<NAT>"
msgstr "B<NAT>"

#. type: TP
#, no-wrap
msgid "B<XRESOLVE>"
msgstr "B<XRESOLVE>"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--src-type> I<type>"
msgstr "[B<!>] B<--src-type> I<type>"

#. type: Plain text
msgid "Matches if the source address is of given type"
msgstr "送信元アドレスが指定された種類の場合にマッチする。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--dst-type> I<type>"
msgstr "[B<!>] B<--dst-type> I<type>"

#. type: Plain text
msgid "Matches if the destination address is of given type"
msgstr "宛先アドレスが指定された種類の場合にマッチする。"

#. type: TP
#, no-wrap
msgid "B<--limit-iface-in>"
msgstr "B<--limit-iface-in>"

#. type: Plain text
msgid "The address type checking can be limited to the interface the packet is coming in. This option is only valid in the B<PREROUTING>, B<INPUT> and B<FORWARD> chains. It cannot be specified with the B<--limit-iface-out> option."
msgstr "アドレス種別のチェックをそのパケットが受信されたインターフェースに限定する。 このオプションは B<PREROUTING>, B<INPUT>, B<FORWARD> チェインでのみ利用できる。 B<--limit-iface-out> オプションと同時に指定することはできない。"

#. type: TP
#, no-wrap
msgid "B<--limit-iface-out>"
msgstr "B<--limit-iface-out>"

#. type: Plain text
msgid "The address type checking can be limited to the interface the packet is going out. This option is only valid in the B<POSTROUTING>, B<OUTPUT> and B<FORWARD> chains. It cannot be specified with the B<--limit-iface-in> option."
msgstr "アドレス種別のチェックをそのパケットが出力されるインターフェースに限定する。 このオプションは B<POSTROUTING>, B<OUTPUT>, B<FORWARD> チェインでのみ利用できる。 B<--limit-iface-in> オプションと同時に指定することはできない。"

#. type: SS
#, no-wrap
msgid "ah (IPv6-specific)"
msgstr "ah (IPv6 のみ)"

#. type: Plain text
msgid "This module matches the parameters in Authentication header of IPsec packets."
msgstr "このモジュールは IPsec パケットの認証ヘッダーのパラメータにマッチする。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--ahspi> I<spi>[B<:>I<spi>]"
msgstr "[B<!>] B<--ahspi> I<spi>[B<:>I<spi>]"

#. type: Plain text
msgid "Matches SPI."
msgstr "SPI にマッチする。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--ahlen> I<length>"
msgstr "[B<!>] B<--ahlen> I<length>"

#. type: Plain text
msgid "Total length of this header in octets."
msgstr "このヘッダーの全体の長さ (8進数)。"

#. type: TP
#, no-wrap
msgid "B<--ahres>"
msgstr "B<--ahres>"

#. type: Plain text
msgid "Matches if the reserved field is filled with zero."
msgstr "予約フィールドが 0 で埋められている場合にマッチする。"

#. type: SS
#, no-wrap
msgid "ah (IPv4-specific)"
msgstr "ah (IPv4 の場合)"

#. type: Plain text
msgid "This module matches the SPIs in Authentication header of IPsec packets."
msgstr "このモジュールは IPsec パケットの認証ヘッダー (AH) の SPI 値にマッチする。"

#. type: SS
#, no-wrap
msgid "bpf"
msgstr "bpf"

#. type: Plain text
msgid "Match using Linux Socket Filter. Expects a path to an eBPF object or a cBPF program in decimal format."
msgstr "Linux Socket Filter を使ってマッチを行う。 eBPF オブジェクトへのパスもしくは、 10 進数形式の cBPF プログラムを指定する。"

#. type: TP
#, no-wrap
msgid "B<--object-pinned> I<path>"
msgstr "B<--object-pinned> I<path>"

#. type: Plain text
msgid "Pass a path to a pinned eBPF object."
msgstr ""

#. type: Plain text
msgid "Applications load eBPF programs into the kernel with the bpf() system call and BPF_PROG_LOAD command and can pin them in a virtual filesystem with BPF_OBJ_PIN.  To use a pinned object in iptables, mount the bpf filesystem using"
msgstr ""

#. type: Plain text
msgid "mount -t bpf bpf ${BPF_MOUNT}"
msgstr ""

#. type: Plain text
msgid "then insert the filter in iptables by path:"
msgstr ""

#. type: Plain text
msgid "iptables -A OUTPUT -m bpf --object-pinned ${BPF_MOUNT}/{PINNED_PATH} -j ACCEPT"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<--bytecode> I<code>"
msgstr "B<--bytecode> I<code>"

#. type: Plain text
msgid "Pass the BPF byte code format as generated by the B<nfbpf_compile> utility."
msgstr "BPF バイトコードフォーマットを渡す。 B<nfbpf_compile> ユーティリティにより生成されるフォーマットである。"

#. type: Plain text
msgid "The code format is similar to the output of the tcpdump -ddd command: one line that stores the number of instructions, followed by one line for each instruction. Instruction lines follow the pattern 'u16 u8 u8 u32' in decimal notation. Fields encode the operation, jump offset if true, jump offset if false and generic multiuse field 'K'. Comments are not supported."
msgstr "コードのフォーマットは tcpdump の -ddd コマンドの出力に似ている。 最初に命令数が入った行が 1 行あり、 1 行 1 命令がこれに続く。 命令行は 'u16 u8 u8 u32' のパターンで 10 進数で指定する。 各フィールドは、命令、 true 時のジャンプオフセット、 false 時のジャンプオフセット、 汎用で様々な用途に使用するフィールド 'K' である。 コメントはサポートされていない。"

#. type: Plain text
msgid "For example, to read only packets matching 'ip proto 6', insert the following, without the comments or trailing whitespace:"
msgstr "例えば 'ip proto 6' にマッチするパケットのみを読み込むには、以下を挿入すればよい (コムと末尾のホワイトスペースは含めずに)。"

#. type: Plain text
msgid "4 # number of instructions"
msgstr "4 # 命令数"

#. type: Plain text
msgid "48 0 0 9 # load byte ip-E<gt>proto"
msgstr "48 0 0 9 # load byte ip-E<gt>proto"

#. type: Plain text
msgid "21 0 1 6 # jump equal IPPROTO_TCP"
msgstr "21 0 1 6 # jump equal IPPROTO_TCP"

#. type: Plain text
msgid "6 0 0 1 # return pass (non-zero)"
msgstr "6 0 0 1 # return pass (non-zero)"

#. type: Plain text
msgid "6 0 0 0 # return fail (zero)"
msgstr "6 0 0 0 # return fail (zero)"

#. type: Plain text
msgid "You can pass this filter to the bpf match with the following command:"
msgstr "このフィルターを bpf マッチに渡すには以下のコマンドのようにする。"

#. type: Plain text
msgid "iptables -A OUTPUT -m bpf --bytecode '4,48 0 0 9,21 0 1 6,6 0 0 1,6 0 0 0' -j ACCEPT"
msgstr "iptables -A OUTPUT -m bpf --bytecode '4,48 0 0 9,21 0 1 6,6 0 0 1,6 0 0 0' -j ACCEPT"

#. type: Plain text
msgid "Or instead, you can invoke the nfbpf_compile utility."
msgstr "代わりに、 nfbpf_compile ユーティリティを使う方法もある。"

#. type: Plain text
msgid "iptables -A OUTPUT -m bpf --bytecode \"`nfbpf_compile RAW 'ip proto 6'`\" -j ACCEPT"
msgstr "iptables -A OUTPUT -m bpf --bytecode \"`nfbpf_compile RAW 'ip proto 6'`\" -j ACCEPT"

#. type: Plain text
msgid "Or use tcpdump -ddd. In that case, generate BPF targeting a device with the same data link type as the xtables match. Iptables passes packets from the network layer up, without mac layer. Select a device with data link type RAW, such as a tun device:"
msgstr ""

#. type: Plain text
msgid "ip tuntap add tun0 mode tun"
msgstr "ip tuntap add tun0 mode tun"

#. type: Plain text
msgid "ip link set tun0 up"
msgstr "ip link set tun0 up"

#. type: Plain text
msgid "tcpdump -ddd -i tun0 ip proto 6"
msgstr "tcpdump -ddd -i tun0 ip proto 6"

#. type: Plain text
msgid "See tcpdump -L -i $dev for a list of known data link types for a given device."
msgstr ""

#. type: Plain text
msgid "You may want to learn more about BPF from FreeBSD's bpf(4) manpage."
msgstr "BPF についてもっと詳しく知るには FreeBSD の bpf(4) manpage を見るといいだろう。"

#. type: SS
#, no-wrap
msgid "cgroup"
msgstr "cgroup"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--path> I<path>"
msgstr "[B<!>] B<--path> I<path>"

#. type: Plain text
msgid "Match cgroup2 membership."
msgstr ""

#. type: Plain text
msgid "Each socket is associated with the v2 cgroup of the creating process.  This matches packets coming from or going to all sockets in the sub-hierarchy of the specified path.  The path should be relative to the root of the cgroup2 hierarchy."
msgstr ""

#. type: TP
#, no-wrap
msgid "[B<!>] B<--cgroup> I<classid>"
msgstr "[B<!>] B<--cgroup> I<classid>"

#. type: Plain text
msgid "Match cgroup net_cls classid."
msgstr ""

#. type: Plain text
msgid "classid is the marker set through the cgroup net_cls controller.  This option and --path can't be used together."
msgstr ""

#. type: Plain text
#, no-wrap
msgid "Example:"
msgstr "例:"

#. type: Plain text
msgid "iptables -A OUTPUT -p tcp --sport 80 -m cgroup ! --path service/http-server -j DROP"
msgstr "iptables -A OUTPUT -p tcp --sport 80 -m cgroup ! --path service/http-server -j DROP"

#. type: Plain text
msgid "iptables -A OUTPUT -p tcp --sport 80 -m cgroup ! --cgroup 1 -j DROP"
msgstr "iptables -A OUTPUT -p tcp --sport 80 -m cgroup ! --cgroup 1 -j DROP"

#. type: Plain text
msgid "B<IMPORTANT>: when being used in the INPUT chain, the cgroup matcher is currently only of limited functionality, meaning it will only match on packets that are processed for local sockets through early socket demuxing. Therefore, general usage on the INPUT chain is not advised unless the implications are well understood."
msgstr ""

#. type: Plain text
msgid "Available since Linux 3.14."
msgstr "Linux 3.14 以降で利用可能。"

#. type: SS
#, no-wrap
msgid "cluster"
msgstr "cluster"

#. type: Plain text
msgid "Allows you to deploy gateway and back-end load-sharing clusters without the need of load-balancers."
msgstr "このモジュールを使うと、負荷分散装置なしで、ゲートウェイとバックエンドの負荷分散クラスターを配備できる。"

#. type: Plain text
msgid "This match requires that all the nodes see the same packets. Thus, the cluster match decides if this node has to handle a packet given the following options:"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<--cluster-total-nodes> I<num>"
msgstr "B<--cluster-total-nodes> I<num>"

#. type: Plain text
msgid "Set number of total nodes in cluster."
msgstr "クラスターの総ノード数を設定する。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--cluster-local-node> I<num>"
msgstr "[B<!>] B<--cluster-local-node> I<num>"

#. type: Plain text
msgid "Set the local node number ID."
msgstr "ローカルノードの数字の ID を設定する。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--cluster-local-nodemask> I<mask>"
msgstr "[B<!>] B<--cluster-local-nodemask> I<mask>"

#. type: Plain text
msgid "Set the local node number ID mask. You can use this option instead of B<--cluster-local-node>."
msgstr "ローカルノードの ID マスクを設定する。 このオプションは B<--cluster-local-node> の代わりに使うことができる。"

#. type: TP
#, no-wrap
msgid "B<--cluster-hash-seed> I<value>"
msgstr "B<--cluster-hash-seed> I<value>"

#. type: Plain text
msgid "Set seed value of the Jenkins hash."
msgstr "Jenkins ハッシュのシード値を設定する。"

#. type: Plain text
msgid "iptables -A PREROUTING -t mangle -i eth1 -m cluster --cluster-total-nodes 2 --cluster-local-node 1 --cluster-hash-seed 0xdeadbeef -j MARK --set-mark 0xffff"
msgstr "iptables -A PREROUTING -t mangle -i eth1 -m cluster --cluster-total-nodes 2 --cluster-local-node 1 --cluster-hash-seed 0xdeadbeef -j MARK --set-mark 0xffff"

#. type: Plain text
msgid "iptables -A PREROUTING -t mangle -i eth2 -m cluster --cluster-total-nodes 2 --cluster-local-node 1 --cluster-hash-seed 0xdeadbeef -j MARK --set-mark 0xffff"
msgstr "iptables -A PREROUTING -t mangle -i eth2 -m cluster --cluster-total-nodes 2 --cluster-local-node 1 --cluster-hash-seed 0xdeadbeef -j MARK --set-mark 0xffff"

#. type: Plain text
msgid "iptables -A PREROUTING -t mangle -i eth1 -m mark ! --mark 0xffff -j DROP"
msgstr "iptables -A PREROUTING -t mangle -i eth1 -m mark ! --mark 0xffff -j DROP"

#. type: Plain text
msgid "iptables -A PREROUTING -t mangle -i eth2 -m mark ! --mark 0xffff -j DROP"
msgstr "iptables -A PREROUTING -t mangle -i eth2 -m mark ! --mark 0xffff -j DROP"

#. type: Plain text
msgid "And the following commands to make all nodes see the same packets:"
msgstr "以下のコマンドで、 すべてのノードに同じパケットを届けることができる。"

#. type: Plain text
msgid "ip maddr add 01:00:5e:00:01:01 dev eth1"
msgstr "ip maddr add 01:00:5e:00:01:01 dev eth1"

#. type: Plain text
msgid "ip maddr add 01:00:5e:00:01:02 dev eth2"
msgstr "ip maddr add 01:00:5e:00:01:02 dev eth2"

#. type: Plain text
msgid "arptables -A OUTPUT -o eth1 --h-length 6 -j mangle --mangle-mac-s 01:00:5e:00:01:01"
msgstr "arptables -A OUTPUT -o eth1 --h-length 6 -j mangle --mangle-mac-s 01:00:5e:00:01:01"

#. type: Plain text
msgid "arptables -A INPUT -i eth1 --h-length 6 --destination-mac 01:00:5e:00:01:01 -j mangle --mangle-mac-d 00:zz:yy:xx:5a:27"
msgstr "arptables -A INPUT -i eth1 --h-length 6 --destination-mac 01:00:5e:00:01:01 -j mangle --mangle-mac-d 00:zz:yy:xx:5a:27"

#. type: Plain text
msgid "arptables -A OUTPUT -o eth2 --h-length 6 -j mangle --mangle-mac-s 01:00:5e:00:01:02"
msgstr "arptables -A OUTPUT -o eth2 --h-length 6 -j mangle --mangle-mac-s 01:00:5e:00:01:02"

#. type: Plain text
msgid "arptables -A INPUT -i eth2 --h-length 6 --destination-mac 01:00:5e:00:01:02 -j mangle --mangle-mac-d 00:zz:yy:xx:5a:27"
msgstr "arptables -A INPUT -i eth2 --h-length 6 --destination-mac 01:00:5e:00:01:02 -j mangle --mangle-mac-d 00:zz:yy:xx:5a:27"

#. type: Plain text
msgid "B<NOTE>: the arptables commands above use mainstream syntax. If you are using arptables-jf included in some RedHat, CentOS and Fedora versions, you will hit syntax errors. Therefore, you'll have to adapt these to the arptables-jf syntax to get them working."
msgstr ""

#. type: Plain text
msgid "In the case of TCP connections, pickup facility has to be disabled to avoid marking TCP ACK packets coming in the reply direction as valid."
msgstr "TCP 接続の場合には、応答方向で受信した TCP ACK パケットが有効とマークされないようにするため、ピックアップ (pickup) 機能を無効する必要がある。"

#. type: Plain text
msgid "echo 0 E<gt> /proc/sys/net/netfilter/nf_conntrack_tcp_loose"
msgstr "echo 0 E<gt> /proc/sys/net/netfilter/nf_conntrack_tcp_loose"

#. type: SS
#, no-wrap
msgid "comment"
msgstr "comment"

#. type: Plain text
msgid "Allows you to add comments (up to 256 characters) to any rule."
msgstr "ルールにコメント (最大 256 文字) を付けることができる。"

#. type: TP
#, no-wrap
msgid "B<--comment> I<comment>"
msgstr "B<--comment> I<comment>"

#. type: Plain text
msgid "iptables -A INPUT -i eth1 -m comment --comment \"my local LAN\""
msgstr "iptables -A INPUT -i eth1 -m comment --comment \"my local LAN\""

#. type: SS
#, no-wrap
msgid "connbytes"
msgstr "connbytes"

#. type: Plain text
msgid "Match by how many bytes or packets a connection (or one of the two flows constituting the connection) has transferred so far, or by average bytes per packet."
msgstr "一つのコネクション (もしくはそのコネクションを構成する 2 つのフローの一方) でそれまでに転送されたバイト数やパケット数、 もしくはパケットあたりの平均バイト数にマッチする。"

#. type: Plain text
msgid "The counters are 64-bit and are thus not expected to overflow ;)"
msgstr "カウンターは 64 ビットであり、したがってオーバーフローすることは考えられていない ;)"

#. type: Plain text
msgid "The primary use is to detect long-lived downloads and mark them to be scheduled using a lower priority band in traffic control."
msgstr "主な利用方法は、長時間存在するダウンロードを検出し、 これらに印を付けることで、 トラフィック制御において艇優先帯域を使うようにスケジューリングできるようにすることである。"

#. type: Plain text
msgid "The transferred bytes per connection can also be viewed through `conntrack -L` and accessed via ctnetlink."
msgstr "コネクションあたりの転送バイト数は、 `conntrack -L` 経由で見ることができ、 ctnetlink 経由でもアクセスすることもできる。"

#. type: Plain text
msgid "NOTE that for connections which have no accounting information, the match will always return false. The \"net.netfilter.nf_conntrack_acct\" sysctl flag controls whether B<new> connections will be byte/packet counted. Existing connection flows will not be gaining/losing a/the accounting structure when be sysctl flag is flipped."
msgstr ""
"アカウント情報を持っていないコネクションでは、 このマッチングは常に false を返す点に注意すること。 \n"
"\"net.netfilter.nf_conntrack_acct\" sysctl フラグで、 B<新規>コネクションでバイト数/パケット数の計測が行われるかが制御できる。 sysctl フラグが変更されても、 既存のコネクションのアカウント情報は影響を受けない。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--connbytes> I<from>[B<:>I<to>]"
msgstr "[B<!>] B<--connbytes> I<from>[B<:>I<to>]"

#. type: Plain text
msgid "match packets from a connection whose packets/bytes/average packet size is more than FROM and less than TO bytes/packets. if TO is omitted only FROM check is done. \"!\" is used to match packets not falling in the range."
msgstr "パケット数/バイト数/平均パケットサイズが FROM バイト/パケットより大きく TO バイト/パケットよりも小さいコネクションのパケットにマッチする。 TO が省略した場合は FROM のみがチェックされる。 \"!\" を使うと、 この範囲にないパケットにマッチする。"

#. type: TP
#, no-wrap
msgid "B<--connbytes-dir> {B<original>|B<reply>|B<both>}"
msgstr "B<--connbytes-dir> {B<original>|B<reply>|B<both>}"

#. type: Plain text
msgid "which packets to consider"
msgstr "どのパケットを計測するかを指定する"

#. type: TP
#, no-wrap
msgid "B<--connbytes-mode> {B<packets>|B<bytes>|B<avgpkt>}"
msgstr "B<--connbytes-mode> {B<packets>|B<bytes>|B<avgpkt>}"

#. type: Plain text
msgid "whether to check the amount of packets, number of bytes transferred or the average size (in bytes) of all packets received so far. Note that when \"both\" is used together with \"avgpkt\", and data is going (mainly)  only in one direction (for example HTTP), the average packet size will be about half of the actual data packets."
msgstr "パケット総数、転送バイト数、これまでに受信した全パケットの平均サイズ (バイト単位) のどれをチェックするかを指定する。 \"both\" と \"avgpkt\" を組み合わせて使った場合で、 (HTTP のように) データが (主に) 片方向でのみ転送される場合、 平均パケットサイズは実際のデータパケットの約半分になる点に注意すること。"

#. type: Plain text
msgid "iptables .. -m connbytes --connbytes 10000:100000 --connbytes-dir both --connbytes-mode bytes ..."
msgstr "iptables .. -m connbytes --connbytes 10000:100000 --connbytes-dir both --connbytes-mode bytes ..."

#. type: SS
#, no-wrap
msgid "connlabel"
msgstr "connlabel"

#. type: Plain text
msgid "Module matches or adds connlabels to a connection.  connlabels are similar to connmarks, except labels are bit-based; i.e.  all labels may be attached to a flow at the same time.  Up to 128 unique labels are currently supported."
msgstr ""

#. type: TP
#, no-wrap
msgid "[B<!>] B<--label> B<name>"
msgstr "[B<!>] B<--label> B<name>"

#. type: Plain text
msgid "matches if label B<name> has been set on a connection.  Instead of a name (which will be translated to a number, see EXAMPLE below), a number may be used instead.  Using a number always overrides connlabel.conf."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<--set>"
msgstr "B<--set>"

#. type: Plain text
msgid "if the label has not been set on the connection, set it.  Note that setting a label can fail.  This is because the kernel allocates the conntrack label storage area when the connection is created, and it only reserves the amount of memory required by the ruleset that exists at the time the connection is created.  In this case, the match will fail (or succeed, in case B<--label> option was negated)."
msgstr ""

#. type: Plain text
msgid "This match depends on libnetfilter_conntrack 1.0.4 or later.  Label translation is done via the B</etc/xtables/connlabel.conf> configuration file."
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"0\teth0-in\n"
"1\teth0-out\n"
"2\tppp-in\n"
"3\tppp-out\n"
"4\tbulk-traffic\n"
"5\tinteractive\n"
msgstr ""

#. type: SS
#, no-wrap
msgid "connlimit"
msgstr "connlimit"

#. type: Plain text
msgid "Allows you to restrict the number of parallel connections to a server per client IP address (or client address block)."
msgstr "一つのサーバーに対する、 一つのクライアント IP アドレス (またはクライアントアドレスブロック) からの同時接続数を制限することができる。"

#. type: TP
#, no-wrap
msgid "B<--connlimit-upto> I<n>"
msgstr "B<--connlimit-upto> I<n>"

#. type: Plain text
msgid "Match if the number of existing connections is below or equal I<n>."
msgstr "既存の接続数が I<n> 以下の場合にマッチする。"

#. type: TP
#, no-wrap
msgid "B<--connlimit-above> I<n>"
msgstr "B<--connlimit-above> I<n>"

#. type: Plain text
msgid "Match if the number of existing connections is above I<n>."
msgstr "既存の接続数が I<n> より多い場合にマッチする。"

#. type: TP
#, no-wrap
msgid "B<--connlimit-mask> I<prefix_length>"
msgstr "B<--connlimit-mask> I<prefix_length>"

#. type: Plain text
msgid "Group hosts using the prefix length. For IPv4, this must be a number between (including) 0 and 32. For IPv6, between 0 and 128. If not specified, the maximum prefix length for the applicable protocol is used."
msgstr "プレフィックス長を使ってホストのグルーピングを行う。 IPv4 の場合には、プレフィックス長は 0 以上 32 以下の値でなければならない。 IPv6 の場合には 0 以上 128 以下でなければならない。 指定しなかった場合、そのプロトコルで使われる最も長いプレフィックス長が使用される。"

#. type: TP
#, no-wrap
msgid "B<--connlimit-saddr>"
msgstr "B<--connlimit-saddr>"

#. type: Plain text
msgid "Apply the limit onto the source group. This is the default if --connlimit-daddr is not specified."
msgstr "送信元グループに対して制限を適用する。 これが --connlimit-daddr が指定されなかった場合のデフォルトである。"

#. type: TP
#, no-wrap
msgid "B<--connlimit-daddr>"
msgstr "B<--connlimit-daddr>"

#. type: Plain text
msgid "Apply the limit onto the destination group."
msgstr "宛先グループに対して制限を適用する。"

#. type: TP
#, no-wrap
msgid "Examples:"
msgstr "例:"

#. type: TP
#, no-wrap
msgid "# allow 2 telnet connections per client host"
msgstr "# クライアントホストあたり 2 つの telnet 接続を許可する"

#. type: Plain text
msgid "iptables -A INPUT -p tcp --syn --dport 23 -m connlimit --connlimit-above 2 -j REJECT"
msgstr "iptables -A INPUT -p tcp --syn --dport 23 -m connlimit --connlimit-above 2 -j REJECT"

#. type: TP
#, no-wrap
msgid "# you can also match the other way around:"
msgstr "# 同じことのに行う別のマッチ方法"

#. type: Plain text
msgid "iptables -A INPUT -p tcp --syn --dport 23 -m connlimit --connlimit-upto 2 -j ACCEPT"
msgstr "iptables -A INPUT -p tcp --syn --dport 23 -m connlimit --connlimit-upto 2 -j ACCEPT"

#. type: TP
#, no-wrap
msgid "# limit the number of parallel HTTP requests to 16 per class C sized source network (24 bit netmask)"
msgstr "# クラス C の送信元ネットワーク (ネットマスクが 24 ビット) あたりの同時 HTTP リクエスト数を 16 までに制限する"

#. type: Plain text
msgid "iptables -p tcp --syn --dport 80 -m connlimit --connlimit-above 16 --connlimit-mask 24 -j REJECT"
msgstr "iptables -p tcp --syn --dport 80 -m connlimit --connlimit-above 16 --connlimit-mask 24 -j REJECT"

#. type: TP
#, no-wrap
msgid "# limit the number of parallel HTTP requests to 16 for the link local network"
msgstr "# リンクローカルネットワークからの同時 HTTP リクエスト数を 16 までに制限する"

#. type: Plain text
msgid "(ipv6)  ip6tables -p tcp --syn --dport 80 -s fe80::/64 -m connlimit --connlimit-above 16 --connlimit-mask 64 -j REJECT"
msgstr "(ipv6)  ip6tables -p tcp --syn --dport 80 -s fe80::/64 -m connlimit --connlimit-above 16 --connlimit-mask 64 -j REJECT"

#. type: TP
#, no-wrap
msgid "# Limit the number of connections to a particular host:"
msgstr "# 特定のホスト宛のコネクション数を制限する"

#. type: Plain text
msgid "ip6tables -p tcp --syn --dport 49152:65535 -d 2001:db8::1 -m connlimit --connlimit-above 100 -j REJECT"
msgstr "ip6tables -p tcp --syn --dport 49152:65535 -d 2001:db8::1 -m connlimit --connlimit-above 100 -j REJECT"

#. type: SS
#, no-wrap
msgid "connmark"
msgstr "connmark"

#. type: Plain text
msgid "This module matches the netfilter mark field associated with a connection (which can be set using the B<CONNMARK> target below)."
msgstr "このモジュールはコネクションに関連づけられた netfilter の mark フィールドにマッチする (このフィールドは、 以下の B<CONNMARK> ターゲットで設定される)。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--mark> I<value>[B</>I<mask>]"
msgstr "[B<!>] B<--mark> I<value>[B</>I<mask>]"

#. type: Plain text
msgid "Matches packets in connections with the given mark value (if a mask is specified, this is logically ANDed with the mark before the comparison)."
msgstr "指定された mark 値を持つコネクションのパケットにマッチする (mask が指定されると、 比較の前に mask との論理積 (AND) がとられる)。"

#. type: SS
#, no-wrap
msgid "conntrack"
msgstr "conntrack"

#. type: Plain text
msgid "This module, when combined with connection tracking, allows access to the connection tracking state for this packet/connection."
msgstr "コネクション追跡 (connection tracking) と組み合わせて使用した場合に、 このモジュールを使うと、 パケットやコネクションの追跡状態を知ることができる。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--ctstate> I<statelist>"
msgstr "[B<!>] B<--ctstate> I<statelist>"

#. type: Plain text
msgid "I<statelist> is a comma separated list of the connection states to match.  Possible states are listed below."
msgstr "I<statelist> はマッチするコネクション状態 (connection state) のリストで、 コンマ区切りで指定する。 指定できる状態のリストは後述。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--ctproto> I<l4proto>"
msgstr "[B<!>] B<--ctproto> I<l4proto>"

#. type: Plain text
msgid "Layer-4 protocol to match (by number or name)"
msgstr "指定されたレイヤ 4 のプロトコルにマッチする。 プロトコルは名前または数値で指定する。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--ctorigsrc> I<address>[B</>I<mask>]"
msgstr "[B<!>] B<--ctorigsrc> I<address>[B</>I<mask>]"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--ctorigdst> I<address>[B</>I<mask>]"
msgstr "[B<!>] B<--ctorigdst> I<address>[B</>I<mask>]"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--ctreplsrc> I<address>[B</>I<mask>]"
msgstr "[B<!>] B<--ctreplsrc> I<address>[B</>I<mask>]"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--ctrepldst> I<address>[B</>I<mask>]"
msgstr "[B<!>] B<--ctrepldst> I<address>[B</>I<mask>]"

#. type: Plain text
msgid "Match against original/reply source/destination address"
msgstr "順方向/反対方向のコネクションの送信元/宛先アドレスにマッチする。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--ctorigsrcport> I<port>[B<:>I<port>]"
msgstr "[B<!>] B<--ctorigsrcport> I<port>[B<:>I<port>]"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--ctorigdstport> I<port>[B<:>I<port>]"
msgstr "[B<!>] B<--ctorigdstport> I<port>[B<:>I<port>]"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--ctreplsrcport> I<port>[B<:>I<port>]"
msgstr "[B<!>] B<--ctreplsrcport> I<port>[B<:>I<port>]"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--ctrepldstport> I<port>[B<:>I<port>]"
msgstr "[B<!>] B<--ctrepldstport> I<port>[B<:>I<port>]"

#. type: Plain text
msgid "Match against original/reply source/destination port (TCP/UDP/etc.) or GRE key.  Matching against port ranges is only supported in kernel versions above 2.6.38."
msgstr "順方向/反対方向のコネクションの (TCP/UDPなどの) 送信元/宛先ポートアドレス、 もしくは GRE キーにマッチする。 ポートの範囲指定はカーネル 2.6.38 以降でのみサポートされている。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--ctstatus> I<statelist>"
msgstr "[B<!>] B<--ctstatus> I<statelist>"

#. type: Plain text
msgid "I<statuslist> is a comma separated list of the connection statuses to match.  Possible statuses are listed below."
msgstr "I<statuslist> はマッチするコネクション状況 (connection status) のリストで、 コンマ区切りで指定する。 指定できる状況のリストは後述。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--ctexpire> I<time>[B<:>I<time>]"
msgstr "[B<!>] B<--ctexpire> I<time>[B<:>I<time>]"

#. type: Plain text
msgid "Match remaining lifetime in seconds against given value or range of values (inclusive)"
msgstr "有効期間の残り秒数、 またはその範囲(両端を含む)にマッチする。"

#. type: TP
#, no-wrap
msgid "B<--ctdir> {B<ORIGINAL>|B<REPLY>}"
msgstr "B<--ctdir> {B<ORIGINAL>|B<REPLY>}"

#. type: Plain text
msgid "Match packets that are flowing in the specified direction. If this flag is not specified at all, matches packets in both directions."
msgstr "指定した方向に流れるパケットにマッチする。 このフラグが全く指定されなかった場合、 両方向のパケットがマッチする。"

#. type: Plain text
msgid "States for B<--ctstate>:"
msgstr "B<--ctstate> に指定できる状態は以下の通り。"

#. type: TP
#, no-wrap
msgid "B<INVALID>"
msgstr "B<INVALID>"

#. type: Plain text
msgid "The packet is associated with no known connection."
msgstr "そのパケットはどの既知のコネクションとも関連付けられていない。"

#. type: TP
#, no-wrap
msgid "B<NEW>"
msgstr "B<NEW>"

#. type: Plain text
msgid "The packet has started a new connection or otherwise associated with a connection which has not seen packets in both directions."
msgstr "そのパケットが新しいコネクションを開始しようとしている。 もしくは、 両方の方向でパケットが観測されていないコネクションに関連付けられる。"

#. type: TP
#, no-wrap
msgid "B<ESTABLISHED>"
msgstr "B<ESTABLISHED>"

#. type: Plain text
msgid "The packet is associated with a connection which has seen packets in both directions."
msgstr "そのパケットが、 両方向のパケットが観測されたコネクションに関連付けられる。"

#. type: TP
#, no-wrap
msgid "B<RELATED>"
msgstr "B<RELATED>"

#. type: Plain text
msgid "The packet is starting a new connection, but is associated with an existing connection, such as an FTP data transfer or an ICMP error."
msgstr "そのパケットは、新しいコネクションを開始しようとしているが、 既存のコネクションと関連付けられる。 FTP データ転送や ICMP エラーなどが該当する。"

#. type: TP
#, no-wrap
msgid "B<UNTRACKED>"
msgstr "B<UNTRACKED>"

#. type: Plain text
msgid "The packet is not tracked at all, which happens if you explicitly untrack it by using -j CT --notrack in the raw table."
msgstr "そのパケットは全く追跡されていない。 この状態は、 raw テーブルで -j CT --notrack を使って明示的にそのパケットを追跡しないようにしている場合に起こる。"

#. type: TP
#, no-wrap
msgid "B<SNAT>"
msgstr "B<SNAT>"

#. type: Plain text
msgid "A virtual state, matching if the original source address differs from the reply destination."
msgstr "元の送信元アドレスが応答の宛先アドレスと異なる場合にマッチする仮想的な状態。"

#. type: TP
#, no-wrap
msgid "B<DNAT>"
msgstr "B<DNAT>"

#. type: Plain text
msgid "A virtual state, matching if the original destination differs from the reply source."
msgstr "元の宛先アドレスが応答の送信元アドレスと異なる場合にマッチする仮想的な状態。"

#. type: Plain text
msgid "Statuses for B<--ctstatus>:"
msgstr "B<--ctstatus> に指定できる値は以下の通り。"

#. type: TP
#, no-wrap
msgid "B<NONE>"
msgstr "B<NONE>"

#. type: Plain text
msgid "None of the below."
msgstr "以下のいずれでもない。"

#. type: TP
#, no-wrap
msgid "B<EXPECTED>"
msgstr "B<EXPECTED>"

#. type: Plain text
msgid "This is an expected connection (i.e. a conntrack helper set it up)."
msgstr "期待通りのコネクションである (つまり conntrack のヘルパーがコネクションをセットアップした)。"

#. type: TP
#, no-wrap
msgid "B<SEEN_REPLY>"
msgstr "B<SEEN_REPLY>"

#. type: Plain text
msgid "Conntrack has seen packets in both directions."
msgstr "conntrack が両方の方向でパケットを観測済である。"

#. type: TP
#, no-wrap
msgid "B<ASSURED>"
msgstr "B<ASSURED>"

#. type: Plain text
msgid "Conntrack entry should never be early-expired."
msgstr "conntrack エントリが early-expired されることはない。"

#. type: TP
#, no-wrap
msgid "B<CONFIRMED>"
msgstr "B<CONFIRMED>"

#. type: Plain text
msgid "Connection is confirmed: originating packet has left box."
msgstr ""

#. type: SS
#, no-wrap
msgid "cpu"
msgstr "cpu"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--cpu> I<number>"
msgstr "[B<!>] B<--cpu> I<number>"

#. type: Plain text
msgid "Match cpu handling this packet. cpus are numbered from 0 to NR_CPUS-1 Can be used in combination with RPS (Remote Packet Steering) or multiqueue NICs to spread network traffic on different queues."
msgstr "このパケットを処理する CPU にマッチする。 CPU には 0 から NR_CPUS-1 の番号が振られる。 ネットワークトラフィックを複数のキューに分散させるために RPS (Remote Packet Steering) やマルチキュー NIC と組み合わせて使用できる。"

#. type: Plain text
msgid "iptables -t nat -A PREROUTING -p tcp --dport 80 -m cpu --cpu 0 -j REDIRECT --to-port 8080"
msgstr "iptables -t nat -A PREROUTING -p tcp --dport 80 -m cpu --cpu 0 -j REDIRECT --to-port 8080"

#. type: Plain text
msgid "iptables -t nat -A PREROUTING -p tcp --dport 80 -m cpu --cpu 1 -j REDIRECT --to-port 8081"
msgstr "iptables -t nat -A PREROUTING -p tcp --dport 80 -m cpu --cpu 1 -j REDIRECT --to-port 8081"

#. type: Plain text
msgid "Available since Linux 2.6.36."
msgstr "Linux 2.6.36 以降で利用可能。"

#. type: SS
#, no-wrap
msgid "dccp"
msgstr "dccp"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--source-port>,B<--sport> I<port>[B<:>I<port>]"
msgstr "[B<!>] B<--source-port>,B<--sport> I<port>[B<:>I<port>]"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--destination-port>,B<--dport> I<port>[B<:>I<port>]"
msgstr "[B<!>] B<--destination-port>,B<--dport> I<port>[B<:>I<port>]"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--dccp-types> I<mask>"
msgstr "[B<!>] B<--dccp-types> I<mask>"

#. type: Plain text
msgid "Match when the DCCP packet type is one of 'mask'. 'mask' is a comma-separated list of packet types.  Packet types are: B<REQUEST RESPONSE DATA ACK DATAACK CLOSEREQ CLOSE RESET SYNC SYNCACK INVALID>."
msgstr "DCCP パケットタイプが I<mask> のいずれかであればマッチする。 I<mask> はカンマ区切りのパケットタイプのリストである。 指定できるパケットタイプは B<REQUEST RESPONSE DATA ACK DATAACK CLOSEREQ CLOSE RESET SYNC SYNCACK INVALID> である。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--dccp-option> I<number>"
msgstr "[B<!>] B<--dccp-option> I<number>"

#. type: Plain text
msgid "Match if DCCP option set."
msgstr "DCCP オプションが設定されている場合にマッチする。"

#. type: SS
#, no-wrap
msgid "devgroup"
msgstr "devgroup"

#. type: Plain text
msgid "Match device group of a packets incoming/outgoing interface."
msgstr "パケットの受信/送信インターフェースのデバイスグループにマッチする。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--src-group> I<name>"
msgstr "[B<!>] B<--src-group> I<name>"

#. type: Plain text
msgid "Match device group of incoming device"
msgstr "受信デバイスのデバイスグループにマッチする"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--dst-group> I<name>"
msgstr "[B<!>] B<--dst-group> I<name>"

#. type: Plain text
msgid "Match device group of outgoing device"
msgstr "送信デバイスのデバイスグループにマッチする"

#. type: SS
#, no-wrap
msgid "dscp"
msgstr "dscp"

#. type: Plain text
msgid "This module matches the 6 bit DSCP field within the TOS field in the IP header.  DSCP has superseded TOS within the IETF."
msgstr "このモジュールは、 IP ヘッダーの TOS フィールド内にある、 6 bit の DSCP フィールドにマッチする。 IETF では DSCP が TOS に取って代わった。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--dscp> I<value>"
msgstr "[B<!>] B<--dscp> I<value>"

#. type: Plain text
msgid "Match against a numeric (decimal or hex) value [0-63]."
msgstr "(10 進または 16 進の) 数値 [0-63] にマッチする。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--dscp-class> I<class>"
msgstr "[B<!>] B<--dscp-class> I<class>"

#. type: Plain text
msgid "Match the DiffServ class. This value may be any of the BE, EF, AFxx or CSx classes.  It will then be converted into its according numeric value."
msgstr "DiffServ クラスにマッチする。 値は BE, EF, AFxx, CSx クラスのいずれかである。 対応する数値に変換される。"

#. type: SS
#, no-wrap
msgid "dst (IPv6-specific)"
msgstr "dst (IPv6 のみ)"

#. type: Plain text
msgid "This module matches the parameters in Destination Options header"
msgstr "このモジュールは宛先オプションヘッダーのパラメータにマッチする。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--dst-len> I<length>"
msgstr "[B<!>] B<--dst-len> I<length>"

#. type: TP
#, no-wrap
msgid "B<--dst-opts> I<type>[B<:>I<length>][B<,>I<type>[B<:>I<length>]...]"
msgstr "B<--dst-opts> I<type>[B<:>I<length>][B<,>I<type>[B<:>I<length>]...]"

#. type: Plain text
msgid "numeric type of option and the length of the option data in octets."
msgstr "数値のオプションタイプとオプションデータのオクテット単位の長さ。"

#. type: SS
#, no-wrap
msgid "ecn"
msgstr "ecn"

#. type: Plain text
msgid "This allows you to match the ECN bits of the IPv4/IPv6 and TCP header.  ECN is the Explicit Congestion Notification mechanism as specified in RFC3168"
msgstr "IPv4/IPv6 と TCP ヘッダーの ECN ビットにマッチングを行う。 ECN とは RFC3168 で規定された Explicit Congestion Notification (明示的な輻輳通知) 機構のことである。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--ecn-tcp-cwr>"
msgstr "[B<!>] B<--ecn-tcp-cwr>"

#. type: Plain text
msgid "This matches if the TCP ECN CWR (Congestion Window Received) bit is set."
msgstr "TCP ECN CWR (Congestion Window Received) ビットがセットされている場合にマッチする。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--ecn-tcp-ece>"
msgstr "[B<!>] B<--ecn-tcp-ece>"

#. type: Plain text
msgid "This matches if the TCP ECN ECE (ECN Echo) bit is set."
msgstr "TCP ECN ECE (ECN Echo) ビットがセットされている場合にマッチする。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--ecn-ip-ect> I<num>"
msgstr "[B<!>] B<--ecn-ip-ect> I<num>"

#. type: Plain text
msgid "This matches a particular IPv4/IPv6 ECT (ECN-Capable Transport). You have to specify a number between `0' and `3'."
msgstr "特定の IPv4/IPv6 ECT (ECN-Capable Transport) にマッチする。 `0' 以上 `3' 以下の値を指定しなければならない。"

#. type: SS
#, no-wrap
msgid "esp"
msgstr "esp"

#. type: Plain text
msgid "This module matches the SPIs in ESP header of IPsec packets."
msgstr "このモジュールは IPsec パケットの ESP ヘッダーの SPI 値にマッチする。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--espspi> I<spi>[B<:>I<spi>]"
msgstr "[B<!>] B<--espspi> I<spi>[B<:>I<spi>]"

#. type: SS
#, no-wrap
msgid "eui64 (IPv6-specific)"
msgstr "eui64 (IPv6 のみ)"

#. type: Plain text
msgid "This module matches the EUI-64 part of a stateless autoconfigured IPv6 address.  It compares the EUI-64 derived from the source MAC address in Ethernet frame with the lower 64 bits of the IPv6 source address. But \"Universal/Local\" bit is not compared. This module doesn't match other link layer frame, and is only valid in the B<PREROUTING>, B<INPUT> and B<FORWARD> chains."
msgstr "このモジュールは stateless の自動で設定された IPv6 アドレスの EUI-64 の部分にマッチする。 Ethernet の送信元 MAC アドレスに基づく EUI-64 と IPv6 送信元アドレスの下位 64 ビットの比較が行われる。 ただし \"Universal/Local\" ビットは比較されない。 このモジュールは他のリンク層フレームにはマッチしない。 このモジュールは B<PREROUTING>, B<INPUT>, B<FORWARD> チェインでのみ有効である。"

#. type: SS
#, no-wrap
msgid "frag (IPv6-specific)"
msgstr "frag (IPv6 のみ)"

#. type: Plain text
msgid "This module matches the parameters in Fragment header."
msgstr "このモジュールはフラグメントヘッダーのパラメータにマッチする。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--fragid> I<id>[B<:>I<id>]"
msgstr "[B<!>] B<--fragid> I<id>[B<:>I<id>]"

#. type: Plain text
msgid "Matches the given Identification or range of it."
msgstr "指定された値もしくは範囲の ID にマッチする。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--fraglen> I<length>"
msgstr "[B<!>] B<--fraglen> I<length>"

#. type: Plain text
msgid "This option cannot be used with kernel version 2.6.10 or later. The length of Fragment header is static and this option doesn't make sense."
msgstr "このオプションはバージョン 2.6.10 以降のカーネルでは使用できない。 フラグメントヘッダー長は変化しないので、このオプションは意味を持たない。"

#. type: TP
#, no-wrap
msgid "B<--fragres>"
msgstr "B<--fragres>"

#. type: Plain text
msgid "Matches if the reserved fields are filled with zero."
msgstr "予約フィールドに 0 が入っている場合にマッチする。"

#. type: TP
#, no-wrap
msgid "B<--fragfirst>"
msgstr "B<--fragfirst>"

#. type: Plain text
msgid "Matches on the first fragment."
msgstr "最初のフラグメントにマッチする。"

#. type: TP
#, no-wrap
msgid "B<--fragmore>"
msgstr "B<--fragmore>"

#. type: Plain text
msgid "Matches if there are more fragments."
msgstr "さらにフラグメントが続く場合にマッチする。"

#. type: TP
#, no-wrap
msgid "B<--fraglast>"
msgstr "B<--fraglast>"

#. type: Plain text
msgid "Matches if this is the last fragment."
msgstr "最後のフラグメントの場合にマッチする。"

#. type: SS
#, no-wrap
msgid "hashlimit"
msgstr "hashlimit"

#. type: Plain text
msgid "B<hashlimit> uses hash buckets to express a rate limiting match (like the B<limit> match) for a group of connections using a B<single> iptables rule. Grouping can be done per-hostgroup (source and/or destination address)  and/or per-port. It gives you the ability to express \"I<N> packets per time quantum per group\" or \"I<N> bytes per seconds\" (see below for some examples)."
msgstr ""

#. type: Plain text
msgid "A hash limit option (B<--hashlimit-upto>, B<--hashlimit-above>) and B<--hashlimit-name> are required."
msgstr "hash limit オプション (B<--hashlimit-upto>, B<--hashlimit-above>) と B<--hashlimit-name> は必須である。"

#. type: TP
#, no-wrap
msgid "B<--hashlimit-upto> I<amount>[B</second>|B</minute>|B</hour>|B</day>]"
msgstr "B<--hashlimit-upto> I<amount>[B</second>|B</minute>|B</hour>|B</day>]"

#. type: Plain text
msgid "Match if the rate is below or equal to I<amount>/quantum. It is specified either as a number, with an optional time quantum suffix (the default is 3/hour), or as I<amount>b/second (number of bytes per second)."
msgstr "単位時間あたりの平均マッチ回数の最大値。 数値で指定され、 添字 `/second', `/minute', `/hour', `/day' を付けることもできる。 デフォルトは 3/hour である。"

#. type: TP
#, no-wrap
msgid "B<--hashlimit-above> I<amount>[B</second>|B</minute>|B</hour>|B</day>]"
msgstr "B<--hashlimit-above> I<amount>[B</second>|B</minute>|B</hour>|B</day>]"

#. type: Plain text
msgid "Match if the rate is above I<amount>/quantum."
msgstr "レートが指定された区間での I<amount> より大きい場合にマッチする。"

#. type: TP
#, no-wrap
msgid "B<--hashlimit-burst> I<amount>"
msgstr "B<--hashlimit-burst> I<amount>"

#. type: Plain text
msgid "Maximum initial number of packets to match: this number gets recharged by one every time the limit specified above is not reached, up to this number; the default is 5.  When byte-based rate matching is requested, this option specifies the amount of bytes that can exceed the given rate.  This option should be used with caution -- if the entry expires, the burst value is reset too."
msgstr "パケットがマッチする回数の最大初期値: 上のオプションで指定した制限に達しなければ、 マッチするごとに、 この数値になるまで 1 個ずつ増やされる。 デフォルトは 5 である。 バイトでのレート照合が要求された場合、 このオプションは指定レートを超過できるバイト数を規定する。 このオプションを使用する際には注意が必要である -- エントリがタイムアウトで削除される際に、バースト値もリセットされる。"

#. type: TP
#, no-wrap
msgid "B<--hashlimit-mode> {B<srcip>|B<srcport>|B<dstip>|B<dstport>}B<,>..."
msgstr "B<--hashlimit-mode> {B<srcip>|B<srcport>|B<dstip>|B<dstport>}B<,>..."

#. type: Plain text
msgid "A comma-separated list of objects to take into consideration. If no --hashlimit-mode option is given, hashlimit acts like limit, but at the expensive of doing the hash housekeeping."
msgstr "対象とする要素のカンマ区切りのリスト。 --hashlimit-mode オプションが指定されなかった場合、 hashlimit は limit と同じ動作をするが、 ハッシュの管理を行うコストがかかる。"

#. type: TP
#, no-wrap
msgid "B<--hashlimit-srcmask> I<prefix>"
msgstr "B<--hashlimit-srcmask> I<prefix>"

#. type: Plain text
msgid "When --hashlimit-mode srcip is used, all source addresses encountered will be grouped according to the given prefix length and the so-created subnet will be subject to hashlimit. I<prefix> must be between (inclusive) 0 and 32. Note that --hashlimit-srcmask 0 is basically doing the same thing as not specifying srcip for --hashlimit-mode, but is technically more expensive."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<--hashlimit-dstmask> I<prefix>"
msgstr "B<--hashlimit-dstmask> I<prefix>"

#. type: Plain text
msgid "Like --hashlimit-srcmask, but for destination addresses."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<--hashlimit-name> I<foo>"
msgstr "B<--hashlimit-name> I<foo>"

#. type: Plain text
msgid "The name for the /proc/net/ipt_hashlimit/foo entry."
msgstr "/proc/net/ipt_hashlimit/foo エントリの名前。"

#. type: TP
#, no-wrap
msgid "B<--hashlimit-htable-size> I<buckets>"
msgstr "B<--hashlimit-htable-size> I<buckets>"

#. type: Plain text
msgid "The number of buckets of the hash table"
msgstr "ハッシュテーブルのバケット数。"

#. type: TP
#, no-wrap
msgid "B<--hashlimit-htable-max> I<entries>"
msgstr "B<--hashlimit-htable-max> I<entries>"

#. type: Plain text
msgid "Maximum entries in the hash."
msgstr "ハッシュの最大エントリ数。"

#. type: TP
#, no-wrap
msgid "B<--hashlimit-htable-expire> I<msec>"
msgstr "B<--hashlimit-htable-expire> I<msec>"

#. type: Plain text
msgid "After how many milliseconds do hash entries expire."
msgstr "ハッシュエントリが何ミリ秒後に削除されるか。"

#. type: TP
#, no-wrap
msgid "B<--hashlimit-htable-gcinterval> I<msec>"
msgstr "B<--hashlimit-htable-gcinterval> I<msec>"

#. type: Plain text
msgid "How many milliseconds between garbage collection intervals."
msgstr "ガベージコレクションの間隔 (ミリ秒)。"

#. type: TP
#, no-wrap
msgid "B<--hashlimit-rate-match>"
msgstr "B<--hashlimit-rate-match>"

#. type: Plain text
msgid "Classify the flow instead of rate-limiting it. This acts like a true/false match on whether the rate is above/below a certain number"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<--hashlimit-rate-interval> I<sec>"
msgstr "B<--hashlimit-rate-interval> I<sec>"

#. type: Plain text
msgid "Can be used with --hashlimit-rate-match to specify the interval at which the rate should be sampled"
msgstr ""

#. type: TP
#, no-wrap
msgid "matching on source host"
msgstr "送信元ホストに対するマッチ"

#. type: Plain text
msgid "\"1000 packets per second for every host in 192.168.0.0/16\" =E<gt> -s 192.168.0.0/16 --hashlimit-mode srcip --hashlimit-upto 1000/sec"
msgstr "\"192.168.0.0/16 の各ホストに対して 1000 パケット/秒\" =E<gt> -s 192.168.0.0/16 --hashlimit-mode srcip --hashlimit-upto 1000/sec"

#. type: TP
#, no-wrap
msgid "matching on source port"
msgstr "送信元ポートに対するマッチ"

#. type: Plain text
msgid "\"100 packets per second for every service of 192.168.1.1\" =E<gt> -s 192.168.1.1 --hashlimit-mode srcport --hashlimit-upto 100/sec"
msgstr "\"192.168.1.1 の各サービスに対して 100 パケット/秒\" =E<gt> -s 192.168.1.1 --hashlimit-mode srcport --hashlimit-upto 100/sec"

#. type: TP
#, no-wrap
msgid "matching on subnet"
msgstr "サブネットに対するマッチ"

#. type: Plain text
msgid "\"10000 packets per minute for every /28 subnet (groups of 8 addresses)  in 10.0.0.0/8\" =E<gt> -s 10.0.0.0/8 --hashlimit-mask 28 --hashlimit-upto 10000/min"
msgstr "\"10.0.0.0/8 内の /28 サブネット (アドレス 8 個のグループ) それぞれに対して 10000 パケット/秒\" =E<gt> -s 10.0.0.0/8 --hashlimit-mask 28 --hashlimit-upto 10000/min"

#. type: TP
#, no-wrap
msgid "matching bytes per second"
msgstr "バイト/秒によるマッチ"

#. type: Plain text
msgid "\"flows exceeding 512kbyte/s\" =E<gt> --hashlimit-mode srcip,dstip,srcport,dstport --hashlimit-above 512kb/s"
msgstr "\"512kbyte/s を超過したフロー\" =E<gt> --hashlimit-mode srcip,dstip,srcport,dstport --hashlimit-above 512kb/s"

#. type: Plain text
msgid "\"hosts that exceed 512kbyte/s, but permit up to 1Megabytes without matching\" --hashlimit-mode dstip --hashlimit-above 512kb/s --hashlimit-burst 1mb"
msgstr "\"512kbyte/s を超過するとマッチするが、 1 メガバイトに達するまではマッチせず許可する\" --hashlimit-mode dstip --hashlimit-above 512kb/s --hashlimit-burst 1mb"

#. type: SS
#, no-wrap
msgid "hbh (IPv6-specific)"
msgstr "hbh (IPv6 のみ)"

#. type: Plain text
msgid "This module matches the parameters in Hop-by-Hop Options header"
msgstr "このモジュールは Hop-by-Hop オプションヘッダーのパラメータにマッチする。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--hbh-len> I<length>"
msgstr "[B<!>] B<--hbh-len> I<length>"

#. type: TP
#, no-wrap
msgid "B<--hbh-opts> I<type>[B<:>I<length>][B<,>I<type>[B<:>I<length>]...]"
msgstr "B<--hbh-opts> I<type>[B<:>I<length>][B<,>I<type>[B<:>I<length>]...]"

#. type: SS
#, no-wrap
msgid "helper"
msgstr "helper"

#. type: Plain text
msgid "This module matches packets related to a specific conntrack-helper."
msgstr "このモジュールは、 指定されたコネクション追跡ヘルパーモジュールに 関連するパケットにマッチする。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--helper> I<string>"
msgstr "[B<!>] B<--helper> I<string>"

#. type: Plain text
msgid "Matches packets related to the specified conntrack-helper."
msgstr "指定されたコネクション追跡ヘルパーモジュールに 関連するパケットにマッチする。"

#. type: Plain text
msgid "string can be \"ftp\" for packets related to a ftp-session on default port.  For other ports append -portnr to the value, ie. \"ftp-2121\"."
msgstr "デフォルトのポートを使った ftp-セッションに関連するパケットでは、 string に \"ftp\" と書ける。 他のポートでは \"-ポート番号\" を値に付け加える。 すなわち \"ftp-2121\" となる。"

#. type: Plain text
msgid "Same rules apply for other conntrack-helpers."
msgstr "他のコネクション追跡ヘルパーでも同じルールが適用される。"

#. type: SS
#, no-wrap
msgid "hl (IPv6-specific)"
msgstr "hl (IPv6 のみ)"

#. type: Plain text
msgid "This module matches the Hop Limit field in the IPv6 header."
msgstr "このモジュールは IPv6 ヘッダーの Hop Limit フィールドにマッチする。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--hl-eq> I<value>"
msgstr "[B<!>] B<--hl-eq> I<value>"

#. type: Plain text
msgid "Matches if Hop Limit equals I<value>."
msgstr "Hop Limit が I<value> と同じ場合にマッチする。"

#. type: TP
#, no-wrap
msgid "B<--hl-lt> I<value>"
msgstr "B<--hl-lt> I<value>"

#. type: Plain text
msgid "Matches if Hop Limit is less than I<value>."
msgstr "Hop Limit が I<value> より小さい場合にマッチする。"

#. type: TP
#, no-wrap
msgid "B<--hl-gt> I<value>"
msgstr "B<--hl-gt> I<value>"

#. type: Plain text
msgid "Matches if Hop Limit is greater than I<value>."
msgstr "Hop Limit が I<value> より大きい場合にマッチする。"

#. type: SS
#, no-wrap
msgid "icmp (IPv4-specific)"
msgstr "icmp (IPv4 の場合)"

#. type: Plain text
msgid "This extension can be used if `--protocol icmp' is specified. It provides the following option:"
msgstr "この拡張は `--protocol icmp' が指定された場合に使用でき、 以下のオプションが提供される:"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--icmp-type> {I<type>[B</>I<code>]|I<typename>}"
msgstr "[B<!>] B<--icmp-type> {I<type>[B</>I<code>]|I<typename>}"

#. type: Plain text
msgid "This allows specification of the ICMP type, which can be a numeric ICMP type, type/code pair, or one of the ICMP type names shown by the command"
msgstr "ICMP タイプを指定できる。 タイプ指定には、 数値の ICMP タイプ、 タイプ/コードの組、 または以下のコマンド で表示される ICMP タイプ名を指定できる。"

#. type: Plain text
#, no-wrap
msgid " iptables -p icmp -h\n"
msgstr " iptables -p icmp -h\n"

#. type: SS
#, no-wrap
msgid "icmp6 (IPv6-specific)"
msgstr "icmp6 (IPv6 のみ)"

#. type: Plain text
msgid "This extension can be used if `--protocol ipv6-icmp' or `--protocol icmpv6' is specified. It provides the following option:"
msgstr "これらの拡張は `--protocol ipv6-icmp' または `--protocol icmpv6' が指定された場合に使用でき、 以下のオプションが提供される:"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--icmpv6-type> I<type>[B</>I<code>]|I<typename>"
msgstr "[B<!>] B<--icmpv6-type> I<type>[B</>I<code>]|I<typename>"

#. type: Plain text
msgid "This allows specification of the ICMPv6 type, which can be a numeric ICMPv6 I<type>, I<type> and I<code>, or one of the ICMPv6 type names shown by the command"
msgstr "ICMPv6 タイプを指定できる。 タイプ指定には、 数値の ICMP I<type>、 I<type> と I<code>、 または以下のコマンド で表示される ICMPv6 タイプ名を指定できる。"

#. type: Plain text
#, no-wrap
msgid " ip6tables -p ipv6-icmp -h\n"
msgstr " ip6tables -p ipv6-icmp -h\n"

#. type: SS
#, no-wrap
msgid "iprange"
msgstr "iprange"

#. type: Plain text
msgid "This matches on a given arbitrary range of IP addresses."
msgstr "このモジュールは指定された任意の範囲の IP アドレスにマッチする。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--src-range> I<from>[B<->I<to>]"
msgstr "[B<!>] B<--src-range> I<from>[B<->I<to>]"

#. type: Plain text
msgid "Match source IP in the specified range."
msgstr "指定された範囲の送信元 IP にマッチする。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--dst-range> I<from>[B<->I<to>]"
msgstr "[B<!>] B<--dst-range> I<from>[B<->I<to>]"

#. type: Plain text
msgid "Match destination IP in the specified range."
msgstr "指定された範囲の宛先 IP にマッチする。"

#. type: SS
#, no-wrap
msgid "ipv6header (IPv6-specific)"
msgstr "ipv6header (IPv6 のみ)"

#. type: Plain text
msgid "This module matches IPv6 extension headers and/or upper layer header."
msgstr "このモジュールは IPv6 拡張ヘッダー、 上位レイヤのヘッダー、もしくはその両方にマッチする。"

#. type: TP
#, no-wrap
msgid "B<--soft>"
msgstr "B<--soft>"

#. type: Plain text
msgid "Matches if the packet includes B<any> of the headers specified with B<--header>."
msgstr "パケットが B<--header> で指定されたヘッダーのB<いずれか>を含む場合にマッチする。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--header> I<header>[B<,>I<header>...]"
msgstr "[B<!>] B<--header> I<header>[B<,>I<header>...]"

#. type: Plain text
msgid "Matches the packet which EXACTLY includes all specified headers. The headers encapsulated with ESP header are out of scope.  Possible I<header> types can be:"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<hop>|B<hop-by-hop>"
msgstr "B<hop>|B<hop-by-hop>"

#. type: Plain text
msgid "Hop-by-Hop Options header"
msgstr "Hop-by-Hop オプションヘッダー"

#. type: TP
#, no-wrap
msgid "B<dst>"
msgstr "B<dst>"

#. type: Plain text
msgid "Destination Options header"
msgstr "宛先オプションヘッダー"

#. type: TP
#, no-wrap
msgid "B<route>"
msgstr "B<route>"

#. type: Plain text
msgid "Routing header"
msgstr "ルーティングヘッダー"

#. type: TP
#, no-wrap
msgid "B<frag>"
msgstr "B<frag>"

#. type: Plain text
msgid "Fragment header"
msgstr "フラグメントヘッダー"

#. type: TP
#, no-wrap
msgid "B<auth>"
msgstr "B<auth>"

#. type: Plain text
msgid "Authentication header"
msgstr "認証ヘッダー (AH)"

#. type: TP
#, no-wrap
msgid "B<esp>"
msgstr "B<esp>"

#. type: Plain text
msgid "Encapsulating Security Payload header"
msgstr "ESP (Encapsulating Security Payload) ヘッダー"

#. type: TP
#, no-wrap
msgid "B<none>"
msgstr "B<none>"

#. type: Plain text
msgid "No Next header which matches 59 in the 'Next Header field' of IPv6 header or any IPv6 extension headers"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<prot>"
msgstr "B<prot>"

#. type: Plain text
msgid "which matches any upper layer protocol header. A protocol name from /etc/protocols and numeric value also allowed. The number 255 is equivalent to B<prot>."
msgstr ""

#. type: SS
#, no-wrap
msgid "ipvs"
msgstr "ipvs"

#. type: Plain text
msgid "Match IPVS connection properties."
msgstr "IPVS コネクション属性にマッチする。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--ipvs>"
msgstr "[B<!>] B<--ipvs>"

#. type: Plain text
msgid "packet belongs to an IPVS connection"
msgstr "IPVS コネクションに属すパケット"

#. type: TP
#, no-wrap
msgid "Any of the following options implies --ipvs (even negated)"
msgstr "以下のオプションでは --ipvs も暗黙のうちに指定される (否定の場合も含む)"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--vproto> I<protocol>"
msgstr "[B<!>] B<--vproto> I<protocol>"

#. type: Plain text
msgid "VIP protocol to match; by number or name, e.g. \"tcp\""
msgstr "マッチする VIP プロトコル (数値か名前 (例えば \"tcp\") で指定する)"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--vaddr> I<address>[B</>I<mask>]"
msgstr "[B<!>] B<--vaddr> I<address>[B</>I<mask>]"

#. type: Plain text
msgid "VIP address to match"
msgstr "マッチする VIP アドレス"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--vport> I<port>"
msgstr "[B<!>] B<--vport> I<port>"

#. type: Plain text
msgid "VIP port to match; by number or name, e.g. \"http\""
msgstr "マッチする VIP プロトコル (数値か名前 (例えば \\\"http\\\") で指定する)"

#. type: TP
#, no-wrap
msgid "B<--vdir> {B<ORIGINAL>|B<REPLY>}"
msgstr "B<--vdir> {B<ORIGINAL>|B<REPLY>}"

#. type: Plain text
msgid "flow direction of packet"
msgstr "パケットフローの方向"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--vmethod> {B<GATE>|B<IPIP>|B<MASQ>}"
msgstr "[B<!>] B<--vmethod> {B<GATE>|B<IPIP>|B<MASQ>}"

#. type: Plain text
msgid "IPVS forwarding method used"
msgstr "使用する IPVS の転送方法"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--vportctl> I<port>"
msgstr "[B<!>] B<--vportctl> I<port>"

#. type: Plain text
msgid "VIP port of the controlling connection to match, e.g. 21 for FTP"
msgstr "マッチする制御用コネクションの VIP ポート (例えば FTP であれば 21)"

#. type: SS
#, no-wrap
msgid "length"
msgstr "length"

#. type: Plain text
msgid "This module matches the length of the layer-3 payload (e.g. layer-4 packet)  of a packet against a specific value or range of values."
msgstr "このモジュールは、 パケットのレイヤ 3 ペイロード (例えばレイヤ 4 パケット) の長さが、 指定された値、 または値の範囲にあればマッチする。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--length> I<length>[B<:>I<length>]"
msgstr "[B<!>] B<--length> I<length>[B<:>I<length>]"

#. type: SS
#, no-wrap
msgid "limit"
msgstr "limit"

#. type: Plain text
msgid "This module matches at a limited rate using a token bucket filter.  A rule using this extension will match until this limit is reached.  It can be used in combination with the B<LOG> target to give limited logging, for example."
msgstr "このモジュールは、 トークンバケットフィルタを使って制限レートのマッチを行う。 この拡張を使ったルールは、指定された制限に達するまでマッチする。 例えば、 このモジュールはログ記録を制限するために B<LOG> ターゲットと組み合わせて使うことができる。"

#. type: Plain text
msgid "xt_limit has no negation support - you will have to use -m hashlimit ! --hashlimit I<rate> in this case whilst omitting --hashlimit-mode."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<--limit> I<rate>[B</second>|B</minute>|B</hour>|B</day>]"
msgstr "B<--limit> I<rate>[B</second>|B</minute>|B</hour>|B</day>]"

#. type: Plain text
msgid "Maximum average matching rate: specified as a number, with an optional `/second', `/minute', `/hour', or `/day' suffix; the default is 3/hour."
msgstr "単位時間あたりの平均マッチ回数の最大値。 数値で指定され、 添字 `/second', `/minute', `/hour', `/day' を付けることもできる。 デフォルトは 3/hour である。"

#. type: TP
#, no-wrap
msgid "B<--limit-burst> I<number>"
msgstr "B<--limit-burst> I<number>"

#. type: Plain text
msgid "Maximum initial number of packets to match: this number gets recharged by one every time the limit specified above is not reached, up to this number; the default is 5."
msgstr "パケットがマッチする回数の最大初期値: 上のオプションで指定した制限に達しなければ、 マッチするごとに、 この数値になるまで 1 個ずつ増やされる。 デフォルトは 5 である。"

#. type: SS
#, no-wrap
msgid "mac"
msgstr "mac"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--mac-source> I<address>"
msgstr "[B<!>] B<--mac-source> I<address>"

#. type: Plain text
msgid "Match source MAC address.  It must be of the form XX:XX:XX:XX:XX:XX.  Note that this only makes sense for packets coming from an Ethernet device and entering the B<PREROUTING>, B<FORWARD> or B<INPUT> chains."
msgstr ""
"送信元 MAC アドレスにマッチする。 I<address> は XX:XX:XX:XX:XX:XX と\n"
"いう形式でなければならない。 イーサーネットデバイスから入ってくるパケッ\n"
"トで、 B<PREROUTING>, B<FORWARD>, B<INPUT> チェインに入るパケットにしか\n"
"意味がない。"

#. type: SS
#, no-wrap
msgid "mark"
msgstr "mark"

#. type: Plain text
msgid "This module matches the netfilter mark field associated with a packet (which can be set using the B<MARK> target below)."
msgstr "このモジュールはパケットに関連づけられた netfilter の mark フィールドにマッチする (このフィールドは、 以下の B<MARK> ターゲットで設定される)。"

#. type: Plain text
msgid "Matches packets with the given unsigned mark value (if a I<mask> is specified, this is logically ANDed with the I<mask> before the comparison)."
msgstr "指定された符号なしの mark 値を持つパケットにマッチする (I<mask> が指定されると、 比較の前に I<mask> との論理積 (AND) がとられる)。"

#. type: SS
#, no-wrap
msgid "mh (IPv6-specific)"
msgstr "mh (IPv6 のみ)"

#. type: Plain text
msgid "This extension is loaded if `--protocol ipv6-mh' or `--protocol mh' is specified. It provides the following option:"
msgstr "この拡張は `--protocol ipv6-mh' または `--protocol mh' が指定された場合にロードされる。 以下のオプションが提供される。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--mh-type> I<type>[B<:>I<type>]"
msgstr "[B<!>] B<--mh-type> I<type>[B<:>I<type>]"

#. type: Plain text
msgid "This allows specification of the Mobility Header(MH) type, which can be a numeric MH I<type>, I<type> or one of the MH type names shown by the command"
msgstr "Mobility Header (MH) タイプを指定できる。 タイプ指定には、 数値の MH タイプか、 以下のコマンドで表示される MH タイプ名を指定できる。"

#. type: Plain text
#, no-wrap
msgid " ip6tables -p mh -h\n"
msgstr " ip6tables -p mh -h\n"

#. type: SS
#, no-wrap
msgid "multiport"
msgstr "multiport"

#. type: Plain text
msgid "This module matches a set of source or destination ports.  Up to 15 ports can be specified.  A port range (port:port) counts as two ports.  It can only be used in conjunction with one of the following protocols: B<tcp>, B<udp>, B<udplite>, B<dccp> and B<sctp>."
msgstr "このモジュールは送信元ポートや宛先ポートの集合にマッチする。 ポートは 15 個まで指定できる。 ポートの範囲指定 (port:port) は 2 ポートとカウントされる。 このモジュールが使用できるのは B<tcp>, B<udp>, B<udplite>, B<dccp>, B<sctp> のいずれかと組み合わせた場合だけである。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--source-ports>,B<--sports> I<port>[B<,>I<port>|B<,>I<port>B<:>I<port>]..."
msgstr "[B<!>] B<--source-ports>,B<--sports> I<port>[B<,>I<port>|B<,>I<port>B<:>I<port>]..."

#. type: Plain text
msgid "Match if the source port is one of the given ports.  The flag B<--sports> is a convenient alias for this option. Multiple ports or port ranges are separated using a comma, and a port range is specified using a colon.  B<53,1024:65535> would therefore match ports 53 and all from 1024 through 65535."
msgstr "送信元ポートが指定されたポートのいずれにマッチする。 フラグ B<--sports> はこのオプションの便利な別名である。 複数のポートやポート範囲がカンマ区切りで指定できる。 ポート範囲はコロン区切りで指定する。 したがって B<53,1024:65535> はポート 53 および 1024 から 65535 までの全ポートにマッチする。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--destination-ports>,B<--dports> I<port>[B<,>I<port>|B<,>I<port>B<:>I<port>]..."
msgstr "[B<!>] B<--destination-ports>,B<--dports> I<port>[B<,>I<port>|B<,>I<port>B<:>I<port>]..."

#. type: Plain text
msgid "Match if the destination port is one of the given ports.  The flag B<--dports> is a convenient alias for this option."
msgstr ""
"宛先ポートが指定されたポートのうちのいずれかであればマッチする。 \n"
"フラグ B<--dports> は、 このオプションの便利な別名である。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--ports> I<port>[B<,>I<port>|B<,>I<port>B<:>I<port>]..."
msgstr "[B<!>] B<--ports> I<port>[B<,>I<port>|B<,>I<port>B<:>I<port>]..."

#. type: Plain text
msgid "Match if either the source or destination ports are equal to one of the given ports."
msgstr "送信元ポートと宛先ポートの一方が指定されたポートのいずれか一つと等しければ、 マッチする。"

#. type: SS
#, no-wrap
msgid "nfacct"
msgstr "nfacct"

#. type: Plain text
msgid "The nfacct match provides the extended accounting infrastructure for iptables.  You have to use this match together with the standalone user-space utility B<nfacct(8)>"
msgstr "nfacct マッチングは iptable に拡張アカウンティング機構を提供する。 このマッチングモジュールはユーザー空間スタンドアロンユーティリティ B<nfacct>(8) と一緒に使う必要がある。"

#. type: Plain text
msgid "The only option available for this match is the following:"
msgstr "以下のオプションだけがこのマッチングで使用できる。"

#. type: TP
#, no-wrap
msgid "B<--nfacct-name> I<name>"
msgstr "B<--nfacct-name> I<name>"

#. type: Plain text
msgid "This allows you to specify the existing object name that will be use for accounting the traffic that this rule-set is matching."
msgstr "このルールセットがマッチするトラフィック量を記録するのに使用する既存のオブジェクト名を指定する。"

#. type: Plain text
msgid "To use this extension, you have to create an accounting object:"
msgstr "この拡張を使用するには、アカウンティングオブジェクトを作成する必要があります。"

#. type: Plain text
msgid "nfacct add http-traffic"
msgstr "nfacct add http-traffic"

#. type: Plain text
msgid "Then, you have to attach it to the accounting object via iptables:"
msgstr "それから、iptables を使ってアカウンティングオブジェクトにトラフィックを関連付けます。"

#. type: Plain text
msgid "iptables -I INPUT -p tcp --sport 80 -m nfacct --nfacct-name http-traffic"
msgstr "iptables -I INPUT -p tcp --sport 80 -m nfacct --nfacct-name http-traffic"

#. type: Plain text
msgid "iptables -I OUTPUT -p tcp --dport 80 -m nfacct --nfacct-name http-traffic"
msgstr "iptables -I OUTPUT -p tcp --dport 80 -m nfacct --nfacct-name http-traffic"

#. type: Plain text
msgid "Then, you can check for the amount of traffic that the rules match:"
msgstr "そうすると、ルールにマッチしたトラフィック量をチェックできる。"

#. type: Plain text
msgid "nfacct get http-traffic"
msgstr "nfacct get http-traffic"

#. type: Plain text
msgid "{ pkts = 00000000000000000156, bytes = 00000000000000151786 } = http-traffic;"
msgstr "{ pkts = 00000000000000000156, bytes = 00000000000000151786 } = http-traffic;"

#. type: Plain text
msgid "You can obtain B<nfacct(8)> from http://www.netfilter.org or, alternatively, from the git.netfilter.org repository."
msgstr "B<nfacct>(8) は http://www.netfilter.org もしくは git.netfilter.org リポジトリから入手できる。"

#. type: SS
#, no-wrap
msgid "osf"
msgstr "osf"

#. type: Plain text
msgid "The osf module does passive operating system fingerprinting. This modules compares some data (Window Size, MSS, options and their order, TTL, DF, and others) from packets with the SYN bit set."
msgstr "osf モジュールは受動的な OS (オペレーティングシステム) フィンガープリンティングを行う。 このモジュールは SYN ビットがセットされたパケットのいくつかのデータ (Window Size, MSS, オプションとその順序, TTL, DF など) を比較する。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--genre> I<string>"
msgstr "[B<!>] B<--genre> I<string>"

#. type: Plain text
msgid "Match an operating system genre by using a passive fingerprinting."
msgstr "受動的フィンガープリンティングでマッチさせるオペレーティングシステムのジャンル。"

#. type: TP
#, no-wrap
msgid "B<--ttl> I<level>"
msgstr "B<--ttl> I<level>"

#. type: Plain text
msgid "Do additional TTL checks on the packet to determine the operating system.  I<level> can be one of the following values:"
msgstr "パケットに対して、オペレーティングシステムを判定するための追加の TTL チェックを行う。 I<level> には以下の値のいずれを指定できる。"

#. type: IP
#, no-wrap
msgid "\\(bu"
msgstr "\\(bu"

#. type: Plain text
msgid "0 - True IP address and fingerprint TTL comparison. This generally works for LANs."
msgstr "0 - 本当の IP アドレスとフィンガープリント TTL の比較を行う。 一般に LAN で有効である。"

#. type: Plain text
msgid "1 - Check if the IP header's TTL is less than the fingerprint one. Works for globally-routable addresses."
msgstr "1 - IP ヘッダーの TTL がフィンガープリント TTL より小さいかチェックする。 グローバルにルーティング可能なアドレスで有効である。"

#. type: Plain text
msgid "2 - Do not compare the TTL at all."
msgstr "2 - TTL の比較を全く行わない。"

#. type: TP
#, no-wrap
msgid "B<--log> I<level>"
msgstr "B<--log> I<level>"

#. type: Plain text
msgid "Log determined genres into dmesg even if they do not match the desired one.  I<level> can be one of the following values:"
msgstr "判別したジャンルが期待するものと違う場合でもロギングするかどうか。 I<level> には以下のいずれかを指定できる。"

#. type: Plain text
msgid "0 - Log all matched or unknown signatures"
msgstr "マッチしたシグネチャーと不明なシグネチャーをすべて記録する"

#. type: Plain text
msgid "1 - Log only the first one"
msgstr "1 - 最初にマッチしたもののみを記録する"

#. type: Plain text
msgid "2 - Log all known matched signatures"
msgstr "2 - マッチした既知のシグネチャーをすべて記録する"

#. type: Plain text
msgid "You may find something like this in syslog:"
msgstr "syslog に以下のようなメッセージが記録される。"

#. type: Plain text
msgid "Windows [2000:SP3:Windows XP Pro SP1, 2000 SP3]: 11.22.33.55:4024 -E<gt> 11.22.33.44:139 hops=3 Linux [2.5-2.6:] : 1.2.3.4:42624 -E<gt> 1.2.3.5:22 hops=4"
msgstr "Windows [2000:SP3:Windows XP Pro SP1, 2000 SP3]: 11.22.33.55:4024 -E<gt> 11.22.33.44:139 hops=3 Linux [2.5-2.6:] : 1.2.3.4:42624 -E<gt> 1.2.3.5:22 hops=4"

#. type: Plain text
msgid "OS fingerprints are loadable using the B<nfnl_osf> program. To load fingerprints from a file, use:"
msgstr "OS フィンガープリントは B<nfnl_osf> プログラムを使ってロードできる。 ファイルからフィンガープリントをロードするには以下のようにする。"

#. type: Plain text
msgid "B<nfnl_osf -f /usr/share/xtables/pf.os>"
msgstr "B<nfnl_osf -f /usr/share/xtables/pf.os>"

#. type: Plain text
msgid "To remove them again,"
msgstr "再度削除するには以下のようにする。"

#. type: Plain text
msgid "B<nfnl_osf -f /usr/share/xtables/pf.os -d>"
msgstr "B<nfnl_osf -f /usr/share/xtables/pf.os -d>"

#. type: Plain text
msgid "The fingerprint database can be downloaded from http://www.openbsd.org/cgi-bin/cvsweb/src/etc/pf.os ."
msgstr "フィンガープリントデータベースは http://www.openbsd.org/cgi-bin/cvsweb/src/etc/pf.os からダウンロードできる。"

#. type: SS
#, no-wrap
msgid "owner"
msgstr "owner"

#. type: Plain text
msgid "This module attempts to match various characteristics of the packet creator, for locally generated packets. This match is only valid in the OUTPUT and POSTROUTING chains. Forwarded packets do not have any socket associated with them. Packets from kernel threads do have a socket, but usually no owner."
msgstr "このモジュールは、 ローカルで生成されたパケットに対して、 パケット生成者の様々な特性に対するマッチを行う。 このマッチは OUTPUT チェインか POSTROUTING チェインでのみ有効である。 転送パケットはどのソケットとも関連付けられていない。 カーネルスレッドからのパケットには対応するソケットがあるが、 通常ソケットの所有者はいない。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--uid-owner> I<username>"
msgstr "[B<!>] B<--uid-owner> I<username>"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--uid-owner> I<userid>[B<->I<userid>]"
msgstr "[B<!>] B<--uid-owner> I<userid>[B<->I<userid>]"

#. type: Plain text
msgid "Matches if the packet socket's file structure (if it has one) is owned by the given user. You may also specify a numerical UID, or an UID range."
msgstr "そのパケットのソケットのファイル構造体が存在し、ソケットの所有者が指定されたユーザーの場合にマッチする。 数値の UID や UID の範囲を指定することもできる。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--gid-owner> I<groupname>"
msgstr "[B<!>] B<--gid-owner> I<groupname>"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--gid-owner> I<groupid>[B<->I<groupid>]"
msgstr "[B<!>] B<--gid-owner> I<groupid>[B<->I<groupid>]"

#. type: Plain text
msgid "Matches if the packet socket's file structure is owned by the given group.  You may also specify a numerical GID, or a GID range."
msgstr "そのパケットのソケットのファイル構造体の所有者が指定されたグループの場合にマッチする。 数値の GID や GID の範囲を指定することもできる。"

#. type: TP
#, no-wrap
msgid "B<--suppl-groups>"
msgstr ""

#. type: Plain text
msgid "Causes group(s) specified with B<--gid-owner> to be also checked in the supplementary groups of a process."
msgstr ""

#. type: TP
#, no-wrap
msgid "[B<!>] B<--socket-exists>"
msgstr "[B<!>] B<--socket-exists>"

#. type: Plain text
msgid "Matches if the packet is associated with a socket."
msgstr "パケットがソケットに関連付けられている場合にマッチする。"

#. type: SS
#, no-wrap
msgid "physdev"
msgstr "physdev"

#. type: Plain text
msgid "This module matches on the bridge port input and output devices enslaved to a bridge device. This module is a part of the infrastructure that enables a transparent bridging IP firewall and is only useful for kernel versions above version 2.5.44."
msgstr "このモジュールは、 ブリッジデバイスのスレーブにされた、 ブリッジポートの入出力デバイスにマッチする。 このモジュールは、 ブリッジによる透過的な IP ファイアウォールの基盤の一部であり、 カーネルバージョン 2.5.44 以降でのみ有効である。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--physdev-in> I<name>"
msgstr "[B<!>] B<--physdev-in> I<name>"

#. type: Plain text
msgid "Name of a bridge port via which a packet is received (only for packets entering the B<INPUT>, B<FORWARD> and B<PREROUTING> chains). If the interface name ends in a \"+\", then any interface which begins with this name will match. If the packet didn't arrive through a bridge device, this packet won't match this option, unless '!' is used."
msgstr "パケットが受信されるブリッジのポート名 (B<INPUT>, B<FORWARD>, B<PREROUTING> チェインに入るパケットのみ)。 インターフェース名が \"+\" で終っている場合、 その名前で始まる任意のインターフェース名にマッチする。 ブリッジデバイスを通して受け取られなかったパケットは、 \\&'!' が指定されていない限り、 このオプションにマッチしない。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--physdev-out> I<name>"
msgstr "[B<!>] B<--physdev-out> I<name>"

#. type: Plain text
msgid "Name of a bridge port via which a packet is going to be sent (for bridged packets entering the B<FORWARD> and B<POSTROUTING> chains).  If the interface name ends in a \"+\", then any interface which begins with this name will match."
msgstr "パケットが送信されるブリッジのポート名 (B<FORWARD>, B<POSTROUTING> チェインに入るパケットに対して)。 インターフェース名が \"+\" で終っている場合、 その名前で始まる任意のインターフェース名にマッチする。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--physdev-is-in>"
msgstr "[B<!>] B<--physdev-is-in>"

#. type: Plain text
msgid "Matches if the packet has entered through a bridge interface."
msgstr "パケットがブリッジインターフェースに入った場合にマッチする。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--physdev-is-out>"
msgstr "[B<!>] B<--physdev-is-out>"

#. type: Plain text
msgid "Matches if the packet will leave through a bridge interface."
msgstr "パケットがブリッジインターフェースから出ようとした場合にマッチする。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--physdev-is-bridged>"
msgstr "[B<!>] B<--physdev-is-bridged>"

#. type: Plain text
msgid "Matches if the packet is being bridged and therefore is not being routed.  This is only useful in the FORWARD and POSTROUTING chains."
msgstr "パケットがブリッジされることにより、 ルーティングされなかった場合にマッチする。 これは FORWARD, POSTROUTING チェインにおいてのみ役立つ。"

#. type: SS
#, no-wrap
msgid "pkttype"
msgstr "pkttype"

#. type: Plain text
msgid "This module matches the link-layer packet type."
msgstr "このモジュールは、 リンク層のパケットタイプにマッチする。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--pkt-type> {B<unicast>|B<broadcast>|B<multicast>}"
msgstr "[B<!>] B<--pkt-type> {B<unicast>|B<broadcast>|B<multicast>}"

#. type: SS
#, no-wrap
msgid "policy"
msgstr "policy"

#. type: Plain text
msgid "This modules matches the policy used by IPsec for handling a packet."
msgstr "このモジュールはパケットを処理する IPsec が使用するポリシーにマッチする。"

#. type: TP
#, no-wrap
msgid "B<--dir> {B<in>|B<out>}"
msgstr "B<--dir> {B<in>|B<out>}"

#. type: Plain text
msgid "Used to select whether to match the policy used for decapsulation or the policy that will be used for encapsulation.  B<in> is valid in the B<PREROUTING, INPUT and FORWARD> chains, B<out> is valid in the B<POSTROUTING, OUTPUT and FORWARD> chains."
msgstr "復号 (decapsulation) に使用するポリシーにマッチするか、カプセル化 (encapsulation) に使用するポリシーにマッチするかを指定する。 B<in> はチェイン B<PREROUTING, INPUT, FORWARD> で有効で、 B<out> はチェイン B<POSTROUTING, OUTPUT, FORWARD> で有効である。"

#. type: TP
#, no-wrap
msgid "B<--pol> {B<none>|B<ipsec>}"
msgstr "B<--pol> {B<none>|B<ipsec>}"

#. type: Plain text
msgid "Matches if the packet is subject to IPsec processing. B<--pol none> cannot be combined with B<--strict>."
msgstr "パケットが IPsec 処理対象であればマッチする。 B<--pol none> は B<--strict> と一緒に使用できない。"

#. type: TP
#, no-wrap
msgid "B<--strict>"
msgstr "B<--strict>"

#. type: Plain text
msgid "Selects whether to match the exact policy or match if any rule of the policy matches the given policy."
msgstr "ポリシーが正確にマッチするか、指定したポリシーがポリシーのいずれかのルールにマッチするかを指定する。"

#. type: Plain text
msgid "For each policy element that is to be described, one can use one or more of the following options. When B<--strict> is in effect, at least one must be used per element."
msgstr "それぞれのポリシー要素を定義するのに、以下のオプション (複数可) を使用することができる。 B<--strict> が有効になっている場合、各要素につき少なくともオプションを一つ指定しなければならない。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--reqid> I<id>"
msgstr "[B<!>] B<--reqid> I<id>"

#. type: Plain text
msgid "Matches the reqid of the policy rule. The reqid can be specified with B<setkey(8)> using B<unique:id> as level."
msgstr "ポリシールールの reqid にマッチする。 reqid は B<setkey>(8) でレベルとして B<unique:id> を使って指定できる。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--spi> I<spi>"
msgstr "[B<!>] B<--spi> I<spi>"

#. type: Plain text
msgid "Matches the SPI of the SA."
msgstr "SA の SPI にマッチする。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--proto> {B<ah>|B<esp>|B<ipcomp>}"
msgstr "[B<!>] B<--proto> {B<ah>|B<esp>|B<ipcomp>}"

#. type: Plain text
msgid "Matches the encapsulation protocol."
msgstr "カプセル化プロトコルにマッチする。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--mode> {B<tunnel>|B<transport>}"
msgstr "[B<!>] B<--mode> {B<tunnel>|B<transport>}"

#. type: Plain text
msgid "Matches the encapsulation mode."
msgstr "カプセル化モードにマッチする。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--tunnel-src> I<addr>[B</>I<mask>]"
msgstr "[B<!>] B<--tunnel-src> I<addr>[B</>I<mask>]"

#. type: Plain text
msgid "Matches the source end-point address of a tunnel mode SA.  Only valid with B<--mode tunnel>."
msgstr "トンネルモード SA の送信元エンドポイントアドレスにマッチする。 B<--mode tunnel> との組み合わせでのみ有効。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--tunnel-dst> I<addr>[B</>I<mask>]"
msgstr "[B<!>] B<--tunnel-dst> I<addr>[B</>I<mask>]"

#. type: Plain text
msgid "Matches the destination end-point address of a tunnel mode SA.  Only valid with B<--mode tunnel>."
msgstr "トンネルモード SA の宛先エンドポイントアドレスにマッチする。 B<--mode tunnel> との組み合わせでのみ有効。"

#. type: TP
#, no-wrap
msgid "B<--next>"
msgstr "B<--next>"

#. type: Plain text
msgid "Start the next element in the policy specification. Can only be used with B<--strict>."
msgstr "ポリシー定義の次の要素から開始する。 B<--strict> との組み合わせでのみ使用できる。"

#. type: SS
#, no-wrap
msgid "quota"
msgstr "quota"

#. type: Plain text
msgid "Implements network quotas by decrementing a byte counter with each packet. The condition matches until the byte counter reaches zero. Behavior is reversed with negation (i.e. the condition does not match until the byte counter reaches zero)."
msgstr ""

#. type: TP
#, no-wrap
msgid "[B<!>] B<--quota> I<bytes>"
msgstr "[B<!>] B<--quota> I<bytes>"

#. type: Plain text
msgid "The quota in bytes."
msgstr "バイト単位のクォータ。"

#. type: SS
#, no-wrap
msgid "rateest"
msgstr "rateest"

#. type: Plain text
msgid "The rate estimator can match on estimated rates as collected by the RATEEST target. It supports matching on absolute bps/pps values, comparing two rate estimators and matching on the difference between two rate estimators."
msgstr "レート推測器 (rate estimator) は RATEEST ターゲットで収集された推定レートにマッチする。 bps/pps の絶対値に対するマッチング、 2 つのレート推測器の比較、 2 つのレート推測器の差分に対するマッチングをサポートしている。"

#.  * Absolute:
#. type: Plain text
msgid "For a better understanding of the available options, these are all possible combinations:"
msgstr "利用可能なオプションが分かりやすいように、すべての可能な組み合わせを以下に示す。"

#. type: Plain text
msgid "B<rateest> I<operator> B<rateest-bps>"
msgstr "B<rateest> I<operator> B<rateest-bps>"

#.  * Absolute + Delta:
#. type: Plain text
msgid "B<rateest> I<operator> B<rateest-pps>"
msgstr "B<rateest> I<operator> B<rateest-pps>"

#. type: Plain text
msgid "(B<rateest> minus B<rateest-bps1>) I<operator> B<rateest-bps2>"
msgstr "(B<rateest> minus B<rateest-bps1>) I<operator> B<rateest-bps2>"

#.  * Relative:
#. type: Plain text
msgid "(B<rateest> minus B<rateest-pps1>) I<operator> B<rateest-pps2>"
msgstr "(B<rateest> minus B<rateest-pps1>) I<operator> B<rateest-pps2>"

#. type: Plain text
msgid "B<rateest1> I<operator> B<rateest2> B<rateest-bps>(without rate!)"
msgstr "B<rateest1> I<operator> B<rateest2> B<rateest-bps>(without rate!)"

#.  * Relative + Delta:
#. type: Plain text
msgid "B<rateest1> I<operator> B<rateest2> B<rateest-pps>(without rate!)"
msgstr "B<rateest1> I<operator> B<rateest2> B<rateest-pps>(without rate!)"

#. type: Plain text
msgid "(B<rateest1> minus B<rateest-bps1>) I<operator> (B<rateest2> minus B<rateest-bps2>)"
msgstr "(B<rateest1> minus B<rateest-bps1>) I<operator> (B<rateest2> minus B<rateest-bps2>)"

#. type: Plain text
msgid "(B<rateest1> minus B<rateest-pps1>) I<operator> (B<rateest2> minus B<rateest-pps2>)"
msgstr "(B<rateest1> minus B<rateest-pps1>) I<operator> (B<rateest2> minus B<rateest-pps2>)"

#. type: TP
#, no-wrap
msgid "B<--rateest-delta>"
msgstr "B<--rateest-delta>"

#. type: Plain text
msgid "For each estimator (either absolute or relative mode), calculate the difference between the estimator-determined flow rate and the static value chosen with the BPS/PPS options. If the flow rate is higher than the specified BPS/PPS, 0 will be used instead of a negative value. In other words, \"max(0, rateest#_rate - rateest#_bps)\" is used."
msgstr "(絶対モードでも相対モードでも) 各レート推測器について、 レート推測器が推測したフローレートと BPS/PPS オプションで指定された固定値の差分を計算する。 フローレートが指定された BPS/PPS よりも大きい場合、 負の値ではなく 0 が代わりに使用される。 つまり \"max(0, rateest#_rate - rateest#_bps)\" が使用される。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--rateest-lt>"
msgstr "[B<!>] B<--rateest-lt>"

#. type: Plain text
msgid "Match if rate is less than given rate/estimator."
msgstr "レートが指定されたレートかレート推測器のレートよりも低い場合にマッチする。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--rateest-gt>"
msgstr "[B<!>] B<--rateest-gt>"

#. type: Plain text
msgid "Match if rate is greater than given rate/estimator."
msgstr "レートが指定されたレートかレート推測器のレートよりも高い場合にマッチする。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--rateest-eq>"
msgstr "[B<!>] B<--rateest-eq>"

#. type: Plain text
msgid "Match if rate is equal to given rate/estimator."
msgstr "レートが指定されたレートかレート推測器のレートと等しい場合にマッチする。"

#. type: Plain text
msgid "In the so-called \"absolute mode\", only one rate estimator is used and compared against a static value, while in \"relative mode\", two rate estimators are compared against another."
msgstr "いわゆる「絶対モード」では、使用できるレート推測器は一つだけであり、固定値に対する比較だけができる。一方、「相対モード」では、2 つのレート推測器が使用でき、レート推測器どうしの比較ができる。"

#. type: TP
#, no-wrap
msgid "B<--rateest> I<name>"
msgstr "B<--rateest> I<name>"

#. type: Plain text
msgid "Name of the one rate estimator for absolute mode."
msgstr "絶対モードで使用するレート推測器の名前"

#. type: TP
#, no-wrap
msgid "B<--rateest1> I<name>"
msgstr "B<--rateest1> I<name>"

#. type: TP
#, no-wrap
msgid "B<--rateest2> I<name>"
msgstr "B<--rateest2> I<name>"

#. type: Plain text
msgid "The names of the two rate estimators for relative mode."
msgstr "相対モードで使用する 2 つレート推測器の名前"

#. type: TP
#, no-wrap
msgid "B<--rateest-bps> [I<value>]"
msgstr "B<--rateest-bps> [I<value>]"

#. type: TP
#, no-wrap
msgid "B<--rateest-pps> [I<value>]"
msgstr "B<--rateest-pps> [I<value>]"

#. type: TP
#, no-wrap
msgid "B<--rateest-bps1> [I<value>]"
msgstr "B<--rateest-bps1> [I<value>]"

#. type: TP
#, no-wrap
msgid "B<--rateest-bps2> [I<value>]"
msgstr "B<--rateest-bps2> [I<value>]"

#. type: TP
#, no-wrap
msgid "B<--rateest-pps1> [I<value>]"
msgstr "B<--rateest-pps1> [I<value>]"

#. type: TP
#, no-wrap
msgid "B<--rateest-pps2> [I<value>]"
msgstr "B<--rateest-pps2> [I<value>]"

#. type: Plain text
msgid "Compare the estimator(s) by bytes or packets per second, and compare against the chosen value. See the above bullet list for which option is to be used in which case. A unit suffix may be used - available ones are: bit, [kmgt]bit, [KMGT]ibit, Bps, [KMGT]Bps, [KMGT]iBps."
msgstr "レート推測器と指定した値を、秒間のバイト数またはパケット数で比較する。 どのオプションがどの場合に使用できるかは上の箇条書きのリストを見てほしい。 単位を示す接尾辞を付けることができる。 bit, [kmgt]bit, [KMGT]ibit, Bps, [KMGT]Bps, [KMGT]iBps が使用できる。"

#. type: Plain text
msgid "Example: This is what can be used to route outgoing data connections from an FTP server over two lines based on the available bandwidth at the time the data connection was started:"
msgstr "例: この機能を、データコネクションの開始時に利用可能帯域に基づいて、 FTP サーバーからの出力データコネクションを 2 つの回線に振り分けるのに使用する場合。"

#. type: Plain text
msgid "# Estimate outgoing rates"
msgstr "# 出力レートを推定する"

#. type: Plain text
msgid "iptables -t mangle -A POSTROUTING -o eth0 -j RATEEST --rateest-name eth0 --rateest-interval 250ms --rateest-ewma 0.5s"
msgstr "iptables -t mangle -A POSTROUTING -o eth0 -j RATEEST --rateest-name eth0 --rateest-interval 250ms --rateest-ewma 0.5s"

#. type: Plain text
msgid "iptables -t mangle -A POSTROUTING -o ppp0 -j RATEEST --rateest-name ppp0 --rateest-interval 250ms --rateest-ewma 0.5s"
msgstr "iptables -t mangle -A POSTROUTING -o ppp0 -j RATEEST --rateest-name ppp0 --rateest-interval 250ms --rateest-ewma 0.5s"

#. type: Plain text
msgid "# Mark based on available bandwidth"
msgstr "# 利用可能帯域に基づいてマーキングを行う"

#. type: Plain text
msgid "iptables -t mangle -A balance -m conntrack --ctstate NEW -m helper --helper ftp -m rateest --rateest-delta --rateest1 eth0 --rateest-bps1 2.5mbit --rateest-gt --rateest2 ppp0 --rateest-bps2 2mbit -j CONNMARK --set-mark 1"
msgstr "iptables -t mangle -A balance -m conntrack --ctstate NEW -m helper --helper ftp -m rateest --rateest-delta --rateest1 eth0 --rateest-bps1 2.5mbit --rateest-gt --rateest2 ppp0 --rateest-bps2 2mbit -j CONNMARK --set-mark 1"

#. type: Plain text
msgid "iptables -t mangle -A balance -m conntrack --ctstate NEW -m helper --helper ftp -m rateest --rateest-delta --rateest1 ppp0 --rateest-bps1 2mbit --rateest-gt --rateest2 eth0 --rateest-bps2 2.5mbit -j CONNMARK --set-mark 2"
msgstr "iptables -t mangle -A balance -m conntrack --ctstate NEW -m helper --helper ftp -m rateest --rateest-delta --rateest1 ppp0 --rateest-bps1 2mbit --rateest-gt --rateest2 eth0 --rateest-bps2 2.5mbit -j CONNMARK --set-mark 2"

#. type: Plain text
msgid "iptables -t mangle -A balance -j CONNMARK --restore-mark"
msgstr "iptables -t mangle -A balance -j CONNMARK --restore-mark"

#. type: SS
#, no-wrap
msgid "realm (IPv4-specific)"
msgstr "realm (IPv4 の場合)"

#. type: Plain text
msgid "This matches the routing realm.  Routing realms are used in complex routing setups involving dynamic routing protocols like BGP."
msgstr ""

#. type: TP
#, no-wrap
msgid "[B<!>] B<--realm> I<value>[B</>I<mask>]"
msgstr "[B<!>] B<--realm> I<value>[B</>I<mask>]"

#. type: Plain text
msgid "Matches a given realm number (and optionally mask). If not a number, value can be a named realm from /etc/iproute2/rt_realms (mask can not be used in that case).  Both value and mask are four byte unsigned integers and may be specified in decimal, hex (by prefixing with \"0x\") or octal (if a leading zero is given)."
msgstr ""

#. type: SS
#, no-wrap
msgid "recent"
msgstr "recent"

#. type: Plain text
msgid "Allows you to dynamically create a list of IP addresses and then match against that list in a few different ways."
msgstr "IP アドレスのリストを動的に作成し、このリストに対するマッチングをいくつかの方法で行う。"

#. type: Plain text
msgid "For example, you can create a \"badguy\" list out of people attempting to connect to port 139 on your firewall and then DROP all future packets from them without considering them."
msgstr "例えば、 あなたのファイアウォールの 139 番ポートに接続しようとした「悪ガキ」リストを作成し、 そのアドレスからのこれ以降のすべてのパケットを「廃棄」する。"

#. type: Plain text
msgid "B<--set>, B<--rcheck>, B<--update> and B<--remove> are mutually exclusive."
msgstr "B<--set>, B<--rcheck>, B<--update>, B<--remove> は同時に使用できない。"

#. type: TP
#, no-wrap
msgid "B<--name> I<name>"
msgstr "B<--name> I<name>"

#. type: Plain text
msgid "Specify the list to use for the commands. If no name is given then B<DEFAULT> will be used."
msgstr "コマンドで使用するリストを指定する。名前が指定されなかった場合 B<DEFAULT> が使用される。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--set>"
msgstr "[B<!>] B<--set>"

#. type: Plain text
msgid "This will add the source address of the packet to the list. If the source address is already in the list, this will update the existing entry. This will always return success (or failure if B<!> is passed in)."
msgstr "リストにパケットの送信元アドレスを追加する。 その送信元アドレスがすでにリストにある場合は、既存のエントリーを更新する。 常に成功を返す (B<!> が指定されている場合は常に失敗を返す)。"

#. type: TP
#, no-wrap
msgid "B<--rsource>"
msgstr "B<--rsource>"

#. type: Plain text
msgid "Match/save the source address of each packet in the recent list table. This is the default."
msgstr "recent リストのテーブルの照合/保存で、各パケットの送信元アドレスを使う。 これがデフォルトである。"

#. type: TP
#, no-wrap
msgid "B<--rdest>"
msgstr "B<--rdest>"

#. type: Plain text
msgid "Match/save the destination address of each packet in the recent list table."
msgstr "recent リストのテーブルの照合/保存で、各パケットの宛先アドレスを使う。"

#. type: TP
#, no-wrap
msgid "B<--mask> I<netmask>"
msgstr "B<--mask> I<netmask>"

#. type: Plain text
msgid "Netmask that will be applied to this recent list."
msgstr "この recent リストに適用するネットマスク。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--rcheck>"
msgstr "[B<!>] B<--rcheck>"

#. type: Plain text
msgid "Check if the source address of the packet is currently in the list."
msgstr "このパケットの送信元アドレスが現在リストに含まれるかをチェックする。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--update>"
msgstr "[B<!>] B<--update>"

#. type: Plain text
msgid "Like B<--rcheck>, except it will update the \"last seen\" timestamp if it matches."
msgstr "B<--rcheck> と同じだが、 このオプションではマッチした場合に \"last seen\" タイムスタンプを更新する。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--remove>"
msgstr "[B<!>] B<--remove>"

#. type: Plain text
msgid "Check if the source address of the packet is currently in the list and if so that address will be removed from the list and the rule will return true. If the address is not found, false is returned."
msgstr "パケットの送信元アドレスが現在リストに含まれているかをチェックし、 含まれている場合、そのアドレスをリストから削除し、ルールは true を返す。 アドレスが含まれない場合、false を返す。"

#. type: TP
#, no-wrap
msgid "B<--seconds> I<seconds>"
msgstr "B<--seconds> I<seconds>"

#. type: Plain text
msgid "This option must be used in conjunction with one of B<--rcheck> or B<--update>. When used, this will narrow the match to only happen when the address is in the list and was seen within the last given number of seconds."
msgstr "このオプションは B<--rcheck> か B<--update> との組み合わせでのみ使用できる。 使用された場合、 アドレスがリストに含まれ、かつそのアドレスが直近の指定された秒数以内に観測された場合にのみ、 マッチするようになる。"

#. type: TP
#, no-wrap
msgid "B<--reap>"
msgstr "B<--reap>"

#. type: Plain text
msgid "This option can only be used in conjunction with B<--seconds>.  When used, this will cause entries older than the last given number of seconds to be purged."
msgstr "このオプションは B<--seconds> との組み合わせでのみ使用できる。 使用された場合、 最後に指定された秒数より古いエントリーを破棄する。"

#. type: TP
#, no-wrap
msgid "B<--hitcount> I<hits>"
msgstr "B<--hitcount> I<hits>"

#. type: Plain text
msgid "This option must be used in conjunction with one of B<--rcheck> or B<--update>. When used, this will narrow the match to only happen when the address is in the list and packets had been received greater than or equal to the given value. This option may be used along with B<--seconds> to create an even narrower match requiring a certain number of hits within a specific time frame. The maximum value for the hitcount parameter is given by the \"ip_pkt_list_tot\" parameter of the xt_recent kernel module. Exceeding this value on the command line will cause the rule to be rejected."
msgstr "このオプションは B<--rcheck> か B<--update> との組み合わせて使用しなければならない。 使用された場合、 アドレスがリストに含まれ、受信されたパケット数が指定した値以上の場合にのみマッチするようになる。 このオプションは B<--seconds> と共に使用することもでき、 その場合は指定された時間内のヒット数に対して照合を行う。 hitcount パラメータの最大値は xt_recent カーネルモードの \"ip_pkt_list_tot\" パラメータで規定される。 このコマンドリストでこの値よりも大きな値を指定すると、そのルールは拒否される。"

#. type: TP
#, no-wrap
msgid "B<--rttl>"
msgstr "B<--rttl>"

#. type: Plain text
msgid "This option may only be used in conjunction with one of B<--rcheck> or B<--update>. When used, this will narrow the match to only happen when the address is in the list and the TTL of the current packet matches that of the packet which hit the B<--set> rule. This may be useful if you have problems with people faking their source address in order to DoS you via this module by disallowing others access to your site by sending bogus packets to you."
msgstr "このオプションは B<--rcheck> か B<--update> との組み合わせでのみ使用できる。 使用された場合、 アドレスがリストに含まれ、かつ現在のパケットの TTL が B<--set> ルールにヒットしたパケットの TTL にマッチする場合にのみマッチするようになる。 このオプションは、 送信元アドレスを偽装する人が偽りのパケットを送信して、このモジュールを使ってあなたのサイトへの他のアクセスができないようにする DoS 攻撃がある場合などに役に立つかもしれない。"

#. type: Plain text
msgid "iptables -A FORWARD -m recent --name badguy --rcheck --seconds 60 -j DROP"
msgstr "iptables -A FORWARD -m recent --name badguy --rcheck --seconds 60 -j DROP"

#. type: Plain text
msgid "iptables -A FORWARD -p tcp -i eth0 --dport 139 -m recent --name badguy --set -j DROP"
msgstr "iptables -A FORWARD -p tcp -i eth0 --dport 139 -m recent --name badguy --set -j DROP"

#. type: Plain text
msgid "B</proc/net/xt_recent/*> are the current lists of addresses and information about each entry of each list."
msgstr "B</proc/net/xt_recent/*> は現在のアドレスのリストと各リストの各エントリーの情報である。"

#. type: Plain text
msgid "Each file in B</proc/net/xt_recent/> can be read from to see the current list or written two using the following commands to modify the list:"
msgstr "B</proc/net/xt_recent/> の各ファイルは、読み出して現在のリストを確認することができる。 また、以下のコマンドを使って、 これらのファイルに書き込んでリストを変更することができる。"

#. type: TP
#, no-wrap
msgid "B<echo +>I<addr>B< E<gt>/proc/net/xt_recent/DEFAULT>"
msgstr "B<echo +>I<addr>B< E<gt>/proc/net/xt_recent/DEFAULT>"

#. type: Plain text
msgid "to add I<addr> to the DEFAULT list"
msgstr "DEFAULT リストに I<addr> を追加する"

#. type: TP
#, no-wrap
msgid "B<echo ->I<addr>B< E<gt>/proc/net/xt_recent/DEFAULT>"
msgstr "B<echo ->I<addr>B< E<gt>/proc/net/xt_recent/DEFAULT>"

#. type: Plain text
msgid "to remove I<addr> from the DEFAULT list"
msgstr "DEFAULT リストから I<addr> を削除する"

#. type: TP
#, no-wrap
msgid "B<echo / E<gt>/proc/net/xt_recent/DEFAULT>"
msgstr "B<echo / E<gt>/proc/net/xt_recent/DEFAULT>"

#. type: Plain text
msgid "to flush the DEFAULT list (remove all entries)."
msgstr "DEFAULT リストをフラッシュ (全エントリーを削除) する"

#. type: Plain text
msgid "The module itself accepts parameters, defaults shown:"
msgstr "モジュール自体もパラメーターを取り、デフォルトは以下の通りである。"

#. type: TP
#, no-wrap
msgid "B<ip_list_tot>=I<100>"
msgstr "B<ip_list_tot>=I<100>"

#. type: Plain text
msgid "Number of addresses remembered per table."
msgstr "テーブル単位の記録アドレス数。"

#. type: TP
#, no-wrap
msgid "B<ip_pkt_list_tot>=I<20>"
msgstr "B<ip_pkt_list_tot>=I<20>"

#. type: Plain text
msgid "Number of packets per address remembered."
msgstr "アドレス単位の記録パケット数。"

#. type: TP
#, no-wrap
msgid "B<ip_list_hash_size>=I<0>"
msgstr "B<ip_list_hash_size>=I<0>"

#. type: Plain text
msgid "Hash table size. 0 means to calculate it based on ip_list_tot, default: 512."
msgstr "ハッシュテーブルサイズ。 0 は ip_list_tot に基づいて計算することを意味する。 デフォルトは 512。"

#. type: TP
#, no-wrap
msgid "B<ip_list_perms>=I<0644>"
msgstr "B<ip_list_perms>=I<0644>"

#. type: Plain text
msgid "Permissions for /proc/net/xt_recent/* files."
msgstr "/proc/net/xt_recent/* ファイルのアクセス許可モード。"

#. type: TP
#, no-wrap
msgid "B<ip_list_uid>=I<0>"
msgstr "B<ip_list_uid>=I<0>"

#. type: Plain text
msgid "Numerical UID for ownership of /proc/net/xt_recent/* files."
msgstr "/proc/net/xt_recent/* ファイルの数値 ID での所有者。"

#. type: TP
#, no-wrap
msgid "B<ip_list_gid>=I<0>"
msgstr "B<ip_list_gid>=I<0>"

#. type: Plain text
msgid "Numerical GID for ownership of /proc/net/xt_recent/* files."
msgstr "/proc/net/xt_recent/* ファイルの数値 ID でのグループ所有者。"

#. type: SS
#, no-wrap
msgid "rpfilter"
msgstr "rpfilter"

#. type: Plain text
msgid "Performs a reverse path filter test on a packet.  If a reply to the packet would be sent via the same interface that the packet arrived on, the packet will match.  Note that, unlike the in-kernel rp_filter, packets protected by IPSec are not treated specially.  Combine this match with the policy match if you want this.  Also, packets arriving via the loopback interface are always permitted.  This match can only be used in the PREROUTING chain of the raw or mangle table."
msgstr "パケットに対して reverse path フィルターテストを行う。 パケットに対する応答がパケットが到着したインターフェースと同じインターフェースから送信される場合、そのパケットにマッチする。 カーネル内の rp_filter と異なり、 IPsec で保護されたパケットが特別扱いされない点に注意すること。 必要な場合は、このマッチをポリシーマッチと組み合わせて使うこと。 また、ループバックインターフェース経由で到着したパケットは常に許可される。 このマッチは raw テーブルまたは mangle テーブルの PREROUTING チェインでのみ使用できる。"

#. type: TP
#, no-wrap
msgid "B<--loose>"
msgstr "B<--loose>"

#. type: Plain text
msgid "Used to specify that the reverse path filter test should match even if the selected output device is not the expected one."
msgstr "選択された出力デバイスが期待されたものではない場合であっても、 reverse path フィルターテストのマッチを行うことを指示する。"

#. type: TP
#, no-wrap
msgid "B<--validmark>"
msgstr "B<--validmark>"

#. type: Plain text
msgid "Also use the packets' nfmark value when performing the reverse path route lookup."
msgstr "reverse path の経路検索実行時にそのパケットの nfmark 値も使用する。"

#. type: TP
#, no-wrap
msgid "B<--accept-local>"
msgstr "B<--accept-local>"

#. type: Plain text
msgid "This will permit packets arriving from the network with a source address that is also assigned to the local machine."
msgstr "ローカルマシンにも割り当てられている送信元アドレスを持つネットワークから到着したパケットを許可する。"

#. type: TP
#, no-wrap
msgid "B<--invert>"
msgstr "B<--invert>"

#. type: Plain text
msgid "This will invert the sense of the match.  Instead of matching packets that passed the reverse path filter test, match those that have failed it."
msgstr "マッチの意味を逆にする。 reverse path フィルターテストに合格したパケットにマッチするのではなく、テストに失敗したパケットにマッチする。"

#. type: Plain text
msgid "Example to log and drop packets failing the reverse path filter test:"
msgstr "reverse path フィルターテストに失敗したパケットをロギングし破棄する例"

#. type: Plain text
msgid "iptables -t raw -N RPFILTER"
msgstr "iptables -t raw -N RPFILTER"

#. type: Plain text
msgid "iptables -t raw -A RPFILTER -m rpfilter -j RETURN"
msgstr "iptables -t raw -A RPFILTER -m rpfilter -j RETURN"

#. type: Plain text
msgid "iptables -t raw -A RPFILTER -m limit --limit 10/minute -j NFLOG --nflog-prefix \"rpfilter drop\""
msgstr "iptables -t raw -A RPFILTER -m limit --limit 10/minute -j NFLOG --nflog-prefix \"rpfilter drop\""

#. type: Plain text
msgid "iptables -t raw -A RPFILTER -j DROP"
msgstr "iptables -t raw -A RPFILTER -j DROP"

#. type: Plain text
msgid "iptables -t raw -A PREROUTING -j RPFILTER"
msgstr "iptables -t raw -A PREROUTING -j RPFILTER"

#. type: Plain text
msgid "Example to drop failed packets, without logging:"
msgstr "失敗したパケットをドロップするが、ロギングを行わない例"

#. type: Plain text
msgid "iptables -t raw -A RPFILTER -m rpfilter --invert -j DROP"
msgstr "iptables -t raw -A RPFILTER -m rpfilter --invert -j DROP"

#. type: SS
#, no-wrap
msgid "rt (IPv6-specific)"
msgstr "rt (IPv6 のみ)"

#. type: Plain text
msgid "Match on IPv6 routing header"
msgstr "IPv6 ルーティングヘッダーに対してマッチする。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--rt-type> I<type>"
msgstr "[B<!>] B<--rt-type> I<type>"

#. type: Plain text
msgid "Match the type (numeric)."
msgstr "指定したタイプ (数値) にマッチする。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--rt-segsleft> I<num>[B<:>I<num>]"
msgstr "[B<!>] B<--rt-segsleft> I<num>[B<:>I<num>]"

#. type: Plain text
msgid "Match the `segments left' field (range)."
msgstr "`segments left' フィールド (範囲) にマッチする。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--rt-len> I<length>"
msgstr "[B<!>] B<--rt-len> I<length>"

#. type: Plain text
msgid "Match the length of this header."
msgstr "このヘッダーの長さにマッチする。"

#. type: TP
#, no-wrap
msgid "B<--rt-0-res>"
msgstr "B<--rt-0-res>"

#. type: Plain text
msgid "Match the reserved field, too (type=0)"
msgstr "予約フィールド (type=0) にもマッチする。"

#. type: TP
#, no-wrap
msgid "B<--rt-0-addrs> I<addr>[B<,>I<addr>...]"
msgstr "B<--rt-0-addrs> I<addr>[B<,>I<addr>...]"

#. type: Plain text
msgid "Match type=0 addresses (list)."
msgstr "type=0 のアドレス (リスト) にマッチする。"

#. type: TP
#, no-wrap
msgid "B<--rt-0-not-strict>"
msgstr "B<--rt-0-not-strict>"

#. type: Plain text
msgid "List of type=0 addresses is not a strict list."
msgstr "type=0 のアドレスのリストは厳密なリストではない。"

#. type: SS
#, no-wrap
msgid "sctp"
msgstr "sctp"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--chunk-types> {B<all>|B<any>|B<only>} I<chunktype>[B<:>I<flags>] [...]"
msgstr "[B<!>] B<--chunk-types> {B<all>|B<any>|B<only>} I<chunktype>[B<:>I<flags>] [...]"

#. type: Plain text
msgid "The flag letter in upper case indicates that the flag is to match if set, in the lower case indicates to match if unset."
msgstr "大文字のフラグ文字はそのフラグがセットされている場合にマッチし、 小文字のフラグ文字はセットされていない場合にマッチすることを指示する。"

#. type: Plain text
msgid "Chunk types: DATA INIT INIT_ACK SACK HEARTBEAT HEARTBEAT_ACK ABORT SHUTDOWN SHUTDOWN_ACK ERROR COOKIE_ECHO COOKIE_ACK ECN_ECNE ECN_CWR SHUTDOWN_COMPLETE ASCONF ASCONF_ACK FORWARD_TSN"
msgstr "チャンク種別: DATA INIT INIT_ACK SACK HEARTBEAT HEARTBEAT_ACK ABORT SHUTDOWN SHUTDOWN_ACK ERROR COOKIE_ECHO COOKIE_ACK ECN_ECNE ECN_CWR SHUTDOWN_COMPLETE ASCONF ASCONF_ACK FORWARD_TSN"

#. type: Plain text
msgid "chunk type available flags"
msgstr "チャンク種別で利用可能なフラグ"

#. type: Plain text
msgid "DATA I U B E i u b e"
msgstr "DATA I U B E i u b e"

#. type: Plain text
msgid "ABORT T t"
msgstr "ABORT T t"

#. type: Plain text
msgid "SHUTDOWN_COMPLETE T t"
msgstr "SHUTDOWN_COMPLETE T t"

#. type: Plain text
msgid "(lowercase means flag should be \"off\", uppercase means \"on\")"
msgstr "(小文字はフラグを「オフ」にすることを、大文字は「オン」にすることを意味する)"

#. type: Plain text
msgid "iptables -A INPUT -p sctp --dport 80 -j DROP"
msgstr "iptables -A INPUT -p sctp --dport 80 -j DROP"

#. type: Plain text
msgid "iptables -A INPUT -p sctp --chunk-types any DATA,INIT -j DROP"
msgstr "iptables -A INPUT -p sctp --chunk-types any DATA,INIT -j DROP"

#. type: Plain text
msgid "iptables -A INPUT -p sctp --chunk-types any DATA:Be -j ACCEPT"
msgstr "iptables -A INPUT -p sctp --chunk-types any DATA:Be -j ACCEPT"

#. type: SS
#, no-wrap
msgid "set"
msgstr "set"

#. type: Plain text
msgid "This module matches IP sets which can be defined by ipset(8)."
msgstr "このモジュールは B<ipsec>(8) で定義できる IP 集合にマッチする。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--match-set> I<setname> I<flag>[B<,>I<flag>]..."
msgstr "[B<!>] B<--match-set> I<setname> I<flag>[B<,>I<flag>]..."

#. type: Plain text
msgid "where flags are the comma separated list of B<src> and/or B<dst> specifications and there can be no more than six of them. Hence the command"
msgstr ""

#. type: Plain text
#, no-wrap
msgid " iptables -A FORWARD -m set --match-set test src,dst\n"
msgstr " iptables -A FORWARD -m set --match-set test src,dst\n"

#. type: Plain text
msgid "will match packets, for which (if the set type is ipportmap) the source address and destination port pair can be found in the specified set. If the set type of the specified set is single dimension (for example ipmap), then the command will match packets for which the source address can be found in the specified set."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<--return-nomatch>"
msgstr "B<--return-nomatch>"

#. type: Plain text
msgid "If the B<--return-nomatch> option is specified and the set type supports the B<nomatch> flag, then the matching is reversed: a match with an element flagged with B<nomatch> returns B<true>, while a match with a plain element returns B<false>."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<!> B<--update-counters>"
msgstr "B<!> B<--update-counters>"

#. type: Plain text
msgid "If the B<--update-counters> flag is negated, then the packet and byte counters of the matching element in the set won't be updated. Default the packet and byte counters are updated."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<!> B<--update-subcounters>"
msgstr "B<!> B<--update-subcounters>"

#. type: Plain text
msgid "If the B<--update-subcounters> flag is negated, then the packet and byte counters of the matching element in the member set of a list type of set won't be updated. Default the packet and byte counters are updated."
msgstr ""

#. type: TP
#, no-wrap
msgid "[B<!>] B<--packets-eq> I<value>"
msgstr "[B<!>] B<--packets-eq> I<value>"

#. type: Plain text
msgid "If the packet is matched an element in the set, match only if the packet counter of the element matches the given value too."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<--packets-lt> I<value>"
msgstr "B<--packets-lt> I<value>"

#. type: Plain text
msgid "If the packet is matched an element in the set, match only if the packet counter of the element is less than the given value as well."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<--packets-gt> I<value>"
msgstr "B<--packets-gt> I<value>"

#. type: Plain text
msgid "If the packet is matched an element in the set, match only if the packet counter of the element is greater than the given value as well."
msgstr ""

#. type: TP
#, no-wrap
msgid "[B<!>] B<--bytes-eq> I<value>"
msgstr "[B<!>] B<--bytes-eq> I<value>"

#. type: Plain text
msgid "If the packet is matched an element in the set, match only if the byte counter of the element matches the given value too."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<--bytes-lt> I<value>"
msgstr "B<--bytes-lt> I<value>"

#. type: Plain text
msgid "If the packet is matched an element in the set, match only if the byte counter of the element is less than the given value as well."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<--bytes-gt> I<value>"
msgstr "B<--bytes-gt> I<value>"

#. type: Plain text
msgid "If the packet is matched an element in the set, match only if the byte counter of the element is greater than the given value as well."
msgstr ""

#. type: Plain text
msgid "The packet and byte counters related options and flags are ignored when the set was defined without counter support."
msgstr ""

#. type: Plain text
msgid "The option B<--match-set> can be replaced by B<--set> if that does not clash with an option of other extensions."
msgstr ""

#. type: Plain text
msgid "Use of -m set requires that ipset kernel support is provided, which, for standard kernels, is the case since Linux 2.6.39."
msgstr ""

#. type: SS
#, no-wrap
msgid "socket"
msgstr "socket"

#. type: Plain text
msgid "This matches if an open TCP/UDP socket can be found by doing a socket lookup on the packet. It matches if there is an established or non-zero bound listening socket (possibly with a non-local address). The lookup is performed using the B<packet> tuple of TCP/UDP packets, or the original TCP/UDP header B<embedded> in an ICMP/ICPMv6 error packet."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<--transparent>"
msgstr "B<--transparent>"

#. type: Plain text
msgid "Ignore non-transparent sockets."
msgstr "非透過 (non-transparent) ソケットを無視する。"

#. type: TP
#, no-wrap
msgid "B<--nowildcard>"
msgstr "B<--nowildcard>"

#. type: Plain text
msgid "Do not ignore sockets bound to 'any' address.  The socket match won't accept zero-bound listeners by default, since then local services could intercept traffic that would otherwise be forwarded.  This option therefore has security implications when used to match traffic being forwarded to redirect such packets to local machine with policy routing.  When using the socket match to implement fully transparent proxies bound to non-local addresses it is recommended to use the --transparent option instead."
msgstr ""

#. type: Plain text
msgid "Example (assuming packets with mark 1 are delivered locally):"
msgstr ""

#. type: Plain text
msgid "-t mangle -A PREROUTING -m socket --transparent -j MARK --set-mark 1"
msgstr "-t mangle -A PREROUTING -m socket --transparent -j MARK --set-mark 1"

#. type: TP
#, no-wrap
msgid "B<--restore-skmark>"
msgstr "B<--restore-skmark>"

#. type: Plain text
msgid "Set the packet mark to the matching socket's mark. Can be combined with the B<--transparent> and B<--nowildcard> options to restrict the sockets to be matched when restoring the packet mark."
msgstr ""

#. type: Plain text
msgid "Example: An application opens 2 transparent (B<IP_TRANSPARENT>) sockets and sets a mark on them with B<SO_MARK> socket option. We can filter matching packets:"
msgstr ""

#. type: Plain text
msgid "-t mangle -I PREROUTING -m socket --transparent --restore-skmark -j action"
msgstr "-t mangle -I PREROUTING -m socket --transparent --restore-skmark -j action"

#. type: Plain text
msgid "-t mangle -A action -m mark --mark 10 -j action2"
msgstr ""

#. type: Plain text
msgid "-t mangle -A action -m mark --mark 11 -j action3"
msgstr ""

#. type: SS
#, no-wrap
msgid "state"
msgstr "state"

#. type: Plain text
msgid "The \"state\" extension is a subset of the \"conntrack\" module.  \"state\" allows access to the connection tracking state for this packet."
msgstr "\"state\" 拡張は \"conntrack\" モジュールのサブセットである。 \"state\" を使うと、 パケットについてのコネクション追跡状態を参照できる。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--state> I<state>"
msgstr "[B<!>] B<--state> I<state>"

#. type: Plain text
msgid "Where state is a comma separated list of the connection states to match. Only a subset of the states unterstood by \"conntrack\" are recognized: B<INVALID>, B<ESTABLISHED>, B<NEW>, B<RELATED> or B<UNTRACKED>. For their description, see the \"conntrack\" heading in this manpage."
msgstr "state はマッチするコネクション状態のカンマ区切りのリストである。 \"conntrack\" が理解できる状態の一部だけが指定できる。 指定できるのは B<INVALID>, B<ESTABLISHED>, B<NEW>, B<RELATED>, B<UNTRACKED> である。 これらの説明はこのマニュアルページの \"conntrack\" の説明を参照のこと。"

#. type: SS
#, no-wrap
msgid "statistic"
msgstr "statistic"

#. type: Plain text
msgid "This module matches packets based on some statistic condition.  It supports two distinct modes settable with the B<--mode> option."
msgstr "このモジュールは統計的な条件に基づいたパケットのマッチングを行う。 二つのモードがサポートされており、 B<--mode> オプションで設定できる。"

#. type: Plain text
msgid "Supported options:"
msgstr "サポートされているオプション:"

#. type: TP
#, no-wrap
msgid "B<--mode> I<mode>"
msgstr "B<--mode> I<mode>"

#. type: Plain text
msgid "Set the matching mode of the matching rule, supported modes are B<random> and B<nth.>"
msgstr "マッチングルールのマッチングモードを設定する。 サポートされているモードは B<random> と B<nth> である。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--probability> I<p>"
msgstr "[B<!>] B<--probability> I<p>"

#. type: Plain text
msgid "Set the probability for a packet to be randomly matched. It only works with the B<random> mode. I<p> must be within 0.0 and 1.0. The supported granularity is in 1/2147483648th increments."
msgstr "ランダムにパケットがマッチする確率を設定する。 B<random> モードでのみ機能する。 I<p> は 0.0 と 1.0 の範囲でなければならない。 サポートされている粒度は 1/2147483648 である。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--every> I<n>"
msgstr "[B<!>] B<--every> I<n>"

#. type: Plain text
msgid "Match one packet every nth packet. It works only with the B<nth> mode (see also the B<--packet> option)."
msgstr "n パケットに 1 つマッチする。 B<nth> モードでのみ機能する (B<--packet> オプションも参照)。"

#. type: TP
#, no-wrap
msgid "B<--packet> I<p>"
msgstr "B<--packet> I<p>"

#. type: Plain text
msgid "Set the initial counter value (0 E<lt>= p E<lt>= n-1, default 0) for the B<nth> mode."
msgstr "B<nth> モードでカウンターの初期値を設定する (0 E<lt>= p E<lt>= n-1, デフォルトは 0)。"

#. type: SS
#, no-wrap
msgid "string"
msgstr "string"

#. type: Plain text
msgid "This modules matches a given string by using some pattern matching strategy. It requires a linux kernel E<gt>= 2.6.14."
msgstr "このモジュールは、いくつかのパターンマッチ手法を用いて指定された文字列とのマッチを行う。 Linux カーネル 2.6.14 以上が必要である。"

#. type: TP
#, no-wrap
msgid "B<--algo> {B<bm>|B<kmp>}"
msgstr "B<--algo> {B<bm>|B<kmp>}"

#. type: Plain text
msgid "Select the pattern matching strategy. (bm = Boyer-Moore, kmp = Knuth-Pratt-Morris)"
msgstr "パターンマッチング手法を選択する (bm = Boyer-Moore, kmp = Knuth-Pratt-Morris)"

#. type: TP
#, no-wrap
msgid "B<--from> I<offset>"
msgstr "B<--from> I<offset>"

#. type: Plain text
msgid "Set the offset from which it starts looking for any matching. If not passed, default is 0."
msgstr "マッチングの検索を開始するオフセットを設定する。 指定されなかった場合のデフォルトは 0 である。"

#. type: TP
#, no-wrap
msgid "B<--to> I<offset>"
msgstr "B<--to> I<offset>"

#. type: Plain text
msgid "Set the offset up to which should be scanned. That is, byte I<offset>-1 (counting from 0) is the last one that is scanned.  If not passed, default is the packet size."
msgstr "検索を終了するオフセットを設定する。 バイト I<offset>-1 (バイト番号は 0 から開始) が検索範囲の最終バイトとなる。 指定されなかった場合、デフォルトはパケットサイズである。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--string> I<pattern>"
msgstr "[B<!>] B<--string> I<pattern>"

#. type: Plain text
msgid "Matches the given pattern."
msgstr "指定されたパターンにマッチする。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--hex-string> I<pattern>"
msgstr "[B<!>] B<--hex-string> I<pattern>"

#. type: Plain text
msgid "Matches the given pattern in hex notation."
msgstr "指定された 16 進表記のパターンにマッチする。"

#. type: TP
#, no-wrap
msgid "B<--icase>"
msgstr "B<--icase>"

#. type: Plain text
msgid "Ignore case when searching."
msgstr ""

#. type: Plain text
msgid "# The string pattern can be used for simple text characters."
msgstr "# 文字列パターンは単純なテキスト文字を探すのに使用できる。"

#. type: Plain text
msgid "iptables -A INPUT -p tcp --dport 80 -m string --algo bm --string 'GET /index.html' -j LOG"
msgstr "iptables -A INPUT -p tcp --dport 80 -m string --algo bm --string 'GET /index.html' -j LOG"

#. type: Plain text
msgid "# The hex string pattern can be used for non-printable characters, like |0D 0A| or |0D0A|."
msgstr "16 進数文字列のパターンは表示可能文字以外を検索するのに使用できる。 |0D 0A| や |0D0A| など。"

#. type: Plain text
msgid "iptables -p udp --dport 53 -m string --algo bm --from 40 --to 57 --hex-string '|03|www|09|netfilter|03|org|00|'"
msgstr "iptables -p udp --dport 53 -m string --algo bm --from 40 --to 57 --hex-string '|03|www|09|netfilter|03|org|00|'"

#. type: SS
#, no-wrap
msgid "tcp"
msgstr "tcp"

#. type: Plain text
msgid "These extensions can be used if `--protocol tcp' is specified. It provides the following options:"
msgstr "これらの拡張は `--protocol tcp' が指定され場合に使用できる。 以下のオプションが提供される:"

#. type: Plain text
msgid "Source port or port range specification. This can either be a service name or a port number. An inclusive range can also be specified, using the format I<first>B<:>I<last>.  If the first port is omitted, \"0\" is assumed; if the last is omitted, \"65535\" is assumed.  The flag B<--sport> is a convenient alias for this option."
msgstr "送信元ポートまたはポート範囲の指定。 サービス名またはポート番号を指定できる。 I<first>B<:>I<last> という形式で、 2 つの番号を含む範囲を指定することもできる。 最初のポートを省略した場合、 \"0\" を仮定する。 最後のポートを省略した場合、 \"65535\" を仮定する。 フラグ B<--sport> は、 このオプションの便利な別名である。"

#. type: Plain text
msgid "Destination port or port range specification.  The flag B<--dport> is a convenient alias for this option."
msgstr "宛先ポートまたはポート範囲の指定。 フラグ B<--dport> は、 このオプションの便利な別名である。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--tcp-flags> I<mask> I<comp>"
msgstr "[B<!>] B<--tcp-flags> I<mask> I<comp>"

#. type: Plain text
msgid "Match when the TCP flags are as specified.  The first argument I<mask> is the flags which we should examine, written as a comma-separated list, and the second argument I<comp> is a comma-separated list of flags which must be set.  Flags are: B<SYN ACK FIN RST URG PSH ALL NONE>.  Hence the command"
msgstr "TCP フラグが指定されたものと等しい場合にマッチする。 第 1 引き数 I<mask> は評価対象とするフラグで、 コンマ区切りのリストである。 第 2 引き数 I<comp> は必ず設定しなければならないフラグで、 コンマ区切りのリストである。 指定できるフラグは B<SYN ACK FIN RST URG PSH ALL NONE> である。 よって、 コマンド"

#. type: Plain text
#, no-wrap
msgid " iptables -A FORWARD -p tcp --tcp-flags SYN,ACK,FIN,RST SYN\n"
msgstr " iptables -A FORWARD -p tcp --tcp-flags SYN,ACK,FIN,RST SYN\n"

#. type: Plain text
msgid "will only match packets with the SYN flag set, and the ACK, FIN and RST flags unset."
msgstr "は、 SYN フラグが設定され ACK, FIN, RST フラグが設定されていない パケットにのみマッチする。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--syn>"
msgstr "[B<!>] B<--syn>"

#. type: Plain text
msgid "Only match TCP packets with the SYN bit set and the ACK,RST and FIN bits cleared.  Such packets are used to request TCP connection initiation; for example, blocking such packets coming in an interface will prevent incoming TCP connections, but outgoing TCP connections will be unaffected.  It is equivalent to B<--tcp-flags SYN,RST,ACK,FIN SYN>.  If the \"!\" flag precedes the \"--syn\", the sense of the option is inverted."
msgstr ""
"SYN ビットが設定され ACK, RST, FIN ビットがクリアされている TCP パケットにのみマッチする。 このようなパケットは TCP コネクションの開始要求に使われる。 例えば、 あるインターフェースに入ってくるこのようなパケットをブロックすれば、 内側への TCP コネクションは禁止されるが、 外側への TCP コネクションには影響しない。 これは B<--tcp-flags SYN,RST,ACK,FIN SYN> と等しい。 \"--syn\" の前に \"!\" フラグ\n"
"を置くと、 SYN ビットがクリアされ ACK と RST ビットが設定されている\n"
"TCP パケットにのみマッチする。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--tcp-option> I<number>"
msgstr "[B<!>] B<--tcp-option> I<number>"

#. type: Plain text
msgid "Match if TCP option set."
msgstr "TCP オプションが設定されている場合にマッチする。"

#. type: SS
#, no-wrap
msgid "tcpmss"
msgstr "tcpmss"

#. type: Plain text
msgid "This matches the TCP MSS (maximum segment size) field of the TCP header.  You can only use this on TCP SYN or SYN/ACK packets, since the MSS is only negotiated during the TCP handshake at connection startup time."
msgstr "TCP ヘッダーの TCP MSS (maximum segment size) フィールドにマッチする。 TCP の SYN パケットか SYN/ACK パケットに対してのみ利用できる。 MSS のネゴシエーションはコネクション開始時の TCP ハンドシェイク中だけだからである。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--mss> I<value>[B<:>I<value>]"
msgstr "[B<!>] B<--mss> I<value>[B<:>I<value>]"

#. type: Plain text
msgid "Match a given TCP MSS value or range. If a range is given, the second I<value> must be greater than or equal to the first I<value>."
msgstr ""

#. type: SS
#, no-wrap
msgid "time"
msgstr "time"

#. type: Plain text
msgid "This matches if the packet arrival time/date is within a given range. All options are optional, but are ANDed when specified. All times are interpreted as UTC by default."
msgstr "このモジュールはパケットの到着時刻/日付が指定された範囲内の場合にマッチする。 すべてのオプションが任意オプションで、 複数指定した場合は AND と解釈される。 デフォルトではすべての時刻は UTC と解釈される。"

#. type: TP
#, no-wrap
msgid "B<--datestart> I<YYYY>[B<->I<MM>[B<->I<DD>[B<T>I<hh>[B<:>I<mm>[B<:>I<ss>]]]]]"
msgstr "B<--datestart> I<YYYY>[B<->I<MM>[B<->I<DD>[B<T>I<hh>[B<:>I<mm>[B<:>I<ss>]]]]]"

#. type: TP
#, no-wrap
msgid "B<--datestop> I<YYYY>[B<->I<MM>[B<->I<DD>[B<T>I<hh>[B<:>I<mm>[B<:>I<ss>]]]]]"
msgstr "B<--datestop> I<YYYY>[B<->I<MM>[B<->I<DD>[B<T>I<hh>[B<:>I<mm>[B<:>I<ss>]]]]]"

#. type: Plain text
msgid "Only match during the given time, which must be in ISO 8601 \"T\" notation.  The possible time range is 1970-01-01T00:00:00 to 2038-01-19T04:17:07."
msgstr "指定された時刻 (日付も含む) の範囲にある場合にマッチする。 時刻は ISO 8601 \"T\" 表記でなければならない。 指定可能な範囲は 1970-01-01T00:00:00 から 2038-01-19T04:17:07 である。"

#. type: Plain text
msgid "If --datestart or --datestop are not specified, it will default to 1970-01-01 and 2038-01-19, respectively."
msgstr "--datestart と --datestop は、指定されなかった場合、それぞれ 1970-01-01 と 2038-01-19 とみなされます。"

#. type: TP
#, no-wrap
msgid "B<--timestart> I<hh>B<:>I<mm>[B<:>I<ss>]"
msgstr "B<--timestart> I<hh>B<:>I<mm>[B<:>I<ss>]"

#. type: TP
#, no-wrap
msgid "B<--timestop> I<hh>B<:>I<mm>[B<:>I<ss>]"
msgstr "B<--timestop> I<hh>B<:>I<mm>[B<:>I<ss>]"

#. type: Plain text
msgid "Only match during the given daytime. The possible time range is 00:00:00 to 23:59:59. Leading zeroes are allowed (e.g. \"06:03\") and correctly interpreted as base-10."
msgstr "指定された時刻 (日付は含まない) の範囲にある場合にマッチする。 指定可能な範囲は 00:00:00 から 23:59:59 である。 (\"06:03\" のように) 先頭に 0 を付けてもよい。 この場合も 10 進数として正しく解釈される。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--monthdays> I<day>[B<,>I<day>...]"
msgstr "[B<!>] B<--monthdays> I<day>[B<,>I<day>...]"

#. type: Plain text
msgid "Only match on the given days of the month. Possible values are B<1> to B<31>. Note that specifying B<31> will of course not match on months which do not have a 31st day; the same goes for 28- or 29-day February."
msgstr "指定された月の日付にマッチする。 指定可能な値は B<1> から B<31> である。 もちろん B<31> を指定した場合 31 日がない月ではマッチしない。 同じことが 2 月 29 日についても言える。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--weekdays> I<day>[B<,>I<day>...]"
msgstr "[B<!>] B<--weekdays> I<day>[B<,>I<day>...]"

#. type: Plain text
msgid "Only match on the given weekdays. Possible values are B<Mon>, B<Tue>, B<Wed>, B<Thu>, B<Fri>, B<Sat>, B<Sun>, or values from B<1> to B<7>, respectively. You may also use two-character variants (B<Mo>, B<Tu>, etc.)."
msgstr "指定した曜日にマッチする。 指定可能な値は B<Mon>, B<Tue>, B<Wed>, B<Thu>, B<Fri>, B<Sat>, B<Sun> および B<1> から B<7> の値である。 また、2 文字の曜日指定 (B<Mo>, B<Tu> など) も使用できる。"

#. type: TP
#, no-wrap
msgid "B<--contiguous>"
msgstr "B<--contiguous>"

#. type: Plain text
msgid "When B<--timestop> is smaller than B<--timestart> value, match this as a single time period instead distinct intervals.  See EXAMPLES."
msgstr "B<--timestop> が B<--timestart> よりも小さい場合、複数の期間ではなく、一つの時間帯としてマッチするようにする。 例を参照。"

#. type: TP
#, no-wrap
msgid "B<--kerneltz>"
msgstr "B<--kerneltz>"

#. type: Plain text
msgid "Use the kernel timezone instead of UTC to determine whether a packet meets the time regulations."
msgstr "パケットが時刻指定にマッチするかを判定する際に UTC ではなくカーネルタイムゾーンを使用する。"

#. type: Plain text
msgid "About kernel timezones: Linux keeps the system time in UTC, and always does so.  On boot, system time is initialized from a referential time source. Where this time source has no timezone information, such as the x86 CMOS RTC, UTC will be assumed. If the time source is however not in UTC, userspace should provide the correct system time and timezone to the kernel once it has the information."
msgstr ""

#. type: Plain text
msgid "Local time is a feature on top of the (timezone independent) system time. Each process has its own idea of local time, specified via the TZ environment variable. The kernel also has its own timezone offset variable. The TZ userspace environment variable specifies how the UTC-based system time is displayed, e.g. when you run date(1), or what you see on your desktop clock.  The TZ string may resolve to different offsets at different dates, which is what enables the automatic time-jumping in userspace. when DST changes. The kernel's timezone offset variable is used when it has to convert between non-UTC sources, such as FAT filesystems, to UTC (since the latter is what the rest of the system uses)."
msgstr ""

#. type: Plain text
msgid "The caveat with the kernel timezone is that Linux distributions may ignore to set the kernel timezone, and instead only set the system time. Even if a particular distribution does set the timezone at boot, it is usually does not keep the kernel timezone offset - which is what changes on DST - up to date.  ntpd will not touch the kernel timezone, so running it will not resolve the issue. As such, one may encounter a timezone that is always +0000, or one that is wrong half of the time of the year. As such, B<using --kerneltz is highly discouraged.>"
msgstr ""

#. type: Plain text
msgid "EXAMPLES. To match on weekends, use:"
msgstr "例をいくつか。 週末にマッチさせる場合:"

#. type: Plain text
msgid "-m time --weekdays Sa,Su"
msgstr "-m time --weekdays Sa,Su"

#. type: Plain text
msgid "Or, to match (once) on a national holiday block:"
msgstr "国の祝日に (一度だけ) マッチさせる場合:"

#. type: Plain text
msgid "-m time --datestart 2007-12-24 --datestop 2007-12-27"
msgstr "-m time --datestart 2007-12-24 --datestop 2007-12-27"

#. type: Plain text
msgid "Since the stop time is actually inclusive, you would need the following stop time to not match the first second of the new day:"
msgstr "終了時刻も実際には含まれるので、新年の最初の 1 秒にマッチしないように終了時刻を以下のように指定する必要がある:"

#. type: Plain text
msgid "-m time --datestart 2007-01-01T17:00 --datestop 2007-01-01T23:59:59"
msgstr "-m time --datestart 2007-01-01T17:00 --datestop 2007-01-01T23:59:59"

#. type: Plain text
msgid "During lunch hour:"
msgstr "昼御飯の時間帯:"

#. type: Plain text
msgid "-m time --timestart 12:30 --timestop 13:30"
msgstr "-m time --timestart 12:30 --timestop 13:30"

#. type: Plain text
msgid "The fourth Friday in the month:"
msgstr "第 4 金曜日:"

#. type: Plain text
msgid "-m time --weekdays Fr --monthdays 22,23,24,25,26,27,28"
msgstr "-m time --weekdays Fr --monthdays 22,23,24,25,26,27,28"

#. type: Plain text
msgid "(Note that this exploits a certain mathematical property. It is not possible to say \"fourth Thursday OR fourth Friday\" in one rule. It is possible with multiple rules, though.)"
msgstr "(これは数学的な性質を利用している点に留意すること。 一つのルールで「第 4 木曜日 または 第 4 金曜日」と指定することはできない。 複数ルールで指定することはできるが。)"

#. type: Plain text
msgid "Matching across days might not do what is expected.  For instance,"
msgstr "日をまたぐマッチングは期待するようには動かないだろう。例えば、"

#. type: Plain text
msgid "-m time --weekdays Mo --timestart 23:00 --timestop 01:00 Will match Monday, for one hour from midnight to 1 a.m., and then again for another hour from 23:00 onwards.  If this is unwanted, e.g. if you would like 'match for two hours from Montay 23:00 onwards' you need to also specify the --contiguous option in the example above."
msgstr "-m time --weekdays Mo --timestart 23:00 --timestop 01:00 は、月曜日の 0 時から午前 1 時の 1 時間にマッチし、 その後さらに 23 時からの 1 時間にもマッチする。 これが希望通りでない場合、例えば、月曜日 23 時から 2 時間にマッチさせたい場合は、 上記に追加で --contiguous オプションも指定する必要がある。"

#. type: SS
#, no-wrap
msgid "tos"
msgstr "tos"

#. type: Plain text
msgid "This module matches the 8-bit Type of Service field in the IPv4 header (i.e.  including the \"Precedence\" bits) or the (also 8-bit) Priority field in the IPv6 header."
msgstr "このモジュールは IPv4 ヘッダーの 8 ビットの Type of Service フィールド (すなわち上位ビットを含まれる) もしくは IPv6 ヘッダーの (8 ビットの) Priority フィールドにマッチする。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--tos> I<value>[B</>I<mask>]"
msgstr "[B<!>] B<--tos> I<value>[B</>I<mask>]"

#. type: Plain text
msgid "Matches packets with the given TOS mark value. If a mask is specified, it is logically ANDed with the TOS mark before the comparison."
msgstr "指定された TOS マーク値を持つパケットにマッチする。 mask が指定されると、 比較の前に TOS マーク値との論理積 (AND) がとられる)。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--tos> I<symbol>"
msgstr "[B<!>] B<--tos> I<symbol>"

#. type: Plain text
msgid "You can specify a symbolic name when using the tos match for IPv4. The list of recognized TOS names can be obtained by calling iptables with B<-m tos -h>.  Note that this implies a mask of 0x3F, i.e. all but the ECN bits."
msgstr ""
"IPv4 の tos フィールドに対するマッチを指定する際にシンボル名を使うことができる。 iptables を B<-m tos -h> で呼び出すと、利用可能な TOS 名の一覧を得ることができる。\n"
"シンボル名を使った場合、 mask として 0x3F が使用される (0x3F は ECN ビット以外の全ビットである)。"

#. type: SS
#, no-wrap
msgid "ttl (IPv4-specific)"
msgstr "ttl (IPv4 の場合)"

#. type: Plain text
msgid "This module matches the time to live field in the IP header."
msgstr "このモジュールは IP ヘッダーの time to live フィールドにマッチする。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--ttl-eq> I<ttl>"
msgstr "[B<!>] B<--ttl-eq> I<ttl>"

#. type: Plain text
msgid "Matches the given TTL value."
msgstr "指定された TTL 値にマッチする。"

#. type: TP
#, no-wrap
msgid "B<--ttl-gt> I<ttl>"
msgstr "B<--ttl-gt> I<ttl>"

#. type: Plain text
msgid "Matches if TTL is greater than the given TTL value."
msgstr "TTL が指定された TTL 値より大きければマッチする。"

#. type: TP
#, no-wrap
msgid "B<--ttl-lt> I<ttl>"
msgstr "B<--ttl-lt> I<ttl>"

#. type: Plain text
msgid "Matches if TTL is less than the given TTL value."
msgstr "TTL が指定された TTL 値より小さければマッチする。"

#. type: SS
#, no-wrap
msgid "u32"
msgstr "u32"

#. type: Plain text
msgid "U32 tests whether quantities of up to 4 bytes extracted from a packet have specified values. The specification of what to extract is general enough to find data at given offsets from tcp headers or payloads."
msgstr "U32 は、パケットから最大 4 バイトの数値を取り出して、指定した値を持つかの検査を行う。 どこを取り出すかの指定は汎用的になっており、TCP ヘッダーやペイロードから指定したオフセットのデータを取り出すことができる。"

#. type: TP
#, no-wrap
msgid "[B<!>] B<--u32> I<tests>"
msgstr "[B<!>] B<--u32> I<tests>"

#. type: Plain text
msgid "The argument amounts to a program in a small language described below."
msgstr "引き数は、以下で説明する小さな言語のプログラムになる。"

#. type: Plain text
msgid "tests := location \"=\" value | tests \"&&\" location \"=\" value"
msgstr "tests := location \"=\" value | tests \"&&\" location \"=\" value"

#. type: Plain text
msgid "value := range | value \",\" range"
msgstr "value := range | value \",\" range"

#. type: Plain text
msgid "range := number | number \":\" number"
msgstr "range := number | number \":\" number"

#. type: Plain text
msgid "a single number, I<n>, is interpreted the same as I<n:n>. I<n:m> is interpreted as the range of numbers B<E<gt>=n> and B<E<lt>=m>."
msgstr "数字 1 個 I<n> は I<n:n> と同じものと解釈される。 I<n:m> は B<E<gt>=n> かつ B<E<lt>=m> の範囲の数字と解釈される。"

#. type: Plain text
msgid "location := number | location operator number"
msgstr "location := number | location operator number"

#. type: Plain text
msgid "operator := \"&\" | \"E<lt>E<lt>\" | \"E<gt>E<gt>\" | \"@\""
msgstr "operator := \"&\" | \"E<lt>E<lt>\" | \"E<gt>E<gt>\" | \"@\""

#. type: Plain text
msgid "The operators B<&>, B<E<lt>E<lt>>, B<E<gt>E<gt>> and B<&&> mean the same as in C.  The B<=> is really a set membership operator and the value syntax describes a set. The B<@> operator is what allows moving to the next header and is described further below."
msgstr "オペレーター B<&>, B<E<lt>E<lt>>, B<E<gt>E<gt>>, B<&&> は C と同じ意味である。 B<=> は集合の所属を検査するオペレーターで、値は集合として記述する。 B<@> オペレーターは、次のヘッダーへの移動に使うオペレーターで、後で詳しく説明する。"

#. type: Plain text
msgid "There are currently some artificial implementation limits on the size of the tests:"
msgstr "現在のところ、テストの大きさにはいくつか実装から来る制約がある。"

#. type: IP
#, no-wrap
msgid "    *"
msgstr "    *"

#. type: Plain text
msgid "no more than 10 of \"B<=>\" (and 9 \"B<&&>\"s) in the u32 argument"
msgstr "u32 引き数あたりの \"B<=>\" は最大 10 個まで (\"B<&&>\" は 9 個まで)"

#. type: Plain text
msgid "no more than 10 ranges (and 9 commas) per value"
msgstr "value あたりの range は 10 個まで (カンマは 9 個まで)"

#. type: Plain text
msgid "no more than 10 numbers (and 9 operators) per location"
msgstr "一つの location あたりの number は最大 10 個まで (operator は 9 個まで)"

#. type: Plain text
msgid "To describe the meaning of location, imagine the following machine that interprets it. There are three registers:"
msgstr "location の意味を説明するために、 location を解釈する以下のようなマシンを考えてみる。 3 つのレジスターがある。"

#. type: Plain text
msgid "A is of type B<char *>, initially the address of the IP header"
msgstr "A は B<char *> 型で、最初は IP ヘッダーのアドレスが入っている。"

#. type: Plain text
msgid "B and C are unsigned 32 bit integers, initially zero"
msgstr "B と C は 32 ビット整数で、最初は 0 である。"

#. type: Plain text
msgid "The instructions are:"
msgstr "命令は以下の通り。"

#. type: TP
#, no-wrap
msgid "B<number>"
msgstr "B<number>"

#. type: Plain text
msgid "B = number;"
msgstr "B = number;"

#. type: Plain text
msgid "C = (*(A+B)E<lt>E<lt>24) + (*(A+B+1)E<lt>E<lt>16) + (*(A+B+2)E<lt>E<lt>8) + *(A+B+3)"
msgstr "C = (*(A+B)E<lt>E<lt>24) + (*(A+B+1)E<lt>E<lt>16) + (*(A+B+2)E<lt>E<lt>8) + *(A+B+3)"

#. type: TP
#, no-wrap
msgid "B<&number>"
msgstr "B<&number>"

#. type: Plain text
msgid "C = C & number"
msgstr "C = C & number"

#. type: TP
#, no-wrap
msgid "B<E<lt>E<lt> number>"
msgstr "B<E<lt>E<lt> number>"

#. type: Plain text
msgid "C = C E<lt>E<lt> number"
msgstr "C = C E<lt>E<lt> number"

#. type: TP
#, no-wrap
msgid "B<E<gt>E<gt> number>"
msgstr "B<E<gt>E<gt> number>"

#. type: Plain text
msgid "C = C E<gt>E<gt> number"
msgstr "C = C E<gt>E<gt> number"

#. type: TP
#, no-wrap
msgid "B<@number>"
msgstr "B<@number>"

#. type: Plain text
msgid "A = A + C; then do the instruction number"
msgstr "A = A + C; then do the instruction number"

#. type: Plain text
msgid "Any access of memory outside [skb-E<gt>data,skb-E<gt>end] causes the match to fail.  Otherwise the result of the computation is the final value of C."
msgstr "[skb-E<gt>data,skb-E<gt>end] 以外へのメモリアクセスはすべてマッチ失敗となる。 それ以外の場合、計算の結果が C の最終的な値となる。"

#. type: Plain text
msgid "Whitespace is allowed but not required in the tests. However, the characters that do occur there are likely to require shell quoting, so it is a good idea to enclose the arguments in quotes."
msgstr "ホワイトスペースを入れることはできるが、テストでは必須ではない。 しただし、テストに含まれる文字はシェルでのクォートが必要な場合もよくあるので、 引き数全体をクォートで囲んでおくとよいだろう。"

#. type: Plain text
msgid "match IP packets with total length E<gt>= 256"
msgstr "トータル長が 256 以上の IP パケットにマッチする"

#. type: Plain text
msgid "The IP header contains a total length field in bytes 2-3."
msgstr "IP ヘッダーではバイト 2-3 にトータル長フィールドがある。"

#. type: Plain text
msgid "--u32 \"B<0 & 0xFFFF = 0x100:0xFFFF>\""
msgstr "--u32 \"B<0 & 0xFFFF = 0x100:0xFFFF>\""

#. type: Plain text
msgid "read bytes 0-3"
msgstr "バイト 0-3 を読み出し、"

#. type: Plain text
msgid "AND that with 0xFFFF (giving bytes 2-3), and test whether that is in the range [0x100:0xFFFF]"
msgstr "0xFFFF (バイト 2-3 に対応) の論理積 (AND) を取り、 その値が範囲 [0x100:0xFFFF] にあるか検査する。"

#. type: Plain text
msgid "Example: (more realistic, hence more complicated)"
msgstr "例: (もっと実用的な、したがってもっと複雑な例)"

#. type: Plain text
msgid "match ICMP packets with icmp type 0"
msgstr "ICMP タイプが 0 の ICMP パケットにマッチする"

#. type: Plain text
msgid "First test that it is an ICMP packet, true iff byte 9 (protocol) = 1"
msgstr "まず ICMP パケットかどうか検査する。 バイト 9 (プロトコル) = 1 であれば真。"

#. type: Plain text
msgid "--u32 \"B<6 & 0xFF = 1 &&> ..."
msgstr "--u32 \"B<6 & 0xFF = 1 &&> ..."

#. type: Plain text
msgid "read bytes 6-9, use B<&> to throw away bytes 6-8 and compare the result to 1. Next test that it is not a fragment. (If so, it might be part of such a packet but we cannot always tell.) N.B.: This test is generally needed if you want to match anything beyond the IP header. The last 6 bits of byte 6 and all of byte 7 are 0 iff this is a complete packet (not a fragment). Alternatively, you can allow first fragments by only testing the last 5 bits of byte 6."
msgstr "バイト 6-9 を読み出し、 B<&> を使ってバイト 6-8 を取り除き、 得られた値を 1 と比較する。 次に、フラグメントではないことを検査する (フラグメントの場合、パケットは ICMP パケットの一部かもしれないが、 常にそうだとは言えない)。 B<注意>: 一般的に IP ヘッダーより先にあるものとマッチを行う場合にはこの検査は必要である。 このパケットが (フラグメントではない) 完全なパケットであれば、バイト 6 の最後の 6 ビットとバイト 7 の全ビットが 0 である。 代わりに、 バイト 6 の最後の 5 ビットを検査するだけで最初のフラグメントを許可することができる。"

#. type: Plain text
msgid "... B<4 & 0x3FFF = 0 &&> ..."
msgstr "... B<4 & 0x3FFF = 0 &&> ..."

#. type: Plain text
msgid "Last test: the first byte past the IP header (the type) is 0. This is where we have to use the @syntax. The length of the IP header (IHL) in 32 bit words is stored in the right half of byte 0 of the IP header itself."
msgstr "最後の検査として、 IP ヘッダー直後のバイト (ICMP タイプ) が 0 かを確認する。 ここで @ 記法を使う必要がある。 IP ヘッダーの長さ (IHL) は IP ヘッダー自身のバイト 0 の右半分に 32 ビットワードで格納されている。"

#. type: Plain text
msgid "... B<0 E<gt>E<gt> 22 & 0x3C @ 0 E<gt>E<gt> 24 = 0>\""
msgstr "... B<0 E<gt>E<gt> 22 & 0x3C @ 0 E<gt>E<gt> 24 = 0>\""

#. type: Plain text
msgid "The first 0 means read bytes 0-3, B<E<gt>E<gt>22> means shift that 22 bits to the right. Shifting 24 bits would give the first byte, so only 22 bits is four times that plus a few more bits. B<&3C> then eliminates the two extra bits on the right and the first four bits of the first byte. For instance, if IHL=5, then the IP header is 20 (4 x 5) bytes long. In this case, bytes 0-1 are (in binary) xxxx0101 yyzzzzzz, B<E<gt>E<gt>22> gives the 10 bit value xxxx0101yy and B<&3C> gives 010100. B<@> means to use this number as a new offset into the packet, and read four bytes starting from there. This is the first 4 bytes of the ICMP payload, of which byte 0 is the ICMP type. Therefore, we simply shift the value 24 to the right to throw out all but the first byte and compare the result with 0."
msgstr "最初の 0 はバイト 0-3 を読み出し、 B<E<gt>E<gt>22> はその値を 22 ビット右にシフトすることを意味する。 24 ビットシフトすると最初のバイトが得られるので、 22 ビットだけシフトすると (少し余計なビットが付いているが) その 4 倍の値が得られる。 B<&3C> で右側の余計な 2 ビットと最初のバイトの先頭 4 ビットを取り除く。 例えば、 IHL が 5 の場合 IP ヘッダーは 20 バイト (4 x 5) である。 この場合、バイト 0-1 は (バイナリで) xxxx0101 yyzzzzzz であり、 B<E<gt>E<gt>22> により 10 ビットの値 xxxx0101yy が得られ、 B<&3C> で 010100 が得られる。 B<@> は、この数字をパケットの新しいオフセットとして使用し、 この地点から始まる 4 バイトを読み出すことを意味する。 この 4 バイトは ICMP ペイロードの最初の 4 バイトであり、 バイト 0 が ICMP タイプである。 したがって、この値を 24 ビット右にシフトして、最初のバイト以外をすべて取り除き、 その結果を 0 と比較するだけでよい。"

#. type: Plain text
msgid "TCP payload bytes 8-12 is any of 1, 2, 5 or 8"
msgstr "TCP ペイロードのバイト 8-12 が 1, 2, 5, 8 のいずれかかを検査する"

#. type: Plain text
msgid "First we test that the packet is a tcp packet (similar to ICMP)."
msgstr "まず、パケットが TCP パケットであるかを検査する (ICMP と同様)。"

#. type: Plain text
msgid "--u32 \"B<6 & 0xFF = 6 &&> ..."
msgstr "--u32 \"B<6 & 0xFF = 6 &&> ..."

#. type: Plain text
msgid "Next, test that it is not a fragment (same as above)."
msgstr "次に、フラグメントでないことを検査する (上記と同じ)。"

#. type: Plain text
msgid "... B<0 E<gt>E<gt> 22 & 0x3C @ 12 E<gt>E<gt> 26 & 0x3C @ 8 = 1,2,5,8>\""
msgstr "... B<0 E<gt>E<gt> 22 & 0x3C @ 12 E<gt>E<gt> 26 & 0x3C @ 8 = 1,2,5,8>\""

#. type: Plain text
msgid "B<0E<gt>E<gt>22&3C> as above computes the number of bytes in the IP header. B<@> makes this the new offset into the packet, which is the start of the TCP header. The length of the TCP header (again in 32 bit words) is the left half of byte 12 of the TCP header. The B<12E<gt>E<gt>26&3C> computes this length in bytes (similar to the IP header before). \"@\" makes this the new offset, which is the start of the TCP payload. Finally, 8 reads bytes 8-12 of the payload and B<=> checks whether the result is any of 1, 2, 5 or 8."
msgstr "上で説明した通り B<0E<gt>E<gt>22&3C> で IP ヘッダーのバイト数を計算する。 B<@> でこの値をパケットの新しいオフセットとし、これは TCP ヘッダーの先頭である。 TCP ヘッダー長 (これも 32 ビットワード) は TCP ヘッダーのバイト 12 の左半分にある。 B<12E<gt>E<gt>26&3C> で TCP ヘッダーのバイト数を計算する (IP ヘッダーの場合と同様)。 \"@\" を使ってこれを新しいオフセットに設定する。この時点で TCP ペイロードの先頭を指している。 最後に、8 でペイロードのバイト 8-12 を読み出し、 B<=> を使って取り出した値が 1, 2, 5, 8 のいずれかであるかチェックする。"

#. type: SS
#, no-wrap
msgid "udp"
msgstr "udp"

#. type: Plain text
msgid "These extensions can be used if `--protocol udp' is specified. It provides the following options:"
msgstr "これらの拡張は `--protocol udp' が指定された場合に利用できる。 以下のオプションが提供される。"

#. type: Plain text
msgid "Source port or port range specification.  See the description of the B<--source-port> option of the TCP extension for details."
msgstr "送信元ポートまたはポート範囲の指定。 詳細は TCP 拡張の B<--source-port> オプションの説明を参照すること。"

#. type: Plain text
msgid "Destination port or port range specification.  See the description of the B<--destination-port> option of the TCP extension for details."
msgstr "宛先ポートまたはポート範囲の指定。 詳細は TCP 拡張の B<--destination-port> オプションの説明を参照すること。"

#. type: SH
#, no-wrap
msgid "TARGET EXTENSIONS"
msgstr "ターゲットの拡張"

#.  @TARGET@
#. type: Plain text
msgid "iptables can use extended target modules: the following are included in the standard distribution."
msgstr "iptables は拡張ターゲットモジュールを使うことができる: 以下のものが、 標準的なディストリビューションに含まれている。"

#. type: SS
#, no-wrap
msgid "AUDIT"
msgstr "AUDIT"

#. type: Plain text
msgid "This target allows to create audit records for packets hitting the target.  It can be used to record accepted, dropped, and rejected packets. See auditd(8) for additional details."
msgstr "このターゲットを使うと、このターゲットにヒットしたパケットに対する監査 (audit) レコードを作成することができる。 許可/廃棄/拒否されたパケットを記録するのに使用できる。 詳細については auditd(8) を参照。"

#. type: TP
#, no-wrap
msgid "B<--type> {B<accept>|B<drop>|B<reject>}"
msgstr "B<--type> {B<accept>|B<drop>|B<reject>}"

#. type: Plain text
msgid "Set type of audit record. Starting with linux-4.12, this option has no effect on generated audit messages anymore. It is still accepted by iptables for compatibility reasons, but ignored."
msgstr ""

#. type: Plain text
msgid "iptables -N AUDIT_DROP"
msgstr "iptables -N AUDIT_DROP"

#. type: Plain text
msgid "iptables -A AUDIT_DROP -j AUDIT"
msgstr "iptables -A AUDIT_DROP -j AUDIT"

#. type: Plain text
msgid "iptables -A AUDIT_DROP -j DROP"
msgstr "iptables -A AUDIT_DROP -j DROP"

#. type: SS
#, no-wrap
msgid "CHECKSUM"
msgstr "CHECKSUM"

#. type: Plain text
msgid "This target allows to selectively work around broken/old applications.  It can only be used in the mangle table."
msgstr "このターゲットは、 おかしいアプリケーションや古いアプリケーションに対する選択的な対処を可能にする。 mangle テーブルでのみ使用できる。"

#. type: TP
#, no-wrap
msgid "B<--checksum-fill>"
msgstr "B<--checksum-fill>"

#. type: Plain text
msgid "Compute and fill in the checksum in a packet that lacks a checksum.  This is particularly useful, if you need to work around old applications such as dhcp clients, that do not work well with checksum offloads, but don't want to disable checksum offload in your device."
msgstr ""

#. type: SS
#, no-wrap
msgid "CLASSIFY"
msgstr "CLASSIFY"

#. type: Plain text
msgid "This module allows you to set the skb-E<gt>priority value (and thus classify the packet into a specific CBQ class)."
msgstr "このモジュールを使うと skb-E<gt>priority の値を設定できる (その結果、そのパケットを特定の CBQ クラスに分類できる)。"

#. type: TP
#, no-wrap
msgid "B<--set-class> I<major>B<:>I<minor>"
msgstr "B<--set-class> I<major>B<:>I<minor>"

#. type: Plain text
msgid "Set the major and minor class value. The values are always interpreted as hexadecimal even if no 0x prefix is given."
msgstr "メジャークラスとマイナークラスの値を設定する。値は常に 16 進数として解釈される。  0x が前に付いていない場合であっても 16 進数と解釈される。"

#. type: SS
#, no-wrap
msgid "CLUSTERIP (IPv4-specific)"
msgstr "CLUSTERIP (IPv4 の場合)"

#. type: Plain text
msgid "This module allows you to configure a simple cluster of nodes that share a certain IP and MAC address without an explicit load balancer in front of them.  Connections are statically distributed between the nodes in this cluster."
msgstr "このモジュールを使うと、 ノードの前段に明示的に負荷分散装置を置かずに、 特定の IP アドレスと MAC アドレスを共有するノードの簡単なクラスターを構成することができる。 コネクションは、このクラスターのノード間で静的に分散される。"

#. type: TP
#, no-wrap
msgid "B<--new>"
msgstr "B<--new>"

#. type: Plain text
msgid "Create a new ClusterIP.  You always have to set this on the first rule for a given ClusterIP."
msgstr "新しい ClusterIP を作成する。 このオプションは、ここで指定する ClusterIP を使うルールの中で一番最初に設定しなければならない。"

#. type: TP
#, no-wrap
msgid "B<--hashmode> I<mode>"
msgstr "B<--hashmode> I<mode>"

#. type: Plain text
msgid "Specify the hashing mode.  Has to be one of B<sourceip>, B<sourceip-sourceport>, B<sourceip-sourceport-destport>."
msgstr "ハッシュモードを指定する。 B<sourceip>, B<sourceip-sourceport>, B<sourceip-sourceport-destport> のいずれかでなければならない。"

#. type: TP
#, no-wrap
msgid "B<--clustermac> I<mac>"
msgstr "B<--clustermac> I<mac>"

#. type: Plain text
msgid "Specify the ClusterIP MAC address. Has to be a link-layer multicast address"
msgstr "ClusterIP の MAC アドレスを指定する。 リンク層のマルチキャストアドレスでなければならない。"

#. type: TP
#, no-wrap
msgid "B<--total-nodes> I<num>"
msgstr "B<--total-nodes> I<num>"

#. type: Plain text
msgid "Number of total nodes within this cluster."
msgstr "このクラスターの総ノード数。"

#. type: TP
#, no-wrap
msgid "B<--local-node> I<num>"
msgstr "B<--local-node> I<num>"

#. type: Plain text
msgid "Local node number within this cluster."
msgstr "このクラスターのローカルノード番号。"

#. type: TP
#, no-wrap
msgid "B<--hash-init> I<rnd>"
msgstr "B<--hash-init> I<rnd>"

#. type: Plain text
msgid "Specify the random seed used for hash initialization."
msgstr "ハッシュの初期化に使用される乱数シード値を指定する。"

#. type: SS
#, no-wrap
msgid "CONNMARK"
msgstr "CONNMARK"

#. type: Plain text
msgid "This module sets the netfilter mark value associated with a connection. The mark is 32 bits wide."
msgstr "このモジュールは、 コネクションに関連付けられた netfilter の mark 値を設定する。 mark は 32 ビット幅である。"

#. type: TP
#, no-wrap
msgid "B<--set-xmark> I<value>[B</>I<mask>]"
msgstr "B<--set-xmark> I<value>[B</>I<mask>]"

#. type: Plain text
msgid "Zero out the bits given by I<mask> and XOR I<value> into the ctmark."
msgstr "I<mask> で指定されたビットを 0 にし、 I<value> と ctmark の XOR を取る。"

#. type: TP
#, no-wrap
msgid "B<--save-mark> [B<--nfmask> I<nfmask>] [B<--ctmask> I<ctmask>]"
msgstr "B<--save-mark> [B<--nfmask> I<nfmask>] [B<--ctmask> I<ctmask>]"

#. type: Plain text
msgid "Copy the packet mark (nfmark) to the connection mark (ctmark) using the given masks. The new nfmark value is determined as follows:"
msgstr "指定されたマスクを使って、 パケットマーク (nfmark) をコネクションマーク (ctmark) にコピーする。 新しい ctmark 値は以下のように決定される。"

#. type: Plain text
msgid "ctmark = (ctmark & ~ctmask) ^ (nfmark & nfmask)"
msgstr "ctmark = (ctmark & ~ctmask) ^ (nfmark & nfmask)"

#. type: Plain text
msgid "i.e. I<ctmask> defines what bits to clear and I<nfmask> what bits of the nfmark to XOR into the ctmark. I<ctmask> and I<nfmask> default to 0xFFFFFFFF."
msgstr "I<ctmask> はどのビットをクリアするかを規定し、 I<nfmask> は nfmark のどのビットを ctmark と XOR するかを規定する。 I<ctmask> と I<nfmask> のデフォルト値は 0xFFFFFFFF である。"

#. type: TP
#, no-wrap
msgid "B<--restore-mark> [B<--nfmask> I<nfmask>] [B<--ctmask> I<ctmask>]"
msgstr "B<--restore-mark> [B<--nfmask> I<nfmask>] [B<--ctmask> I<ctmask>]"

#. type: Plain text
msgid "Copy the connection mark (ctmark) to the packet mark (nfmark) using the given masks. The new ctmark value is determined as follows:"
msgstr "指定されたマスクを使って、 コネクションマーク (ctmark) をパケットマーク (nfmark) にコピーする。 新しい nfmark 値は以下のように決定される。"

#. type: Plain text
msgid "nfmark = (nfmark & ~I<nfmask>) ^ (ctmark & I<ctmask>);"
msgstr "nfmark = (nfmark & ~I<nfmask>) ^ (ctmark & I<ctmask>);"

#. type: Plain text
msgid "i.e. I<nfmask> defines what bits to clear and I<ctmask> what bits of the ctmark to XOR into the nfmark. I<ctmask> and I<nfmask> default to 0xFFFFFFFF."
msgstr "I<nfmask> はどのビットをクリアするかを規定し、 I<ctmask> は ctmark のどのビットを nfmark と XOR するかを規定する。 I<ctmask> と I<nfmask> のデフォルト値は 0xFFFFFFFF である。"

#. type: Plain text
msgid "B<--restore-mark> is only valid in the B<mangle> table."
msgstr "B<--restore-mark> は B<mangle> テーブルでのみ有効である。"

#. type: Plain text
msgid "The following mnemonics are available for B<--set-xmark>:"
msgstr "以下の簡易表現が B<--set-xmark> の代わりに利用できる。"

#. type: TP
#, no-wrap
msgid "B<--and-mark> I<bits>"
msgstr "B<--and-mark> I<bits>"

#. type: Plain text
msgid "Binary AND the ctmark with I<bits>. (Mnemonic for B<--set-xmark 0/>I<invbits>, where I<invbits> is the binary negation of I<bits>.)"
msgstr "ctmark と I<bits> のビット論理積 (AND) を取る (B<--set-xmark 0/>I<invbits> の簡易表現、 I<invbits> は I<bits> のビット単位の否定である)。"

#. type: TP
#, no-wrap
msgid "B<--or-mark> I<bits>"
msgstr "B<--or-mark> I<bits>"

#. type: Plain text
msgid "Binary OR the ctmark with I<bits>. (Mnemonic for B<--set-xmark> I<bits>B</>I<bits>.)"
msgstr "ctmark と I<bits> のビット論理和 (OR) を取る (B<--set-xmark> I<bits>B</>I<bits> の簡易表現)。"

#. type: TP
#, no-wrap
msgid "B<--xor-mark> I<bits>"
msgstr "B<--xor-mark> I<bits>"

#. type: Plain text
msgid "Binary XOR the ctmark with I<bits>. (Mnemonic for B<--set-xmark> I<bits>B</0>.)"
msgstr "ctmark と I<bits> のビット XOR を取る (B<--set-xmark> I<bits>B</0> の簡易表現)。"

#. type: TP
#, no-wrap
msgid "B<--set-mark> I<value>[B</>I<mask>]"
msgstr "B<--set-mark> I<value>[B</>I<mask>]"

#. type: Plain text
msgid "Set the connection mark. If a mask is specified then only those bits set in the mask are modified."
msgstr "コネクションマークを設定する。 mask が指定された場合、 mask で指定されたビットだけが変更される。"

#. type: TP
#, no-wrap
msgid "B<--save-mark> [B<--mask> I<mask>]"
msgstr "B<--save-mark> [B<--mask> I<mask>]"

#. type: Plain text
msgid "Copy the nfmark to the ctmark. If a mask is specified, only those bits are copied."
msgstr "nfmark を ctmark へコピーする。 mask が指定された場合、そのビットだけがコピーされる。"

#. type: TP
#, no-wrap
msgid "B<--restore-mark> [B<--mask> I<mask>]"
msgstr "B<--restore-mark> [B<--mask> I<mask>]"

#. type: Plain text
msgid "Copy the ctmark to the nfmark. If a mask is specified, only those bits are copied. This is only valid in the B<mangle> table."
msgstr "ctmark を nfmark にコピーする。 mask が指定されると、 指定されたビットだけがコピーされる。 B<mangle> テーブルのみで有効である。"

#. type: SS
#, no-wrap
msgid "CONNSECMARK"
msgstr "CONNSECMARK"

#. type: Plain text
msgid "This module copies security markings from packets to connections (if unlabeled), and from connections back to packets (also only if unlabeled).  Typically used in conjunction with SECMARK, it is valid in the B<security> table (for backwards compatibility with older kernels, it is also valid in the B<mangle> table)."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<--save>"
msgstr "B<--save>"

#. type: Plain text
msgid "If the packet has a security marking, copy it to the connection if the connection is not marked."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<--restore>"
msgstr "B<--restore>"

#. type: Plain text
msgid "If the packet does not have a security marking, and the connection does, copy the security marking from the connection to the packet."
msgstr ""

#. type: SS
#, no-wrap
msgid "CT"
msgstr "CT"

#. type: Plain text
msgid "The CT target allows to set parameters for a packet or its associated connection. The target attaches a \"template\" connection tracking entry to the packet, which is then used by the conntrack core when initializing a new ct entry. This target is thus only valid in the \"raw\" table."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<--notrack>"
msgstr "B<--notrack>"

#. type: Plain text
msgid "Disables connection tracking for this packet."
msgstr "このパケットに対するコネクション追跡を無効にする。"

#. type: TP
#, no-wrap
msgid "B<--helper> I<name>"
msgstr "B<--helper> I<name>"

#. type: Plain text
msgid "Use the helper identified by I<name> for the connection. This is more flexible than loading the conntrack helper modules with preset ports."
msgstr "I<name> で指定されるヘルパーをこのコネクションで使用する。 この方法は、あらかじめ設定したポートに対して conntrack ヘルパーモジュールをロードするよりも柔軟性がある。"

#. type: TP
#, no-wrap
msgid "B<--ctevents> I<event>[B<,>...]"
msgstr "B<--ctevents> I<event>[B<,>...]"

#. type: Plain text
msgid "Only generate the specified conntrack events for this connection. Possible event types are: B<new>, B<related>, B<destroy>, B<reply>, B<assured>, B<protoinfo>, B<helper>, B<mark> (this refers to the ctmark, not nfmark), B<natseqinfo>, B<secmark> (ctsecmark)."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<--expevents> I<event>[B<,>...]"
msgstr "B<--expevents> I<event>[B<,>...]"

#. type: Plain text
msgid "Only generate the specified expectation events for this connection.  Possible event types are: B<new>."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<--zone-orig> {I<id>|B<mark>}"
msgstr "B<--zone-orig> {I<id>|B<mark>}"

#. type: Plain text
msgid "For traffic coming from ORIGINAL direction, assign this packet to zone I<id> and only have lookups done in that zone. If B<mark> is used instead of I<id>, the zone is derived from the packet nfmark."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<--zone-reply> {I<id>|B<mark>}"
msgstr "B<--zone-reply> {I<id>|B<mark>}"

#. type: Plain text
msgid "For traffic coming from REPLY direction, assign this packet to zone I<id> and only have lookups done in that zone. If B<mark> is used instead of I<id>, the zone is derived from the packet nfmark."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<--zone> {I<id>|B<mark>}"
msgstr "B<--zone> {I<id>|B<mark>}"

#. type: Plain text
msgid "Assign this packet to zone I<id> and only have lookups done in that zone.  If B<mark> is used instead of I<id>, the zone is derived from the packet nfmark. By default, packets have zone 0. This option applies to both directions."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<--timeout> I<name>"
msgstr "B<--timeout> I<name>"

#. type: Plain text
msgid "Use the timeout policy identified by I<name> for the connection. This is provides more flexible timeout policy definition than global timeout values available at /proc/sys/net/netfilter/nf_conntrack_*_timeout_*."
msgstr ""

#. type: SS
#, no-wrap
msgid "DNAT"
msgstr "DNAT"

#. type: Plain text
msgid "This target is only valid in the B<nat> table, in the B<PREROUTING> and B<OUTPUT> chains, and user-defined chains which are only called from those chains.  It specifies that the destination address of the packet should be modified (and all future packets in this connection will also be mangled), and rules should cease being examined.  It takes the following options:"
msgstr "このターゲットは B<nat> テーブルの B<PREROUTING>, B<OUTPUT> チェイン、 これらのチェインから呼び出される ユーザー定義チェインのみで有効である。 このターゲットはパケットの宛先アドレスを修正する (このコネクションの以降のパケットも修正して分からなく (mangle) する)。 さらに、 ルールによるチェックを止めさせる。 このターゲットは以下のオプションを取る。"

#. type: TP
#, no-wrap
msgid "B<--to-destination> [I<ipaddr>[B<->I<ipaddr>]][B<:>I<port>[B<->I<port>]]"
msgstr "B<--to-destination> [I<ipaddr>[B<->I<ipaddr>]][B<:>I<port>[B<->I<port>]]"

#. type: Plain text
msgid "which can specify a single new destination IP address, an inclusive range of IP addresses. Optionally a port range, if the rule also specifies one of the following protocols: B<tcp>, B<udp>, B<dccp> or B<sctp>.  If no port range is specified, then the destination port will never be modified. If no IP address is specified then only the destination port will be modified.  In Kernels up to 2.6.10 you can add several --to-destination options. For those kernels, if you specify more than one destination address, either via an address range or multiple --to-destination options, a simple round-robin (one after another in cycle) load balancing takes place between these addresses.  Later Kernels (E<gt>= 2.6.11-rc1) don't have the ability to NAT to multiple ranges anymore."
msgstr "1 つの新しい宛先 IP アドレス、 または IP アドレスの範囲が指定できる。 また、ルールでプロトコルとして B<tcp>, B<udp>, B<dccp>, B<sctp> のいずれが指定されている場合は、ポートの範囲を指定することもできる。 ポートの範囲が指定されていない場合、 宛先ポートは変更されない。 IP アドレスが指定されなかった場合は、 宛先ポートだけが変更される。 2.6.10 以前のカーネルでは、 複数の --to-destination オプションを指定することができる。 これらのカーネルでは、 アドレスの範囲指定や --to-destination オプションの複数回指定により 2 つ以上の宛先アドレスを指定した場合、 それらのアドレスを使った単純なラウンドロビンによる負荷分散が行われる。 それ以降のカーネル (E<gt>= 2.6.11-rc1) には複数の範囲を NAT する機能は存在しない。"

#. type: TP
#, no-wrap
msgid "B<--random>"
msgstr "B<--random>"

#. type: Plain text
msgid "If option B<--random> is used then port mapping will be randomized (kernel E<gt>= 2.6.22)."
msgstr "B<--random> オプションを使用すると、 ポートマッピングがランダム化される (カーネル 2.6.22 以降)。"

#. type: TP
#, no-wrap
msgid "B<--persistent>"
msgstr "B<--persistent>"

#. type: Plain text
msgid "Gives a client the same source-/destination-address for each connection.  This supersedes the SAME target. Support for persistent mappings is available from 2.6.29-rc2."
msgstr "クライアントの各コネクションに同じ送信元アドレス/宛先アドレスを割り当てる。 これは SAME ターゲットよりも優先される。 persistent マッピングのサポートは 2.6.29-rc2 以降で利用可能である。"

#. type: TP
#, no-wrap
msgid "IPv6 support available since Linux kernels E<gt>= 3.7."
msgstr "IPv6 サポートは Linux カーネル 3.7 以降で利用可能である。"

#. type: SS
#, no-wrap
msgid "DNPT (IPv6-specific)"
msgstr "DNPT (IPv6 のみ)"

#. type: Plain text
msgid "Provides stateless destination IPv6-to-IPv6 Network Prefix Translation (as described by RFC 6296)."
msgstr "(RFC 6296 で説明されている) ステートレス IPv6-to-IPv6 宛先ネットワークプレフィックス変換を提供する。"

#. type: Plain text
msgid "You have to use this target in the B<mangle> table, not in the B<nat> table. It takes the following options:"
msgstr "このターゲットは B<nat> テーブルではなく B<mangle> テーブルで使わなければならない。 以下のオプションを取る。"

#. type: TP
#, no-wrap
msgid "B<--src-pfx> [I<prefix/>I<length]>"
msgstr "B<--src-pfx> [I<prefix/>I<length]>"

#. type: Plain text
msgid "Set source prefix that you want to translate and length"
msgstr "変換を行う送信元プレフィックスとその長さを設定する。"

#. type: TP
#, no-wrap
msgid "B<--dst-pfx> [I<prefix/>I<length]>"
msgstr "B<--dst-pfx> [I<prefix/>I<length]>"

#. type: Plain text
msgid "Set destination prefix that you want to use in the translation and length"
msgstr "変換を行う宛先プレフィックスとその長さを設定する。"

#. type: Plain text
msgid "You have to use the SNPT target to undo the translation. Example:"
msgstr "変換を取り消すには SNPT ターゲットを使わなければならない。 例:"

#. type: Plain text
msgid "ip6tables -t mangle -I POSTROUTING -s fd00::/64 \\! -o vboxnet0 -j SNPT --src-pfx fd00::/64 --dst-pfx 2001:e20:2000:40f::/64"
msgstr "ip6tables -t mangle -I POSTROUTING -s fd00::/64 \\! -o vboxnet0 -j SNPT --src-pfx fd00::/64 --dst-pfx 2001:e20:2000:40f::/64"

#. type: Plain text
msgid "ip6tables -t mangle -I PREROUTING -i wlan0 -d 2001:e20:2000:40f::/64 -j DNPT --src-pfx 2001:e20:2000:40f::/64 --dst-pfx fd00::/64"
msgstr "ip6tables -t mangle -I PREROUTING -i wlan0 -d 2001:e20:2000:40f::/64 -j DNPT --src-pfx 2001:e20:2000:40f::/64 --dst-pfx fd00::/64"

#. type: Plain text
msgid "You may need to enable IPv6 neighbor proxy:"
msgstr "IPv6 neighbor proxy を有効にする必要があるかもしれない。"

#. type: Plain text
msgid "sysctl -w net.ipv6.conf.all.proxy_ndp=1"
msgstr "sysctl -w net.ipv6.conf.all.proxy_ndp=1"

#. type: Plain text
msgid "You also have to use the B<NOTRACK> target to disable connection tracking for translated flows."
msgstr "また、変換されたフローに対するコネクション追跡を無効にするには B<NOTRACK> ターゲットを使用する必要がある。"

#. type: SS
#, no-wrap
msgid "DSCP"
msgstr "DSCP"

#. type: Plain text
msgid "This target allows to alter the value of the DSCP bits within the TOS header of the IPv4 packet.  As this manipulates a packet, it can only be used in the mangle table."
msgstr "このターゲットは、 IPv4 パケットの TOS ヘッダーにある DSCP ビットの値の書き換えを可能にする。 これはパケットを操作するので、 mangle テーブルでのみ使用できる。"

#. type: TP
#, no-wrap
msgid "B<--set-dscp> I<value>"
msgstr "B<--set-dscp> I<value>"

#. type: Plain text
msgid "Set the DSCP field to a numerical value (can be decimal or hex)"
msgstr "DSCP フィールドの数値を設定する (10 進または 16 進)。"

#. type: TP
#, no-wrap
msgid "B<--set-dscp-class> I<class>"
msgstr "B<--set-dscp-class> I<class>"

#. type: Plain text
msgid "Set the DSCP field to a DiffServ class."
msgstr "DSCP フィールドの DiffServ クラスを設定する。"

#. type: SS
#, no-wrap
msgid "ECN (IPv4-specific)"
msgstr "ECN (IPv4 の場合)"

#. type: Plain text
msgid "This target allows to selectively work around known ECN blackholes.  It can only be used in the mangle table."
msgstr "このターゲットは ECN ブラックホール問題への対処を可能にする。 mangle テーブルでのみ使用できる。"

#. type: TP
#, no-wrap
msgid "B<--ecn-tcp-remove>"
msgstr "B<--ecn-tcp-remove>"

#. type: Plain text
msgid "Remove all ECN bits from the TCP header.  Of course, it can only be used in conjunction with B<-p tcp>."
msgstr "TCP ヘッダーから全ての ECN ビット (訳注: ECE/CWR フラグ) を取り除く。 当然、 B<-p tcp> オプションとの組合わせでのみ使用できる。"

#. type: SS
#, no-wrap
msgid "HL (IPv6-specific)"
msgstr "HL (IPv6 のみ)"

#. type: Plain text
msgid "This is used to modify the Hop Limit field in IPv6 header. The Hop Limit field is similar to what is known as TTL value in IPv4.  Setting or incrementing the Hop Limit field can potentially be very dangerous, so it should be avoided at any cost. This target is only valid in B<mangle> table."
msgstr "このターゲットを使うと IPv6 ヘッダーの Hop Limit フィールドを変更することができる。 Hop Limit フィールドは IPv4 の TTL 値と同じようなものである。 Hop Limit フィールドを設定したり増やすのは、 危険性を非常にはらんでいる。 したがって、可能な限り避けるべきである。 このターゲットは B<mangle> テーブルでのみ有効である。"

#. type: Plain text
msgid "B<Don't ever set or increment the value on packets that leave your local network!>"
msgstr "B<決してローカルネットワーク内に留まるパケットのフィールド値を設定したり増やしたりしないこと！>"

#. type: TP
#, no-wrap
msgid "B<--hl-set> I<value>"
msgstr "B<--hl-set> I<value>"

#. type: Plain text
msgid "Set the Hop Limit to `value'."
msgstr "Hop Limit を `value' に設定する。"

#. type: TP
#, no-wrap
msgid "B<--hl-dec> I<value>"
msgstr "B<--hl-dec> I<value>"

#. type: Plain text
msgid "Decrement the Hop Limit `value' times."
msgstr "Hop Limit を `value' 回減算する。"

#. type: TP
#, no-wrap
msgid "B<--hl-inc> I<value>"
msgstr "B<--hl-inc> I<value>"

#. type: Plain text
msgid "Increment the Hop Limit `value' times."
msgstr "Hop Limit を `value' 回加算する。"

#. type: SS
#, no-wrap
msgid "HMARK"
msgstr "HMARK"

#. type: Plain text
msgid "Like MARK, i.e. set the fwmark, but the mark is calculated from hashing packet selector at choice. You have also to specify the mark range and, optionally, the offset to start from. ICMP error messages are inspected and used to calculate the hashing."
msgstr ""

#. type: Plain text
msgid "Existing options are:"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<--hmark-tuple> tuple"
msgstr "B<--hmark-tuple> tuple"

#. type: Plain text
msgid "Possible tuple members are: B<src> meaning source address (IPv4, IPv6 address), B<dst> meaning destination address (IPv4, IPv6 address), B<sport> meaning source port (TCP, UDP, UDPlite, SCTP, DCCP), B<dport> meaning destination port (TCP, UDP, UDPlite, SCTP, DCCP), B<spi> meaning Security Parameter Index (AH, ESP), and B<ct> meaning the usage of the conntrack tuple instead of the packet selectors."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<--hmark-mod> I<value (must be E<gt> 0)>"
msgstr "B<--hmark-mod> I<value (must be E<gt> 0)>"

#. type: Plain text
msgid "Modulus for hash calculation (to limit the range of possible marks)"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<--hmark-offset> I<value>"
msgstr "B<--hmark-offset> I<value>"

#. type: Plain text
msgid "Offset to start marks from."
msgstr ""

#. type: TP
#, no-wrap
msgid "For advanced usage, instead of using --hmark-tuple, you can specify custom"
msgstr ""

#. type: Plain text
msgid "prefixes and masks:"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<--hmark-src-prefix> I<cidr>"
msgstr "B<--hmark-src-prefix> I<cidr>"

#. type: Plain text
msgid "The source address mask in CIDR notation."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<--hmark-dst-prefix> I<cidr>"
msgstr "B<--hmark-dst-prefix> I<cidr>"

#. type: Plain text
msgid "The destination address mask in CIDR notation."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<--hmark-sport-mask> I<value>"
msgstr "B<--hmark-sport-mask> I<value>"

#. type: Plain text
msgid "A 16 bit source port mask in hexadecimal."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<--hmark-dport-mask> I<value>"
msgstr "B<--hmark-dport-mask> I<value>"

#. type: Plain text
msgid "A 16 bit destination port mask in hexadecimal."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<--hmark-spi-mask> I<value>"
msgstr "B<--hmark-spi-mask> I<value>"

#. type: Plain text
msgid "A 32 bit field with spi mask."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<--hmark-proto-mask> I<value>"
msgstr "B<--hmark-proto-mask> I<value>"

#. type: Plain text
msgid "An 8 bit field with layer 4 protocol number."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<--hmark-rnd> I<value>"
msgstr "B<--hmark-rnd> I<value>"

#. type: Plain text
msgid "A 32 bit random custom value to feed hash calculation."
msgstr ""

#. type: Plain text
msgid "I<Examples:>"
msgstr "I<例>:"

#. type: Plain text
#, no-wrap
msgid ""
"iptables -t mangle -A PREROUTING -m conntrack --ctstate NEW\n"
" -j HMARK --hmark-tuple ct,src,dst,proto --hmark-offset 10000\n"
"--hmark-mod 10 --hmark-rnd 0xfeedcafe\n"
msgstr ""
"iptables -t mangle -A PREROUTING -m conntrack --ctstate NEW\n"
" -j HMARK --hmark-tuple ct,src,dst,proto --hmark-offset 10000\n"
"--hmark-mod 10 --hmark-rnd 0xfeedcafe\n"

#. type: Plain text
msgid "iptables -t mangle -A PREROUTING -j HMARK --hmark-offset 10000 --hmark-tuple src,dst,proto --hmark-mod 10 --hmark-rnd 0xdeafbeef"
msgstr "iptables -t mangle -A PREROUTING -j HMARK --hmark-offset 10000 --hmark-tuple src,dst,proto --hmark-mod 10 --hmark-rnd 0xdeafbeef"

#. type: SS
#, no-wrap
msgid "IDLETIMER"
msgstr "IDLETIMER"

#. type: Plain text
msgid "This target can be used to identify when interfaces have been idle for a certain period of time.  Timers are identified by labels and are created when a rule is set with a new label.  The rules also take a timeout value (in seconds) as an option.  If more than one rule uses the same timer label, the timer will be restarted whenever any of the rules get a hit.  One entry for each timer is created in sysfs.  This attribute contains the timer remaining for the timer to expire.  The attributes are located under the xt_idletimer class:"
msgstr ""

#. type: Plain text
msgid "/sys/class/xt_idletimer/timers/E<lt>labelE<gt>"
msgstr "/sys/class/xt_idletimer/timers/E<lt>labelE<gt>"

#. type: Plain text
msgid "When the timer expires, the target module sends a sysfs notification to the userspace, which can then decide what to do (eg. disconnect to save power)."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<--timeout> I<amount>"
msgstr "B<--timeout> I<amount>"

#. type: Plain text
msgid "This is the time in seconds that will trigger the notification."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<--label> I<string>"
msgstr "B<--label> I<string>"

#. type: Plain text
msgid "This is a unique identifier for the timer.  The maximum length for the label string is 27 characters."
msgstr ""

#. type: SS
#, no-wrap
msgid "LED"
msgstr "LED"

#. type: Plain text
msgid "This creates an LED-trigger that can then be attached to system indicator lights, to blink or illuminate them when certain packets pass through the system. One example might be to light up an LED for a few minutes every time an SSH connection is made to the local machine. The following options control the trigger behavior:"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<--led-trigger-id> I<name>"
msgstr "B<--led-trigger-id> I<name>"

#. type: Plain text
msgid "This is the name given to the LED trigger. The actual name of the trigger will be prefixed with \"netfilter-\"."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<--led-delay> I<ms>"
msgstr "B<--led-delay> I<ms>"

#. type: Plain text
msgid "This indicates how long (in milliseconds) the LED should be left illuminated when a packet arrives before being switched off again. The default is 0 (blink as fast as possible.) The special value I<inf> can be given to leave the LED on permanently once activated. (In this case the trigger will need to be manually detached and reattached to the LED device to switch it off again.)"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<--led-always-blink>"
msgstr "B<--led-always-blink>"

#. type: Plain text
msgid "Always make the LED blink on packet arrival, even if the LED is already on.  This allows notification of new packets even with long delay values (which otherwise would result in a silent prolonging of the delay time.)"
msgstr ""

#. type: TP
#, no-wrap
msgid "Create an LED trigger for incoming SSH traffic:"
msgstr ""

#. type: Plain text
msgid "iptables -A INPUT -p tcp --dport 22 -j LED --led-trigger-id ssh"
msgstr "iptables -A INPUT -p tcp --dport 22 -j LED --led-trigger-id ssh"

#. type: TP
#, no-wrap
msgid "Then attach the new trigger to an LED:"
msgstr ""

#. type: Plain text
msgid "echo netfilter-ssh E<gt>/sys/class/leds/I<ledname>/trigger"
msgstr "echo netfilter-ssh E<gt>/sys/class/leds/I<ledname>/trigger"

#. type: SS
#, no-wrap
msgid "LOG"
msgstr "LOG"

#. type: Plain text
msgid "Turn on kernel logging of matching packets.  When this option is set for a rule, the Linux kernel will print some information on all matching packets (like most IP/IPv6 header fields) via the kernel log (where it can be read with I<dmesg(1)> or read in the syslog)."
msgstr "マッチしたパケットをカーネルログに記録する。 このオプションがルールに対して設定されると、 Linux カーネルはマッチしたパケットについての何らかの情報 (多くの IP/IPv6 ヘッダーフィールドなど) を カーネルログに表示する (カーネルログは I<dmesg>(1) や syslog で参照できる)。"

#. type: Plain text
msgid "This is a \"non-terminating target\", i.e. rule traversal continues at the next rule.  So if you want to LOG the packets you refuse, use two separate rules with the same matching criteria, first using target LOG then DROP (or REJECT)."
msgstr "これは \"非終了ターゲット\" である。 すなわち、 ルールの探索は次のルールへと継続される。 よって、 拒否するパケットをログ記録したければ、 同じマッチング判断基準を持つ 2 つのルールを使用し、 最初のルールで LOG ターゲットを、 次のルールで DROP (または REJECT) ターゲットを指定する。"

#. type: TP
#, no-wrap
msgid "B<--log-level> I<level>"
msgstr "B<--log-level> I<level>"

#. type: Plain text
msgid "Level of logging, which can be (system-specific) numeric or a mnemonic.  Possible values are (in decreasing order of priority): B<emerg>, B<alert>, B<crit>, B<error>, B<warning>, B<notice>, B<info> or B<debug>."
msgstr "ロギングレベル。 (システム固有の) 数値かシンボル名を指定する。 指定できる値は (優先度が高い順に)  B<emerg>, B<alert>, B<crit>, B<error>, B<warning>, B<notice>, B<info>, B<debug> である。"

#. type: TP
#, no-wrap
msgid "B<--log-prefix> I<prefix>"
msgstr "B<--log-prefix> I<prefix>"

#. type: Plain text
msgid "Prefix log messages with the specified prefix; up to 29 letters long, and useful for distinguishing messages in the logs."
msgstr ""
"指定したプレフィックスをログメッセージの前に付ける。 \n"
"プレフィックスは 29 文字までの長さで、 \n"
"ログの中でメッセージを区別するのに役立つ。"

#. type: TP
#, no-wrap
msgid "B<--log-tcp-sequence>"
msgstr "B<--log-tcp-sequence>"

#. type: Plain text
msgid "Log TCP sequence numbers. This is a security risk if the log is readable by users."
msgstr "TCP シーケンス番号をログに記録する。 ログがユーザーから読める場合、 セキュリティ上の危険がある。"

#. type: TP
#, no-wrap
msgid "B<--log-tcp-options>"
msgstr "B<--log-tcp-options>"

#. type: Plain text
msgid "Log options from the TCP packet header."
msgstr "TCP パケットヘッダーのオプションをログに記録する。"

#. type: TP
#, no-wrap
msgid "B<--log-ip-options>"
msgstr "B<--log-ip-options>"

#. type: Plain text
msgid "Log options from the IP/IPv6 packet header."
msgstr "IP/IPv6 パケットヘッダーのオプションをログに記録する。"

#. type: TP
#, no-wrap
msgid "B<--log-uid>"
msgstr "B<--log-uid>"

#. type: Plain text
msgid "Log the userid of the process which generated the packet."
msgstr "パケットを生成したプロセスのユーザー ID をログに記録する。"

#. type: SS
#, no-wrap
msgid "MARK"
msgstr "MARK"

#. type: Plain text
msgid "This target is used to set the Netfilter mark value associated with the packet.  It can, for example, be used in conjunction with routing based on fwmark (needs iproute2). If you plan on doing so, note that the mark needs to be set in the PREROUTING chain of the mangle table to affect routing.  The mark field is 32 bits wide."
msgstr "このターゲットを使うと、 そのパケットに関連付けられる Netfilter マーク値を設定する。 例えば、 fwmark に基づくルーティング (iproute2 が必要) と組み合わせて使うことができる。 そうする場合には、 ルーティング時に考慮されるようにするには、 mangle テーブルの PREROUTING チェインでマークを設定する必要がある。 マークフィールドは 32 ビット幅である。"

#. type: Plain text
msgid "Zeroes out the bits given by I<mask> and XORs I<value> into the packet mark (\"nfmark\"). If I<mask> is omitted, 0xFFFFFFFF is assumed."
msgstr "I<mask> で指定されたビットを 0 にし、 I<value> と packet mark (\"nfmark\") の XOR を取る。 I<mask> が省略された場合は 0xFFFFFFFF とみなされる。"

#. type: Plain text
msgid "Zeroes out the bits given by I<mask> and ORs I<value> into the packet mark. If I<mask> is omitted, 0xFFFFFFFF is assumed."
msgstr "I<mask> で指定されたビットを 0 にし、 I<value> と packet mark の OR を取る。 I<mask> が省略された場合は 0xFFFFFFFF とみなされる。"

#. type: Plain text
msgid "The following mnemonics are available:"
msgstr "以下の簡易表現が利用できる。"

#. type: Plain text
msgid "Binary AND the nfmark with I<bits>. (Mnemonic for B<--set-xmark 0/>I<invbits>, where I<invbits> is the binary negation of I<bits>.)"
msgstr "nfmark と I<bits> のビット論理積 (AND) を取る (B<--set-xmark 0/>I<invbits> の簡易表現、 I<invbits> は I<bits> のビット単位の否定である)。"

#. type: Plain text
msgid "Binary OR the nfmark with I<bits>. (Mnemonic for B<--set-xmark> I<bits>B</>I<bits>.)"
msgstr "nfmark と I<bits> のビット論理和 (OR) を取る (B<--set-xmark> I<bits>B</>I<bits> の簡易表現)。"

#. type: Plain text
msgid "Binary XOR the nfmark with I<bits>. (Mnemonic for B<--set-xmark> I<bits>B</0>.)"
msgstr "nfmark と I<bits> のビット XOR を取る (B<--set-xmark> I<bits>B</0> の簡易表現)。"

#. type: SS
#, no-wrap
msgid "MASQUERADE"
msgstr "MASQUERADE"

#. type: Plain text
msgid "This target is only valid in the B<nat> table, in the B<POSTROUTING> chain.  It should only be used with dynamically assigned IP (dialup)  connections: if you have a static IP address, you should use the SNAT target.  Masquerading is equivalent to specifying a mapping to the IP address of the interface the packet is going out, but also has the effect that connections are I<forgotten> when the interface goes down.  This is the correct behavior when the next dialup is unlikely to have the same interface address (and hence any established connections are lost anyway)."
msgstr "このターゲットは B<nat> テーブルの B<POSTROUTING> チェインのみで有効である。 動的割り当て IP (ダイヤルアップ) コネクションの場合にのみ使うべきである。 固定 IP アドレスならば、 SNAT ターゲットを使うべきである。 マスカレーディングは、 パケットが送信されるインターフェースの IP アドレスへのマッピングを指定するのと同じであるが、 インターフェースが停止した場合にコネクションをI<忘れる>という効果がある。 次のダイヤルアップでは同じインターフェースアドレスになる可能性が低い (そのため、 前回確立されたコネクションは失われる) 場合、 この動作は正しい。"

#. type: TP
#, no-wrap
msgid "B<--to-ports> I<port>[B<->I<port>]"
msgstr "B<--to-ports> I<port>[B<->I<port>]"

#. type: Plain text
msgid "This specifies a range of source ports to use, overriding the default B<SNAT> source port-selection heuristics (see above).  This is only valid if the rule also specifies one of the following protocols: B<tcp>, B<udp>, B<dccp> or B<sctp>."
msgstr "このオプションは、 使用する送信元ポートの範囲を指定し、 デフォルトの B<SNAT> 送信元ポートの選択方法 (上記) よりも優先される。 ルールがプロトコルとして B<tcp>, B<udp>, B<dccp>, B<sctp> を指定している場合にのみ有効である。"

#. type: Plain text
msgid "Randomize source port mapping If option B<--random> is used then port mapping will be randomized (kernel E<gt>= 2.6.21).  Since kernel 5.0, B<--random> is identical to B<--random-fully>."
msgstr "送信元ポートのマッピングをランダム化する。 B<--random> オプションを使用すると、 ポートマッピングがランダム化される (カーネル 2.6.21 以降)。カーネル 5.0 以降では、 B<--random> は B<--random-fully> と等価である。"

#. type: TP
#, no-wrap
msgid "B<--random-fully>"
msgstr "B<--random-fully>"

#. type: Plain text
msgid "Full randomize source port mapping If option B<--random-fully> is used then port mapping will be fully randomized (kernel E<gt>= 3.13)."
msgstr "送信元ポートのマッピングを完全にランダム化する。 B<--random-fully> オプションを使用すると、 ポートマッピングが完全にランダム化される (カーネル 3.13 以降)。"

#. type: SS
#, no-wrap
msgid "NETMAP"
msgstr "NETMAP"

#. type: Plain text
msgid "This target allows you to statically map a whole network of addresses onto another network of addresses.  It can only be used from rules in the B<nat> table."
msgstr "このターゲットを使うと、あるアドレスネットワーク全体を別のネットワークアドレスに静的にマッピングできる。 このターゲットは B<nat> テーブルでルールでのみ使用できる。"

#. type: TP
#, no-wrap
msgid "B<--to> I<address>[B</>I<mask>]"
msgstr "B<--to> I<address>[B</>I<mask>]"

#. type: Plain text
msgid "Network address to map to.  The resulting address will be constructed in the following way: All 'one' bits in the mask are filled in from the new `address'.  All bits that are zero in the mask are filled in from the original address."
msgstr "マッピング先のネットワークアドレス。 変換後のアドレスは以下のようにして構築される。 mask で '1' になっているビットは新しいアドレスが使われ、 mask で '0' になっているビットは元のアドレスが使われる。"

#. type: SS
#, no-wrap
msgid "NFLOG"
msgstr "NFLOG"

#. type: Plain text
msgid "This target provides logging of matching packets. When this target is set for a rule, the Linux kernel will pass the packet to the loaded logging backend to log the packet. This is usually used in combination with nfnetlink_log as logging backend, which will multicast the packet through a I<netlink> socket to the specified multicast group. One or more userspace processes may subscribe to the group to receive the packets. Like LOG, this is a non-terminating target, i.e. rule traversal continues at the next rule."
msgstr "このターゲットは、 マッチしたパケットをログに記録する機能を提供する。 このターゲットがルールに設定されると、 Linux カーネルはそのログに記録するためにそのパケットをロードされたロギングバックエンドに渡す。 このターゲットは通常は nfnetlink_log をロギングバックエンドとして使う組み合わせで使用される。 nfnetlink_log はそのパケットを I<netlink> ソケット経由で指定されたマルチキャストグループにマルチキャストする。 1 つ以上のユーザー空間プロセスがマルチキャストグループを購読しパケットを受信することができる。 LOG と同様に、 このターゲットは非終了ターゲットであり、 ルールの探索は次のルールへと継続される。"

#. type: TP
#, no-wrap
msgid "B<--nflog-group> I<nlgroup>"
msgstr "B<--nflog-group> I<nlgroup>"

#. type: Plain text
msgid "The netlink group (0 - 2^16-1) to which packets are (only applicable for nfnetlink_log). The default value is 0."
msgstr "パケットを送信する netlink グループ (0 - 2^16-1) を指定する (nfnetlink_log の場合のみ利用できる)。 デフォルトの値は 0 である。"

#. type: TP
#, no-wrap
msgid "B<--nflog-prefix> I<prefix>"
msgstr "B<--nflog-prefix> I<prefix>"

#. type: Plain text
msgid "A prefix string to include in the log message, up to 64 characters long, useful for distinguishing messages in the logs."
msgstr "ログメッセージの前に付けるプレフィックス文字列。 最大 64 文字までの指定できる。 ログの中でメッセージを区別するのに役に立つ。"

#. type: TP
#, no-wrap
msgid "B<--nflog-range> I<size>"
msgstr "B<--nflog-range> I<size>"

#. type: Plain text
msgid "This option has never worked, use --nflog-size instead"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<--nflog-size> I<size>"
msgstr "B<--nflog-size> I<size>"

#. type: Plain text
msgid "The number of bytes to be copied to userspace (only applicable for nfnetlink_log). nfnetlink_log instances may specify their own range, this option overrides it."
msgstr "ユーザー空間にコピーするバイト数 (nfnetlink_log の場合のみ利用できる)。 nfnetlink_log のインスタンスは自身でコピーする範囲を指定できるが、 このオプションはそれを上書きする。"

#. type: TP
#, no-wrap
msgid "B<--nflog-threshold> I<size>"
msgstr "B<--nflog-threshold> I<size>"

#. type: Plain text
msgid "Number of packets to queue inside the kernel before sending them to userspace (only applicable for nfnetlink_log). Higher values result in less overhead per packet, but increase delay until the packets reach userspace. The default value is 1."
msgstr "ユーザー空間にパケットを送信する前に、カーネル内部のキューに入れるパケット数 (nfnetlink_log の場合のみ利用できる)。 大きめの値を指定するほどパケット単位のオーバヘッドは少なくなるが、 パケットがユーザー空間に届くまでの遅延が大きくなる。 デフォルト値は 1 である。"

#. type: SS
#, no-wrap
msgid "NFQUEUE"
msgstr "NFQUEUE"

#. type: Plain text
msgid "This target passes the packet to userspace using the B<nfnetlink_queue> handler.  The packet is put into the queue identified by its 16-bit queue number.  Userspace can inspect and modify the packet if desired. Userspace must then drop or reinject the packet into the kernel.  Please see libnetfilter_queue for details.  B<nfnetlink_queue> was added in Linux 2.6.14. The B<queue-balance> option was added in Linux 2.6.31, B<queue-bypass> in 2.6.39."
msgstr ""
"このターゲットは、 B<nfnetlink_queue> ハンドラーを使ってそのパケットをユーザー空間に渡す。 パケットは 16 ビットのキュー番号で指定されたキューに入れられる。 ユーザー空間では好きなようにパケットを検査し変更できる。 ユーザー空間側では、必ずそのパケットを破棄するかカーネルに戻すかのどちらかをしなければならない。 詳細は libnetfilter_queue を参照のこと。\n"
"B<nfnetlink_queue> は Linux 2.6.14 で追加された。 B<queue-balance> オプションは Linux 2.6.31 で、 B<queue-bypass> は Linux 2.6.39 で追加された。"

#. type: TP
#, no-wrap
msgid "B<--queue-num> I<value>"
msgstr "B<--queue-num> I<value>"

#. type: Plain text
msgid "This specifies the QUEUE number to use. Valid queue numbers are 0 to 65535. The default value is 0."
msgstr "使用する QUEUE 番号を指定する。 有効なキュー番号は 0 から 65535 である。 デフォルトは 0 である。"

#. type: TP
#, no-wrap
msgid "B<--queue-balance> I<value>B<:>I<value>"
msgstr "B<--queue-balance> I<value>B<:>I<value>"

#. type: Plain text
msgid "This specifies a range of queues to use. Packets are then balanced across the given queues.  This is useful for multicore systems: start multiple instances of the userspace program on queues x, x+1, .. x+n and use \"--queue-balance I<x>B<:>I<x+n>\".  Packets belonging to the same connection are put into the same nfqueue."
msgstr "使用するキューの範囲を指定する。 パケットは指定された範囲のキューに分散される。 これはマルチコアシステムで有用である。 ユーザー空間プログラムの複数インスタンスをキュー x, x+1, .. x+n で開始し、 \"--queue-balance I<x>B<:>I<x+n>\" を使用する。 同じコネクションに所属するパケットは同じ nfqueue に入れられる。"

#. type: TP
#, no-wrap
msgid "B<--queue-bypass>"
msgstr "B<--queue-bypass>"

#. type: Plain text
msgid "By default, if no userspace program is listening on an NFQUEUE, then all packets that are to be queued are dropped.  When this option is used, the NFQUEUE rule behaves like ACCEPT instead, and the packet will move on to the next table."
msgstr "デフォルトでは、 どのユーザー空間プログラムも NFQUEUE をリッスンしていない場合、 キューされるはずのすべてのパケットが破棄される。 このオプションを使うと、 NFQUEUE ルールは ACCEPT のような動作となり、 パケットは次のテーブルに進む。"

#. type: TP
#, no-wrap
msgid "B<--queue-cpu-fanout>"
msgstr "B<--queue-cpu-fanout>"

#. type: Plain text
msgid "Available starting Linux kernel 3.10. When used together with B<--queue-balance> this will use the CPU ID as an index to map packets to the queues. The idea is that you can improve performance if there's a queue per CPU. This requires B<--queue-balance> to be specified."
msgstr "Linux カーネル 3.10 以降で利用可能。 B<--queue-balance> とともに使用されると、このオプションはパケットをキューにマッピングする際のインデックスとして CPU ID を使用する。 これは、 CPU ごとにキューがある場合に性能を向上させようというものである。 このオプションを使うには B<--queue-balance> を指定する必要がある。"

#. type: SS
#, no-wrap
msgid "NOTRACK"
msgstr "NOTRACK"

#. type: Plain text
msgid "This extension disables connection tracking for all packets matching that rule.  It is equivalent with -j CT --notrack. Like CT, NOTRACK can only be used in the B<raw> table."
msgstr "このターゲットを使うと、そのルールにマッチした全てのパケットでコネクション追跡が無効になる。 これは -j CT --notrack と等価である。 CT と同様、 NOTRACK は B<raw> テーブルでのみ使用できる。"

#. type: SS
#, no-wrap
msgid "RATEEST"
msgstr "RATEEST"

#. type: Plain text
msgid "The RATEEST target collects statistics, performs rate estimation calculation and saves the results for later evaluation using the B<rateest> match."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<--rateest-name> I<name>"
msgstr "B<--rateest-name> I<name>"

#. type: Plain text
msgid "Count matched packets into the pool referred to by I<name>, which is freely choosable."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<--rateest-interval> I<amount>{B<s>|B<ms>|B<us>}"
msgstr "B<--rateest-interval> I<amount>{B<s>|B<ms>|B<us>}"

#. type: Plain text
msgid "Rate measurement interval, in seconds, milliseconds or microseconds."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<--rateest-ewmalog> I<value>"
msgstr "B<--rateest-ewmalog> I<value>"

#. type: Plain text
msgid "Rate measurement averaging time constant."
msgstr ""

#. type: SS
#, no-wrap
msgid "REDIRECT"
msgstr "REDIRECT"

#. type: Plain text
msgid "This target is only valid in the B<nat> table, in the B<PREROUTING> and B<OUTPUT> chains, and user-defined chains which are only called from those chains.  It redirects the packet to the machine itself by changing the destination IP to the primary address of the incoming interface (locally-generated packets are mapped to the localhost address, 127.0.0.1 for IPv4 and ::1 for IPv6, and packets arriving on interfaces that don't have an IP address configured are dropped)."
msgstr "このターゲットは、 B<nat> テーブルの B<PREROUTING> チェインと B<OUTPUT> チェイン、 およびこれらチェインから呼び出されるユーザー定義チェインでのみ有効である。 このターゲットは、 宛先 IP をパケットを受信したインタフェースの最初のアドレスに変更することで、 パケットをそのマシン自身にリダイレクトする (ローカルで生成されたパケットはローカルホストのアドレス、 IPv4 では 127.0.0.1、 IPv6 では ::1 にマップされる。 IP アドレスを設定されていないインタフェースに到着したパケットは破棄される)。"

#. type: Plain text
msgid "This specifies a destination port or range of ports to use: without this, the destination port is never altered.  This is only valid if the rule also specifies one of the following protocols: B<tcp>, B<udp>, B<dccp> or B<sctp>."
msgstr "このオプションは使用される宛先ポート・ポート範囲・複数ポートを指定する。 このオプションが指定されない場合、 宛先ポートは変更されない。 ルールがプロトコルとして B<tcp>, B<udp>, B<dccp>, B<sctp> を指定している場合にのみ有効である。"

#. type: TP
#, no-wrap
msgid "IPv6 support available starting Linux kernels E<gt>= 3.7."
msgstr "IPv6 サポートは Linux カーネル 3.7 以降で利用可能である。"

#. type: SS
#, no-wrap
msgid "REJECT (IPv6-specific)"
msgstr "REJECT (IPv6 のみ)"

#. type: Plain text
msgid "This is used to send back an error packet in response to the matched packet: otherwise it is equivalent to B<DROP> so it is a terminating TARGET, ending rule traversal.  This target is only valid in the B<INPUT>, B<FORWARD> and B<OUTPUT> chains, and user-defined chains which are only called from those chains.  The following option controls the nature of the error packet returned:"
msgstr ""
"マッチしたパケットの応答としてエラーパケットを送信するために使われる。 \n"
"エラーパケットを送らなければ、 B<DROP> と同じであり、 TARGET を終了し、 \n"
"ルールの探索を終了する。 このターゲットは、 B<INPUT>, B<FORWARD>,\n"
"B<OUTPUT> チェインと、 これらのチェインから呼ばれる ユーザー定義チェイン\n"
"だけで有効である。 以下のオプションは、 返されるエラーパケットの特性を\n"
"制御する。"

#. type: TP
#, no-wrap
msgid "B<--reject-with> I<type>"
msgstr "B<--reject-with> I<type>"

#. type: Plain text
msgid "The type given can be B<icmp6-no-route>, B<no-route>, B<icmp6-adm-prohibited>, B<adm-prohibited>, B<icmp6-addr-unreachable>, B<addr-unreach>, or B<icmp6-port-unreachable>, which return the appropriate ICMPv6 error message (B<icmp6-port-unreachable> is the default). Finally, the option B<tcp-reset> can be used on rules which only match the TCP protocol: this causes a TCP RST packet to be sent back.  This is mainly useful for blocking I<ident> (113/tcp) probes which frequently occur when sending mail to broken mail hosts (which won't accept your mail otherwise).  B<tcp-reset> can only be used with kernel versions 2.6.14 or later."
msgstr "指定できるタイプは B<icmp6-no-route>, B<no-route>, B<icmp6-adm-prohibited>, B<adm-prohibited>, B<icmp6-addr-unreachable>, B<addr-unreach>, B<icmp6-port-unreachable> である。 指定したタイプの適切な IPv6 エラーメッセージが返される (B<icmp6-port-unreachable> がデフォルトである)。 さらに、 TCP プロトコルにのみマッチするルールに対して、 オプション B<tcp-reset> を使うことができる。 このオプションを使うと、 TCP RST パケットが送り返される。 主として I<ident> (113/tcp) による探査を阻止するのに役立つ。 I<ident> による探査は、 壊れている (メールを受け取らない) メールホストに メールが送られる場合に頻繁に起こる。 B<tcp-reset> はバージョン 2.6.14 以降のカーネルでのみ使用できる。"

#. type: SS
#, no-wrap
msgid "REJECT (IPv4-specific)"
msgstr "REJECT (IPv4 の場合)"

#. type: Plain text
msgid "The type given can be B<icmp-net-unreachable>, B<icmp-host-unreachable>, B<icmp-port-unreachable>, B<icmp-proto-unreachable>, B<icmp-net-prohibited>, B<icmp-host-prohibited>, or B<icmp-admin-prohibited> (*), which return the appropriate ICMP error message (B<icmp-port-unreachable> is the default).  The option B<tcp-reset> can be used on rules which only match the TCP protocol: this causes a TCP RST packet to be sent back.  This is mainly useful for blocking I<ident> (113/tcp) probes which frequently occur when sending mail to broken mail hosts (which won't accept your mail otherwise)."
msgstr "指定できるタイプは B<icmp-net-unreachable>, B<icmp-host-unreachable>, B<icmp-port-unreachable>, B<icmp-proto-unreachable>, B<icmp-net-prohibited>, B<icmp-host-prohibited>, B<icmp-admin-prohibited> (*) である。指定したタイプの適切な ICMP エラーメッセージを返す (B<icmp-port-unreachable> がデフォルトである)。 TCP プロトコルにのみマッチするルールに対して、 オプション B<tcp-reset> を使うことができる。 このオプションを使うと、 TCP RST パケットが送り返される。 主として I<ident> (113/tcp) による探査を阻止するのに役立つ。 I<ident> による探査は、 壊れている (メールを受け取らない) メールホストに メールが送られる場合に頻繁に起こる。"

#. type: Plain text
msgid "(*) Using icmp-admin-prohibited with kernels that do not support it will result in a plain DROP instead of REJECT"
msgstr "(*) icmp-admin-prohibited をサポートしないカーネルで、 icmp-admin-prohibited を使用すると、 REJECT ではなく単なる DROP になる。"

#. type: SS
#, no-wrap
msgid "SECMARK"
msgstr "SECMARK"

#. type: Plain text
msgid "This is used to set the security mark value associated with the packet for use by security subsystems such as SELinux.  It is valid in the B<security> table (for backwards compatibility with older kernels, it is also valid in the B<mangle> table). The mark is 32 bits wide."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<--selctx> I<security_context>"
msgstr "B<--selctx> I<security_context>"

#. type: SS
#, no-wrap
msgid "SET"
msgstr "SET"

#. type: Plain text
msgid "This module adds and/or deletes entries from IP sets which can be defined by ipset(8)."
msgstr "このモジュールは B<ipsec>(8) で定義できる IP 集合のエントリの追加、削除、その両方を行う。"

#. type: TP
#, no-wrap
msgid "B<--add-set> I<setname> I<flag>[B<,>I<flag>...]"
msgstr "B<--add-set> I<setname> I<flag>[B<,>I<flag>...]"

#. type: Plain text
msgid "add the address(es)/port(s) of the packet to the set"
msgstr "集合に指定されたアドレス/ポート (複数可) を追加する"

#. type: TP
#, no-wrap
msgid "B<--del-set> I<setname> I<flag>[B<,>I<flag>...]"
msgstr "B<--del-set> I<setname> I<flag>[B<,>I<flag>...]"

#. type: Plain text
msgid "delete the address(es)/port(s) of the packet from the set"
msgstr "集合から指定されたアドレス/ポート (複数可) を削除する"

#. type: TP
#, no-wrap
msgid "B<--map-set> I<setname> I<flag>[B<,>I<flag>...] "
msgstr "B<--map-set> I<setname> I<flag>[B<,>I<flag>...] "

#. type: Plain text
msgid "[--map-mark] [--map-prio] [--map-queue] map packet properties (firewall mark, tc priority, hardware queue)"
msgstr ""

#. type: Plain text
msgid "where I<flag>(s) are B<src> and/or B<dst> specifications and there can be no more than six of them."
msgstr "I<flag> は B<src> や B<dst> の指定であり、 指定できるのは 6 個までである。"

#. type: TP
#, no-wrap
msgid "B<--timeout> I<value>"
msgstr "B<--timeout> I<value>"

#. type: Plain text
msgid "when adding an entry, the timeout value to use instead of the default one from the set definition"
msgstr "エントリを追加する際に、 集合定義のデフォルト値ではなく指定したタイムアウト値を使用する"

#. type: TP
#, no-wrap
msgid "B<--exist>"
msgstr "B<--exist>"

#. type: Plain text
msgid "when adding an entry if it already exists, reset the timeout value to the specified one or to the default from the set definition"
msgstr "エントリを追加する際に、 エントリが存在する場合、 タイムアウト値を、 指定された値か集合定義のデフォルト値にリセットする"

#. type: TP
#, no-wrap
msgid "B<--map-set> I<set-name>"
msgstr "B<--map-set> I<set-name>"

#. type: Plain text
msgid "the set-name should be created with --skbinfo option B<--map-mark> map firewall mark to packet by lookup of value in the set B<--map-prio> map traffic control priority to packet by lookup of value in the set B<--map-queue> map hardware NIC queue to packet by lookup of value in the set"
msgstr ""

#. type: Plain text
msgid "The B<--map-set> option can be used from the mangle table only. The B<--map-prio> and B<--map-queue> flags can be used in the OUTPUT, FORWARD and POSTROUTING chains."
msgstr ""

#. type: Plain text
msgid "Use of -j SET requires that ipset kernel support is provided, which, for standard kernels, is the case since Linux 2.6.39."
msgstr "-j SET を使用するには ipset のカーネルサポートが必要である。 標準のカーネルでは、 Linux 2.6.39 以降で提供されている。"

#. type: SS
#, no-wrap
msgid "SNAT"
msgstr "SNAT"

#. type: Plain text
msgid "This target is only valid in the B<nat> table, in the B<POSTROUTING> and B<INPUT> chains, and user-defined chains which are only called from those chains.  It specifies that the source address of the packet should be modified (and all future packets in this connection will also be mangled), and rules should cease being examined.  It takes the following options:"
msgstr "このターゲットは B<nat> テーブルの B<POSTROUTING>, B<INPUT> チェイン、 これらのチェインから呼び出される ユーザー定義チェインのみで有効である。 このターゲットはパケットの送信元アドレスを修正する (このコネクションの以降のパケットも修正して分からなく (mangle) する)。 さらに、 ルールによるチェックを止めさせる。 このターゲットには以下のオプションがある:"

#. type: TP
#, no-wrap
msgid "B<--to-source> [I<ipaddr>[B<->I<ipaddr>]][B<:>I<port>[B<->I<port>]]"
msgstr "B<--to-source> [I<ipaddr>[B<->I<ipaddr>]][B<:>I<port>[B<->I<port>]]"

#. type: Plain text
msgid "which can specify a single new source IP address, an inclusive range of IP addresses. Optionally a port range, if the rule also specifies one of the following protocols: B<tcp>, B<udp>, B<dccp> or B<sctp>.  If no port range is specified, then source ports below 512 will be mapped to other ports below 512: those between 512 and 1023 inclusive will be mapped to ports below 1024, and other ports will be mapped to 1024 or above. Where possible, no port alteration will occur.  In Kernels up to 2.6.10, you can add several --to-source options. For those kernels, if you specify more than one source address, either via an address range or multiple --to-source options, a simple round-robin (one after another in cycle) takes place between these addresses.  Later Kernels (E<gt>= 2.6.11-rc1) don't have the ability to NAT to multiple ranges anymore."
msgstr "1 つの新しい送信元 IP アドレス、 または IP アドレスの範囲が指定できる。 ルールでプロトコルとして B<tcp>, B<udp>, B<dccp>, B<sctp> が指定されている場合、 ポートの範囲を指定することもできる。 ポートの範囲が指定されていない場合、 512 未満の送信元ポートは、 他の 512 未満のポートにマッピングされる。 512 〜 1023 までのポートは、 1024 未満のポートにマッピングされる。 それ以外のポートは、 1024 以上のポートにマッピングされる。 可能であれば、 ポートの変換は起こらない。 2.6.10 以前のカーネルでは、 複数の --to-source オプションを指定することができる。 これらのカーネルでは、 アドレスの範囲指定や --to-source オプションの複数回指定により 2 つ以上の送信元アドレスを指定した場合、 それらのアドレスを使った単純なラウンド・ロビンが行われる。 それ以降のカーネル (E<gt>= 2.6.11-rc1) には複数の範囲を NAT する機能は存在しない。"

#. type: Plain text
msgid "If option B<--random> is used then port mapping will be randomized through a hash-based algorithm (kernel E<gt>= 2.6.21)."
msgstr "B<--random> オプションが使用されると、ポートマッピングは、ハッシュを使ったアルゴリズムでランダム化される (カーネル 2.6.21 以降)。"

#. type: Plain text
msgid "If option B<--random-fully> is used then port mapping will be fully randomized through a PRNG (kernel E<gt>= 3.14)."
msgstr "B<--random> オプションが使用されると、ポートマッピングは PRNG でランダム化される (カーネル 2.6.21 以降)。"

#. type: Plain text
msgid "Kernels prior to 2.6.36-rc1 don't have the ability to B<SNAT> in the B<INPUT> chain."
msgstr "2.6.36-rc1 より前のカーネルでは B<INPUT> チェインで B<SNAT> を使用できない。"

#. type: SS
#, no-wrap
msgid "SNPT (IPv6-specific)"
msgstr "SNPT (IPv6 のみ)"

#. type: Plain text
msgid "Provides stateless source IPv6-to-IPv6 Network Prefix Translation (as described by RFC 6296)."
msgstr "(RFC 6296 で説明されている) ステートレス IPv6-to-IPv6 送信元ネットワークプレフィックス変換を提供する。"

#. type: Plain text
msgid "You have to use the DNPT target to undo the translation. Example:"
msgstr "変換を取り消すには DNPT ターゲットを使わなければならない。 例:"

#. type: SS
#, no-wrap
msgid "SYNPROXY"
msgstr "SYNPROXY"

#. type: Plain text
msgid "This target will process TCP three-way-handshake parallel in netfilter context to protect either local or backend system. This target requires connection tracking because sequence numbers need to be translated.  The kernels ability to absorb SYNFLOOD was greatly improved starting with Linux 4.4, so this target should not be needed anymore to protect Linux servers."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<--mss> I<maximum segment size>"
msgstr ""

#. type: Plain text
msgid "Maximum segment size announced to clients. This must match the backend."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<--wscale> I<window scale>"
msgstr "B<--wscale> I<window scale>"

#. type: Plain text
msgid "Window scale announced to clients. This must match the backend."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<--sack-perm>"
msgstr "B<--sack-perm>"

#. type: Plain text
msgid "Pass client selective acknowledgement option to backend (will be disabled if not present)."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<--timestamps>"
msgstr "B<--timestamps>"

#. type: Plain text
msgid "Pass client timestamp option to backend (will be disabled if not present, also needed for selective acknowledgement and window scaling)."
msgstr ""

#. type: Plain text
msgid "Determine tcp options used by backend, from an external system"
msgstr ""

#. type: Plain text
msgid "tcpdump -pni eth0 -c 1 'tcp[tcpflags] == (tcp-syn|tcp-ack)'"
msgstr ""

#. type: Plain text
#, no-wrap
msgid "    port 80 &\n"
msgstr ""

#. type: Plain text
msgid "telnet 192.0.2.42 80"
msgstr ""

#. type: Plain text
msgid "18:57:24.693307 IP 192.0.2.42.80 E<gt> 192.0.2.43.48757:"
msgstr ""

#. type: Plain text
#, no-wrap
msgid "    Flags [S.], seq 360414582, ack 788841994, win 14480,\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid "    options [mss 1460,sackOK,\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid "    TS val 1409056151 ecr 9690221,\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid "    nop,wscale 9],\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid "    length 0\n"
msgstr "    length 0\n"

#. type: Plain text
msgid "Switch tcp_loose mode off, so conntrack will mark out-of-flow packets as state INVALID."
msgstr ""

#. type: Plain text
msgid "Make SYN packets untracked"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"iptables -t raw -A PREROUTING -i eth0 -p tcp --dport 80\n"
"    --syn -j CT --notrack\n"
msgstr ""
"iptables -t raw -A PREROUTING -i eth0 -p tcp --dport 80\n"
"    --syn -j CT --notrack\n"

#. type: Plain text
msgid "Catch UNTRACKED (SYN packets) and INVALID (3WHS ACK packets) states and send them to SYNPROXY. This rule will respond to SYN packets with SYN+ACK syncookies, create ESTABLISHED for valid client response (3WHS ACK packets) and drop incorrect cookies. Flags combinations not expected during 3WHS will not match and continue (e.g. SYN+FIN, SYN+ACK)."
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"iptables -A INPUT -i eth0 -p tcp --dport 80\n"
"    -m state --state UNTRACKED,INVALID -j SYNPROXY\n"
"    --sack-perm --timestamp --mss 1460 --wscale 9\n"
msgstr ""

#. type: Plain text
msgid "Drop invalid packets, this will be out-of-flow packets that were not matched by SYNPROXY."
msgstr ""

#. type: Plain text
msgid "iptables -A INPUT -i eth0 -p tcp --dport 80 -m state --state INVALID -j DROP"
msgstr "iptables -A INPUT -i eth0 -p tcp --dport 80 -m state --state INVALID -j DROP"

#. type: SS
#, no-wrap
msgid "TCPMSS"
msgstr "TCPMSS"

#. type: Plain text
msgid "This target allows to alter the MSS value of TCP SYN packets, to control the maximum size for that connection (usually limiting it to your outgoing interface's MTU minus 40 for IPv4 or 60 for IPv6, respectively).  Of course, it can only be used in conjunction with B<-p tcp>."
msgstr "このターゲットを用いると、 TCP の SYN パケットの MSS 値を書き換え、 そのコネクションでの最大サイズを制御できる (通常は、 送信インターフェースの MTU から IPv4 では 40 を、 IPv6 では 60 を引いた値に制限する)。 もちろん B<-p tcp> との組み合わせでしか使えない。"

#. type: Plain text
msgid "This target is used to overcome criminally braindead ISPs or servers which block \"ICMP Fragmentation Needed\" or \"ICMPv6 Packet Too Big\" packets.  The symptoms of this problem are that everything works fine from your Linux firewall/router, but machines behind it can never exchange large packets:"
msgstr "このターゲットは、 \"ICMP Fragmentation Needed\" や \"ICMPv6 Packet Too Big\" パケットをブロックしている犯罪的に頭のいかれた ISP やサーバーを乗り越えるために使用される。 Linux ファイアウォール/ルーターでは何も問題がないのに、 そこにぶら下がるマシンでは以下のように大きなパケットをやりとりできないというのが、 この問題の兆候である。"

#. type: IP
#, no-wrap
msgid "1."
msgstr "1."

#. type: Plain text
msgid "Web browsers connect, then hang with no data received."
msgstr "ウェブ・ブラウザで接続しようとすると、 何のデータも受け取らずにハングする"

#. type: IP
#, no-wrap
msgid "2."
msgstr "2."

#. type: Plain text
msgid "Small mail works fine, but large emails hang."
msgstr "短いメールは問題ないが、 長いメールがハングする"

#. type: IP
#, no-wrap
msgid "3."
msgstr "3."

#. type: Plain text
msgid "ssh works fine, but scp hangs after initial handshaking."
msgstr "ssh は問題ないが、 scp は最初のハンドシェーク後にハングする"

#. type: Plain text
msgid "Workaround: activate this option and add a rule to your firewall configuration like:"
msgstr "回避方法: このオプションを有効にし、 以下のようなルールを ファイアウォールの設定に追加する。"

#. type: Plain text
#, no-wrap
msgid ""
" iptables -t mangle -A FORWARD -p tcp --tcp-flags SYN,RST SYN\n"
"             -j TCPMSS --clamp-mss-to-pmtu\n"
msgstr ""
" iptables -t mangle -A FORWARD -p tcp --tcp-flags SYN,RST SYN\n"
"             -j TCPMSS --clamp-mss-to-pmtu\n"

#. type: TP
#, no-wrap
msgid "B<--set-mss> I<value>"
msgstr "B<--set-mss> I<value>"

#. type: Plain text
msgid "Explicitly sets MSS option to specified value. If the MSS of the packet is already lower than I<value>, it will B<not> be increased (from Linux 2.6.25 onwards) to avoid more problems with hosts relying on a proper MSS."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<--clamp-mss-to-pmtu>"
msgstr "B<--clamp-mss-to-pmtu>"

#. type: Plain text
msgid "Automatically clamp MSS value to (path_MTU - 40 for IPv4; -60 for IPv6).  This may not function as desired where asymmetric routes with differing path MTU exist \\(em the kernel uses the path MTU which it would use to send packets from itself to the source and destination IP addresses. Prior to Linux 2.6.25, only the path MTU to the destination IP address was considered by this option; subsequent kernels also consider the path MTU to the source IP address."
msgstr ""

#. type: Plain text
msgid "These options are mutually exclusive."
msgstr "これらのオプションはどちらか 1 つしか指定できない。"

#. type: SS
#, no-wrap
msgid "TCPOPTSTRIP"
msgstr "TCPOPTSTRIP"

#. type: Plain text
msgid "This target will strip TCP options off a TCP packet. (It will actually replace them by NO-OPs.) As such, you will need to add the B<-p tcp> parameters."
msgstr "このターゲットは TCP パケットから TCP オプションを削除する (実際には TCPオプションを NO-OP で置き換える)。 このターゲットを使うには B<-p tcp> パラメーターを使う必要があるだろう。"

#. type: TP
#, no-wrap
msgid "B<--strip-options> I<option>[B<,>I<option>...]"
msgstr "B<--strip-options> I<option>[B<,>I<option>...]"

#. type: Plain text
msgid "Strip the given option(s). The options may be specified by TCP option number or by symbolic name. The list of recognized options can be obtained by calling iptables with B<-j TCPOPTSTRIP -h>."
msgstr "指定されたオプション (複数可) を削除する。 オプションは TCP オプション番号かシンボル名で指定する。 iptables を B<-j TCPOPTSTRIP -h> で呼び出すと、指定できるオプションのシンボル名を取得できる。"

#. type: SS
#, no-wrap
msgid "TEE"
msgstr "TEE"

#. type: Plain text
msgid "The B<TEE> target will clone a packet and redirect this clone to another machine on the B<local> network segment. In other words, the nexthop must be the target, or you will have to configure the nexthop to forward it further if so desired."
msgstr "B<TEE> ターゲットは、 パケットのクローンを作成し、 クローンしたパケットをB<ローカル>ネットワークセグメントにある別のマシンにリダイレクトする。 言い換えると、ネクストホップがターゲットでなければならないということだ。 つまり、必要に応じてネクストホップがさらにパケットを転送するように設定する必要があるということだ。"

#. type: TP
#, no-wrap
msgid "B<--gateway> I<ipaddr>"
msgstr "B<--gateway> I<ipaddr>"

#. type: Plain text
msgid "Send the cloned packet to the host reachable at the given IP address.  Use of 0.0.0.0 (for IPv4 packets) or :: (IPv6) is invalid."
msgstr "クローンしたパケットを指定した IP アドレスで届くホストに送信する。 (IPv4 の場合) 0.0.0.0、 (IPv6 の場合) :: は無効である。"

#. type: Plain text
msgid "To forward all incoming traffic on eth0 to an Network Layer logging box:"
msgstr "eth0 に届いたすべての入力トラフィックをネットワーク層のロギングボックスに転送する。"

#. type: Plain text
msgid "-t mangle -A PREROUTING -i eth0 -j TEE --gateway 2001:db8::1"
msgstr "-t mangle -A PREROUTING -i eth0 -j TEE --gateway 2001:db8::1"

#. type: SS
#, no-wrap
msgid "TOS"
msgstr "TOS"

#. type: Plain text
msgid "This module sets the Type of Service field in the IPv4 header (including the \"precedence\" bits) or the Priority field in the IPv6 header. Note that TOS shares the same bits as DSCP and ECN. The TOS target is only valid in the B<mangle> table."
msgstr "このモジュールは IPv4 ヘッダーの Type of Service フィールド (上位ビットも含む) や IPv6 ヘッダーの Priority フィールドを設定する。 TOS は DSCP と ECN と同じビットを共有する点に注意すること。 TOS ターゲットは B<mangle> テーブルでのみ有効である。"

#. type: TP
#, no-wrap
msgid "B<--set-tos> I<value>[B</>I<mask>]"
msgstr "B<--set-tos> I<value>[B</>I<mask>]"

#. type: Plain text
msgid "Zeroes out the bits given by I<mask> (see NOTE below) and XORs I<value> into the TOS/Priority field. If I<mask> is omitted, 0xFF is assumed."
msgstr "I<mask> で指定されたビットを 0 にし (下の「注意」を参照)、 I<value> と TOS/Priority フィールド の XOR を取る。 I<mask> が省略された場合は 0xFF とみなされる。"

#. type: TP
#, no-wrap
msgid "B<--set-tos> I<symbol>"
msgstr "B<--set-tos> I<symbol>"

#. type: Plain text
msgid "You can specify a symbolic name when using the TOS target for IPv4. It implies a mask of 0xFF (see NOTE below). The list of recognized TOS names can be obtained by calling iptables with B<-j TOS -h>."
msgstr "IPv4 の TOS ターゲットを使用する際にはシンボル名を指定することができる。 暗黙のうち 0xFF が mask として使用される (下の「注意」を参照)。 使用できる TOS 名のリストは iptables を B<-j TOS -h> で呼び出すと取得できる。"

#. type: TP
#, no-wrap
msgid "B<--and-tos> I<bits>"
msgstr "B<--and-tos> I<bits>"

#. type: Plain text
msgid "Binary AND the TOS value with I<bits>. (Mnemonic for B<--set-tos 0/>I<invbits>, where I<invbits> is the binary negation of I<bits>.  See NOTE below.)"
msgstr "TOS 値と I<bits> のビット論理積 (AND) を取る (B<--set-tos 0/>I<invbits> の簡易表現、 I<invbits> は I<bits> のビット単位の否定である。 下の「注意」を参照)"

#. type: TP
#, no-wrap
msgid "B<--or-tos> I<bits>"
msgstr "B<--or-tos> I<bits>"

#. type: Plain text
msgid "Binary OR the TOS value with I<bits>. (Mnemonic for B<--set-tos> I<bits>B</>I<bits>. See NOTE below.)"
msgstr "TOS 値と I<bits> のビット論理和 (OR) を取る (B<--set-tos> I<bits>B</>I<bits> の簡易表現。下の「注意」を参照)"

#. type: TP
#, no-wrap
msgid "B<--xor-tos> I<bits>"
msgstr "B<--xor-tos> I<bits>"

#. type: Plain text
msgid "Binary XOR the TOS value with I<bits>. (Mnemonic for B<--set-tos> I<bits>B</0>. See NOTE below.)"
msgstr "TOS 値と I<bits> の XOR を取る (B<--set-tos> I<bits>B</0> の簡易表現。下の「注意」を参照)"

#. type: Plain text
msgid "NOTE: In Linux kernels up to and including 2.6.38, with the exception of longterm releases 2.6.32 (E<gt>=.42), 2.6.33 (E<gt>=.15), and 2.6.35 (E<gt>=.14), there is a bug whereby IPv6 TOS mangling does not behave as documented and differs from the IPv4 version. The TOS mask indicates the bits one wants to zero out, so it needs to be inverted before applying it to the original TOS field. However, the aformentioned kernels forgo the inversion which breaks --set-tos and its mnemonics."
msgstr "注意: 2.6.38 以前の Linux カーネル (ただし、長期間サポートのリリース 2.6.32 (E<gt>=.42), 2.6.33 (E<gt>=.15), 2.6.35 (E<gt>=.14) 以外) では、 IPv6 TOS mangling がドキュメントに書かれている通りに動作せず、IPv4 バージョンの場合と異なる動作をするというバグがある。 TOS mask はビットが 1 の場合に対応するビットが 0 にすることを指示するので、 元の TOS フィールドに mask を適用する前に反転する必要がある。 しかしながら、 上記のカーネルではこの反転が抜けており --set-tos と関連する簡易表現が正しく動作しない。"

#. type: SS
#, no-wrap
msgid "TPROXY"
msgstr "TPROXY"

#. type: Plain text
msgid "This target is only valid in the B<mangle> table, in the B<PREROUTING> chain and user-defined chains which are only called from this chain. It redirects the packet to a local socket without changing the packet header in any way. It can also change the mark value which can then be used in advanced routing rules.  It takes three options:"
msgstr "このターゲットは、 B<mangle> テーブルで、 B<PREROUTING> チェインと、 B<PREROUTING> チェインから呼び出される ユーザー定義チェインでのみ有効である。 このターゲットは、 そのパケットをパケットヘッダーを変更せずにそのままローカルソケットにリダイレクトする。 また、 mark 値を変更することもでき、 この mark 値は後で高度なルーティングルールで使用することができる。 このターゲットにはオプションが 3 つある:"

#. type: TP
#, no-wrap
msgid "B<--on-port> I<port>"
msgstr "B<--on-port> I<port>"

#. type: Plain text
msgid "This specifies a destination port to use. It is a required option, 0 means the new destination port is the same as the original. This is only valid if the rule also specifies B<-p tcp> or B<-p udp>."
msgstr "このオプションは使用する宛先ポートを指定する。 このオプションは必須で、 0 は宛先ポートが元々の宛先ポートと同じであることを意味する。 ルールが B<-p tcp> または B<-p udp> を指定している場合にのみ有効である。"

#. type: TP
#, no-wrap
msgid "B<--on-ip> I<address>"
msgstr "B<--on-ip> I<address>"

#. type: Plain text
msgid "This specifies a destination address to use. By default the address is the IP address of the incoming interface. This is only valid if the rule also specifies B<-p tcp> or B<-p udp>."
msgstr "このオプションは使用する宛先アドレスを指定する。 デフォルトでは、 パケットが到着したインタフェースの IP アドレスが使用される。 ルールが B<-p tcp> または B<-p udp> を指定している場合にのみ有効である。"

#. type: TP
#, no-wrap
msgid "B<--tproxy-mark> I<value>[B</>I<mask>]"
msgstr "B<--tproxy-mark> I<value>[B</>I<mask>]"

#. type: Plain text
msgid "Marks packets with the given value/mask. The fwmark value set here can be used by advanced routing. (Required for transparent proxying to work: otherwise these packets will get forwarded, which is probably not what you want.)"
msgstr ""

#. type: SS
#, no-wrap
msgid "TRACE"
msgstr "TRACE"

#. type: Plain text
msgid "This target marks packets so that the kernel will log every rule which match the packets as those traverse the tables, chains, rules. It can only be used in the B<raw> table."
msgstr ""

#. type: Plain text
msgid "With iptables-legacy, a logging backend, such as ip(6)t_LOG or nfnetlink_log, must be loaded for this to be visible.  The packets are logged with the string prefix: \"TRACE: tablename:chainname:type:rulenum \" where type can be \"rule\" for plain rule, \"return\" for implicit rule at the end of a user defined chain and \"policy\" for the policy of the built in chains."
msgstr ""

#. type: Plain text
msgid "With iptables-nft, the target is translated into nftables' B<meta nftrace> expression. Hence the kernel sends trace events via netlink to userspace where they may be displayed using B<xtables-monitor --trace> command. For details, refer to B<xtables-monitor>(8)."
msgstr ""

#. type: SS
#, no-wrap
msgid "TTL (IPv4-specific)"
msgstr "TTL (IPv4 の場合)"

#. type: Plain text
msgid "This is used to modify the IPv4 TTL header field.  The TTL field determines how many hops (routers) a packet can traverse until it's time to live is exceeded."
msgstr "このターゲットを使うと、 IPv4 の TTL ヘッダーフィールドを変更できる。 TTL フィールドにより、 TTL がなくなるまでに、パケットが何ホップ (何個のルータ) を通過できるかが決定される。"

#. type: Plain text
msgid "Setting or incrementing the TTL field can potentially be very dangerous, so it should be avoided at any cost. This target is only valid in B<mangle> table."
msgstr "TTL フィールドを設定したり増やすのは、 危険性を非常にはらんでいる。 したがって、可能な限り避けるべきである。 このターゲットは B<mangle> テーブルでのみ有効である。"

#. type: TP
#, no-wrap
msgid "B<--ttl-set> I<value>"
msgstr "B<--ttl-set> I<value>"

#. type: Plain text
msgid "Set the TTL value to `value'."
msgstr "TTL 値を `value' に設定する。"

#. type: TP
#, no-wrap
msgid "B<--ttl-dec> I<value>"
msgstr "B<--ttl-dec> I<value>"

#. type: Plain text
msgid "Decrement the TTL value `value' times."
msgstr "TTL 値を `value' 回減算する。"

#. type: TP
#, no-wrap
msgid "B<--ttl-inc> I<value>"
msgstr "B<--ttl-inc> I<value>"

#. type: Plain text
msgid "Increment the TTL value `value' times."
msgstr "TTL 値を `value' 回加算する。"

#. type: SS
#, no-wrap
msgid "ULOG (IPv4-specific)"
msgstr "ULOG (IPv4 の場合)"

#. type: Plain text
msgid "This is the deprecated ipv4-only predecessor of the NFLOG target.  It provides userspace logging of matching packets.  When this target is set for a rule, the Linux kernel will multicast this packet through a I<netlink> socket. One or more userspace processes may then subscribe to various multicast groups and receive the packets.  Like LOG, this is a \"non-terminating target\", i.e. rule traversal continues at the next rule."
msgstr "このターゲットは NFLOG ターゲットの前身で IPv4 専用である。現在は非推奨となっている。 マッチしたパケットを ユーザー空間でログ記録する機能を提供する。 このターゲットがルールに設定されると、 Linux カーネルは、 そのパケットを I<netlink> ソケットを用いてマルチキャストする。 そして、 1 つ以上のユーザー空間プロセスが いろいろなマルチキャストグループに登録をおこない、 パケットを受信する。 LOG と同様、 これは \"非終了ターゲット\" であり、 ルールの探索は次のルールへと継続される。"

#. type: TP
#, no-wrap
msgid "B<--ulog-nlgroup> I<nlgroup>"
msgstr "B<--ulog-nlgroup> I<nlgroup>"

#. type: Plain text
msgid "This specifies the netlink group (1-32) to which the packet is sent.  Default value is 1."
msgstr "パケットを送信する netlink グループ (1-32) を指定する。 デフォルトの値は 1 である。"

#. type: TP
#, no-wrap
msgid "B<--ulog-prefix> I<prefix>"
msgstr "B<--ulog-prefix> I<prefix>"

#. type: Plain text
msgid "Prefix log messages with the specified prefix; up to 32 characters long, and useful for distinguishing messages in the logs."
msgstr "指定したプレフィックスをログメッセージの前に付ける。 32 文字までの指定できる。 ログの中でメッセージを区別するのに便利である。"

#. type: TP
#, no-wrap
msgid "B<--ulog-cprange> I<size>"
msgstr "B<--ulog-cprange> I<size>"

#. type: Plain text
msgid "Number of bytes to be copied to userspace.  A value of 0 always copies the entire packet, regardless of its size.  Default is 0."
msgstr "ユーザー空間にコピーするパケットのバイト数。 値が 0 の場合、 サイズに関係なく全パケットをコピーする。 デフォルトは 0 である。"

#. type: TP
#, no-wrap
msgid "B<--ulog-qthreshold> I<size>"
msgstr "B<--ulog-qthreshold> I<size>"

#. type: Plain text
msgid "Number of packet to queue inside kernel.  Setting this value to, e.g. 10 accumulates ten packets inside the kernel and transmits them as one netlink multipart message to userspace.  Default is 1 (for backwards compatibility)."
msgstr "カーネル内部のキューに入れられるパケットの数。 例えば、 この値を 10 にした場合、 カーネル内部で 10 個のパケットをまとめ、 1 つの netlink マルチパートメッセージとしてユーザー空間に送る。 (過去のものとの互換性のため) デフォルトは 1 である。"

#~ msgid "Name of a bridge port via which a packet is going to be sent (for packets entering the B<FORWARD>, B<OUTPUT> and B<POSTROUTING> chains).  If the interface name ends in a \"+\", then any interface which begins with this name will match. Note that in the B<nat> and B<mangle> B<OUTPUT> chains one cannot match on the bridge output port, however one can in the B<filter OUTPUT> chain. If the packet won't leave by a bridge device or if it is yet unknown what the output device will be, then the packet won't match this option, unless '!' is used."
#~ msgstr "パケットを送信することになるブリッジのポート名 (B<FORWARD>, B<OUTPUT>, B<POSTROUTING> チェインに入るパケットのみ)。 インターフェース名が \"+\" で終っている場合、 その名前で始まる任意のインターフェース名にマッチする。 B<nat> と B<mangle> テーブルの B<OUTPUT> チェインではブリッジの出力ポートにマッチさせることができないが、 B<filter> テーブルの B<OUPUT> チェインではマッチ可能である。 パケットがブリッジデバイスから送られなかった場合、 またはパケットの出力デバイスが不明であった場合は、 \\&'!' が指定されていない限り、 パケットはこのオプションにマッチしない。"

#~ msgid "Match a given TCP MSS value or range."
#~ msgstr "指定された TCP MSS 値か範囲にマッチする。"

#~ msgid "unclean (IPv4-specific)"
#~ msgstr "unclean (IPv4 の場合)"

#~ msgid "This module takes no options, but attempts to match packets which seem malformed or unusual.  This is regarded as experimental."
#~ msgstr "このモジュールにはオプションがないが、 おかしく正常でないように見えるパケットにマッチする。 これは実験的なものとして扱われている。"

#~ msgid "Set type of audit record."
#~ msgstr "監査レコード種別を設定する。"

#~ msgid "iptables -A AUDIT_DROP -j AUDIT --type drop"
#~ msgstr "iptables -A AUDIT_DROP -j AUDIT --type drop"

#~ msgid "MIRROR (IPv4-specific)"
#~ msgstr "MIRROR (IPv4 の場合)"

#~ msgid "This is an experimental demonstration target which inverts the source and destination fields in the IP header and retransmits the packet.  It is only valid in the B<INPUT>, B<FORWARD> and B<PREROUTING> chains, and user-defined chains which are only called from those chains.  Note that the outgoing packets are B<NOT> seen by any packet filtering chains, connection tracking or NAT, to avoid loops and other problems."
#~ msgstr "実験的なデモンストレーション用のターゲットであり、 IP ヘッダーの送信元と宛先フィールドを入れ換え、 パケットを再送信するものである。 これは B<INPUT>, B<FORWARD>, B<PREROUTING> チェインと、 これらのチェインから呼び出される ユーザー定義チェインだけで有効である。 ループ等の問題を回避するため、 外部に送られるパケットは いかなるパケットフィルタリングチェイン・コネクション追跡・NAT からも 監視B<されない>。"

#~ msgid "SAME (IPv4-specific)"
#~ msgstr "SAME (IPv4 の場合)"

#~ msgid "B<--to> I<ipaddr>[B<->I<ipaddr>]"
#~ msgstr "B<--to> I<ipaddr>[B<->I<ipaddr>]"

#~ msgid "B<--nodst>"
#~ msgstr "B<--nodst>"
